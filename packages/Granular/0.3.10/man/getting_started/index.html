<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · Granular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Granular.jl logo"/></a><h1>Granular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../package_contents/">Package contents</a></li><li><a class="toctext" href="../methods/">Computational methods</a></li><li class="current"><a class="toctext" href>Getting started</a><ul class="internal"><li><a class="toctext" href="#Collision-between-two-particles-1">Collision between two particles</a></li><li><a class="toctext" href="#Sedimentation-of-grains-1">Sedimentation of grains</a></li></ul></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../lib/public/">Public API</a></li><li><a class="toctext" href="../../lib/internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Getting started</a></li></ul></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>In this section, it is assumed that <a href="https://julialang.org">Julia</a> and  <a href="https://github.com/anders-dc/Granular.jl">Granular.jl</a> have been successfully  installed.  If not, please consult the <a href="../installation/#Installation-1">Installation</a>  section of this manual.  If you are new to the <a href="https://julialang.org">Julia</a>  programming language, the official manual has a useful guide to <a href="https://docs.julialang.org/en/latest/manual/getting-started/">getting  started with  Julia</a>.</p><p>In the following, two simple examples are presented using some of the core  functionality of Granular.jl.  For more examples, see the scripts in the  <a href="https://github.com/anders-dc/Granular.jl/tree/master/examples">examples/</a>  directory.</p><p>The relevant functions are all contained in the <code>Granular</code> module, which can be  imported with <code>import Granular</code>.  <em>Note:</em> As per Julia conventions, functions  that contain an exclamation mark (!) modify the values of the arguments.</p><p>All of the functions called below are documented in the source code, and their  documentation can be found in the <a href="../../lib/public/#main-index-1">Public API Index</a> in the  online documentation, or simply from the Julia shell by typing <code>?&lt;function  name&gt;</code>.  An example:</p><pre><code class="language-julia-repl">julia&gt; ?Granular.createSimulation
  createSimulation([id])

  Create a simulation object to contain all relevant variables such as temporal 
  parameters, fluid grids, grains, and contacts. The parameter id is used to 
  uniquely identify the simulation when it is written to disk.

  The function returns a Simulation object, which you can add grains to, e.g. 
  with addGrainCylindrical!.

     Optional argument
    ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

    •    id::String=&quot;unnamed&quot;: simulation identifying string.</code></pre><p>You can go through the examples below by typing in the lines starting with  <code>julia&gt;</code> into the Julia interactive shell, which comes up when you start the  Julia app or run <code>julia</code> from the command line in a terminal.  Do not include  the <code>julia&gt;</code> part, just the remaining text of that line.</p><p>Alternatively, you can create a Julia script with the file name extension  <code>.jl</code>.  This file should contains all of the relevant commands in succession,  which is useful for quickly repeating runs.  Julia scripts can be evaluated  form the command line using <code>julia &lt;scriptname&gt;.jl</code>.</p><h2><a class="nav-anchor" id="Collision-between-two-particles-1" href="#Collision-between-two-particles-1">Collision between two particles</a></h2><p>For the first example (<code>examples/two-grains.jl</code>), we will create two grains and  make the first grain bump in to the second grain.</p><p>As the first step, we import all the Granular.jl functionality:</p><pre><code class="language-julia-repl">julia&gt; import Granular</code></pre><h3><a class="nav-anchor" id="Simulation-setup-1" href="#Simulation-setup-1">Simulation setup</a></h3><p>Next, we create our simulation object which holds all information related to  the simulated grains.  In this documentation, we will use the name <code>sim</code> for  the simulation object:</p><pre><code class="language-julia-repl">julia&gt; sim = Granular.createSimulation(id=&quot;two-grains&quot;)
Granular.Simulation(&quot;two-grains&quot;, 0, 0.0, -1.0, -1.0, -1.0, 0, 0.0, 
Granular.GrainCylindrical[], Granular.Ocean(false, [0.0], [0.0], [0.0], [0.0], 
[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], Array{Int64,1}[#undef], 1, 1, 
1, 1), Granular.Atmosphere(false, [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], 
[0.0], [0.0], Array{Int64,1}[#undef], 1, 1, 1, 1, false), 16)</code></pre><p>After creating the simulation object <code>sim</code>, we will be presented with some  output about the default contents of the <code>sim</code> simulation object.  This is of  minor importance as of now, and can safely be ignored.</p><p>In the above <code>createSimulation</code> call, the <code>id</code> argument is optional. It is used  to name simulation output files that are written to the disk.</p><h3><a class="nav-anchor" id="Adding-grains-one-by-one-1" href="#Adding-grains-one-by-one-1">Adding grains one by one</a></h3><p>We have now created a simulation object <code>sim</code>, which will be used during all of  the following commands.  Next, we can add grains to this object.  The first  grain is cylinder shaped, placed at the x-y position (0,0) m.  It has a radius  of 0.1 m, and has a thickness of 0.05 m.  As this call modifies the <code>sim</code>  object, the function contains an exclamation mark (!).  For further information  regarding this call, see the reference to <a href="../../lib/public/#Granular.addGrainCylindrical!-Tuple{Granular.Simulation,Array{Float64,1},Float64,Float64}"><code>addGrainCylindrical!</code></a>, found  in the <a href="../../lib/public/#Public-API-documentation-1">Public API documentation</a>.</p><pre><code class="language-julia-repl">julia&gt; Granular.addGrainCylindrical!(sim, [0.0, 0.0], 0.1, 0.05)
INFO: Added Grain 1</code></pre><p>Let&#39;s add another grain, placed at some distance from the first grain:</p><pre><code class="language-julia-repl">julia&gt; Granular.addGrainCylindrical!(sim, [0.5, 0.0], 0.1, 0.05)
INFO: Added Grain 2</code></pre><p>We now want to prescribe a linear (not rotational or angular) velocity to the  first grain to make it bump into the second grain.</p><p>The simulation object <code>sim</code> contains an array of all grains that are added to  it.  We can directly inspect the grains and their values from the simulation  object.  Let&#39;s take a look at the default value of the linear velocity, called  <code>lin_vel</code>:</p><pre><code class="language-julia-repl">julia&gt; sim.grains[1].lin_vel
2-element Array{Float64, 1}:
 0.0
 0.0</code></pre><p>The default value is a (0,0) vector, which means that it is not moving in  space.  With a similar call, we can modify the properties of the first grain  directly and prescribe a velocity to it:</p><pre><code class="language-julia-repl">julia&gt; sim.grains[1].lin_vel = [1.0, 0.0]
2-element Array{Float64, 1}:
 1.0
 0.0</code></pre><p>The first grain (index 1 in <code>sim.grains</code>) now has a positive velocity along <code>x</code>  with the value of 1.0 meter per second.</p><h3><a class="nav-anchor" id="Setting-temporal-parameters-for-the-simulation-1" href="#Setting-temporal-parameters-for-the-simulation-1">Setting temporal parameters for the simulation</a></h3><p>Before we can start the simulation we need to set some more parameters vital to  the simulation, like what time step to use, how often to write output files to  the disk, and for how long to run the simulation.  To set the computational  time step, we call the following:</p><pre><code class="language-julia-repl">julia&gt; Granular.setTimeStep!(sim)
INFO: Time step length t=8.478741928617433e-5 s</code></pre><p>A suitable time step is automatically determined based on the size and elastic  properties of the grain.</p><p>The two grains are 0.3 meters apart, as the centers are placed 0.5 meter from  each other and each grain has a radius of 0.1 m.  With a linear velocity of 1.0  m/s, the collision should occur after 0.3 seconds.  For that reason it seems  reasonable to run the simulation for a total of 1.0 seconds.  We choose to  produce an output file every 0.05 seconds, but this can be tweaked to taste.   We will later use the produced output files for visualization purposes.</p><pre><code class="language-julia-repl">julia&gt; Granular.setOutputFileInterval!(sim, 0.05)

julia&gt; Granular.setTotalTime!(sim, 1.0)</code></pre><h3><a class="nav-anchor" id="Running-the-simulation-1" href="#Running-the-simulation-1">Running the simulation</a></h3><p>We are now ready to run the simulation.  For illustrative purposes, let us  compare the kinetic energy in the granular system before and after the  collision.  For now, we compute the initial value using the following call:</p><pre><code class="language-julia-repl">julia&gt; Granular.totalGrainKineticTranslationalEnergy(sim)
0.7335618846132168</code></pre><p>The above value is the total translational (not angular) kinetic energy in  Joules before the simulation is started.</p><p>We have two choices for running the simulation; we can either run the entire  simulation length with a single call, which steps time until the total time is  reached and generates output files along the way.  Alternatively, we can run  the simulation for a single time step a time, and inspect the progress or do  other modifications along the way.</p><p>Here, we will run the entire simulation in one go, and afterwards visualize the  grains from their output files using ParaView.</p><pre><code class="language-julia-repl">julia&gt; Granular.run!(sim)

INFO: Output file: ./two-grains/two-grains.grains.1.vtu
INFO: wrote status to ./two-grains/two-grains.status.txt
  t = 0.04239370964308682/1.0 s
INFO: Output file: ./two-grains/two-grains.grains.2.vtu
INFO: wrote status to ./two-grains/two-grains.status.txt

...

INFO: Output file: ./two-grains/two-grains.grains.20.vtu
INFO: wrote status to ./two-grains/two-grains.status.txt
  t = 0.9920128056483803/1.0 s
INFO: ./two-grains/two-grains.py written, execute with &#39;pvpython /Users/ad/code/Granular-ext/two-grains/two-grains.py&#39;
INFO: wrote status to ./two-grains/two-grains.status.txt
  t = 1.0000676104805686/1.0 s</code></pre><p>The code informs us of the simulation progress along the way.  It also and  notifies us as output files are generated.  This output can be disabled by  passing <code>verbose=false</code> to the <code>run!()</code> command.  Finally, the code tells us  that it has generated a ParaView python file for visualization, called  <code>two-grains.py</code>, located in the <code>two-grains/</code> directory.</p><p>We are interested in getting an immediate idea of how the collision went,  before going further.  We can print the new velocities with the following  commands:</p><pre><code class="language-julia-repl">julia&gt; sim.grains[1].lin_vel
2-element Array{Float64, 1}:
 7.58343e-5
 0.0

julia&gt; sim.grains[2].lin_vel
2-element Array{Float64, 1}:
 0.999924
 0.0</code></pre><p>The first grain has transferred effectively all of its kinetic energy to the  second grain during the cause of the simulation.  The total kinetic energy now  is the following:</p><pre><code class="language-julia-repl">julia&gt; Granular.totalGrainKineticTranslationalEnergy(sim)
0.7334506347624973</code></pre><p>The before and after values for total kinetic energy are reasonably close (to  less than 0.1 percent), which is what can be expected given the computation  accuracy of the algorithm.</p><h3><a class="nav-anchor" id="Visualizing-the-output-1" href="#Visualizing-the-output-1">Visualizing the output</a></h3><p>To visualize the output we open <a href="https://www.paraview.org">ParaView</a>.  The  output files of the simulation are written using the VTK (visualization  toolkit) format, which is natively supported by ParaView.</p><p>While the <code>.vtu</code> files produced during the simulation can be opened with  ParaView and visualized manually using <em>Glyph</em> filters, the simplest and  fastest way to visualize the data is to use the Python script generated for the  simulation by Granular.jl.</p><p>Open ParaView and open the <em>Python Shell</em>, found under the menu <em>Tools &gt; Python  Shell</em>.  In the pop-up dialog we select <em>Run Script</em>, which opens yet another  dialog prompting us to locate the visualization script  (<code>two-grains/two-grains.py</code> in our example).  We locate this file, which is  placed under the directory from where we launched the <code>julia</code> session with the  commands above.  If you are not sure what the current working directory for the  Julia session is, it can be displayed with the command <code>pwd()</code> in the Julia  shell.</p><p>After selecting the <code>two-grains/two-grains.py</code> script, we can close the <em>Python  Shell</em> window to inspect our simulation visually.  Press the <em>Play</em> symbol in  the top toolbar, and see what happens.</p><p>By default, the grains are colored according to their size.  Alternatively, you  can color the grains using different parameters, such as linear velocity,  number of contacts, etc.  These parameters can be selected by changing the  chosen field under the <em>Glyph1</em> object in the <em>Pipeline Browser</em> on the left,  and by selecting a parameter for <em>Coloring</em>.  Press the <em>Apply</em> button at the  top of  the panel on the left to see the changes in effect.</p><p><strong>Tip:</strong> If you have the command <code>pvpython</code> (ParaView Python) is available from  the command line, you can visualize the simulation directly from the Julia  shell without entering ParaView by the command <code>Granular.render(sim)</code>.  The  program <code>pvpython</code> is included in the ParaView download, and is in the macOS  application bundle located in  <code>/Applications/Paraview-5.4.0.app/Contents/bin/pvpython</code>.  Furthermore, if you  have the <code>convert</code> command from ImageMagick installed (<code>brew install  imagemagick</code> on macOS), the output images will be merged into an animated GIF.</p><h3><a class="nav-anchor" id="Exercises-1" href="#Exercises-1">Exercises</a></h3><p>To gain more familiarity with the simulation procedure, I suggest experimenting  with the following exercises.  <em>Tip:</em> You can rerun an experiment after  changing one or more parameters by calling <code>Granular.resetTime!(sim);  Granular.run!(sim)</code>.  Changes in grain size, grain mass, or elastic properties  require a recomputation of the numerical time step  (<code>Granular.setTimeStep!(sim)</code>) before calling <code>Granular.run!(sim)</code>.  The output  files will be overwritten, and changes will be immediately available in  ParaView.</p><ul><li>What effect does the grain size have on the time step?</li><li>Try to make an oblique collision by placing one of the grains at a different    <code>y</code> position.</li><li>What happens if the second grain is set to be fixed in space    (<code>sim.grains[2].fixed = true</code>)?</li><li>How is the relationship between total kinetic energy before and after    affected by the choice of time step length?  Try setting different time    step values, e.g. with <code>sim.time_step = 0.1234</code> and rerun the simulation.</li></ul><h2><a class="nav-anchor" id="Sedimentation-of-grains-1" href="#Sedimentation-of-grains-1">Sedimentation of grains</a></h2><p>Grains are known to settle under gravitation in water according to <em>Stoke&#39;s  law</em>, where resistive drag acts opposite of gravity and with a magnitude  according to the square root of velocity difference between water and grain. Granular.jl offers simple fluid grids with prescribed velocity fields, and the  grains are met with drag in this grid.</p><p>In this example (<code>examples/sedimentation.jl</code>) we will initialize grains with a  range of grain sizes in a loose configuration, add gravity and a surrounding  fluid grid, and let the grains settle towards the bottom.</p><p>As in the previous example, we start by creating a fluid grid:</p><pre><code class="language-julia-repl">julia&gt; import Granular
julia&gt; sim = Granular.createSimulation(id=&quot;sedimentation&quot;)</code></pre><h3><a class="nav-anchor" id="Creating-a-pseudo-random-grain-packing-1" href="#Creating-a-pseudo-random-grain-packing-1">Creating a pseudo-random grain packing</a></h3><p>Instead of manually adding grains one by one, we can use the  <code>regularPacking!()</code> function to add a regular grid of random-sized grains to  the simulation.  Below, we specify that we want the grid of grains to be 7  grains wide along x, and 25 grains tall along y.  We also specify the grain  radii to fall between 0.02 and 0.2 m.  The sizes will be drawn from a power-law  distribution by default.</p><pre><code class="language-julia-repl">julia&gt; Granular.regularPacking!(sim, [7, 25], 0.02, 0.2)</code></pre><p>Since we haven&#39;t explicitly set the grain sizes for this example, we can  inspect the values by plotting a histogram of sizes (only works if the <code>PyPlot</code>  package is installed with <code>Pkg.add(&quot;PyPlot&quot;)</code>):</p><pre><code class="language-julia-repl">julia&gt; Granular.plotGrainSizeDistribution(sim)
INFO: sedimentation-grain-size-distribution.png</code></pre><p>The output informs us that we have the plot saved as an image with the file  name <code>sedimentation-grain-size-distribution.png</code>.</p><h3><a class="nav-anchor" id="Creating-a-fluid-grid-1" href="#Creating-a-fluid-grid-1">Creating a fluid grid</a></h3><p>We can now create a fluid (ocean) grid spanning the extent of the grains  created above:</p><pre><code class="language-julia-repl">julia&gt; Granular.fitGridToGrains!(sim, sim.ocean)
INFO: Created regular Granular.Ocean grid from [0.06382302477946442, 
0.03387419706945263] to [3.0386621000253293, 10.87955941983313] with a cell 
size of 0.3862075959573571 ([7, 28]).</code></pre><p>The code informs us of the number of grid cells in each dimension (7 by 28  cells), and the edge positions (x = 0.0638 to 3.04 m, y = 0.0339 to 10.9 m).</p><p>We want the boundaries of the above grid to be impermeable for the grains, so  they stack up at the bottom.  Granular.jl acknowledges the boundary types with  a confirmation message:</p><pre><code class="language-julia-repl">julia&gt; Granular.setGridBoundaryConditions!(sim.ocean, &quot;impermeable&quot;)
West  (-x): impermeable (3)
East  (+x): impermeable (3)
South (-y): impermeable (3)
North (+y): impermeable (3)</code></pre><h3><a class="nav-anchor" id="Adding-gravitational-acceleration-1" href="#Adding-gravitational-acceleration-1">Adding gravitational acceleration</a></h3><p>If we start the simulation now nothing would happen as gravity is disabled by  default.  We can enable gravitational acceleration as a constant body force for  each grain (<code>Force = mass * acceleration</code>):</p><pre><code class="language-julia-repl">julia&gt; g = [0.0, -9.8];
julia&gt; for grain in sim.grains
       Granular.addBodyForce!(grain, grain.mass*g)
       end</code></pre><h3><a class="nav-anchor" id="Setting-temporal-parameters-1" href="#Setting-temporal-parameters-1">Setting temporal parameters</a></h3><p>As before, we ask the code to select a suitable computational time step based  on grain sizes and properties:</p><pre><code class="language-julia-repl">julia&gt; Granular.setTimeStep!(sim)
INFO: Time step length t=1.6995699879716792e-5 s</code></pre><p>We also, as before, set the total simulation time as well as the output file  interval:</p><pre><code class="language-julia-repl">julia&gt; Granular.setTotalTime!(sim, 10.0)
julia&gt; Granular.setOutputFileInterval!(sim, 0.2)</code></pre><h3><a class="nav-anchor" id="Running-the-simulation-2" href="#Running-the-simulation-2">Running the simulation</a></h3><p>We are now ready to run the simulation:</p><pre><code class="language-julia-repl">julia&gt; Granular.run!(sim)
INFO: Output file: ./sedimentation/sedimentation.grains.1.vtu
INFO: Output file: ./sedimentation/sedimentation.ocean.1.vts
INFO: wrote status to ./sedimentation/sedimentation.status.txt
  t = 0.19884968859273294/10.0 s
INFO: Output file: ./sedimentation/sedimentation.grains.2.vtu
INFO: Output file: ./sedimentation/sedimentation.ocean.2.vts
INFO: wrote status to ./sedimentation/sedimentation.status.txt
  t = 0.3993989471735396/10.0 s

...

INFO: Output file: ./sedimentation/sedimentation.grains.50.vtu
INFO: Output file: ./sedimentation/sedimentation.ocean.50.vts
INFO: wrote status to ./sedimentation/sedimentation.status.txt
  t = 9.998435334626701/10.0 s
INFO: ./sedimentation/sedimentation.py written, execute with &#39;pvpython /Users/ad/code/Granular-ext/examples/sedimentation/sedimentation.py&#39;
INFO: wrote status to ./sedimentation/sedimentation.status.txt
  t = 10.00001593471549/10.0 s</code></pre><p>The output can be plotted in ParaView as described in the <code>two-grain</code> example  above, or, if <code>pvpython</code> is available from the command line, directly from  Julia with the following command:</p><pre><code class="language-julia-repl">julia&gt; Granular.render(sim, trim=false)</code></pre><h3><a class="nav-anchor" id="Exercises-2" href="#Exercises-2">Exercises</a></h3><ul><li>How are the granular contact pressures distributed in the final result?  You    can visualize this by selecting &quot;Contact Pressure [Pa]&quot; in the <em>Coloring</em>    field inside ParaView.</li><li>Try running the above example, but without fluid drag.  Disable the drag by    including the call <code>Granlar.disableOceanDrag!(grain)</code> in the <code>for</code> loop    where gravitational acceleration is set for each grain.</li><li>How does the range of grain sizes affect the result?  Try making all grains    bigger or smaller.</li><li>How is the model performance effected if the grain-size distribution is    wide or narrow?</li><li>Create a landslide by turning the gravitational acceleration vector (set the    <code>y</code> component to a non-zero value, and setting the side boundaries to be    periodic with <code>Granular.setGridBoundaryConditions!(sim.ocean, &quot;periodic&quot;,    &quot;east west&quot;)</code>.</li></ul><footer><hr/><a class="previous" href="../methods/"><span class="direction">Previous</span><span class="title">Computational methods</span></a><a class="next" href="../../lib/public/"><span class="direction">Next</span><span class="title">Public API</span></a></footer></article></body></html>
