<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/joins/">Joins</a></li><li><a class="toctext" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="toctext" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="toctext" href="../../man/sorting/">Sorting</a></li><li><a class="toctext" href="../../man/categorical/">Categorical Data</a></li><li><a class="toctext" href="../../man/missing/">Missing Data</a></li><li><a class="toctext" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../types/">Types</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li><li><a class="toctext" href="../indexing/">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Functions</a></li></ul></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.eachcol"><code>Base.eachcol</code></a></li><li><a href="#Base.eachrow"><code>Base.eachrow</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.join"><code>Base.join</code></a></li><li><a href="#Base.map"><code>Base.map</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="#DataFrames.colwise"><code>DataFrames.colwise</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.deletecols!"><code>DataFrames.deletecols!</code></a></li><li><a href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.eltypes"><code>DataFrames.eltypes</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.melt"><code>DataFrames.melt</code></a></li><li><a href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a></li><li><a href="#DataFrames.names!"><code>DataFrames.names!</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#StatsBase.describe"><code>StatsBase.describe</code></a></li></ul><h2><a class="nav-anchor" id="Grouping,-Joining,-and-Split-Apply-Combine-1" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.aggregate" href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine that applies a set of functions over columns of an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">aggregate(d::AbstractDataFrame, cols, fs)
aggregate(gd::GroupedDataFrame, fs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>gd</code> : a GroupedDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Statistics
df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
aggregate(df, :a, sum)
aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.by" href="#DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">by(d::AbstractDataFrame, keys, cols =&gt; f...; sort::Bool = false)
by(d::AbstractDataFrame, keys; (colname = cols =&gt; f)..., sort::Bool = false)
by(d::AbstractDataFrame, keys, f; sort::Bool = false)
by(f, d::AbstractDataFrame, keys; sort::Bool = false)</code></pre><p>Split-apply-combine in one step: apply <code>f</code> to each grouping in <code>d</code> based on grouping columns <code>keys</code>, and return a <code>DataFrame</code>.</p><p><code>keys</code> can be either a single column index, or a vector thereof.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted on <code>keys</code> if <code>sort=true</code>. Otherwise, ordering of rows is undefined.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(f, groupby(d, cols))</code> and to the less efficient <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; by(df, :a, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, d -&gt; sum(d.c)) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, :c =&gt; x -&gt; 2 .* x)
8×2 DataFrame
│ Row │ a     │ c_function │
│     │ Int64 │ Int64      │
├─────┼───────┼────────────┤
│ 1   │ 1     │ 2          │
│ 2   │ 1     │ 10         │
│ 3   │ 2     │ 4          │
│ 4   │ 2     │ 12         │
│ 5   │ 3     │ 6          │
│ 6   │ 3     │ 14         │
│ 7   │ 4     │ 8          │
│ 8   │ 4     │ 16         │

julia&gt; by(df, :a, c_sum = :c =&gt; sum, c_sum2 = :c =&gt; x -&gt; sum(x.^2))
4×3 DataFrame
│ Row │ a     │ c_sum │ c_sum2 │
│     │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 6     │ 26     │
│ 2   │ 2     │ 8     │ 40     │
│ 3   │ 3     │ 10    │ 58     │
│ 4   │ 4     │ 12    │ 80     │

julia&gt; by(df, :a, (:b, :c) =&gt; x -&gt; (minb = minimum(x.b), sumc = sum(x.c)))
4×3 DataFrame
│ Row │ a     │ minb  │ sumc  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 2     │ 1     │ 8     │
│ 3   │ 3     │ 2     │ 10    │
│ 4   │ 4     │ 1     │ 12    │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.colwise" href="#DataFrames.colwise"><code>DataFrames.colwise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply a function to each column in an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">colwise(f, d)</code></pre><p><strong>Arguments</strong></p><ul><li><code>f</code> : a function or vector of functions</li><li><code>d</code> : an AbstractDataFrame of GroupedDataFrame</li></ul><p><strong>Returns</strong></p><ul><li>various, depending on the call</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
colwise(sum, df)
colwise([sum, length], df)
colwise((minimum, maximum), df)
colwise(sum, groupby(df, :a))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine(gd::GroupedDataFrame, cols =&gt; f...)
combine(gd::GroupedDataFrame; (colname = cols =&gt; f)...)
combine(gd::GroupedDataFrame, f)
combine(f, gd::GroupedDataFrame)</code></pre><p>Transform a <code>GroupedDataFrame</code> into a <code>DataFrame</code>.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted if <code>sort=true</code> was passed to the <a href="#DataFrames.groupby"><code>groupby</code></a> call from which <code>gd</code> was constructed. Otherwise, ordering of rows is undefined.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(:c =&gt; sum, gd)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(df -&gt; sum(df.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><a href="#DataFrames.by"><code>by(f, df, cols)</code></a> is a shorthand for <code>combine(f, groupby(df, cols))</code>.</p><p><a href="#Base.map"><code>map</code></a>: <code>combine(f, groupby(df, cols))</code> is a more efficient equivalent of <code>combine(map(f, groupby(df, cols)))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A view of an AbstractDataFrame split into row groups</p><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)
groupby(cols; sort = false, skipmissing = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame to split (optional, see <a href="#returns">Returns</a>)</li><li><code>cols</code> : data table columns to group by</li><li><code>sort</code>: whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code>: whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Returns</strong></p><p>A <code>GroupedDataFrame</code> : a grouped view into <code>d</code></p><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>d</code>. A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p>See the following for additional split-apply-combine operations:</p><ul><li><code>by</code> : split-apply-combine using functions</li><li><code>aggregate</code> : split-apply-combine; applies functions in the form of a cross product</li><li><code>colwise</code> : apply a function to each column in an <code>AbstractDataFrame</code> or <code>GroupedDataFrame</code></li><li><code>map</code> : apply a function to each group of a <code>GroupedDataFrame</code> (without combining)</li><li><code>combine</code> : combine a <code>GroupedDataFrame</code>, optionally applying a function to each group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
gd = groupby(df, :a)
gd[1]
last(gd)
vcat([g[:b] for g in gd]...)
for g in gd
    println(g)
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <code>GroupedDataFrame</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupvars" href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupvars(gd::GroupedDataFrame)</code></pre><p>Return a vector of column names in <code>parent(gd)</code> used for grouping.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))</code></pre><p>Join two <code>DataFrame</code> objects</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code> : the two AbstractDataFrames to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be <code>(left, right)</code> tuples or <code>left =&gt; right</code> pairs, or a vector of   such tuples or pairs. <code>on</code> is a required argument for all joins except for   <code>kind = :cross</code></p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul></li></ul><ul><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code></p><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the joined DataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
join(name, job2, on = (:ID, :identifier))
join(name, job2, on = :ID =&gt; :identifier)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map(cols =&gt; f, gd::GroupedDataFrame)
map(f, gd::GroupedDataFrame)</code></pre><p>Apply a function to each group of rows and return a <code>GroupedDataFrame</code>.</p><p>If the first argument is a <code>cols =&gt; f</code> pair, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If a named tuple, field names are used to name each generated column.</p><p>If the first argument is a callable, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting <code>GroupedDataFrame</code> contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; map(:c =&gt; sum, gd)
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │

julia&gt; map(df -&gt; sum(df.c), gd) # Slower variant
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><code>combine(f, gd)</code> returns a <code>DataFrame</code> rather than a <code>GroupedDataFrame</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.melt" href="#DataFrames.melt"><code>DataFrames.melt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format; see <code>stack</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format</p><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value)
melt(df::AbstractDataFrame, [id_vars], [measure_vars];
     variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be stacked</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code>. If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li><li><p><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></p></li><li><p><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>See also <code>stackdf</code> and <code>meltdf</code> for stacking methods that return a view into the original DataFrame. See <code>unstack</code> for converting from long to wide format.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = melt(d1, [:a, :b, :e])
d1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unstacks a DataFrame; convert from a long to wide format</p><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Symbol, Integer},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Symbol, Integer}},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, colkey::Union{Symbol, Integer},
        value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be unstacked</p></li><li><p><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></p></li><li><p><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></p></li><li><p><code>value</code> : the value column, defaults to <code>:value</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the wide-format DataFrame</li></ul><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)</code></pre><p>Note that there are some differences between the widened results above.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stackdf" href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format)</p><p>Like <code>stack</code> and <code>melt</code>, but a view is returned rather than data copies.</p><pre><code class="language-julia">stackdf(df::AbstractDataFrame, [measure_vars], [id_vars];
        variable_name::Symbol=:variable, value_name::Symbol=:value)
meltdf(df::AbstractDataFrame, [id_vars], [measure_vars];
       variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the wide AbstractDataFrame</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code></p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>The result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stackdf(d1, [:c, :d])
d1s2 = stackdf(d1, [:c, :d], [:a])
d1m = meltdf(d1, [:a, :b, :e])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.meltdf" href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format); see <code>stackdf</code></p></div></div></section><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">completecases(df::AbstractDataFrame)
completecases(df::AbstractDataFrame, cols::AbstractVector)
completecases(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; completecases(df)
5-element BitArray{1}:
 false
 false
 false
  true
  true

julia&gt; completecases(df, :x)
5-element BitArray{1}:
 false
  true
 false
  true
  true

julia&gt; completecases(df, [:x, :y])
5-element BitArray{1}:
 false
 false
 false
  true
  true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.deletecols!" href="#DataFrames.deletecols!"><code>DataFrames.deletecols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deletecols!(df::DataFrame, ind)</code></pre><p>Delete columns specified by <code>ind</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Argument <code>ind</code> can be any index that is allowed for column indexing of a <code>DataFrame</code> provided that the columns requested to be removed are unique.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; deletecols!(d, 1)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.deleterows!" href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deleterows!(df::DataFrame, ind)</code></pre><p>Delete rows specified by <code>ind</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>ind</code> must be: a vector of sorted and unique integers, a boolean vector or an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; deleterows!(d, 2)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 3     │ 6     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.describe" href="#StatsBase.describe"><code>StatsBase.describe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Report descriptive statistics for a data frame</p><pre><code class="language-julia">describe(df::AbstractDataFrame; stats = [:mean, :min, :median, :max, :nmissing, :nunique, :eltype])</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>stats::Union{Symbol,AbstractVector{Symbol}}</code> : the summary statistics to report. If a vector, allowed fields are <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. If set to <code>:all</code>, all summary statistics are reported.</li></ul><p><strong>Result</strong></p><ul><li>A <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable. If the column does not allow missing values, <code>nothing</code> is returned. Consequently, <code>nmissing = 0</code> indicates that the column allows missing values, but does not currently contain any.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
describe(df)
describe(df, stats = :all)
describe(df, stats = [:min, :max])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disallowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing(df::AbstractDataFrame; disallowmissing::Bool=false)
dropmissing(df::AbstractDataFrame, cols::AbstractVector; disallowmissing::Bool=false)
dropmissing(df::AbstractDataFrame, cols::Union{Integer, Symbol}; disallowmissing::Bool=false)</code></pre><p>Return a copy of data frame <code>df</code> excluding rows with missing values. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>In the future <code>disallowmissing</code> will be <code>true</code> by default.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing(df)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, disallowmissing=true)
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing(df, :x)
3×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 2     │ 4      │ missing │
│ 2   │ 4     │ 2      │ d       │
│ 3   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing!(df::AbstractDataFrame; disallowmissing::Bool=false)
dropmissing!(df::AbstractDataFrame, cols::AbstractVector; disallowmissing::Bool=false)
dropmissing!(df::AbstractDataFrame, cols::Union{Integer, Symbol}; disallowmissing::Bool=false)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>In the future <code>disallowmissing</code> will be <code>true</code> by default.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; df1 = copy(df);

julia&gt; dropmissing!(df1);

julia&gt; df1
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing!(df1, disallowmissing=true);
 julia&gt; df1
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; df2 = copy(df);

julia&gt; dropmissing!(df2, :x);

julia&gt; df2
3×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 2     │ 4      │ missing │
│ 2   │ 4     │ 2      │ d       │
│ 3   │ 5     │ 1      │ e       │

julia&gt; df3 = copy(df);

julia&gt; dropmissing!(df3, [:x, :y]);


julia&gt; df3
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; eachrow(df)
4-element DataFrameRows:
 DataFrameRow (row 1)
x  1
y  11
 DataFrameRow (row 2)
x  2
y  12
 DataFrameRow (row 3)
x  3
y  13
 DataFrameRow (row 4)
x  4
y  14

julia&gt; copy.(eachrow(df))
4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4,3], [2,1]))
2-element DataFrameRows:
 DataFrameRow (row 4)
y  14
x  4
 DataFrameRow (row 3)
y  13
x  3</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachcol" href="#Base.eachcol"><code>Base.eachcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachcol(df::AbstractDataFrame, names::Bool=true)</code></pre><p>Return a <code>DataFrameColumns</code> that iterates an <code>AbstractDataFrame</code> column by column. If <code>names</code> is equal to <code>true</code> (currently the default, in the future the default will be set to <code>false</code>) iteration returns a pair consisting of column name and column vector. If <code>names</code> is equal to <code>false</code> then column vectors are yielded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; collect(eachcol(df, true))
2-element Array{Pair{Symbol,AbstractArray{T,1} where T},1}:
 :x =&gt; [1, 2, 3, 4]
 :y =&gt; [11, 12, 13, 14]

julia&gt; collect(eachcol(df, false))
2-element Array{AbstractArray{T,1} where T,1}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; sum.(eachcol(df, false))
2-element Array{Int64,1}:
 10
 50

julia&gt; map(eachcol(df, false)) do col
           maximum(col) - minimum(col)
       end
2-element Array{Int64,1}:
 3
 3</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.eltypes" href="#DataFrames.eltypes"><code>DataFrames.eltypes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return element types of columns</p><pre><code class="language-julia">eltypes(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Type}</code> : the element type of each column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
eltypes(df)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter(function, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>function</code> returns <code>true</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row[:x] &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter!(function, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>function</code> returns <code>false</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row[:x] &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Insert a column into a data frame in place.</p><pre><code class="language-julia">insertcols!(df::DataFrame, ind::Int; name=col,
            makeunique::Bool=false)
insertcols!(df::DataFrame, ind::Int, (:name =&gt; col)::Pair{Symbol,&lt;:AbstractVector};
            makeunique::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the DataFrame to which we want to add a column</p></li><li><p><code>ind</code> : a position at which we want to insert a column</p></li><li><p><code>name</code> : the name of the new column</p></li><li><p><code>col</code> : an <code>AbstractVector</code> giving the contents of the new column</p></li><li><p><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : a <code>DataFrame</code> with added column.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; insertcols!(d, 1, b=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
3×2 DataFrame
│ Row │ b    │ a     │
│     │ Char │ Int64 │
├─────┼──────┼───────┤
│ 1   │ &#39;a&#39;  │ 1     │
│ 2   │ &#39;b&#39;  │ 2     │
│ 3   │ &#39;c&#39;  │ 3     │

julia&gt; insertcols!(d, 1, :c =&gt; [2, 3, 4])
3×3 DataFrame
│ Row │ c     │ b    │ a     │
│     │ Int64 │ Char │ Int64 │
├─────┼───────┼──────┼───────┤
│ 1   │ 2     │ &#39;a&#39;  │ 1     │
│ 2   │ 3     │ &#39;b&#39;  │ 2     │
│ 3   │ 4     │ &#39;c&#39;  │ 3     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapcols(f::Union{Function,Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.names!" href="#DataFrames.names!"><code>DataFrames.names!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set column names</p><pre><code class="language-julia">names!(df::AbstractDataFrame, vals)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>vals</code> : column names, normally a Vector{Symbol} the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
names!(df, [:a, :b, :c])
names!(df, [:a, :b, :a])  # throws ArgumentError
names!(df, [:a, :b, :a], makeunique=true)  # renames second :a to :a_1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Indexes of duplicate rows (a row that is a duplicate of a prior row)</p><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Bool}</code> : indicates whether the row is a duplicate of some prior row</li></ul><p>See also <a href="lib/@ref"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div></div><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Delete duplicate rows</p><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated version of <code>df</code> with unique rows.</li></ul><p>When <code>cols</code> is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.permutecols!" href="#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutecols!(df::DataFrame, p::AbstractVector)</code></pre><p>Permute the columns of <code>df</code> in-place, according to permutation <code>p</code>. Elements of <code>p</code> may be either column indices (<code>Int</code>) or names (<code>Symbol</code>), but cannot be a combination of both. All columns must be listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a=1:5, b=2:6, c=3:7)
5×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │
│ 2   │ 2     │ 3     │ 4     │
│ 3   │ 3     │ 4     │ 5     │
│ 4   │ 4     │ 5     │ 6     │
│ 5   │ 5     │ 6     │ 7     │

julia&gt; permutecols!(df, [2, 1, 3]);

julia&gt; df
5×3 DataFrame
│ Row │ b     │ a     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 3     │ 2     │ 4     │
│ 3   │ 4     │ 3     │ 5     │
│ 4   │ 5     │ 4     │ 6     │
│ 5   │ 6     │ 5     │ 7     │

julia&gt; permutecols!(df, [:c, :a, :b]);

julia&gt; df
5×3 DataFrame
│ Row │ c     │ a     │ b     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 1     │ 2     │
│ 2   │ 4     │ 2     │ 3     │
│ 3   │ 5     │ 3     │ 4     │
│ 4   │ 6     │ 4     │ 5     │
│ 5   │ 7     │ 5     │ 6     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vcat(dfs::AbstractDataFrame...)</code></pre><p>Vertically concatenate <code>AbstractDataFrames</code>.</p><p>Column names in all passed data frames must be the same, but they can have different order. In such cases the order of names in the first passed <code>DataFrame</code> is used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; vcat(df1, df2)
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">append!(df1::DataFrame, df2::AbstractDataFrame)</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df1</code>.</p><p>Column names must be equal (including order). Values corresponding to new rows are appended in-place to the column vectors of <code>df1</code>. Column types are therefore preserved, and new values are converted if necessary. An error is thrown if conversion fails: this is the case in particular if a column in <code>df2</code> contains <code>missing</code> values but the corresponding column in <code>df1</code> does not accept them.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Use <a href="#Base.vcat"><code>vcat</code></a> instead of <code>append!</code> when more flexibility is needed. Since <code>vcat</code> does not operate in place, it is able to use promotion to find an appropriate element type to hold values from both data frames. It also accepts columns in different orders between <code>df1</code> and <code>df2</code>.</p><p>Use <a href="lib/@ref"><code>push!</code></a> to add individual rows to a data frame.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6);

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │</code></pre></div></div></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="../indexing/"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></html>
