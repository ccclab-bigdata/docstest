<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · DandelionWebSockets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DandelionWebSockets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.@expect" href="#DandelionWebSockets.@expect"><code>DandelionWebSockets.@expect</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Expect a call with some arguments, and perform an action when that call has been made..</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.@mock" href="#DandelionWebSockets.@mock"><code>DandelionWebSockets.@mock</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Define a mock type, given a symbol for its name and a type from which it should inherit.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.@mockfunction" href="#DandelionWebSockets.@mockfunction"><code>DandelionWebSockets.@mockfunction</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Define one or more functions that mock the behaviour the object should have.</p><p>The functions defined here are the functions called by the code under test. The functions check that their arguments match those that are expected, and that the mock action is performed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.AbnormalNoCloseResponseReceived" href="#DandelionWebSockets.AbnormalNoCloseResponseReceived"><code>DandelionWebSockets.AbnormalNoCloseResponseReceived</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>No Close frame response was received by the client after a reasonable time</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.AbnormalSocketNotClosedByServer" href="#DandelionWebSockets.AbnormalSocketNotClosedByServer"><code>DandelionWebSockets.AbnormalSocketNotClosedByServer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The socket did not close the socket in a reasonable timeframe.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.AbstractBackoff</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractClientProtocol</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractFrameWriter</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.AbstractHandshakeResult" href="#DandelionWebSockets.AbstractHandshakeResult"><code>DandelionWebSockets.AbstractHandshakeResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>AbstractHandshakeResult is a  supertype for either a successful or an unsuccessful handshake.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.AbstractMatcher" href="#DandelionWebSockets.AbstractMatcher"><code>DandelionWebSockets.AbstractMatcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for objects that match actual arguments against expected arguments. For instance, we sometimes don&#39;t care what value is provided a mock function, only what type it is. Also, this can be used to parse an actual argument as JSON and compare the resulting object, rather than relying on a string comparison.</p><p>All <code>AbstractMatcher</code> types <code>T</code> must define a function <code>mock_match(::T, v::Any)</code>.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.AbstractPinger</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractPonger</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractRetry</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractServerReader</code></pre><pre><code class="language-none">DandelionWebSockets.AbstractWSClient</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.Backoff" href="#DandelionWebSockets.Backoff"><code>DandelionWebSockets.Backoff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A backoff that follows a atan curve, and reaches about 90% of max backoff in 12 attempts.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.BadHandshake" href="#DandelionWebSockets.BadHandshake"><code>DandelionWebSockets.BadHandshake</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BadHandshake is returned when an unsuccessful handshake has been made.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.BinaryFrameSender" href="#DandelionWebSockets.BinaryFrameSender"><code>DandelionWebSockets.BinaryFrameSender</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FrameSender is used to send multi-frame messages.</p><p>You are provided a FrameSender via the client. You then send data using the <code>sendframe(sender, data; isfinal=false)</code> method. For the last frame you set <code>isfinal = true</code>.</p><p>After the last frame has been sent, you MAY NOT use the FrameSender again. Trying to send another frame with the same instance of FrameSender WILL lead to an exception of type <code>FinalFrameAlreadySentException</code>.</p><p>NOTE: While you have a <code>FrameSender</code> in which you have not sent the last frame, then       you MAY NOT use the client to send any other messages. Interleaving messages is       prohibited by the WebSocket protocol and will lead to the socket being closed.</p><p>NOTE: You may send frames that are individually invalid UTF-8. However, the complete message, which       is all frames concatenated, MUST be valid UTF-8, or the other endpoint is required to fail       the WebSocket connection.       With the <code>TextFrameSender</code> you can use both a <code>String</code> or a <code>Vector{UInt8}</code> as the payload.       The <code>Vector{UInt8}</code> alternative can be used to send invalid UTF-8, or possibly invalid UTF-8.</p><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframetext(client)
sendframe(sender, &quot;Hello&quot;)
sendframe(sender, &quot;world&quot;)
sendframe(sender, &quot;Goodbye&quot;; isfinal=true)</code></pre><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframebinary(client)
sendframe(sender, b&quot;Hello&quot;)
sendframe(sender, b&quot;world&quot;)
sendframe(sender, b&quot;Goodbye&quot;; isfinal=true)</code></pre></div></div></section><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_ABNORMAL_CLOSE</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_EXPECTED_EXTENSION</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_FATAL_UNEXPECTED_CONDITION</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_GOING_AWAY</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_INCONSISTENT_DATA</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_MESSAGE_TOO_BIG</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_NORMAL</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_NO_STATUS</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_POLICY_VIOLATION</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_PROTOCOL_ERROR</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_RESERVED_1004</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_TLS_HANDSHAKE_FAILURE</code></pre><pre><code class="language-none">DandelionWebSockets.CLOSE_STATUS_UNACCEPTABLE_DATA</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ClientInitiatedCloseBehaviour" href="#DandelionWebSockets.ClientInitiatedCloseBehaviour"><code>DandelionWebSockets.ClientInitiatedCloseBehaviour</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Closing the WebSocket connection is a procedure for closing the connection during the normal course the protocol lifetime.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ClientPingRequest" href="#DandelionWebSockets.ClientPingRequest"><code>DandelionWebSockets.ClientPingRequest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Send a ping request to the server.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ClientProtocol" href="#DandelionWebSockets.ClientProtocol"><code>DandelionWebSockets.ClientProtocol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for the logic of a client WebSocket.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ClientProtocolInput" href="#DandelionWebSockets.ClientProtocolInput"><code>DandelionWebSockets.ClientProtocolInput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all commands sent to <code>ClientProtocol</code>.</p><p>These commands are sent as arguments to the different <code>handle</code> functions on <code>ClientProtocol</code>. Each command represents an action on a WebSocket, such as sending a text frame, ping request, or closing the connection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.CloseRequest" href="#DandelionWebSockets.CloseRequest"><code>DandelionWebSockets.CloseRequest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A request to close the WebSocket.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.CloseStatus" href="#DandelionWebSockets.CloseStatus"><code>DandelionWebSockets.CloseStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>CloseStatusCode indicates a reason for closing the connection. It is optionally sent as the first two bytes of a Close frames payload.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.CloseStatusAndReason</code></pre><pre><code class="language-none">DandelionWebSockets.ClosingBehaviour</code></pre><pre><code class="language-none">DandelionWebSockets.DandelionWebSockets</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.FailTheConnectionBehaviour" href="#DandelionWebSockets.FailTheConnectionBehaviour"><code>DandelionWebSockets.FailTheConnectionBehaviour</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Failing the WebSocket connection is an action taken at certain points in the protocol specification, in response to error conditions.</p><p>The closing behaviour is to optionally send a Close frame, with an appropriate status code, and then close the socket.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.FinalFrameAlreadySentException" href="#DandelionWebSockets.FinalFrameAlreadySentException"><code>DandelionWebSockets.FinalFrameAlreadySentException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FinalFrameAlreadySentException is thrown when sendframe is called again after the last frame.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.Frame</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.FrameFromServer" href="#DandelionWebSockets.FrameFromServer"><code>DandelionWebSockets.FrameFromServer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A frame was received from the server.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.FrameSender" href="#DandelionWebSockets.FrameSender"><code>DandelionWebSockets.FrameSender</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FrameSender is used to send multi-frame messages.</p><p>You are provided a FrameSender via the client. You then send data using the <code>sendframe(sender, data; isfinal=false)</code> method. For the last frame you set <code>isfinal = true</code>.</p><p>After the last frame has been sent, you MAY NOT use the FrameSender again. Trying to send another frame with the same instance of FrameSender WILL lead to an exception of type <code>FinalFrameAlreadySentException</code>.</p><p>NOTE: While you have a <code>FrameSender</code> in which you have not sent the last frame, then       you MAY NOT use the client to send any other messages. Interleaving messages is       prohibited by the WebSocket protocol and will lead to the socket being closed.</p><p>NOTE: You may send frames that are individually invalid UTF-8. However, the complete message, which       is all frames concatenated, MUST be valid UTF-8, or the other endpoint is required to fail       the WebSocket connection.       With the <code>TextFrameSender</code> you can use both a <code>String</code> or a <code>Vector{UInt8}</code> as the payload.       The <code>Vector{UInt8}</code> alternative can be used to send invalid UTF-8, or possibly invalid UTF-8.</p><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframetext(client)
sendframe(sender, &quot;Hello&quot;)
sendframe(sender, &quot;world&quot;)
sendframe(sender, &quot;Goodbye&quot;; isfinal=true)</code></pre><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframebinary(client)
sendframe(sender, b&quot;Hello&quot;)
sendframe(sender, b&quot;world&quot;)
sendframe(sender, b&quot;Goodbye&quot;; isfinal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.FrameWriter" href="#DandelionWebSockets.FrameWriter"><code>DandelionWebSockets.FrameWriter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FrameWriter is used by the protocols to write frames to a socket.</p><p>This is separate from the client protocol code, because the protocol for closing a connection is separate from the rest of the client protocol, and both need to send frames.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.GoodHandshake" href="#DandelionWebSockets.GoodHandshake"><code>DandelionWebSockets.GoodHandshake</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>GoodHandshake is returned when a successful handshake has been made.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.HTTPAdapter" href="#DandelionWebSockets.HTTPAdapter"><code>DandelionWebSockets.HTTPAdapter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>HTTPAdapter is an abstract type for an HTTP package that can be used for a handshake GET.</p><p>Any subtype of HTTPAdapter should implement the <code>dohandshake</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.HTTPHandshake" href="#DandelionWebSockets.HTTPHandshake"><code>DandelionWebSockets.HTTPHandshake</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>HTTPHandshake implements the HTTP handshake from the WebSocket specification.</p><p>It requires a random number generator to generate the WebSocket random key used to verify that the other side is actually a WebSocket server. The <code>HTTPAdapter</code> supplied implements the actual HTTP GET request, which returns an <code>HTTPUpgradeResponse</code>.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.HTTPHandshakeLogic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.HTTPUpgradeResponse" href="#DandelionWebSockets.HTTPUpgradeResponse"><code>DandelionWebSockets.HTTPUpgradeResponse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>HTTPUpgradeResponse is a collection of data returned by a HTTP upgrade, regardless of package.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.HTTPjlAdapter</code></pre><pre><code class="language-none">DandelionWebSockets.HandshakeValidationResult</code></pre><pre><code class="language-none">DandelionWebSockets.HeaderList</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.MockCall" href="#DandelionWebSockets.MockCall"><code>DandelionWebSockets.MockCall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An expected function call, along with expected arguments, and an action it should perform.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.MockExpectationException" href="#DandelionWebSockets.MockExpectationException"><code>DandelionWebSockets.MockExpectationException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An exception thrown when an unexpected argument was found or a function was called.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.OPCODE_BINARY</code></pre><pre><code class="language-none">DandelionWebSockets.OPCODE_CLOSE</code></pre><pre><code class="language-none">DandelionWebSockets.OPCODE_CONTINUATION</code></pre><pre><code class="language-none">DandelionWebSockets.OPCODE_PING</code></pre><pre><code class="language-none">DandelionWebSockets.OPCODE_PONG</code></pre><pre><code class="language-none">DandelionWebSockets.OPCODE_TEXT</code></pre><pre><code class="language-none">DandelionWebSockets.Opcode</code></pre><pre><code class="language-none">DandelionWebSockets.Pinger</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.PongMissed" href="#DandelionWebSockets.PongMissed"><code>DandelionWebSockets.PongMissed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A pong reply was expected, but never received.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.Ponger</code></pre><pre><code class="language-none">DandelionWebSockets.Proxy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.RandomizedBackoff" href="#DandelionWebSockets.RandomizedBackoff"><code>DandelionWebSockets.RandomizedBackoff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Randomize another backoff by adding some randomness to the backoff time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.Retry" href="#DandelionWebSockets.Retry"><code>DandelionWebSockets.Retry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Start a timer for some function, based on a backoff.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.STATE_CLOSED</code></pre><pre><code class="language-none">DandelionWebSockets.STATE_CLOSING</code></pre><pre><code class="language-none">DandelionWebSockets.STATE_CONNECTING</code></pre><pre><code class="language-none">DandelionWebSockets.STATE_OPEN</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.SendBinaryFrame" href="#DandelionWebSockets.SendBinaryFrame"><code>DandelionWebSockets.SendBinaryFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Send a binary frame, sent to <code>ClientProtocol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.SendTextFrame" href="#DandelionWebSockets.SendTextFrame"><code>DandelionWebSockets.SendTextFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Send a text frame, sent to <code>ClientProtocol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ServerInitiatedCloseBehaviour" href="#DandelionWebSockets.ServerInitiatedCloseBehaviour"><code>DandelionWebSockets.ServerInitiatedCloseBehaviour</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The server can initiate a Close, in which case this behaviour ensures a proper close.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ServerReader" href="#DandelionWebSockets.ServerReader"><code>DandelionWebSockets.ServerReader</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reading from a network socket and placing the resulting frame on a channel.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.SocketClosed" href="#DandelionWebSockets.SocketClosed"><code>DandelionWebSockets.SocketClosed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Used when the underlying network socket was closed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.SocketState" href="#DandelionWebSockets.SocketState"><code>DandelionWebSockets.SocketState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Enum value for the different states a WebSocket can be in.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.StopTaskException" href="#DandelionWebSockets.StopTaskException"><code>DandelionWebSockets.StopTaskException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An exception thrown into a task in order to stop it.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.SuccessfulHandshake</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.TLSBufferedIO" href="#DandelionWebSockets.TLSBufferedIO"><code>DandelionWebSockets.TLSBufferedIO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TLSBufferedIO adapts a TLS socket so we can do byte I/O.</p><p>The stream returned by MbedTLS when using a TLS socket does not support the byte I/O used when reading a frame. It only supports reading a chunk of data. This is a fake stream that buffers some data and lets us do byte I/O.</p><p>Note: This should have been done by the BufferedStreams.jl package. However, I couldn&#39;t get it to work with the MbedTLS stream, for reasons unknown. If we can investigate and fix that problem, then we should really replace this type with a BufferedInputStream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.TextFrameSender" href="#DandelionWebSockets.TextFrameSender"><code>DandelionWebSockets.TextFrameSender</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FrameSender is used to send multi-frame messages.</p><p>You are provided a FrameSender via the client. You then send data using the <code>sendframe(sender, data; isfinal=false)</code> method. For the last frame you set <code>isfinal = true</code>.</p><p>After the last frame has been sent, you MAY NOT use the FrameSender again. Trying to send another frame with the same instance of FrameSender WILL lead to an exception of type <code>FinalFrameAlreadySentException</code>.</p><p>NOTE: While you have a <code>FrameSender</code> in which you have not sent the last frame, then       you MAY NOT use the client to send any other messages. Interleaving messages is       prohibited by the WebSocket protocol and will lead to the socket being closed.</p><p>NOTE: You may send frames that are individually invalid UTF-8. However, the complete message, which       is all frames concatenated, MUST be valid UTF-8, or the other endpoint is required to fail       the WebSocket connection.       With the <code>TextFrameSender</code> you can use both a <code>String</code> or a <code>Vector{UInt8}</code> as the payload.       The <code>Vector{UInt8}</code> alternative can be used to send invalid UTF-8, or possibly invalid UTF-8.</p><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframetext(client)
sendframe(sender, &quot;Hello&quot;)
sendframe(sender, &quot;world&quot;)
sendframe(sender, &quot;Goodbye&quot;; isfinal=true)</code></pre><p><strong>Example</strong></p><pre><code class="language-none">sender = sendmultiframebinary(client)
sendframe(sender, b&quot;Hello&quot;)
sendframe(sender, b&quot;world&quot;)
sendframe(sender, b&quot;Goodbye&quot;; isfinal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.Throws" href="#DandelionWebSockets.Throws"><code>DandelionWebSockets.Throws</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tells a mock function that it should throw an exception.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.TypeMatcher" href="#DandelionWebSockets.TypeMatcher"><code>DandelionWebSockets.TypeMatcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Match a value by checking its type only.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.UniformResourceIdentifiers</code></pre><pre><code class="language-none">DandelionWebSockets.UnsuccessfulHandshake</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.ValueMatcher" href="#DandelionWebSockets.ValueMatcher"><code>DandelionWebSockets.ValueMatcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simply match a value by equality. This is the default.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.WSClient" href="#DandelionWebSockets.WSClient"><code>DandelionWebSockets.WSClient</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A WebSocket client, used to connect to a server, and send messages.</p><p>Note: The keyword arguments in the constructor are primarily for testing.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.WebSocketConnection</code></pre><pre><code class="language-none">DandelionWebSockets.WebSocketConnectionImpl</code></pre><pre><code class="language-none">DandelionWebSockets.WebSocketHandler</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.WebSocketHandshake" href="#DandelionWebSockets.WebSocketHandshake"><code>DandelionWebSockets.WebSocketHandshake</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>WebSocketHandshake represents a way to make a WebSocket connection handshake.</p><p>The only handshake detailed in the specification is an HTTP handshake, represented by the <code>HTTPHandshake</code> type (regardless of HTTP package used to implement it). The specification does mention the possibility of other types of handshakes, even though these would be outside of the specification.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.WebSocketUpgrade</code></pre><pre><code class="language-none">DandelionWebSockets.WebSocketUpgradeAdapter</code></pre><pre><code class="language-none">DandelionWebSockets._expectheader</code></pre><pre><code class="language-none">DandelionWebSockets.attach</code></pre><pre><code class="language-none">DandelionWebSockets.backoff_max</code></pre><pre><code class="language-none">DandelionWebSockets.backoff_min</code></pre><pre><code class="language-none">DandelionWebSockets.buffer</code></pre><pre><code class="language-none">DandelionWebSockets.clientprotocolinput</code></pre><pre><code class="language-none">DandelionWebSockets.closesocket</code></pre><pre><code class="language-none">DandelionWebSockets.closestatusandreason</code></pre><pre><code class="language-none">DandelionWebSockets.closetheconnection</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.connection_result_" href="#DandelionWebSockets.connection_result_"><code>DandelionWebSockets.connection_result_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connection_result(::WSClient, ::GoodHandshake, ::WebSocketHandler, fix_small_message_latency::Bool)</code></pre><p>For a valid handshake, start all background tasks for this connection. This includes tasks for reading and writing from the socket, as well as a task for user callback.</p></div></div><div><div><p>The HTTP Upgrade failed, for whatever reason.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.default_timer_factory</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.do_reader" href="#DandelionWebSockets.do_reader"><code>DandelionWebSockets.do_reader</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Read frames from the network, until an exception is thrown in this task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.dohandshake" href="#DandelionWebSockets.dohandshake"><code>DandelionWebSockets.dohandshake</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dohandshake(http::HTTPAdapter, uri::String, headers::HeaderList)</code></pre><p>Do an HTTP GET request to <code>uri</code> including headers <code>headers</code>.</p><p>The <code>headers</code> list will contain all WebSocket upgrade specific headers, such as <code>Connection</code>, <code>Upgrade</code>, and <code>Sec-WebSocket-Key</code>.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.eval</code></pre><pre><code class="language-none">DandelionWebSockets.failtheconnection</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.fill_buffer" href="#DandelionWebSockets.fill_buffer"><code>DandelionWebSockets.fill_buffer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Read all available data, and block until we have enough to fulfíll the next read.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.getrequestheaders</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.handle" href="#DandelionWebSockets.handle"><code>DandelionWebSockets.handle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a single text frame.</p></div></div><div><div><p>Send a single binary frame.</p></div></div><div><div><p>Handle a user request to close the WebSocket.</p></div></div><div><div><p>The underlying socket was closed. This is sent by the reader.</p></div></div><div><div><p>Handle a frame from the server.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.handle_binary</code></pre><pre><code class="language-none">DandelionWebSockets.handle_close</code></pre><pre><code class="language-none">DandelionWebSockets.handle_continuation</code></pre><pre><code class="language-none">DandelionWebSockets.handle_ping</code></pre><pre><code class="language-none">DandelionWebSockets.handle_pong</code></pre><pre><code class="language-none">DandelionWebSockets.handle_text</code></pre><pre><code class="language-none">DandelionWebSockets.include</code></pre><pre><code class="language-none">DandelionWebSockets.isclosedcleanly</code></pre><pre><code class="language-none">DandelionWebSockets.iscontrolframe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.issuccessful" href="#DandelionWebSockets.issuccessful"><code>DandelionWebSockets.issuccessful</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issuccessful(::AbstractHandshakeResult)</code></pre><p>True if a handshake was succcessful, false otherwise.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.masking!</code></pre><pre><code class="language-none">DandelionWebSockets.maybewrapio</code></pre><pre><code class="language-none">DandelionWebSockets.mock_action</code></pre><pre><code class="language-none">DandelionWebSockets.mock_match</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.name_args_" href="#DandelionWebSockets.name_args_"><code>DandelionWebSockets.name_args_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Define a name for an argument, if no name is provided.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.on_binary" href="#DandelionWebSockets.on_binary"><code>DandelionWebSockets.on_binary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Handle a binary frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.on_text" href="#DandelionWebSockets.on_text"><code>DandelionWebSockets.on_text</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Handle a text frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.performhandshake" href="#DandelionWebSockets.performhandshake"><code>DandelionWebSockets.performhandshake</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">performhandshake(h::HTTPHandshake, uri::String)</code></pre><p>Do a handshake with the server at <code>uri</code>, with parameters supplied by <code>h</code>. Validate the handshake, and return a good or bad result, depending on the validation.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.ping_sent</code></pre><pre><code class="language-none">DandelionWebSockets.pong_received</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.protocolstate" href="#DandelionWebSockets.protocolstate"><code>DandelionWebSockets.protocolstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The state of the connection.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.readstatusandreason</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reset" href="#Base.reset"><code>Base.reset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reset the backoff to its initial state.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.retry</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.send" href="#DandelionWebSockets.send"><code>DandelionWebSockets.send</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a frame to the other endpoint, using the supplied payload and opcode.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.send_binary" href="#DandelionWebSockets.send_binary"><code>DandelionWebSockets.send_binary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a single binary frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.send_text" href="#DandelionWebSockets.send_text"><code>DandelionWebSockets.send_text</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a single text frame.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.sendcloseframe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.sendframe" href="#DandelionWebSockets.sendframe"><code>DandelionWebSockets.sendframe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a frame with a payload to the other endpoint. <code>isfinal</code> must be set to true for the last frame.</p><p>After the call with <code>isfinal = true</code>, then this method MAY NOT be called again. If it is, then a <code>FinalFrameAlreadySentException</code> will be thrown.</p></div></div><div><div><p>Specialization of sendframe for TextFrameSender, for sending Strings as data.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.sendmultiframebinary</code></pre><pre><code class="language-none">DandelionWebSockets.sendmultiframetext</code></pre><pre><code class="language-none">DandelionWebSockets.set_function</code></pre><pre><code class="language-none">DandelionWebSockets.show</code></pre><pre><code class="language-none">DandelionWebSockets.start_buffer</code></pre><pre><code class="language-none">DandelionWebSockets.start_reader</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.state_closed" href="#DandelionWebSockets.state_closed"><code>DandelionWebSockets.state_closed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The WebSocket was closed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.state_closing" href="#DandelionWebSockets.state_closing"><code>DandelionWebSockets.state_closing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The WebSocket is about to close.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.state_connecting" href="#DandelionWebSockets.state_connecting"><code>DandelionWebSockets.state_connecting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The WebSocket is trying to connect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.state_open" href="#DandelionWebSockets.state_open"><code>DandelionWebSockets.state_open</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The WebSocket is open and ready to send and receive messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.stop" href="#DandelionWebSockets.stop"><code>DandelionWebSockets.stop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Close the WebSocket connection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.tcpnodelay" href="#DandelionWebSockets.tcpnodelay"><code>DandelionWebSockets.tcpnodelay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tcpnodelay(::IO)</code></pre><p>Sets the TCP_NODELAY flag on a socket. This is a separate function only for testing purposes. It can be implemented with a more specific type if the flag makes no sense for another <code>IO</code> subtype.</p></div></div></section><pre><code class="language-none">DandelionWebSockets.to_matcher</code></pre><pre><code class="language-none">DandelionWebSockets.validateresponse</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DandelionWebSockets.wsconnect" href="#DandelionWebSockets.wsconnect"><code>DandelionWebSockets.wsconnect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Connect the client to a WebSocket server at <code>uri</code>, and use <code>handler</code> for the callbacks.</p><p><strong>Arguments</strong></p><ul><li><code>fix_small_message_latency::Bool = false</code>: Set the TCP_NODELAY flag to improve small message latency.</li></ul><p><strong>Fix small message latency</strong></p><p>The TCP protocol can buffer small messages (1448 bytes and smaller). The reason is that this reduces the overhead when sending large amounts of small packets. However, it also means that latency can be much higher for small messages. This buffering can be disabled by setting a flag TCP<em>NODELAY. By default, the WebSocket client will now set the TCP</em>NODELAY flag.</p><p>If your application will send and receive primarily small messages (1448 bytes or smaller), and it is sensitive to latency, then leave <code>fix_small_message_latency</code> set to true (now the default). This sets the TCP<em>NODELAY flag. If you are not concerned about latency, but concerned about throughput for many small messages, then you can set `fix</em>small<em>message</em>latency = false`. Then you may get higher throughput, at the expense of higher latency for small messages.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
