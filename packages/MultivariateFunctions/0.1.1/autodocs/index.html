<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MultivariateFunctions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MultivariateFunctions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">MultivariateFunctions.*</code></pre><pre><code class="language-none">MultivariateFunctions.+</code></pre><pre><code class="language-none">MultivariateFunctions.-</code></pre><pre><code class="language-none">MultivariateFunctions./</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.Hessian" href="#MultivariateFunctions.Hessian"><code>MultivariateFunctions.Hessian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Hessian(f::MultivariateFunction, dimensions::Array{Symbol,1})
Hessian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels_::Array{Symbol,1})</code></pre><p>This represents expressions for constructing a hessian matrix for a function. It can be evaluated to get a symmetric matrix of the hessian at a particular location.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.IntegrationLimitDict</code></pre><pre><code class="language-none">MultivariateFunctions.MultivariateFunction</code></pre><pre><code class="language-none">MultivariateFunctions.MultivariateFunctions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.PE_Function" href="#MultivariateFunctions.PE_Function"><code>MultivariateFunctions.PE_Function</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PE_Function(multiplier_::Float64, functions_::Dict{Symbol,PE_Unit})</code></pre><p>This is the main constructor for a PE Function. The functional form of the function is the multiplier multiplied by all PE_Units.</p><p>For instance the PE<em>Function created by PE</em>Function(6.0, Dict([:x, :y] .=&gt; [PE<em>Unit(1.0,1.0,1), PE</em>Unit(0.0,2.0,4)])) has a functional form of 6 (x-1) exp(x-1) (y-2)^4</p><p>The following convenience functions create a PE<em>Function where there is only one variable (with a symbol :default).     PE</em>Function(multiplier<em>::Float64,b</em>::Float64, base<em>::Float64, d</em>::Int)     PE<em>Function(multiplier</em>::Float64,b<em>::Float64, base</em>::Date, d<em>::Int) The following convenience function creates a PE</em>Function where there are no variables and hence it is constant:     PE_Function(num::Float64 = 0.0)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.PE_Unit" href="#MultivariateFunctions.PE_Unit"><code>MultivariateFunctions.PE_Unit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PE_Unit(b_::Float64, base_::Float64, d_::Int)
PE_Unit(b_::Float64, base_::Date, d_::Int)</code></pre><p>This creates a PE<em>Unit which has a functional form of exp(b</em>(x-base<em>)) (x-base</em>)^d. They cannot be used in any productive way by themselves but are needed to construct a PE<em>Function. An empty PE</em>Unit (which might be used to create a constant PE<em>Function) can be created by PE</em>Unit().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.Piecewise_Function" href="#MultivariateFunctions.Piecewise_Function"><code>MultivariateFunctions.Piecewise_Function</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Piecewise_Function(functions_::Array{Union{Missing,Sum_Of_Functions}}, thresholds_::OrderedDict{Symbol,Array{Float64,1}})</code></pre><p>Creates a Piecewise<em>Function from a multidimensional array of Sum</em>Of<em>Functions and an ordered dict of thresholds. The xth dimension in the thresholds dict corresponds to the xth dimension of the array of functions. A function can be lookuped up considering the thresholds and then selecting from the array. For instance if the first dimension is denoted :y and it&#39;s thresholds are [-4.0,0.0,3.4] and we query at a point with a :y coordinate of 2.7 then the function we look up will be from the file functions</em>[2, ...] where ... represents the coordinates the the other dimensions. This is because 2.7 is greater than the second element of [-4.0,0.0,3.4] but less than the third. If this piecewise function were to be queried at a :y coordinate of -5.0 then a missing value will be returned. To specify piecewise functions on an unlimited domain the first element of the threshold can be set as -Inf. To set a limited domain on the upper end then add a Missing value to the functions_ array. Any other (ie interior) point can also be made undefined by putting a Missing() type into the functions_ array.</p><p>Note that Piecewise<em>Function works by assigning a Sum</em>Of<em>Functions to every region within the space defined by the thresholds</em> dict. It is only possible to specify a region as a hypercube however. More complex regions are not possible.</p><p>Note too that piecewise functions will scale poorly in high dimensions. If there are 10 dimensions and each has 4 elements in its threshold dict then the array for the piecewise function will have more than one million entries. In cases where there are no interactions between dimensions it is more efficient to use a Sum<em>Of</em>Piecewise<em>Functions object (which is basically an array of Piecewise Functions). For instance consider the following function: f(x,y,z) = max(x,5) + max(y,3) + max(z,3) We could code this as a piecewise function or as the sum of three piecewise functions. The three piecewise function implementation will contain fewer PE</em>Functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.Sum_Of_Functions" href="#MultivariateFunctions.Sum_Of_Functions"><code>MultivariateFunctions.Sum_Of_Functions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Sum_Of_Functions(functions)</code></pre><p>Creates a Sum<em>Of</em>Functions from an array of PE<em>Functions and/or Sum</em>Of<em>Functions. The constructors for this type go through each input Sum</em>Of<em>Functions and takes out the contained PE</em>Functions (so unecessary nesting doesnt occur where a Sum<em>Of</em>Functions could contain another Sum<em>Of</em>Functions). The constructors also aggregate PE<em>Functions where possible. For intance if two PE</em>Functions have the same PE<em>Units and differ in their multiplier these multipliers can be added. The constructors also remove zero multiplier PE</em>Functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.Sum_Of_Piecewise_Functions" href="#MultivariateFunctions.Sum_Of_Piecewise_Functions"><code>MultivariateFunctions.Sum_Of_Piecewise_Functions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Sum_Of_Piecewise_Functions(functions_::Array{Piecewise_Function,1}, global_funcs_::Sum_Of_Functions)</code></pre><p>At the cost of being less flexible a Sum<em>Of</em>Piecewise_Functions is more efficient than a PiecewiseFunction. Use this if trying to represent a piecewise function that can be decomposed into a sum of lower dimensional piecewise functions.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.^</code></pre><pre><code class="language-none">MultivariateFunctions.add_split_with_max_function</code></pre><pre><code class="language-none">MultivariateFunctions.add_split_with_step_function</code></pre><pre><code class="language-none">MultivariateFunctions.add_to_dict</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.all_derivatives" href="#MultivariateFunctions.all_derivatives"><code>MultivariateFunctions.all_derivatives</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> all_derivatives(f::MultivariateFunction, degree::Int = 2, dimensions::Set{Symbol} = underlying_dimensions(f))</code></pre><p>This generates a dict containing functions representing all of the deriviates of a function up to the order of degree.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.apply_limits</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.change_base" href="#MultivariateFunctions.change_base"><code>MultivariateFunctions.change_base</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">change_base(f::PE_Function, new_bases::Dict{Symbol,Float64})</code></pre><p>This function changes the bases in the PE<em>Units of a PE</em>Function. This is useful for getting two PE<em>Functions comformable for simpler multiplication. Often a base change means that an array of PE</em>Functions are needed to represent a function. So an Array{PE_Function,1} is returned.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.change_base_</code></pre><pre><code class="language-none">MultivariateFunctions.convert</code></pre><pre><code class="language-none">MultivariateFunctions.convert_chebyshevs</code></pre><pre><code class="language-none">MultivariateFunctions.convert_format</code></pre><pre><code class="language-none">MultivariateFunctions.convert_to_conformable_dict</code></pre><pre><code class="language-none">MultivariateFunctions.convert_to_linearly_rescale_inputs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_chebyshev_approximation" href="#MultivariateFunctions.create_chebyshev_approximation"><code>MultivariateFunctions.create_chebyshev_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_chebyshev_approximation(f::Function, nodes::Int, degree::Int, limits::OrderedDict{Symbol,Tuple{Float64,Float64}}, function_takes_Dict::Bool = false)</code></pre><p>Creates a Sum<em>Of</em>Functions that approximates a function, f, with a set of chebyshevs of a particular degree. The nodes input specifies at how many locations the function is to be evaluated for approximation purposes in each dimension. The limits OrderedDict specifies the domain of where the function is to be approximated.</p><p>If function<em>takes</em>Dict is true then the function will be evaluated by inputting a  Dict{Symbol,Float64}. Otherwise the function will be evaluated with f(values(limits)...) Note that the order of the OrderedDict specifies the order of inputs to the function in this case.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.create_common_pieces</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_constant_interpolation_to_left" href="#MultivariateFunctions.create_constant_interpolation_to_left"><code>MultivariateFunctions.create_constant_interpolation_to_left</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_constant_interpolation_to_left(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_left(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise constant one-dimensional function which carries values from the right to the left.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_constant_interpolation_to_right" href="#MultivariateFunctions.create_constant_interpolation_to_right"><code>MultivariateFunctions.create_constant_interpolation_to_right</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_constant_interpolation_to_right(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_right(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise constant one-dimensional function which carries values from the left to the right.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_linear_interpolation" href="#MultivariateFunctions.create_linear_interpolation"><code>MultivariateFunctions.create_linear_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_linear_interpolation(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_linear_interpolation(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise linear one-dimensional function which interpolates linearly between datapoints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_mars_spline" href="#MultivariateFunctions.create_mars_spline"><code>MultivariateFunctions.create_mars_spline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_mars_spline(dd::DataFrame, y::Symbol, x_variables::Set{Symbol}, MaxM::Int; rel_tol::Float64 = 1e-2)</code></pre><p>This creates a mars spline given a dataframe, response variable and a set of x<em>variables from the dataframe. The relative tolerance is used in a one-dimensional optimisation step to determine what points at which split values to place a max(0,x-split) function in a particular dimension. The default is intentionally set high because precision is generally not the not that important. For small scale data however you might want to decrease it and increase it for large scale data. You might also want to decrease it if spline creation time doesnt matter much. Note that a small rel</em>tol only affects creation time for the spline and not the evaluation time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_ols_approximation" href="#MultivariateFunctions.create_ols_approximation"><code>MultivariateFunctions.create_ols_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_ols_approximation(dd::DataFrame, y::Symbol, model::MultivariateFunction; allowrankdeficient = true)
create_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Functions; allowrankdeficient = true)
create_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Piecewise_Functions; allowrankdeficient = true)</code></pre><p>This creates MultivariationFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. You also input the regression model. This is input as a Array{MultivariateFunction,1}. Each function that is input will be multiplied by the ols coefficient and will return a new function with these coefficients incorporated.</p></div></div><div><div><pre><code class="language-none">create_ols_approximation(y::Array{Float64,1}, x::Array{Float64,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_x::Float64 = 0.0)
create_ols_approximation(y::Array{Float64,1}, x::Array{Date,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_date::Date = global_base_date)</code></pre><p>This predicts a linear relationship between the y and x arrays and creates a MultivariateFunction containing the approximation function. The degree specifies how many higher order terms of x should be used (for instance degree 2 implies x and x^2 are both used to predict y).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_quadratic_spline" href="#MultivariateFunctions.create_quadratic_spline"><code>MultivariateFunctions.create_quadratic_spline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_quadratic_spline(x::Array{Date,1},y::Array{Float64,1} ; gradients::Array{Any,1} = [], extrapolation::String = &quot;Curve&quot;, dim_name::Symbol = default_symbol)
create_quadratic_spline(x::Array{Int,1},y::Array{Float64,1} ; gradients::Array{Any,1} = [], extrapolation::String = &quot;Curve&quot;, dim_name::Symbol = default_symbol)
create_quadratic_spline(x::Array{Float64,1},y::Array{Float64,1} ; gradients::Array{Any,1} = [], extrapolation::String = &quot;Curve&quot;, dim_name::Symbol = default_symbol)
create_quadratic_spline(schum::Schumaker; dim_name::Symbol = default_symbol)</code></pre><p>Create a quadratic spline. The spline is a Schumaker shape-preserving spline which is taken from the SchumakerSpline.jl package.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.create_recursive_partitioning</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.create_saturated_ols_approximation" href="#MultivariateFunctions.create_saturated_ols_approximation"><code>MultivariateFunctions.create_saturated_ols_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create_saturated_ols_approximation(dd::DataFrame, y::Symbol, x_variables::Array{Symbol,1}, degree::Int; intercept::Bool = true,  bases::Dict{Symbol,Float64} = Dict{Symbol,Float64}(x_variables .=&gt; repeat([0.0],length(x_variables))))</code></pre><p>This creates MultivariateFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. you also put in an array of what x_variables should be used in prediction. A saturated ols model is then calculated up to the specified degree which is returned as a MultivariateFunction.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.days_per_year</code></pre><pre><code class="language-none">MultivariateFunctions.default_symbol</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.derivative" href="#MultivariateFunctions.derivative"><code>MultivariateFunctions.derivative</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> derivative(f::MultivariateFunction, derivs::Dict{Symbol,Int})</code></pre><p>This generates a function representing the derivative of function f. The derivative is that specified by the derivs dict. So if derivs is Dict{[:x,:y] .=&gt; [1,2]} then there will be one derivative with respect to x and 2 with respect to y.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.derivative_</code></pre><pre><code class="language-none">MultivariateFunctions.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.evaluate" href="#MultivariateFunctions.evaluate"><code>MultivariateFunctions.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate(f::MultivariateFunction, coordinates::Dict{Symbol,Float64})
evaluates a function at coordinates.

For univariate functions with a variable name of :default (such as those created by PE_Function&#39;s convenience functions)
evaluation can take place with no dictionary:
evaluate(f::MultivariateFunction, coordinate::Float64)</code></pre></div></div><div><div><pre><code class="language-none">evaluate(hess::Hessian, coordinates::Dict{Symbol,Float64})</code></pre><p>This evaluates a Hessian object to create a Symmetric matrix representing the hessian at a point.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.evaluate_function_at_nodes</code></pre><pre><code class="language-none">MultivariateFunctions.expand_array</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.find_local_optima" href="#MultivariateFunctions.find_local_optima"><code>MultivariateFunctions.find_local_optima</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_local_optima(func::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)</code></pre><p>This takes the analytical jacobian and hessian of a function and uses them to find a nearby optima. The optima it will find are based on Newton&#39;s method. There is no way to specify whether a minimum or a maximum is sought in Newton&#39;s method (at least the pure version of it) and thus this function cannot selectively search for a maximum or minimum. It simply searches for a stationary point.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.get_bases</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.get_chevyshevs_up_to" href="#MultivariateFunctions.get_chevyshevs_up_to"><code>MultivariateFunctions.get_chevyshevs_up_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_chevyshevs_up_to(num::Int, first_kind::Bool = true; dim_name::Symbol = default_symbol)
Output all chebyshev polynomials up to degree num.</code></pre></div></div></section><pre><code class="language-none">MultivariateFunctions.get_cholesky_coefficients</code></pre><pre><code class="language-none">MultivariateFunctions.get_correct_function_from_piecewise</code></pre><pre><code class="language-none">MultivariateFunctions.get_first_kind_Chebyshevs</code></pre><pre><code class="language-none">MultivariateFunctions.get_function_cube</code></pre><pre><code class="language-none">MultivariateFunctions.get_point_coordinates</code></pre><pre><code class="language-none">MultivariateFunctions.get_second_kind_Chebyshevs</code></pre><pre><code class="language-none">MultivariateFunctions.get_threshold_dict</code></pre><pre><code class="language-none">MultivariateFunctions.global_base_date</code></pre><pre><code class="language-none">MultivariateFunctions.global_base_date_as_day</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.hypercubes_to_integrate" href="#MultivariateFunctions.hypercubes_to_integrate"><code>MultivariateFunctions.hypercubes_to_integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> integral(f::Piecewise_Function, limits::Dict{Symbol,Tuple{Float64,Float64}})
 integral(f::Sum_Of_Piecewise_Functions, limits::Dict{Symbol,Tuple{Float64,Float64}})</code></pre><p>This gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each must be a Float64 (Support for inputting a symbol is planned but not yet implemented).</p></div></div></section><pre><code class="language-none">MultivariateFunctions.include</code></pre><pre><code class="language-none">MultivariateFunctions.indefinite_integral</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.integral" href="#MultivariateFunctions.integral"><code>MultivariateFunctions.integral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> integral(f::PE_Function, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})
 integral(f::Sum_Of_Functions, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})</code></pre><p>This gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each can be a Float64 or a symbol. If a symbol is input then this will get incorporated as a dimension in the MultivariateFunction created by the integral function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.jacobian" href="#MultivariateFunctions.jacobian"><code>MultivariateFunctions.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels::Array{Symbol,1})
jacobian(f::MultivariateFunction, dimensions::Array{Symbol,1})</code></pre><p>This generates an array of MultivariateFunctions representing the derivatives of a function. This array can be evaluated with evaluate.(jacobian, Ref(coordinates))  to give a vector of the derivative values at a point.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.next_chebyshev</code></pre><pre><code class="language-none">MultivariateFunctions.optimise_given_specific_split</code></pre><pre><code class="language-none">MultivariateFunctions.optimise_split</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.rebadge" href="#MultivariateFunctions.rebadge"><code>MultivariateFunctions.rebadge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rebadge(f::PE_Function, mapping::Dict{Symbol,Symbol})
can be used to change the names of the variables in a MultivariateFunction.</code></pre></div></div></section><pre><code class="language-none">MultivariateFunctions.sort</code></pre><pre><code class="language-none">MultivariateFunctions.tensor_outer_product</code></pre><pre><code class="language-none">MultivariateFunctions.tol</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.trim_mars_spline" href="#MultivariateFunctions.trim_mars_spline"><code>MultivariateFunctions.trim_mars_spline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>trim<em>mars</em>spline(dd::DataFrame, y::Symbol, model::Sum<em>Of</em>Piecewise<em>Functions;                    maximum</em>RSS::Float64 = -1.0, maximum<em>increase</em>in<em>RSS::Float64 = -1.0, final</em>number<em>of</em>functions::Int = -1)</p><p>This trims a mars spline created in the create<em>mars</em>spline function. This algorithm goes through each piecewise function in the mars spline and deletes the one that contributes least to the fit. A termination criterion must be set. There are three possible termination criterions. The first is the maximum<em>RSS that can be tolerated. If this is set then functions will be deleted until the deletion of an additional function would push RSS over this amount. The second is maximum</em>increase<em>in</em>RSS which will delete functions until a deletion increases RSS by more than this amount. The final is final<em>number</em>of_functions which reduces the number of fucntions to this number.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.trim_mars_spline_final_number_of_functions</code></pre><pre><code class="language-none">MultivariateFunctions.trim_mars_spline_maximum_RSS</code></pre><pre><code class="language-none">MultivariateFunctions.trim_mars_spline_maximum_increase_in_RSS</code></pre><pre><code class="language-none">MultivariateFunctions.trim_piecewise_function</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.underlying_dimensions" href="#MultivariateFunctions.underlying_dimensions"><code>MultivariateFunctions.underlying_dimensions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">underlying_dimensions(f::MultivariateFunction)
Returns a set containing all of the variables upon which f depends.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.uniroot" href="#MultivariateFunctions.uniroot"><code>MultivariateFunctions.uniroot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uniroot(f::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)</code></pre><p>This takes the analytical jacobian and hessian of a function and uses them to find a nearby root. It finds a root using Newton&#39;s method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.years_between" href="#MultivariateFunctions.years_between"><code>MultivariateFunctions.years_between</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">years_between(a::Date, b::Date)
years_between(a::Dates.Day, b::Dates.Day)</code></pre><p>Returns the number of years between two dates. For the purposes of this calculation there are 365.2422 days in a year.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateFunctions.years_from_global_base" href="#MultivariateFunctions.years_from_global_base"><code>MultivariateFunctions.years_from_global_base</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">years_between(a::Date, b::Date)
years_between(a::Dates.Day, b::Dates.Day)</code></pre><p>Returns the number of years that have elapsed since 1-Jan-2000. For the purposes of this calculation there are 365.2422 days in a year.</p></div></div></section><pre><code class="language-none">MultivariateFunctions.≂</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
