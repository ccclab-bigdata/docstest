<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · HCubature.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HCubature.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">HCubature.Box</code></pre><pre><code class="language-none">HCubature.GaussKronrod</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.GenzMalik" href="#HCubature.GenzMalik"><code>HCubature.GenzMalik</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>GenzMalik{n,T}</code> holds the points and weights corresponding to an <code>n</code>-dimensional Genz-Malik cubature rule over coordinates of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.HCubature" href="#HCubature.HCubature"><code>HCubature.HCubature</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The HCubature module is a pure-Julia implementation of multidimensional &quot;h-adaptive&quot; integration.  That is, given an n-dimensional integral</p><p><span>$\int_{a_1}^{b_1}\int_{a_2}^{b_2}\cdots\int_{a_n}^{b_n} (\vec{x}) d^n\vec{x}$</span></p><p>then <code>hcubature(f, a, b)</code> computes the integral, adaptively subdividing the integration volume into smaller and smaller pieces until convergence is achieved to the desired tolerance (specified by optional <code>rtol</code> and <code>atol</code> keyword arguments, described in more detail below.</p><p>Because <code>hcubature</code> is written purely in Julia, the integrand <code>f(x)</code> can return any vector-like object (technically, any type supporting <code>+</code>, <code>-</code>, <code>*</code> real, and <code>norm</code>: a Banach space).  You can integrate real, complex, and matrix-valued integrands, for example.</p></div></div></section><pre><code class="language-none">HCubature.Trivial</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.combos" href="#HCubature.combos"><code>HCubature.combos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combos(k, λ, Val{n}())</code></pre><p>Return an array of SVector{n} of all n-component vectors with k components equal to λ and other components equal to zero.</p></div></div></section><pre><code class="language-none">HCubature.countevals</code></pre><pre><code class="language-none">HCubature.cubrule</code></pre><pre><code class="language-none">HCubature.eval</code></pre><pre><code class="language-none">HCubature.gk_float64</code></pre><pre><code class="language-none">HCubature.gkcache</code></pre><pre><code class="language-none">HCubature.gmcache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.hcubature" href="#HCubature.hcubature"><code>HCubature.hcubature</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hcubature(f, a, b; norm=norm, rtol=sqrt(eps), atol=0, maxevals=typemax(Int), initdiv=1)</code></pre><p>Compute the n-dimensional integral of f(x), where <code>n == length(a) == length(b)</code>, over the hypercube whose corners are given by the vectors (or tuples) <code>a</code> and <code>b</code>. That is, dimension <code>x[i]</code> is integrated from <code>a[i]</code> to <code>b[i]</code>.  The return value of <code>hcubature</code> is a tuple <code>(I, E)</code> of the estimated integral <code>I</code> and an estimated error <code>E</code>.</p><p><code>f</code> should be a function <code>f(x)</code> that takes an n-dimensional vector <code>x</code> and returns the integrand at <code>x</code>.   The integrand can be any type that supports <code>+</code>, <code>-</code>, <code>*</code> real, and <code>norm</code> functions.  For example, the integrand can be real or complex numbers, vectors, matrices, etcetera.</p><p>The integrand <code>f(x)</code> will be always be passed an <code>SVector{n,T}</code>, where <code>SVector</code> is an efficient vector type defined in the <code>StaticArrays</code> package and <code>T</code> is a floating-point type determined by promoting the endpoint <code>a</code> and <code>b</code> coordinates to a floating-point type. (Your integrand <code>f</code> should be type-stable: it should always return a value of the same type, given this type of <code>x</code>.)</p><p>The integrand will never be evaluated exactly at the boundaries of the integration volume.  (So, for example, it is possible to have an integrand that blows up at the boundaries, as long as the integral is finite, though such singularities will slow convergence.)</p><p>The integration volume is adaptively subdivided, using a cubature rule due to Genz and Malik (1980), until the estimated error <code>E</code> satisfies <code>E ≤ max(rtol*norm(I), atol)</code>, i.e. <code>rtol</code> and <code>atol</code> are the relative and absolute tolerances requested, respectively. It also stops if the number of <code>f</code> evaluations exceeds <code>maxevals</code>. If neither <code>atol</code> nor <code>rtol</code> are specified, the default <code>rtol</code> is the square root of the precision <code>eps(T)</code> of the coordinate type <code>T</code> described above. Initially, the volume is divided into <code>initdiv</code> segments along each dimension.</p><p>The error is estimated by <code>norm(I - I′)</code>, where <code>I′</code> is an alternative estimated integral (via an &quot;embedded&quot; lower-order cubature rule.) By default, the norm function used (for both this and the convergence test above) is <code>norm</code>, but you can pass an alternative norm by the <code>norm</code> keyword argument.  (This is especially useful when <code>f</code> returns a vector of integrands with different scalings.)</p></div></div></section><pre><code class="language-none">HCubature.hcubature_</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.hquadrature" href="#HCubature.hquadrature"><code>HCubature.hquadrature</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hquadrature(f, a, b; norm=norm, rtol=sqrt(eps), atol=0, maxevals=typemax(Int), initdiv=1)</code></pre><p>Compute the integral of f(x) from <code>a</code> to <code>b</code>.  The return value of <code>hcubature</code> is a tuple <code>(I, E)</code> of the estimated integral <code>I</code> and an estimated error <code>E</code>.</p><p>The other parameters are the same as <a href="#HCubature.hcubature"><code>hcubature</code></a>.  <code>hquadrature</code><code>is just a convenience wrapper around</code>hcubature<code>so that you can work with scalar</code>x<code>,</code>a<code>, and</code>b`, rather than 1-component vectors.</p><p>Alternatively, for 1d integrals you can import the <a href="@ref"><code>QuadGK</code></a> module and call the <a href="@ref"><code>quadgk</code></a> function, which provides additional flexibility e.g. in choosing the order of the quadrature rule.</p></div></div></section><pre><code class="language-none">HCubature.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HCubature.signcombos" href="#HCubature.signcombos"><code>HCubature.signcombos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">signcombos(k, λ, Val{n}())</code></pre><p>Return an array of SVector{n} of all n-component vectors with k components equal to ±λ and other components equal to zero (with all possible signs).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
