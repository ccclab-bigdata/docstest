<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · FastGroupBy.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FastGroupBy.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#fastby-and-fastby!-1"><code>fastby</code> and <code>fastby!</code></a></li><li><a class="toctext" href="#fastby!-with-an-arbitrary-fn-1"><code>fastby!</code> with an arbitrary <code>fn</code></a></li><li><a class="toctext" href="#fastby-on-DataFrames-1"><code>fastby</code> on <code>DataFrames</code></a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="FastGroupBy-1" href="#FastGroupBy-1">FastGroupBy</a></h1><p>Faster algorithms for doing vector group-by. You can install it using</p><pre><code class="language-julia"># install
Pkg.add(&quot;FastGroupBy&quot;)
# install latest version
# `fastby` is not yet published so need to clone
Pkg.clone(&quot;https://github.com/xiaodaigh/FastGroupBy.jl.git&quot;)</code></pre><p><strong>Note: <code>fastby</code> is not yet published and hence need to manual install with <code>Pkg.clone</code></strong></p><h1><a class="nav-anchor" id="fastby-and-fastby!-1" href="#fastby-and-fastby!-1"><code>fastby</code> and <code>fastby!</code></a></h1><p>The <code>fastby</code> and <code>fastby!</code> functions allow the user to perform arbitrary computation on a vector (<code>valvec</code>) grouped by another vector (<code>byvec</code>). Their output format is a <code>Dict</code> whose <code>Dict</code>-keys are the distinct groups and the <code>Dict</code>-values are the results of applying the function, <code>fn</code> on the <code>valvec</code>, see below for explanation of <code>fn</code>, <code>byvec</code>, and <code>valvec</code>.</p><p>The difference between <code>fastby</code> and <code>fastby!</code> is that <code>fastby!</code> may change the input vectors <code>byvec</code> and <code>valvec</code> whereas <code>fastby</code> won&#39;t.</p><p>Both functions have the same three main arguments, but we shall illustrate using <code>fastby</code> only</p><pre><code class="language-julia">fastby(fn, byvec, valvec)</code></pre><ul><li><code>fn</code> is a function <code>fn</code> to be applied to each by-group of <code>valvec</code></li><li><code>byvec</code> is the vector to group by; <code>eltype(byvec)</code> must be one of these <code>Bool, Int8, Int16, Int32, Int64, Int128,                                    UInt8, UInt16, UInt32, UInt64, UInt128, String</code></li><li><code>valvec</code> is the vector that <code>fn</code> is applied to</li></ul><p>For example <code>fastby(sum, byvec, valvec)</code> is equivalent to <code>StatsBase</code>&#39;s <code>countmap(byvec, weights(valvec))</code>. Consider the below</p><pre><code class="language-julia">byvec  = [88, 888, 8, 88, 888, 88]
valvec = [1 , 2  , 3, 4 , 5  , 6]</code></pre><p>to compute the sum value of <code>valvec</code> in each group of <code>byvec</code> we do</p><pre><code class="language-julia">grpsum = fastby(sum, byvec, valvec)
expected_result = Dict(88 =&gt; 11, 8 =&gt; 3, 888 =&gt; 7)
grpsum == expected_result # true</code></pre><h2><a class="nav-anchor" id="fastby!-with-an-arbitrary-fn-1" href="#fastby!-with-an-arbitrary-fn-1"><code>fastby!</code> with an arbitrary <code>fn</code></a></h2><p>You can also compute arbitrary functions for each by-group e.g. <code>mean</code></p><pre><code class="language-julia">@time a = fastby(mean, x, y)</code></pre><p>This generalizes to arbitrary user-defined functions e.g. the below computes the <code>sizeof</code> each element within each by group</p><pre><code class="language-julia">byvec  = [88   , 888  , 8  , 88  , 888 , 88]
valvec = [&quot;abc&quot;, &quot;def&quot;, &quot;g&quot;, &quot;hi&quot;, &quot;jk&quot;, &quot;lmop&quot;]
@time a = fastby(yy -&gt; sizeof.(yy), x, y);</code></pre><p>Julia&#39;s do-notation can be used</p><pre><code class="language-julia">@time a = fastby(x, y) do grouped_y
    # you can perform complex caculations here knowing that grouped_y is y grouped by x
    grouped_y[end] - grouped_y[1]
end;</code></pre><p>The <code>fastby</code> is fast if group by a vector of <code>Bool</code>&#39;s as well</p><pre><code class="language-julia">using Random
Random.seed!(1)
x = rand(Bool, 100_000_000);
y = rand(100_000_000);

@time fastby(sum, x, y)</code></pre><p>The <code>fastby</code> works on <code>String</code> type as well but is still slower than <code>countmap</code> and uses MUCH more RAM and therefore is <strong>NOT recommended (at this stage)</strong>.</p><pre><code class="language-julia">using Random
const M=10_000_000; const K=100;
Random.seed!(1)
svec1 = rand([string(rand(Char.(32:126), rand(1:8))...) for k in 1:M÷K], M);
y = repeat([1], inner=length(svec1));
@time a = fastby!(sum, svec1, y);

a_dict = Dict(zip(a...))

using StatsBase
@time b = countmap(svec1, alg = :dict);
a_dict == b #true</code></pre><h2><a class="nav-anchor" id="fastby-on-DataFrames-1" href="#fastby-on-DataFrames-1"><code>fastby</code> on <code>DataFrames</code></a></h2><p>One can also apply <code>fastby</code> on <code>DataFrame</code> by supplying the DataFrame as the second argument and its columns using <code>Symbol</code> in the third and fourth argument, being <code>bycol</code> and <code>valcol</code> respectively. For example</p><pre><code class="language-julia">df1 = DataFrame(grps = rand(1:100, 1_000_000), val = rand(1_000_000))
# compute the difference between the number rows in that group and the mean of `val` in that group
res = fastby(val_grouped -&gt; length(val_grouped) - mean(val_grouped), df1, :grps, :val)
# convert to dataframe
resdf = DataFrame(grps = keys(res) |&gt; collect, len_minus_mean_val = values(res) |&gt; collect)</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
