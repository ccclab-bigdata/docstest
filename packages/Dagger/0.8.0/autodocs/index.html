<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Dagger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dagger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.@dbg" href="#Dagger.@dbg"><code>Dagger.@dbg</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Run a block of code only if DEBUG is true</p></div></div></section><pre><code class="language-none">Dagger.@logmsg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.@unimplemented" href="#Dagger.@unimplemented"><code>Dagger.@unimplemented</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@unimplemented fname(&lt;args...&gt;)</code></pre><p>While it is nice to define generic function ad-hoc, it can sometimes get confusing to figure out which method is missing. <code>@interface</code> creates a function which errors out pointing which method is missing.</p></div></div></section><pre><code class="language-none">Dagger.AbstractPart</code></pre><pre><code class="language-none">Dagger.AllocateArray</code></pre><pre><code class="language-none">Dagger.ArrayDomain</code></pre><pre><code class="language-none">Dagger.ArrayOp</code></pre><pre><code class="language-none">Dagger.B</code></pre><pre><code class="language-none">Dagger.BCast</code></pre><pre><code class="language-none">Dagger.BlockPartition</code></pre><pre><code class="language-none">Dagger.BlockedDomains</code></pre><pre><code class="language-none">Dagger.Blocks</code></pre><pre><code class="language-none">Dagger.Bytes</code></pre><pre><code class="language-none">Dagger.CAT</code></pre><pre><code class="language-none">Dagger.Cat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Chunk" href="#Dagger.Chunk"><code>Dagger.Chunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A chunk with some data</p></div></div></section><pre><code class="language-none">Dagger.Computation</code></pre><pre><code class="language-none">Dagger.ComputedArray</code></pre><pre><code class="language-none">Dagger.Concat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Context" href="#Dagger.Context"><code>Dagger.Context</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A context represents a set of processors to use for a papply operation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.DArray" href="#Dagger.DArray"><code>Dagger.DArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DArray{T,N,F}(domain, subdomains, chunks, concat)</code></p><p>An N-dimensional distributed array of element type T.</p><ul><li><code>domain</code>: the whole ArrayDomain of the array</li><li><code>subdomains</code>: a <code>DomainBlocks</code> of the same dimensions as the array</li><li><code>chunks</code>: an array of chunks of dimension N</li><li><code>concat</code>: a function of type <code>F</code>. <code>concat(x, y; dims=d)</code> takes two chunks <code>x</code> and <code>y</code>           and concatenates them along dimension <code>d</code>. <code>cat</code> is used by default.</li></ul></div></div></section><pre><code class="language-none">Dagger.Dagger</code></pre><pre><code class="language-none">Dagger.DaggerBroadcastStyle</code></pre><pre><code class="language-none">Dagger.Distribute</code></pre><pre><code class="language-none">Dagger.DomainBlocks</code></pre><pre><code class="language-none">Dagger.ENABLE_DEBUG</code></pre><pre><code class="language-none">Dagger.Event</code></pre><pre><code class="language-none">Dagger.FileReader</code></pre><pre><code class="language-none">Dagger.FilterLog</code></pre><pre><code class="language-none">Dagger.GB</code></pre><pre><code class="language-none">Dagger.GetIndex</code></pre><pre><code class="language-none">Dagger.GetIndexScalar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.LocalEventLog" href="#Dagger.LocalEventLog"><code>Dagger.LocalEventLog</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>represents a process local events array.</p><p>A context with log_sink set to LocalEventLog() will cause events to be recorded into the </p></div></div></section><pre><code class="language-none">Dagger.MB</code></pre><pre><code class="language-none">Dagger.Map</code></pre><pre><code class="language-none">Dagger.MapChunk</code></pre><pre><code class="language-none">Dagger.MatMul</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.NoOpLog" href="#Dagger.NoOpLog"><code>Dagger.NoOpLog</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Various means of writing an event to something.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.OSProc" href="#Dagger.OSProc"><code>Dagger.OSProc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>OS process - contains pid returned by <code>addprocs</code></p></div></div></section><pre><code class="language-none">Dagger.PARTSPEC</code></pre><pre><code class="language-none">Dagger.PLUGINS</code></pre><pre><code class="language-none">Dagger.PLUGIN_CONFIGS</code></pre><pre><code class="language-none">Dagger.Part</code></pre><pre><code class="language-none">Dagger.Processor</code></pre><pre><code class="language-none">Dagger.ProfilerResult</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.PromotePartition" href="#Dagger.PromotePartition"><code>Dagger.PromotePartition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This is a way of suggesting that stage should call stage_operand with the operation and other arguments</p></div></div></section><pre><code class="language-none">Dagger.ReduceBlock</code></pre><pre><code class="language-none">Dagger.Reducedim</code></pre><pre><code class="language-none">Dagger.Save</code></pre><pre><code class="language-none">Dagger.Scale</code></pre><pre><code class="language-none">Dagger.Sch</code></pre><pre><code class="language-none">Dagger.SetIndex</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.State" href="#Dagger.State"><code>Dagger.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Overall state used during visualization</p></div></div></section><pre><code class="language-none">Dagger.TB</code></pre><pre><code class="language-none">Dagger.Thunk</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Timespan" href="#Dagger.Timespan"><code>Dagger.Timespan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>identifies</p><p>space (category, id) time (timeline, start, finish)</p><p>also tracks gc_num during this and profiling samples.</p></div></div></section><pre><code class="language-none">Dagger.Timestamp</code></pre><pre><code class="language-none">Dagger.Transpose</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.UnitDomain" href="#Dagger.UnitDomain"><code>Dagger.UnitDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Default domain – has no information about the value</p></div></div></section><pre><code class="language-none">Dagger._ctranspose</code></pre><pre><code class="language-none">Dagger._cumlength</code></pre><pre><code class="language-none">Dagger._cumsum</code></pre><pre><code class="language-none">Dagger._dep_message_AbstractPart</code></pre><pre><code class="language-none">Dagger._dep_message_BlockedDomains</code></pre><pre><code class="language-none">Dagger._dep_message_Cat</code></pre><pre><code class="language-none">Dagger._dep_message_ComputedArray</code></pre><pre><code class="language-none">Dagger._dep_message_Part</code></pre><pre><code class="language-none">Dagger._getindex</code></pre><pre><code class="language-none">Dagger._intersect</code></pre><pre><code class="language-none">Dagger._local_event_log</code></pre><pre><code class="language-none">Dagger._merge_sorted</code></pre><pre><code class="language-none">Dagger._mul</code></pre><pre><code class="language-none">Dagger._part_labels</code></pre><pre><code class="language-none">Dagger._promote_array</code></pre><pre><code class="language-none">Dagger._scale</code></pre><pre><code class="language-none">Dagger._stage_cache</code></pre><pre><code class="language-none">Dagger._sum</code></pre><pre><code class="language-none">Dagger.add_gc_diff</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.add_span" href="#Dagger.add_span"><code>Dagger.add_span</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Add a Timespan to a given State under <code>tl</code> (timeline) and <code>category</code>.</p></div></div></section><pre><code class="language-none">Dagger.affinity</code></pre><pre><code class="language-none">Dagger.aggregate_events</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.alignfirst" href="#Dagger.alignfirst"><code>Dagger.alignfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">alignfirst(a)</code></pre><p>Make a subdomain a standalone domain. For example,</p><pre><code class="language-none">alignfirst(ArrayDomain(11:25, 21:100))
# =&gt; ArrayDomain((1:15), (1:80))</code></pre></div></div></section><pre><code class="language-none">Dagger.allslices</code></pre><pre><code class="language-none">Dagger.argname</code></pre><pre><code class="language-none">Dagger.arrayorvcat</code></pre><pre><code class="language-none">Dagger.batchedsplitmerge</code></pre><pre><code class="language-none">Dagger.build_timespans</code></pre><pre><code class="language-none">Dagger.cache_result!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.cached_stage" href="#Dagger.cached_stage"><code>Dagger.cached_stage</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A memoized version of stage. It is important that the tasks generated for the same DArray have the same identity, for example:</p><pre><code class="language-none">A = rand(Blocks(100,100), Float64, 1000, 1000)
compute(A+A&#39;)</code></pre><p>must not result in computation of A twice.</p></div></div></section><pre><code class="language-none">Dagger.chunks</code></pre><pre><code class="language-none">Dagger.chunktype</code></pre><pre><code class="language-none">Dagger.cleanup</code></pre><pre><code class="language-none">Dagger.clear_local_event_log</code></pre><pre><code class="language-none">Dagger.collect_merge</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute" href="#Dagger.compute"><code>Dagger.compute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute a Thunk - creates the DAG, assigns ranks to nodes for tie breaking and runs the scheduler.</p></div></div><div><div><p>A DArray object may contain a thunk in it, in which case we first turn it into a Thunk object and then compute it.</p></div></div></section><pre><code class="language-none">Dagger.cumulative_domains</code></pre><pre><code class="language-none">Dagger.debug_compute</code></pre><pre><code class="language-none">Dagger.default_ord</code></pre><pre><code class="language-none">Dagger.delayed</code></pre><pre><code class="language-none">Dagger.delayedmap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.dependents" href="#Dagger.dependents"><code>Dagger.dependents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>find the set of direct dependents for each task</p></div></div></section><pre><code class="language-none">Dagger.distribute</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.domain" href="#Dagger.domain"><code>Dagger.domain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">domain(x::T)</code></pre><p>Returns metadata about <code>x</code>. This metadata will be in the <code>domain</code> field of a Chunk object when an object of type <code>T</code> is created as the result of evaluating a Thunk.</p></div></div></section><pre><code class="language-none">Dagger.domainchunks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.dsort_chunks" href="#Dagger.dsort_chunks"><code>Dagger.dsort_chunks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dsort_chunks(cs, [nchunks, nsamples]; options...)</code></p><p>Sort contents of chunks (<code>cs</code>) and return a new set of chunks such that the chunks when concatenated return a sorted collection. Each chunk in turn is sorted.</p><p>Args:</p><ul><li><code>nchunks</code> – the number of chunks to produce, regardless of how many chunks were given as input</li><li><code>nsamples</code> – the number of elements to sample from each chunk to guess the splitters (<code>nchunks-1</code> splitters) each chunk will be delimited by the splitter.</li><li><code>merge</code> – a function to merge two sorted collections.</li><li><code>sub</code> – a function to get a subset of the collection takes (collection, range) (defaults to <code>getindex</code>)</li><li><code>order</code> – <code>Base.Sort.Ordering</code> to be used for sorting</li><li><code>batchsize</code> – number of chunks to split and merge at a time (e.g. if there are 128 input chunks and 128 output chunks, and batchsize is 8, then we first sort among batches of 8 chunks – giving 16 batches. Then we sort among the first chunk of the first 8 batches (all elements less than the first splitter), then go on to the first 8 chunks of the second 8 batches, and so on...</li><li><code>chunks_presorted</code> – is each chunk in the input already sorted?</li><li><code>sortandsample</code> – a function to sort a chunk, then sample N elements to infer the splitters. It takes 3 arguments: (collection, N, presorted). presorted is a boolean which is true if the chunk is already sorted.</li></ul><p>Returns a tuple of <code>(chunk, samples)</code> where <code>chunk</code> is the <code>Dagger.Chunk</code> object. <code>chunk</code> can be nothing if no change to the initial array was made (e.g. it was already sorted)</p><ul><li><code>affinities</code> – a list of processes where the output chunks should go. If the length is not equal to <code>nchunks</code> then affinities array is cycled through.</li></ul></div></div></section><pre><code class="language-none">Dagger.empty_prof</code></pre><pre><code class="language-none">Dagger.eval</code></pre><pre><code class="language-none">Dagger.fnbody</code></pre><pre><code class="language-none">Dagger.free!</code></pre><pre><code class="language-none">Dagger.free_chunks</code></pre><pre><code class="language-none">Dagger.gather</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.get_logs!" href="#Dagger.get_logs!"><code>Dagger.get_logs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the logs from each process, clear it too</p></div></div></section><pre><code class="language-none">Dagger.get_type</code></pre><pre><code class="language-none">Dagger.getmedians</code></pre><pre><code class="language-none">Dagger.getsub</code></pre><pre><code class="language-none">Dagger.getvarname</code></pre><pre><code class="language-none">Dagger.group_indices</code></pre><pre><code class="language-none">Dagger.include</code></pre><pre><code class="language-none">Dagger.indexes</code></pre><pre><code class="language-none">Dagger.inputs</code></pre><pre><code class="language-none">Dagger.isasync</code></pre><pre><code class="language-none">Dagger.istask</code></pre><pre><code class="language-none">Dagger.kB</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.load" href="#Dagger.load"><code>Dagger.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load(ctx, file_path)</code></pre><p>Load an Union{Chunk, Thunk} from a file.</p></div></div><div><div><pre><code class="language-none">load(ctx, ::Type{Chunk}, fpath, io)</code></pre><p>Load a Chunk object from a file, the file path is required for creating a FileReader object</p></div></div></section><pre><code class="language-none">Dagger.lookup_parts</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.make_timespan" href="#Dagger.make_timespan"><code>Dagger.make_timespan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>create a timespan given the strt and finish events</p></div></div></section><pre><code class="language-none">Dagger.mapchunk</code></pre><pre><code class="language-none">Dagger.mappart</code></pre><pre><code class="language-none">Dagger.mapreducebykey_seq</code></pre><pre><code class="language-none">Dagger.merge_cumsums</code></pre><pre><code class="language-none">Dagger.merge_reducebykey</code></pre><pre><code class="language-none">Dagger.merge_sorted</code></pre><pre><code class="language-none">Dagger.mix_samples</code></pre><pre><code class="language-none">Dagger.mul_size</code></pre><pre><code class="language-none">Dagger.next_id</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.next_state" href="#Dagger.next_state"><code>Dagger.next_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>When building state for real-time visualization, use next_state to progress gantt state.</p></div></div></section><pre><code class="language-none">Dagger.node_id</code></pre><pre><code class="language-none">Dagger.node_label</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.noffspring" href="#Dagger.noffspring"><code>Dagger.noffspring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>recursively find the number of taks dependent on each task in the DAG. Input: dependents dict</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.order" href="#Dagger.order"><code>Dagger.order</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a root node of the DAG, calculates a total order for tie-braking</p><ul><li>Root node gets score 1,</li><li>rest of the nodes are explored in DFS fashion but chunks of each node are explored in order of <code>noffspring</code>, i.e. total number of tasks depending on the result of the said node.</li></ul><p>Args:     - node: root node     - ndeps: result of <code>noffspring</code></p></div></div></section><pre><code class="language-none">Dagger.part</code></pre><pre><code class="language-none">Dagger.partition</code></pre><pre><code class="language-none">Dagger.partition_sparse</code></pre><pre><code class="language-none">Dagger.parts</code></pre><pre><code class="language-none">Dagger.parttype</code></pre><pre><code class="language-none">Dagger.persist!</code></pre><pre><code class="language-none">Dagger.project</code></pre><pre><code class="language-none">Dagger.promote_distribution</code></pre><pre><code class="language-none">Dagger.propagate_affinity!</code></pre><pre><code class="language-none">Dagger.pushkey</code></pre><pre><code class="language-none">Dagger.raise_event</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.recursive_splitters" href="#Dagger.recursive_splitters"><code>Dagger.recursive_splitters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>split the splitters themselves into batches.</p><p>Args:</p><ul><li><code>ord</code> – <code>Sorting.Ordering</code> object</li><li><code>splitters</code> – the <code>nchunks-1</code> splitters</li><li><code>batchsize</code> – batch size</li></ul><p>Returns: A Tuple{Vector, Vector{Vector}} – the coarse splitters which create <code>batchsize</code> splits, finer splitters within those batches which create a total of <code>nchunks</code> splits.</p><pre><code class="language-julia">julia&gt; Dagger.recursive_splitters(Dagger.default_ord,
            [10,20,30,40,50,60], 5,3)
([30], Any[[10, 20], [40, 50, 60]])</code></pre><p>The first value <code>[30]</code> represents a coarse split that cuts the dataset from -Inf-30, and 30-Inf. Each part is further recursively split using the next set of splitters</p></div></div></section><pre><code class="language-none">Dagger.reduce_async</code></pre><pre><code class="language-none">Dagger.reduceblock</code></pre><pre><code class="language-none">Dagger.reduceblock_async</code></pre><pre><code class="language-none">Dagger.reducebykey</code></pre><pre><code class="language-none">Dagger.reducebykey_seq</code></pre><pre><code class="language-none">Dagger.reduced_dims</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save" href="#Dagger.save"><code>Dagger.save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">save(io::IO, val)</code></pre><p>Save a value into the IO buffer. In the case of arrays and sparse matrices, this will save it in a memory-mappable way.</p><p><code>load(io::IO, t::Type, domain)</code> will load the object given its domain</p></div></div><div><div><pre><code class="language-none">save(ctx, chunk::Union{Chunk, Thunk}, file_path::AbsractString)</code></pre><p>Save a chunk to a file at <code>file_path</code>.</p></div></div><div><div><p>special case distmem writing - write to disk on the process with the chunk.</p></div></div></section><pre><code class="language-none">Dagger.savechunk</code></pre><pre><code class="language-none">Dagger.scale</code></pre><pre><code class="language-none">Dagger.setindex</code></pre><pre><code class="language-none">Dagger.shouldpersist</code></pre><pre><code class="language-none">Dagger.show_ast</code></pre><pre><code class="language-none">Dagger.show_plan</code></pre><pre><code class="language-none">Dagger.show_statement</code></pre><pre><code class="language-none">Dagger.showfn</code></pre><pre><code class="language-none">Dagger.showloc</code></pre><pre><code class="language-none">Dagger.sortandsample_array</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.split_range" href="#Dagger.split_range"><code>Dagger.split_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Utility function to divide the range <code>range</code> into <code>n</code> chunks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.split_range_interval" href="#Dagger.split_range_interval"><code>Dagger.split_range_interval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">split_range_interval(range, n)</code></pre><p>split a range into pieces each of length <code>n</code> or lesser</p></div></div></section><pre><code class="language-none">Dagger.splitchunk</code></pre><pre><code class="language-none">Dagger.splitmerge</code></pre><pre><code class="language-none">Dagger.stage</code></pre><pre><code class="language-none">Dagger.stage_operand</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.stage_operands" href="#Dagger.stage_operands"><code>Dagger.stage_operands</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>an operand which should be distributed as per convenience</p></div></div></section><pre><code class="language-none">Dagger.summarize_events</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.thunkize" href="#Dagger.thunkize"><code>Dagger.thunkize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If a DArray tree has a Thunk in it, make the whole thing a big thunk</p></div></div></section><pre><code class="language-none">Dagger.timespan_end</code></pre><pre><code class="language-none">Dagger.timespan_start</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.tochunk" href="#Dagger.tochunk"><code>Dagger.tochunk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Create a chunk from a sequential object.</p></div></div></section><pre><code class="language-none">Dagger.transpose_vecvec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.treereduce" href="#Dagger.treereduce"><code>Dagger.treereduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Tree reduce</p></div></div></section><pre><code class="language-none">Dagger.treereduce_nd</code></pre><pre><code class="language-none">Dagger.treereducedim</code></pre><pre><code class="language-none">Dagger.unrelease</code></pre><pre><code class="language-none">Dagger.use_shared_array</code></pre><pre><code class="language-none">Dagger.write_dag</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.write_event" href="#Dagger.write_event"><code>Dagger.write_event</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Write a log event</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
