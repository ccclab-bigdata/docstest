<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· WriteVTK.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>WriteVTK.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage:-rectilinear-and-structured-meshes-1">Usage: rectilinear and structured meshes</a></li><li><a class="toctext" href="#Usage:-image-data-1">Usage: image data</a></li><li><a class="toctext" href="#Usage:-julia-array-1">Usage: julia array</a></li><li><a class="toctext" href="#Usage:-unstructured-meshes-1">Usage: unstructured meshes</a></li><li><a class="toctext" href="#Multiblock-files-1">Multiblock files</a></li><li><a class="toctext" href="#Paraview-Data-(PVD)-file-format-1">Paraview Data (PVD) file format</a></li><li><a class="toctext" href="#Do-block-syntax-1">Do-block syntax</a></li><li><a class="toctext" href="#Additional-options-1">Additional options</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="WriteVTK-1" href="#WriteVTK-1">WriteVTK</a></h1><p><a href="https://travis-ci.org/jipolanco/WriteVTK.jl"><img src="https://travis-ci.org/jipolanco/WriteVTK.jl.svg?branch=master" alt="Build Status"/></a></p><p>This module allows to write VTK XML files, that can be visualised for example with <a href="http://www.paraview.org/">ParaView</a>.</p><p>The data is written compressed by default, using the <a href="https://github.com/bicycle1885/CodecZlib.jl">CodecZlib</a> package.</p><p>Rectilinear (.vtr), structured (.vts), image data (.vti) and unstructured (.vtu) grids are supported. Multiblock files (.vtm), which can point to multiple VTK files, can also be exported.</p><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#installation">Installation</a></li><li><a href="#usage-rectilinear-and-structured-meshes">Rectilinear and structured meshes</a></li><li><a href="#usage-image-data">Image data</a></li><li><a href="#usage-julia-array">Julia array</a></li><li><a href="#usage-unstructured-meshes">Unstructured meshes</a></li><li><a href="#multiblock-files">Multiblock files</a></li><li><a href="#paraview-data-pvd-file-format">Paraview PVD files</a></li><li><a href="#do-block-syntax">Do-block syntax</a></li><li><a href="#additional-options">Additional options</a></li><li><a href="#examples">Examples</a></li></ul><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>From the Julia REPL:</p><pre><code class="language-julia">Pkg.add(&quot;WriteVTK&quot;)</code></pre><p>Then load the module in Julia with:</p><pre><code class="language-julia">using WriteVTK</code></pre><h2><a class="nav-anchor" id="Usage:-rectilinear-and-structured-meshes-1" href="#Usage:-rectilinear-and-structured-meshes-1">Usage: rectilinear and structured meshes</a></h2><h3><a class="nav-anchor" id="Define-a-grid-1" href="#Define-a-grid-1">Define a grid</a></h3><p>The function <code>vtk_grid</code> initialises the VTK file. This function requires a filename with no extension, and the grid coordinates. Depending on the shape of the arrays <code>x</code>, <code>y</code> and <code>z</code>, either a rectilinear or structured grid is created.</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, x, y, z) # 3-D
vtkfile = vtk_grid(&quot;my_vtk_file&quot;, x, y)    # 2-D</code></pre><p>Required array shapes for each grid type:</p><ul><li>Rectilinear grid: <code>x</code>, <code>y</code>, <code>z</code> are 1-D arrays with different lengths in general (<code>Ni</code>, <code>Nj</code> and <code>Nk</code> respectively).</li><li>Structured grid: <code>x</code>, <code>y</code>, <code>z</code> are 3-D arrays with the same shape: <code>[Ni, Nj, Nk]</code>. For the two dimensional case, <code>x</code> and <code>y</code> are 2-D arrays with shape <code>[Ni, Nj]</code></li></ul><p>Alternatively, in the case of structured grids, the grid points can be defined from a single 4-D array <code>xyz</code>, of dimensions <code>[3, Ni, Nj, Nk]</code>. For the two dimensional case <code>xy</code> is a 3-D array, with dimensions <code>[2, Ni, Nj]</code>:</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, xyz) # 3-D
vtkfile = vtk_grid(&quot;my_vtk_file&quot;, xy)  # 2-D</code></pre><p>This is actually more efficient than the previous formulation.</p><h3><a class="nav-anchor" id="Add-some-data-to-the-file-1" href="#Add-some-data-to-the-file-1">Add some data to the file</a></h3><p>The function <code>vtk_point_data</code> adds point data to the file. The required input is a VTK file object created by <code>vtk_grid</code>, an array and a string:</p><pre><code class="language-julia">vtk_point_data(vtkfile, p, &quot;Pressure&quot;)
vtk_point_data(vtkfile, C, &quot;Concentration&quot;)
vtk_point_data(vtkfile, vel, &quot;Velocity&quot;)</code></pre><p>The array can represent either scalar or vectorial data. The shape of the array should be <code>[Ni, Nj, Nk]</code> for scalars, and <code>[Ncomp, Ni, Nj, Nk]</code> for vectors, where <code>Ncomp</code> is the number of components of the vector.</p><p>Vector datasets can also be given as a tuple of scalar datasets, where each scalar represents a component of the vector field. Example:</p><pre><code class="language-julia">acc = (acc_x, acc_y, acc_z)  # acc_x, acc_y and acc_z have size [Ni, Nj, Nk]
vtk_point_data(vtkfile, acc, &quot;Acceleration&quot;)</code></pre><p>This can be useful to avoid copies of data in some cases.</p><p>Cell data can also be added, using <code>vtk_cell_data</code>:</p><pre><code class="language-julia">vtk_cell_data(vtkfile, T, &quot;Temperature&quot;)</code></pre><p>Note that in rectilinear and structured meshes, the cell resolution is always <code>[Ni-1, Nj-1, Nk-1]</code>, and the dimensions of the data arrays should be consistent with that resolution.</p><h3><a class="nav-anchor" id="Save-the-file-1" href="#Save-the-file-1">Save the file</a></h3><p>Finally, close and save the file with <code>vtk_save</code>:</p><pre><code class="language-julia">outfiles = vtk_save(vtkfile)</code></pre><p><code>outfiles</code> is an array of strings with the paths to the generated files. In this case, the array is of length 1, but that changes when working with <a href="#multiblock-files">multiblock files</a>.</p><h2><a class="nav-anchor" id="Usage:-image-data-1" href="#Usage:-image-data-1">Usage: image data</a></h2><p>The points and cells of an image data file are defined by the number of points in each direction, <code>(Nx, Ny, Nz)</code>. The origin of the dataset and the spacing in each direction can be optionally included. Example:</p><pre><code class="language-julia">Nx, Ny, Nz = 10, 12, 42
origin = [3.0, 4.0, -3.2]
spacing = [0.1, 0.2, 0.3]
vtk = vtk_grid(&quot;my_vti_file&quot;, Nx, Ny, Nz, origin=origin, spacing=spacing)
vtk_save(vtk)</code></pre><h2><a class="nav-anchor" id="Usage:-julia-array-1" href="#Usage:-julia-array-1">Usage: julia array</a></h2><p>A convenience function is provided to quickly save Julia arrays as image data:</p><pre><code class="language-julia">A = rand(100, 100, 100)
vtk_write_array(&quot;my_vti_file&quot;, A, &quot;my_property_name&quot;)</code></pre><h2><a class="nav-anchor" id="Usage:-unstructured-meshes-1" href="#Usage:-unstructured-meshes-1">Usage: unstructured meshes</a></h2><p>An unstructured mesh is defined by a set of points in space and a set of cells that connect those points.</p><h3><a class="nav-anchor" id="Defining-cells-1" href="#Defining-cells-1">Defining cells</a></h3><p>In WriteVTK, a cell is defined using the MeshCell type:</p><pre><code class="language-julia">cell = MeshCell(cell_type, connectivity)</code></pre><ul><li><p><code>cell_type</code> is of type <code>VTKCellType</code> which contains the name and an integer value that determines the type of the cell, as defined in the <a href="http://www.vtk.org/VTK/img/file-formats.pdf">VTK specification</a> (see figures 2 and 3 in that document). For convenience, WriteVTK includes a <code>VTKCellTypes</code> module that contains these definitions. For instance, a triangle is associated to the value <code>cell_type = VTKCellTypes.VTK_TRIANGLE</code>.</p></li><li><p><code>connectivity</code> is a vector of indices that determine the mesh points that are connected by the cell. In the case of a triangle, this would be an integer array of length 3.</p><p>Note that the connectivity indices are one-based (as opposed to <a href="https://en.wikipedia.org/wiki/Zero-based_numbering">zero-based</a>), following the convention in Julia.</p></li></ul><h3><a class="nav-anchor" id="Generating-an-unstructured-VTK-file-1" href="#Generating-an-unstructured-VTK-file-1">Generating an unstructured VTK file</a></h3><p>First, initialise the file:</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, points, cells)</code></pre><ul><li><p><code>points</code> is an array with the point locations, of dimensions <code>[dim, num_points]</code> where <code>dim</code> is the dimension (1, 2 or 3) and <code>num_points</code> the number of points.</p></li><li><p><code>cells</code> is a MeshCell array that contains all the cells of the mesh. For example:</p><pre><code class="language-julia"># Suppose that the mesh is made of 5 points:
cells = [MeshCell(VTKCellTypes.VTK_TRIANGLE, [1, 4, 2]),
         MeshCell(VTKCellTypes.VTK_QUAD,     [2, 4, 3, 5])]</code></pre></li></ul><p>Alternatively, the grid points can be defined from 1-D arrays <code>x</code>, <code>y</code>, <code>z</code> with equal lengths <code>num_points</code>:</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, x, y, z, cells) # 3D
vtkfile = vtk_grid(&quot;my_vtk_file&quot;, x, y, cells)    # 2D
vtkfile = vtk_grid(&quot;my_vtk_file&quot;, x, cells)       # 1D</code></pre><p>or from a 4-D array <code>points</code>, with dimension <code>[dim, Ni, Nj, Nk]</code> where <code>dim</code> is the dimension and <code>Ni</code>,<code>Nj</code>,<code>Nk</code> the number of points in each direction <code>x</code>,<code>y</code>,<code>z</code>:</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, points, cells)</code></pre><p>These two last methods are less efficient though.</p><p>Now add some data to the file. It is possible to add both point data and cell data:</p><pre><code class="language-julia">vtk_point_data(vtkfile, pdata, &quot;my_point_data&quot;)
vtk_cell_data(vtkfile, cdata, &quot;my_cell_data&quot;)</code></pre><p>The <code>pdata</code> and <code>cdata</code> arrays must have sizes consistent with the number of points and cells in the mesh, respectively. The arrays can contain scalar and vectorial data (see <a href="#add-some-data-to-the-file">here</a>).</p><p>Finally, close and save the file:</p><pre><code class="language-julia">outfiles = vtk_save(vtkfile)</code></pre><h2><a class="nav-anchor" id="Multiblock-files-1" href="#Multiblock-files-1">Multiblock files</a></h2><p>Multiblock files (.vtm) are XML VTK files that can point to multiple other VTK files. They can be useful when working with complex geometries that are composed of multiple sub-domains. In order to generate multiblock files, the <code>vtk_multiblock</code> function must be used. The functions introduced above are then used with some small modifications.</p><p>First, a multiblock file must be initialised:</p><pre><code class="language-julia">vtmfile = vtk_multiblock(&quot;my_vtm_file&quot;)</code></pre><p>Then, each sub-grid can be generated with <code>vtk_grid</code> using the <code>vtmfile</code> object as the first argument:</p><pre><code class="language-julia"># First block.
vtkfile = vtk_grid(vtmfile, x1, y1, z1)
vtk_point_data(vtkfile, p1, &quot;Pressure&quot;)

# Second block.
vtkfile = vtk_grid(vtmfile, x2, y2, z2)
vtk_point_data(vtkfile, p2, &quot;Pressure&quot;)</code></pre><p>Finally, only the multiblock file needs to be saved explicitly:</p><pre><code class="language-julia">outfiles = vtk_save(vtmfile)</code></pre><p>Assuming that the two blocks are structured grids, this generates the files <code>my_vtm_file.vtm</code>, <code>my_vtm_file.z01.vts</code> and <code>my_vtm_file.z02.vts</code>, where the <code>vtm</code> file points to the two <code>vts</code> files.</p><h2><a class="nav-anchor" id="Paraview-Data-(PVD)-file-format-1" href="#Paraview-Data-(PVD)-file-format-1">Paraview Data (PVD) file format</a></h2><p>A <code>pvd</code> file is a collection of VTK files, typically for holding results at different time steps in a simulation. A <code>pvd</code> file is initialised with:</p><pre><code class="language-julia">pvd = paraview_collection(&quot;my_pvd_file&quot;)</code></pre><p>VTK files are then added to the <code>pvd</code> file with</p><pre><code class="language-julia">collection_add_timestep(pvd, vtkfile, time)</code></pre><p>Here, <code>time</code> is a number that represents the current time (or step) in the simulation. When all the files are added to the <code>pvd</code> file, it can be saved using:</p><pre><code class="language-julia">vtk_save(pvd)</code></pre><h2><a class="nav-anchor" id="Do-block-syntax-1" href="#Do-block-syntax-1">Do-block syntax</a></h2><p><a href="http://docs.julialang.org/en/release-0.5/manual/functions/#do-block-syntax-for-function-arguments">Do-block syntax</a> is supported by <code>vtk_grid</code>, <code>vtk_multiblock</code> and <code>paraview_collection</code>. At the end of the do-block, <code>vtk_save</code> is called implicitly on the generated VTK object. Example:</p><pre><code class="language-julia"># Rectilinear or structured grid
outfiles = vtk_grid(&quot;my_vtk_file&quot;, x, y, z) do vtk
    vtk_point_data(vtk, p, &quot;Pressure&quot;)
    vtk_point_data(vtk, vel, &quot;Velocity&quot;)
end

# Multiblock file
outfiles = vtk_multiblock(&quot;my_vtm_file&quot;) do vtm
    vtk = vtk_grid(vtm, x1, y1, z1)
    vtk_point_data(vtk, vel1, &quot;Velocity&quot;)

    vtk = vtk_grid(vtm, x2, y2, z2)
    vtk_point_data(vtk, vel2, &quot;Velocity&quot;)
end</code></pre><h2><a class="nav-anchor" id="Additional-options-1" href="#Additional-options-1">Additional options</a></h2><p>By default, numerical data is written to the XML files as compressed raw binary data. This can be changed using the optional <code>compress</code> and <code>append</code> parameters of the <code>vtk_grid</code> functions.</p><p>For instance, to disable both compressing and appending raw data in the case of unstructured meshes:</p><pre><code class="language-julia">vtkfile = vtk_grid(&quot;my_vtk_file&quot;, points, cells; compress=false, append=false)</code></pre><ul><li><p>If <code>append</code> is <code>true</code> (default), data is written appended at the end of the XML file as raw binary data. Note that this violates the XML specification, although it is allowed by VTK.</p><p>Otherwise, if <code>append</code> is <code>false</code>, data is written &quot;inline&quot;, and base-64 encoded instead of raw. This is usually slower than writing raw binary data, and also results in larger files, but is valid according to the XML specification.</p></li><li><p>If <code>compress</code> is <code>true</code> (default), data is first compressed using zlib. Its value may also be a compression level between 1 (fast compression) and 9 (best compression).</p></li></ul><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>See some examples in the <code>test/</code> directory.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
