<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · DimArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DimArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DimArrays.jl-1" href="#DimArrays.jl-1">DimArrays.jl</a></h1><p>This packages provides Julia arrays with named dimensions.  Like the built-in Array type these are mutable objects,  unlike <a href="https://github.com/davidavdav/NamedArrays.jl">NamedArrays</a> and <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays</a> which are immutable. </p><p>The idea was to have a convenient way to gather results of calculations in a script or notebook, rather than for anything high-performance.  For example, here I have a matrix of results at each iteration, and <code>nest</code> these into a 3-tensor, whose axis order I need not remember:</p><pre><code class="language-julia">using DimArrays

list = [];
for i=1:33
    slowcalc = sqrt(i) .* randn(3,13) .+ i
    push!(list, DimArray(slowcalc, :a, :b, :c ))  # add labels for 1st and 2nd dimensions  
end

list3 = nest(list, :iter)   # now i is the 3rd index, and named &quot;iter&quot;

using Statistics

mean(list3, dims=:iter)     # equivalent to dropdims(mean(list3, dims=3), dims=3)</code></pre><p>For quick plots, dimension names are used for axes and series: </p><pre><code class="language-julia">using Plots

plot(selectdim(list3, :b, 1)&#39; , legend=:bottomright)</code></pre><p>Here <code>selectdim(list3, :b, 1) == list3[:,1,:]</code> in contents, but retains the labels.</p><p>Besides each dimension&#39;s name (which is a Symbol, strings will be converted) it can also store a function, which is used in plotting to scale the axes etc.  (But only the output, <code>getindex</code> uses original integer indices). You can pass a number by which to scale the index, or a dictionary, instead of a function.</p><p>For example, this plots data saved every 4 iterations correctly over the above example:</p><pre><code class="language-julia">saveevery = 4
list4 = DimArray([], :iter, saveevery);     # equivalent to function  i-&gt;4i
for i=1:33
    slowcalc = sqrt(i) .* randn(3,23) .+ i
    slownice = DimArray(slowcalc, [:a, :b], [Dict(1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;, 3=&gt;&quot;three&quot;)], :stuff )
                                            # equivalent to  i-&gt;Dict(...)[i]
    rem(i,saveevery)==0 &amp;&amp; push!(list4, slownice)
end
nest(list4)

plot!(mean(nest(list4), dims=:b)&#39;, s=:dash)</code></pre><p>If you do not provide a name for a dimension (or give an empty string &quot;&quot;)  then you can still refer to it by default names like <code>size(x, :row) == size(x,1)</code> or <code>maximum(y, :col)</code> etc.  However these defaults are not stored, and not manipulated by <code>transpose(x)</code> or <code>kron(x,y)</code>.</p><p>For now, the list of functions supported is:</p><ul><li><code>DimArray</code>, <code>DimVector</code>, <code>DimMatrix</code> create one, taking names and functions for dimensions in the order given.</li><li><code>dictvector</code> defines a DimVector whose function is a Dict. </li><li><code>nest</code> converts arrays of arrays, and <code>squeeze</code> drops dimensions of size 1. </li></ul><p>and these built-in functions:</p><ul><li><code>selectdim, size</code> understand a dimension&#39;s name.</li><li><code>sum, maximum, minimum, dropdims</code> and <code>Statistics.mean, std</code>: all can be called with a dimension&#39;s name, in which case by default <code>squeeze=true</code> on that dimension, like <code>mean(..., dims=:b)</code> above.   They can also be called with a list of dimensions: <code>sum(x, dims=[1,:c])</code> etc.</li><li><code>push!, append!, hcat, vcat, transpose, ctranspose, permutedims</code>.</li><li>Matrix multiplication <code>*</code> will warn (once) if you multiply along directions with mismatched names... which may be a terrible idea.   And <code>kron</code>ecker products produce new names like <code>:a_b</code>.  </li><li><code>collect</code>, implicitly used by comprehensions like <code>[ sqrt(n) for n in DimVector(1:10, &quot;int&quot;)&#39; ]</code> which thus inherit the names of the array being iterated over.</li></ul><p>Since <code>DimArray &lt;: AbstractArray</code> anything else will fall back on their methods, and forget the dimension labels. </p><p>See also:</p><ul><li><a href="https://github.com/davidavdav/NamedArrays.jl">NamedArrays</a></li><li><a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays</a></li><li><a href="https://github.com/JuliaDiffEq/RecursiveArrayTools.jl">RecursiveArrayTools</a></li><li><a href="https://github.com/bramtayl/JuliennedArrays.jl">JuliennedArrays</a></li></ul><p>ToDo:</p><ul><li>Make things like <code>x[:, 1:10:end]</code> and <code>hcat(a,b)</code> update the functions correctly.</li><li>Figure out Julia 0.7&#39;s new broadcasting machinery.</li></ul><p>Michael Abbott, January 2018, mostly (as I had a grant to write).</p><p><a href="https://travis-ci.org/mcabbott/DimArrays.jl"><img src="https://travis-ci.org/mcabbott/DimArrays.jl.svg?branch=master" alt="Build Status"/></a></p><p>&lt;!– <a href="https://coveralls.io/github/mcabbott/DimArrays.jl?branch=master"><img src="https://coveralls.io/repos/mcabbott/DimArrays.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a> <a href="http://codecov.io/github/mcabbott/DimArrays.jl?branch=master"><img src="http://codecov.io/github/mcabbott/DimArrays.jl/coverage.svg?branch=master" alt="codecov.io"/></a> –&gt; </p><p>&lt;!– Note to self: pandoc -o README.html README.md –&gt;</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
