<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · RigidBodyDynamics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodyDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.@framecheck" href="#RigidBodyDynamics.Spatial.@framecheck"><code>RigidBodyDynamics.Spatial.@framecheck</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Check that <code>CartesianFrame3D</code> <code>f1</code> is one of <code>f2s</code>.</p><p>Note that if <code>f2s</code> is a <code>CartesianFrame3D</code>, then <code>f1</code> and <code>f2s</code> are simply checked for equality.</p><p>Throws an <code>ArgumentError</code> if <code>f1</code> is not among <code>f2s</code> when bounds checks are enabled. <code>@framecheck</code> is a no-op when bounds checks are disabled.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.@indextype</code></pre><pre><code class="language-none">RigidBodyDynamics.@modcountcheck</code></pre><pre><code class="language-none">RigidBodyDynamics.AbstractTypeDict</code></pre><pre><code class="language-none">RigidBodyDynamics.BodyCacheDict</code></pre><pre><code class="language-none">RigidBodyDynamics.BodyDict</code></pre><pre><code class="language-none">RigidBodyDynamics.BodyID</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Bounds" href="#RigidBodyDynamics.Bounds"><code>RigidBodyDynamics.Bounds</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Bounds{T}</code></pre><p>Bounds is a scalar-like type representing a closed interval from <span>$lower$</span> to <span>$upper$</span>. To indicate that a vector of values falls with some range, use a <span>$Vector{Bounds{T}}$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.CartesianFrame3D" href="#RigidBodyDynamics.Spatial.CartesianFrame3D"><code>RigidBodyDynamics.Spatial.CartesianFrame3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct CartesianFrame3D</code></pre><p>A <code>CartesianFrame3D</code> identifies a three-dimensional Cartesian coordinate system.</p><p><code>CartesianFrame3D</code>s are typically used to annotate the frame in which certain quantities are expressed.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.Contact</code></pre><pre><code class="language-none">RigidBodyDynamics.CustomCollections</code></pre><pre><code class="language-none">RigidBodyDynamics.DEFAULT_GRAVITATIONAL_ACCELERATION</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.DynamicsResult" href="#RigidBodyDynamics.DynamicsResult"><code>RigidBodyDynamics.DynamicsResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct DynamicsResult{T, M}</code></pre><p>Stores variables related to the dynamics of a <code>Mechanism</code>, e.g. the <code>Mechanism</code>&#39;s mass matrix and joint acceleration vector.</p><p>Type parameters:</p><ul><li><code>T</code>: the scalar type of the dynamics-related variables.</li><li><code>M</code>: the scalar type of the <code>Mechanism</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.DynamicsResultCache" href="#RigidBodyDynamics.DynamicsResultCache"><code>RigidBodyDynamics.DynamicsResultCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DynamicsResultCache{M} &lt;: RigidBodyDynamics.AbstractTypeDict</code></pre><p>A container that manages the creation and storage of <a href="#RigidBodyDynamics.DynamicsResult"><code>DynamicsResult</code></a> objects of various scalar types, associated with a given <code>Mechanism</code>. Similar to <a href="#RigidBodyDynamics.StateCache"><code>StateCache</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Fixed" href="#RigidBodyDynamics.Fixed"><code>RigidBodyDynamics.Fixed</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Fixed{T} &lt;: JointType{T}</code></pre><p>The <code>Fixed</code> joint type is a degenerate joint type, in the sense that it allows no motion between its predecessor and successor rigid bodies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.FreeVector3D" href="#RigidBodyDynamics.Spatial.FreeVector3D"><code>RigidBodyDynamics.Spatial.FreeVector3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct FreeVector3D{V&lt;:(AbstractArray{T,1} where T)}</code></pre><p>A <code>FreeVector3D</code> represents a <a href="https://en.wikipedia.org/wiki/Euclidean_vector#Overview">free vector</a>.</p><p>Examples of free vectors include displacements and velocities of points.</p><p>Applying a <code>Transform3D</code> to a <code>FreeVector3D</code> only rotates the <code>FreeVector3D</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.GeometricJacobian" href="#RigidBodyDynamics.Spatial.GeometricJacobian"><code>RigidBodyDynamics.Spatial.GeometricJacobian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GeometricJacobian{A&lt;:(AbstractArray{T,2} where T)}</code></pre><p>A geometric Jacobian (also known as basic, or spatial Jacobian) maps a vector of joint velocities to a twist.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.Graphs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Joint" href="#RigidBodyDynamics.Joint"><code>RigidBodyDynamics.Joint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Joint{T, JT&lt;:JointType{T}}</code></pre><p>A joint represents a kinematic restriction of the relative twist between two rigid bodies to a linear subspace of dimension <span>$k$</span>.</p><p>A joint has a direction. The rigid body before the joint is called the joint&#39;s predecessor, and the rigid body after the joint is its successor.</p><p>The state related to the joint is parameterized by two sets of variables, namely</p><ul><li>a vector <span>$q \in \mathcal{Q}$</span>, parameterizing the relative homogeneous transform.</li><li>a vector <span>$v \in \mathbb{R}^k$</span>, parameterizing the relative twist.</li></ul><p>The twist of the successor with respect to the predecessor is a linear function of <span>$v$</span>.</p><p>For some joint types (notably those using a redundant representation of relative orientation, such as a unit quaternion), <span>$\dot{q}$</span>, the time derivative of <span>$q$</span>, may not be the same as <span>$v$</span>. However, an invertible linear transformation exists between <span>$\dot{q}$</span> and <span>$v$</span>.</p><p>See also:</p><ul><li>Definition 2.9 in Duindam, &quot;Port-Based Modeling and Control for Efficient Bipedal Walking Robots&quot;, 2006.</li><li>Section 4.4 of Featherstone, &quot;Rigid Body Dynamics Algorithms&quot;, 2008.</li></ul></div></div></section><pre><code class="language-none">RigidBodyDynamics.JointCacheDict</code></pre><pre><code class="language-none">RigidBodyDynamics.JointDict</code></pre><pre><code class="language-none">RigidBodyDynamics.JointID</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.JointType" href="#RigidBodyDynamics.JointType"><code>RigidBodyDynamics.JointType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type JointType</code></pre><p>The abstract supertype of all concrete joint types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Mechanism" href="#RigidBodyDynamics.Mechanism"><code>RigidBodyDynamics.Mechanism</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct Mechanism{T}</code></pre><p>A <code>Mechanism</code> represents an interconnection of rigid bodies and joints. <code>Mechanism</code>s store the joint layout and inertia parameters, but no state-dependent information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.MechanismState" href="#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct MechanismState{X, M, C, JointCollection}</code></pre><p>A <code>MechanismState</code> stores state information for an entire <code>Mechanism</code>. It contains the joint configuration and velocity vectors <span>$q$</span> and <span>$v$</span>, and a vector of additional states <span>$s$</span>. In addition, it stores cache variables that depend on <span>$q$</span> and <span>$v$</span> and are aimed at preventing double work.</p><p>Type parameters:</p><ul><li><code>X</code>: the scalar type of the <span>$q$</span>, <span>$v$</span>, and <span>$s$</span> vectors.</li><li><code>M</code>: the scalar type of the <code>Mechanism</code></li><li><code>C</code>: the scalar type of the cache variables (<code>== promote_type(X, M)</code>)</li><li><code>JointCollection</code>: the type of the <code>treejoints</code> and <code>nontreejoints</code> members (a <code>TypeSortedCollection</code> subtype)</li></ul></div></div></section><pre><code class="language-none">RigidBodyDynamics.ModificationCountMismatch</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.Momentum" href="#RigidBodyDynamics.Spatial.Momentum"><code>RigidBodyDynamics.Spatial.Momentum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Momentum{T}</code></pre><p>A <code>Momentum</code> is the product of a <code>SpatialInertia</code> and a <code>Twist</code>, i.e.</p><div>\[h^i =
\left(\begin{array}{c}
k^{i}\\
l^{i}
\end{array}\right) =
I^i T^{i, j}_k\]</div><p>where <span>$I^i$</span> is the spatial inertia of a given body expressed in frame <span>$i$</span>, and <span>$T^{i, j}_k$</span> is the twist of frame <span>$k$</span> (attached to the body) with respect to inertial frame <span>$j$</span>, expressed in frame <span>$i$</span>. <span>$k^i$</span> is the angular momentum and <span>$l^i$</span> is the linear momentum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.MomentumMatrix" href="#RigidBodyDynamics.Spatial.MomentumMatrix"><code>RigidBodyDynamics.Spatial.MomentumMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct MomentumMatrix{A&lt;:(AbstractArray{T,2} where T)}</code></pre><p>A momentum matrix maps a joint velocity vector to momentum.</p><p>This is a slight generalization of the centroidal momentum matrix (Orin, Goswami, &quot;Centroidal momentum matrix of a humanoid robot: Structure and properties.&quot;) in that the matrix (and hence the corresponding total momentum) need not be expressed in a centroidal frame.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.OdeIntegrators</code></pre><pre><code class="language-none">RigidBodyDynamics.PDControl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Planar" href="#RigidBodyDynamics.Planar"><code>RigidBodyDynamics.Planar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Planar{T} &lt;: JointType{T}</code></pre><p>The <code>Planar</code> joint type allows translation along two orthogonal vectors, referred to as <span>$x$</span> and <span>$y$</span>, as well as rotation about an axis <span>$z = x \times y$</span>.</p><p>The components of the 3-dimensional configuration vector <span>$q$</span> associated with a <code>Planar</code> joint are the <span>$x$</span>- and <span>$y$</span>-coordinates of the translation, and the angle of rotation <span>$\theta$</span> about <span>$z$</span>, in that order.</p><p>The components of the 3-dimension velocity vector <span>$v$</span> associated with a <code>Planar</code> joint are the <span>$x$</span>- and <span>$y$</span>-coordinates of the linear part of the joint twist, expressed in the frame after the joint, followed by the <span>$z$</span>-component of the angular part of this joint twist.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>For the <code>Planar</code> joint type, <span>$v \neq \dot{q}$</span>! Although the angular parts of <span>$v$</span> and <span>$\dot{q}$</span> are the same, their linear parts differ. The linear part of <span>$v$</span> is the linear part of <span>$\dot{q}$</span>, rotated to the frame after the joint. This parameterization was chosen to allow the translational component of the joint transform to be independent of the rotation angle <span>$\theta$</span> (i.e., the rotation is applied <strong>after</strong> the translation), while still retaining a constant motion subspace expressed in the frame after the joint.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.Point3D" href="#RigidBodyDynamics.Spatial.Point3D"><code>RigidBodyDynamics.Spatial.Point3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Point3D{V&lt;:(AbstractArray{T,1} where T)}</code></pre><p>A <code>Point3D</code> represents a position in a given coordinate system.</p><p>A <code>Point3D</code> is a <a href="https://en.wikipedia.org/wiki/Euclidean_vector#Overview">bound vector</a>. Applying a <code>Transform3D</code> to a <code>Point3D</code> both rotates and translates the <code>Point3D</code>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.PointJacobian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Prismatic" href="#RigidBodyDynamics.Prismatic"><code>RigidBodyDynamics.Prismatic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Prismatic{T} &lt;: JointType{T}</code></pre><p>A <code>Prismatic</code> joint type allows translation along a fixed axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.QuaternionFloating" href="#RigidBodyDynamics.QuaternionFloating"><code>RigidBodyDynamics.QuaternionFloating</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct QuaternionFloating{T} &lt;: JointType{T}</code></pre><p>A floating joint type that uses a unit quaternion representation for orientation.</p><p>Floating joints are 6-degree-of-freedom joints that are in a sense degenerate, as they impose no constraints on the relative motion between two bodies.</p><p>The full, 7-dimensional configuration vector of a <code>QuaternionFloating</code> joint type consists of a unit quaternion representing the orientation that rotates vectors from the frame &#39;directly after&#39; the joint to the frame &#39;directly before&#39; it, and a 3D position vector representing the origin of the frame after the joint in the frame before the joint.</p><p>The 6-dimensional velocity vector of a <code>QuaternionFloating</code> joint is the twist of the frame after the joint with respect to the frame before it, expressed in the frame after the joint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.QuaternionSpherical" href="#RigidBodyDynamics.QuaternionSpherical"><code>RigidBodyDynamics.QuaternionSpherical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct QuaternionSpherical{T} &lt;: JointType{T}</code></pre><p>The <code>QuaternionSpherical</code> joint type allows rotation in any direction. It is an implementation of a ball-and-socket joint.</p><p>The 4-dimensional configuration vector <span>$q$</span> associated with a <code>QuaternionSpherical</code> joint is the unit quaternion that describes the orientation of the frame after the joint with respect to the frame before the joint. In other words, it is the quaternion that can be used to rotate vectors from the frame after the joint to the frame before the joint.</p><p>The 3-dimensional velocity vector <span>$v$</span> associated with a <code>QuaternionSpherical</code> joint is the angular velocity of the frame after the joint with respect to the frame before the joint, expressed in the frame after the joint (body frame).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Revolute" href="#RigidBodyDynamics.Revolute"><code>RigidBodyDynamics.Revolute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Revolute{T} &lt;: JointType{T}</code></pre><p>A <code>Revolute</code> joint type allows rotation about a fixed axis.</p><p>The configuration vector for the <code>Revolute</code> joint type simply consists of the angle of rotation about the specified axis. The velocity vector consists of the angular rate, and is thus the time derivative of the configuration vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.RigidBody" href="#RigidBodyDynamics.RigidBody"><code>RigidBodyDynamics.RigidBody</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct RigidBody{T}</code></pre><p>A non-deformable body.</p><p>A <code>RigidBody</code> has inertia (represented as a <a href="#RigidBodyDynamics.Spatial.SpatialInertia"><code>SpatialInertia</code></a>), unless it represents a root (world) body. A <code>RigidBody</code> additionally stores a list of definitions of coordinate systems that are rigidly attached to it.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.RigidBodyDynamics</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.SPQuatFloating" href="#RigidBodyDynamics.SPQuatFloating"><code>RigidBodyDynamics.SPQuatFloating</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SPQuatFloating{T} &lt;: JointType{T}</code></pre><p>A floating joint type that uses a SPQuat representation for orientation.</p><p>Floating joints are 6-degree-of-freedom joints that are in a sense degenerate, as they impose no constraints on the relative motion between two bodies.</p><p>The 6-dimensional configuration vector of a <code>SPQuatFloating</code> joint type consists of a SPQuat representing the orientation that rotates vectors from the frame &#39;directly after&#39; the joint to the frame &#39;directly before&#39; it, and a 3D position vector representing the origin of the frame after the joint in the frame before the joint.</p><p>The 6-dimensional velocity vector of a <code>SPQuatFloating</code> joint is the twist of the frame after the joint with respect to the frame before it, expressed in the frame after the joint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.CustomCollections.SegmentedVector" href="#RigidBodyDynamics.CustomCollections.SegmentedVector"><code>RigidBodyDynamics.CustomCollections.SegmentedVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SegmentedVector{K, T, KeyRange&lt;:AbstractRange{K}, P&lt;:AbstractArray{T,1}} &lt;: AbstractArray{T,1}</code></pre><p><code>SegmentedVector</code> is an <code>AbstractVector</code> backed by another <code>AbstractVector</code> (its parent), which additionally stores an <a href="@ref"><code>IndexDict</code></a> containing views into the parent. Together, these views cover the parent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1., 2., 3., 4.]
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia&gt; viewlength(i) = 2
viewlength (generic function with 1 method)

julia&gt; xseg = SegmentedVector{Int}(x, 1 : 2, viewlength)
4-element RigidBodyDynamics.CustomCollections.SegmentedVector{Int64,Float64,Base.OneTo{Int64},Array{Float64,1}}:
 1.0
 2.0
 3.0
 4.0

julia&gt; segments(xseg)[1]
2-element SubArray{Float64,1,Array{Float64,1},Tuple{UnitRange{Int64}},true}:
 1.0
 2.0

julia&gt; yseg = similar(xseg, Int32); yseg .= 1 : 4 # same view ranges, different element type
4-element RigidBodyDynamics.CustomCollections.SegmentedVector{Int64,Int32,Base.OneTo{Int64},Array{Int32,1}}:
 1
 2
 3
 4

julia&gt; segments(yseg)[2]
2-element SubArray{Int32,1,Array{Int32,1},Tuple{UnitRange{Int64}},true}:
 3
 4</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.SegmentedVectorCache" href="#RigidBodyDynamics.SegmentedVectorCache"><code>RigidBodyDynamics.SegmentedVectorCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SegmentedVectorCache{K, KeyRange&lt;:AbstractUnitRange{K}} &lt;: RigidBodyDynamics.AbstractTypeDict</code></pre><p>A container that manages the creation and storage of heterogeneously typed <a href="#RigidBodyDynamics.CustomCollections.SegmentedVector"><code>SegmentedVector</code></a> objects. Similar to <a href="#RigidBodyDynamics.StateCache"><code>StateCache</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.SinCosRevolute" href="#RigidBodyDynamics.SinCosRevolute"><code>RigidBodyDynamics.SinCosRevolute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SinCosRevolute{T} &lt;: JointType{T}</code></pre><p>A <code>SinCosRevolute</code> joint type allows rotation about a fixed axis.</p><p>In contrast to the <a href="#RigidBodyDynamics.Revolute"><code>Revolute</code></a> joint type, the configuration vector for the <code>SinCosRevolute</code> joint type consists of the sine and cosine of the angle of rotation about the specified axis (in that order). The velocity vector for the <code>SinCosRevolute</code> joint type is the same as for the <code>Revolute</code> joint type, i.e., the time derivative of the angle about the axis.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.Spatial</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.SpatialAcceleration" href="#RigidBodyDynamics.Spatial.SpatialAcceleration"><code>RigidBodyDynamics.Spatial.SpatialAcceleration</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SpatialAcceleration{T}</code></pre><p>A spatial acceleration is the time derivative of a twist.</p><p>See <a href="#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.SpatialInertia" href="#RigidBodyDynamics.Spatial.SpatialInertia"><code>RigidBodyDynamics.Spatial.SpatialInertia</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SpatialInertia{T}</code></pre><p>A spatial inertia, or inertia matrix, represents the mass distribution of a rigid body.</p><p>A spatial inertia expressed in frame <span>$i$</span> is defined as:</p><div>\[I^i =
\int_{B}\rho\left(x\right)\left[\begin{array}{cc}
\hat{p}^{T}\left(x\right)\hat{p}\left(x\right) &amp; \hat{p}\left(x\right)\\
\hat{p}^{T}\left(x\right) &amp; I
\end{array}\right]dx=\left[\begin{array}{cc}
J &amp; \hat{c}\\
\hat{c}^{T} &amp; mI
\end{array}\right]\]</div><p>where <span>$\rho(x)$</span> is the density of point <span>$x$</span>, and <span>$p(x)$</span> are the coordinates of point <span>$x$</span> expressed in frame <span>$i$</span>. <span>$J$</span> is the mass moment of inertia, <span>$m$</span> is the total mass, and <span>$c$</span> is the &#39;cross part&#39;, center of mass position scaled by <span>$m$</span>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The <code>moment</code> field of a <code>SpatialInertia</code> is the moment of inertia <strong>about the origin of its <code>frame</code></strong>, not about the center of mass.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.StateCache" href="#RigidBodyDynamics.StateCache"><code>RigidBodyDynamics.StateCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct StateCache{M, JointCollection} &lt;: RigidBodyDynamics.AbstractTypeDict</code></pre><p>A container that manages the creation and storage of <a href="#RigidBodyDynamics.MechanismState"><code>MechanismState</code></a> objects of various scalar types, associated with a given <code>Mechanism</code>.</p><p>A <code>StateCache</code> can be used to write generic functions that use <code>MechanismState</code> objects, while avoiding overhead due to the construction of a new <code>MechanismState</code> with a given scalar type every time the function is called.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mechanism = rand_tree_mechanism(Float64, Revolute{Float64}, Prismatic{Float64}, QuaternionFloating{Float64});

julia&gt; cache = StateCache(mechanism)
StateCache{…}

julia&gt; state32 = cache[Float32]
MechanismState{Float32, Float64, Float64, …}(…)

julia&gt; cache[Float32] === state32
true

julia&gt; cache[Float64]
MechanismState{Float64, Float64, Float64, …}(…)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.Transform3D" href="#RigidBodyDynamics.Spatial.Transform3D"><code>RigidBodyDynamics.Spatial.Transform3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Transform3D{T}</code></pre><p>A homogeneous transformation matrix representing the transformation from one three-dimensional Cartesian coordinate system to another.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.Twist" href="#RigidBodyDynamics.Spatial.Twist"><code>RigidBodyDynamics.Spatial.Twist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Twist{T}</code></pre><p>A twist represents the relative angular and linear motion between two bodies.</p><p>The twist of frame <span>$j$</span> with respect to frame <span>$i$</span>, expressed in frame <span>$k$</span> is defined as</p><div>\[T_{j}^{k,i}=\left(\begin{array}{c}
\omega_{j}^{k,i}\\
v_{j}^{k,i}
\end{array}\right)\in\mathbb{R}^{6}\]</div><p>such that</p><div>\[\left[\begin{array}{cc}
\hat{\omega}_{j}^{k,i} &amp; v_{j}^{k,i}\\
0 &amp; 0
\end{array}\right]=H_{i}^{k}\dot{H}_{j}^{i}H_{k}^{j}\]</div><p>where <span>$H^{\beta}_{\alpha}$</span> is the homogeneous transform from frame <span>$\alpha$</span> to frame <span>$\beta$</span>, and <span>$\hat{x}$</span> is the <span>$3 \times 3$</span> skew symmetric matrix that satisfies <span>$\hat{x} y = x \times y$</span> for all <span>$y \in \mathbb{R}^3$</span>.</p><p>Here, <span>$\omega_{j}^{k,i}$</span> is the angular part and <span>$v_{j}^{k,i}$</span> is the linear part. Note that the linear part is not in general the same as the linear velocity of the origin of frame <span>$j$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.URDF</code></pre><pre><code class="language-none">RigidBodyDynamics.VectorSegment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.Wrench" href="#RigidBodyDynamics.Spatial.Wrench"><code>RigidBodyDynamics.Spatial.Wrench</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Wrench{T}</code></pre><p>A wrench represents a system of forces.</p><p>The wrench <span>$w^i$</span> expressed in frame <span>$i$</span> is defined as</p><div>\[w^{i} =
\left(\begin{array}{c}
\tau^{i}\\
f^{i}
\end{array}\right) =
\sum_{j}\left(\begin{array}{c}
r_{j}^{i}\times f_{j}^{i}\\
f_{j}^{i}
\end{array}\right)\]</div><p>where the <span>$f_{j}^{i}$</span> are forces expressed in frame <span>$i$</span>, exerted at positions <span>$r_{j}^{i}$</span>. <span>$\tau^i$</span> is the total torque and <span>$f^i$</span> is the total force.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.WrenchMatrix</code></pre><pre><code class="language-none">RigidBodyDynamics._constraint_wrench_subspace</code></pre><pre><code class="language-none">RigidBodyDynamics._copyjoint!</code></pre><pre><code class="language-none">RigidBodyDynamics._motion_subspace</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics._point_jacobian!" href="#RigidBodyDynamics._point_jacobian!"><code>RigidBodyDynamics._point_jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_point_jacobian!(Jp, state, path, point, transformfun)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics._update_bias_accelerations_wrt_world!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_constraint_wrench_subspaces!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_crb_inertias!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_joint_bias_accelerations!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_joint_twists!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_motion_subspaces!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_spatial_inertias!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_transforms!</code></pre><pre><code class="language-none">RigidBodyDynamics._update_twists_wrt_world!</code></pre><pre><code class="language-none">RigidBodyDynamics.acceleration</code></pre><pre><code class="language-none">RigidBodyDynamics.add_body_fixed_frame!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.add_contact_point!" href="#RigidBodyDynamics.add_contact_point!"><code>RigidBodyDynamics.add_contact_point!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_contact_point!(body, point)
</code></pre><p>Add a new contact point to the rigid body</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.add_environment_primitive!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.add_frame!" href="#RigidBodyDynamics.add_frame!"><code>RigidBodyDynamics.add_frame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_frame!(body, transform)
</code></pre><p>Add a new frame definition to <code>body</code>, represented by a homogeneous transform from the <code>CartesianFrame3D</code> to be added to any other frame that is already attached to <code>body</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.additional_state" href="#RigidBodyDynamics.additional_state"><code>RigidBodyDynamics.additional_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">additional_state(state)
</code></pre><p>Return the vector of additional states <span>$s$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.angular</code></pre><pre><code class="language-none">RigidBodyDynamics.angular_velocity</code></pre><pre><code class="language-none">RigidBodyDynamics.angular_velocity_in_body</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.attach!" href="#RigidBodyDynamics.attach!"><code>RigidBodyDynamics.attach!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">attach!(mechanism, predecessor, successor, joint; joint_pose, successor_pose)
</code></pre><p>Attach <code>successor</code> to <code>predecessor</code> using <code>joint</code>.</p><p>See <a href="#RigidBodyDynamics.Joint"><code>Joint</code></a> for definitions of the terms successor and predecessor.</p><p>The <code>Transform3D</code>s <code>joint_pose</code> and <code>successor_pose</code> define where <code>joint</code> is attached to each body. <code>joint_pose</code> should define <code>frame_before(joint)</code> with respect to any frame fixed to <code>predecessor</code>, and likewise <code>successor_pose</code> should define any frame fixed to <code>successor</code> with respect to <code>frame_after(joint)</code>.</p><p><code>predecessor</code> is required to already be among the bodies of the <code>Mechanism</code>.</p><p>If <code>successor</code> is not yet a part of the <code>Mechanism</code>, it will be added to the <code>Mechanism</code>. Otherwise, the <code>joint</code> will be treated as a non-tree edge in the <code>Mechanism</code>, effectively creating a loop constraint that will be enforced using Lagrange multipliers (as opposed to using recursive algorithms).</p></div></div><div><div><pre><code class="language-julia">attach!(mechanism, parentbody, childmechanism; child_root_pose)
</code></pre><p>Attach a copy of <code>childmechanism</code> to <code>mechanism</code>. Return mappings from the bodies and joints of the <code>childmechanism</code> to the bodies and joints that were added to <code>mechanism</code>.</p><p>Essentially replaces the root body of a copy of <code>childmechanism</code> with <code>parentbody</code> (which belongs to <code>mechanism</code>).</p><p>Note: gravitational acceleration for <code>childmechanism</code> is ignored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.bias_acceleration" href="#RigidBodyDynamics.bias_acceleration"><code>RigidBodyDynamics.bias_acceleration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bias_acceleration(joint, q, v)
</code></pre><p>Return the acceleration of the joint&#39;s successor with respect to its predecessor in configuration <span>$q$</span> and at velocity <span>$v$</span>, when the joint acceleration <span>$\dot{v}$</span> is zero.</p></div></div><div><div><pre><code class="language-julia">bias_acceleration(state, joint)
bias_acceleration(state, joint, safe)
</code></pre><p>Return the bias acceleration across the given joint, i.e. the spatial acceleration of <code>frame_after(joint)</code> with respect to <code>frame_before(joint)</code>, expressed in the root frame of the mechanism when all joint accelerations are zero.</p></div></div><div><div><pre><code class="language-julia">bias_acceleration(state, body)
bias_acceleration(state, body, safe)
</code></pre><p>Return the bias acceleration of the given body with respect to the world, i.e. the spatial acceleration of <code>default_frame(body)</code> with respect to the root frame of the mechanism, expressed in the root frame, when all joint accelerations are zero.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.bias_accelerations!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.bodies" href="#RigidBodyDynamics.bodies"><code>RigidBodyDynamics.bodies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bodies(mechanism)
</code></pre><p>Return the <code>RigidBody</code>s that are part of the <code>Mechanism</code> as an iterable collection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.body_fixed_frame_definition" href="#RigidBodyDynamics.body_fixed_frame_definition"><code>RigidBodyDynamics.body_fixed_frame_definition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">body_fixed_frame_definition(mechanism, frame)
</code></pre><p>Return the definition of body-fixed frame <code>frame</code>, i.e., the <code>Transform3D</code> from <code>frame</code> to the default frame of the body to which it is attached.</p><p>Note: this function is linear in the number of bodies and is not meant to be called in tight loops.</p><p>See also <a href="#RigidBodyDynamics.default_frame"><code>default_frame</code></a>, <a href="#RigidBodyDynamics.frame_definition"><code>frame_definition</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.body_fixed_frame_to_body" href="#RigidBodyDynamics.body_fixed_frame_to_body"><code>RigidBodyDynamics.body_fixed_frame_to_body</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">body_fixed_frame_to_body(mechanism, frame)
</code></pre><p>Return the <code>RigidBody</code> to which <code>frame</code> is attached.</p><p>Note: this function is linear in the number of bodies and is not meant to be called in tight loops.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.cache_eltype</code></pre><pre><code class="language-none">RigidBodyDynamics.cached_download</code></pre><pre><code class="language-none">RigidBodyDynamics.canonicalize_frame_definitions!</code></pre><pre><code class="language-none">RigidBodyDynamics.canonicalize_graph!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.center_of_mass" href="#RigidBodyDynamics.Spatial.center_of_mass"><code>RigidBodyDynamics.Spatial.center_of_mass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">center_of_mass(inertia)
</code></pre><p>Return the center of mass of the <code>SpatialInertia</code> as a <a href="#RigidBodyDynamics.Spatial.Point3D"><code>Point3D</code></a>.</p></div></div><div><div><pre><code class="language-julia">center_of_mass(state, itr)
</code></pre><p>Compute the center of mass of an iterable subset of a <code>Mechanism</code>&#39;s bodies in the given state. Ignores the root body of the mechanism.</p></div></div><div><div><pre><code class="language-julia">center_of_mass(state)
</code></pre><p>Compute the center of mass of the whole <code>Mechanism</code> in the given state.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.change_base</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.change_default_frame!" href="#RigidBodyDynamics.change_default_frame!"><code>RigidBodyDynamics.change_default_frame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">change_default_frame!(body, new_default_frame)
</code></pre><p>Change the default frame of <code>body</code> to <code>frame</code> (which should already be among <code>body</code>&#39;s frame definitions).</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.check_num_positions</code></pre><pre><code class="language-none">RigidBodyDynamics.check_num_velocities</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration" href="#RigidBodyDynamics.configuration"><code>RigidBodyDynamics.configuration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration(state, joint)
</code></pre><p>Return the part of the configuration vector <span>$q$</span> associated with <code>joint</code>.</p></div></div><div><div><pre><code class="language-julia">configuration(state)
</code></pre><p>Return the configuration vector <span>$q$</span>.</p><p>Note that this returns a reference to the underlying data in <code>state</code>. The user is responsible for calling <a href="#RigidBodyDynamics.setdirty!"><code>setdirty!</code></a> after modifying this vector to ensure that dependent cache variables are invalidated.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.configuration_derivative</code></pre><pre><code class="language-none">RigidBodyDynamics.configuration_derivative!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration_derivative_to_velocity!" href="#RigidBodyDynamics.configuration_derivative_to_velocity!"><code>RigidBodyDynamics.configuration_derivative_to_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_derivative_to_velocity!(v, joint, q, q̇)
</code></pre><p>Compute joint velocity vector <span>$v$</span> given the joint configuration vector <span>$q$</span> and its time derivative <span>$\dot{q}$</span> (in place).</p><p>Note that this mapping is linear.</p><p>See also <a href="#RigidBodyDynamics.velocity_to_configuration_derivative!"><code>velocity_to_configuration_derivative!</code></a>, the inverse mapping.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration_derivative_to_velocity_adjoint!" href="#RigidBodyDynamics.configuration_derivative_to_velocity_adjoint!"><code>RigidBodyDynamics.configuration_derivative_to_velocity_adjoint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_derivative_to_velocity_adjoint!(fq, joint, q, fv)
</code></pre><p>Given  a linear function</p><div>\[f(v) = \langle f_v, v \rangle\]</div><p>where <span>$v$</span> is the joint velocity vector, return a vector <span>$f_q$</span> such that</p><div>\[\langle f_v, v \rangle = \langle f_q, \dot{q}(v) \rangle.\]</div><p>Note: since <span>$v$</span> is a linear function of <span>$\dot{q}$</span> (see <a href="#RigidBodyDynamics.configuration_derivative_to_velocity!"><code>configuration_derivative_to_velocity!</code></a>), we can write <span>$v = J_{\dot{q} \rightarrow v} \dot{q}$</span>, so</p><div>\[\langle f_v, v \rangle = \langle f_v, J_{\dot{q} \rightarrow v} \dot{q} \rangle = \langle J_{\dot{q} \rightarrow v}^{*} f_v, \dot{q} \rangle\]</div><p>so <span>$f_q = J_{\dot{q} \rightarrow v}^{*} f_v$</span>.</p><p>To compute <span>$J_{\dot{q} \rightarrow v}$</span> see <a href="#RigidBodyDynamics.configuration_derivative_to_velocity_jacobian"><code>configuration_derivative_to_velocity_jacobian</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration_derivative_to_velocity_jacobian" href="#RigidBodyDynamics.configuration_derivative_to_velocity_jacobian"><code>RigidBodyDynamics.configuration_derivative_to_velocity_jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_derivative_to_velocity_jacobian(joint, q)
</code></pre><p>Compute the jacobian <span>$J_{\dot{q} \rightarrow v}$</span> which maps joint configuration derivative to velocity for the given joint:</p><div>\[v = J_{\dot{q} \rightarrow v} \dot{q}\]</div></div></div></section><pre><code class="language-none">RigidBodyDynamics.configuration_derivative_to_velocity_jacobian!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration_index_to_joint_id" href="#RigidBodyDynamics.configuration_index_to_joint_id"><code>RigidBodyDynamics.configuration_index_to_joint_id</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_index_to_joint_id(state, qindex)
</code></pre><p>Return the <code>JointID</code> of the joint associated with the given index into the configuration vector <span>$q$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.configuration_range" href="#RigidBodyDynamics.configuration_range"><code>RigidBodyDynamics.configuration_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_range(state, joint)
</code></pre><p>Return the range of indices into the joint configuration vector <span>$q$</span> corresponding to joint <code>joint</code>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.constraint_bias!</code></pre><pre><code class="language-none">RigidBodyDynamics.constraint_jacobian!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.constraint_range" href="#RigidBodyDynamics.constraint_range"><code>RigidBodyDynamics.constraint_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">constraint_range(state, joint)
</code></pre><p>Return the range of row indices into the constraint Jacobian corresponding to joint <code>joint</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.constraint_wrench_subspace" href="#RigidBodyDynamics.constraint_wrench_subspace"><code>RigidBodyDynamics.constraint_wrench_subspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">constraint_wrench_subspace(joint, joint_transform)
</code></pre><p>Return a basis for the constraint wrench subspace of the joint, where <code>joint_transform</code> is the transform from the frame after the joint to the frame before the joint.</p><p>The constraint wrench subspace is a <span>$6 \times (6 - k)$</span> matrix, where <span>$k$</span> is the dimension of the velocity vector <span>$v$</span>, that maps a vector of Lagrange multipliers <span>$\lambda$</span> to the constraint wrench exerted across the joint onto its successor.</p><p>The constraint wrench subspace is orthogonal to the motion subspace.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.contact_dynamics!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.contact_points" href="#RigidBodyDynamics.contact_points"><code>RigidBodyDynamics.contact_points</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">contact_points(body)
</code></pre><p>Return the contact points attached to the body as an ordered collection.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.contact_state_derivatives</code></pre><pre><code class="language-none">RigidBodyDynamics.contact_states</code></pre><pre><code class="language-none">RigidBodyDynamics.contact_wrench</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.crb_inertia" href="#RigidBodyDynamics.crb_inertia"><code>RigidBodyDynamics.crb_inertia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">crb_inertia(state, body)
crb_inertia(state, body, safe)
</code></pre><p>Return the composite rigid body inertia <code>body</code> expressed in the root frame of the mechanism.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.default_constraint_stabilization_gains" href="#RigidBodyDynamics.default_constraint_stabilization_gains"><code>RigidBodyDynamics.default_constraint_stabilization_gains</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the default Baumgarte constraint stabilization gains. These gains result in critical damping, and correspond to <span>$T_{stab} = 0.1$</span> in Featherstone (2008), section 8.3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.default_frame" href="#RigidBodyDynamics.default_frame"><code>RigidBodyDynamics.default_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">default_frame(body)
</code></pre><p>The <a href="#RigidBodyDynamics.Spatial.CartesianFrame3D"><code>CartesianFrame3D</code></a> with respect to which all other frames attached to <code>body</code> are defined.</p><p>See <a href="#RigidBodyDynamics.frame_definitions"><code>frame_definitions(body)</code></a>, <a href="#RigidBodyDynamics.frame_definition"><code>frame_definition(body, frame)</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics!" href="#RigidBodyDynamics.dynamics!"><code>RigidBodyDynamics.dynamics!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dynamics!(result, state)
dynamics!(result, state, torques)
dynamics!(result, state, torques, externalwrenches; stabilization_gains)
</code></pre><p>Compute the joint acceleration vector <span>$\dot{v}$</span> and Lagrange multipliers <span>$\lambda$</span> that satisfy the joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau - K(q)^{T} \lambda\]</div><p>and the constraint equations</p><div>\[K(q) \dot{v} = -k\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, and (optionally) joint torques <span>$\tau$</span> and external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>The <code>stabilization_gains</code> keyword argument can be used to set PD gains for Baumgarte stabilization, which can be used to prevent separation of non-tree (loop) joints. See Featherstone (2008), section 8.3 for more information. There are several options for specifying gains:</p><ul><li><code>nothing</code> can be used to completely disable Baumgarte stabilization.</li><li>Gains can be specifed on a per-joint basis using any <code>AbstractDict{JointID, &lt;:RigidBodyDynamics.PDControl.SE3PDGains}</code>, which maps the <code>JointID</code> for the non-tree joints of the mechanism to the gains for that joint.</li><li>As a special case of the second option, the same gains can be used for all joints by passing in a <code>RigidBodyDynamics.CustomCollections.ConstDict{JointID}</code>.</li></ul><p>The <a href="#RigidBodyDynamics.default_constraint_stabilization_gains"><code>default_constraint_stabilization_gains</code></a> function is called to produce the default gains, which use the last option.</p></div></div><div><div><pre><code class="language-julia">dynamics!(ẋ, result, state, x)
dynamics!(ẋ, result, state, x, torques)
dynamics!(ẋ, result, state, x, torques, externalwrenches; stabilization_gains)
</code></pre><p>Convenience function for use with standard ODE integrators that takes a <code>Vector</code> argument</p><div>\[x = \left(\begin{array}{c}
q\\
v
\end{array}\right)\]</div><p>and returns a <code>Vector</code> <span>$\dot{x}$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics_bias" href="#RigidBodyDynamics.dynamics_bias"><code>RigidBodyDynamics.dynamics_bias</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dynamics_bias(state)
dynamics_bias(state, externalwrenches)
</code></pre><p>Compute the &#39;dynamics bias term&#39;, i.e. the term</p><div>\[c(q, v, w_\text{ext})\]</div><p>in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics_bias!" href="#RigidBodyDynamics.dynamics_bias!"><code>RigidBodyDynamics.dynamics_bias!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dynamics_bias!(torques, biasaccelerations, wrenches, state)
dynamics_bias!(torques, biasaccelerations, wrenches, state, externalwrenches)
</code></pre><p>Compute the &#39;dynamics bias term&#39;, i.e. the term</p><div>\[c(q, v, w_\text{ext})\]</div><p>in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.dynamics_bias_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.dynamics_solve!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.effort_bounds" href="#RigidBodyDynamics.effort_bounds"><code>RigidBodyDynamics.effort_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">effort_bounds(joint)
</code></pre><p>Return a <code>Vector{Bounds{T}}</code> giving the upper and lower bounds of the effort for <code>joint</code></p></div></div></section><pre><code class="language-none">RigidBodyDynamics.eval</code></pre><pre><code class="language-none">RigidBodyDynamics.findbody</code></pre><pre><code class="language-none">RigidBodyDynamics.findjoint</code></pre><pre><code class="language-none">RigidBodyDynamics.findunique</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.fixed_transform" href="#RigidBodyDynamics.fixed_transform"><code>RigidBodyDynamics.fixed_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fixed_transform(body, from, to)
</code></pre><p>Return the transform from <code>CartesianFrame3D</code> <code>from</code> to <code>to</code>, both of which are rigidly attached to <code>body</code>.</p></div></div><div><div><pre><code class="language-julia">fixed_transform(mechanism, from, to)
</code></pre><p>Return the transform from <code>CartesianFrame3D</code> <code>from</code> to <code>to</code>, both of which are rigidly attached to the same <code>RigidBody</code>.</p><p>Note: this function is linear in the number of bodies and is not meant to be called in tight loops.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.flip_direction</code></pre><pre><code class="language-none">RigidBodyDynamics.frame_after</code></pre><pre><code class="language-none">RigidBodyDynamics.frame_before</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.frame_definition" href="#RigidBodyDynamics.frame_definition"><code>RigidBodyDynamics.frame_definition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">frame_definition(body, frame)
</code></pre><p>Return the <a href="#RigidBodyDynamics.Spatial.Transform3D"><code>Transform3D</code></a> defining <code>frame</code> (attached to <code>body</code>) with respect to <a href="#RigidBodyDynamics.default_frame"><code>default_frame(body)</code></a>.</p><p>Throws an error if <code>frame</code> is not attached to <code>body</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.frame_definitions" href="#RigidBodyDynamics.frame_definitions"><code>RigidBodyDynamics.frame_definitions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame_definitions(body)</code></pre><p>Return the list of homogeneous transforms (<a href="#RigidBodyDynamics.Spatial.Transform3D"><code>Transform3D</code></a>s) that define the coordinate systems attached to <code>body</code> with respect to a single common frame (<a href="#RigidBodyDynamics.default_frame"><code>default_frame(body)</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian" href="#RigidBodyDynamics.geometric_jacobian"><code>RigidBodyDynamics.geometric_jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">geometric_jacobian(state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="#RigidBodyDynamics.path"><code>path</code></a>, <a href="#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p>The Jacobian is computed in the <code>Mechanism</code>&#39;s root frame.</p><p>See <a href="#RigidBodyDynamics.geometric_jacobian!"><code>geometric_jacobian!(out, state, path)</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!" href="#RigidBodyDynamics.geometric_jacobian!"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">geometric_jacobian!(jac, state, path, transformfun)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="#RigidBodyDynamics.path"><code>path</code></a>, <a href="#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual motion subspaces of each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div><div><div><pre><code class="language-julia">geometric_jacobian!(out, state, path, root_to_desired)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="#RigidBodyDynamics.path"><code>path</code></a>, <a href="#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div><div><div><pre><code class="language-julia">geometric_jacobian!(out, state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="#RigidBodyDynamics.path"><code>path</code></a>, <a href="#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p>See <a href="#RigidBodyDynamics.geometric_jacobian!"><code>geometric_jacobian!(out, state, path, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.geometric_jacobian_doc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.global_coordinates!" href="#RigidBodyDynamics.global_coordinates!"><code>RigidBodyDynamics.global_coordinates!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">global_coordinates!(q, joint, q0, ϕ)
</code></pre><p>Compute the global parameterization of the joint&#39;s configuration, <span>$q$</span>, given a &#39;base&#39; orientation <span>$q_0$</span> and a vector of local coordinates <span>$ϕ$</span> centered around <span>$q_0$</span>.</p><p>See also <a href="#RigidBodyDynamics.local_coordinates!"><code>local_coordinates!</code></a>.</p></div></div><div><div><pre><code class="language-julia">global_coordinates!(state, q0, ϕ)
</code></pre><p>Convert local coordinates <span>$\phi$</span> centered around <span>$q_0$</span> to (global) configuration vector <span>$q$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.gravitational_potential_energy" href="#RigidBodyDynamics.gravitational_potential_energy"><code>RigidBodyDynamics.gravitational_potential_energy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gravitational_potential_energy(state, body)
gravitational_potential_energy(state, body, safe)
</code></pre><p>Return the gravitational potential energy in the given state, computed as the negation of the dot product of the gravitational force and the center of mass expressed in the <code>Mechanism</code>&#39;s root frame.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.gravitational_spatial_acceleration</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.has_defined_inertia" href="#RigidBodyDynamics.has_defined_inertia"><code>RigidBodyDynamics.has_defined_inertia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">has_defined_inertia(b)
</code></pre><p>Whether the body has a defined inertia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.has_fixed_subspaces" href="#RigidBodyDynamics.has_fixed_subspaces"><code>RigidBodyDynamics.has_fixed_subspaces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">has_fixed_subspaces(joint)
</code></pre><p>Whether the joint&#39;s motion subspace and constraint wrench subspace depend on <span>$q$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.has_loops</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.in_joints" href="#RigidBodyDynamics.in_joints"><code>RigidBodyDynamics.in_joints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">in_joints(body, mechanism)
</code></pre><p>Return the joints that have <code>body</code> as their <a href="#RigidBodyDynamics.successor"><code>successor</code></a>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics" href="#RigidBodyDynamics.inverse_dynamics"><code>RigidBodyDynamics.inverse_dynamics</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inverse_dynamics(state, v̇)
inverse_dynamics(state, v̇, externalwrenches)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics!" href="#RigidBodyDynamics.inverse_dynamics!"><code>RigidBodyDynamics.inverse_dynamics!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇)
inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇, externalwrenches)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.inverse_dynamics_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.is_configuration_normalized</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.is_fixed_to_body" href="#RigidBodyDynamics.is_fixed_to_body"><code>RigidBodyDynamics.is_fixed_to_body</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_fixed_to_body(body, frame)
</code></pre><p>Whether <code>frame</code> is attached to <code>body</code> (i.e. whether it is among <a href="#RigidBodyDynamics.frame_definitions"><code>frame_definitions(body)</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.isfloating" href="#RigidBodyDynamics.isfloating"><code>RigidBodyDynamics.isfloating</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isfloating(joint)
</code></pre><p>Whether the joint is a floating joint, i.e., whether it imposes no constraints on the relative motions of its successor and predecessor bodies.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.isroot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joint_spatial_acceleration" href="#RigidBodyDynamics.joint_spatial_acceleration"><code>RigidBodyDynamics.joint_spatial_acceleration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joint_spatial_acceleration(joint, q, v, vd)
</code></pre><p>Return the spatial acceleration of <code>joint</code>&#39;s  successor with respect to its predecessor, expressed in the frame after the joint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joint_to_parent" href="#RigidBodyDynamics.joint_to_parent"><code>RigidBodyDynamics.joint_to_parent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joint_to_parent(body, mechanism)
</code></pre><p>Return the joint that is part of the mechanism&#39;s kinematic tree and has <code>body</code> as its successor.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.joint_to_predecessor</code></pre><pre><code class="language-none">RigidBodyDynamics.joint_to_successor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joint_torque!" href="#RigidBodyDynamics.joint_torque!"><code>RigidBodyDynamics.joint_torque!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joint_torque!(τ, joint, q, joint_wrench)
</code></pre><p>Given the wrench exerted across the joint on the joint&#39;s successor, compute the vector of joint torques <span>$\tau$</span> (in place), in configuration <code>q</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joint_transform" href="#RigidBodyDynamics.joint_transform"><code>RigidBodyDynamics.joint_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joint_transform(joint, q)
</code></pre><p>Return a <code>Transform3D</code> representing the homogeneous transform from the frame after the joint to the frame before the joint for joint configuration vector <span>$q$</span>.</p></div></div><div><div><pre><code class="language-julia">joint_transform(state, joint)
joint_transform(state, joint, safe)
</code></pre><p>Return the joint transform for the given joint, i.e. the transform from <code>frame_after(joint)</code> to <code>frame_before(joint)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joint_twist" href="#RigidBodyDynamics.joint_twist"><code>RigidBodyDynamics.joint_twist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joint_twist(joint, q, v)
</code></pre><p>Return the twist of <code>joint</code>&#39;s  successor with respect to its predecessor, expressed in the frame after the joint.</p><p>Note that this is the same as <code>Twist(motion_subspace(joint, q), v)</code>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.joint_type</code></pre><pre><code class="language-none">RigidBodyDynamics.joint_wrench</code></pre><pre><code class="language-none">RigidBodyDynamics.joint_wrenches_and_torques!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joints" href="#RigidBodyDynamics.joints"><code>RigidBodyDynamics.joints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joints(mechanism)
</code></pre><p>Return the <code>Joint</code>s that are part of the <code>Mechanism</code> as an iterable collection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.joints_to_children" href="#RigidBodyDynamics.joints_to_children"><code>RigidBodyDynamics.joints_to_children</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">joints_to_children(body, mechanism)
</code></pre><p>Return the joints that are part of the mechanism&#39;s kinematic tree and have <code>body</code> as their predecessor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.kinetic_energy" href="#RigidBodyDynamics.Spatial.kinetic_energy"><code>RigidBodyDynamics.Spatial.kinetic_energy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kinetic_energy(inertia, twist)
</code></pre><p>Compute the kinetic energy of a body with spatial inertia <span>$I$</span>, which has twist <span>$T$</span> with respect to an inertial frame.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.linear</code></pre><pre><code class="language-none">RigidBodyDynamics.linear_velocity</code></pre><pre><code class="language-none">RigidBodyDynamics.linearized_rodrigues_vec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.local_coordinates!" href="#RigidBodyDynamics.local_coordinates!"><code>RigidBodyDynamics.local_coordinates!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">local_coordinates!(ϕ, ϕ̇, joint, q0, q, v)
</code></pre><p>Compute a vector of local coordinates <span>$\phi$</span> around configuration <span>$q_0$</span> corresponding to configuration <span>$q$</span> (in place). Also compute the time derivative <span>$\dot{\phi}$</span> of <span>$\phi$</span> given the joint velocity vector <span>$v$</span>.</p><p>The local coordinate vector <span>$\phi$</span> must be zero if and only if <span>$q = q_0$</span>.</p><p>For revolute or prismatic joint types, the local coordinates can just be <span>$\phi = q - q_0$</span>, but for joint types with configuration vectors that are restricted to a manifold (e.g. when unit quaternions are used to represent orientation), elementwise subtraction may not make sense. For such joints, exponential coordinates could be used as the local coordinate vector <span>$\phi$</span>.</p><p>See also <a href="#RigidBodyDynamics.global_coordinates!"><code>global_coordinates!</code></a>.</p></div></div><div><div><pre><code class="language-julia">local_coordinates!(ϕ, ϕd, state, q0)
</code></pre><p>Compute local coordinates <span>$\phi$</span> centered around (global) configuration vector <span>$q_0$</span>, as well as their time derivatives <span>$\dot{\phi}$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.log_with_time_derivative" href="#RigidBodyDynamics.Spatial.log_with_time_derivative"><code>RigidBodyDynamics.Spatial.log_with_time_derivative</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">log_with_time_derivative(t, twist)
</code></pre><p>Compute exponential coordinates as well as their time derivatives in one shot. This mainly exists because ForwardDiff won&#39;t work at the singularity of <code>log</code>. It is also ~50% faster than ForwardDiff in this case.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.lower</code></pre><pre><code class="language-none">RigidBodyDynamics.makevalue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass" href="#RigidBodyDynamics.mass"><code>RigidBodyDynamics.mass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mass(m)
</code></pre><p>Return the total mass of the <code>Mechanism</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix" href="#RigidBodyDynamics.mass_matrix"><code>RigidBodyDynamics.mass_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>This method implements the composite rigid body algorithm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix!" href="#RigidBodyDynamics.mass_matrix!"><code>RigidBodyDynamics.mass_matrix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mass_matrix!(M, state)
</code></pre><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>This method implements the composite rigid body algorithm.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p><p>The <code>out</code> argument must be an <span>$n_v \times n_v$</span> lower triangular <code>Symmetric</code> matrix, where <span>$n_v$</span> is the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.mass_matrix_doc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.maximal_coordinates" href="#RigidBodyDynamics.maximal_coordinates"><code>RigidBodyDynamics.maximal_coordinates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">maximal_coordinates(mechanism)
</code></pre><p>Return a dynamically equivalent <code>Mechanism</code>, but with a flat tree structure with all bodies attached to the root body with a quaternion floating joint, and with the &#39;tree edge&#39; joints of the input <code>Mechanism</code> transformed into non-tree edge joints (a constraint enforced using Lagrange multipliers in <code>dynamics!</code>). In addition, return:</p><ul><li>a mapping from bodies in the maximal-coordinate <code>Mechanism</code> to their floating joints.</li><li>a mapping from bodies in the input <code>Mechanism</code> to bodies in the returned <code>Mechanism</code></li><li>a mapping from joints in the input <code>Mechanism</code> to joints in the returned <code>Mechanism</code></li></ul></div></div></section><pre><code class="language-none">RigidBodyDynamics.mechanism_eltype</code></pre><pre><code class="language-none">RigidBodyDynamics.modcount</code></pre><pre><code class="language-none">RigidBodyDynamics.modcount_check_fail</code></pre><pre><code class="language-none">RigidBodyDynamics.module_tempdir</code></pre><pre><code class="language-none">RigidBodyDynamics.momentum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix" href="#RigidBodyDynamics.momentum_matrix"><code>RigidBodyDynamics.momentum_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">momentum_matrix(state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>See <a href="#RigidBodyDynamics.momentum_matrix!"><code>momentum_matrix!(out, state)</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!" href="#RigidBodyDynamics.momentum_matrix!"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">momentum_matrix!(mat, state, transformfun)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual momentum matrix blocks associated with each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div><div><div><pre><code class="language-julia">momentum_matrix!(mat, state, root_to_desired)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div><div><div><pre><code class="language-julia">momentum_matrix!(out, state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p>See <a href="#RigidBodyDynamics.momentum_matrix!"><code>momentum_matrix!(out, state, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.momentum_matrix!_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.momentum_matrix_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.momentum_rate_bias</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.motion_subspace" href="#RigidBodyDynamics.motion_subspace"><code>RigidBodyDynamics.motion_subspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">motion_subspace(joint, q)
</code></pre><p>Return a basis for the motion subspace of the joint in configuration <span>$q$</span>.</p><p>The motion subspace basis is a <span>$6 \times  k$</span> matrix, where <span>$k$</span> is the dimension of the velocity vector <span>$v$</span>, that maps <span>$v$</span> to the twist of the joint&#39;s successor with respect to its predecessor. The returned motion subspace is expressed in the frame after the joint, which is attached to the joint&#39;s successor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.newton_euler" href="#RigidBodyDynamics.Spatial.newton_euler"><code>RigidBodyDynamics.Spatial.newton_euler</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">newton_euler(inertia, spatial_accel, twist)
</code></pre><p>Apply the Newton-Euler equations to find the external wrench required to make a body with spatial inertia <span>$I$</span>, which has twist <span>$T$</span> with respect to an inertial frame, achieve spatial acceleration <span>$\dot{T}$</span>.</p><p>This wrench is also equal to the rate of change of momentum of the body.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.newton_euler!</code></pre><pre><code class="language-none">RigidBodyDynamics.noalloc_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.non_root_bodies</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.non_tree_joints" href="#RigidBodyDynamics.non_tree_joints"><code>RigidBodyDynamics.non_tree_joints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">non_tree_joints(mechanism)
</code></pre><p>Return the <code>Joint</code>s that are not part of the <code>Mechanism</code>&#39;s spanning tree as an iterable collection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.normalize_configuration!" href="#RigidBodyDynamics.normalize_configuration!"><code>RigidBodyDynamics.normalize_configuration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">normalize_configuration!(q, joint)
</code></pre><p>Renormalize the configuration vector <span>$q$</span> associated with <code>joint</code> so that it lies on the joint&#39;s configuration manifold.</p></div></div><div><div><pre><code class="language-julia">normalize_configuration!(state)
</code></pre><p>Project the configuration vector <span>$q$</span> onto the configuration manifold.</p><p>For example:</p><ul><li>for a part of <span>$q$</span> corresponding to a revolute joint, this method is a no-op;</li><li>for a part of <span>$q$</span> corresponding to a spherical joint that uses a unit quaternion</li></ul><p>to parameterize the orientation of its successor with respect to its predecessor, <code>normalize_configuration!</code> will renormalize the quaternion so that it is indeed of unit length.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"></div></div><p>This method does not ensure that the configuration or velocity satisfy joint configuration or velocity limits/bounds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.num_additional_states" href="#RigidBodyDynamics.num_additional_states"><code>RigidBodyDynamics.num_additional_states</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">num_additional_states(mechanism)
</code></pre><p>Return the dimension of the vector of additional states <span>$s$</span> (used for stateful contact models).</p></div></div><div><div><pre><code class="language-julia">num_additional_states(state)
</code></pre><p>Return the length of the vector of additional states <span>$s$</span> (currently used for stateful contact models).</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.num_bodies</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.num_constraints" href="#RigidBodyDynamics.num_constraints"><code>RigidBodyDynamics.num_constraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">num_constraints(joint)
</code></pre><p>Return the number of constraints imposed on the relative twist between the joint&#39;s predecessor and successor</p></div></div><div><div><pre><code class="language-julia">num_constraints(mechanism)
</code></pre><p>Return the number of constraints imposed by the mechanism&#39;s non-tree joints (i.e., the number of rows of the constraint Jacobian).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.num_positions" href="#RigidBodyDynamics.num_positions"><code>RigidBodyDynamics.num_positions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">num_positions(joint)
</code></pre><p>Return the length of the configuration vector of <code>joint</code>.</p></div></div><div><div><pre><code class="language-julia">num_positions(mechanism)
</code></pre><p>Return the dimension of the joint configuration vector <span>$q$</span>.</p></div></div><div><div><pre><code class="language-julia">num_positions(state)
</code></pre><p>Return the length of the joint configuration vector <span>$q$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.num_velocities" href="#RigidBodyDynamics.num_velocities"><code>RigidBodyDynamics.num_velocities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">num_velocities(joint)
</code></pre><p>Return the length of the velocity vector of <code>joint</code>.</p></div></div><div><div><pre><code class="language-julia">num_velocities(mechanism)
</code></pre><p>Return the dimension of the joint velocity vector <span>$v$</span>.</p></div></div><div><div><pre><code class="language-julia">num_velocities(state)
</code></pre><p>Return the length of the joint velocity vector <span>$v$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.out_joints" href="#RigidBodyDynamics.out_joints"><code>RigidBodyDynamics.out_joints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">out_joints(body, mechanism)
</code></pre><p>Return the joints that have <code>body</code> as their <a href="#RigidBodyDynamics.predecessor"><code>predecessor</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.URDF.parse_urdf" href="#RigidBodyDynamics.URDF.parse_urdf"><code>RigidBodyDynamics.URDF.parse_urdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parse_urdf(filename; scalar_type, floating, floating_joint_type, revolute_joint_type, root_joint_type, remove_fixed_tree_joints, gravity)
</code></pre><p>Create a <code>Mechanism</code> by parsing a <a href="https://wiki.ros.org/urdf/XML/model">URDF</a> file.</p><p>Keyword arguments:</p><ul><li><code>scalar_type</code>: the scalar type used to store the <code>Mechanism</code>&#39;s kinematic and inertial properties. Default: <code>Float64</code>.</li><li><code>floating</code>: whether to use a floating joint as the root joint. Default: false.</li><li><code>floating_joint_type</code>: what <code>JointType</code> to use for floating joints. Default: <code>QuaternionFloating{scalar_type}</code>.</li><li><code>revolute_joint_type</code>: what <code>JointType</code> to use for revolute joints. Default: <code>Revolute{scalar_type}</code>.</li><li><code>root_joint_type</code>: the joint type used to connect the parsed <code>Mechanism</code> to the world. Default: <code>floating_joint_type()</code> if <code>floating</code>, <code>Fixed{scalar_type}()</code> otherwise.</li><li><code>remove_fixed_tree_joints</code>: whether to remove any fixed joints present in the kinematic tree using <a href="#RigidBodyDynamics.remove_fixed_tree_joints!"><code>remove_fixed_tree_joints!</code></a>. Default: <code>true</code>.</li><li><code>gravity</code>: gravitational acceleration as a 3-vector expressed in the <code>Mechanism</code>&#39;s root frame. Default: <code>[0.0, 0.0, -9.81]</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.path" href="#RigidBodyDynamics.path"><code>RigidBodyDynamics.path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">path(mechanism, from, to)
</code></pre><p>Return the path from rigid body <code>from</code> to <code>to</code> along edges of the <code>Mechanism</code>&#39;s kinematic tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.point_acceleration" href="#RigidBodyDynamics.Spatial.point_acceleration"><code>RigidBodyDynamics.Spatial.point_acceleration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_acceleration(twist, accel, point)
</code></pre><p>Given the twist <span>$dot{T}_{j}^{k,i}$</span> of frame <span>$j$</span> with respect to frame <span>$i$</span>, expressed in frame <span>$k$</span> and its time derivative (a spatial acceleration), as well as the location of a point fixed in frame <span>$j$</span>, also expressed in frame <span>$k$</span>, compute the acceleration of the point relative to frame <span>$i$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.point_jacobian" href="#RigidBodyDynamics.point_jacobian"><code>RigidBodyDynamics.point_jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_jacobian(state, path, point)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.point_jacobian!" href="#RigidBodyDynamics.point_jacobian!"><code>RigidBodyDynamics.point_jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_jacobian!(out, state, path, point)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed if necessary.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.point_jacobian_doc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.point_velocity" href="#RigidBodyDynamics.Spatial.point_velocity"><code>RigidBodyDynamics.Spatial.point_velocity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_velocity(twist, point)
</code></pre><p>Given the twist <span>$T_{j}^{k,i}$</span> of frame <span>$j$</span> with respect to frame <span>$i$</span>, expressed in frame <span>$k$</span>, and the location of a point fixed in frame <span>$j$</span>, also expressed in frame <span>$k$</span>, compute the velocity of the point relative to frame <span>$i$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.position_bounds" href="#RigidBodyDynamics.position_bounds"><code>RigidBodyDynamics.position_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">position_bounds(joint)
</code></pre><p>Return a <code>Vector{Bounds{T}}</code> giving the upper and lower bounds of the configuration for <code>joint</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.predecessor" href="#RigidBodyDynamics.predecessor"><code>RigidBodyDynamics.predecessor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">predecessor(joint, mechanism)
</code></pre><p>Return the body &#39;before&#39; the joint, i.e. the &#39;tail&#39; of the joint interpreted as an arrow in the <code>Mechanism</code>&#39;s kinematic graph.</p><p>See <a href="#RigidBodyDynamics.Joint"><code>Joint</code></a>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.predsucc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.principal_value!" href="#RigidBodyDynamics.principal_value!"><code>RigidBodyDynamics.principal_value!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">principal_value!(q, joint)
</code></pre><p>Applies the principal<em>value functions from [Rotations.jl](https://github.com/FugroRoames/Rotations.jl/blob/d080990517f89b56c37962ad53a7fd24bd94b9f7/src/principal</em>value.jl) to joint angles. This currently only applies to <code>SPQuatFloating</code> joints.</p></div></div><div><div><pre><code class="language-julia">principal_value!(state)
</code></pre><p>Applies the principal<em>value functions from [Rotations.jl](https://github.com/FugroRoames/Rotations.jl/blob/d080990517f89b56c37962ad53a7fd24bd94b9f7/src/principal</em>value.jl) to joint angles. This currently only applies to <code>SPQuatFloating</code> joints.</p><p>For example:</p><ul><li>for a part of <span>$q$</span> corresponding to a revolute joint, this method is a no-op;</li><li>for a part of <span>$q$</span> corresponding to a <code>SPQuatFloating</code> joint this function applies</li></ul><p>`principal_value the orientation.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.quaternion_derivative</code></pre><pre><code class="language-none">RigidBodyDynamics.quatnorm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rand_chain_mechanism" href="#RigidBodyDynamics.rand_chain_mechanism"><code>RigidBodyDynamics.rand_chain_mechanism</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_chain_mechanism(?, jointtypes)
</code></pre><p>Create a random chain <code>Mechanism</code> with the given joint types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rand_configuration!" href="#RigidBodyDynamics.rand_configuration!"><code>RigidBodyDynamics.rand_configuration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_configuration!(q, joint)
</code></pre><p>Set <span>$q$</span> to a random configuration. The distribution used depends on the joint type.</p></div></div><div><div><pre><code class="language-julia">rand_configuration!(state)
</code></pre><p>Randomize the configuration vector <span>$q$</span>. The distribution depends on the particular joint types present in the associated <code>Mechanism</code>. The resulting <span>$q$</span> is guaranteed to be on the <code>Mechanism</code>&#39;s configuration manifold. Invalidates cache variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rand_floating_tree_mechanism" href="#RigidBodyDynamics.rand_floating_tree_mechanism"><code>RigidBodyDynamics.rand_floating_tree_mechanism</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Create a random tree <code>Mechanism</code>, with a quaternion floating joint as the first joint (between the root body and the first non-root body).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rand_tree_mechanism" href="#RigidBodyDynamics.rand_tree_mechanism"><code>RigidBodyDynamics.rand_tree_mechanism</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_tree_mechanism(?, parentselector, jointtypes)
</code></pre><p>Create a random tree <code>Mechanism</code> with the given joint types. Each new body is attached to a parent selected using the <code>parentselector</code> function.</p></div></div><div><div><p>Create a random tree <code>Mechanism</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rand_velocity!" href="#RigidBodyDynamics.rand_velocity!"><code>RigidBodyDynamics.rand_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand_velocity!(state)
</code></pre><p>Randomize the velocity vector <span>$v$</span>. Invalidates cache variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.rebuild_spanning_tree!" href="#RigidBodyDynamics.rebuild_spanning_tree!"><code>RigidBodyDynamics.rebuild_spanning_tree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rebuild_spanning_tree!(mechanism)
rebuild_spanning_tree!(mechanism, flipped_joint_map; next_edge)
</code></pre><p>Reconstruct the mechanism&#39;s spanning tree.</p><p>Optionally, the <code>flipped_joint_map</code> keyword argument can be used to pass in an associative container that will be populated with a mapping from original joints to flipped joints, if the rebuilding process required the polarity of some joints to be flipped.</p><p>Also optionally, <code>next_edge</code> can be used to select which joints should become part of the new spanning tree.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.register_modification!</code></pre><pre><code class="language-none">RigidBodyDynamics.relative_acceleration</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.relative_transform" href="#RigidBodyDynamics.relative_transform"><code>RigidBodyDynamics.relative_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">relative_transform(state, from, to)
</code></pre><p>Return the homogeneous transform from <code>from</code> to <code>to</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.relative_twist" href="#RigidBodyDynamics.relative_twist"><code>RigidBodyDynamics.relative_twist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">relative_twist(state, body, base)
</code></pre><p>Return the twist of <code>body</code> with respect to <code>base</code>, expressed in the <code>Mechanism</code>&#39;s root frame.</p></div></div><div><div><pre><code class="language-julia">relative_twist(state, body_frame, base_frame)
</code></pre><p>Return the twist of <code>body_frame</code> with respect to <code>base_frame</code>, expressed in the <code>Mechanism</code>&#39;s root frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.remove_fixed_tree_joints!" href="#RigidBodyDynamics.remove_fixed_tree_joints!"><code>RigidBodyDynamics.remove_fixed_tree_joints!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remove_fixed_tree_joints!(mechanism)
</code></pre><p>Remove any fixed joints present as tree edges in <code>mechanism</code> by merging the rigid bodies that these fixed joints join together into bodies with equivalent inertial properties. Return the fixed joints that were removed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.remove_joint!" href="#RigidBodyDynamics.remove_joint!"><code>RigidBodyDynamics.remove_joint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remove_joint!(mechanism, joint; flipped_joint_map, spanning_tree_next_edge)
</code></pre><p>Remove a joint from the mechanism. Rebuilds the spanning tree if the joint is part of the current spanning tree.</p><p>Optionally, the <code>flipped_joint_map</code> keyword argument can be used to pass in an associative container that will be populated with a mapping from original joints to flipped joints, if removing <code>joint</code> requires rebuilding the spanning tree of <code>mechanism</code> and the polarity of some joints needed to be changed in the process.</p><p>Also optionally, <code>spanning_tree_next_edge</code> can be used to select which joints should become part of the new spanning tree, if rebuilding the spanning tree is required.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.replace_joint!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.reset_contact_state!" href="#RigidBodyDynamics.reset_contact_state!"><code>RigidBodyDynamics.reset_contact_state!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset_contact_state!(state)
</code></pre><p>Reset all contact state variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.root_body" href="#RigidBodyDynamics.root_body"><code>RigidBodyDynamics.root_body</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">root_body(mechanism)
</code></pre><p>Return the root (stationary &#39;world&#39;) body of the <code>Mechanism</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.root_frame" href="#RigidBodyDynamics.root_frame"><code>RigidBodyDynamics.root_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">root_frame(mechanism)
</code></pre><p>Return the default frame of the root body.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.rotation</code></pre><pre><code class="language-none">RigidBodyDynamics.rotation_vector_rate</code></pre><pre><code class="language-none">RigidBodyDynamics.segments</code></pre><pre><code class="language-none">RigidBodyDynamics.set_acceleration!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.set_additional_state!" href="#RigidBodyDynamics.set_additional_state!"><code>RigidBodyDynamics.set_additional_state!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_additional_state!(state, s)
</code></pre><p>Set the vector of additional states <span>$s$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.set_angular_velocity!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_col!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.set_configuration!" href="#RigidBodyDynamics.set_configuration!"><code>RigidBodyDynamics.set_configuration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_configuration!(state, joint, config)
</code></pre><p>Set the part of the configuration vector associated with <code>joint</code>. Invalidates cache variables.</p></div></div><div><div><pre><code class="language-julia">set_configuration!(state, q)
</code></pre><p>Set the configuration vector <span>$q$</span>. Invalidates cache variables.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.set_contact_wrench!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_joint_to_predecessor!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_joint_to_successor!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_joint_wrench!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_linear_velocity!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_rotation!</code></pre><pre><code class="language-none">RigidBodyDynamics.set_translation!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.set_velocity!" href="#RigidBodyDynamics.set_velocity!"><code>RigidBodyDynamics.set_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_velocity!(state, joint, vel)
</code></pre><p>Set the part of the velocity vector associated with <code>joint</code>. Invalidates cache variables.</p></div></div><div><div><pre><code class="language-julia">set_velocity!(state, v)
</code></pre><p>Set the velocity vector <span>$v$</span>. Invalidates cache variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.setdirty!" href="#RigidBodyDynamics.setdirty!"><code>RigidBodyDynamics.setdirty!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setdirty!(state)
</code></pre><p>Invalidate all cache variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.simulate" href="#RigidBodyDynamics.simulate"><code>RigidBodyDynamics.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate(state0, final_time)
simulate(state0, final_time, control!; Δt, stabilization_gains)
</code></pre><p>Basic <code>Mechanism</code> simulation: integrate the state from time <span>$0$</span> to <code>final_time</code> starting from the initial state <code>state0</code>. Return a <code>Vector</code> of times, as well as <code>Vector</code>s of configuration vectors and velocity vectors at these times.</p><p>Optionally, a function (or other callable) can be passed in as the third argument (<code>control!</code>). <code>control!</code> will be called at each time step of the simulation and allows you to specify joint torques given the time and the state of the <code>Mechanism</code>. It should look like this:</p><pre><code class="language-julia">function control!(torques::AbstractVector, t, state::MechanismState)
    rand!(torques) # for example
end</code></pre><p>The integration time step can be specified using the <code>Δt</code> keyword argument (defaults to <code>1e-4</code>).</p><p>The <code>stabilization_gains</code> keyword argument can be used to set PD gains for Baumgarte stabilization, which can be used to prevent separation of non-tree (loop) joints. See Featherstone (2008), section 8.3 for more information. There are several options for specifying gains:</p><ul><li><code>nothing</code> can be used to completely disable Baumgarte stabilization.</li><li>Gains can be specifed on a per-joint basis using any <code>AbstractDict{JointID, &lt;:RigidBodyDynamics.PDControl.SE3PDGains}</code>, which maps the <code>JointID</code> for the non-tree joints of the mechanism to the gains for that joint.</li><li>As a special case of the second option, the same gains can be used for all joints by passing in a <code>RigidBodyDynamics.CustomCollections.ConstDict{JointID}</code>.</li></ul><p>The <a href="#RigidBodyDynamics.default_constraint_stabilization_gains"><code>default_constraint_stabilization_gains</code></a> function is called to produce the default gains, which use the last option.</p><p>Uses <code>MuntheKaasIntegrator</code>. See <a href="@ref"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a> for a lower level interface with more options.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.spatial_accelerations!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.spatial_inertia" href="#RigidBodyDynamics.spatial_inertia"><code>RigidBodyDynamics.spatial_inertia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the spatial inertia of the body. If the inertia is undefined, calling this method will result in an error.</p></div></div><div><div><pre><code class="language-julia">spatial_inertia(state, body)
spatial_inertia(state, body, safe)
</code></pre><p>Return the spatial inertia of <code>body</code> expressed in the root frame of the mechanism.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.spatial_inertia!" href="#RigidBodyDynamics.spatial_inertia!"><code>RigidBodyDynamics.spatial_inertia!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spatial_inertia!(body, inertia)
</code></pre><p>Set the spatial inertia of the body.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.spquat_derivative</code></pre><pre><code class="language-none">RigidBodyDynamics.stabilization_gains_doc</code></pre><pre><code class="language-none">RigidBodyDynamics.state_vector_eltype</code></pre><pre><code class="language-none">RigidBodyDynamics.statesum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.submechanism" href="#RigidBodyDynamics.submechanism"><code>RigidBodyDynamics.submechanism</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">submechanism(mechanism, submechanismroot)
</code></pre><p>Create a new <code>Mechanism</code> from the subtree of <code>mechanism</code> rooted at <code>submechanismroot</code>.</p><p>Also return mappings from the bodies and joints of the input mechanism to the bodies and joints of the submechanism.</p><p>Any non-tree joint in <code>mechanism</code> will appear in the returned <code>Mechanism</code> if and only if both its successor and its predecessor are part of the subtree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.subtree_mass" href="#RigidBodyDynamics.subtree_mass"><code>RigidBodyDynamics.subtree_mass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">subtree_mass(base, mechanism)
</code></pre><p>Return the mass of a subtree of a <code>Mechanism</code>, rooted at <code>base</code> (including the mass of <code>base</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.successor" href="#RigidBodyDynamics.successor"><code>RigidBodyDynamics.successor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">successor(joint, mechanism)
</code></pre><p>Return the body &#39;after&#39; the joint, i.e. the &#39;head&#39; of the joint interpreted as an arrow in the <code>Mechanism</code>&#39;s kinematic graph.</p><p>See <a href="#RigidBodyDynamics.Joint"><code>Joint</code></a>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.successorid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.supports" href="#RigidBodyDynamics.supports"><code>RigidBodyDynamics.supports</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">supports(joint, body, state)
</code></pre><p>Return whether <code>joint</code> supports <code>body</code>, i.e., <code>joint</code> is a tree joint on the path between <code>body</code> and the root.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.torque</code></pre><pre><code class="language-none">RigidBodyDynamics.torque!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.Spatial.transform" href="#RigidBodyDynamics.Spatial.transform"><code>RigidBodyDynamics.Spatial.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transform(x, t)
</code></pre><p>Return <code>x</code> transformed to <code>CartesianFrame3D</code> <code>t.from</code>.</p></div></div><div><div><pre><code class="language-julia">transform(x, t)
</code></pre><p>Return <code>x</code> transformed to <code>CartesianFrame3D</code> <code>t.from</code>.</p></div></div><div><div><pre><code class="language-julia">transform(jac, tf)
</code></pre><p>Transform the <code>GeometricJacobian</code> to a different frame.</p></div></div><div><div><pre><code class="language-julia">transform(twist, tf)
</code></pre><p>Transform the <code>Twist</code> to a different frame.</p></div></div><div><div><pre><code class="language-julia">transform(accel, old_to_new, twist_of_current_wrt_new, twist_of_body_wrt_base)
</code></pre><p>Transform the <code>SpatialAcceleration</code> to a different frame.</p><p>The transformation rule is obtained by differentiating the transformation rule for twists.</p></div></div><div><div><pre><code class="language-julia">transform(f, tf)
</code></pre><p>Transform the Momentum to a different frame.</p></div></div><div><div><pre><code class="language-julia">transform(f, tf)
</code></pre><p>Transform the Wrench to a different frame.</p></div></div><div><div><pre><code class="language-julia">transform(inertia, t)
</code></pre><p>Transform the <code>SpatialInertia</code> to a different frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.transform_to_root" href="#RigidBodyDynamics.transform_to_root"><code>RigidBodyDynamics.transform_to_root</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transform_to_root(state, body)
transform_to_root(state, body, safe)
</code></pre><p>Return the transform from <code>default_frame(body)</code> to the root frame of the mechanism.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.translation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.tree_joints" href="#RigidBodyDynamics.tree_joints"><code>RigidBodyDynamics.tree_joints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tree_joints(mechanism)
</code></pre><p>Return the <code>Joint</code>s that are part of the <code>Mechanism</code>&#39;s spanning tree as an iterable collection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.twist" href="#RigidBodyDynamics.twist"><code>RigidBodyDynamics.twist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">twist(state, joint)
twist(state, joint, safe)
</code></pre><p>Return the joint twist for the given joint, i.e. the twist of <code>frame_after(joint)</code> with respect to <code>frame_before(joint)</code>, expressed in the root frame of the mechanism.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.twist_wrt_world" href="#RigidBodyDynamics.twist_wrt_world"><code>RigidBodyDynamics.twist_wrt_world</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">twist_wrt_world(state, body)
twist_wrt_world(state, body, safe)
</code></pre><p>Return the twist of <code>default_frame(body)</code> with respect to the root frame of the mechanism, expressed in the root frame.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.update_bias_accelerations_wrt_world!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_constraint_wrench_subspaces!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_crb_inertias!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_joint_bias_accelerations!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_joint_twists!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_motion_subspaces!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_spatial_inertias!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_transforms!</code></pre><pre><code class="language-none">RigidBodyDynamics.update_twists_wrt_world!</code></pre><pre><code class="language-none">RigidBodyDynamics.upper</code></pre><pre><code class="language-none">RigidBodyDynamics.valuetype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity" href="#RigidBodyDynamics.velocity"><code>RigidBodyDynamics.velocity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity(state, joint)
</code></pre><p>Return the part of the velocity vector <span>$v$</span> associated with <code>joint</code>.</p></div></div><div><div><pre><code class="language-julia">velocity(state)
</code></pre><p>Return the velocity vector <span>$v$</span>.</p><p>Note that this function returns a read-write reference to a field in <code>state</code>. The user is responsible for calling <a href="#RigidBodyDynamics.setdirty!"><code>setdirty!</code></a> after modifying this vector to ensure that dependent cache variables are invalidated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity_bounds" href="#RigidBodyDynamics.velocity_bounds"><code>RigidBodyDynamics.velocity_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity_bounds(joint)
</code></pre><p>Return a <code>Vector{Bounds{T}}</code> giving the upper and lower bounds of the velocity for <code>joint</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity_index_to_joint_id" href="#RigidBodyDynamics.velocity_index_to_joint_id"><code>RigidBodyDynamics.velocity_index_to_joint_id</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity_index_to_joint_id(state, qindex)
</code></pre><p>Return the <code>JointID</code> of the joint associated with the given index into the velocity vector <span>$v$</span>.</p></div></div></section><pre><code class="language-none">RigidBodyDynamics.velocity_jacobian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity_range" href="#RigidBodyDynamics.velocity_range"><code>RigidBodyDynamics.velocity_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity_range(state, joint)
</code></pre><p>Return the range of indices into the joint velocity vector <span>$v$</span> corresponding to joint <code>joint</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity_to_configuration_derivative!" href="#RigidBodyDynamics.velocity_to_configuration_derivative!"><code>RigidBodyDynamics.velocity_to_configuration_derivative!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity_to_configuration_derivative!(q̇, joint, q, v)
</code></pre><p>Compute the time derivative <span>$\dot{q}$</span> of the joint configuration vector <span>$q$</span> given <span>$q$</span> and the joint velocity vector <span>$v$</span> (in place).</p><p>Note that this mapping is linear.</p><p>See also <a href="#RigidBodyDynamics.configuration_derivative_to_velocity!"><code>configuration_derivative_to_velocity!</code></a>, the inverse mapping.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.velocity_to_configuration_derivative_jacobian" href="#RigidBodyDynamics.velocity_to_configuration_derivative_jacobian"><code>RigidBodyDynamics.velocity_to_configuration_derivative_jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">velocity_to_configuration_derivative_jacobian(joint, q)
</code></pre><p>Compute the jacobian <span>$J_{v \rightarrow \dot{q}}$</span> which maps joint velocity to configuration derivative for the given joint:</p><div>\[\dot{q} = J_{v \rightarrow \dot{q}} v\]</div></div></div></section><pre><code class="language-none">RigidBodyDynamics.velocity_to_configuration_derivative_jacobian!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.URDF.write_urdf" href="#RigidBodyDynamics.URDF.write_urdf"><code>RigidBodyDynamics.URDF.write_urdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Serialize a <code>Mechanism</code> to the <a href="https://wiki.ros.org/urdf/XML/model">URDF</a> file format.</p><p>Limitations:</p><ul><li>for <code>&lt;link&gt;</code> tags, only the <code>&lt;inertial&gt;</code> tag is written; there is no support for <code>&lt;visual&gt;</code> and <code>&lt;collision&gt;</code> tags.</li><li>for <code>&lt;joint&gt;</code> tags, only the <code>&lt;origin&gt;</code>, <code>&lt;parent&gt;</code>, <code>&lt;child&gt;</code>, and <code>&lt;limit&gt;</code> tags are written. There is no support for the <code>&lt;calibration&gt;</code> and <code>&lt;safety_controller&gt;</code> tags.</li></ul><p>These limitations are simply due to the fact that <code>Mechanism</code>s do not store the required information to write these tags.</p><p>Keyword arguments:</p><ul><li><code>robot_name</code>: used to set the <code>name</code> attribute of the root <code>&lt;robot&gt;</code> tag in the URDF. Default: <code>nothing</code> (name attribute will not be set).</li><li><code>include_root</code>: whether to include <code>root_body(mechanism)</code> in the URDF. If <code>false</code>, joints with <code>root_body(mechanism)</code> as their predecessor will also be omitted. Default: <code>true</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.zero!" href="#RigidBodyDynamics.zero!"><code>RigidBodyDynamics.zero!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">zero!(state)
</code></pre><p>Zero both the configuration and velocity. Invalidates cache variables.</p><p>See <a href="#RigidBodyDynamics.zero_configuration!"><code>zero_configuration!</code></a>, <a href="#RigidBodyDynamics.zero_velocity!"><code>zero_velocity!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.zero_configuration!" href="#RigidBodyDynamics.zero_configuration!"><code>RigidBodyDynamics.zero_configuration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">zero_configuration!(q, joint)
</code></pre><p>Set <span>$q$</span> to the &#39;zero&#39; configuration, corresponding to an identity joint transform.</p></div></div><div><div><pre><code class="language-julia">zero_configuration!(state)
</code></pre><p>&#39;Zero&#39; the configuration vector <span>$q$</span>. Invalidates cache variables.</p><p>Note that when the <code>Mechanism</code> contains e.g. quaternion-parameterized joints, <span>$q$</span> may not actually be set to all zeros; the quaternion part of the configuration vector would be set to identity. The contract is that each of the joint transforms should be an identity transform.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.zero_torque!" href="#RigidBodyDynamics.zero_torque!"><code>RigidBodyDynamics.zero_torque!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">zero_torque!(torques, t, state)
</code></pre><p>A trivial controller that simply sets the torques to zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.zero_velocity!" href="#RigidBodyDynamics.zero_velocity!"><code>RigidBodyDynamics.zero_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">zero_velocity!(state)
</code></pre><p>Zero the velocity vector <span>$v$</span>. Invalidates cache variables.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
