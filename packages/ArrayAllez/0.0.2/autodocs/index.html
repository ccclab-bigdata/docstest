<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ArrayAllez.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ArrayAllez.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">ArrayAllez.ARVector</code></pre><pre><code class="language-none">ArrayAllez.ArrayAllez</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.Array_" href="#ArrayAllez.Array_"><code>ArrayAllez.Array_</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div><pre><code class="language-none">similar_(name, A)     ≈ similar(A)
Array_{T}(name, size) ≈ Array{T}(undef, size)</code></pre><p>New arrays for intermediate results, drawn from an LRU cache when <code>length(A) &gt;= 2000</code>. The cache&#39;s key uses <code>name::Symbol</code> as well as type &amp; size to ensure different uses don&#39;t collide.</p><pre><code class="language-none">copy_(name, A) = copyto!(similar_(name, A), A)</code></pre><p>Just like that.</p></div></div></div></section><pre><code class="language-none">ArrayAllez.CFloat</code></pre><pre><code class="language-none">ArrayAllez.CFloatArray</code></pre><pre><code class="language-none">ArrayAllez.CFloatMatrix</code></pre><pre><code class="language-none">ArrayAllez.CacheKey</code></pre><pre><code class="language-none">ArrayAllez.IVERBOSE</code></pre><pre><code class="language-none">ArrayAllez.RVector</code></pre><pre><code class="language-none">ArrayAllez.VEC</code></pre><pre><code class="language-none">ArrayAllez.__init__</code></pre><pre><code class="language-none">ArrayAllez.__inits__</code></pre><pre><code class="language-none">ArrayAllez._bsum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.broadsum" href="#ArrayAllez.broadsum"><code>ArrayAllez.broadsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">broadsum(*, A, B, C)       = sum(A .* B .* C)
broadsum(f,*, A,B)         = sum(f, A .* B)</code></pre><p>These aim to work exactly like <code>sum(broadcast(...))</code>, but without materialising the broadcast array. Simplest case works &amp; is fast. Version with <code>f</code> is slow. </p><pre><code class="language-none">broadsum(*, A, B; dims=1)  = sum(A .* B; dims=1)
broadsum!(Z, *,A,B)        = sum!(Z, A .* B)</code></pre><p>Similarly immitates <code>sum!(Z, broadcast(...))</code> without materialising.  Now uses <code>LazyArrays.BroadcastArray</code>. The in-place form is actually a little slower. </p></div></div></section><pre><code class="language-none">ArrayAllez.broadsum!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.bsum" href="#ArrayAllez.bsum"><code>ArrayAllez.bsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">broadsum(*, A, B, C)       = sum(A .* B .* C)
broadsum(f,*, A,B)         = sum(f, A .* B)</code></pre><p>These aim to work exactly like <code>sum(broadcast(...))</code>, but without materialising the broadcast array. Simplest case works &amp; is fast. Version with <code>f</code> is slow. </p><pre><code class="language-none">broadsum(*, A, B; dims=1)  = sum(A .* B; dims=1)
broadsum!(Z, *,A,B)        = sum!(Z, A .* B)</code></pre><p>Similarly immitates <code>sum!(Z, broadcast(...))</code> without materialising.  Now uses <code>LazyArrays.BroadcastArray</code>. The in-place form is actually a little slower. </p></div></div></section><pre><code class="language-none">ArrayAllez.bsum!</code></pre><pre><code class="language-none">ArrayAllez.cache</code></pre><pre><code class="language-none">ArrayAllez.checksum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.copy_" href="#ArrayAllez.copy_"><code>ArrayAllez.copy_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">similar_(name, A)     ≈ similar(A)
Array_{T}(name, size) ≈ Array{T}(undef, size)</code></pre><p>New arrays for intermediate results, drawn from an LRU cache when <code>length(A) &gt;= 2000</code>. The cache&#39;s key uses <code>name::Symbol</code> as well as type &amp; size to ensure different uses don&#39;t collide.</p><pre><code class="language-none">copy_(name, A) = copyto!(similar_(name, A), A)</code></pre><p>Just like that.</p></div></div></div></section><pre><code class="language-none">ArrayAllez.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.exp!" href="#ArrayAllez.exp!"><code>ArrayAllez.exp!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">exp!(A)
exp_(A) = exp!(similar(A), A)
exp0(A) ≈ exp.(A)</code></pre><p>Element-wise in-place exponential, and friends. Multi-threaded when <code>length(A) &gt;= 100</code>. Will be handled by <code>Yeppp</code> or <code>AppleAccelerate</code> if you load one of them. </p></div></div></section><pre><code class="language-none">ArrayAllez.exp!!</code></pre><pre><code class="language-none">ArrayAllez.exp0</code></pre><pre><code class="language-none">ArrayAllez.exp1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.exp_" href="#ArrayAllez.exp_"><code>ArrayAllez.exp_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">exp!(A)
exp_(A) = exp!(similar(A), A)
exp0(A) ≈ exp.(A)</code></pre><p>Element-wise in-place exponential, and friends. Multi-threaded when <code>length(A) &gt;= 100</code>. Will be handled by <code>Yeppp</code> or <code>AppleAccelerate</code> if you load one of them. </p></div></div></div></section><pre><code class="language-none">ArrayAllez.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.inv!" href="#ArrayAllez.inv!"><code>ArrayAllez.inv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inv!(A) ≈ 1 ./ A
inv!(A, b::Number) ≈ b ./ A</code></pre><p>And <code>inv_(A)</code> which copies, and <code>inv0(A)</code> simple broadcasting. Multi-threaded when <code>length(A) &gt;= 1000</code>. Will be handled by <code>AppleAccelerate</code> if you load it.</p></div></div></section><pre><code class="language-none">ArrayAllez.inv!!</code></pre><pre><code class="language-none">ArrayAllez.inv0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.inv_" href="#ArrayAllez.inv_"><code>ArrayAllez.inv_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">inv!(A) ≈ 1 ./ A
inv!(A, b::Number) ≈ b ./ A</code></pre><p>And <code>inv_(A)</code> which copies, and <code>inv0(A)</code> simple broadcasting. Multi-threaded when <code>length(A) &gt;= 1000</code>. Will be handled by <code>AppleAccelerate</code> if you load it.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.iscale!" href="#ArrayAllez.iscale!"><code>ArrayAllez.iscale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iscale!(A, b::Number) ≈ A ./ b
iscale!(A, v::Vector) ≈ A ./ v      # A::Matrix
iscale!(A, r::Adjoint) ≈ A ./ r     # r::RowVector / Transpose etc.
iscale!(A, B) ≈ A ./ B</code></pre><p>For each of these, there is also <code>iscale_(A, ...)</code> non-mutating but perhaps accellerated, and <code>iscale0(A, ...)</code> simple broadcasting. Finally there is <code>iscale!!(A, x)</code> which mutate both arguments, wihch may be a terrible idea.</p></div></div></section><pre><code class="language-none">ArrayAllez.iscale!!</code></pre><pre><code class="language-none">ArrayAllez.iscale0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.iscale_" href="#ArrayAllez.iscale_"><code>ArrayAllez.iscale_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">iscale!(A, b::Number) ≈ A ./ b
iscale!(A, v::Vector) ≈ A ./ v      # A::Matrix
iscale!(A, r::Adjoint) ≈ A ./ r     # r::RowVector / Transpose etc.
iscale!(A, B) ≈ A ./ B</code></pre><p>For each of these, there is also <code>iscale_(A, ...)</code> non-mutating but perhaps accellerated, and <code>iscale0(A, ...)</code> simple broadcasting. Finally there is <code>iscale!!(A, x)</code> which mutate both arguments, wihch may be a terrible idea.</p></div></div></div></section><pre><code class="language-none">ArrayAllez.load_note</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.log!" href="#ArrayAllez.log!"><code>ArrayAllez.log!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log!(A)
log_(A) ≈ log!(similar(A), A)
log0(A) = log.(A)</code></pre><p>Element-wise in-place natural logarithm, and friends. Multi-threaded when <code>length(A) &gt;= 100</code>. Will be handled by <code>Yeppp</code> or <code>AppleAccelerate</code> if you load one of them.</p></div></div></section><pre><code class="language-none">ArrayAllez.log!!</code></pre><pre><code class="language-none">ArrayAllez.log0</code></pre><pre><code class="language-none">ArrayAllez.log1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.log_" href="#ArrayAllez.log_"><code>ArrayAllez.log_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">log!(A)
log_(A) ≈ log!(similar(A), A)
log0(A) = log.(A)</code></pre><p>Element-wise in-place natural logarithm, and friends. Multi-threaded when <code>length(A) &gt;= 100</code>. Will be handled by <code>Yeppp</code> or <code>AppleAccelerate</code> if you load one of them.</p></div></div></div></section><pre><code class="language-none">ArrayAllez.osizes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.scale!" href="#ArrayAllez.scale!"><code>ArrayAllez.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scale!(A, b::Number) ≈ A .* b
scale!(A, v::Vector) ≈ A .* v       # A::Matrix
scale!(A, r::Adjoint) ≈ A .* r      # r::RowVector / Transpose etc.
scale!(A, B) ≈ A .* B</code></pre><p>For each of these, there is also also <code>scale_(A, ...)</code> non-mutating but perhaps accellerated, and <code>scale0(A, ...)</code> simple broadcasting.</p></div></div></section><pre><code class="language-none">ArrayAllez.scale!!</code></pre><pre><code class="language-none">ArrayAllez.scale0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.scale_" href="#ArrayAllez.scale_"><code>ArrayAllez.scale_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">scale!(A, b::Number) ≈ A .* b
scale!(A, v::Vector) ≈ A .* v       # A::Matrix
scale!(A, r::Adjoint) ≈ A .* r      # r::RowVector / Transpose etc.
scale!(A, B) ≈ A .* B</code></pre><p>For each of these, there is also also <code>scale_(A, ...)</code> non-mutating but perhaps accellerated, and <code>scale0(A, ...)</code> simple broadcasting.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArrayAllez.similar_" href="#ArrayAllez.similar_"><code>ArrayAllez.similar_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">similar_(name, A)     ≈ similar(A)
Array_{T}(name, size) ≈ Array{T}(undef, size)</code></pre><p>New arrays for intermediate results, drawn from an LRU cache when <code>length(A) &gt;= 2000</code>. The cache&#39;s key uses <code>name::Symbol</code> as well as type &amp; size to ensure different uses don&#39;t collide.</p><pre><code class="language-none">copy_(name, A) = copyto!(similar_(name, A), A)</code></pre><p>Just like that.</p></div></div></section><pre><code class="language-none">ArrayAllez.sum_</code></pre><pre><code class="language-none">ArrayAllez.↓</code></pre><pre><code class="language-none">ArrayAllez.⊙</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
