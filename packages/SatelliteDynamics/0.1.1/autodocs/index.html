<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SatelliteDynamics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SatelliteDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.AS2RAD" href="#SatelliteDynamics.Constants.AS2RAD"><code>SatelliteDynamics.Constants.AS2RAD</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Constant to convert arcseconds to radians. Equal to 2pi/(360*3600). [rad/as]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.AU" href="#SatelliteDynamics.Constants.AU"><code>SatelliteDynamics.Constants.AU</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Astronomical Unit. Equal to the mean distance of the Earth from the sun. TDB-compatible value. [m]</p><p>P. Gérard and B. Luzum, IERS Technical Note 36, 2010</p></div></div></section><pre><code class="language-none">SatelliteDynamics.Astrodynamics</code></pre><pre><code class="language-none">SatelliteDynamics.Attitude</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.C_LIGHT" href="#SatelliteDynamics.Constants.C_LIGHT"><code>SatelliteDynamics.Constants.C_LIGHT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Speed of light in vacuum. [m/s]</p><p>D. Vallado, <em>Fundamentals of Astrodynamics and Applications</em> (4th Ed.), 2010</p></div></div></section><pre><code class="language-none">SatelliteDynamics.Constants</code></pre><pre><code class="language-none">SatelliteDynamics.Coordinates</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.EOP" href="#SatelliteDynamics.Universe.EOP"><code>SatelliteDynamics.Universe.EOP</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Module-wide global EarthOrientationData object. This data object is used as the default source of Earth Orientation Data by reference system transformations if no explicit EarthOrientationData file is provided to those transformations.</p><p>This value can be overridden in your own code as follows:</p><pre><code class="language-julia">SatelliteDynamics.EOP = EarthOrientationData(:EOP_PRODUCT_CHOICE)</code></pre><p>This global variable defaults to use the module&#39;s internal version of <code>:FINALS_2000</code>  if it is not otherwise set/provided.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.EarthOrientationData" href="#SatelliteDynamics.Universe.EarthOrientationData"><code>SatelliteDynamics.Universe.EarthOrientationData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The EarthOrientationData constains a single data member of type  <code>Dict{Int32, Tuple{Float64, Float64, Float64}}</code> that stores the Earth Orientation parameters <code>UT1-UTC</code>, <code>xp</code>, and <code>yp</code> whose units are <em>meters</em>,  <em>radians</em>, and <em>radians</em>, respectively. <code>xp</code> and <code>yp</code> are the x- and  y-components of Earth&#39;s polar motion. The dictionary key is the Epoch the  parameters are for as a Modified Julian Day at 0h UTC.</p><p><strong>Arguments:</strong></p><ul><li><code>product::Symbol</code> The IERS product type can be <code>:C04_14</code>, <code>:C04_80</code>, or <code>:FINALS_2000</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.Epoch" href="#SatelliteDynamics.Time.Epoch"><code>SatelliteDynamics.Time.Epoch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>Epoch</code> type represents a single instant in time. It is used throughout the SatelliteDynamics module. It is meant to provide a clear definition of moments in time and provide a convenient interface display time in various representations as well as in differrent time systems. The internal data members are also chosen such that the representation maintains nanosecond-precision in reprersenation of time and doesn&#39;t accumulate floating-point arithmetic errors larger than nanoseconds even after centuries.</p><p>Supports <code>+</code>, <code>+=</code>, <code>-</code>, and <code>-=</code> operators. Two Epoch&#39;s can be differenced to return the time difference between two Epochs. If adding a <code>Real</code> number it is interpreted as an offset in seconds to add to the Epoch.</p><p>The class also supports all arithmetic operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></p><p>Arguments:</p><ul><li><code>year::Int</code> Year</li><li><code>year::Int</code> Month</li><li><code>year::Int</code> Day</li><li><code>hour::Int</code> Hour (optional)</li><li><code>minute::Int</code> Minute (optional)</li><li><code>second::Real</code> Seconds (optional)</li><li><code>nanoseconds::Real</code> Nanoseconds (optional)</li><li><code>tsys::Symbol</code>: Time system of the epoch at initialization</li></ul><p>The Epoch class can be also be initialized from a string. Examples of Valid String constructors are: </p><pre><code class="language-julia">epc = Epoch(&quot;2018-12-20&quot;)
epc = Epoch(&quot;2018-12-20T16:22:19.0Z&quot;)
epc = Epoch(&quot;2018-12-20T16:22:19.123Z&quot;)
epc = Epoch(&quot;2018-12-20T16:22:19.123456789Z&quot;)
epc = Epoch(&quot;2018-12-20T16:22:19Z&quot;)
epc = Epoch(&quot;20181220T162219Z&quot;)
epc = Epoch(&quot;2018-12-01 16:22:19 GPS&quot;)
epc = Epoch(&quot;2018-12-01 16:22:19.0 GPS&quot;)
epc = Epoch(&quot;2018-12-01 16:22:19.123 GPS&quot;)
epc = Epoch(&quot;2018-12-01 16:22:19.123456789 GPS&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.EulerAngle" href="#SatelliteDynamics.Attitude.EulerAngle"><code>SatelliteDynamics.Attitude.EulerAngle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>EulerAngle</code> type provides a represenation of EulerAngles for storing attitude information.</p><p>Valid sequences are: <code>121, 123, 131, 132, 212, 213, 231, 232, 312, 313, 321, 323</code>.</p><p>Data members:</p><ul><li><code>seq::Symbol</code>: Order of application of angles with respect to body axis.</li><li><code>phi::Float64</code>: First Euler angle</li><li><code>theta::Float64</code>: Second Euler angle</li><li><code>psi::Float64</code>: Third Euler angle</li></ul><p>References:</p><ol><li>J. Diebel, <em>Representing attitude: Euler angles, unit quaternions, and rotation vectors.</em> Matrix 58(15-16) (2006).</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.EulerAxis" href="#SatelliteDynamics.Attitude.EulerAxis"><code>SatelliteDynamics.Attitude.EulerAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>EulerAxis</code> type provides a representation of the Euler angle-and-axis attitude representation.</p><p>Data members:</p><ul><li><code>theta::Float64</code>: Angle of rotation</li><li><code>vec::Array{Float64, 1}</code>: Axis of rotation</li></ul><p>References:</p><ol><li>J. Diebel, <em>Representing attitude: Euler angles, unit quaternions, and rotation vectors.</em> Matrix 58(15-16) (2006).</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_EARTH" href="#SatelliteDynamics.Constants.GM_EARTH"><code>SatelliteDynamics.Constants.GM_EARTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s Gravitational constant [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_JUPITER" href="#SatelliteDynamics.Constants.GM_JUPITER"><code>SatelliteDynamics.Constants.GM_JUPITER</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Jupiter. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_MARS" href="#SatelliteDynamics.Constants.GM_MARS"><code>SatelliteDynamics.Constants.GM_MARS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Mars. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_MERCURY" href="#SatelliteDynamics.Constants.GM_MERCURY"><code>SatelliteDynamics.Constants.GM_MERCURY</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Mercury. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_MOON" href="#SatelliteDynamics.Constants.GM_MOON"><code>SatelliteDynamics.Constants.GM_MOON</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Moon. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_NEPTUNE" href="#SatelliteDynamics.Constants.GM_NEPTUNE"><code>SatelliteDynamics.Constants.GM_NEPTUNE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Neptune. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_PLUTO" href="#SatelliteDynamics.Constants.GM_PLUTO"><code>SatelliteDynamics.Constants.GM_PLUTO</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Pluto. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_SATURN" href="#SatelliteDynamics.Constants.GM_SATURN"><code>SatelliteDynamics.Constants.GM_SATURN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Saturn. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_SUN" href="#SatelliteDynamics.Constants.GM_SUN"><code>SatelliteDynamics.Constants.GM_SUN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Sun. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_URANUS" href="#SatelliteDynamics.Constants.GM_URANUS"><code>SatelliteDynamics.Constants.GM_URANUS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Uranus. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GM_VENUS" href="#SatelliteDynamics.Constants.GM_VENUS"><code>SatelliteDynamics.Constants.GM_VENUS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Gravitational constant of the Venus. [m^3/s^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GPS_TAI" href="#SatelliteDynamics.Constants.GPS_TAI"><code>SatelliteDynamics.Constants.GPS_TAI</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of GPS time system with respect to TAI time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GPS_TT" href="#SatelliteDynamics.Constants.GPS_TT"><code>SatelliteDynamics.Constants.GPS_TT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of GPS time system with respect to TT time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.GPS_ZERO" href="#SatelliteDynamics.Constants.GPS_ZERO"><code>SatelliteDynamics.Constants.GPS_ZERO</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Modified Julian Date of the start of the GPS time system in the GPS time system. This date was January 6, 1980 0H as reckond in the UTC time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.GRAVITY_MODEL" href="#SatelliteDynamics.Universe.GRAVITY_MODEL"><code>SatelliteDynamics.Universe.GRAVITY_MODEL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Module-wide global GravityModel object. This data object is used as the default spherical harmonic gravity field unless one is otherwise provided.</p><p>This value can be overridden in your own code as follows:</p><pre><code class="language-julia">SatelliteDynamics.GravityModel = GravityModel(PATH_TO_YOUR_GRAVITY_MODEL)</code></pre><p>This global variable defaults to use the module&#39;s internal version of the EGM2008 model truncated to order and degree 90, if it is not otherwise set.</p></div></div></section><pre><code class="language-none">SatelliteDynamics.GRAV_COEF</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.GravModel" href="#SatelliteDynamics.Universe.GravModel"><code>SatelliteDynamics.Universe.GravModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>GravModel stores a spherical harmonic gravity field in memory. Can store normalized or denomalized coefficients. Package contains EGM2008, GGM01S, and GGM0S gravity models, as well as the default gravity model of EGM2008 truncated to degree and order 90.</p><p>Additional gravity field models can be downloaded from: <a href="http://icgem.gfz-potsdam.de/home">http://icgem.gfz-potsdam.de/home</a></p><p><strong>Arguments:</strong></p><ul><li><code>filepath::string</code> Path to spherical harmonic gravity model file.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.J2_EARTH" href="#SatelliteDynamics.Constants.J2_EARTH"><code>SatelliteDynamics.Constants.J2_EARTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s first zonal harmonic. [dimensionless]</p><p>GGM05s Gravity Model.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.MJD2000" href="#SatelliteDynamics.Constants.MJD2000"><code>SatelliteDynamics.Constants.MJD2000</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Modified Julian Date of January 1, 2000 00:00:00. Value is independent of time scale.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.MJD_ZERO" href="#SatelliteDynamics.Constants.MJD_ZERO"><code>SatelliteDynamics.Constants.MJD_ZERO</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of Modified Julian Days representation with respect to Julian Days. For  a time, t, MJD_ZERO is equal to:</p><pre><code class="language-none">MJD_ZERO = t_jd - t_mjd</code></pre><p>Where t<em>jd is the epoch represented in Julian Days, and t</em>mjd is the epoch in Modified Julian Days.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.OMEGA_EARTH" href="#SatelliteDynamics.Constants.OMEGA_EARTH"><code>SatelliteDynamics.Constants.OMEGA_EARTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth axial rotation rate. [rad/s]</p><p>D. Vallado, <em>Fundamentals of Astrodynamics and Applications</em> (4th Ed.), p. 222, 2010</p></div></div></section><pre><code class="language-none">SatelliteDynamics.OrbitDynamics</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.POLE_LOCATOR" href="#SatelliteDynamics.Universe.POLE_LOCATOR"><code>SatelliteDynamics.Universe.POLE_LOCATOR</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the location of the pole. Returns x- and y- components as a tuple with the units of [radians].  If the EarthOrientationData argument is ommitted the function will use the default module-global value.</p><p><strong>Arguments:</strong></p><ul><li><code>eop::EarthOrientationData</code> EarthOrientationData object to use to compute the offset</li><li><code>mjd::Real</code> Modified Julian Date in UTC of the Epoch for which the pole locator is desired.</li><li><code>interp::Bool</code> Whether to linearly interpolate the parameter data to the input MJD.</li></ul><p><strong>Returns:</strong></p><ul><li><code>pole_locator::Tuple{ -Float, Float}</code> (x, y) pole location in radians.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.P_SUN" href="#SatelliteDynamics.Constants.P_SUN"><code>SatelliteDynamics.Constants.P_SUN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Nominal solar radiation pressure at 1 AU. [N/m^2]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.Quaternion" href="#SatelliteDynamics.Attitude.Quaternion"><code>SatelliteDynamics.Attitude.Quaternion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>Quaternion</code> type defines a <em>scalar-first</em> quaternion for representation of attitude.</p><p>Data members:</p><ul><li><code>q0::Float64</code>: Scalar part of quaternion</li><li><code>q1::Float64</code>: First vector component of quaternion</li><li><code>q2::Float64</code>: Second vector component of quaternion</li><li><code>q3::Float64</code>: Third vector component of quaternion</li></ul><p>References:</p><ol><li>J. Diebel, <em>Representing attitude: Euler angles, unit quaternions, and rotation vectors.</em> Matrix 58(15-16) (2006).</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.RAD2AS" href="#SatelliteDynamics.Constants.RAD2AS"><code>SatelliteDynamics.Constants.RAD2AS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Constant to convert radians to arcseconds. Equal to 2pi/(360*3600) [as/ras]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.R_EARTH" href="#SatelliteDynamics.Constants.R_EARTH"><code>SatelliteDynamics.Constants.R_EARTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s equatorial radius. [m]</p><p>GGM05s Gravity Model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.R_SUN" href="#SatelliteDynamics.Constants.R_SUN"><code>SatelliteDynamics.Constants.R_SUN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Nominal solar photospheric radius. [m]</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><pre><code class="language-none">SatelliteDynamics.ReferenceSystems</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.Rx" href="#SatelliteDynamics.Attitude.Rx"><code>SatelliteDynamics.Attitude.Rx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rotation matrix, for a rotation about the x-axis.</p><p>Arguments:</p><ul><li><code>angle::Real</code>: Counter-clockwise angle of rotation as viewed looking back along the postive direction of the rotation axis.</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li></ul><p>Returns:</p><ul><li><code>r::Array{&lt;:Real, 2}</code>: Rotation matrix</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.27.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.Ry" href="#SatelliteDynamics.Attitude.Ry"><code>SatelliteDynamics.Attitude.Ry</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rotation matrix, for a rotation about the y-axis.</p><p>Arguments:</p><ul><li><code>angle::Real</code>: Counter-clockwise angle of rotation as viewed looking back along the postive direction of the rotation axis.</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li></ul><p>Returns:</p><ul><li><code>r::Array{&lt;:Real, 2}</code>: Rotation matrix</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.27.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.Rz" href="#SatelliteDynamics.Attitude.Rz"><code>SatelliteDynamics.Attitude.Rz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rotation matrix, for a rotation about the z-axis.</p><p>Arguments:</p><ul><li><code>angle::Real</code>: Counter-clockwise angle of rotation as viewed looking back along the postive direction of the rotation axis.</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li></ul><p>Returns:</p><ul><li><code>r::Array{&lt;:Real, 2}</code>: Rotation matrix</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.27.</li></ol></div></div></section><pre><code class="language-none">SatelliteDynamics.SatelliteDynamics</code></pre><pre><code class="language-none">SatelliteDynamics.Simulation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.TAI_GPS" href="#SatelliteDynamics.Constants.TAI_GPS"><code>SatelliteDynamics.Constants.TAI_GPS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of TAI time system with respect to GPS time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.TAI_TT" href="#SatelliteDynamics.Constants.TAI_TT"><code>SatelliteDynamics.Constants.TAI_TT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of TAI time system with respect to TT time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.TT_GPS" href="#SatelliteDynamics.Constants.TT_GPS"><code>SatelliteDynamics.Constants.TT_GPS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of TT time system with respect to GPS time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.TT_TAI" href="#SatelliteDynamics.Constants.TT_TAI"><code>SatelliteDynamics.Constants.TT_TAI</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Offset of TT time system with respect to TAI time system.</p><p>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and  Applications</em>, 2012.</p></div></div></section><pre><code class="language-none">SatelliteDynamics.Time</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.UT1_UTC" href="#SatelliteDynamics.Universe.UT1_UTC"><code>SatelliteDynamics.Universe.UT1_UTC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the offset between the UT1 and UTC time systems in seconds. If the EarthOrientationData argument is ommitted the function will use the default module-global value.</p><p><strong>Arguments:</strong></p><ul><li><code>eop::EarthOrientationData</code> EarthOrientationData object to use to compute the offset</li><li><code>mjd::Real</code> Modified Julian Date in UTC of the Epoch for which the UT1-UTC offset is desired.</li><li><code>interp::Bool</code> Whether to linearly interpolate the parameter data to the input MJD.</li></ul><p><strong>Returns:</strong></p><ul><li><code>ut1_utc::Float</code> UT1 - UTC offset. [s] </li></ul></div></div></section><pre><code class="language-none">SatelliteDynamics.Universe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.WGS84_a" href="#SatelliteDynamics.Constants.WGS84_a"><code>SatelliteDynamics.Constants.WGS84_a</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s semi-major axis as defined by the WGS84 geodetic system. [m]</p><p>NIMA Technical Report TR8350.2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.WGS84_f" href="#SatelliteDynamics.Constants.WGS84_f"><code>SatelliteDynamics.Constants.WGS84_f</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s ellipsoidal flattening.  WGS84 Value.</p><p>NIMA Technical Report TR8350.2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.XP" href="#SatelliteDynamics.Universe.XP"><code>SatelliteDynamics.Universe.XP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the x-component of the pole locator in [radians]. If the first EarthOrientationData argument is ommitted the function will use the default module-global value.</p><p><strong>Arguments:</strong></p><ul><li><code>eop::EarthOrientationData</code> EarthOrientationData object to use to compute the offset</li><li><code>mjd::Real</code> Modified Julian Date in UTC of the Epoch for which the xp value is desired.</li><li><code>interp::Bool</code> Whether to linearly interpolate the parameter data to the input MJD.</li></ul><p><strong>Returns:</strong></p><ul><li><code>xp::Float</code> x-component of pole locator in radians.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.YP" href="#SatelliteDynamics.Universe.YP"><code>SatelliteDynamics.Universe.YP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the y-component of the pole locator in [radians]. If the first EarthOrientationData argument is ommitted the function will use the default module-global value.</p><p><strong>Arguments:</strong></p><ul><li><code>eop::EarthOrientationData</code> EarthOrientationData object to use to compute the offset</li><li><code>mjd::Real</code> Modified Julian Date in UTC of the Epoch for which the yp value is desired.</li><li><code>interp::Bool</code> Whether to linearly interpolate the parameter data to the input MJD.</li></ul><p><strong>Returns:</strong></p><ul><li><code>yp::Float</code> y-component of pole locator in radians.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_drag" href="#SatelliteDynamics.OrbitDynamics.accel_drag"><code>SatelliteDynamics.OrbitDynamics.accel_drag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the perturbing, non-conservative acceleration caused by atmospheric drag assuming that the ballistic properties of the spacecraft are captured by the coefficient of drag.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>rho::Real</code>: atmospheric density [kg/m^3]</li><li><code>mass::Real</code>: Spacecraft mass [kg]</li><li><code>area::Real</code>: Wind-facing cross-sectional area [m^2]</li><li><code>Cd::Real</code>: coefficient of drag [dimensionless]</li><li><code>T::Array{&lt;:Real, 2}</code>: Rotation matrix from the inertial to the true-of-date frame</li></ul><p>Return:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Acceleration due to drag in the X, Y, and Z inertial directions. [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.83-86.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_gravity" href="#SatelliteDynamics.OrbitDynamics.accel_gravity"><code>SatelliteDynamics.OrbitDynamics.accel_gravity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the accleration caused by Earth gravity as modeled by a spherical  harmonic gravity field.</p><p>Arguments:</p><ul><li><code>r_sat::Array{&lt;:Real, 1}</code>: Satellite position in the inertial frame [m]</li><li><code>R_eci_ecef::Array{&lt;:Real, 2}</code>: Rotation matrix transforming a vector from the inertial to body-fixed reference frames. </li><li><code>n_max::Integer</code>: Maximum degree coefficient to use in expansion</li><li><code>m_max::Integer</code>: Maximum order coefficient to use in the expansion. Must be less than the degree.</li></ul><p>Return:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Gravitational acceleration in X, Y, and Z inertial directions [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.56-68.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_point_mass" href="#SatelliteDynamics.OrbitDynamics.accel_point_mass"><code>SatelliteDynamics.OrbitDynamics.accel_point_mass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the acceleration of a satellite caused by a point-mass approximation  of the central body. Returns the acceleration vector of the satellite.</p><p>Assumes the satellite is much, much less massive than the central body.</p><p>Arguments:</p><ul><li><code>r_sat::Array{&lt;:Real, 1}</code>: satellite position in a commonn inertial frame [m]</li><li><code>r_body::Array{&lt;:Real, 1}</code>: position of body in a commonn inertial frame [m]</li><li><code>GM::Array{&lt;:Real, 1}</code>: gravitational coeffient of attracting body [m^3/s^2] Default: SatelliteDynamics.Constants.GM_EARTH)</li></ul><p>(Default: SatelliteDynamics.Constants.GM_EARTH</p><p>Return:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Acceleration in X, Y, and Z inertial directions [m/s^2]</li></ul></div></div><div><div><p>Computes the acceleration on a satellite caused by a point-mass approximation  of a massive body. Returns the acceleration vector of the satellite.</p><p>Arguments:</p><ul><li><code>r_sat::Array{&lt;:Real, 1}</code>: satellite position in the inertial frame [m]</li><li><code>GM::Array{&lt;:Real, 1}</code>: gravitational coeffient of attracting body [m^3/s^2] Default: SatelliteDynamics.Constants.GM_EARTH)</li></ul><p>(Default: SatelliteDynamics.Constants.GM_EARTH</p><p>Return:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Acceleration in X, Y, and Z inertial directions [m/s^2]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_relativity" href="#SatelliteDynamics.OrbitDynamics.accel_relativity"><code>SatelliteDynamics.OrbitDynamics.accel_relativity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes perturbation accleration of a satellite in the Inertial frame due to the combined effects of special and general relativity.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li></ul><p>Returns:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Satellite acceleration due to relativity. [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.110-112.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_srp" href="#SatelliteDynamics.OrbitDynamics.accel_srp"><code>SatelliteDynamics.OrbitDynamics.accel_srp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the perturbing acceleration due to direct solar radiation  pressure assuming the reflecting surface is a flat plate pointed directly at the Sun.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li></ul><p>Returns:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Satellite acceleration due to solar radiation pressure [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.77-79.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_thirdbody_moon" href="#SatelliteDynamics.OrbitDynamics.accel_thirdbody_moon"><code>SatelliteDynamics.OrbitDynamics.accel_thirdbody_moon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the acceleration of a satellite in the inertial frame due to the gravitational attraction of the Moon.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>r_moon::Array{&lt;:Real, 1}</code>: Position of moon in inertial frame.</li></ul><p>Returns:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Acceleration due to the Moon&#39;s gravity in the inertial frame [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.69-70.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.accel_thirdbody_sun" href="#SatelliteDynamics.OrbitDynamics.accel_thirdbody_sun"><code>SatelliteDynamics.OrbitDynamics.accel_thirdbody_sun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the acceleration of a satellite in the inertial frame due to the gravitational attraction of the Sun.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>r_sun::Array{&lt;:Real, 1}</code>: Position of sun in inertial frame.</li></ul><p>Return:</p><ul><li><code>a::Array{&lt;:Real, 1}</code>: Acceleration due to the Sun&#39;s gravity in the inertial frame [m/s^2]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.69-70.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.anomaly_eccentric_to_mean" href="#SatelliteDynamics.Astrodynamics.anomaly_eccentric_to_mean"><code>SatelliteDynamics.Astrodynamics.anomaly_eccentric_to_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert eccentric anomaly into mean anomaly.</p><p>Arguments:</p><ul><li><code>E::Real</code>: Eccentric anomaly. [rad] or [deg]</li><li><code>e::Real</code>: Eccentricity. [dimensionless]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input will be interpreted as being in degrees, and output will be returned in degrees.</li></ul><p>Returns:</p><ul><li><code>M::Real</code>: Mean anomaly. [rad] or [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.anomaly_mean_to_eccentric" href="#SatelliteDynamics.Astrodynamics.anomaly_mean_to_eccentric"><code>SatelliteDynamics.Astrodynamics.anomaly_mean_to_eccentric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert mean anomaly into eccentric anomaly.</p><p>Arguments:</p><ul><li><code>M::Real</code>: Mean anomaly. [deg] or [deg]</li><li><code>e::Real</code>: Eccentricity. [dimensionless]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input will be interpreted as being in degrees, and output will be returned in degrees.</li></ul><p>Returns:</p><ul><li><code>E::Real</code>: Eccentric anomaly. [rad] or [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.as_matrix" href="#SatelliteDynamics.Attitude.as_matrix"><code>SatelliteDynamics.Attitude.as_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the rotation matrix representation of a Quaternion.</p><p>Arguments:</p><ul><li><code>q::Quaternion</code>: Quaternion</li></ul><p>Returns:</p><ul><li><code>mat::Array{Float64, 2}</code>: Rotation Matrix on SO(3).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.as_vector" href="#SatelliteDynamics.Attitude.as_vector"><code>SatelliteDynamics.Attitude.as_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return quaternion as a vector. </p><p>Equivalent to q[:]</p><p>Arguments:</p><ul><li><code>q::Quaternion</code>: Quaternion</li></ul><p>Returns:</p><ul><li><code>vec::Array{Float64, 1}</code>: Quaternion as a (4,) vector</li></ul></div></div><div><div><p>Return Euler angles as a vector.</p><p>Equivalent to: <code>[e.phi, e.theta, e.psi]</code> for <code>EulerAngle</code> <code>e</code></p><p>Arguments:</p><ul><li><code>e::EulerAngle</code> Euler Angle</li></ul><p>Returns:</p><ul><li><code>evec::Array{Float64, 1}</code> Euler angles components in vector form.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.bias_precession_nutation" href="#SatelliteDynamics.ReferenceSystems.bias_precession_nutation"><code>SatelliteDynamics.ReferenceSystems.bias_precession_nutation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the Bias-Precession-Nutation matrix transforming the GCRS to the  CIRS intermediate reference frame. This transformation corrects for the  bias, precession, and nutation of Celestial Intermediate Origin (CIO) with respect to inertial space.</p><p><strong>Arguments:</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li></ul><p><strong>Returns:</strong></p><ul><li><code>rc2i::Array{&lt;:Real, 2}</code>: 3x3 Rotation matrix transforming GCRS -&gt; CIRS</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.caldate" href="#SatelliteDynamics.Time.caldate"><code>SatelliteDynamics.Time.caldate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the Gregorian calendar date for a specific </p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Input epoch</li><li><code>tsys::Symbol</code>: Time system to compute output in.</li></ul><p>Returns:</p><ul><li><code>year::Int</code>: Year of epoch</li><li><code>month::Int</code>: Month of epoch</li><li><code>day::Int</code>: Day of epoch</li><li><code>hour::Int</code>: Hour of epoch</li><li><code>minute::Int</code>: Minute of epoch</li><li><code>second::Int</code>: Second of epoch</li><li><code>nanoseconds::Int</code>: Year of epoch</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.caldate_to_jd" href="#SatelliteDynamics.Time.caldate_to_jd"><code>SatelliteDynamics.Time.caldate_to_jd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert a Gregorian calendar date to the equivalent Julian Date representation of that time instant.</p><p><strong>Aguments:</strong></p><ul><li><code>year::Integer</code>: Year</li><li><code>year::Integer</code>: Month</li><li><code>year::Integer</code>: Day</li><li><code>hour::Integer</code>: Hour</li><li><code>minute::Integer</code>: Minute </li><li><code>second::Real</code>: Seconds</li><li><code>nanoseconds::Real</code>: Nanoseconds</li></ul><p><strong>Returns:</strong></p><ul><li><code>mjd::Float64</code>: Julian Date of Epoch</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.caldate_to_mjd" href="#SatelliteDynamics.Time.caldate_to_mjd"><code>SatelliteDynamics.Time.caldate_to_mjd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert a Gregorian calendar date to the equivalent Modified Julian Date representation of that time instant.</p><p><strong>Aguments:</strong></p><ul><li><code>year::Integer</code> Year</li><li><code>year::Integer</code> Month</li><li><code>year::Integer</code> Day</li><li><code>hour::Integer</code> Hour</li><li><code>minute::Integer</code> Minute </li><li><code>second::Real</code> Seconds</li><li><code>nanoseconds::Real</code> Nanoseconds</li></ul><p><strong>Returns:</strong></p><ul><li><code>mjd::Float64</code> Modified Julian Date of Epoch</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.day_of_year" href="#SatelliteDynamics.Time.day_of_year"><code>SatelliteDynamics.Time.day_of_year</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the day-of-year number for a given <code>Epoch</code>. </p><p>January 1 0h of each year will return 1.</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>tsys::Symbol</code>: Time system to return output in</li></ul><p>Returns:</p><ul><li><code>doy::Real</code>: Day of year number. </li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.days_from_elapsed" href="#SatelliteDynamics.Time.days_from_elapsed"><code>SatelliteDynamics.Time.days_from_elapsed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the day number in a given time scale given the elapsed time since epoch and the epoch itself.</p><p>Assumes all days are counted using a uniform 86400.0 seconds over the time span.</p><p><strong>Arguments:</strong></p><ul><li><code>t::Real</code>: Elapsed seconds since the <code>day_epoch</code>.</li><li><code>day_epoch::Real</code>: Day number of the epoch. Common values are <code>SatelliteDynamics.Constants.MJD_ZERO</code> (to get the Julian Day number) or <code>SatelliteDynamics.Constants.MJD2000</code> (to get Modified Julian Days if reckoning time from January 1, 2000 0H)</li></ul><p><strong>Returns:</strong></p><ul><li><code>days::Float</code>: Number of elapsed days in the time scale.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.density_harris_priester" href="#SatelliteDynamics.OrbitDynamics.density_harris_priester"><code>SatelliteDynamics.OrbitDynamics.density_harris_priester</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the local density using the Harris-Priester density model.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>r_sun::Array{&lt;:Real, 1}</code>: Position of sun in inertial frame.</li></ul><p>Returns:</p><ul><li><code>rho:Float64</code>: Local atmospheric density [kg/m^3]</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.89-91.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.deriv_orbit_earth" href="#SatelliteDynamics.OrbitDynamics.deriv_orbit_earth"><code>SatelliteDynamics.OrbitDynamics.deriv_orbit_earth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the state derivative.</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Current epoch</li><li><code>x::Array{&lt;:Real, 1}</code>: Satellite state vector</li><li><code>mass::Real</code>: Satellite mass [kg]</li><li><code>area_drag</code>: Velocity-facing area affected by drag. [m^2]</li><li><code>coef_drag</code>: Coefficient of drag [dimensionless]</li><li><code>area_srp</code>: Velocity-facing area affected by drag. [m^2]</li><li><code>coef_srp</code>: Coefficient of reflectivity [dimensionless]  </li><li><code>n_grav::Integer</code>: Gravity model degree (Default: 20)</li><li><code>m_grav::Integer</code>: Gravity model order (Default: 20)</li><li><code>drag::Bool</code>: Include cannonball atomospheric drag in force model (Default: <code>true</code>)</li><li><code>srp::Bool</code>: Include flat-plate solar radiation pressure in force model (Default: <code>true</code>)</li><li><code>moon::Bool</code>: Include thridbody lunar gravity in force model (Default: <code>true</code>)</li><li><code>sun::Bool</code>: Include thirdbody solar in force model (Default: <code>true</code>)</li><li><code>relativity::Bool</code>: Include relativistic effects in force model (Default: <code>true</code>)</li></ul><p>Returns:</p><ul><li><code>dx::Array{&lt;:Float64, 1}</code>: Satellite state derivative, velocity and accelerations [m; m/s]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Constants.e_EARTH" href="#SatelliteDynamics.Constants.e_EARTH"><code>SatelliteDynamics.Constants.e_EARTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Earth&#39;s first eccentricity. WGS84 Value. [dimensionless]</p><p>NIMA Technical Report TR8350.2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.earth_rotation" href="#SatelliteDynamics.ReferenceSystems.earth_rotation"><code>SatelliteDynamics.ReferenceSystems.earth_rotation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the Earth rotation matrix transforming the CIRS to the TIRS intermediate reference frame. This transformation corrects for the Earth rotation.</p><p><strong>Arguments:</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li></ul><p><strong>Returns:</strong></p><ul><li><code>r::Array{&lt;:Real, 2}</code>: 3x3 Rotation matrix transforming CIRS -&gt; TIRS</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.eclipse_conical" href="#SatelliteDynamics.OrbitDynamics.eclipse_conical"><code>SatelliteDynamics.OrbitDynamics.eclipse_conical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the illumination fraction of a satellite in Earth orbit using a conical Earth shadow model.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>r_sun::Array{&lt;:Real, 1}</code>: Position of sun in inertial frame.</li></ul><p>Return:</p><ul><li><code>nu::Float64</code>: Illumination fraction (0 &lt;= nu &lt;= 1). nu = 0 means spacecraft in complete shadow, nu = 1 mean spacecraft fully illuminated by sun.</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.80-83.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.eclipse_cylindrical" href="#SatelliteDynamics.OrbitDynamics.eclipse_cylindrical"><code>SatelliteDynamics.OrbitDynamics.eclipse_cylindrical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the illumination fraction of a satellite in Earth orbit using a cylindrical Earth shadow model.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Satellite Cartesean state in the inertial reference frame [m; m/s]</li><li><code>r_sun::Array{&lt;:Real, 1}</code>: Position of sun in inertial frame.</li></ul><p>Return:</p><ul><li><code>nu::Float64</code>: Illumination fraction (0 &lt;= nu &lt;= 1). nu = 0 means spacecraft in complete shadow, nu = 1 mean spacecraft fully illuminated by sun.</li></ul><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.80-83.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.elapsed_from_epoch" href="#SatelliteDynamics.Time.elapsed_from_epoch"><code>SatelliteDynamics.Time.elapsed_from_epoch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the number of elapsed seconds since a given Epoch from the day number. Can be used to compute the elapsed time since a given Julian or Modified Julian Date.</p><p><strong>Arguments:</strong></p><ul><li><code>day_number::Real</code>: Day number, can contain fractional days. Asummes all days are a uniform 86400.0 seconds in length.</li><li><code>day_epoch::Real</code>: Modified Julian Date of Epoch</li></ul><p><strong>Returns:</strong></p><ul><li><code>t::Float</code>: Number of elapsed seconds between the Provided Modified   Julian date and the epoch.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.epoch_to_jdfd" href="#SatelliteDynamics.Time.epoch_to_jdfd"><code>SatelliteDynamics.Time.epoch_to_jdfd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the two-part date format used by SOFA.jl functions forr a given Epoch.</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>tsys::Symbol</code>: Time system to return output in</li></ul><p>Returns:</p><ul><li><code>d1::Real</code>: First part of two part date. [days]</li><li><code>d2::Real</code>: Second part of two part date. [days]</li></ul></div></div></section><pre><code class="language-none">SatelliteDynamics.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.gast" href="#SatelliteDynamics.Time.gast"><code>SatelliteDynamics.Time.gast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Greenwich Mean Sidereal Time for the given Epoch.</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>use_degrees::Bool</code>: Return output in degrees (Default: false)</li></ul><p>Returns:</p><ul><li><code>gast::Real</code>: Greenwich Apparent Sidereal Time [rad/deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.gmst" href="#SatelliteDynamics.Time.gmst"><code>SatelliteDynamics.Time.gmst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Greenwich Mean Sidereal Time for the given Epoch.</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>use_degrees::Bool</code>: Return output in degrees (Default: false)</li></ul><p>Returns:</p><ul><li><code>gmst::Real</code>: Greenwich Mean Sidereal Time [rad/deg]</li></ul></div></div></section><pre><code class="language-none">SatelliteDynamics.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.jd" href="#SatelliteDynamics.Time.jd"><code>SatelliteDynamics.Time.jd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Julian Date for a specific epoch</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>tsys::Symbol</code>: Time system to return output in</li></ul><p>Returns:</p><ul><li><code>jd::Real</code>: Julian date of the epoch in the requested time system</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.jd_to_caldate" href="#SatelliteDynamics.Time.jd_to_caldate"><code>SatelliteDynamics.Time.jd_to_caldate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert a Julian Date to the equivalent Gregorian calendar date representation of the same instant in time.</p><p><strong>Aguments:</strong></p><ul><li><code>jd::Real</code>: Julian Date of Epoch</li></ul><p><strong>Returns:</strong></p><ul><li><code>year::Int32</code>: Year</li><li><code>year::Int32</code>: Month</li><li><code>year::Int32</code>: Day</li><li><code>hour::Int32</code>: Hour</li><li><code>minute::Int32</code>: Minute </li><li><code>second::Float64</code>: Seconds</li><li><code>microsecond::Float64</code>: Nanoseconds</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.load_eop" href="#SatelliteDynamics.Universe.load_eop"><code>SatelliteDynamics.Universe.load_eop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Load new Earth orientation data into the module global EarthOrientationData object. The product can be one of the symbols: <code>:C04_14</code>, <code>:C04_80</code>, or <code>:FINALS_2000</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>product::Symbol</code> Loads a different set of EarthOrientationData values into the module-wide global EarthOrientationData parameters.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.load_gravity_model" href="#SatelliteDynamics.Universe.load_gravity_model"><code>SatelliteDynamics.Universe.load_gravity_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Load new gravity model into module global EarthOrientationData object. The product can be one of the symbols: <code>:EGM2008_20</code>, <code>:EGM2008_90</code>, <code>:GGM01S</code>, <code>:GGM05S</code>, or the filepath to a text-encoded gravity model file.</p><p><strong>Arguments:</strong></p><ul><li><code>gfc_file::String</code> File path of gravity field model</li><li><code>product_name::Symbol</code> <em>OR</em> a symbol of a known gravity field product. Valid ones are: <code>:EGM2008_20</code>, <code>:EGM2008_90</code>, <code>:GGM01S</code>, <code>:GGM05S</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.mean_motion" href="#SatelliteDynamics.Astrodynamics.mean_motion"><code>SatelliteDynamics.Astrodynamics.mean_motion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the mean motion given a semi-major axis.</p><p>Arguments:</p><ul><li><code>a::Real</code>: Semi-major axis. [m]</li><li><code>use_degrees:Bool</code>: If <code>true</code> returns result in units of degrees</li><li><code>GM::Real</code>: Gravitational constant of central body. Defaults to <code>SatelliteDynamics.Constants.GM_EARTH</code> if none is provided.</li></ul><p>Returns:</p><ul><li><code>n::Real</code>: Orbital mean motion. [rad/s] or [deg/s]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.mjd" href="#SatelliteDynamics.Time.mjd"><code>SatelliteDynamics.Time.mjd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Modified Julian Date for a specific epoch</p><p>Arguments:</p><ul><li><code>epc::Epoch</code>: Epoch</li><li><code>tsys::Symbol</code>: Time system to return output in</li></ul><p>Returns:</p><ul><li><code>mjd::Real</code>: Julian date of the epoch in the requested time system</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.mjd_to_caldate" href="#SatelliteDynamics.Time.mjd_to_caldate"><code>SatelliteDynamics.Time.mjd_to_caldate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert a Modified Julian Date to the equivalent Gregorian calendar date representation of the same instant in time.</p><p><strong>Aguments:</strong></p><ul><li><code>mjd::Real</code>: Modified Julian Date of Epoch</li></ul><p><strong>Returns:</strong></p><ul><li><code>year::Int32</code>: Year</li><li><code>year::Int32</code>: Month</li><li><code>year::Int32</code>: Day</li><li><code>hour::Int32</code>: Hour</li><li><code>minute::Int32</code>: Minute </li><li><code>second::Float64</code>: Seconds</li><li><code>nanoseconds::Float64</code>: Nanoseconds</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.moon_position" href="#SatelliteDynamics.OrbitDynamics.moon_position"><code>SatelliteDynamics.OrbitDynamics.moon_position</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Moon&#39;s position in the EME2000 inertial frame through the use of low-precision analytical functions.</p><p>Argument:</p><ul><li><code>epc::Epoch</code>: Epoch</li></ul><p>Returns:</p><ul><li><code>r_moon::Array{&lt;:Real, 1}</code>: Position vector of the Moon in the Earth-centered inertial fame.</li></ul><p>Notes:</p><ol><li>The EME2000 inertial frame is for most purposes equivalent to the GCRF frame.</li></ol><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.70-73.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.orbit_period" href="#SatelliteDynamics.Astrodynamics.orbit_period"><code>SatelliteDynamics.Astrodynamics.orbit_period</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the satellite orbital period given the semi-major axis.</p><p>Arguments:</p><ul><li><code>a::Real</code>: Semi-major axis. [m]</li><li><code>GM::Real</code>: Gravitational constant of central body. Defaults to <code>SatelliteDynamics.Constants.GM_EARTH</code> if none is provided.</li></ul><p>Returns:</p><ul><li><code>T::Real</code>: Orbital period. [s]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.polar_motion" href="#SatelliteDynamics.ReferenceSystems.polar_motion"><code>SatelliteDynamics.ReferenceSystems.polar_motion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the Earth rotation matrix transforming the TIRS to the ITRF reference  frame.</p><p><strong>Arguments</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li></ul><p><strong>Returns</strong></p><ul><li><code>rpm::Array{&lt;:Real, 2}</code>: 3x3 Rotation matrix transforming TIRS -&gt; ITRF</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Simulation.propagate_orbit" href="#SatelliteDynamics.Simulation.propagate_orbit"><code>SatelliteDynamics.Simulation.propagate_orbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Simulate orbit dynamics</p><p>Arguments:</p><ul><li><code>epc0::Epoch</code>: Propagation start Epoch</li><li><code>eci0::Epoch</code>: Initial Cartesean inertial state [m; m/s]</li><li><code>epcf::Epoch</code>: Final to simulate to.</li><li><code>timestep::Real</code>: Timestep to use for simulation (Default: 5.0)</li><li><code>solver</code>: Solver to use to solve ODEProblem</li><li><code>atol::Real</code>: Absolute tolerate limit for differential equation solution (Default: 1.0e-9)</li><li><code>atol::Real</code>: Absolute tolerate limit for differential equation solution (Default: 1.0e-9)</li><li><code>mass::Real</code>: Satellite mass (Default: 100.0) [kg]</li><li><code>area_drag::Real</code>: Area of drag (cannon-ball model) (Default: 1.0) [m^2]</li><li><code>coef_drag::Real</code>: Coefficient of drag (Default: 2.3) [dimensionless]</li><li><code>area_srp::Real</code>: Area of solar radiation prerssure (Default: 1.0) [m^2]</li><li><code>coef_srp::Real</code>: Coefficient of reflectivity (Default: 1.8) [dimensionless]</li><li><code>n_grav::Integer</code>: Degree of gravity field (Default: 0.0) [dimensionless]</li><li><code>m_grav::Integer</code>: Order of gravity field (Default: 0.0) [dimensionless]</li><li><code>drag::Bool</code>: Apply drag perturbation (Default: false)</li><li><code>srp::Bool</code>: Apply solar radiation pressure perturbation (Default: false)</li><li><code>moon::Bool</code>: Apply third-body lunar gravity perturbation (Default: false)</li><li><code>sun::Bool</code>: Apply third-body solar gravity perturbation (Default: false)</li><li><code>relativity::Bool</code>: Apply relativistic perturbations (Default: false)</li></ul><p>Returns:</p><ul><li><code>t::Array{Float64, 1}</code>: Simulation output times at elapsed seconds from initial Epoch</li><li><code>epc::Array{Epoch, 1}</code>: Simulation output times as absolute Epochs</li><li><code>eci::Array{Float64, 2}</code>: Propgated inertial state. Time is aligned with column dimension.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.rECEFtoECI" href="#SatelliteDynamics.ReferenceSystems.rECEFtoECI"><code>SatelliteDynamics.ReferenceSystems.rECEFtoECI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p><p>The transformation is accomplished using the IAU 2006/2000A, CIO-based  theory using classical angles. The method as described in section 5.5 of  the SOFA C transformation cookbook.</p><p><strong>Arguments</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li></ul><p><strong>Returns</strong></p><ul><li><code>r::Array{&lt;:Real, 1}</code>: 3x3 Rotation matrix transforming ITRF -&gt; GCRF</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.rECEFtoENZ" href="#SatelliteDynamics.Coordinates.rECEFtoENZ"><code>SatelliteDynamics.Coordinates.rECEFtoENZ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the rotation matrix from the Earth-fixed to the East-North-Up coorindate basis.</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Real, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.rECEFtoSEZ" href="#SatelliteDynamics.Coordinates.rECEFtoSEZ"><code>SatelliteDynamics.Coordinates.rECEFtoSEZ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the rotation matrix from the Earth-fixed to the South-East-Zenith  coorindate basis.</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.rECItoECEF" href="#SatelliteDynamics.ReferenceSystems.rECItoECEF"><code>SatelliteDynamics.ReferenceSystems.rECItoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p><p>The transformation is accomplished using the IAU 2006/2000A, CIO-based  theory using classical angles. The method as described in section 5.5 of  the SOFA C transformation cookbook.</p><p><strong>Arguments</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li></ul><p><strong>Returns</strong></p><ul><li><code>r::Array{&lt;:Real, 2}</code>: 3x3 Rotation matrix transforming GCRF -&gt; ITRF</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.rECItoRTN" href="#SatelliteDynamics.ReferenceSystems.rECItoRTN"><code>SatelliteDynamics.ReferenceSystems.rECItoRTN</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Earth-centered inertial to radial, along-track, cross-track (RTN)  rotation matrix. Which, if applied to a position vector in the ECI frame, will  transform that vector into the equivalent position vector in the RTN frame.</p><p>The RTN frame is also commonly refered to as the local-vertical, local-horizontal (LVLH) frame.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of primary (observing) satellite</li><li><code>xt::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of the target satellite</li></ul><p>Returns:</p><ul><li><code>R_eci_to_rtn::Array{&lt;:Real, 1}</code>: Rotation matrix transforming <em>from</em> the ECI frame <em>to</em> the RTN frame.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.rENZtoECEF" href="#SatelliteDynamics.Coordinates.rENZtoECEF"><code>SatelliteDynamics.Coordinates.rENZtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the rotation matrix from the Earth-fixed to the South-East-Zenith  coorindate basis.</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.rRTNtoECI" href="#SatelliteDynamics.ReferenceSystems.rRTNtoECI"><code>SatelliteDynamics.ReferenceSystems.rRTNtoECI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the radial, along-track, cross-track (RTN) rotation matrix. Which, if applied to a position vector in the RTN frame, will transform that vector to beinto the equivalent relative position in the ECI frame.</p><p>The RTN frame is also commonly refered to as the local-vertical, local-horizontal (LVLH) frame.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of primary (observing) satellite</li><li><code>xt::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of the target satellite</li></ul><p>Returns:</p><ul><li><code>R_rtn_to_eci::Array{&lt;:Real, 1}</code>: Rotation matrix transforming <em>from</em> the RTN frame <em>to</em> the ECI frame.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.rSEZtoECEF" href="#SatelliteDynamics.Coordinates.rSEZtoECEF"><code>SatelliteDynamics.Coordinates.rSEZtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the rotation matrix from the Earth-fixed to the South-East-Zenith  coorindate basis.</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.sCARTtoOSC" href="#SatelliteDynamics.Astrodynamics.sCARTtoOSC"><code>SatelliteDynamics.Astrodynamics.sCARTtoOSC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a Cartesean position and velocity in the inertial frame, return the  state expressed in terms of  osculating orbital elements.</p><p>The osculating elements are assumed to be (in order):</p><ol><li><em>a</em>, Semi-major axis [m]</li><li><em>e</em>, Eccentricity [dimensionless]</li><li><em>i</em>, Inclination [rad]</li><li><em>Ω</em>, Right Ascension of the Ascending Node (RAAN) [rad]</li><li><em>ω</em>, Argument of Perigee [ramd]</li><li><em>M</em>, Mean anomaly [rad]</li></ol><p><strong>Arguments:</strong></p><ul><li>x <code>x::Array{&lt;:Real, 1}</code>: Cartesean inertial state. Returns position and velocity. [m; m/s]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input will be interpreted as being in degrees, and output will be returned in degrees.</li><li><code>GM::Real</code>: Gravitational constant of central body. Defaults to <code>SatelliteDynamics.Constants.GM_EARTH</code> if none is provided.</li></ul><p><strong>Returns</strong></p><ul><li>x_oe <code>x::Array{&lt;:Real, 1}</code>: Osculating orbital elements. See above for desription of the elements and their required order.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.sECEFtoECI" href="#SatelliteDynamics.ReferenceSystems.sECEFtoECI"><code>SatelliteDynamics.ReferenceSystems.sECEFtoECI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transforms an Earth fixed state into an Inertial state</p><p>The transformation is accomplished using the IAU 2006/2000A, CIO-based  theory using classical angles. The method as described in section 5.5 of  the SOFA C transformation cookbook.</p><p><strong>Arguments</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li><li><code>x::Array{&lt;:Real, 1}</code>: Earth-fixed state (position, velocity) [m; m/s]</li></ul><p><strong>Returns</strong></p><ul><li><code>x_ecef::Array{&lt;:Real, 1}</code>: Inertial state (position, velocity)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sECEFtoENZ" href="#SatelliteDynamics.Coordinates.sECEFtoENZ"><code>SatelliteDynamics.Coordinates.sECEFtoENZ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the coordinates of an object in the topocentric frame of an Earth-fixed frame</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>ecef::Array{&lt;:Real, 1}</code>: Coordinates of the object in Earth-fixed station</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sECEFtoGEOC" href="#SatelliteDynamics.Coordinates.sECEFtoGEOC"><code>SatelliteDynamics.Coordinates.sECEFtoGEOC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert Earth-fixed position to geocentric location.</p><p>Arguments:</p><ul><li><code>ecef::Array{&lt;:Real, 1}</code>: Earth-fixed coordinated [m]</li><li><code>use_degrees:Bool</code>: If <code>true</code> returns result in units of degrees</li></ul><p>Returns:</p><ul><li><code>geoc</code>: Geocentric coordinates (lon, lat, altitude) [rad] / [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sECEFtoGEOD" href="#SatelliteDynamics.Coordinates.sECEFtoGEOD"><code>SatelliteDynamics.Coordinates.sECEFtoGEOD</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert geodetic coordinaties to Earth-fixed position</p><p>Arguments:</p><ul><li><code>ecef::Array{&lt;:Real, 1}</code>: Earth-fixed position [m]</li><li><code>use_degrees:Bool</code>: If <code>true</code> returns result in units of degrees</li></ul><p>Returns:</p><ul><li><code>geod::Array{&lt;:Real, 1}</code>: Geocentric coordinates (lon, lat, altitude) [rad] / [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sECEFtoSEZ" href="#SatelliteDynamics.Coordinates.sECEFtoSEZ"><code>SatelliteDynamics.Coordinates.sECEFtoSEZ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the coordinates of an object in the topocentric frame of an Earth-fixed frame</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>ecef::Array{&lt;:Real, 1}</code>: Coordinates of the object in Earth-fixed station</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.sECItoECEF" href="#SatelliteDynamics.ReferenceSystems.sECItoECEF"><code>SatelliteDynamics.ReferenceSystems.sECItoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transforms an Earth inertial state into an Earth fixed state</p><p>The transformation is accomplished using the IAU 2006/2000A, CIO-based  theory using classical angles. The method as described in section 5.5 of  the SOFA C transformation cookbook.</p><p><strong>Arguments</strong></p><ul><li><code>epc::Epoch</code>: Epoch of transformation</li><li><code>x::Array{&lt;:Real, 1}</code>: Inertial state (position, velocity) [m; m/s]</li></ul><p><strong>Returns</strong></p><ul><li><code>x_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed state (position, velocity)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.sECItoRTN" href="#SatelliteDynamics.ReferenceSystems.sECItoRTN"><code>SatelliteDynamics.ReferenceSystems.sECItoRTN</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the radial, along-track, cross-track (RTN) coordinates of a target satellite in the primary satellites RTN frame.</p><p>The RTN frame is also commonly refered to as the local-vertical, local-horizontal (LVLH) frame.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of primary (observing) satellite</li><li><code>xt::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of the target satellite</li></ul><p>Returns:</p><ul><li><code>rtn::Array{&lt;:Real, 1}</code>: Position and velocity of the target relative of the observing satellite in the RTN.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sENZtoAZEL" href="#SatelliteDynamics.Coordinates.sENZtoAZEL"><code>SatelliteDynamics.Coordinates.sENZtoAZEL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert East-North-Zenith topocentric state to azimuth, elevation, and range.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: East-North-Up state</li><li><code>use_degrees:Bool</code>: If <code>true</code> returns result in units of degrees</li></ul><p>Returns:</p><ul><li><code>azel::Array{&lt;:Real, 1}</code>: Azimuth, elevation and range [rad; rad; m]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sENZtoECEF" href="#SatelliteDynamics.Coordinates.sENZtoECEF"><code>SatelliteDynamics.Coordinates.sENZtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the coordinates of an object in the topocentric frame of an Earth-fixed frame</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>sez::Array{&lt;:Real, 1}</code>: SEZ coordinates of the object</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sGEOCtoECEF" href="#SatelliteDynamics.Coordinates.sGEOCtoECEF"><code>SatelliteDynamics.Coordinates.sGEOCtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert geocentric position to equivalent Earth-fixed position.</p><p>Arguments:</p><ul><li><code>geoc::Array{&lt;:Real, 1}</code>: Geocentric coordinates (lon, lat, altitude) [rad] / [deg]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li></ul><p>Returns:</p><ul><li><code>ecef::Array{&lt;:Real, 1}</code>: Earth-fixed coordinates [m]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sGEODtoECEF" href="#SatelliteDynamics.Coordinates.sGEODtoECEF"><code>SatelliteDynamics.Coordinates.sGEODtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert geodetic position to equivalent Earth-fixed position.</p><p>Arguments:</p><ul><li><code>geod::Array{&lt;:Real, 1}</code>: Geodetic coordinates (lon, lat, altitude) [rad] / [deg]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li></ul><p>Returns:</p><ul><li><code>ecef::Array{&lt;:Real, 1}</code>: Earth-fixed coordinates [m]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.sOSCtoCART" href="#SatelliteDynamics.Astrodynamics.sOSCtoCART"><code>SatelliteDynamics.Astrodynamics.sOSCtoCART</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given an orbital state expressed in osculating orbital elements compute the equivalent Cartesean position and velocity of the inertial state.</p><p>The osculating elements are assumed to be (in order):</p><ol><li><em>a</em>, Semi-major axis [m]</li><li><em>e</em>, Eccentricity [dimensionless]</li><li><em>i</em>, Inclination [rad]</li><li><em>Ω</em>, Right Ascension of the Ascending Node (RAAN) [rad]</li><li><em>ω</em>, Argument of Perigee [ramd]</li><li><em>M</em>, Mean anomaly [rad]</li></ol><p><strong>Arguments:</strong></p><ul><li>x_oe <code>x::Array{&lt;:Real, 1}</code>: Osculating orbital elements. See above for desription of the elements and their required order.</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input will be interpreted as being in degrees, and output will be returned in degrees.</li><li><code>GM::Real</code>: Gravitational constant of central body. Defaults to <code>SatelliteDynamics.Constants.GM_EARTH</code> if none is provided.</li></ul><p><strong>Returns</strong></p><ul><li>x <code>x::Array{&lt;:Real, 1}</code>: Cartesean inertial state. Returns position and velocity. [m; m/s]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.ReferenceSystems.sRTNtoECI" href="#SatelliteDynamics.ReferenceSystems.sRTNtoECI"><code>SatelliteDynamics.ReferenceSystems.sRTNtoECI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Earth-center</p><p>The RTN frame is also commonly refered to as the local-vertical, local-horizontal (LVLH) frame.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of primary (observing) satellite</li><li><code>xt::Array{&lt;:Real, 1}</code>: Inertial state (position and velocity) of the target satellite</li></ul><p>Returns:</p><ul><li><code>rtn::Array{&lt;:Real, 1}</code>: Position and velocity of the target relative of the observing satellite in the RTN.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sSEZtoAZEL" href="#SatelliteDynamics.Coordinates.sSEZtoAZEL"><code>SatelliteDynamics.Coordinates.sSEZtoAZEL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert South-East-Zenith topocentric state to azimuth, elevation, and range.</p><p>Arguments:</p><ul><li><code>x::Array{&lt;:Real, 1}</code>: South-East-Zenith state</li><li><code>use_degrees:Bool</code>: If <code>true</code> returns result in units of degrees</li></ul><p>Returns:</p><ul><li><code>azel::Array{&lt;:Real, 1}</code>: Azimuth, elevation and range [rad; rad; m]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Coordinates.sSEZtoECEF" href="#SatelliteDynamics.Coordinates.sSEZtoECEF"><code>SatelliteDynamics.Coordinates.sSEZtoECEF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the coordinates of an object in the topocentric frame of an Earth-fixed frame</p><p>Arguments:</p><ul><li><code>station_ecef::Array{&lt;:Real, 1}</code>: Earth-fixed cartesian station coordinates</li><li><code>sez::Array{&lt;:Real, 1}</code>: SEZ coordinates of the object</li><li><code>conversion::Bool</code>: Conversion type to use. Can be &quot;geocentric&quot; or &quot;geodetic&quot;</li></ul><p>Returns:</p><ul><li><code>E::Array{Float64, 2}</code>: Topocentric rotation matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.semimajor_axis" href="#SatelliteDynamics.Astrodynamics.semimajor_axis"><code>SatelliteDynamics.Astrodynamics.semimajor_axis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate semi-major axis given mean-motion.</p><p>Arguments:</p><ul><li><code>n::Real</code>: Orbital mean motion. [rad/s] or [deg/s]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret input as being in degrees.</li><li><code>GM::Real</code>: Gravitational constant of central body. Defaults to <code>SatelliteDynamics.Constants.GM_EARTH</code> if none is provided.</li></ul><p>Returns:</p><ul><li><code>a::Real</code>: Semi-major axis. [m]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.set_eop" href="#SatelliteDynamics.Universe.set_eop"><code>SatelliteDynamics.Universe.set_eop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set Earth orientation data values for a specific date in the module global EarthOrientationData object.</p><p><strong>Arguments:</strong></p><ul><li><code>mjd::Real</code> Modified Julian Date in UTC of the Epoch for which the Earth orientation data is aligned to.</li><li><code>ut1_utc::Real</code> Offset between UT1 and UTC in seconds.</li><li><code>xp::Real</code> x-component of the pole locator in radians.</li><li><code>yp::Real</code> y-component of the pole locator in radians.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Attitude.slerp" href="#SatelliteDynamics.Attitude.slerp"><code>SatelliteDynamics.Attitude.slerp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Perform spherical linear interpolation (SLERP) on two quaternions. Interpolatles  from quaternion, <code>q1</code>, to quaternion, <code>q2</code>, at normalized interpolation time, <code>t</code>.</p><p>Interpolation time must be in the range <code>[0, 1]</code> a value of <code>0</code> will return <code>q1</code>, while a value of <code>1</code> will return <code>q2</code>.</p><p>Arguments:</p><ul><li><code>q1::Quaternion</code>: Starting Quaternion</li><li><code>q2::Quaternion</code>: Ending Quaternion</li><li><code>t::Real</code>: Normalized interpolation time. [0, 1]</li></ul><p>Returns:</p><ul><li><code>q:Quaternion</code>: Quaternion attitude interpolation from q1 toward q2 at time t.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.OrbitDynamics.sun_position" href="#SatelliteDynamics.OrbitDynamics.sun_position"><code>SatelliteDynamics.OrbitDynamics.sun_position</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the Sun&#39;s position in the EME2000 inertial frame through the use of low-precision analytical functions.</p><p>Argument:</p><ul><li><code>epc::Epoch</code>: Epoch</li></ul><p>Returns:</p><ul><li><code>r_sun::Array{&lt;:Real, 1}</code>: Position vector of the Sun in the Earth-centered inertial fame.</li></ul><p>Notes:</p><ol><li>The EME2000 inertial frame is for most purposes equivalent to the GCRF frame.</li></ol><p>References:</p><ol><li>O. Montenbruck, and E. Gill, <em>Satellite Orbits: Models, Methods and Applications</em>, 2012, p.70-73.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Astrodynamics.sun_sync_inclination" href="#SatelliteDynamics.Astrodynamics.sun_sync_inclination"><code>SatelliteDynamics.Astrodynamics.sun_sync_inclination</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the required inclination for a Sun-synchronous Earth orbit.</p><p>Algorithm assumes the nodal precession is entirely due to the J2 perturbation, and no other perturbations are considered.</p><p>The inclination is computed using a first-order, non-iterative approximation.</p><p>Arguments:</p><ul><li><code>a::Real</code>: Semi-major axis. [m]</li><li><code>e::Real</code>: Eccentricity. [dimensionless]</li><li><code>use_degrees:Bool</code>: If <code>true</code> interpret output will be returned in degrees.</li></ul><p>Returns:</p><ul><li><code>iss::Real</code>: Requierd inclination for a sun-synchronous orbit. [rad] or [deg]</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Time.time_system_offset" href="#SatelliteDynamics.Time.time_system_offset"><code>SatelliteDynamics.Time.time_system_offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the offset between two time systems at a given Epoch.</p><p>The offset (in seconds) is computed as:</p><pre><code class="language-none">time_system_offset = tsys_dest - tsys_src</code></pre><p>The value returned is the number of seconds that musted be added to the source time system given the input epoch, to get the equivalent epoch.</p><p>Conversions are accomplished using SOFA C library calls. Epoch.</p><p>Arguments:</p><ul><li><code>jd::Real</code>: Part 1 of two-part date (Julian days)</li><li><code>fd::Real</code>: Part 2 of two-part date (Fractional days)</li><li><code>tsys_src::Symbol</code>: Base time system</li><li><code>tsys_dest::Symbol</code>: Destination time system</li></ul><p>Returns:</p><ul><li><code>offset::Float</code>: Offset between soruce and destination time systems in seconds.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SatelliteDynamics.Universe.update_eop" href="#SatelliteDynamics.Universe.update_eop"><code>SatelliteDynamics.Universe.update_eop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Download updated Earth orientation datafiles for included products IERS products.</p><p><strong>Arguments:</strong></p><ul><li><code>product::Symbol</code> The IERS product type can be <code>:C04_14</code>, <code>:C04_80</code>, or <code>:FINALS_2000</code></li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
