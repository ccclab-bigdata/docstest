<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · StructIO.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StructIO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.@io" href="#StructIO.@io"><code>StructIO.@io</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@io &lt;type definition&gt;
    ...
end</code></pre><p>Generates <code>packing_strategy()</code> and <code>packed_sizeof()</code> methods for the type being defined within the given type definition.  This enables usage of the <code>unpack</code> method.</p></div></div></section><pre><code class="language-none">StructIO.Default</code></pre><pre><code class="language-none">StructIO.Packed</code></pre><pre><code class="language-none">StructIO.PackingStrategy</code></pre><pre><code class="language-none">StructIO.StructIO</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.bswap!" href="#StructIO.bswap!"><code>StructIO.bswap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bswap!(ptr::Ptr{UInt8}, sz)</code></pre><p>Byte-swap a chunk of data in-place</p></div></div></section><pre><code class="language-none">StructIO.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.fieldsize" href="#StructIO.fieldsize"><code>StructIO.fieldsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fieldsize(T::DataType, field_idx)</code></pre><p>Return the size (in bytes) of a field within <code>T</code> in memory</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.fix_endian" href="#StructIO.fix_endian"><code>StructIO.fix_endian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fix_endian(x, endianness::Symbol)</code></pre><p>Returns a byte-swapped version of <code>x</code> if the given endianness must be swapped for the current host system.</p></div></div></section><pre><code class="language-none">StructIO.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.needs_bswap" href="#StructIO.needs_bswap"><code>StructIO.needs_bswap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">needs_bswap(endianness::Symbol)</code></pre><p>Returns <code>true</code> if the given endianness does not match the current host system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.pack" href="#StructIO.pack"><code>StructIO.pack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pack(io::IO, source, endianness::Symbol = :NativeEndian)</code></pre><p>Given an input <code>source</code>, pack it into <code>io</code>, byte-swapping according to the given <code>endianness</code> of <code>io</code>. If <code>endianness</code> is <code>:NativeEndian</code> (the default), no byteswapping will occur.  If <code>endianness</code> is <code>:LittleEndian</code> or <code>:BigEndian</code>, byteswapping will occur if the endianness of the host system does not match the endianness of <code>io</code>.</p></div></div></section><pre><code class="language-none">StructIO.packed_sizeof</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.packing_strategy" href="#StructIO.packing_strategy"><code>StructIO.packing_strategy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">packing_strategy(x)</code></pre><p>Return the packing strategy for the given type, defaults to <code>Default</code>, is overridden by auto-generated methods for specific types from <code>@io</code> invocations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.unpack" href="#StructIO.unpack"><code>StructIO.unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unpack(io::IO, T::Type, endianness::Symbol = :NativeEndian)</code></pre><p>Given an input <code>io</code>, unpack type <code>T</code>, byte-swapping according to the given <code>endianness</code> of <code>io</code>. If <code>endianness</code> is <code>:NativeEndian</code> (the default), no byteswapping will occur.  If <code>endianness</code> is <code>:LittleEndian</code> or <code>:BigEndian</code>, byteswapping will occur of the endianness if the host system does not match the endianness of <code>io</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.unsafe_pack" href="#StructIO.unsafe_pack"><code>StructIO.unsafe_pack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_pack(io, source, endianness, ::Type{Packed/Default})</code></pre><p>Pack <code>source</code> into <code>io</code>, byte-swapping if <code>endianness</code> dictates we should.  The last argument is a packing strategy, used to determine the layout of the data in memory.  All <code>Packed</code> objects recurse until bitstypes objects are eventually reached, at which point <code>Default</code> packing is identical to <code>Packed</code> behavior.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructIO.unsafe_unpack" href="#StructIO.unsafe_unpack"><code>StructIO.unsafe_unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_unpack(io, T, target, endianness, ::Type{Default})</code></pre><p>Unpack an object of type <code>T</code> from <code>io</code> into <code>target</code>, byte-swapping if <code>endianness</code> dictates we should, assuming a <code>Default</code> packing strategy.  All packed structs recurse until bitstypes objects are eventually reached, at which point <code>Default</code> packing is the only behavior.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
