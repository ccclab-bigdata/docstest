<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · OIFITS.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OIFITS.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#OI-FITS-Summary-1">OI-FITS Summary</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Typical-usage-1">Typical usage</a></li><li><a class="toctext" href="#Accessor-functions-1">Accessor functions</a></li><li><a class="toctext" href="#Reading-data-1">Reading data</a></li><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Miscellaneous-functions-1">Miscellaneous functions</a></li><li><a class="toctext" href="#Credits-1">Credits</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="OIFITS.jl-1" href="#OIFITS.jl-1">OIFITS.jl</a></h1><p><a href="LICENSE.md"><img src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" alt="License"/></a> <a href="https://travis-ci.org/emmt/OIFITS.jl"><img src="https://travis-ci.org/emmt/OIFITS.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/emmt/OIFITS-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/emmt/OIFITS.jl?branch=master" alt="Build Status"/></a></p><p>The <code>OIFITS.jl</code> package provides support for OI-FITS data in Julia language.</p><h2><a class="nav-anchor" id="OI-FITS-Summary-1" href="#OI-FITS-Summary-1">OI-FITS Summary</a></h2><p>OI-FITS is a standard to store optical interferometry data as a collection of data-blocks.  In the first version of the standard (see <a href="#references">Ref. 1</a>), the available data-blocks are:</p><ul><li><code>OI_TARGET</code> provides a list of observed targets;</li><li><code>OI_ARRAY</code> describes a given array of stations;</li><li><code>OI_WAVELENGTH</code> describes a given instrument (notably the effective wavelengths and bandwidths of its spectral channels);</li><li><code>OI_VIS</code> contains complex visibility data;</li><li><code>OI_VIS2</code> contains squared visibility (powerspectrum) data;</li><li><code>OI_T3</code> contains triple product (bispectrum) data.</li></ul><p>These data-blocks, are stored as binary tables in a FITS data file.  The support for the actual FITS files is provided by the <a href="https://github.com/JuliaAstro/FITSIO.jl"><code>FITSIO.jl</code></a> package.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>OIFITS is a <a href="http://pkg.julialang.org/">registered Julia package</a>, the installation is as simple as:</p><pre><code class="language-julia">Pkg.add(&quot;OIFITS&quot;)
Pkg.update()</code></pre><p>The last command <code>Pkg.update()</code> may be unnecessary.</p><h2><a class="nav-anchor" id="Typical-usage-1" href="#Typical-usage-1">Typical usage</a></h2><p>Loading an OI-FITS data file:</p><pre><code class="language-julia">using OIFITS
master = OIFITS.load(&quot;testdata.oifits&quot;)</code></pre><p>To iterate through all data-blocks:</p><pre><code class="language-julia">for db in master
    dbname = OIFITS.get_dbname(db)
    revn = OIFITS.get_revn(db)
    println(&quot;Data block is $dbname, revision $revn&quot;)
end</code></pre><p>To iterate through a sub-set of the data-blocks (here the complex visibility data, the powerspectrum data and the bispectrum data):</p><pre><code class="language-julia">for db in OIFITS.select(master, &quot;OI_VIS&quot;, &quot;OI_VIS2&quot;, &quot;OI_T3&quot;)
    dbname = OIFITS.get_dbname(db)
    n = length(OIFITS.get_time(db))
    println(&quot;Data block is $dbname, number of exposures is $n&quot;)
end</code></pre><h2><a class="nav-anchor" id="Accessor-functions-1" href="#Accessor-functions-1">Accessor functions</a></h2><p>Any OI-FITS field (keyword/column) of a given data-block can be retrieved via an accessor whose name has suffix <code>OIFITS.get_</code> followed by the name of the field (in lower case letters and with all non-letter and all non-digit letters replaced by the underscore character <code>&#39;_&#39;</code>).  A notable exception is the revision number corresponding to the keyword &quot;OI<em>REVN&quot; which is retrieved with the method `OIFITS.get</em>revn()`.  For instance:</p><pre><code class="language-julia">OIFITS.get_revn(db)      # get the revison number of the format (OI_REVN)
OIFITS.get_eff_wave(db)  # get effective wavelengths (EFF_WAVE)
OIFITS.get_eff_band(db)  # get effective bandwidths (EFF_BAND)
OIFITS.get_ucoord(db)    # get the U coordinates of the data (UCOORD)</code></pre><p>Of course, getting a given field must make sense.  For instance, <code>OIFITS.get_eff_wave()</code> can be applied on any <code>OI_WAVELENGTH</code> data-blocks but also on data-blocks which contains interferometric data such as <code>OI_VIS</code>, <code>OI_VIS2</code>, <code>OI_T3</code>, <em>etc.</em> but not on other data-blocks like <code>OI_TARGET</code>.</p><h2><a class="nav-anchor" id="Reading-data-1" href="#Reading-data-1">Reading data</a></h2><p>To load the contents of an OI-FITS file in memory, use:</p><pre><code class="language-julia">master = OIFITS.load(filename)</code></pre><p>where <code>filename</code> is the name of the file and the returned value, <code>master</code>, contains all the OI-FITS data-blocks of the file.  You may have the names of the data blocks printed as they get read with keyword <code>quiet=false</code>:</p><pre><code class="language-julia">master = OIFITS.load(filename, quiet=false)</code></pre><p>If you already have a <code>FITS</code> handle to the data, you can use it as the argument to <code>OIFITS.load</code> in place of the file name.</p><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><p>It is possible to build OI-FITS data-blocks individually.  The general syntax is:</p><pre><code class="language-julia">OIFITS.new_XXX(KEY1=VAL1, KEY2=VAL2, ...)</code></pre><p>where <code>XXX</code> is the type of the data-block and <code>KEYn=VALn</code> constructions give the fields of the data-block and their values.  The names of the fields follow the same convention as for the field accessors.</p><p>Available data-block constructors are:</p><ul><li><code>OIFITS.new_target</code> =&gt; <code>OI_TARGET</code></li><li><code>OIFITS.new_array</code> =&gt; <code>OI_ARRAY</code></li><li><code>OIFITS.new_wavelength</code> =&gt; <code>OI_WAVELENGTH</code></li><li><code>OIFITS.new_vis</code>  =&gt; <code>OI_VIS</code></li><li><code>OIFITS.new_vis2</code> =&gt; <code>OI_VIS2</code></li><li><code>OIFITS.new_t3</code>   =&gt; <code>OI_T3</code></li></ul><p>When defining a new data-block, all mandatory fields must be provided. For instance, to create an <code>OI_WAVELENGTH</code> data-block:</p><pre><code class="language-julia">µm = 1e-6  # all values are in SI units in OI-FITS
db = OIFITS.new_wavelength(insname=&quot;Amber&quot;,
                           eff_wave=[1.4µm,1.6µm,1.8µm],
                           eff_band=[0.2µm,0.2µm,0.2µm])</code></pre><p>Note that the revision number (<code>revn=...</code>) can be omitted; by default, the highest defined revision will be used.</p><p>A consistent set of OI-FITS data-blocks is made of: exactly one <code>OI_TARGET</code> data-block, one or more <code>OI_WAVELENGTH</code> data-blocks, one or more <code>OI_ARRAY</code> data-blocks and any number of data-blocks with interferometric data (<code>OI_VIS</code>, <code>OI_VIS2</code> or <code>OI_T3</code>).  These data-blocks must be stored in a container created by:</p><pre><code class="language-julia">master = OIFITS.new_master()</code></pre><p>Then, call:</p><pre><code class="language-julia">OIFITS.attach(master, db)</code></pre><p>to attach all data-block <code>db</code> to the OI-FITS container (in any order). Finally, you must call:</p><pre><code class="language-julia">OIFITS.update(master)</code></pre><p>to update internal information such as links between data-blocks with interferometric data and the related instrument (<code>OI_WAVELENGTH</code> data-block) and array of stations (<code>OI_ARRAY</code> data-block).  If you do not do that, then applying some accessors may not work, <em>e.g.</em> <code>OIFITS.get_eff_wave()</code> on a data-blocks with interferometric data.</p><p>To read an OI-FITS data-block from the HDU of a FITS file:</p><pre><code class="language-julia">db = OIFITS.read_datablock(hdu)</code></pre><p>where <code>hdu</code> is a FITS <code>HDU</code> handle.  The result may be <code>nothing</code> if the current HDU does not contain an OI-FITS data-block.</p><h2><a class="nav-anchor" id="Miscellaneous-functions-1" href="#Miscellaneous-functions-1">Miscellaneous functions</a></h2><p>OI-FITS implements some useful functions which can be used to deal with FITS file (not just OI-FITS ones).  These functions could be part of <code>FITSIO</code> package.</p><h3><a class="nav-anchor" id="Retrieving-information-from-the-header-of-a-FITS-HDU-1" href="#Retrieving-information-from-the-header-of-a-FITS-HDU-1">Retrieving information from the header of a FITS HDU</a></h3><p>The header of a FITS HDU can be read with the function:</p><pre><code class="language-julia">fts = FITS(filename)
hdr = FITSIO.read_header(fts[1])</code></pre><p>which returns an indexable and iterable object, here <code>hdr</code>.  The keys of <code>hdr</code> are the FITS keywords of the header.  For instance:</p><pre><code class="language-julia">keys(hdr)          # yield an iterator on the keys of hdr
collect(keys(hdr)) # yield all the keys of hdr
haskey(hdr, key)   # check whether key is present
hdr[key]           # retrieve the contents associated with the key</code></pre><p>For commentary FITS keywords (<code>&quot;HISTORY&quot;</code> or <code>&quot;COMMENT&quot;</code>), there is no value, just a comment but there may be any number of these <em>commentary</em> keywords.  Other keywords must be unique and thus have a scalar value.  Use <code>get_comment</code> to retrieve the comment of a FITS keyword:</p><pre><code class="language-julia">get_comment(hdr, key)keys(hdr)          # yield an iterator on the keys of hdr
collect(keys(hdr)) # yield all the keys of hdr
haskey(hdr, key)   # check whether key is present
hdr[key]           # retrieve the contents associated with the key</code></pre><p><em>OIFITS</em> provides method <code>OIFITS.get_value()</code> and <code>OIFITS.get_comment()</code> method to retrieve the value and comment (respectively) of a FITS keyword with type checking and, optionaly, let you provide a default value if the keyword is absent:</p><pre><code class="language-julia">val = OIFITS.get_value(hdr, key)
val = OIFITS.get_value(hdr, key, def)
com = OIFITS.get_comment(hdr, key)
com = OIFITS.get_comment(hdr, key, def)</code></pre><p>To retrieve a value and make sure it has a specific type, the following methods are available:</p><pre><code class="language-julia">OIFITS.get_logical(hdr, &quot;SIMPLE&quot;)
OIFITS.get_integer(hdr, &quot;BITPIX&quot;)
OIFITS.get_real(hdr, &quot;BSCALE&quot;)
OIFITS.get_string(hdr, &quot;XTENSION&quot;)</code></pre><p>which throw an error if the keyword is not present and perform type checking and conversion if allowed.  It is also possible to supply a default value to return if the keyword is not present:</p><pre><code class="language-julia">bscale = OIFITS.get_real(hdr, &quot;BSCALE&quot;, 1.0)
bzero = OIFITS.get_real(hdr, &quot;BZERO&quot;, 0.0)
xtension = OIFITS.get_string(hdr, &quot;XTENSION&quot;, &quot;IMAGE&quot;)</code></pre><p>The function:</p><pre><code class="language-julia">OIFITS.get_hdutype(hdr)</code></pre><p>returns the HDU type as a Symbol, <code>:image_hdu</code> for an image, <code>:ascii_table</code> for an ASCII table, <code>:binary_table</code> for a binary table, and <code>:unknown</code> otherwise.</p><p>For a FITS table, the function:</p><pre><code class="language-julia">OIFITS.get_dbtype(hdr)</code></pre><p>returns the OI-FITS data-block type as a Symbol like <code>:OI_TARGET</code>, <code>:OI_WAVELENGTH</code>, <em>etc.</em></p><h3><a class="nav-anchor" id="Reading-FITS-tables-1" href="#Reading-FITS-tables-1">Reading FITS tables</a></h3><p>In addition to the method <code>read(tbl::TableHDU, colname::String)</code> provided by FITSIO for reading a specific column of a FITS table, the low-level function:</p><pre><code class="language-julia">OIFITS.read_column(ff::FITSFile, colnum::Integer)</code></pre><p>returns a Julia array with the contents of the <code>colnum</code>-th column of the current HDU in FITS file handle <code>ff</code>.  The current HDU must be a FITS table (an ASCII or a binary one).  The last dimension of the result corresponds to the rows of the table.  It is also possible to read all the table:</p><pre><code class="language-julia">OIFITS.read_table(ff::FITSFile)
OIFITS.read_table(hdu::Union(TableHDU,ASCIITableHDU))</code></pre><p>or at high-level:</p><pre><code class="language-julia">read(hdu::Union(TableHDU,ASCIITableHDU))</code></pre><p>The result is a dictionary whose keys are the names of the columns (in uppercase letters and with trailing spaces removed).  If a column has given units, the units are stored in the dictionary with suffix <code>&quot;.units&quot;</code> appended to the column name.  For instance, the units for column <code>&quot;TIME&quot;</code> are accessible with key <code>&quot;TIME.units&quot;</code>.</p><h3><a class="nav-anchor" id="FITS-and-Julia-types-conversion-1" href="#FITS-and-Julia-types-conversion-1">FITS and Julia types conversion</a></h3><p>The functions <code>cfitsio_datatype()</code> and <code>fits_bitpix()</code> deal with conversion between CFITSIO type code or BITPIX value and actual Julia data types. They can be used as follows (assuming <code>T</code> is a Julia data type, while <code>code</code> and <code>bitpix</code> are integers):</p><pre><code class="language-julia">cfitsio_datatype(T) --------&gt; code (e.g., TBYTE, TFLOAT, etc.)
cfitsio_datatype(code) -----&gt; T

fits_bitpix(T) -------------&gt; bitpix (e.g., BYTE_IMG, FLOAT_IMG, etc.)
fits_bitpix(bitpix) --------&gt; T</code></pre><p>The functions <code>fits_get_coltype()</code> and <code>fits_get_eqcoltype()</code> yield the data type, repeat count and width in bytes of a given column, their prototypes are:</p><pre><code class="language-julia">(code, repcnt, width) = fits_get_coltype(ff::FITSFile, colnum::Integer)
(code, repcnt, width) = fits_get_eqcoltype(ff::FITSFile, colnum::Integer)</code></pre><p>with <code>colnum</code> the column number, <code>code</code> the CFITSIO column type (call <code>cfitsio_datatype(code)</code> to convert it to a Julia type) of the elements in this column, <code>repcnt</code> and <code>width</code> the repeat count and width of a cell in this column.  The difference between <code>fits_get_coltype()</code> and <code>fits_get_eqcoltype()</code> is that the former yields the column type as it is stored in the file, while the latter yields the column type after automatic scaling by the values <code>&quot;TSCALn&quot;</code> and <code>&quot;TZEROn&quot;</code> keywods if present (with <code>n</code> the column number).  Note that reading the column data with <code>fits_read_col()</code> or <code>fitsio_read_column()</code> automatically apply this kind of scaling.</p><p>To retrieve the dimensions of the cells in a given column, call the function <code>fits_read_tdim()</code>, its prototype is:</p><pre><code class="language-julia">dims = fits_read_tdim(ff::FITSFile, colnum::Integer)</code></pre><p>where <code>dims</code> is a vector of integer dimensions.</p><h2><a class="nav-anchor" id="Credits-1" href="#Credits-1">Credits</a></h2><p>The developments of this package has received funding from the European Community&#39;s Seventh Framework Programme (FP7/2013-2016) under Grant Agreement 312430 (OPTICON).</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><ol><li><p>Pauls, T. A., Young, J. S., Cotton, W. D., &amp; Monnier, J. D. &quot;A data exchange standard for optical (visible/IR) interferometry.&quot; Publications of the Astronomical Society of the Pacific, vol. 117, no 837, p. 1255 (2005). <a href="http://arxiv.org/pdf/astro-ph/0508185">[pdf]</a></p></li><li><p>Duvert, G., Young, J., &amp; Hummel, C. &quot;OIFITS 2: the 2nd version of the Data Exchange Standard for Optical (Visible/IR) Interferometry.&quot; arXiv preprint <a href="http://arxiv.org/abs/1510.04556v2">[arXiv:1510.04556v2.04556]</a>.</p></li></ol><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
