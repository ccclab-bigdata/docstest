<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CutPruners.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CutPruners.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.AbstractCutPruner" href="#CutPruners.AbstractCutPruner"><code>CutPruners.AbstractCutPruner</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A cut pruner maintains a matrix <code>A</code> and a vector <code>b</code> such that represents <code>size(A, 1)</code> (<code>== length(b)</code>) cuts. Let <code>a_i</code> be <code>-A[i,:]</code> if <code>lazy_minus</code> and <code>A[i,:]</code> otherwise and <code>β_i</code> be <code>b[i]</code>, the meaning of the cut depends on the sense. If <code>sense</code> is</p><ul><li><code>:Min</code>, then the cut pruner represents the concave polyhedral function <code>min ⟨a_i, x⟩ + β_i</code>;</li><li><code>:Max</code>, then the cut pruner represents the convex polyhedral function <code>max ⟨a_i, x⟩ + β_i</code>;</li><li><code>:≤</code>, then the cut pruner represents the polyhedra defined by the intersection of the half-space <code>⟨a_i, x⟩ ≤ β_i</code>;</li><li><code>:≥</code>, then the cut pruner represents the polyhedra defined by the intersection of the half-space <code>⟨a_i, x⟩ ≥ β_i</code>.</li></ul><p>Internally, instead of <code>sense</code>, the booleans <code>isfun</code> and <code>islb</code> are stored. The mapping between <code>sense</code> and these two booleans is given by the following table</p><table><tr><th><code>sense</code></th><th><code>isfun</code></th><th><code>islb</code></th></tr><tr><td>Min</td><td>true</td><td>false</td></tr><tr><td>Max</td><td>true</td><td>true</td></tr><tr><td>≤</td><td>false</td><td>false</td></tr><tr><td>≥</td><td>false</td><td>true</td></tr></table></div></div></section><pre><code class="language-none">CutPruners.AbstractCutPruningAlgo</code></pre><pre><code class="language-none">CutPruners.AvgCutPruner</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.AvgCutPruningAlgo" href="#CutPruners.AvgCutPruningAlgo"><code>CutPruners.AvgCutPruningAlgo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgCutPruningAlgo &lt;: AbstractCutPruningAlgo</code></pre><p>Removes the cuts with lower trust where the trust is: nused / nwith + bonus where the cut has been used <code>nused</code> times amoung <code>nwith</code> optimization done with it. We say that the cut was used if its dual value is nonzero. It has a bonus equal to <code>mycutbonus</code> if the cut was generated using a trial given by the problem using this cut. If <code>nwidth</code> is zero, <code>nused/nwith</code> is replaced by <code>newcuttrust</code>.</p></div></div></section><pre><code class="language-none">CutPruners.CutPruner</code></pre><pre><code class="language-none">CutPruners.CutPruners</code></pre><pre><code class="language-none">CutPruners.DeMatosCutPruner</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.DeMatosPruningAlgo" href="#CutPruners.DeMatosPruningAlgo"><code>CutPruners.DeMatosPruningAlgo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DeMatosPruningAlgo &lt;: AbstractCutPruningAlgo</code></pre><p>Removes the cuts with lower trust where the trust is the number of points <code>x</code> associated to the cuts. The more points are associated, the higher is the trust.</p><p>We refer to [1] for further details.</p><p>[1] De Matos, Vitor L., Andy B. Philpott, and Erlon C. Finardi. &quot;Improving the performance of stochastic dual dynamic programming.&quot; Journal of Computational and Applied Mathematics 290 (2015): 196-208.</p></div></div></section><pre><code class="language-none">CutPruners.DecayCutPruner</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.DecayCutPruningAlgo" href="#CutPruners.DecayCutPruningAlgo"><code>CutPruners.DecayCutPruningAlgo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DecayCutPruningAlgo &lt;: AbstractCutPruningAlgo</code></pre><p>Removes the cuts with lower trust where the trust is initially <code>newcuttrust + bonus</code> and is updated using <code>trust -&gt; λ * trust + used</code> after each optimization done with it. The value <code>used</code> is 1 if the cut was used and 0 otherwise. It has a bonus equal to <code>mycutbonus</code> if the cut was generated using a trial given by the problem using this cut. We say that the cut was used if its dual value is nonzero.</p></div></div></section><pre><code class="language-none">CutPruners._appendcuts!</code></pre><pre><code class="language-none">CutPruners._indmin</code></pre><pre><code class="language-none">CutPruners._keeponlycuts!</code></pre><pre><code class="language-none">CutPruners._replacecuts!</code></pre><pre><code class="language-none">CutPruners.addcuts!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.addposition!" href="#CutPruners.addposition!"><code>CutPruners.addposition!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addposition!(man::DeMatosCutPruner, position::Matrix)</code></pre><p>Update territories with cuts previously computed during backward pass.</p><p><strong>Arguments</strong></p><ul><li><code>man::DeMatosCutPruner</code>   Pruner to update.</li><li><code>position::Array{T, 2}</code>   New visited positions, corresponding to a collection of points.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.addstate!" href="#CutPruners.addstate!"><code>CutPruners.addstate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addstate!(man::DeMatosCutPruner, x::Vector)</code></pre><p>Add a new state to test and accordingly update territories of each cut.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.addusage!" href="#CutPruners.addusage!"><code>CutPruners.addusage!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Update cuts relevantness after a solver&#39;s call returning dual vector <code>σρ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.appendcuts!" href="#CutPruners.appendcuts!"><code>CutPruners.appendcuts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Append cuts (A, b, mycut) in CutPruner <code>man</code>.</p></div></div><div><div><p>Push new cut in CutPruner <code>man</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.checkredundancy" href="#CutPruners.checkredundancy"><code>CutPruners.checkredundancy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkredundancy{T}(A::AbstractMatrix{T}, b::AbstractVector{T},
                   Anew::AbstractMatrix{T}, bnew::AbstractVector{T},
                   isfun::Bool, islb::Bool, tol::Float64, ident::Bool=false)</code></pre><p>Check redundant cuts between the Polyhedra (A,b) and (Anew, bnew). Return index of redundant cuts in <code>Anew</code>.</p><p><strong>Arguments</strong></p><ul><li><code>isfun::Bool</code>   States if the Polyhedra defines a function</li><li><code>islb::Bool</code>   States if the Polyhedra is a lower-bound or an upper-bound</li><li><code>tol::Float64</code>   Tolerance of redundancy check</li><li><code>ident::Bool</code>   States whether (A,b)==(Anew,bnew) if we want to remove redundant   lines in a single Polyhedra</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.choosecutstoremove" href="#CutPruners.choosecutstoremove"><code>CutPruners.choosecutstoremove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove <code>num</code> cuts in CutPruner <code>man</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.cutvalue" href="#CutPruners.cutvalue"><code>CutPruners.cutvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cutvalue{T}(man::DeMatosCutPruner, indc::Int, x::Vector{T})</code></pre><p>Get value of cut with index <code>indc</code> at point <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>man::DeMatosCutPruner</code>   Approximation of the value function as linear cuts</li><li><code>indc::Int</code>   Index of cut to consider</li><li><code>x::Vector{T}</code>   Coordinates of state</li></ul><p><strong>Return</strong></p><p><code>cost::T</code>     Value of cut <code>indc</code> at point <code>x</code>.     If <code>man</code> is a polyhedral function, then it is the value of the cut at <code>x</code>,     otherwise, it is the distance between <code>x</code> and the cut.     As a rule of thumb, the higher the <code>cutvalue</code> is, the less it is redundant.</p></div></div></section><pre><code class="language-none">CutPruners.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.exactpruning!" href="#CutPruners.exactpruning!"><code>CutPruners.exactpruning!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">exactpruning!(man::AbstractCutPruner, solver::MathProgBase.AbstractMathProgSolver;
              ub=Inf, lb=-Inf, epsilon=1e-5)</code></pre><p>Remove dominated cuts in CutPruner <code>man</code>.</p><p>We use a LP solver to determine whether a cut is dominated or not.</p><p><strong>Arguments</strong></p><ul><li><code>man::AbstractCutPruner</code>   Cut pruner where to remove cuts</li><li><code>solver</code>   Solver used to solve LP</li><li><code>ub::Union{Float64, Vector{Float64}}</code>   State x upper bound</li><li><code>lb::Union{Float64, Vector{Float64}}</code>   State x lower bound</li><li><code>epsilon::Float64</code>   Pruning&#39;s tolerance</li></ul></div></div></section><pre><code class="language-none">CutPruners.flength</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.getdominated" href="#CutPruners.getdominated"><code>CutPruners.getdominated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return dominated cuts.</p></div></div></section><pre><code class="language-none">CutPruners.getnreplaced</code></pre><pre><code class="language-none">CutPruners.getsense</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.gettrust" href="#CutPruners.gettrust"><code>CutPruners.gettrust</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get current <code>trust</code> of CutPruner <code>man</code>.</p></div></div></section><pre><code class="language-none">CutPruners.gettrustof</code></pre><pre><code class="language-none">CutPruners.gettype</code></pre><pre><code class="language-none">CutPruners.giveterritory!</code></pre><pre><code class="language-none">CutPruners.hasterritories</code></pre><pre><code class="language-none">CutPruners.hastrust</code></pre><pre><code class="language-none">CutPruners.include</code></pre><pre><code class="language-none">CutPruners.initialtrust</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.initialtrusts" href="#CutPruners.initialtrusts"><code>CutPruners.initialtrusts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get a Vector of Float64 specifying the initial trusts of <code>mycut</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.isbetter" href="#CutPruners.isbetter"><code>CutPruners.isbetter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Test if cut <code>i</code> is better than <code>newcuttrust</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.isdominated" href="#CutPruners.isdominated"><code>CutPruners.isdominated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>State whether a cut is dominated with a tolerance epsilon.</p></div></div></section><pre><code class="language-none">CutPruners.isfun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.isinside" href="#CutPruners.isinside"><code>CutPruners.isinside</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if <code>λ</code> is a line of matrix <code>A</code>. <code>λ</code> might not have the same <code>eltype</code> as <code>A</code> and <code>b</code> as it might have been scaled by <code>normalizecut</code>.</p></div></div></section><pre><code class="language-none">CutPruners.islb</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.keeponlycuts!" href="#CutPruners.keeponlycuts!"><code>CutPruners.keeponlycuts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Keep only cuts whose indexes are in Vector <code>K</code> in CutPruner <code>man</code>. If <code>K</code> is not sorted, the cuts will change their order accordingly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.ncuts" href="#CutPruners.ncuts"><code>CutPruners.ncuts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return number of cuts in CutPruner <code>man</code>.</p></div></div></section><pre><code class="language-none">CutPruners.newids</code></pre><pre><code class="language-none">CutPruners.normalizedcut</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.optimalcut" href="#CutPruners.optimalcut"><code>CutPruners.optimalcut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimalcut{T}(man::DeMatosCutPruner, xf::Vector{T})</code></pre><p>Find active cut at point <code>xf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>man::DeMatosCutPruner</code>:   CutPruner</li><li><code>xf::Vector{T}</code>:</li></ul><p><strong>Return</strong></p><ul><li><code>bestcost::T</code>   Value of supporting cut at point <code>xf</code></li><li><code>bestcut::Int</code>   Index of supporting cut at point <code>xf</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.removecuts!" href="#CutPruners.removecuts!"><code>CutPruners.removecuts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove cuts whose indexes are in Vector <code>K</code> in CutPruner <code>man</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.replacecuts!" href="#CutPruners.replacecuts!"><code>CutPruners.replacecuts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Replace cuts at indexes in <code>K</code> by cuts in (A, b, mycut) in CutPruner <code>man</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CutPruners.updateterritory!" href="#CutPruners.updateterritory!"><code>CutPruners.updateterritory!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updateterritory!(man::DeMatosCutPruner, indcut::Int)</code></pre><p>Update territories (i.e. the set of tested states where     a given cut is active) considering new cut given by index <code>indcut</code>.</p><p><strong>Arguments</strong></p><ul><li><code>man::DeMatosCutPruner</code>:</li><li><code>indcut::Int</code>:   new cut index</li></ul></div></div></section><pre><code class="language-none">CutPruners.updatetrust!</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
