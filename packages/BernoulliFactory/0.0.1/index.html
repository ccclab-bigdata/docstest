<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · BernoulliFactory.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BernoulliFactory.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Currently-implemented-1">Currently implemented</a></li><li><a class="toctext" href="#Algorithms-used-1">Algorithms used</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BernoulliFactory.jl-1" href="#BernoulliFactory.jl-1">BernoulliFactory.jl</a></h1><p><a href="https://travis-ci.org/awllee/BernoulliFactory.jl"><img src="https://travis-ci.org/awllee/BernoulliFactory.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/awllee/bernoullifactory-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/x5w1kedalfn3f6wp/branch/master?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/github/awllee/BernoulliFactory.jl?branch=master"><img src="https://coveralls.io/repos/github/awllee/BernoulliFactory.jl/badge.svg?branch=master" alt="Coverage Status"/></a> <a href="http://codecov.io/github/awllee/BernoulliFactory.jl?branch=master"><img src="http://codecov.io/github/awllee/BernoulliFactory.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>This package provides some Bernoulli factory algorithms, and a constrained, unbiased estimation algorithm.</p><p>Given a function g such that g() returns a Bernoulli(p) variate, and a function f mapping [0,1] -&gt; [0,1] a Bernoulli factory algorithm should use calls to g produce a Bernoulli(f(p)) variate. Not all functions f admit an algorithm (Keane &amp; O&#39;Brien, 1994), and some algorithms require additional information.</p><h2><a class="nav-anchor" id="Currently-implemented-1" href="#Currently-implemented-1">Currently implemented</a></h2><table><tr><th>Command</th><th>Description</th></tr><tr><td>f(p) = exp(-λp), λ &gt;= 0</td><td><code>expMinus(g, λ)</code></td></tr><tr><td>f(p) = p⁠^a, a &gt;= 0</td><td><code>power(g, a)</code></td></tr><tr><td>f(p) = C*p / (1+C*p), C &gt; 0</td><td><code>logistic(g, C)</code></td></tr><tr><td>f(p) = C*p, ϵ ∈ (0, 1-C*p)</td><td><code>linear(g, C, ϵ)</code></td></tr><tr><td>f(p) = C/p, ϵ ∈ (0, p-C)</td><td><code>inverse(g, C, ϵ)</code></td></tr><tr><td>f(p1, p2) = C1*p1 / (C1*p1 + C2*p2)</td><td><code>twocoin(g1, g2, C1, C2)</code></td></tr></table><h3><a class="nav-anchor" id="Constrained,-unbiased-estimation-1" href="#Constrained,-unbiased-estimation-1">Constrained, unbiased estimation</a></h3><p>Also implemented is a variant of signed estimation, <code>signedEstimate(μ, φ, a, b, δ, c, n)</code>:</p><p>Let X ~ μ and real-valued φ satisfy</p><p>a &lt;= inf<em>x φ(x) &lt; b &lt; δ &lt;= E[φ(X)] &lt; sup</em>x φ(x) &lt;= c,</p><p>with known (a, b, δ, c). If simulation from μ and evaluation of φ is feasible, one can simulate W satisfying</p><ol><li>E[W] = E[φ(X)]</li><li>Pr(b &lt;= W &lt;= max{2b-a,c}) = 1</li></ol><p>The random variable W is the product of two independent random variables, X and Z, and the positive integer parameter <code>n</code> specifies a number of averages to use to define X.</p><h2><a class="nav-anchor" id="Algorithms-used-1" href="#Algorithms-used-1">Algorithms used</a></h2><p><code>expMinus</code> is an obvious extension of the approach described in Wastlund (1999) for λ=1.</p><p><code>power</code> is from Mendo (2016).</p><p><code>logistic</code> is from Huber (2017).</p><p><code>linear</code> is from Huber (2016), and for a large range of parameter settings appears to use the least expected flips of all algorithms for this problem.</p><p><code>inverse</code> is described in Lee, Doucet &amp; Łatuszyński (2014).</p><p><code>twocoin</code> is described in Gonçalves, Łatuszyński &amp; Roberts (2017).</p><p><code>signedEstimate</code> is described in Appendix C of Lee, Doucet &amp; Łatuszyński (2014).</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>All Bernoulli factory algorithms return a tuple <code>(X, flips)</code> where <code>X</code> is true or false and <code>flips</code> is the number of calls of <code>g()</code> by the algorithms.</p><p><code>signedEstimate</code> returns a tuple <code>(X, flips, calls)</code> where <code>X</code> is true or false, <code>flips</code> is the number of Bernoulli factory flips and <code>calls</code> is the number of calls of <code>μ()</code> by the algorithms. <code>calls</code> is typically much larger thatn <code>flips</code></p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>Gonçalves, F.B., Łatuszyński, K.G. and Roberts, G.O., 2017. Exact Monte Carlo likelihood-based inference for jump-diffusion processes. arXiv:1707.00332</p><p>Huber, M., 2016. Nearly optimal Bernoulli factories for linear functions. Combinatorics, Probability and Computing, 25(4), pp.577-591.</p><p>Huber, M., 2017. Optimal linear Bernoulli factories for small mean problems. Methodology and Computing in Applied Probability, 19(2), pp.631-645.</p><p>Keane, M.S. and O&#39;Brien, G.L., 1994. A Bernoulli factory. ACM Transactions on Modeling and Computer Simulation (TOMACS), 4(2), pp.213-219.</p><p>Lee, A., Doucet, A. and Łatuszyński, K., 2014. Perfect simulation using atomic regeneration with application to Sequential Monte Carlo. arXiv:1407.5770</p><p>Mendo, L., 2016. An asymptotically optimal Bernoulli factory for certain functions that can be expressed as power series. arXiv:1612.08923</p><p>Wästlund, J., 1999. Functions arising by coin flipping. Technical Report, KTH, Stockholm.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
