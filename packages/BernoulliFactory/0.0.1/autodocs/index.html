<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BernoulliFactory.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BernoulliFactory.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BernoulliFactory.BernoulliFactory</code></pre><pre><code class="language-none">BernoulliFactory._algorithmA</code></pre><pre><code class="language-none">BernoulliFactory._algorithmB</code></pre><pre><code class="language-none">BernoulliFactory._annotateμ</code></pre><pre><code class="language-none">BernoulliFactory._highPowerLogistic</code></pre><pre><code class="language-none">BernoulliFactory._huber2016</code></pre><pre><code class="language-none">BernoulliFactory._huber2017</code></pre><pre><code class="language-none">BernoulliFactory._huber2017Small</code></pre><pre><code class="language-none">BernoulliFactory._logistic</code></pre><pre><code class="language-none">BernoulliFactory._mendoPower</code></pre><pre><code class="language-none">BernoulliFactory._sampleGeometric</code></pre><pre><code class="language-none">BernoulliFactory._sampleSignedBernoulli</code></pre><pre><code class="language-none">BernoulliFactory._signRejectionSample</code></pre><pre><code class="language-none">BernoulliFactory._signedEstimate</code></pre><pre><code class="language-none">BernoulliFactory._wastlundSqrt</code></pre><pre><code class="language-none">BernoulliFactory.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.expMinus" href="#BernoulliFactory.expMinus"><code>BernoulliFactory.expMinus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expMinus(f::F, λ::Float64, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>λ &gt;= 0</code></li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(exp(-λ*p)) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><pre><code class="language-none">BernoulliFactory.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.inverse" href="#BernoulliFactory.inverse"><code>BernoulliFactory.inverse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inverse(f::F, C::Float64, ϵ::Float64, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>C ∈ [0,p)</code></li><li><code>ϵ ∈ (0,1)</code> satisfying p &gt; C + ⁠ϵ.</li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(C/p) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.linear" href="#BernoulliFactory.linear"><code>BernoulliFactory.linear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linear(f::F, C::Float64, ϵ::Float64, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>C &gt;= 0</code></li><li><code>ϵ ∈ (0,1)</code> satisfying C*p &lt; 1-⁠ϵ.</li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(C*p) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.logistic" href="#BernoulliFactory.logistic"><code>BernoulliFactory.logistic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logistic(f::F, C::Float64, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>C &gt;= 0</code></li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(C<em>p/(1.0+C</em>p)) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.power" href="#BernoulliFactory.power"><code>BernoulliFactory.power</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">power(f::F, a::Float64, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>a &gt;= 0</code></li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(p^a) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.signedEstimate" href="#BernoulliFactory.signedEstimate"><code>BernoulliFactory.signedEstimate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>signedEstimate(μ::F1, φ::F2, c::Float64, δ::Float64, n::Int64, rng::RNG=GLOBAL_RNG) where {F1&lt;:Function, F2&lt;:Function, RNG&lt;:AbstractRNG} where {F1&lt;:Function, F2&lt;:Function, RNG&lt;:AbstractRNG}</p><p>Input:</p><ul><li><code>μ()</code> simulates a random variate X</li><li><code>φ(X)</code> is real-valued</li><li><code>c</code> satisfies sup_x |φ(x)| &lt;= c</li><li><code>δ &gt; 0</code> satisfies μ(φ) &gt;= δ</li><li><code>n</code> specifies a number of X variables to average</li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>Y, flips, calls</code></p><ul><li><code>Y</code> is almost surely valued in [0.0,c] with E[Y] = μ(φ)</li><li><code>flips</code> is the number of coin tosses by the Bernoulli Factory algorithm</li><li><code>calls</code> is the number of calls of μ() in total</li></ul></div></div><div><div><p>signedEstimate(μ::F1, φ::F2, a::Float64, b::Float64, δ::Float64, c::Float64, n::Int64, rng::RNG=GLOBAL_RNG) where {F1&lt;:Function, F2&lt;:Function, RNG&lt;:AbstractRNG}</p><p>Input:</p><ul><li><code>μ()</code> simulates a random variate X</li><li><code>φ(X)</code> is real-valued</li><li><code>a,b,δ,c</code> satisfy a &lt;= inf<em>x φ(x) &lt; b &lt; δ &lt;= μ(φ) &lt; sup</em>x φ(x) &lt;= c</li><li><code>n</code> specifies a number of X variables to average</li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>Y, flips, calls</code></p><ul><li><code>Y</code> is almost surely valued in [b, max{2b-a,c}] with E[Y] = μ(φ)</li><li><code>flips</code> is the number of coin tosses by the Bernoulli Factory algorithm</li><li><code>calls</code> is the number of calls of μ() in total</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.sqrt" href="#BernoulliFactory.sqrt"><code>BernoulliFactory.sqrt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sqrt(f::F, rng::RNG=GLOBAL_RNG) where {F&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f()</code> simulates Bernoulli(p) random variates (of type Bool)</li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(sqrt(p)) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernoulliFactory.twocoin" href="#BernoulliFactory.twocoin"><code>BernoulliFactory.twocoin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">twocoin(f1::F1, f2::F2, C1::Float64, C2::Float64, rng::RNG=GLOBAL_RNG) where {F1&lt;:Function, F2&lt;:Function, RNG&lt;:AbstractRNG}</code></pre><p>Input:</p><ul><li><code>f1()</code> simulates Bernoulli(p1) random variates (of type Bool)</li><li><code>f2()</code> simulates Bernoulli(p2) random variates (of type Bool)</li><li><code>C1, C2 &gt;= 0</code></li><li><code>[rng]</code> the RNG to used by the algorithm (does not affect f)</li></ul><p>Output: <code>X, flips</code></p><ul><li><code>X</code> is a Bernoulli(C1<em>p1/(C1</em>p1+C2*p2)) variate</li><li><code>flips</code> is the number of calls of f()</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
