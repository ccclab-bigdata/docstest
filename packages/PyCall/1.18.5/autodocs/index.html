<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · PyCall.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PyCall.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">PyCall.@npyinitialize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.@py_str" href="#PyCall.@py_str"><code>PyCall.@py_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">py&quot;.....python code.....&quot;</code></pre><p>Evaluate the given Python code string in the main Python module.</p><p>If the string is a single line (no newlines), then the Python expression is evaluated and the result is returned. If the string is multiple lines (contains a newline), then the Python code is compiled and evaluated in the <code>__main__</code> Python module and nothing is returned.</p><p>If the <code>o</code> option is appended to the string, as in <code>py&quot;...&quot;o</code>, then the return value is an unconverted <code>PyObject</code>; otherwise, it is automatically converted to a native Julia type if possible.</p><p>Any <code>$var</code> or <code>$(expr)</code> expressions that appear in the Python code (except in comments or string literals) are evaluated in Julia and passed to Python via auto-generated global variables. This allows you to &quot;interpolate&quot; Julia values into Python code.</p><p>Similarly, ny <code>$$var</code> or <code>$$(expr)</code> expressions in the Python code are evaluated in Julia, converted to strings via <code>string</code>, and are pasted into the Python code.   This allows you to evaluate code where the code itself is generated by a Julia expression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.@pycall" href="#PyCall.@pycall"><code>PyCall.@pycall</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@pycall func(args...)::T</code></pre><p>Convenience macro which turns <code>func(args...)::T</code> into pycall(func, T, args...)</p></div></div></section><pre><code class="language-none">PyCall.@pycheck</code></pre><pre><code class="language-none">PyCall.@pycheckn</code></pre><pre><code class="language-none">PyCall.@pycheckv</code></pre><pre><code class="language-none">PyCall.@pycheckz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.@pydef" href="#PyCall.@pydef"><code>PyCall.@pydef</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@pydef</code> creates a Python class whose methods are implemented in Julia. For instance,</p><pre><code class="language-none">@pyimport numpy.polynomial as P
@pydef type Doubler &lt;: P.Polynomial
    __init__(self, x=10) = (self[:x] = x)
    my_method(self, arg1::Number) = arg1 + 20
    x2.get(self) = self[:x] * 2
    x2.set!(self, new_val) = (self[:x] = new_val / 2)
end
Doubler()[:x2]</code></pre><p>is essentially equivalent to the following Python code:</p><pre><code class="language-none">class Doubler(numpy.polynomial.Polynomial):
    def __init__(self, x=10):
        self.x = x
    def my_method(self, arg1): return arg1 + 20
    @property
    def x2(self): return self.x * 2
    @x2.setter
    def x2(self, new_val):
        self.x = new_val / 2
Doubler().x2</code></pre><p>The method arguments and return values are automatically converted between Julia and Python. All Python special methods are supported (<code>__len__</code>, <code>__add__</code>, etc.)</p><p><code>@pydef</code> allows for multiple inheritance of Python types:</p><pre><code class="language-none">@pydef type SomeType &lt;: (BaseClass1, BaseClass2)
    ...
end</code></pre><p>Multiple dispatch works, too:</p><pre><code class="language-none">x2.set!(self, new_x::Int) = ...
x2.set!(self, new_x::Float64) = ...</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.@pydef_object" href="#PyCall.@pydef_object"><code>PyCall.@pydef_object</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@pydef_object</code> is like <code>@pydef</code>, but it returns the metaclass as a <code>PyObject</code> instead of binding it to the class name. It&#39;s side-effect-free, except for the definition of the class methods.</p></div></div></section><pre><code class="language-none">PyCall.@pyglobal</code></pre><pre><code class="language-none">PyCall.@pyglobalobj</code></pre><pre><code class="language-none">PyCall.@pyglobalobjptr</code></pre><pre><code class="language-none">PyCall.@pyimport</code></pre><pre><code class="language-none">PyCall.@pylab</code></pre><pre><code class="language-none">PyCall.@pysym</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.@pywith" href="#PyCall.@pywith"><code>PyCall.@pywith</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@pywith</code></pre><p>Mimics a Python &#39;with&#39; statement. Usage:</p><p>@pywith EXPR[::TYPE1] [as VAR[::TYPE2]] begin     BLOCK end</p><p>TYPE1/TYPE2 can optionally be used to override automatic conversion to Julia types for both the context manager and variable in cases where this is not desired.</p></div></div></section><pre><code class="language-none">PyCall.@return_not_None</code></pre><pre><code class="language-none">PyCall.@with_ioraise</code></pre><pre><code class="language-none">PyCall.ActivatePyActCtx</code></pre><pre><code class="language-none">PyCall.BuiltinFunctionType</code></pre><pre><code class="language-none">PyCall.DateTimeType</code></pre><pre><code class="language-none">PyCall.DateTime_FromDateAndTime</code></pre><pre><code class="language-none">PyCall.DateType</code></pre><pre><code class="language-none">PyCall.Date_FromDate</code></pre><pre><code class="language-none">PyCall.DeactivatePyActCtx</code></pre><pre><code class="language-none">PyCall.DeltaType</code></pre><pre><code class="language-none">PyCall.Delta_FromDelta</code></pre><pre><code class="language-none">PyCall.Dl_info</code></pre><pre><code class="language-none">PyCall.EnumProcessModules</code></pre><pre><code class="language-none">PyCall.FuncWrapper</code></pre><pre><code class="language-none">PyCall.LongInt</code></pre><pre><code class="language-none">PyCall.METH_CLASS</code></pre><pre><code class="language-none">PyCall.METH_KEYWORDS</code></pre><pre><code class="language-none">PyCall.METH_NOARGS</code></pre><pre><code class="language-none">PyCall.METH_O</code></pre><pre><code class="language-none">PyCall.METH_STATIC</code></pre><pre><code class="language-none">PyCall.METH_VARARGS</code></pre><pre><code class="language-none">PyCall.MethodType</code></pre><pre><code class="language-none">PyCall.MethodWrapperType</code></pre><pre><code class="language-none">PyCall.NPY_ANYORDER</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_ALIGNED</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_C_CONTIGUOUS</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_ELEMENTSTRIDES</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_ENSUREARRAY</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_ENSURECOPY</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_FORCECAST</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_F_CONTIGUOUS</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_NOTSWAPPED</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_OWNDATA</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_UPDATEIFCOPY</code></pre><pre><code class="language-none">PyCall.NPY_ARRAY_WRITEABLE</code></pre><pre><code class="language-none">PyCall.NPY_BOOL</code></pre><pre><code class="language-none">PyCall.NPY_BYTE</code></pre><pre><code class="language-none">PyCall.NPY_CDOUBLE</code></pre><pre><code class="language-none">PyCall.NPY_CFLOAT</code></pre><pre><code class="language-none">PyCall.NPY_CLONGDOUBLE</code></pre><pre><code class="language-none">PyCall.NPY_CORDER</code></pre><pre><code class="language-none">PyCall.NPY_DOUBLE</code></pre><pre><code class="language-none">PyCall.NPY_FLOAT</code></pre><pre><code class="language-none">PyCall.NPY_FORTRANORDER</code></pre><pre><code class="language-none">PyCall.NPY_HALF</code></pre><pre><code class="language-none">PyCall.NPY_INT</code></pre><pre><code class="language-none">PyCall.NPY_LONG</code></pre><pre><code class="language-none">PyCall.NPY_LONGDOUBLE</code></pre><pre><code class="language-none">PyCall.NPY_LONGLONG</code></pre><pre><code class="language-none">PyCall.NPY_OBJECT</code></pre><pre><code class="language-none">PyCall.NPY_SHORT</code></pre><pre><code class="language-none">PyCall.NPY_STRING</code></pre><pre><code class="language-none">PyCall.NPY_TYPES</code></pre><pre><code class="language-none">PyCall.NPY_UBYTE</code></pre><pre><code class="language-none">PyCall.NPY_UINT</code></pre><pre><code class="language-none">PyCall.NPY_ULONG</code></pre><pre><code class="language-none">PyCall.NPY_ULONGLONG</code></pre><pre><code class="language-none">PyCall.NPY_UNICODE</code></pre><pre><code class="language-none">PyCall.NPY_USHORT</code></pre><pre><code class="language-none">PyCall.NPY_VOID</code></pre><pre><code class="language-none">PyCall.NULL_UInt8_Ptr</code></pre><pre><code class="language-none">PyCall.NpyArray</code></pre><pre><code class="language-none">PyCall.PYTHONHOME</code></pre><pre><code class="language-none">PyCall.PY_WRITE_RESTRICTED</code></pre><pre><code class="language-none">PyCall.PyAny</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyArray" href="#PyCall.PyArray"><code>PyCall.PyArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyArray(o::PyObject)</code></pre><p>This converts an <code>ndarray</code> object <code>o</code> to a PyArray.</p><p>This implements a nocopy wrapper to a NumPy array (currently of only numeric types only).</p><p>If you are using <code>pycall</code> and the function returns an <code>ndarray</code>, you can use <code>PyArray</code> as the return type to directly receive a <code>PyArray</code>.</p></div></div></section><pre><code class="language-none">PyCall.PyArray_Info</code></pre><pre><code class="language-none">PyCall.PyBUF_ANY_CONTIGUOUS</code></pre><pre><code class="language-none">PyCall.PyBUF_C_CONTIGUOUS</code></pre><pre><code class="language-none">PyCall.PyBUF_FORMAT</code></pre><pre><code class="language-none">PyCall.PyBUF_F_CONTIGUOUS</code></pre><pre><code class="language-none">PyCall.PyBUF_INDIRECT</code></pre><pre><code class="language-none">PyCall.PyBUF_MAX_NDIM</code></pre><pre><code class="language-none">PyCall.PyBUF_ND</code></pre><pre><code class="language-none">PyCall.PyBUF_SIMPLE</code></pre><pre><code class="language-none">PyCall.PyBUF_STRIDES</code></pre><pre><code class="language-none">PyCall.PyBUF_WRITABLE</code></pre><pre><code class="language-none">PyCall.PyBuffer</code></pre><pre><code class="language-none">PyCall.PyCall</code></pre><pre><code class="language-none">PyCall.PyDateTime_CAPI</code></pre><pre><code class="language-none">PyCall.PyDateTime_Check</code></pre><pre><code class="language-none">PyCall.PyDateTime_Delta</code></pre><pre><code class="language-none">PyCall.PyDate_Check</code></pre><pre><code class="language-none">PyCall.PyDate_HEAD</code></pre><pre><code class="language-none">PyCall.PyDelta_Check</code></pre><pre><code class="language-none">PyCall.PyDelta_FromDSU</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyDict" href="#PyCall.PyDict"><code>PyCall.PyDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyDict(o::PyObject)
PyDict(d::Dict{K,V})</code></pre><p>This returns a PyDict, which is a no-copy wrapper around a Python dictionary.</p><p>Alternatively, you can specify the return type of a <code>pycall</code> as PyDict.</p></div></div></section><pre><code class="language-none">PyCall.PyDict_Iterator</code></pre><pre><code class="language-none">PyCall.PyError</code></pre><pre><code class="language-none">PyCall.PyGetSetDef</code></pre><pre><code class="language-none">PyCall.PyIO</code></pre><pre><code class="language-none">PyCall.PyIOError</code></pre><pre><code class="language-none">PyCall.PyMemberDef</code></pre><pre><code class="language-none">PyCall.PyMethodDef</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyNULL" href="#PyCall.PyNULL"><code>PyCall.PyNULL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PyNULL()</code></pre><p>Return a <code>PyObject</code> that has a <code>NULL</code> underlying pointer, i.e. it doesn&#39;t actually refer to any Python object.</p><p>This is useful for initializing <code>PyObject</code> global variables and array elements before an actual Python object is available.   For example, you might do <code>const myglobal = PyNULL()</code> and later on (e.g. in a module <code>__init__</code> function), reassign <code>myglobal</code> to point to an actual object with <code>copy!(myglobal, someobject)</code>.   This procedure will properly handle Python&#39;s reference counting (so that the Python object will not be freed until you are done with <code>myglobal</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyObject" href="#PyCall.PyObject"><code>PyCall.PyObject</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyObject(juliavar)</code></pre><p>This converts a julia variable to a PyObject, which is a reference to a Python object. You can convert back to native julia types using <code>convert(T, o::PyObject)</code>, or using <code>PyAny(o)</code>.</p><p>Given <code>o::PyObject</code>, <code>o[:attribute]</code> is equivalent to <code>o.attribute</code> in Python, with automatic type conversion.</p><p>Given <code>o::PyObject</code>, <code>get(o, key)</code> is equivalent to <code>o[key]</code> in Python, with automatic type conversion.</p></div></div></section><pre><code class="language-none">PyCall.PyObject_struct</code></pre><pre><code class="language-none">PyCall.PyPtr</code></pre><pre><code class="language-none">PyCall.PyPtr_NULL</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyReverseDims" href="#PyCall.PyReverseDims"><code>PyCall.PyReverseDims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PyReverseDims(array)</code></pre><p>Passes a Julia <code>array</code> to Python as a NumPy row-major array (rather than Julia&#39;s native column-major order) with the dimensions reversed (e.g. a 2×3×4 Julia array is passed as a 4×3×2 NumPy row-major array).  This is useful for Python libraries that expect row-major data.</p></div></div></section><pre><code class="language-none">PyCall.PyString_AsStringAndSize</code></pre><pre><code class="language-none">PyCall.PyString_FromStringAndSize</code></pre><pre><code class="language-none">PyCall.PyString_Size</code></pre><pre><code class="language-none">PyCall.PyString_Type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyTextIO" href="#PyCall.PyTextIO"><code>PyCall.PyTextIO</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PyTextIO(io::IO)
PyObject(io::IO)</code></pre><p>Julia IO streams are converted into Python objects implementing the RawIOBase interface, so they can be used for binary I/O in Python</p></div></div></section><pre><code class="language-none">PyCall.PyTypeObject</code></pre><pre><code class="language-none">PyCall.PyTypeObject!</code></pre><pre><code class="language-none">PyCall.PyUnicode_AsUTF8String</code></pre><pre><code class="language-none">PyCall.PyUnicode_DecodeUTF8</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyVector" href="#PyCall.PyVector"><code>PyCall.PyVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyVector(o::PyObject)</code></pre><p>This returns a PyVector object, which is a wrapper around an arbitrary Python list or sequence object.</p><p>Alternatively, <code>PyVector</code> can be used as the return type for a <code>pycall</code> that returns a sequence object (including tuples).</p></div></div></section><pre><code class="language-none">PyCall.Py_EQ</code></pre><pre><code class="language-none">PyCall.Py_GE</code></pre><pre><code class="language-none">PyCall.Py_GT</code></pre><pre><code class="language-none">PyCall.Py_GetVersion</code></pre><pre><code class="language-none">PyCall.Py_LE</code></pre><pre><code class="language-none">PyCall.Py_LT</code></pre><pre><code class="language-none">PyCall.Py_NE</code></pre><pre><code class="language-none">PyCall.Py_SetPythonHome</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_BASETYPE</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_BASE_EXC_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_BYTES_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_CHECKTYPES</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_DICT_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_GC</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_CLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_GC</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_GETCHARBUFFER</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_INDEX</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_INPLACEOPS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_ITER</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_NEWBUFFER</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_RICHCOMPARE</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_SEQUENCE_IN</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_STACKLESS_EXTENSION</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_STACKLESS_EXTENSION_</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_VERSION_TAG</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HAVE_WEAKREFS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_HEAPTYPE</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_INT_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_IS_ABSTRACT</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_LIST_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_LONG_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_READY</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_READYING</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_STRING_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_TUPLE_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_TYPE_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_UNICODE_SUBCLASS</code></pre><pre><code class="language-none">PyCall.Py_TPFLAGS_VALID_VERSION_TAG</code></pre><pre><code class="language-none">PyCall.Py_buffer</code></pre><pre><code class="language-none">PyCall.Py_eval_input</code></pre><pre><code class="language-none">PyCall.Py_file_input</code></pre><pre><code class="language-none">PyCall.Py_hash_t</code></pre><pre><code class="language-none">PyCall.Py_jlWrap</code></pre><pre><code class="language-none">PyCall.Py_single_input</code></pre><pre><code class="language-none">PyCall.READONLY</code></pre><pre><code class="language-none">PyCall.READ_RESTRICTED</code></pre><pre><code class="language-none">PyCall.RESTRICTED</code></pre><pre><code class="language-none">PyCall.T_BOOL</code></pre><pre><code class="language-none">PyCall.T_BYTE</code></pre><pre><code class="language-none">PyCall.T_CHAR</code></pre><pre><code class="language-none">PyCall.T_DOUBLE</code></pre><pre><code class="language-none">PyCall.T_FLOAT</code></pre><pre><code class="language-none">PyCall.T_INT</code></pre><pre><code class="language-none">PyCall.T_LONG</code></pre><pre><code class="language-none">PyCall.T_LONGLONG</code></pre><pre><code class="language-none">PyCall.T_NONE</code></pre><pre><code class="language-none">PyCall.T_OBJECT</code></pre><pre><code class="language-none">PyCall.T_OBJECT_EX</code></pre><pre><code class="language-none">PyCall.T_PYSSIZET</code></pre><pre><code class="language-none">PyCall.T_SHORT</code></pre><pre><code class="language-none">PyCall.T_STRING</code></pre><pre><code class="language-none">PyCall.T_STRING_INPLACE</code></pre><pre><code class="language-none">PyCall.T_UBYTE</code></pre><pre><code class="language-none">PyCall.T_UINT</code></pre><pre><code class="language-none">PyCall.T_ULONG</code></pre><pre><code class="language-none">PyCall.T_ULONGLONG</code></pre><pre><code class="language-none">PyCall.T_USHORT</code></pre><pre><code class="language-none">PyCall.Tk_eventloop</code></pre><pre><code class="language-none">PyCall.TypeTuple</code></pre><pre><code class="language-none">PyCall.__init__</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.__pycall!" href="#PyCall.__pycall!"><code>PyCall.__pycall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Lowest level version of  <code>pycall!(ret, o, ...)</code>, assumes <code>pyargsptr</code> and <code>kw</code> have all their args set to Python values, so we can just call the function <code>o</code>. Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code>.</p></div></div></section><pre><code class="language-none">PyCall._getindex</code></pre><pre><code class="language-none">PyCall._localvar_counter</code></pre><pre><code class="language-none">PyCall._maindict</code></pre><pre><code class="language-none">PyCall._pickle</code></pre><pre><code class="language-none">PyCall._ps_len</code></pre><pre><code class="language-none">PyCall._ps_ptr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall._pycall!" href="#PyCall._pycall!"><code>PyCall._pycall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Low-level version of <code>pycall!(ret, o, ...; kwargs...)</code> Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code></p></div></div><div><div><p>Low-level version of <code>pycall!(ret, o, ...)</code> for when <code>kw</code> is already in python friendly format but you don&#39;t have the python tuple to hold the arguments (<code>pyargsptr</code>). Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code>.</p></div></div></section><pre><code class="language-none">PyCall._pyimport</code></pre><pre><code class="language-none">PyCall._pyjlwrap_call</code></pre><pre><code class="language-none">PyCall._pywith</code></pre><pre><code class="language-none">PyCall._start</code></pre><pre><code class="language-none">PyCall.aligned</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.anaconda_conda" href="#PyCall.anaconda_conda"><code>PyCall.anaconda_conda</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">anaconda_conda()</code></pre><p>Return the path of the <code>conda</code> program if PyCall is configured to use an Anaconda install (but <em>not</em> the Conda.jl Python), and the empty string otherwise.</p></div></div></section><pre><code class="language-none">PyCall.array2py</code></pre><pre><code class="language-none">PyCall.builtin</code></pre><pre><code class="language-none">PyCall.c_contiguous</code></pre><pre><code class="language-none">PyCall.c_void_p_Type</code></pre><pre><code class="language-none">PyCall.callsym</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.conda" href="#PyCall.conda"><code>PyCall.conda</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>True if we are using the Python distribution in the Conda package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.def_py_class" href="#PyCall.def_py_class"><code>PyCall.def_py_class</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">def_py_class(type_name::AbstractString, methods::Vector;
             base_classes=[], getsets::Vector=[])</code></pre><p><code>def_py_class</code> creates a Python class whose methods are implemented in Julia. <code>@pydef</code> macros expand into a call to this function.</p><p><strong>Arguments</strong></p><ul><li><code>methods</code>: a vector of tuples <code>(py_name::String, jl_fun::Function)</code>  <code>py_name</code> will be a method of the Python class, which will call <code>jl_fun</code></li><li><code>base_classes</code>: the Python base classes to inherit from.</li></ul><p>Return value: the created class (<code>::PyTypeObject</code>)</p></div></div></section><pre><code class="language-none">PyCall.delta_dsμ</code></pre><pre><code class="language-none">PyCall.depfile</code></pre><pre><code class="language-none">PyCall.dlinfo1</code></pre><pre><code class="language-none">PyCall.dlinfo2</code></pre><pre><code class="language-none">PyCall.docstring</code></pre><pre><code class="language-none">PyCall.eval</code></pre><pre><code class="language-none">PyCall.eventloops</code></pre><pre><code class="language-none">PyCall.f_contiguous</code></pre><pre><code class="language-none">PyCall.findsym</code></pre><pre><code class="language-none">PyCall.fixqtpath</code></pre><pre><code class="language-none">PyCall.format_traceback</code></pre><pre><code class="language-none">PyCall.gstring_ptr</code></pre><pre><code class="language-none">PyCall.gtk_eventloop</code></pre><pre><code class="language-none">PyCall.gtk_requireversion</code></pre><pre><code class="language-none">PyCall.gui</code></pre><pre><code class="language-none">PyCall.hashsalt</code></pre><pre><code class="language-none">PyCall.hassym</code></pre><pre><code class="language-none">PyCall.include</code></pre><pre><code class="language-none">PyCall.ind2py</code></pre><pre><code class="language-none">PyCall.init_datetime</code></pre><pre><code class="language-none">PyCall.inspect</code></pre><pre><code class="language-none">PyCall.install_doevent</code></pre><pre><code class="language-none">PyCall.interpolate_pycode</code></pre><pre><code class="language-none">PyCall.ioraise</code></pre><pre><code class="language-none">PyCall.is_mapping_object</code></pre><pre><code class="language-none">PyCall.is_pyjlwrap</code></pre><pre><code class="language-none">PyCall.iscontiguous</code></pre><pre><code class="language-none">PyCall.ispybytearray</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.ispynull" href="#PyCall.ispynull"><code>PyCall.ispynull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ispynull(o::PyObject)</code></pre><p>Test where <code>o</code> contains a <code>NULL</code> pointer to a Python object, i.e. whether it is equivalent to a <code>PyNULL()</code> object.</p></div></div></section><pre><code class="language-none">PyCall.isseekable</code></pre><pre><code class="language-none">PyCall.istuplen</code></pre><pre><code class="language-none">PyCall.isvatuple</code></pre><pre><code class="language-none">PyCall.jlWrapIteratorType</code></pre><pre><code class="language-none">PyCall.jlWrapType</code></pre><pre><code class="language-none">PyCall.jl_io_readline</code></pre><pre><code class="language-none">PyCall.jl_io_readlines</code></pre><pre><code class="language-none">PyCall.jl_io_seek</code></pre><pre><code class="language-none">PyCall.jlfun2pyfun</code></pre><pre><code class="language-none">PyCall.jlwrap_iterator</code></pre><pre><code class="language-none">PyCall.julia_args</code></pre><pre><code class="language-none">PyCall.julia_kwarg</code></pre><pre><code class="language-none">PyCall.libpy_handle</code></pre><pre><code class="language-none">PyCall.libpython</code></pre><pre><code class="language-none">PyCall.maindict</code></pre><pre><code class="language-none">PyCall.make_fname</code></pre><pre><code class="language-none">PyCall.modulename</code></pre><pre><code class="language-none">PyCall.mpc</code></pre><pre><code class="language-none">PyCall.mpf</code></pre><pre><code class="language-none">PyCall.mpmath</code></pre><pre><code class="language-none">PyCall.mpmath_init</code></pre><pre><code class="language-none">PyCall.mpprec</code></pre><pre><code class="language-none">PyCall.npy_api</code></pre><pre><code class="language-none">PyCall.npy_bool</code></pre><pre><code class="language-none">PyCall.npy_complexfloating</code></pre><pre><code class="language-none">PyCall.npy_floating</code></pre><pre><code class="language-none">PyCall.npy_initialized</code></pre><pre><code class="language-none">PyCall.npy_integer</code></pre><pre><code class="language-none">PyCall.npy_multiarray</code></pre><pre><code class="language-none">PyCall.npy_number</code></pre><pre><code class="language-none">PyCall.npy_type</code></pre><pre><code class="language-none">PyCall.npy_typestrs</code></pre><pre><code class="language-none">PyCall.npyinitialize</code></pre><pre><code class="language-none">PyCall.parse_pydef</code></pre><pre><code class="language-none">PyCall.parse_pydef_toplevel</code></pre><pre><code class="language-none">PyCall.permanent_strings</code></pre><pre><code class="language-none">PyCall.pickle</code></pre><pre><code class="language-none">PyCall.proc_handle</code></pre><pre><code class="language-none">PyCall.py2array</code></pre><pre><code class="language-none">PyCall.pyFSM</code></pre><pre><code class="language-none">PyCall.pyany_toany</code></pre><pre><code class="language-none">PyCall.pyarray_dims</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pybuiltin" href="#PyCall.pybuiltin"><code>PyCall.pybuiltin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pybuiltin(s::AbstractString)</code></pre><p>Look up a string or symbol <code>s</code> among the global Python builtins. If <code>s</code> is a string it returns a PyObject, while if <code>s</code> is a symbol it returns the builtin converted to <code>PyAny</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pybytes" href="#PyCall.pybytes"><code>PyCall.pybytes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pybytes(b::Union{String,DenseVector{UInt8}})</code></pre><p>Convert <code>b</code> to a Python <code>bytes</code> object.   This differs from the default <code>PyObject(b)</code> conversion of <code>String</code> to a Python string (which may fail if <code>b</code> does not contain valid Unicode), or from the default conversion of a <code>Vector{UInt8}</code> to a <code>bytearray</code> object (which is mutable, unlike <code>bytes</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pycall" href="#PyCall.pycall"><code>PyCall.pycall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pycall(o::Union{PyObject,PyPtr}, returntype::TypeTuple, args...; kwargs...)</code></pre><p>Call the given Python function (typically looked up from a module) with the given args... (of standard Julia types which are converted automatically to the corresponding Python types if possible), converting the return value to returntype (use a returntype of PyObject to return the unconverted Python object reference, or of PyAny to request an automated conversion)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pycall!" href="#PyCall.pycall!"><code>PyCall.pycall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pycall!(ret::PyObject, o::Union{PyObject,PyPtr}, returntype::Type, args...; kwargs...)</code></pre><p>Set <code>ret</code> to the result of <code>pycall(o, returntype, args...; kwargs)</code> and return <code>convert(returntype, ret)</code>. Avoids allocating an extra PyObject for <code>ret</code>. See <code>pycall</code> for other details.</p></div></div></section><pre><code class="language-none">PyCall.pycall_gc</code></pre><pre><code class="language-none">PyCall.pycomplex_query</code></pre><pre><code class="language-none">PyCall.pydate_query</code></pre><pre><code class="language-none">PyCall.pydecref</code></pre><pre><code class="language-none">PyCall.pydecref_</code></pre><pre><code class="language-none">PyCall.pydict_query</code></pre><pre><code class="language-none">PyCall.pyembed</code></pre><pre><code class="language-none">PyCall.pyerr_check</code></pre><pre><code class="language-none">PyCall.pyerr_clear</code></pre><pre><code class="language-none">PyCall.pyerr_occurred</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyeval" href="#PyCall.pyeval"><code>PyCall.pyeval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyeval(s::AbstractString, returntype::TypeTuple=PyAny, locals=PyDict{AbstractString, PyObject}(),
                            input_type=Py_eval_input; kwargs...)</code></pre><p>This evaluates <code>s</code> as a Python string and returns the result converted to <code>rtype</code> (which defaults to <code>PyAny</code>). The remaining arguments are keywords that define local variables to be used in the expression.</p><p>For example, <code>pyeval(&quot;x + y&quot;, x=1, y=2)</code> returns 3.</p></div></div></section><pre><code class="language-none">PyCall.pyeval_</code></pre><pre><code class="language-none">PyCall.pyexc</code></pre><pre><code class="language-none">PyCall.pyexc_initialize</code></pre><pre><code class="language-none">PyCall.pyexists</code></pre><pre><code class="language-none">PyCall.pyfloat_query</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyfunction" href="#PyCall.pyfunction"><code>PyCall.pyfunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyfunction(f, argtypes...; kwtypes...)</code></pre><p>Create a Python object that wraps around the Julia function (or callable object) <code>f</code>.   Unlike <code>PyObject(f)</code>, this allows you to specify the argument types that the Julia function expects — giving you more control and potentially better performance.</p><p><code>kwtypes...</code> should be a set of <code>somekeyword=SomeType</code> arguments giving the desired Julia type for each keyword <code>somekeyword</code>.  Unspecified keywords are converted to <code>PyAny</code> (i.e. auto-detected) by default.</p><p>The return value <code>ret = f(...)</code> is still converted back to a Python object by <code>PyObject(ret)</code>.   If you want a different return-type conversion than the default of <code>PyObject(ret)</code>, you can instead call <code>pyfunctionret</code>.</p></div></div></section><pre><code class="language-none">PyCall.pyfunction_query</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyfunctionret" href="#PyCall.pyfunctionret"><code>PyCall.pyfunctionret</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyfunctionret(f, returntype, argtypes...; kwtypes...)</code></pre><p>Like <code>pyfunction</code>, but also lets you specify the <code>returntype</code> for conversion back to Python.   In particular, if <code>ret = f(...)</code> is the return value of <code>f</code>, then it is converted to Python via <code>PyObject(returntype(ret))</code>.</p><p>If <code>returntype</code> is <code>Any</code>, then <code>ret</code> is not converted to a &quot;native&quot; Python type at all, and is instead converted to a &quot;wrapped&quot; Julia object in Python.  If <code>returntype</code> is <code>nothing</code>, then the return value is discarded and <code>nothing</code> is returned to Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui" href="#PyCall.pygui"><code>PyCall.pygui</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pygui()</code></pre><p>Return the current GUI toolkit as a symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui_start" href="#PyCall.pygui_start"><code>PyCall.pygui_start</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pygui_start(gui::Symbol = pygui())</code></pre><p>Start the event loop of a certain toolkit.</p><p>The argument <code>gui</code> defaults to the current default GUI, but it could be <code>:wx</code>, <code>:gtk</code>, <code>:gtk3</code>, <code>:tk</code>, or <code>:qt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui_stop" href="#PyCall.pygui_stop"><code>PyCall.pygui_stop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pygui_stop(gui::Symbol = pygui())</code></pre><p>Stop any running event loop for gui. The <code>gui</code> argument defaults to current default GUI.</p></div></div></section><pre><code class="language-none">PyCall.pygui_stop_all</code></pre><pre><code class="language-none">PyCall.pygui_works</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport" href="#PyCall.pyimport"><code>PyCall.pyimport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyimport(s::AbstractString)</code></pre><p>Import the Python module <code>s</code> (a string or symbol) and return a pointer to it (a <code>PyObject</code>). Functions or other symbols in the module may then be looked up by s[name] where name is a string (for the raw PyObject) or symbol (for automatic type-conversion). Unlike the @pyimport macro, this does not define a Julia module and members cannot be accessed with <code>s.name</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport_conda" href="#PyCall.pyimport_conda"><code>PyCall.pyimport_conda</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyimport_conda(modulename, condapkg, [channel])</code></pre><p>Returns the result of <code>pyimport(modulename)</code> if possible.   If the module is not found, and PyCall is configured to use the Conda Python distro (via the Julia Conda package), then automatically install <code>condapkg</code> via <code>Conda.add(condapkg)</code> and then re-try the <code>pyimport</code>.   Other Anaconda-based Python installations are also supported as long as their <code>conda</code> program is functioning.</p><p>If PyCall is not using Conda and the <code>pyimport</code> fails, throws an exception with an error message telling the user how to configure PyCall to use Conda for automated installation of the module.</p><p>The third argument, <code>channel</code> is an optional Anaconda &quot;channel&quot; to use for installing the package; this is useful for packages that are not included in the default Anaconda package listing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport_e" href="#PyCall.pyimport_e"><code>PyCall.pyimport_e</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyimport_e(s::AbstractString)</code></pre><p>Like <code>pyimport(s)</code>, but returns an <code>ispynull(o) == true</code> object if the module cannot be imported rather than throwing an error.</p></div></div></section><pre><code class="language-none">PyCall.pyimport_name</code></pre><pre><code class="language-none">PyCall.pyincref</code></pre><pre><code class="language-none">PyCall.pyincref_</code></pre><pre><code class="language-none">PyCall.pyint_query</code></pre><pre><code class="language-none">PyCall.pyio_initialize</code></pre><pre><code class="language-none">PyCall.pyio_initialized</code></pre><pre><code class="language-none">PyCall.pyio_jl</code></pre><pre><code class="language-none">PyCall.pyisinstance</code></pre><pre><code class="language-none">PyCall.pyjlwrap_call</code></pre><pre><code class="language-none">PyCall.pyjlwrap_dealloc</code></pre><pre><code class="language-none">PyCall.pyjlwrap_doc</code></pre><pre><code class="language-none">PyCall.pyjlwrap_getattr</code></pre><pre><code class="language-none">PyCall.pyjlwrap_getiter</code></pre><pre><code class="language-none">PyCall.pyjlwrap_hash</code></pre><pre><code class="language-none">PyCall.pyjlwrap_hash32</code></pre><pre><code class="language-none">PyCall.pyjlwrap_init</code></pre><pre><code class="language-none">PyCall.pyjlwrap_iternext</code></pre><pre><code class="language-none">PyCall.pyjlwrap_membername</code></pre><pre><code class="language-none">PyCall.pyjlwrap_members</code></pre><pre><code class="language-none">PyCall.pyjlwrap_new</code></pre><pre><code class="language-none">PyCall.pyjlwrap_repr</code></pre><pre><code class="language-none">PyCall.pyjlwrap_type</code></pre><pre><code class="language-none">PyCall.pyjlwrap_type!</code></pre><pre><code class="language-none">PyCall.pymp_query</code></pre><pre><code class="language-none">PyCall.pynothing</code></pre><pre><code class="language-none">PyCall.pynothing_query</code></pre><pre><code class="language-none">PyCall.pyprogramname</code></pre><pre><code class="language-none">PyCall.pyproperty</code></pre><pre><code class="language-none">PyCall.pyptr_query</code></pre><pre><code class="language-none">PyCall.pyquery</code></pre><pre><code class="language-none">PyCall.pyraise</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyrepr" href="#PyCall.pyrepr"><code>PyCall.pyrepr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyrepr(o::PyObject)</code></pre><p>Return a string representation of <code>o</code> corresponding to <code>repr(o)</code> in Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyreturn" href="#PyCall.pyreturn"><code>PyCall.pyreturn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyreturn(x) :: PyPtr</code></pre><p>Prepare <code>PyPtr</code> from <code>x</code> for passing it to Python.  If <code>x</code> is already a <code>PyObject</code>, the refcount is incremented.  Otherwise a <code>PyObject</code> wrapping/converted from <code>x</code> is created.</p></div></div></section><pre><code class="language-none">PyCall.pysalt</code></pre><pre><code class="language-none">PyCall.pysalt32</code></pre><pre><code class="language-none">PyCall.pysequence_query</code></pre><pre><code class="language-none">PyCall.pysetarg!</code></pre><pre><code class="language-none">PyCall.pysetargs!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystealref!" href="#PyCall.pystealref!"><code>PyCall.pystealref!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>&quot;Steal&quot; a reference from a PyObject: return the raw PyPtr, while setting the corresponding <code>o.o</code> field to <code>NULL</code> so that no decref will be performed when <code>o</code> is garbage collected.  (This means that you can no longer use <code>o</code>.)  Used for passing objects to Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystr" href="#PyCall.pystr"><code>PyCall.pystr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pystr(o::PyObject)</code></pre><p>Return a string representation of <code>o</code> corresponding to <code>str(o)</code> in Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystring" href="#PyCall.pystring"><code>PyCall.pystring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pystring(o::PyObject)</code></pre><p>Return a string representation of <code>o</code>.  Normally, this corresponds to <code>repr(o)</code> in Python, but unlike <code>repr</code> it should never fail (falling back to <code>str</code> or to printing the raw pointer if necessary).</p></div></div></section><pre><code class="language-none">PyCall.pystring_query</code></pre><pre><code class="language-none">PyCall.python</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pytype_mapping" href="#PyCall.pytype_mapping"><code>PyCall.pytype_mapping</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pytype_mapping(pytype, jltype)</code></pre><p>Given a Python type object <code>pytype</code>, tell PyCall to convert it to <code>jltype</code> in <code>PyAny(object)</code> conversions.</p></div></div></section><pre><code class="language-none">PyCall.pytype_queries</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pytype_query" href="#PyCall.pytype_query"><code>PyCall.pytype_query</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pytype_query(o::PyObject, default=PyObject)</code></pre><p>Given a Python object <code>o</code>, return the corresponding native Julia type (defaulting to <code>default</code>) that we convert <code>o</code> to in <code>PyAny(o)</code> conversions.</p></div></div></section><pre><code class="language-none">PyCall.pytypeof</code></pre><pre><code class="language-none">PyCall.pyunicode_literals</code></pre><pre><code class="language-none">PyCall.pyversion</code></pre><pre><code class="language-none">PyCall.pyversion_build</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pywrap" href="#PyCall.pywrap"><code>PyCall.pywrap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pywrap(o::PyObject)</code></pre><p>This returns a wrapper <code>w</code> that is an anonymous module which provides (read) access to converted versions of o&#39;s members as w.member.</p><p>For example, <code>@pyimport module as name</code> is equivalent to <code>const name = pywrap(pyimport(&quot;module&quot;))</code></p><p>If the Python module contains identifiers that are reserved words in Julia (e.g. function), they cannot be accessed as <code>w.member</code>; one must instead use <code>w.pymember(:member)</code> (for the PyAny conversion) or w.pymember(&quot;member&quot;) (for the raw PyObject).</p></div></div></section><pre><code class="language-none">PyCall.pywrapfn</code></pre><pre><code class="language-none">PyCall.pyxrange</code></pre><pre><code class="language-none">PyCall.qt_eventloop</code></pre><pre><code class="language-none">PyCall.reserved</code></pre><pre><code class="language-none">PyCall.set!</code></pre><pre><code class="language-none">PyCall.sizeof_PyObject_HEAD</code></pre><pre><code class="language-none">PyCall.some_address_in_libpython</code></pre><pre><code class="language-none">PyCall.some_address_in_main_exe</code></pre><pre><code class="language-none">PyCall.symbols_present</code></pre><pre><code class="language-none">PyCall.tkinter_name</code></pre><pre><code class="language-none">PyCall.tuptype</code></pre><pre><code class="language-none">PyCall.typetuple</code></pre><pre><code class="language-none">PyCall.ufuncType</code></pre><pre><code class="language-none">PyCall.unsafe_pyjlwrap_to_objref</code></pre><pre><code class="language-none">PyCall.wPYTHONHOME</code></pre><pre><code class="language-none">PyCall.weakref_callback</code></pre><pre><code class="language-none">PyCall.weakref_callback_meth</code></pre><pre><code class="language-none">PyCall.weakref_callback_obj</code></pre><pre><code class="language-none">PyCall.wpyprogramname</code></pre><pre><code class="language-none">PyCall.writedims</code></pre><pre><code class="language-none">PyCall.writeok_assign</code></pre><pre><code class="language-none">PyCall.wx_eventloop</code></pre><pre><code class="language-none">PyCall.xrange</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
