<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· PyCall.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PyCall.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Troubleshooting-1">Troubleshooting</a></li><li><a class="toctext" href="#Python-object-interfaces-1">Python object interfaces</a></li><li><a class="toctext" href="#Author-1">Author</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Calling-Python-functions-from-the-Julia-language-1" href="#Calling-Python-functions-from-the-Julia-language-1">Calling Python functions from the Julia language</a></h1><p><a href="https://travis-ci.org/JuliaPy/PyCall.jl"><img src="https://travis-ci.org/JuliaPy/PyCall.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/StevenGJohnson/pycall-jl-nu3aa"><img src="https://ci.appveyor.com/api/projects/status/ycvukpk4ujq987pm?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/r/JuliaPy/PyCall.jl?branch=master"><img src="https://coveralls.io/repos/JuliaPy/PyCall.jl/badge.svg?branch=master" alt="Coverage Status"/></a></p><p><a href="http://pkg.julialang.org/?pkg=PyCall&amp;ver=0.5"><img src="http://pkg.julialang.org/badges/PyCall_0.5.svg" alt="PyCall"/></a> <a href="http://pkg.julialang.org/?pkg=PyCall&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/PyCall_0.6.svg" alt="PyCall"/></a> <a href="http://pkg.julialang.org/?pkg=PyCall&amp;ver=0.7"><img src="http://pkg.julialang.org/badges/PyCall_0.7.svg" alt="PyCall"/></a></p><p>This package provides the ability to directly call and <strong>fully interoperate with Python</strong> from <a href="http://julialang.org/">the Julia language</a>.  You can import arbitrary Python modules from Julia, call Python functions (with automatic conversion of types between Julia and Python), define Python classes from Julia methods, and share large data structures between Julia and Python without copying them.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Within Julia, just use the package manager to run <code>Pkg.add(&quot;PyCall&quot;)</code> to install the files.  Julia 0.5 or later is required.</p><p>The latest development version of PyCall is available from <a href="https://github.com/stevengj/PyCall.jl">https://github.com/stevengj/PyCall.jl</a>.  If you want to switch to this after installing the package, run <code>Pkg.checkout(&quot;PyCall&quot;); Pkg.build(&quot;PyCall&quot;)</code>.</p><p>By default on Mac and Windows systems, <code>Pkg.add(&quot;PyCall&quot;)</code> or <code>Pkg.build(&quot;PyCall&quot;)</code> will use the <a href="https://github.com/Luthaf/Conda.jl">Conda.jl</a> package to install a minimal Python distribution (via <a href="http://conda.pydata.org/docs/install/quick.html">Miniconda</a>) that is private to Julia (not in your <code>PATH</code>).  You can use the <code>Conda</code> Julia package to install more Python packages, and <code>import Conda</code> to print the <code>Conda.PYTHONDIR</code> directory where <code>python</code> was installed. On GNU/Linux systems, PyCall will default to using the <code>python3</code> program (if any, otherwise <code>python</code>) in your PATH.</p><p>The advantage of a Conda-based configuration is particularly compelling if you are installing PyCall in order to use packages like <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> or <a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, as these can then automatically install their Python dependencies.  (To exploit this in your own packages, use the <code>pyimport_conda</code> function described below.)</p><h3><a class="nav-anchor" id="Specifying-the-Python-version-1" href="#Specifying-the-Python-version-1">Specifying the Python version</a></h3><p>If you want to use a different version of Python than the default, you can change the Python version by setting the <code>PYTHON</code> environment variable to the path of the <code>python</code> (or <code>python3</code> etc.) executable and then re-running <code>Pkg.build(&quot;PyCall&quot;)</code>. In Julia:</p><pre><code class="language-none">ENV[&quot;PYTHON&quot;] = &quot;... path of the python program you want ...&quot;
Pkg.build(&quot;PyCall&quot;)</code></pre><p>Note also that you will need to re-run <code>Pkg.build(&quot;PyCall&quot;)</code> if your <code>python</code> program changes significantly (e.g. you switch to a new Python distro, or you switch from Python 2 to Python 3).</p><p>To force Julia to use its own Python distribution, via Conda, simply set <code>ENV[&quot;PYTHON&quot;]</code> to the empty string <code>&quot;&quot;</code> and re-run <code>Pkg.build(&quot;PyCall&quot;)</code>.</p><p>The current Python version being used is stored in the <code>pyversion</code> global variable of the <code>PyCall</code> module.  You can also look at <code>PyCall.libpython</code> to find the name of the Python library or <code>PyCall.pyprogramname</code> for the <code>python</code> program name.  If it is using the Conda Python, <code>PyCall.conda</code> will be <code>true</code>.</p><p>(Technically, PyCall does not use the <code>python</code> program per se: it links directly to the <code>libpython</code> library.  But it finds the location of <code>libpython</code> by running <code>python</code> during <code>Pkg.build</code>.)</p><p>Subsequent builds of PyCall (e.g. when you update the package via <code>Pkg.update</code>) will use the same Python executable name by default, unless you set the <code>PYTHON</code> environment variable or delete the file <code>Pkg.dir(&quot;PyCall&quot;,&quot;deps&quot;,&quot;PYTHON&quot;)</code>.</p><p><strong>Note:</strong> If you use Python <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">virtualenvs</a>, then be aware that PyCall <em>uses the virtualenv it was built with</em>, even if you switch virtualenvs.  If you want to switch PyCall to use a different virtualenv, then you should switch virtualenvs and run <code>rm(Pkg.dir(&quot;PyCall&quot;,&quot;deps&quot;,&quot;PYTHON&quot;)); Pkg.build(&quot;PyCall&quot;)</code>.</p><p><strong>Note:</strong> Usually, the necessary libraries are installed along with Python, but <a href="https://github.com/stevengj/PyCall.jl/issues/122">pyenv on MacOS</a> requires you to install it with <code>env PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.4.3</code>.  The Enthought Canopy Python distribution is currently <a href="https://github.com/stevengj/PyCall.jl/issues/42">not supported</a>. As a general rule, we tend to recommend the <a href="https://store.continuum.io/cshop/anaconda/">Anaconda Python distribution</a> on MacOS and Windows, or using the Julia Conda package, in order to minimize headaches.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>Here is a simple example to call Python&#39;s <code>math.sin</code> function and compare it to the built-in Julia <code>sin</code>:</p><pre><code class="language-none">using PyCall
@pyimport math
math.sin(math.pi / 4) - sin(pi / 4)  # returns 0.0</code></pre><p>Type conversions are automatically performed for numeric, boolean, string, IO stream, date/period, and function types, along with tuples, arrays/lists, and dictionaries of these types. (Python functions can be converted/passed to Julia functions and vice versa!)  Other types are supported via the generic PyObject type, below.</p><p>Python submodules must be imported by a separate <code>@pyimport</code> call, and in this case you must supply an identifier to to use in Julia.  For example</p><pre><code class="language-none">@pyimport numpy.random as nr
nr.rand(3,4)</code></pre><p>Multidimensional arrays exploit the NumPy array interface for conversions between Python and Julia.  By default, they are passed from Julia to Python without making a copy, but from Python to Julia a copy is made; no-copy conversion of Python to Julia arrays can be achieved with the <code>PyArray</code> type below.</p><p>Keyword arguments can also be passed. For example, matplotlib&#39;s <a href="http://matplotlib.org/">pyplot</a> uses keyword arguments to specify plot options, and this functionality is accessed from Julia by:</p><pre><code class="language-none">@pyimport matplotlib.pyplot as plt
x = linspace(0,2*pi,1000); y = sin(3*x + 4*cos(2*x));
plt.plot(x, y, color=&quot;red&quot;, linewidth=2.0, linestyle=&quot;--&quot;)
plt.show()</code></pre><p>However, for better integration with Julia graphics backends and to avoid the need for the <code>show</code> function, we recommend using matplotlib via the Julia <a href="https://github.com/stevengj/PyPlot.jl">PyPlot module</a>.</p><p>Arbitrary Julia functions can be passed to Python routines taking function arguments.  For example, to find the root of cos(x) - x, we could call the Newton solver in scipy.optimize via:</p><pre><code class="language-none">@pyimport scipy.optimize as so
so.newton(x -&gt; cos(x) - x, 1)</code></pre><p>A macro exists for mimicking Python&#39;s &quot;with statement&quot;. For example:</p><pre><code class="language-none">@pywith pybuiltin(&quot;open&quot;)(&quot;file.txt&quot;,&quot;w&quot;) as f begin
    f[:write](&quot;hello&quot;)
end</code></pre><p>The type of <code>f</code> can be specified with <code>f::T</code> (for example, to override automatic conversion, use <code>f::PyObject</code>). Similarly, if the context manager returns a type which is automatically converted to a Julia type, you will have override this via <code>@pywith EXPR::PyObject ...</code>.</p><p><strong>Important:</strong> The biggest difference from Python is that object attributes/members are accessed with <code>o[:attribute]</code> rather than <code>o.attribute</code>, so that <code>o.method(...)</code> in Python is replaced by <code>o[:method](...)</code> in Julia.  Also, you use <code>get(o, key)</code> rather than <code>o[key]</code>.  (However, you can access integer indices via <code>o[i]</code> as in Python, albeit with 1-based Julian indices rather than 0-based Python indices.)  (This is because Julia does not permit overloading the <code>.</code> operator yet.)  See also the section on <code>PyObject</code> below, as well as the <code>pywrap</code> function to create anonymous modules that simulate <code>.</code> access (this is what <code>@pyimport</code> does).  For example, using <a href="http://biopython.org/wiki/Seq">Biopython</a> we can do:</p><pre><code class="language-none">@pyimport Bio.Seq as s
@pyimport Bio.Alphabet as a
my_dna = s.Seq(&quot;AGTACACTGGT&quot;, a.generic_dna)
my_dna[:find](&quot;ACT&quot;)</code></pre><p>whereas in Python the last step would have been <code>my_dna.find(&quot;ACT&quot;)</code>.</p><h2><a class="nav-anchor" id="Troubleshooting-1" href="#Troubleshooting-1">Troubleshooting</a></h2><p>Here are solutions to some common problems:</p><ul><li>As mentioned above, use <code>foo[:bar]</code> and <code>foo[:bar](...)</code> rather than <code>foo.bar</code> and <code>foo.bar(...)</code>,</li></ul><p>respectively, to access attributes and methods of Python objects.</p><ul><li>By default, PyCall <a href="https://github.com/stevengj/PyCall.jl/issues/48">doesn&#39;t include the current directory in the Python search path</a>.   If you want to do that (in order to load a Python module from the current directory), just run <code>pushfirst!(PyVector(pyimport(&quot;sys&quot;)[&quot;path&quot;]), &quot;&quot;)</code>.</li></ul><h2><a class="nav-anchor" id="Python-object-interfaces-1" href="#Python-object-interfaces-1">Python object interfaces</a></h2><p>The <code>@pyimport</code> macro is built on top of several routines for manipulating Python objects in Julia, via a type <code>PyObject</code> described below.  These can be used to have greater control over the types and data passed between Julia and Python, as well as to access additional Python functionality (especially in conjunction with the low-level interfaces described later).</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><h4><a class="nav-anchor" id="PyObject-1" href="#PyObject-1">PyObject</a></h4><p>The PyCall module also provides a new type <code>PyObject</code> (a wrapper around <code>PyObject*</code> in Python&#39;s C API) representing a reference to a Python object.</p><p>Constructors <code>PyObject(o)</code> are provided for a number of Julia types, and PyCall also supplies <code>convert(T, o::PyObject)</code> to convert PyObjects back into Julia types <code>T</code>.  Currently, the types supported are numbers (integer, real, and complex), booleans, strings, IO streams, dates/periods, and functions, along with tuples and arrays/lists thereof, but more are planned.  (Julia symbols are converted to Python strings.)</p><p>Given <code>o::PyObject</code>, <code>o[:attribute]</code> is equivalent to <code>o.attribute</code> in Python, with automatic type conversion.  To get an attribute as a <code>PyObject</code> without type conversion, do <code>o[&quot;attribute&quot;]</code> instead. The <code>keys(o::PyObject)</code> function returns an array of the available attribute symbols.</p><p>Given <code>o::PyObject</code>, <code>get(o, key)</code> is equivalent to <code>o[key]</code> in Python, with automatic type conversion.  To get as a <code>PyObject</code> without type conversion, do <code>get(o, PyObject, key)</code>, or more generally <code>get(o, SomeType, key)</code>.  You can also supply a default value to use if the key is not found by <code>get(o, key, default)</code> or <code>get(o, SomeType, key, default)</code>.  Similarly, <code>set!(o, key, val)</code> is equivalent to <code>o[key] = val</code> in Python, and <code>delete!(o, key)</code> is equivalent to <code>del o[key]</code> in Python.   For one or more <em>integer</em> indices, <code>o[i]</code> in Julia is equivalent to <code>o[i-1]</code> in Python.</p><p>You can call an <code>o::PyObject</code> via <code>o(args...)</code> just like in Python (assuming that the object is callable in Python).  The explicit <code>pycall</code> form is still useful in Julia if you want to specify the return type.</p><p><code>pystr(o)</code> and <code>pyrepr(o)</code> are analogous to <code>str</code> and <code>repr</code> in Python, respectively.</p><h4><a class="nav-anchor" id="Arrays-and-PyArray-1" href="#Arrays-and-PyArray-1">Arrays and PyArray</a></h4><h5><a class="nav-anchor" id="From-Julia-to-Python-1" href="#From-Julia-to-Python-1">From Julia to Python</a></h5><p>Assuming you have NumPy installed (true by default if you use Conda), then a Julia <code>a::Array</code> of NumPy-compatible elements is converted by <code>PyObject(a)</code> into a NumPy wrapper for the <em>same data</em>, i.e. without copying the data.  Julia arrays are stored in <a href="https://en.wikipedia.org/wiki/Row-major_order">column-major order</a>, and since NumPy supports column-major arrays this is not a problem.</p><p>However, the <em>default</em> ordering of NumPy arrays created in <em>Python</em> is row-major, and some Python packages will throw an error if you try to pass them column-major NumPy arrays.  To deal with this, you can use <code>PyReverseDims(a)</code> to pass a Julia array as a row-major NumPy array with the dimensions <em>reversed</em>. For example, if <code>a</code> is a 3x4x5 Julia array, then <code>PyReverseDims(a)</code> passes it as a 5x4x3 NumPy row-major array (without making a copy of the underlying data).</p><p>A <code>Vector{UInt8}</code> object in Julia, by default, is converted to a Python <code>bytearray</code> object.   If you want a <code>bytes</code> object instead, you can use the function <code>pybytes(a)</code>.</p><h5><a class="nav-anchor" id="From-Python-to-Julia-1" href="#From-Python-to-Julia-1">From Python to Julia</a></h5><p>Multidimensional NumPy arrays (<code>ndarray</code>) are supported and can be converted to the native Julia <code>Array</code> type, which makes a copy of the data.</p><p>Alternatively, the PyCall module also provides a new type <code>PyArray</code> (a subclass of <code>AbstractArray</code>) which implements a no-copy wrapper around a NumPy array (currently of numeric types or objects only).  Just use <code>PyArray</code> as the return type of a <code>pycall</code> returning an <code>ndarray</code>, or call <code>PyArray(o::PyObject)</code> on an <code>ndarray</code> object <code>o</code>.  (Technically, a <code>PyArray</code> works for any Python object that uses the NumPy array interface to provide a data pointer and shape information.)</p><p>Conversely, when passing arrays <em>to</em> Python, Julia <code>Array</code> types are converted to <code>PyObject</code> types <em>without</em> making a copy via NumPy, e.g. when passed as <code>pycall</code> arguments.</p><h4><a class="nav-anchor" id="PyVector-1" href="#PyVector-1">PyVector</a></h4><p>The PyCall module provides a new type <code>PyVector</code> (a subclass of <code>AbstractVector</code>) which implements a no-copy wrapper around an arbitrary Python list or sequence object.  (Unlike <code>PyArray</code>, the <code>PyVector</code> type is not limited to <code>NumPy</code> arrays, although using <code>PyArray</code> for the latter is generally more efficient.)  Just use <code>PyVector</code> as the return type of a <code>pycall</code> returning a list or sequence object (including tuples), or call <code>PyVector(o::PyObject)</code> on a sequence object <code>o</code>.</p><p>A <code>v::PyVector</code> supports the usual <code>v[index]</code> referencing and assignment, along with <code>delete!</code> and <code>pop!</code> operations.  <code>copy(v)</code> converts <code>v</code> to an ordinary Julia <code>Vector</code>.</p><h4><a class="nav-anchor" id="PyDict-1" href="#PyDict-1">PyDict</a></h4><p>Similar to <code>PyVector</code>, PyCall also provides a type <code>PyDict</code> (a subclass of <code>Association</code>) that implements a no-copy wrapper around a Python dictionary (or any object implementing the mapping protocol).  Just use <code>PyDict</code> as the return type of a <code>pycall</code> returning a dictionary, or call <code>PyDict(o::PyObject)</code> on a dictionary object <code>o</code>.  By default, a <code>PyDict</code> is an <code>Any =&gt; Any</code> dictionary (or actually <code>PyAny =&gt; PyAny</code>) that performs runtime type inference, but if your Python dictionary has known, fixed types you can insteady use <code>PyDict{K,V}</code> given the key and value types <code>K</code> and <code>V</code> respectively.</p><p>Currently, passing Julia dictionaries to Python makes a copy of the Julia dictionary.</p><h4><a class="nav-anchor" id="PyTextIO-1" href="#PyTextIO-1">PyTextIO</a></h4><p>Julia <code>IO</code> streams are converted into Python objects implementing the <a href="http://docs.python.org/2/library/io.html#io.RawIOBase">RawIOBase</a> interface, so they can be used for binary I/O in Python.  However, some Python code (notably unpickling) expects a stream implementing the <a href="http://docs.python.org/2/library/io.html#io.TextIOBase">TextIOBase</a> interface, which differs from RawIOBase mainly in that <code>read</code> an <code>readall</code> functions return strings rather than byte arrays.  If you need to pass an <code>IO</code> stream as a text-IO object, just call <code>PyTextIO(io::IO)</code> to convert it.</p><p>(There doesn&#39;t seem to be any good way to determine automatically whether Python wants a stream argument to return strings or binary data.  Also, unlike Python, Julia does not open files separately in &quot;text&quot; or &quot;binary&quot; modes, so we cannot determine the conversion simply from how the file was opened.)</p><h4><a class="nav-anchor" id="PyAny-1" href="#PyAny-1">PyAny</a></h4><p>The <code>PyAny</code> type is used in conversions to tell PyCall to detect the Python type at runtime and convert to the corresponding native Julia type.  That is, <code>pycall(func, PyAny, ...)</code> and <code>convert(PyAny, o::PyObject)</code> both automatically convert their result to a native Julia type (if possible).   This is convenient, but will lead to slightly worse performance (due to the overhead of runtime type-checking and the fact that the Julia JIT compiler can no longer infer the type).</p><h3><a class="nav-anchor" id="Calling-Python-1" href="#Calling-Python-1">Calling Python</a></h3><p>In most cases, the <code>@pyimport</code> macro automatically makes the appropriate type conversions to Julia types based on runtime inspection of the Python objects.  However greater control over these type conversions (e.g. to use a no-copy <code>PyArray</code> for a Python multidimensional array rather than copying to an <code>Array</code>) can be achieved by using the lower-level functions below.  Using <code>pycall</code> in cases where the Python return type is known can also improve performance, both by eliminating the overhead of runtime type inference and also by providing more type information to the Julia compiler.</p><ul><li><p><code>pycall(function::PyObject, returntype::Type, args...)</code>.   Call the given Python <code>function</code> (typically looked up from a module) with the given <code>args...</code> (of standard Julia types which are converted automatically to the corresponding Python types if possible), converting the return value to <code>returntype</code> (use a <code>returntype</code> of <code>PyObject</code> to return the unconverted Python object reference, or of <code>PyAny</code> to request an automated conversion). For convenience, a macro <code>@pycall</code> exists which automatically converts <code>@pycall function(args...)::returntype</code> into <code>pycall(function,returntype,args...)</code>.</p></li><li><p><code>pyimport(s)</code>: Import the Python module <code>s</code> (a string or symbol) and return a pointer to it (a <code>PyObject</code>).  Functions or other symbols in the module may then be looked up by <code>s[name]</code> where <code>name</code> is a string (for the raw <code>PyObject</code>) or symbol (for automatic type-conversion).  Unlike the <code>@pyimport</code> macro, this does not define a Julia module and members cannot be accessed with <code>s.name</code>.</p></li><li><p><code>py&quot;...&quot;</code> evaluates <code>&quot;...&quot;</code> as a Python string, equivalent to Python&#39;s <a href="https://docs.python.org/2/library/functions.html#eval"><code>eval</code></a> function, and returns the result converted to <code>PyAny</code>.  Alternatively, <code>py&quot;...&quot;o</code> returns the raw <code>PyObject</code> (which can then be manually converted if desired).   You can interpolate Julia variables and other expressions into the Python code with <code>$</code>, which interpolates the <em>value</em> (converted to <code>PyObject</code>) of the given expressionâ-data is not passed as a string, so this is different from ordinary Julia string interpolation.  e.g. <code>py&quot;sum($([1,2,3]))&quot;</code> calls the Python <code>sum</code> function on the Julia array <code>[1,2,3]</code>, returning <code>6</code>. In contrast, if you use <code>$$</code> before the interpolated expression, then the value of the expression is inserted as a string into the Python code, allowing you to generate Python code itself via Julia expressions. For example, if <code>x=&quot;1+1&quot;</code> in Julia, then <code>py&quot;$x&quot;</code> returns the string <code>&quot;1+1&quot;</code>, but <code>py&quot;$$x&quot;</code> returns <code>2</code>. If you use <code>py&quot;&quot;&quot;...&quot;&quot;&quot;</code> to pass a <em>multi-line</em> string, the string can contain arbitrary Python code (not just a single expression) to be evaluated, but the return value is <code>nothing</code>; this is useful e.g. to define pure-Python functions, and is equivalent to Python&#39;s <a href="https://docs.python.org/2/reference/simple_stmts.html#exec"><code>exec</code></a> statement.  (If you define a Python global <code>g</code> in a multiline <code>py&quot;&quot;&quot;...&quot;&quot;&quot;</code> string, you can retrieve it in Julia by subsequently evaluating <code>py&quot;g&quot;</code>.)</p></li><li><p><code>pybuiltin(s)</code>: Look up <code>s</code> (a string or symbol) among the global Python builtins.  If <code>s</code> is a string it returns a <code>PyObject</code>, while if <code>s</code> is a symbol it returns the builtin converted to <code>PyAny</code>.  (You can also use <code>py&quot;s&quot;</code> to look up builtins or other Python globas.)</p></li><li><p><code>pywrap(o::PyObject)</code> returns a wrapper <code>w</code> that is an anonymous module which provides (read) access to converted versions of <code>o</code>&#39;s members as <code>w.member</code>.  (For example, <code>@pyimport module as name</code> is equivalent to <code>name = pywrap(pyimport(&quot;module&quot;))</code>.)  If the Python module contains identifiers that are reserved words in Julia (e.g. <code>function</code>), they cannot be accessed as <code>w.member</code>; one must instead use <code>w.pymember(:member)</code> (for the <code>PyAny</code> conversion) or <code>w.pymember(&quot;member&quot;)</code> (for the raw <code>PyObject</code>).  <code>pywrap</code> is rather inefficient since it converts <em>every</em> member of <code>o</code> at once; you are generally encouraged to simply access members via <code>o[:member]</code> rather than using <code>pywrap</code>.</p></li></ul><p>Occasionally, you may need to pass a keyword argument to Python that is a <a href="https://en.wikipedia.org/wiki/Reserved_word">reserved word</a> in Julia. For example, calling <code>f(x, function=g)</code> will fail because <code>function</code> is a reserved word in Julia. In such cases, you can use the lower-level Julia syntax <code>f(x; :function=&gt;g)</code>.</p><h3><a class="nav-anchor" id="Calling-Julia-from-Python-1" href="#Calling-Julia-from-Python-1">Calling Julia from Python</a></h3><p>Julia functions get converted to callable Python objects, so you can easily call Julia from Python via callback function arguments. The <a href="https://github.com/JuliaPy/pyjulia">pyjulia module</a> allows you to call Julia directly from Python, and also uses PyCall to do its conversions.</p><p>A Julia function <code>f(args...)</code> is ordinarily converted to a callable Python object <code>p(args...)</code> that first converts its Python arguments into Julia arguments by the default <code>PyAny</code> conversion, calls <code>f</code>, then converts the Julia return value of <code>f</code> back into a Python object with the default <code>PyObject(...)</code> conversion.    However, you can exert lower-level control over these argument/return conversions by calling <code>pyfunction(f, ...)</code> or <code>pyfunctionret(f, ...)</code>; see the documentation <code>?pyfunction</code> and <code>?pyfunctionret</code> for more information.</p><h3><a class="nav-anchor" id="Defining-Python-Classes-1" href="#Defining-Python-Classes-1">Defining Python Classes</a></h3><p><code>@pydef</code> creates a Python class whose methods are implemented in Julia. For instance,</p><pre><code class="language-none">@pyimport numpy.polynomial as P
@pydef mutable struct Doubler &lt;: P.Polynomial
    function __init__(self, x=10)
        self[:x] = x
    end
    my_method(self, arg1::Number) = arg1 + 20
    x2.get(self) = self[:x] * 2
    function x2.set!(self, new_val)
        self[:x] = new_val / 2
    end
end
Doubler()[:x2]</code></pre><p>is essentially equivalent to the following Python code:</p><pre><code class="language-none">import numpy.polynomial
class Doubler(numpy.polynomial.Polynomial):
    def __init__(self, x=10):
        self.x = x
    def my_method(self, arg1): return arg1 + 20
    @property
    def x2(self): return self.x * 2
    @x2.setter
    def x2(self, new_val):
        self.x = new_val / 2
Doubler().x2</code></pre><p>The method arguments and return values are automatically converted between Julia and Python. All Python special methods are supported (<code>__len__</code>, <code>__add__</code>, etc.).</p><p><code>@pydef</code> allows for multiple inheritance of Python classes:</p><pre><code class="language-none">@pydef mutable struct SomeType &lt;: (BaseClass1, BaseClass2)
    ...
end</code></pre><p>Here&#39;s another example using <a href="https://wiki.python.org/moin/TkInter">Tkinter</a>:</p><pre><code class="language-none">using PyCall
@pyimport Tkinter as tk

@pydef mutable struct SampleApp &lt;: tk.Tk
    __init__(self, args...; kwargs...) = begin
        tk.Tk[:__init__](self, args...; kwargs...)
        self[:label] = tk.Label(text=&quot;Hello, world!&quot;)
        self[:label][:pack](padx=10, pady=10)
    end
end

app = SampleApp()
app[:mainloop]()</code></pre><h3><a class="nav-anchor" id="GUI-Event-Loops-1" href="#GUI-Event-Loops-1">GUI Event Loops</a></h3><p>For Python packages that have a graphical user interface (GUI), notably plotting packages like matplotlib (or MayaVi or Chaco), it is convenient to start the GUI event loop (which processes things like mouse clicks) as an asynchronous task within Julia, so that the GUI is responsive without blocking Julia&#39;s input prompt.  PyCall includes functions to implement these event loops for some of the most common cross-platform <a href="http://en.wikipedia.org/wiki/Widget_toolkit">GUI toolkits</a>: <a href="http://www.wxwidgets.org/">wxWidgets</a>, <a href="http://www.gtk.org/">GTK+</a> version 2 (via <a href="http://www.pygtk.org/">PyGTK</a>) or version 3 (via <a href="https://pygobject.readthedocs.io/en/latest/">PyGObject</a>), and <a href="http://qt-project.org/">Qt</a> (via the <a href="http://wiki.python.org/moin/PyQt4">PyQt4</a> or <a href="http://qt-project.org/wiki/PySide">PySide</a> Python modules).</p><p>You can set a GUI event loop via:</p><ul><li><p><code>pygui_start(gui::Symbol=pygui())</code>.  Here, <code>gui</code> is either <code>:wx</code>, <code>:gtk</code>, <code>:gtk3</code>, <code>:tk</code>, or <code>:qt</code> to start the respective toolkit&#39;s event loop.  (<code>:qt</code> will use PyQt4 or PySide, preferring the former; if you need to require one or the other you can instead use <code>:qt_pyqt4</code> or <code>:qt_pyside</code>, respectively.) It defaults to the return value of <code>pygui()</code>, which returns a current default GUI (see below).  Passing a <code>gui</code> argument also changes the default GUI, equivalent to calling <code>pygui(gui)</code> below.  You may start event loops for more than one GUI toolkit (to run simultaneously).  Calling <code>pygui_start</code> more than once for a given toolkit does nothing (except to change the current <code>pygui</code> default).</p></li><li><p><code>pygui()</code>: return the current default GUI toolkit (<code>Symbol</code>).  If the default GUI has not been set already, this is the first of <code>:tk</code>, <code>:qt</code>, <code>:wx</code>, <code>:gtk</code>, or <code>:gtk3</code> for which the corresponding Python package is installed.  <code>pygui(gui::Symbol)</code> changes the default GUI to <code>gui</code>.</p></li><li><p><code>pygui_stop(gui::Symbol=pygui())</code>: Stop any running event loop for <code>gui</code> (which defaults to the current return value of <code>pygui</code>).  Returns <code>true</code> if an event loop was running, and <code>false</code> otherwise.</p></li></ul><p>To use these GUI facilities with some Python libraries, it is enough to simply start the appropriate toolkit&#39;s event-loop before importing the library.  However, in other cases it is necessary to explicitly tell the library which GUI toolkit to use and that an interactive mode is desired.  To make this even easier, it is convenient to have wrapper modules around popular Python libraries, such as the <a href="https://github.com/stevengj/PyPlot.jl">PyPlot module</a> for Julia.</p><h3><a class="nav-anchor" id="Low-level-Python-API-access-1" href="#Low-level-Python-API-access-1">Low-level Python API access</a></h3><p>If you want to call low-level functions in the Python C API, you can do so using <code>ccall</code>.</p><ul><li><p>Use <code>@pysym(func::Symbol)</code> to get a function pointer to pass to <code>ccall</code> given a symbol <code>func</code> in the Python API.  e.g. you can call <code>int Py_IsInitialized()</code> by <code>ccall(@pysym(:Py_IsInitialized), Int32, ())</code>.</p></li><li><p>PyCall defines the typealias <code>PyPtr</code> for <code>PythonObject*</code> argument types, and <code>PythonObject</code> (see above) arguments are correctly converted to this type.  <code>PythonObject(p::PyPtr)</code> creates a Julia wrapper around a <code>PyPtr</code> return value.</p></li><li><p>Use <code>PyObject</code> and the <code>convert</code> routines mentioned above to convert Julia types to/from <code>PyObject*</code> references.</p></li><li><p>If a new reference is returned by a Python function, immediately convert the <code>PyPtr</code> return values to <code>PythonObject</code> objects in order to have their Python reference counts decremented when the object is garbage collected in Julia.  i.e. <code>PythonObject(ccall(func, PyPtr, ...))</code>. <strong>Important</strong>: for Python routines that return a borrowed reference, you should instead do <code>pyincref(PyObject(...))</code> to obtain a new reference.</p></li><li><p>You can call <code>pyincref(o::PyObject)</code> and <code>pydecref(o::PyObject)</code> to manually increment/decrement the reference count.  This is sometimes needed when low-level functions steal a reference or return a borrowed one.</p></li><li><p>The function <code>pyerr_check(msg::AbstractString)</code> can be used to check if a Python exception was thrown, and throw a Julia exception (which includes both <code>msg</code> and the Python exception object) if so.  The Python exception status may be cleared by calling <code>pyerr_clear()</code>.</p></li><li><p>The function <code>pytype_query(o::PyObject)</code> returns a native Julia type that <code>o</code> can be converted into, if possible, or <code>PyObject</code> if not.</p></li><li><p><code>pyisinstance(o::PyObject, t::Symbol)</code> can be used to query whether <code>o</code> is of a given Python type (where <code>t</code> is the identifier of a global <code>PyTypeObject</code> in the Python C API), e.g. <code>pyisinstance(o, :PyDict_Type)</code> checks whether <code>o</code> is a Python dictionary.  Alternatively, <code>pyisinstance(o::PyObject, t::PyObject)</code> performs the same check given a Python type object <code>t</code>.  <code>pytypeof(o::PyObject)</code> returns the Python type of <code>o</code>, equivalent to <code>type(o)</code> in Python.</p></li></ul><h3><a class="nav-anchor" id="Using-PyCall-from-Julia-Modules-1" href="#Using-PyCall-from-Julia-Modules-1">Using PyCall from Julia Modules</a></h3><p>You can use PyCall from any Julia code, including within Julia modules. However, some care is required when using PyCall from <a href="http://docs.julialang.org/en/latest/manual/modules/#module-initialization-and-precompilation">precompiled Julia modules</a>. The key thing to remember is that <em>all Python objects</em> (any <code>PyObject</code>) contain <em>pointers</em> to memory allocated by the Python runtime, and such pointers <em>cannot be saved</em> in precompiled constants.   (When a precompiled library is reloaded, these pointers will not contain valid memory addresses.)</p><p>The solution is fairly simple:</p><ul><li><p>Python objects that you create in functions called <em>after</em> the module is loaded are always safe.</p></li><li><p>If you want to store a Python object in a global variable that is initialized automatically when the module is loaded, then initialize the variable in your module&#39;s <code>__init__</code> function.  For a type-stable global constant, initialize the constant to <code>PyNULL()</code> at the top level, and then use the <code>copy!</code> function in your module&#39;s <code>__init__</code> function to mutate it to its actual value.</p></li></ul><p>For example, suppose your module uses the <code>scipy.optimize</code> module, and you want to load this module when your module is loaded and store it in a global constant <code>scipy_opt</code>.  You could do:</p><pre><code class="language-jl">__precompile__() # this module is safe to precompile
module MyModule
using PyCall

const scipy_opt = PyNULL()

function __init__()
    copy!(scipy_opt, pyimport_conda(&quot;scipy.optimize&quot;, &quot;scipy&quot;))
end

end</code></pre><p>Then you can access the <code>scipy.optimize</code> functions as <code>scipy_opt[:newton]</code> and so on.</p><p>Here, instead of <code>pyimport</code>, we have used the function <code>pyimport_conda</code>.   The second argument is the name of the <a href="https://docs.continuum.io/anaconda/pkg-docs">Anaconda package</a> that provides this module.   This way, if importing <code>scipy.optimize</code> fails because the user hasn&#39;t installed <code>scipy</code>, it will either (a) automatically install <code>scipy</code> and retry the <code>pyimport</code> if PyCall is configured to use the <a href="https://github.com/Luthaf/Conda.jl">Conda</a> Python install (or any other Anaconda-based Python distro for which the user has installation privileges), or (b) throw an error explaining that <code>scipy</code> needs to be installed, and explain how to configure PyCall to use Conda so that it can be installed automatically.   More generally, you can call <code>pyimport(module, package, channel)</code> to specify an optional Anaconda &quot;channel&quot; for installing non-standard Anaconda packages.</p><p>(Note that you cannot use <code>@pyimport</code> safely with precompilation, because that declares a global constant that internally has a pointer to the module.  You can use <code>pywrap(pyimport(...))</code> in your <code>__init__</code> function to a assign a global variable using the <code>.</code> notation like <code>@pyimport</code>, however, albeit without the type stability of the global <code>const</code> as above.)</p><h2><a class="nav-anchor" id="Author-1" href="#Author-1">Author</a></h2><p>This package was written by <a href="http://math.mit.edu/~stevenj/">Steven G. Johnson</a>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
