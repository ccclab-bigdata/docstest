<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2.0 Training Hyperparameters Â· BayesianIntegral</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BayesianIntegral</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">BayesianIntegral</a></li><li><a class="toctext" href="../1_bayesian_integration/">1.0 Bayesian Integration</a></li><li class="current"><a class="toctext" href>2.0 Training Hyperparameters</a><ul class="internal"><li><a class="toctext" href="#.1-Maximum-Likelihood-with-Stochastic-Gradient-Descent-1">2.1 Maximum Likelihood with Stochastic Gradient Descent</a></li><li><a class="toctext" href="#.2-RProp-1">2.2 RProp</a></li></ul></li><li><a class="toctext" href="../99_refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>2.0 Training Hyperparameters</a></li></ul></nav><hr/><div id="topbar"><span>2.0 Training Hyperparameters</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".0-Training-Hyperparameters-1" href="#.0-Training-Hyperparameters-1">2.0 Training Hyperparameters</a></h1><p>This package currently supports two ways of training hyperparameters. The first is Maximum likelihood with stochastic gradient descent while the second uses a momentum based algorithm to maximise likelihood (Blum and Riedmiller 2013).</p><h2><a class="nav-anchor" id=".1-Maximum-Likelihood-with-Stochastic-Gradient-Descent-1" href="#.1-Maximum-Likelihood-with-Stochastic-Gradient-Descent-1">2.1 Maximum Likelihood with Stochastic Gradient Descent</a></h2><p>This is done by the calibrate_by_ML_with_SGD function. The procedure is:</p><ul><li>Extract a sample of the requested size from the dataset. Sampling is done without replacement (or else the K matrix is singular and not invertible)</li><li>Find the likelihood of the dataset given the input hyperparameters. Also find the marginal likelihood (with respect to all hyperparameters) and use the Newtonian method to suggest another set of hyperparameters. The step to the new parameter set (as chosen by the Newtonian method) can be adjusted by the step_multiple parameter.</li></ul><p>This process continues for a user-specifiable number of iterates.</p><p>Note that using stochastic gradient descent is important here as the major time here is in inverting an <span>$N$</span>x<span>$N$</span> matrix which has a complexity of about <span>$O(N^{2.3})$</span>. Thus if only 10\% of observations are used in each iterate this makes the calibration more than 100 times faster than using all observations.</p><p>This function can be used in the following way:</p><pre><code class="language-none">old_cov_func_parameters = gaussian_kernel_hyperparameters(1.0, repeat([10.0] , outer = dims))
steps = 100                           # How many optimisation steps
batch_size = 5                        # Number of observations per sample
step_multiple = 1.0                   # How far to step
noise = 0.001                         # Noise parameter
seed = 2                              # Random number seed (for gathering random samples)
new_cov_func_parameters = calibrate_by_ML_with_SGD(X, y, cov_func_parameters, steps, batch_size, step_multiple, noise, seed)</code></pre><h2><a class="nav-anchor" id=".2-RProp-1" href="#.2-RProp-1">2.2 RProp</a></h2><p>This technique also maximises Maximum Likelihood. The main difference is that rather than taking Newtonian steps towards an maximum, the Rprop algorithm ignores the magnitude of the marginal likelihood and looks only at the sign. It moves a small distance uphill towards a higher likelihood. If the slope is still positive at this new point it will speed up and step by a greater amount in this direction. If the sign of the gradient ever changes it will slow down. It is thus a momentum based optimiser.</p><p>This is implemented with the calibrate_by_ML_with_Rprop function as below:</p><pre><code class="language-none">old_cov_func_parameters = gaussian_kernel_hyperparameters(1.0, repeat([10.0] , outer = dims))
params  = RProp_params(1.01,0.99,0.2,5.0,0.5)    # parameters for the RProp algorithm.
noise = 0.001                                    # Noise parameter
MaxIter = 2000                                   # Number of steps
new_cov_func_parameters = train_with_RProp(X, y, cov_func_parameters, MaxIter, noise, params)</code></pre><footer><hr/><a class="previous" href="../1_bayesian_integration/"><span class="direction">Previous</span><span class="title">1.0 Bayesian Integration</span></a><a class="next" href="../99_refs/"><span class="direction">Next</span><span class="title">References</span></a></footer></article></body></html>
