<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MLDataUtils.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLDataUtils.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">MLDataUtils.BalancedObs</code></pre><pre><code class="language-none">MLDataUtils.BatchView</code></pre><pre><code class="language-none">MLDataUtils.BufferGetObs</code></pre><pre><code class="language-none">MLDataUtils.DataSubset</code></pre><pre><code class="language-none">MLDataUtils.FeatureNormalizer</code></pre><pre><code class="language-none">MLDataUtils.FoldsView</code></pre><pre><code class="language-none">MLDataUtils.LabelEnc</code></pre><pre><code class="language-none">MLDataUtils.MLDataUtils</code></pre><pre><code class="language-none">MLDataUtils.ObsDim</code></pre><pre><code class="language-none">MLDataUtils.ObsView</code></pre><pre><code class="language-none">MLDataUtils.RandomBatches</code></pre><pre><code class="language-none">MLDataUtils.RandomObs</code></pre><pre><code class="language-none">MLDataUtils.SlidingWindow</code></pre><pre><code class="language-none">MLDataUtils._throw_table_error</code></pre><pre><code class="language-none">MLDataUtils.batchsize</code></pre><pre><code class="language-none">MLDataUtils.batchview</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.center!" href="#MLDataUtils.center!"><code>MLDataUtils.center!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">μ = center!(X[, μ, obsdim])</code></pre><p>or</p><pre><code class="language-none">μ = center!(D[, colnames, μ])</code></pre><p>where <code>X</code> is of type Matrix or Vector and <code>D</code> of type DataFrame.</p><p>Center <code>X</code> along <code>obsdim</code> around the corresponding entry in the vector <code>μ</code>. If <code>μ</code> is not specified then it defaults to the feature specific means.</p><p>For DataFrames, <code>obsdim</code> is obsolete and centering is done column wise. Instead the vector <code>colnames</code> allows to specify which columns to center. If <code>colnames</code> is not provided all columns of type T&lt;:Real are centered.</p><p>Example:</p><pre><code class="language-none">X = rand(4, 100)
D = DataFrame(A=rand(10), B=collect(1:10), C=[string(x) for x in 1:10])

μ = center!(X, obsdim=2)
μ = center!(X, ObsDim.First())
μ = center!(D)
μ = center!(D, [:A, :B])</code></pre></div></div></section><pre><code class="language-none">MLDataUtils.classify</code></pre><pre><code class="language-none">MLDataUtils.classify!</code></pre><pre><code class="language-none">MLDataUtils.convertlabel</code></pre><pre><code class="language-none">MLDataUtils.convertlabelview</code></pre><pre><code class="language-none">MLDataUtils.datasubset</code></pre><pre><code class="language-none">MLDataUtils.downsample</code></pre><pre><code class="language-none">MLDataUtils.eachbatch</code></pre><pre><code class="language-none">MLDataUtils.eachobs</code></pre><pre><code class="language-none">MLDataUtils.eachtarget</code></pre><pre><code class="language-none">MLDataUtils.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.expand_poly" href="#MLDataUtils.expand_poly"><code>MLDataUtils.expand_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>X = DataUtils.expand_poly(x; degree = 5)</code></p><p>Performs a polynomial basis expansion of the given <code>degree</code> for the vector <code>x</code>. The return value <code>X</code> is a matrix of size <code>(degree, length(x))</code>.</p><p>Note: all the features of <code>X</code> are centered and rescaled.</p></div></div></section><pre><code class="language-none">MLDataUtils.fit</code></pre><pre><code class="language-none">MLDataUtils.getobs</code></pre><pre><code class="language-none">MLDataUtils.getobs!</code></pre><pre><code class="language-none">MLDataUtils.include</code></pre><pre><code class="language-none">MLDataUtils.ind2label</code></pre><pre><code class="language-none">MLDataUtils.islabelenc</code></pre><pre><code class="language-none">MLDataUtils.isneglabel</code></pre><pre><code class="language-none">MLDataUtils.isposlabel</code></pre><pre><code class="language-none">MLDataUtils.kfolds</code></pre><pre><code class="language-none">MLDataUtils.label</code></pre><pre><code class="language-none">MLDataUtils.label2ind</code></pre><pre><code class="language-none">MLDataUtils.labelenc</code></pre><pre><code class="language-none">MLDataUtils.labelfreq</code></pre><pre><code class="language-none">MLDataUtils.labelfreq!</code></pre><pre><code class="language-none">MLDataUtils.labelmap</code></pre><pre><code class="language-none">MLDataUtils.labelmap!</code></pre><pre><code class="language-none">MLDataUtils.labelmap2vec</code></pre><pre><code class="language-none">MLDataUtils.labeltype</code></pre><pre><code class="language-none">MLDataUtils.leaveout</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.load_iris" href="#MLDataUtils.load_iris"><code>MLDataUtils.load_iris</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>X, y, vars = load_iris(n)</code></p><p>Loads the first <code>n</code> (of 150) observations from the Iris flower data set introduced by Ronald Fisher (1936). The 4 by <code>n</code> matrix <code>X</code> contains the numeric measurements, in which each individual column denotes an observation. The vector <code>y</code> contains the class labels as strings. The optional vector <code>vars</code> contains the names of the features (i.e. rows of <code>X</code>)</p><p>[1] Fisher, Ronald A. &quot;The use of multiple measurements in taxonomic problems.&quot; Annals of eugenics 7.2 (1936): 179-188.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.load_line" href="#MLDataUtils.load_line"><code>MLDataUtils.load_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y, vars = load_line()</code></p><p>Loads an artificial example dataset for a noisy line. It is particularly useful to explain under- and overfitting. The vector <code>x</code> contains 11 equally spaced points between 0 and 1 The vector <code>y</code> contains <code>x ./ 2 + 1</code> plus some gaussian noise The optional vector <code>vars</code> contains descriptive names for <code>x</code> and <code>y</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.load_poly" href="#MLDataUtils.load_poly"><code>MLDataUtils.load_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y, vars = load_poly()</code></p><p>Loads an artificial example dataset for a noisy quadratic function. It is particularly useful to explain under- and overfitting. The vector <code>x</code> contains 50 points between 0 and 4 The vector <code>y</code> contains <code>2.6 * x^2 + .8 * x</code> plus some gaussian noise The optional vector <code>vars</code> contains descriptive names for <code>x</code> and <code>y</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.load_sin" href="#MLDataUtils.load_sin"><code>MLDataUtils.load_sin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y, vars = load_sin()</code></p><p>Loads an artificial example dataset for a noisy sin. It is particularly useful to explain under- and overfitting. The vector <code>x</code> contains equally spaced points between 0 and 2π The vector <code>y</code> contains <code>sin(x)</code> plus some gaussian noise The optional vector <code>vars</code> contains descriptive names for <code>x</code> and <code>y</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.load_spiral" href="#MLDataUtils.load_spiral"><code>MLDataUtils.load_spiral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>x, y, vars = load_spiral()`</p><p>Loads an artificial example dataset for a noisy spiral function. It is particularly useful to explain representation learning and nonlinearity. The matrix <code>x</code> contains 194 points between 0 and 6.5 lying on the spiral. The vector <code>y</code> contains the corresponding labels, i.e &quot;ones&quot; or &quot;zeros&quot;. The optional vector <code>vars</code> contains descriptive names for <code>x</code> and <code>y</code></p></div></div></section><pre><code class="language-none">MLDataUtils.neglabel</code></pre><pre><code class="language-none">MLDataUtils.nlabel</code></pre><pre><code class="language-none">MLDataUtils.nobs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.noisy_function" href="#MLDataUtils.noisy_function"><code>MLDataUtils.noisy_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y = noisy_function(fun, x; noise = 0.01, f_rand = randn)</code></p><p>Generates a noisy response <code>y</code> for the given function <code>fun</code> by adding <code>noise .* f_randn(length(x))</code> to the result of <code>fun(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.noisy_poly" href="#MLDataUtils.noisy_poly"><code>MLDataUtils.noisy_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y = noisy_poly(coef, x; noise = 0.01, f_rand = randn)</code></p><p>Generates a noisy response for a polynomial of degree <code>length(coef)</code> using the vector <code>x</code> as input and adding <code>noise .* f_randn(length(x))</code> to the result. The vector <code>coef</code> contains the coefficients for the terms of the polynome. The first element of <code>coef</code> denotes the coefficient for the term with the highest degree, while the last element of <code>coef</code> denotes the intercept.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.noisy_sin" href="#MLDataUtils.noisy_sin"><code>MLDataUtils.noisy_sin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y = noisy_sin(n, start, stop; noise = 0.3, f_rand = randn)</code></p><p>Generates <code>n</code> noisy equally spaces samples of a sinus from <code>start</code> to <code>stop</code> by adding <code>noise .* f_randn(length(x))</code> to the result of <code>fun(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.noisy_spiral" href="#MLDataUtils.noisy_spiral"><code>MLDataUtils.noisy_spiral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>x, y = noisy_spiral(n, a, theta, b; noise = 0.01, f_rand = randn)</code></p><p>Generates <code>n</code> noisy responses for a spiral with two labels. Uses the radius, angle and scaling arguments to space the points in 2D space and adding <code>noise .* f_randn(n)</code> to the response.</p></div></div></section><pre><code class="language-none">MLDataUtils.obsview</code></pre><pre><code class="language-none">MLDataUtils.oversample</code></pre><pre><code class="language-none">MLDataUtils.poslabel</code></pre><pre><code class="language-none">MLDataUtils.predict</code></pre><pre><code class="language-none">MLDataUtils.predict!</code></pre><pre><code class="language-none">MLDataUtils.randobs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataUtils.rescale!" href="#MLDataUtils.rescale!"><code>MLDataUtils.rescale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">μ, σ = rescale!(X[, μ, σ, obsdim])</code></pre><p>or</p><pre><code class="language-none">μ, σ = rescale!(D[, colnames, μ, σ])</code></pre><p>where <code>X</code> is of type Matrix or Vector and <code>D</code> of type DataFrame.</p><p>Center <code>X</code> along <code>obsdim</code> around the corresponding entry in the vector <code>μ</code> and then rescale each feature using the corresponding entry in the vector <code>σ</code>.</p><p>For DataFrames, <code>obsdim</code> is obsolete and centering is done column wise. The vector <code>colnames</code> allows to specify which columns to center. If <code>colnames</code> is not provided all columns of type T&lt;:Real are centered.</p><p>Example:</p><pre><code class="language-none">X = rand(4, 100)
D = DataFrame(A=rand(10), B=collect(1:10), C=[string(x) for x in 1:10])

μ, σ = rescale!(X, obsdim=2)
μ, σ = rescale!(X, ObsDim.First())
μ, σ = rescale!(D)
μ, σ = rescale!(D, [:A, :B])</code></pre></div></div></section><pre><code class="language-none">MLDataUtils.shuffleobs</code></pre><pre><code class="language-none">MLDataUtils.slidingwindow</code></pre><pre><code class="language-none">MLDataUtils.splitobs</code></pre><pre><code class="language-none">MLDataUtils.stratifiedobs</code></pre><pre><code class="language-none">MLDataUtils.targets</code></pre><pre><code class="language-none">MLDataUtils.undersample</code></pre><pre><code class="language-none">MLDataUtils.upsample</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
