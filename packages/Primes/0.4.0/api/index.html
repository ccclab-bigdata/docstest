<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Primes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Primes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Prime-factorization-1">Prime factorization</a></li><li><a class="toctext" href="#Generating-prime-numbers-1">Generating prime numbers</a></li><li><a class="toctext" href="#Identifying-prime-numbers-1">Identifying prime numbers</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Functions</a></li></ul></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Prime-number-functions-1" href="#Prime-number-functions-1">Prime number functions</a></h1><h2><a class="nav-anchor" id="Prime-factorization-1" href="#Prime-factorization-1">Prime factorization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.factor" href="#Primes.factor"><code>Primes.factor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">factor(n::Integer) -&gt; Primes.Factorization</code></pre><p>Compute the prime factorization of an integer <code>n</code>. The returned object, of type <code>Factorization</code>, is an associative container whose keys correspond to the factors, in sorted order. The value associated with each key indicates the multiplicity (i.e. the number of times the factor appears in the factorization).</p><pre><code class="language-julia">julia&gt; factor(100)
2^2 ⋅ 5^2</code></pre><p>For convenience, a negative number <code>n</code> is factored as <code>-1*(-n)</code> (i.e. <code>-1</code> is considered to be a factor), and <code>0</code> is factored as <code>0^1</code>:</p><pre><code class="language-julia">julia&gt; factor(-9)
-1 ⋅ 3^2

julia&gt; factor(0)
0

julia&gt; collect(factor(0))
1-element Array{Pair{Int64,Int64},1}:
 0=&gt;1</code></pre></div></div><div><div><pre><code class="language-none">factor(ContainerType, n::Integer) -&gt; ContainerType</code></pre><p>Return the factorization of <code>n</code> stored in a <code>ContainerType</code>, which must be a subtype of <code>AbstractDict</code> or <code>AbstractArray</code>, a <code>Set</code>, or an <code>BitSet</code>.</p><pre><code class="language-julia">julia&gt; factor(DataStructures.SortedDict, 100)
DataStructures.SortedDict{Int64,Int64,Base.Order.ForwardOrdering} with 2 entries:
  2 =&gt; 2
  5 =&gt; 2</code></pre><p>When <code>ContainerType &lt;: AbstractArray</code>, this returns the list of all prime factors of <code>n</code> with multiplicities, in sorted order.</p><pre><code class="language-julia">julia&gt; factor(Vector, 100)
4-element Array{Int64,1}:
 2
 2
 5
 5

julia&gt; prod(factor(Vector, 100)) == 100
true</code></pre><p>When <code>ContainerType == Set</code>, this returns the distinct prime factors as a set.</p><pre><code class="language-julia">julia&gt; factor(Set, 100)
Set([2,5])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.prodfactors" href="#Primes.prodfactors"><code>Primes.prodfactors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prodfactors(factors)</code></pre><p>Compute <code>n</code> (or the radical of <code>n</code> when <code>factors</code> is of type <code>Set</code> or <code>BitSet</code>) where <code>factors</code> is interpreted as the result of <code>factor(typeof(factors), n)</code>. Note that if <code>factors</code> is of type <code>AbstractArray</code> or <code>Primes.Factorization</code>, then <code>prodfactors</code> is equivalent to <code>Base.prod</code>.</p><pre><code class="language-julia-repl">julia&gt; prodfactors(factor(100))
100</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.radical" href="#Primes.radical"><code>Primes.radical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radical(n::Integer)</code></pre><p>Compute the radical of <code>n</code>, i.e. the largest square-free divisor of <code>n</code>. This is equal to the product of the distinct prime numbers dividing <code>n</code>.</p><pre><code class="language-julia-repl">julia&gt; radical(2*2*3)
6</code></pre></div></div></section><h2><a class="nav-anchor" id="Generating-prime-numbers-1" href="#Generating-prime-numbers-1">Generating prime numbers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.primes" href="#Primes.primes"><code>Primes.primes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primes([lo,] hi)</code></pre><p>Returns a collection of the prime numbers (from <code>lo</code>, if specified) up to <code>hi</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.nextprime" href="#Primes.nextprime"><code>Primes.nextprime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nextprime(n::Integer, i::Integer=1)</code></pre><p>The <code>i</code>-th smallest prime not less than <code>n</code> (in particular, <code>nextprime(p) == p</code> if <code>p</code> is prime). If <code>i &lt; 0</code>, this is equivalent to prevprime(n, -i). Note that for <code>n::BigInt</code>, the returned number is only a pseudo-prime (the function <a href="#Primes.isprime"><code>isprime</code></a> is used internally). See also <a href="#Primes.prevprime"><code>prevprime</code></a>.</p><pre><code class="language-julia-repl">julia&gt; nextprime(4)
5

julia&gt; nextprime(5)
5

julia&gt; nextprime(4, 2)
7

julia&gt; nextprime(5, 2)
7</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.prevprime" href="#Primes.prevprime"><code>Primes.prevprime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prevprime(n::Integer, i::Integer=1)</code></pre><p>The <code>i</code>-th largest prime not greater than <code>n</code> (in particular <code>prevprime(p) == p</code> if <code>p</code> is prime). If <code>i &lt; 0</code>, this is equivalent to <code>nextprime(n, -i)</code>. Note that for <code>n::BigInt</code>, the returned number is only a pseudo-prime (the function <a href="#Primes.isprime"><code>isprime</code></a> is used internally). See also <a href="#Primes.nextprime"><code>nextprime</code></a>.</p><pre><code class="language-julia-repl">julia&gt; prevprime(4)
3

julia&gt; prevprime(5)
5

julia&gt; prevprime(5, 2)
3</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.prime" href="#Primes.prime"><code>Primes.prime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prime(::Type{&lt;:Integer}=Int, i::Integer)</code></pre><p>The <code>i</code>-th prime number.</p><pre><code class="language-julia-repl">julia&gt; prime(1)
2

julia&gt; prime(3)
5
</code></pre></div></div></section><h2><a class="nav-anchor" id="Identifying-prime-numbers-1" href="#Identifying-prime-numbers-1">Identifying prime numbers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.isprime" href="#Primes.isprime"><code>Primes.isprime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isprime(n::Integer) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>n</code> is prime, and <code>false</code> otherwise.</p><pre><code class="language-julia">julia&gt; isprime(3)
true</code></pre></div></div><div><div><pre><code class="language-none">isprime(x::BigInt, [reps = 25]) -&gt; Bool</code></pre><p>Probabilistic primality test. Returns <code>true</code> if <code>x</code> is prime with high probability (pseudoprime); and <code>false</code> if <code>x</code> is composite (not prime). The false positive rate is about <code>0.25^reps</code>. <code>reps = 25</code> is considered safe for cryptographic applications (Knuth, Seminumerical Algorithms).</p><pre><code class="language-julia">julia&gt; isprime(big(3))
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.ismersenneprime" href="#Primes.ismersenneprime"><code>Primes.ismersenneprime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ismersenneprime(M::Integer; [check::Bool = true]) -&gt; Bool</code></pre><p>Lucas-Lehmer deterministic test for Mersenne primes. <code>M</code> must be a Mersenne number, i.e. of the form <code>M = 2^p - 1</code>, where <code>p</code> is a prime number. Use the keyword argument <code>check</code> to enable/disable checking whether <code>M</code> is a valid Mersenne number; to be used with caution. Return <code>true</code> if the given Mersenne number is prime, and <code>false</code> otherwise.</p><pre><code class="language-julia-repl">julia&gt; ismersenneprime(2^11 - 1)
false

julia&gt; ismersenneprime(2^13 - 1)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Primes.primesmask" href="#Primes.primesmask"><code>Primes.primesmask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primesmask([lo,] hi)</code></pre><p>Returns a prime sieve, as a <code>BitArray</code>, of the positive integers (from <code>lo</code>, if specified) up to <code>hi</code>. Useful when working with either primes or composite numbers.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
