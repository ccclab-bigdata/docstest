<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Reactive.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Reactive.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Reactive.CHANNEL_SIZE</code></pre><pre><code class="language-none">Reactive.MaybeMessage</code></pre><pre><code class="language-none">Reactive.Message</code></pre><pre><code class="language-none">Reactive.NullException</code></pre><pre><code class="language-none">Reactive.Reactive</code></pre><pre><code class="language-none">Reactive.Signal</code></pre><pre><code class="language-none">Reactive.__init__</code></pre><pre><code class="language-none">Reactive._active_binds</code></pre><pre><code class="language-none">Reactive._bindings</code></pre><pre><code class="language-none">Reactive._messages</code></pre><pre><code class="language-none">Reactive.activate!</code></pre><pre><code class="language-none">Reactive.add_action!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.async_map" href="#Reactive.async_map"><code>Reactive.async_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tasks, results = async_map(f, init, input...;typ=typeof(init), onerror=Reactive.print_error)</code></pre><p>Spawn a new task to run a function when input signal updates. Returns a signal of tasks and a <code>results</code> signal which updates asynchronously with the results. <code>init</code> will be used as the default value of <code>results</code>. <code>onerror</code> is the callback to be called when an error occurs, by default it is set to a callback which prints the error to stderr. It&#39;s the same as the <code>onerror</code> argument to <code>push!</code> but is run in the spawned task.</p></div></div></section><pre><code class="language-none">Reactive.async_mode</code></pre><pre><code class="language-none">Reactive.async_push!</code></pre><pre><code class="language-none">Reactive.auto_name!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.bind!" href="#Reactive.bind!"><code>Reactive.bind!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`bind!(dest, src, twoway=true; initial=true)`</code></pre><p>for every update to <code>src</code> also update <code>dest</code> with the same value and, if <code>twoway</code> is true, vice-versa. If <code>initial</code> is false, <code>dest</code> will only be updated to <code>src</code>&#39;s value when <code>src</code> next updates, otherwise (if <code>initial</code> is true) both <code>dest</code> and <code>src</code> will take <code>src</code>&#39;s value immediately.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.bindmap!" href="#Reactive.bindmap!"><code>Reactive.bindmap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`bindmap!(dest::Signal, src2dest::Function, src::Signal, dest2src=nothing; initial=true)`</code></pre><p>for every update to <code>src</code> also update <code>dest</code> with a modified value (using the function <code>src2dest</code>) and, if <code>dest2src</code> is specified, a two-way update will hold. If <code>initial</code> is false, <code>dest</code> will only be updated to <code>src</code>&#39;s modified value when <code>src</code> next updates, otherwise (if <code>initial</code> is true) both <code>dest</code> and <code>src</code> will take their respective modified values immediately.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.bound_dests" href="#Reactive.bound_dests"><code>Reactive.bound_dests</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bound_dests(src::Signal)</code> returns a vector of all signals that will update when <code>src</code> updates, that were bound using <code>bind!(dest, src)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.bound_srcs" href="#Reactive.bound_srcs"><code>Reactive.bound_srcs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bound_srcs(dest::Signal)</code> returns a vector of all signals that will cause an update to <code>dest</code> when they update, that were bound using <code>bind!(dest, src)</code></p></div></div></section><pre><code class="language-none">Reactive.break_loop</code></pre><pre><code class="language-none">Reactive.close</code></pre><pre><code class="language-none">Reactive.connect_delay</code></pre><pre><code class="language-none">Reactive.connect_droprepeats</code></pre><pre><code class="language-none">Reactive.connect_filter</code></pre><pre><code class="language-none">Reactive.connect_filterwhen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.connect_flatten" href="#Reactive.connect_flatten"><code>Reactive.connect_flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>connect_flatten(output, input)</code></p><p><code>output</code> is the flatten node, <code>input</code> is the Signal{Signal} (&quot;sigsig&quot;) node. The flatten needs to update on changes to the input sigsig, or changes to the value of the current sig (<code>current_node</code>). The former is achieved through a foreach <code>wire_flatten</code> attached to the input sigsig. The latter is achieved through binding the flatten to <code>current_node</code>.</p></div></div></section><pre><code class="language-none">Reactive.connect_foldp</code></pre><pre><code class="language-none">Reactive.connect_map</code></pre><pre><code class="language-none">Reactive.connect_merge</code></pre><pre><code class="language-none">Reactive.connect_previous</code></pre><pre><code class="language-none">Reactive.connect_sampleon</code></pre><pre><code class="language-none">Reactive.deactivate!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.debounce" href="#Reactive.debounce"><code>Reactive.debounce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">debounce(dt, input, f=(acc,x)-&gt;x, init=value(input), reinit=x-&gt;x;
            typ=typeof(init), name=auto_name!(string(&quot;debounce &quot;,dt,&quot;s&quot;), input))</code></pre><p>Creates a signal that will delay updating until <code>dt</code> seconds have passed since the last time <code>input</code> has updated. By default, the debounce signal holds the last update of the <code>input</code> signal since the debounce signal last updated.</p><p>This behavior can be changed by the <code>f</code>, <code>init</code> and <code>reinit</code> arguments. The <code>init</code> and <code>f</code> functions are similar to <code>init</code> and <code>f</code> in <code>foldp</code>. <code>reinit</code> is called after the debounce sends an update, to reinitialize the initial value for accumulation, it gets one argument, the previous accumulated value.</p><p>For example     <code>y = debounce(0.2, x, push!, Int[], _-&gt;Int[])</code> will accumulate a vector of updates to the integer signal <code>x</code> and push it after <code>x</code> is inactive (doesn&#39;t update) for 0.2 seconds.</p></div></div></section><pre><code class="language-none">Reactive.debug_memory</code></pre><pre><code class="language-none">Reactive.debug_mode</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.delay" href="#Reactive.delay"><code>Reactive.delay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delay(input, default=value(input))</code></pre><p>Schedule an update to happen after the current update propagates throughout the signal graph.</p><p>Returns the delayed signal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.droprepeats" href="#Reactive.droprepeats"><code>Reactive.droprepeats</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">droprepeats(input)</code></pre><p>Drop updates to <code>input</code> whenever the new value is the same as the previous value of the signal.</p></div></div></section><pre><code class="language-none">Reactive.edges</code></pre><pre><code class="language-none">Reactive.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.every" href="#Reactive.every"><code>Reactive.every</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">every(dt)</code></pre><p>A signal that updates every <code>dt</code> seconds to the current timestamp. Consider using <code>fpswhen</code> or <code>fps</code> if you want specify the timing signal by frequency, rather than delay.</p></div></div></section><pre><code class="language-none">Reactive.every_connect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter(f, default, signal)</code></pre><p>remove updates from the <code>signal</code> where <code>f</code> returns <code>false</code>. The filter will hold the value default until f(value(signal)) returns true, when it will be updated to value(signal).</p></div></div><div><div><pre><code class="language-none">filter(f, signal)</code></pre><p>remove updates from the <code>signal</code> where <code>f</code> returns <code>false</code>. The filter will hold the current value of the signal until <code>f(value(signal))</code> returns true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.filterwhen" href="#Reactive.filterwhen"><code>Reactive.filterwhen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filterwhen(switch::Signal{Bool}, default, input)</code></pre><p>Keep updates to <code>input</code> only when <code>switch</code> is true.</p><p>If switch is false initially, the specified default value is used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.flatten" href="#Reactive.flatten"><code>Reactive.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flatten(input::Signal{Signal}; typ=Any)</code></pre><p>Flatten a signal of signals into a signal which holds the value of the current signal. The <code>typ</code> keyword argument specifies the type of the flattened signal. It is <code>Any</code> by default.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.foldp" href="#Reactive.foldp"><code>Reactive.foldp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">foldp(f, init, inputs...)</code></pre><p><a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Fold</a> over past values.</p><p>Accumulate a value as the input signals change. <code>init</code> is the initial value of the accumulator. <code>f</code> should take <code>1 + length(inputs)</code> arguments: the first is the current accumulated value and the rest are the current input signal values. <code>f</code> will be called when one or more of the <code>inputs</code> updates. It should return the next accumulated value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.fps" href="#Reactive.fps"><code>Reactive.fps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fps(rate)</code></pre><p>Same as <code>fpswhen(Input(true), rate)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.fpswhen" href="#Reactive.fpswhen"><code>Reactive.fpswhen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fpswhen(switch, rate)</code></pre><p>returns a signal which when <code>switch</code> signal is true, updates <code>rate</code> times every second. If <code>rate</code> is not possible to attain because of slowness in computing dependent signal values, the signal will self adjust to provide the best possible rate.</p></div></div></section><pre><code class="language-none">Reactive.fpswhen_connect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.getlastactive" href="#Reactive.getlastactive"><code>Reactive.getlastactive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>getlastactive(merge_node)</code> Search backwards in nodes, and return the first active node that is one of merge_node&#39;s parents</p></div></div></section><pre><code class="language-none">Reactive.include</code></pre><pre><code class="language-none">Reactive.io_lock</code></pre><pre><code class="language-none">Reactive.isactive</code></pre><pre><code class="language-none">Reactive.isnull</code></pre><pre><code class="language-none">Reactive.log_gc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map(f, s::Signal...) -&gt; signal</code></pre><p>Transform signal <code>s</code> by applying <code>f</code> to each element. For multiple signal arguments, apply <code>f</code> elementwise.</p></div></div></section><pre><code class="language-none">Reactive.maybe_restart_queue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">merge(inputs...)</code></pre><p>Merge many signals into one. Returns a signal which updates when any of the inputs update. If many signals update at the same time, the value of the <em>youngest</em> (most recently created) input signal is taken.</p></div></div></section><pre><code class="language-none">Reactive.node_count</code></pre><pre><code class="language-none">Reactive.nodes</code></pre><pre><code class="language-none">Reactive.nodeset</code></pre><pre><code class="language-none">Reactive.onerror_rethrow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.pause_push" href="#Reactive.pause_push"><code>Reactive.pause_push</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pause a push by recording the active nodes and setting them to inactive. The push can be resumed by reactivating the nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.preserve" href="#Reactive.preserve"><code>Reactive.preserve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">preserve(signal::Signal)</code></pre><p>prevents <code>signal</code> from being garbage collected as long as any of its parents are around. Useful for when you want to do some side effects in a signal. e.g. <code>preserve(map(println, x))</code> - this will continue to print updates to x, until x goes out of scope. <code>foreach</code> is a shorthand for <code>map</code> with <code>preserve</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.previous" href="#Reactive.previous"><code>Reactive.previous</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">previous(input, default=value(input))</code></pre><p>Create a signal which holds the previous value of <code>input</code>. You can optionally specify a different initial value.</p></div></div></section><pre><code class="language-none">Reactive.print_error</code></pre><pre><code class="language-none">Reactive.probe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>push!(signal, value, onerror=Reactive.print_error)</code></p><p>Queue an update to a signal. The update will be propagated when all currently queued updates are done processing.</p><p>The third (optional) argument, <code>onerror</code>, is a callback triggered when the update ends in an error. The callback receives 4 arguments, <code>onerror(sig, val, node, capex)</code>, where <code>sig</code> and <code>val</code> are the Signal and value that <code>push!</code> was called with, respectively, <code>node</code> is the Signal whose action triggered the error, and <code>capex</code> is a <code>CapturedException</code> with the fields <code>ex</code> which is the original exception object, and <code>processed_bt</code> which is the backtrace of the exception.</p><p>The default error callback will print the error and backtrace to stderr.</p></div></div></section><pre><code class="language-none">Reactive.reinit_edges!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.remote_map" href="#Reactive.remote_map"><code>Reactive.remote_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remoterefs, results = remote_map(procid, f, init, input...;typ=typeof(init), onerror=Reactive.print_error)</code></pre><p>Spawn a new task on process <code>procid</code> to run a function when input signal updates. Returns a signal of remote refs and a <code>results</code> signal which updates asynchronously with the results. <code>init</code> will be used as the default value of <code>results</code>. <code>onerror</code> is the callback to be called when an error occurs, by default it is set to a callback which prints the error to stderr. It&#39;s the same as the <code>onerror</code> argument to <code>push!</code> but is run in the spawned task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.remove_action!" href="#Reactive.remove_action!"><code>Reactive.remove_action!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Removes <code>action</code> from <code>node.actions</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.remove_dead_nodes!" href="#Reactive.remove_dead_nodes!"><code>Reactive.remove_dead_nodes!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove GC&#39;d nodes from <code>nodes</code>, is run before push! when scheduled. Not thread-safe in the sense that if it is run while other code is iterating through <code>nodes</code>, e.g. in run_push, iteration could skip nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.rename!" href="#Reactive.rename!"><code>Reactive.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rename!(s::Signal, name::String)</code></p><p>Change a Signal&#39;s name</p></div></div></section><pre><code class="language-none">Reactive.restart_queue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.run" href="#Reactive.run"><code>Reactive.run</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Processes <code>n</code> messages from the Reactive event queue.</p></div></div></section><pre><code class="language-none">Reactive.run_async</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.run_node" href="#Reactive.run_node"><code>Reactive.run_node</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A node&#39;s actions should be run if any of its parents are active, since that generally means one (or more) of the parent nodes&#39; values have changed. If the node doesn&#39;t have actions, don&#39;t set it to active, since its value won&#39;t be updated, meaning the update propagation can stop. N.b. The non-active when node has no actions mechanism is relied on for correct behaviour by fpswhen, and possibly other operators, i.e. it is not just an optimisation.</p></div></div></section><pre><code class="language-none">Reactive.run_push</code></pre><pre><code class="language-none">Reactive.run_remove_dead_nodes</code></pre><pre><code class="language-none">Reactive.run_till_now</code></pre><pre><code class="language-none">Reactive.runaction</code></pre><pre><code class="language-none">Reactive.runner_task</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.sampleon" href="#Reactive.sampleon"><code>Reactive.sampleon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sampleon(a, b)</code></pre><p>Sample the value of <code>b</code> whenever <code>a</code> updates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.schedule_node_cleanup" href="#Reactive.schedule_node_cleanup"><code>Reactive.schedule_node_cleanup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Schedule a cleanup of dead nodes - called as a finalizer on each GC&#39;d node</p></div></div></section><pre><code class="language-none">Reactive.set_debug_mode</code></pre><pre><code class="language-none">Reactive.set_value!</code></pre><pre><code class="language-none">Reactive.setup_next_tick</code></pre><pre><code class="language-none">Reactive.stop</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.throttle" href="#Reactive.throttle"><code>Reactive.throttle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">throttle(dt, input, f=(acc,x)-&gt;x, init=value(input), reinit=x-&gt;x;
            typ=typeof(init), name=auto_name!(string(&quot;throttle &quot;,dt,&quot;s&quot;), input), leading=false)</code></pre><p>Throttle a signal to update at most once every dt seconds. By default, the throttled signal holds the last update of the <code>input</code> signal during each <code>dt</code> second time window.</p><p>This behavior can be changed by the <code>f</code>, <code>init</code> and <code>reinit</code> arguments. The <code>init</code> and <code>f</code> functions are similar to <code>init</code> and <code>f</code> in <code>foldp</code>. <code>reinit</code> is called when a new throttle time window opens to reinitialize the initial value for accumulation, it gets one argument, the previous accumulated value.</p><p>For example     <code>y = throttle(0.2, x, push!, Int[], _-&gt;Int[])</code> will create vectors of updates to the integer signal <code>x</code> which occur within 0.2 second time windows.</p><p>If <code>leading</code> is <code>true</code>, the first update from <code>input</code> will be sent immediately by the throttle signal. If it is false, the first update will happen <code>dt</code> seconds after <code>input</code>&#39;s first update</p><p>New in v0.4.1: <code>throttle</code>&#39;s behaviour from previous versions is now available with the <code>debounce</code> signal type.</p></div></div></section><pre><code class="language-none">Reactive.throttle_connect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.unbind!" href="#Reactive.unbind!"><code>Reactive.unbind!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`unbind!(dest, src, twoway=true)`</code></pre><p>remove a link set up using <code>bind!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reactive.unpreserve" href="#Reactive.unpreserve"><code>Reactive.unpreserve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unpreserve(signal::Signal)</code></pre><p>allow <code>signal</code> to be garbage collected. See also <code>preserve</code>.</p></div></div></section><pre><code class="language-none">Reactive.value</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
