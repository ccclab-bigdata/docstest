<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FlashWeave.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FlashWeave.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">FlashWeave.AbstractContTest</code></pre><pre><code class="language-none">FlashWeave.AbstractCorTest</code></pre><pre><code class="language-none">FlashWeave.AbstractNz</code></pre><pre><code class="language-none">FlashWeave.AbstractTest</code></pre><pre><code class="language-none">FlashWeave.ContTest2D</code></pre><pre><code class="language-none">FlashWeave.ContTest3D</code></pre><pre><code class="language-none">FlashWeave.FWResult</code></pre><pre><code class="language-none">FlashWeave.FlashWeave</code></pre><pre><code class="language-none">FlashWeave.FzTest</code></pre><pre><code class="language-none">FlashWeave.FzTestCond</code></pre><pre><code class="language-none">FlashWeave.HitonState</code></pre><pre><code class="language-none">FlashWeave.InvalidStateException</code></pre><pre><code class="language-none">FlashWeave.IteratorSize</code></pre><pre><code class="language-none">FlashWeave.LGL</code></pre><pre><code class="language-none">FlashWeave.LGLResult</code></pre><pre><code class="language-none">FlashWeave.MiTest</code></pre><pre><code class="language-none">FlashWeave.MiTestCond</code></pre><pre><code class="language-none">FlashWeave.NbrStatDict</code></pre><pre><code class="language-none">FlashWeave.NoNz</code></pre><pre><code class="language-none">FlashWeave.Nz</code></pre><pre><code class="language-none">FlashWeave.PairCorObj</code></pre><pre><code class="language-none">FlashWeave.PairMeanObj</code></pre><pre><code class="language-none">FlashWeave.RejDict</code></pre><pre><code class="language-none">FlashWeave.SimpleWeightedGraph_nodemax</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.StackChannel" href="#FlashWeave.StackChannel"><code>FlashWeave.StackChannel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StackChannel{T}(sz::Int)</code></pre><p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>sz</code> objects of type <code>T</code>. <a href="@ref"><code>put!</code></a> calls on a full StackChannel block until an object is removed with <a href="@ref"><code>take!</code></a>. Other constructors:</p><ul><li><code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code></li><li><code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code></li></ul></div></div></section><pre><code class="language-none">FlashWeave.TestResult</code></pre><pre><code class="language-none">FlashWeave.ZMapper</code></pre><pre><code class="language-none">FlashWeave.adaptive_clr!</code></pre><pre><code class="language-none">FlashWeave.adaptive_pseudocount</code></pre><pre><code class="language-none">FlashWeave.adaptive_pseudocount!</code></pre><pre><code class="language-none">FlashWeave.add_pwresults_to_matrix!</code></pre><pre><code class="language-none">FlashWeave.adjust_df</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.benjamini_hochberg!" href="#FlashWeave.benjamini_hochberg!"><code>FlashWeave.benjamini_hochberg!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Accelerated version of that found in MultipleTesting.jl</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.bind" href="#FlashWeave.bind"><code>FlashWeave.bind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bind(chnl::StackChannel, task::Task)</code></pre><p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code> <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>. The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects. When a StackChannel is bound to multiple tasks, the first task to terminate will close the StackChannel. When multiple StackChannels are bound to the same task, termination of the task will close all of the bound StackChannels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; c = StackChannel(0);
julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);
julia&gt; bind(c,task);
julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4
julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl">julia&gt; c = StackChannel(0);
julia&gt; task = @async (put!(c,1);error(&quot;foo&quot;));
julia&gt; bind(c,task);
julia&gt; take!(c)
1
julia&gt; put!(c,1);
ERROR: foo
Stacktrace:
[...]</code></pre></div></div></section><pre><code class="language-none">FlashWeave.candidate_in_blackwhite_lists!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.channeled_tasks" href="#FlashWeave.channeled_tasks"><code>FlashWeave.channeled_tasks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))</code></pre><p>A convenience method to create <code>n</code> StackChannels and bind them to tasks started from the provided functions in a single call. Each <code>func</code> must accept <code>n</code> arguments which are the created StackChannels. StackChannel types and sizes may be specified via keyword arguments <code>ctypes</code> and <code>csizes</code> respectively. If unspecified, all StackChannels are of type <code>Channel{Any}(0)</code>. Returns a tuple, <code>(Array{StackChannel}, Array{Task})</code>, of the created StackChannels and tasks.</p></div></div></section><pre><code class="language-none">FlashWeave.check_candidate!</code></pre><pre><code class="language-none">FlashWeave.check_channel_state</code></pre><pre><code class="language-none">FlashWeave.check_convert_sparse</code></pre><pre><code class="language-none">FlashWeave.check_data</code></pre><pre><code class="language-none">FlashWeave.close_chnl_on_taskdone</code></pre><pre><code class="language-none">FlashWeave.closed_exception</code></pre><pre><code class="language-none">FlashWeave.clr!</code></pre><pre><code class="language-none">FlashWeave.clrnorm</code></pre><pre><code class="language-none">FlashWeave.condensed_stats_to_dict</code></pre><pre><code class="language-none">FlashWeave.contingency_table</code></pre><pre><code class="language-none">FlashWeave.contingency_table!</code></pre><pre><code class="language-none">FlashWeave.converged</code></pre><pre><code class="language-none">FlashWeave.cor_subset!</code></pre><pre><code class="language-none">FlashWeave.discretize</code></pre><pre><code class="language-none">FlashWeave.discretize_meta</code></pre><pre><code class="language-none">FlashWeave.discretize_meta!</code></pre><pre><code class="language-none">FlashWeave.discretize_nz</code></pre><pre><code class="language-none">FlashWeave.elimination_phase</code></pre><pre><code class="language-none">FlashWeave.eval</code></pre><pre><code class="language-none">FlashWeave.fetch_buffered</code></pre><pre><code class="language-none">FlashWeave.fisher_z_transform</code></pre><pre><code class="language-none">FlashWeave.fz_pval</code></pre><pre><code class="language-none">FlashWeave.get_levels</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.graph" href="#FlashWeave.graph"><code>FlashWeave.graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph(result::FWResult{T}) -&gt; SimpleWeightedGraph{Int, Float64}</code></pre><p>Extract the underlying weighted graph from network results.</p></div></div></section><pre><code class="language-none">FlashWeave.hasrowids</code></pre><pre><code class="language-none">FlashWeave.hiton_backend</code></pre><pre><code class="language-none">FlashWeave.include</code></pre><pre><code class="language-none">FlashWeave.inf_weight</code></pre><pre><code class="language-none">FlashWeave.infer_conditional_neighbors</code></pre><pre><code class="language-none">FlashWeave.init_candidates</code></pre><pre><code class="language-none">FlashWeave.init_hiton_pc</code></pre><pre><code class="language-none">FlashWeave.interleaved_backend</code></pre><pre><code class="language-none">FlashWeave.interleaved_worker</code></pre><pre><code class="language-none">FlashWeave.interleaving_phase</code></pre><pre><code class="language-none">FlashWeave.is_zero_adjusted</code></pre><pre><code class="language-none">FlashWeave.isbiom</code></pre><pre><code class="language-none">FlashWeave.iscontinuous</code></pre><pre><code class="language-none">FlashWeave.iscontinuousnorm</code></pre><pre><code class="language-none">FlashWeave.isdefaultkey</code></pre><pre><code class="language-none">FlashWeave.isdiscrete</code></pre><pre><code class="language-none">FlashWeave.isdlm</code></pre><pre><code class="language-none">FlashWeave.isedgelist</code></pre><pre><code class="language-none">FlashWeave.isgml</code></pre><pre><code class="language-none">FlashWeave.isjld</code></pre><pre><code class="language-none">FlashWeave.isopen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.isready" href="#FlashWeave.isready"><code>FlashWeave.isready</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isready(c::StackChannel)</code></pre><p>Determine whether a <a href="@ref"><code>Channel</code></a> has a value stored to it. Returns immediately, does not block.</p></div></div></section><pre><code class="language-none">FlashWeave.issig</code></pre><pre><code class="language-none">FlashWeave.iter_apply_sparse_rows!</code></pre><pre><code class="language-none">FlashWeave.iterate</code></pre><pre><code class="language-none">FlashWeave.last_conv_num_edges</code></pre><pre><code class="language-none">FlashWeave.last_conv_time</code></pre><pre><code class="language-none">FlashWeave.learn_graph_structure</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.learn_network" href="#FlashWeave.learn_network"><code>FlashWeave.learn_network</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">learn_network(data_path::AbstractString, meta_data_path::AbstractString) -&gt; FWResult{Int}</code></pre><p>Works like learn_network(data::AbstractArray{ElType}), but takes file paths an OTU table and optionally a meta data table as an input (instead of a data matrix).</p><ul><li><p><code>data_path</code> - path to a file storing an OTU count table (and in the case of JLD2 possibly meta data)</p></li><li><p><code>meta_data_path</code> - optional path to a file with meta data</p></li><li><p><code>*_key</code>  - HDF5 keys to access data sets with OTU counts, Meta variables and variable names in a JLD2 file, if a data item is absent the corresponding key should be &#39;nothing&#39;. More help under &#39;?load_data&#39;</p></li><li><p><code>verbose</code> - print progress information</p></li><li><p><code>transposed</code> - if <code>true</code>, rows of <code>data</code> are variables and columns are samples</p></li><li><p><code>kwargs...</code> - additional keyword arguments passed to learn_network(data::AbstractArray{ElType})</p></li></ul></div></div><div><div><pre><code class="language-none">learn_network(data::AbstractArray{&lt;:Real}) -&gt; FWResult{Int}</code></pre><p>Learn an interaction network from a data table (including OTUs and optionally meta variables).</p><ul><li><p><code>data</code> - data table with information on OTU counts and (optionally) meta variables</p></li><li><p><code>header</code> - names of variable columns in <code>data</code></p></li><li><p><code>meta_mask</code> - true/false mask indicating which variables are meta variables</p></li></ul><p><em>Algorithmic parameters</em>:</p><ul><li><p><code>heterogeneous</code> - enable heterogeneous mode for multi-habitat or -protocol data with at least thousands of samples (FlashWeaveHE)</p></li><li><p><code>sensitive</code> - enable fine-grained associations (FlashWeave-S, FlashWeaveHE-S),  <code>sensitive=false</code> results in the <code>fast</code> modes FlashWeave-F or FlashWeaveHE-F</p></li><li><p><code>max_k</code> - maximum size of conditioning sets, high values can strongly increase runtime. <code>max_k=0</code> results in no conditioning (univariate mode)</p></li><li><p><code>alpha</code> - threshold used to determine statistical significance</p></li><li><p><code>conv</code> - convergence threshold, i.e. if <code>conv=0.01</code> assume convergence if the number of edges increased by only 1% after 100% more runtime (checked in intervals)</p></li><li><p><code>feed_forward</code> - enable feed-forward heuristic</p></li><li><p><code>max_tests</code> - maximum number of conditional tests that should be performed on a variable pair before association is assumed</p></li><li><p><code>hps</code> - reliability criterion for statistical tests when <code>sensitive=false</code></p></li><li><p><code>FDR</code> - perform False Discovery Rate correction (Benjamini-Hochberg method) on pairwise associations</p></li><li><p><code>n_obs_min</code> - don&#39;t compute associations between variables having less reliable samples (i.e. non-zero if <code>heterogeneous=true</code>) than this number. <code>-1</code>: automatically choose a threshold.</p></li><li><p><code>time_limit</code> - if feed-forward heuristic is active, determines the interval (seconds) at which neighborhood information is updated</p></li></ul><p><em>General parameters</em>:</p><ul><li><p><code>normalize</code> - automatically choose and perform data normalization (based on <code>sensitive</code> and <code>heterogeneous</code>)</p></li><li><p><code>track_rejections</code> - store for each discarded edge, which variable set lead to its exclusion (can be memory intense for large networks)</p></li><li><p><code>verbose</code> - print progress information</p></li><li><p><code>transposed</code> - if <code>true</code>, rows of <code>data</code> are variables and columns are samples</p></li><li><p><code>prec</code> - precision in bits to use for calculations (16, 32, 64 or 128)</p></li><li><p><code>make_sparse</code> - use a sparse data representation (should be left at <code>true</code> in almost all cases)</p></li><li><p><code>update_interval</code> - if <code>verbose=true</code>, determines the interval (seconds) at which network stat updates are printed</p></li></ul></div></div></section><pre><code class="language-none">FlashWeave.level_map!</code></pre><pre><code class="language-none">FlashWeave.load_biom</code></pre><pre><code class="language-none">FlashWeave.load_biom_hdf5</code></pre><pre><code class="language-none">FlashWeave.load_biom_json</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.load_data" href="#FlashWeave.load_data"><code>FlashWeave.load_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_data(data_path::AbstractString, meta_path::AbstractString) -&gt; (AbstractMatrix{&lt;:Real}, Vector{String}, AbstractMatrix{&lt;:Real}, Vector{String})</code></pre><p>Load tables with OTU count and optionally meta data from disc. Available formats are &#39;.tsv&#39;, &#39;.csv&#39;, &#39;.biom&#39; and &#39;.jld2&#39;.</p><ul><li><p><code>data_path</code> - path to a file storing an OTU count table</p></li><li><p><code>meta_data_path</code> - optional path to a file with meta variable information</p></li><li><p><code>*_key</code> - HDF5 keys to access data sets with OTU counts, Meta variables and variable names in a JLD2 file, if a data item is absent the corresponding key should be &#39;nothing&#39;</p></li><li><p><code>transposed</code> - if <code>true</code>, rows of <code>data</code> are variables and columns are samples</p></li></ul></div></div></section><pre><code class="language-none">FlashWeave.load_dlm</code></pre><pre><code class="language-none">FlashWeave.load_jld</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.load_network" href="#FlashWeave.load_network"><code>FlashWeave.load_network</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_network(net_path::AbstractString) -&gt; FWResult{Int}</code></pre><p>Load network results from disk. Available formats are &#39;.tsv&#39;, &#39;.csv&#39;, &#39;.gml&#39; and &#39;.jld2&#39;. For GML, only files with structure identical to save_network(&#39;network.gml&#39;) output can currently be loaded. Run parameters are only available when loading from JLD2.</p><ul><li><code>net_path</code> - path from which to load the network results</li></ul></div></div></section><pre><code class="language-none">FlashWeave.make_chunks</code></pre><pre><code class="language-none">FlashWeave.make_final_HitonState</code></pre><pre><code class="language-none">FlashWeave.make_stopped_HitonState</code></pre><pre><code class="language-none">FlashWeave.make_symmetric_graph</code></pre><pre><code class="language-none">FlashWeave.make_test_object</code></pre><pre><code class="language-none">FlashWeave.make_weights</code></pre><pre><code class="language-none">FlashWeave.make_zmap_expression</code></pre><pre><code class="language-none">FlashWeave.mapslices_sparse_nz</code></pre><pre><code class="language-none">FlashWeave.maxweight</code></pre><pre><code class="language-none">FlashWeave.meta_variable_mask</code></pre><pre><code class="language-none">FlashWeave.mi_pval</code></pre><pre><code class="language-none">FlashWeave.mode_string</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.mutual_information" href="#FlashWeave.mutual_information"><code>FlashWeave.mutual_information</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>IMPORTANT NOTE: returns mutual information * number of observations! (avoids repeated calculation later)</p></div></div></section><pre><code class="language-none">FlashWeave.n_avail</code></pre><pre><code class="language-none">FlashWeave.needs_nz_view</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.normalize_data" href="#FlashWeave.normalize_data"><code>FlashWeave.normalize_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize_data(data::AbstractMatrix{&lt;:Real}) -&gt; AbstractMatrix OR (AbstractMatrix{&lt;:Real}, Vector{String})</code></pre><p>Normalize data using various forms of clr transform and discretization. This should only be used manually when experimenting with different normalization techniques.</p><ul><li><p><code>data</code> - data table with information on OTU counts and (optionally) meta variables</p></li><li><p><code>header</code> - names of variable-column s in <code>data</code></p></li><li><p><code>meta_mask</code> - true/false mask indicating which variables are meta variables</p></li><li><p><code>test_name</code> - name of a FlashWeave-specific statistical test mode, the appropriate normalization method will be chosen automatically</p></li><li><p><code>norm_mode</code> - identifier of a valid normalization mode (&#39;clr-adapt&#39;, &#39;clr-nonzero&#39;, &#39;clr-nonzero-binned&#39;, &#39;pres-abs&#39;, &#39;tss&#39;, &#39;tss-nonzero-binned&#39;)</p></li><li><p><code>filter_data</code> - whether to remove samples and variables without information from <code>data</code></p></li><li><p><code>verbose</code> - print progress information</p></li><li><p><code>prec</code> - precision in bits to use for calculations (16, 32, 64 or 128)</p></li></ul></div></div></section><pre><code class="language-none">FlashWeave.notify_error</code></pre><pre><code class="language-none">FlashWeave.nz_adjust_cont_tab</code></pre><pre><code class="language-none">FlashWeave.oddsratio</code></pre><pre><code class="language-none">FlashWeave.order_pair</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.parameters" href="#FlashWeave.parameters"><code>FlashWeave.parameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parameters(result::FWResult{T}) -&gt; Dict{Symbol, Any}</code></pre><p>Extract the used parameters from network results.</p></div></div></section><pre><code class="language-none">FlashWeave.parse_gml_field</code></pre><pre><code class="language-none">FlashWeave.pcor</code></pre><pre><code class="language-none">FlashWeave.pcor_rec</code></pre><pre><code class="language-none">FlashWeave.prepare_elimination_phase</code></pre><pre><code class="language-none">FlashWeave.prepare_interleaving_phase</code></pre><pre><code class="language-none">FlashWeave.prepare_lgl</code></pre><pre><code class="language-none">FlashWeave.prepare_nzdata</code></pre><pre><code class="language-none">FlashWeave.prepare_univar_results</code></pre><pre><code class="language-none">FlashWeave.preprocess_data</code></pre><pre><code class="language-none">FlashWeave.preprocess_data_default</code></pre><pre><code class="language-none">FlashWeave.presabs_norm!</code></pre><pre><code class="language-none">FlashWeave.print_network_stats</code></pre><pre><code class="language-none">FlashWeave.pseudocount_vars_from_sample</code></pre><pre><code class="language-none">FlashWeave.put_buffered</code></pre><pre><code class="language-none">FlashWeave.pw_univar_kernel</code></pre><pre><code class="language-none">FlashWeave.pw_univar_kernel!</code></pre><pre><code class="language-none">FlashWeave.pw_univar_neighbors</code></pre><pre><code class="language-none">FlashWeave.read_edgelist</code></pre><pre><code class="language-none">FlashWeave.read_gml</code></pre><pre><code class="language-none">FlashWeave.rejections</code></pre><pre><code class="language-none">FlashWeave.reset!</code></pre><pre><code class="language-none">FlashWeave.rownorm!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FlashWeave.save_network" href="#FlashWeave.save_network"><code>FlashWeave.save_network</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">save_network(net_path::AbstractString, net_result::FWResult) -&gt; Void</code></pre><p>Save network results to disk. Available formats are &#39;.tsv&#39;, &#39;.csv&#39;, &#39;.gml&#39; and &#39;.jld2&#39;.</p><ul><li><p><code>net_path</code> - output path for the network</p></li><li><p><code>net_result</code> - network results object that should be saved</p></li><li><p><code>detailed</code> - output additional information, such as discarding sets, if available</p></li></ul></div></div></section><pre><code class="language-none">FlashWeave.save_rejections</code></pre><pre><code class="language-none">FlashWeave.save_unfinished_variable_info</code></pre><pre><code class="language-none">FlashWeave.show</code></pre><pre><code class="language-none">FlashWeave.si_HITON_PC</code></pre><pre><code class="language-none">FlashWeave.signed_weight</code></pre><pre><code class="language-none">FlashWeave.sparse_ctab_backend!</code></pre><pre><code class="language-none">FlashWeave.stop_reached</code></pre><pre><code class="language-none">FlashWeave.sufficient_power</code></pre><pre><code class="language-none">FlashWeave.take_buffered</code></pre><pre><code class="language-none">FlashWeave.test</code></pre><pre><code class="language-none">FlashWeave.test_subsets</code></pre><pre><code class="language-none">FlashWeave.unchecked_statistics</code></pre><pre><code class="language-none">FlashWeave.unfinished_states</code></pre><pre><code class="language-none">FlashWeave.update!</code></pre><pre><code class="language-none">FlashWeave.update_PC_dict!</code></pre><pre><code class="language-none">FlashWeave.update_sig_result!</code></pre><pre><code class="language-none">FlashWeave.valid_data_formats</code></pre><pre><code class="language-none">FlashWeave.valid_net_formats</code></pre><pre><code class="language-none">FlashWeave.wait_impl</code></pre><pre><code class="language-none">FlashWeave.work_chunker</code></pre><pre><code class="language-none">FlashWeave.workers_all_local</code></pre><pre><code class="language-none">FlashWeave.write_edgelist</code></pre><pre><code class="language-none">FlashWeave.write_gml</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
