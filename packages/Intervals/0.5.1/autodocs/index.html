<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Intervals.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Intervals.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Intervals...</code></pre><pre><code class="language-none">Intervals.AbstractInterval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.AnchoredInterval" href="#Intervals.AnchoredInterval"><code>Intervals.AnchoredInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AnchoredInterval{P, T}(anchor::T, [inclusivity::Inclusivity]) where {P, T} -&gt; AnchoredInterval{P, T}
AnchoredInterval{P, T}(anchor::T, [closed_left::Bool, closed_right::Bool]) where {P, T} -&gt; AnchoredInterval{P, T}</code></pre><p><code>AnchoredInterval</code> is a subtype of <code>AbstractInterval</code> that represents a non-iterable range or span of values defined not by two endpoints but instead by a single <code>anchor</code> point and the value type <code>P</code> which represents the size of the range. When <code>P</code> is positive, the <code>anchor</code> represents the lesser endpoint (the beginning of the range); when <code>P</code> is negative, the <code>anchor</code> represents the greater endpoint (the end of the range).</p><p>The interval represented by an <code>AnchoredInterval</code> value may be closed (both endpoints are included in the interval), open (neither endpoint is included), or half-open. This openness is defined by an <code>Inclusivity</code> value, which defaults to half-open (with the lesser endpoint included for positive values of <code>P</code> and the greater endpoint included for negative values).</p><p><strong>Why?</strong></p><p><code>AnchoredIntervals</code> are most useful in cases where a single value is used to stand in for a range of values. This happens most often with dates and times, where &quot;HE15&quot; is often used as shorthand for (14:00..15:00].</p><p>To this end, <code>HourEnding</code> is a type alias for <code>AnchoredInterval{Hour(-1)}</code>. Similarly, <code>HourBeginning</code> is a type alias for <code>AnchoredInterval{Hour(1)}</code>.</p><p><strong>Rounding</strong></p><p>While the user may expect an <code>HourEnding</code> or <code>HourBeginning</code> value to be anchored to a specific hour, the constructor makes no guarantees that the anchor provided is rounded:</p><pre><code class="language-julia">julia&gt; HourEnding(DateTime(2016, 8, 11, 2, 30))
HourEnding{DateTime}(2016-08-11T02:30:00, Inclusivity(false, true))</code></pre><p>The <code>HE</code> and <code>HB</code> pseudoconstructors round the input up or down to the nearest hour, as appropriate:</p><pre><code class="language-julia">julia&gt; HE(DateTime(2016, 8, 11, 2, 30))
HourEnding{DateTime}(2016-08-11T03:00:00, Inclusivity(false, true))

julia&gt; HB(DateTime(2016, 8, 11, 2, 30))
HourBeginning{DateTime}(2016-08-11T02:00:00, Inclusivity(true, false))</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; AnchoredInterval{Hour(-1)}(DateTime(2016, 8, 11, 12))
HourEnding{DateTime}(2016-08-11T12:00:00, Inclusivity(false, true))

julia&gt; AnchoredInterval{Day(1)}(DateTime(2016, 8, 11))
AnchoredInterval{1 day, DateTime}(2016-08-11T00:00:00, Inclusivity(true, false))

julia&gt; AnchoredInterval{Minute(5)}(DateTime(2016, 8, 11, 12, 30), true, true)
AnchoredInterval{5 minutes, DateTime}(2016-08-11T12:30:00, Inclusivity(true, true))</code></pre><p>See also: <a href="../#Intervals.Interval"><code>Interval</code></a>, <a href="../#Intervals.Inclusivity"><code>Inclusivity</code></a>, <a href="../#Intervals.HE"><code>HE</code></a>, <a href="../#Intervals.HB"><code>HB</code></a></p></div></div></section><pre><code class="language-none">Intervals.Beginning</code></pre><pre><code class="language-none">Intervals.Direction</code></pre><pre><code class="language-none">Intervals.Ending</code></pre><pre><code class="language-none">Intervals.Endpoint</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.HB" href="#Intervals.HB"><code>Intervals.HB</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HB(anchor, args...) -&gt; HourBeginning</code></pre><p><code>HB</code> is a pseudoconstructor for <a href="../#Intervals.HourBeginning"><code>HourBeginning</code></a> that rounds the anchor provided down to the nearest hour.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.HE" href="#Intervals.HE"><code>Intervals.HE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HE(anchor, args...) -&gt; HourEnding</code></pre><p><code>HE</code> is a pseudoconstructor for <a href="../#Intervals.HourEnding"><code>HourEnding</code></a> that rounds the anchor provided up to the nearest hour.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.HourBeginning" href="#Intervals.HourBeginning"><code>Intervals.HourBeginning</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HourBeginning{T&lt;:TimeType} &lt;: AbstractInterval{T}</code></pre><p>A type alias for <code>AnchoredInterval{Hour(1), T}</code> which is used to denote a 1-hour period of time which begins at a time instant (of type <code>T</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.HourEnding" href="#Intervals.HourEnding"><code>Intervals.HourEnding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HourEnding{T&lt;:TimeType} &lt;: AbstractInterval{T}</code></pre><p>A type alias for <code>AnchoredInterval{Hour(-1), T}</code> which is used to denote a 1-hour period of time which ends at a time instant (of type <code>T</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.Inclusivity" href="#Intervals.Inclusivity"><code>Intervals.Inclusivity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Inclusivity(first::Bool, last::Bool) -&gt; Inclusivity</code></pre><p>Defines whether an <code>AbstractInterval</code> is open, half-open, or closed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.Interval" href="#Intervals.Interval"><code>Intervals.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interval(first, last, [inclusivity::Inclusivity]) -&gt; Interval
Interval(first, last, [closed_left::Bool, closed_right::Bool]) -&gt; Interval</code></pre><p>An <code>Interval</code> represents a non-iterable range or span of values (non-interable because, unlike a <code>StepRange</code>, no step is defined).</p><p>An <code>Interval</code> can be closed (both <code>first</code> and <code>last</code> are included in the interval), open (neither <code>first</code> nor <code>last</code> are included), or half-open. This openness is defined by an <code>Inclusivity</code> value, which defaults to closed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; i = Interval(0, 100, true, false)
Interval{Int64}(0, 100, Inclusivity(true, false))

julia&gt; in(0, i)
true

julia&gt; in(50, i)
true

julia&gt; in(100, i)
false

julia&gt; intersect(Interval(0, 25, false, false), Interval(20, 50, true, true)
Interval{Int64}(20, 25, Inclusivity(true, false))</code></pre><p><strong>Infix Constructor: <code>..</code></strong></p><p>A closed <code>Interval</code> can be constructed with the <code>..</code> infix constructor:</p><pre><code class="language-julia">julia&gt; Dates.today() - Dates.Week(1) .. Dates.today()
Interval{Date}(2018-01-24, 2018-01-31, Inclusivity(true, true))</code></pre><p><strong>Note on Ordering</strong></p><p>The <code>Interval</code> constructor will compare <code>first</code> and <code>last</code>; if it finds that <code>first &gt; last</code>, they will be reversed to ensure that <code>first &lt; last</code>. This simplifies calls to <code>in</code> and <code>intersect</code>:</p><pre><code class="language-julia">julia&gt; i = Interval(Date(2016, 8, 11), Date(2013, 2, 13), false, true)
Interval{Date}(2013-02-13, 2016-08-11, Inclusivity(true, false))</code></pre><p>Note that the <code>Inclusivity</code> value is also reversed in this case.</p><p>See also: <a href="../#Intervals.AnchoredInterval"><code>AnchoredInterval</code></a>, <a href="../#Intervals.Inclusivity"><code>Inclusivity</code></a></p></div></div></section><pre><code class="language-none">Intervals.Intervals</code></pre><pre><code class="language-none">Intervals.Left</code></pre><pre><code class="language-none">Intervals.LeftEndpoint</code></pre><pre><code class="language-none">Intervals.Right</code></pre><pre><code class="language-none">Intervals.RightEndpoint</code></pre><pre><code class="language-none">Intervals.anchor</code></pre><pre><code class="language-none">Intervals.canonicalize</code></pre><pre><code class="language-none">Intervals.contiguous</code></pre><pre><code class="language-none">Intervals.description</code></pre><pre><code class="language-none">Intervals.eval</code></pre><pre><code class="language-none">Intervals.first</code></pre><pre><code class="language-none">Intervals.greater_than_disjoint</code></pre><pre><code class="language-none">Intervals.include</code></pre><pre><code class="language-none">Intervals.inclusivity</code></pre><pre><code class="language-none">Intervals.isclosed</code></pre><pre><code class="language-none">Intervals.last</code></pre><pre><code class="language-none">Intervals.less_than_disjoint</code></pre><pre><code class="language-none">Intervals.merge</code></pre><pre><code class="language-none">Intervals.overlaps</code></pre><pre><code class="language-none">Intervals.prefix</code></pre><pre><code class="language-none">Intervals.span</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Intervals.superset" href="#Intervals.superset"><code>Intervals.superset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">superset(intervals::AbstractArray{&lt;:AbstractInterval}) -&gt; Interval</code></pre><p>Create the smallest single interval which encompasses all of the provided intervals.</p></div></div></section><pre><code class="language-none">Intervals.time_string</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union(intervals::AbstractVector{&lt;:AbstractInterval})</code></pre><p>Flattens a vector of overlapping intervals into a new, smaller vector containing only non-overlapping intervals.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union!" href="#Base.union!"><code>Base.union!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union!(intervals::AbstractVector{&lt;:Union{Interval, AbstractInterval}})</code></pre><p>Flattens a vector of overlapping intervals in-place to be a smaller vector containing only non-overlapping intervals.</p></div></div></section><pre><code class="language-none">Intervals.≪</code></pre><pre><code class="language-none">Intervals.≫</code></pre><pre><code class="language-none">Intervals.⊆</code></pre><pre><code class="language-none">Intervals.⊇</code></pre><pre><code class="language-none">Intervals.⊈</code></pre><pre><code class="language-none">Intervals.⊉</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
