<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structured solvers · StochasticPrograms.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StochasticPrograms.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../quickstart/">Quick start</a></li><li><a class="toctext" href="../data/">Stochastic data</a></li><li><a class="toctext" href="../modeldef/">Model definition</a></li><li><a class="toctext" href="../distributed/">Distributed stochastic programs</a></li><li class="current"><a class="toctext" href>Structured solvers</a><ul class="internal"><li><a class="toctext" href="#Solver-interface-1">Solver interface</a></li><li><a class="toctext" href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a></li><li><a class="toctext" href="#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../library/public/">Public interface</a></li><li><a class="toctext" href="../../library/solverinterface/">Solver interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Structured solvers</a></li></ul></nav><hr/><div id="topbar"><span>Structured solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Structured-solvers-1" href="#Structured-solvers-1">Structured solvers</a></h1><p>A stochastic program has a structure that can exploited in solver algorithms through decomposition. This can heavily reduce the computation time required to optimize the stochastic program, compared to solving the extensive form directly. Moreover, a distributed stochastic program is by definition decomposed and a structured solver that can operate in parallel will be much more efficient.</p><h2><a class="nav-anchor" id="Solver-interface-1" href="#Solver-interface-1">Solver interface</a></h2><p>The structured solver interface mimics that of <code>MathProgBase</code>, and it needs to be implemented by any structured solver to be compatible with StochasticPrograms. Define a new structured solver as a subtype of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. Moreoever, define a shallow object of type <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a>. This object is intended to be the interface to end users of the solver and is what should be passed to <a href="../../library/public/#StochasticPrograms.optimize!-Tuple{StochasticProgram}"><code>optimize!</code></a>. Next, implement <a href="../../library/solverinterface/#StochasticPrograms.StructuredModel-Tuple{StochasticProgram,AbstractStructuredSolver}"><code>StructuredModel</code></a>, that takes the stochastic program and the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredSolver"><code>AbstractStructuredSolver</code></a> object and return and instance of <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a> which internal state depends on the given stochastic program. Next, the solver algorithm should be run when calling <a href="../../library/solverinterface/#StochasticPrograms.optimize_structured!-Tuple{AbstractStructuredModel}"><code>optimize_structured!</code></a> on the <a href="../../library/solverinterface/#StochasticPrograms.AbstractStructuredModel"><code>AbstractStructuredModel</code></a>. After successfuly optimizing the model, the solver must be able to fill in the optimal solution in the first stage and all second stages through <a href="../../library/solverinterface/#StochasticPrograms.fill_solution!-Tuple{StochasticProgram,AbstractStructuredModel}"><code>fill_solution!</code></a>.</p><p>Some procedures in StochasticPrograms require a <code>MathProgBase</code> solver. It is common that structured solvers rely internally on some <code>MathProgBase</code> solver. Hence, for convenience, a structured solver can implement <a href="../../library/solverinterface/#StochasticPrograms.internal_solver-Tuple{AbstractStructuredSolver}"><code>internal_solver</code></a> to return any internal <code>MathProgBase</code> solver. A stochastic program that has an loaded structured solver that implements this method can then make use of that solver for those procedures, instead of requiring an external solver to be supplied. Finally, a structured solver can optionally implement <a href="../../library/solverinterface/#StochasticPrograms.solverstr-Tuple{AbstractStructuredModel}"><code>solverstr</code></a> to return an informative description string for printouts.</p><p>As an example, a simplified version of the implementation of the structured solver interface in <a href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a> is given below:</p><pre><code class="language-julia">abstract AbstractLShapedSolver &lt;: AbstractStructuredModel end

const MPB = MathProgBase

mutable struct LShapedSolver &lt;: AbstractStructuredSolver
    lpsolver::MPB.AbstractMathProgSolver
    subsolver::MPB.AbstractMathProgSolver
    checkfeas::Bool
    crash::Crash.CrashMethod
    parameters::Dict{Symbol,Any}

    function (::Type{LShapedSolver})(lpsolver::MPB.AbstractMathProgSolver; crash::Crash.CrashMethod = Crash.None(), subsolver::MPB.AbstractMathProgSolver = lpsolver, checkfeas::Bool = false, kwargs...)
        return new(lpsolver, subsolver, checkfeas, crash, Dict{Symbol,Any}(kwargs))
    end
end

function StructuredModel(stochasticprogram::StochasticProgram, solver::LShapedSolver)
    x₀ = solver.crash(stochasticprogram, solver.lpsolver)
    return LShaped(stochasticprogram, x₀, solver.lpsolver, solver.subsolver, solver.checkfeas; solver.parameters...)
end

function internal_solver(solver::LShapedSolver)
    return solver.lpsolver
end

function optimize_structured!(lshaped::AbstractLShapedSolver)
    return lshaped()
end

function fill_solution!(stochasticprogram::StochasticProgram, lshaped::AbstractLShapedSolver)
    # First stage
    first_stage = StochasticPrograms.get_stage_one(stochasticprogram)
    nrows, ncols = first_stage_dims(stochasticprogram)
    StochasticPrograms.set_decision!(stochasticprogram, decision(lshaped))
    μ = try
        MPB.getreducedcosts(lshaped.mastersolver.lqmodel)[1:ncols]
    catch
        fill(NaN, ncols)
    end
    StochasticPrograms.set_first_stage_redcosts!(stochasticprogram, μ)
    λ = try
        MPB.getconstrduals(lshaped.mastersolver.lqmodel)[1:nrows]
    catch
        fill(NaN, nrows)
    end
    StochasticPrograms.set_first_stage_duals!(stochasticprogram, λ)
    # Second stage
    fill_submodels!(lshaped, scenarioproblems(stochasticprogram))
end</code></pre><h2><a class="nav-anchor" id="LShapedSolvers.jl-1" href="#LShapedSolvers.jl-1">LShapedSolvers.jl</a></h2><p>LShapedSolvers is a collection of structured optimization algorithms for two-stage (L-shaped) stochastic recourse problems. All algorithm variants are based on the L-shaped method by Van Slyke and Wets. LShapedSolvers interfaces with StochasticPrograms through the structured solver interface. It is available as an unregistered package on Github, ans can be installed as follows:</p><pre><code class="language-julia">pkg&gt; add https://github.com/martinbiel/LShapedSolvers.jl</code></pre><div></div><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start-1">Quick start</a>:</p><pre><code class="language-julia">using LShapedSolvers
using GLPKMathProgInterface

optimize!(sp, solver = LShapedSolver(:ls, GLPKSolverLP()))</code></pre><pre><code class="language-julia">L-Shaped Gap  Time: 0:00:01 (6 iterations)
  Objective:       -855.8333333333358
  Gap:             0.0
  Number of cuts:  8
:Optimal</code></pre><p>Note, that an LP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems. The following variants of the L-shaped algorithm are implemented:</p><ol><li>L-shaped with multiple cuts (default): <code>LShapedSolver(:ls)</code></li><li>L-shaped with regularized decomposition: <code>LShapedSolver(:rd)</code></li><li>L-shaped with trust region: <code>LShapedSolver(:tr)</code></li><li>L-shaped with level sets: <code>LShapedSolver(:lv)</code></li></ol><p>Note, that <code>LShapedSolver(:rd)</code> and <code>LShapedSolver(:lv)</code> both require a QP capable <code>AbstractMathProgSolver</code> for the master problems. If not available, setting the <code>linearize</code> keyword to <code>true</code> is an alternative.</p><p>In addition, there is a distributed variant of each algorithm:</p><ol><li>Distributed L-shaped with multiple cuts: <code>LShapedSolver(:dls)</code></li><li>Distributed L-shaped with regularized decomposition: <code>LShapedSolver(:drd)</code></li><li>Distributed L-shaped with trust region: <code>LShapedSolver(:dtr)</code></li><li>Distributed L-shaped with level sets: <code>LShapedSolver(:dlv)</code></li></ol><p>which requires adding processes with <code>addprocs</code> prior to execution. The distributed variants are designed for StochasticPrograms, and are most efficient when run on distributed stochastic programs.</p><p>Each algorithm has a set of parameters that can be tuned prior to execution. For a list of these parameters and their default values, use <code>?</code> in combination with the solver object. For example, <code>?LShaped</code> gives the parameter list of the default L-shaped algorithm. For a list of all solvers and their handle names, use <code>?LShapedSolver</code>.</p><h2><a class="nav-anchor" id="ProgressiveHedgingSolvers.jl-1" href="#ProgressiveHedgingSolvers.jl-1">ProgressiveHedgingSolvers.jl</a></h2><p>ProgressiveHedgingSolvers includes implementations of the progressive-hedging algorithm for two-stage stochastic recourse problems. All algorithm variants are based on the original progressive-hedging algorithm by Rockafellar and Wets. ProgressiveHedgingSolvers interfaces with StochasticPrograms through the structured solver interface. It is available as an unregistered package on Github, ans can be installed as follows:</p><pre><code class="language-julia">pkg&gt; add https://github.com/martinbiel/LShapedSolvers.jl</code></pre><p>As an example, we solve the simple problem introduced in the <a href="../quickstart/#Quick-start-1">Quick start</a>:</p><pre><code class="language-julia">using ProgressiveHedgingSolvers
using Ipopt

optimize!(sp, solver = ProgressiveHedgingSolver(:ph, IpoptSolver(print_level=0)))</code></pre><pre><code class="language-julia">Progressive Hedging Time: 0:00:06 (1315 iterations)
  Objective:  -855.8332803469448
  δ:          9.570267362791345e-7
:Optimal</code></pre><p>Note, that a QP capable <code>AbstractMathProgSolver</code> is required to solve emerging subproblems. In addition, there is a distributed variant of the algorithm: <code>ProgressiveHedgingSolver(:dph)</code>, which requires adding processes with <code>addprocs</code> prior to execution. The distributed variant is designed for StochasticPrograms, and is most efficient when run on distributed stochastic programs.</p><p>The algorithm has a set of parameters that can be tuned prior to execution. For a list of these parameters and their default values, use <code>?</code> in combination with the solver object. For example, <code>?ProgressiveHedging</code> gives the parameter list of the sequential progressive-hedging algorithm. For a list of all solvers and their handle names, use <code>?ProgressiveHedgingSolver</code>.</p><footer><hr/><a class="previous" href="../distributed/"><span class="direction">Previous</span><span class="title">Distributed stochastic programs</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
