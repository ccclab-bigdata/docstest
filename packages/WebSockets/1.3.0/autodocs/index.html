<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · WebSockets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>WebSockets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">WebSockets.@wslog</code></pre><pre><code class="language-none">WebSockets.CLOSED</code></pre><pre><code class="language-none">WebSockets.CLOSING</code></pre><pre><code class="language-none">WebSockets.CONNECTED</code></pre><pre><code class="language-none">WebSockets.Dt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_BINARY" href="#WebSockets.OPCODE_BINARY"><code>WebSockets.OPCODE_BINARY</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%x2 denotes a binary frame</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_CLOSE" href="#WebSockets.OPCODE_CLOSE"><code>WebSockets.OPCODE_CLOSE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%x8 denotes a connection close</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_CONTINUATION" href="#WebSockets.OPCODE_CONTINUATION"><code>WebSockets.OPCODE_CONTINUATION</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%x0 denotes a continuation frame</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_PING" href="#WebSockets.OPCODE_PING"><code>WebSockets.OPCODE_PING</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%x9 denotes a ping</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_PONG" href="#WebSockets.OPCODE_PONG"><code>WebSockets.OPCODE_PONG</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%xA denotes a pong</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.OPCODE_TEXT" href="#WebSockets.OPCODE_TEXT"><code>WebSockets.OPCODE_TEXT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><ul><li>%x1 denotes a text frame</li></ul></div></div></section><pre><code class="language-none">WebSockets.ReadyState</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.SUBProtocols" href="#WebSockets.SUBProtocols"><code>WebSockets.SUBProtocols</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Handshakes with subprotocols are rejected by default. Add to acceptable SUBProtocols through e.g.</p><pre><code class="language-julia">   addsubproto(&quot;json&quot;)</code></pre><p>Also see function subprotocol</p></div></div></section><pre><code class="language-none">WebSockets.ServerOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.ServerWS" href="#WebSockets.ServerWS"><code>WebSockets.ServerWS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WebSockets.ServerWS(handler::Function, wshandler::Function, logger::IO)</code></pre><p>WebSockets.ServerWS is an argument type for WebSockets.serve. Instances include .in  and .out channels, see WebSockets.serve.</p><p>Server options can be set using keyword arguments, see methods(WebSockets.ServerWS)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.TIMEOUT_CLOSEHANDSHAKE" href="#WebSockets.TIMEOUT_CLOSEHANDSHAKE"><code>WebSockets.TIMEOUT_CLOSEHANDSHAKE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A reasonable amount of time</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.WebSocket" href="#WebSockets.WebSocket"><code>WebSockets.WebSocket</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A WebSocket is a wrapper over a TCPSocket. It takes care of wrapping outgoing data in a frame and unwrapping (and concatenating) incoming data.</p></div></div></section><pre><code class="language-none">WebSockets.WebSocketClosedError</code></pre><pre><code class="language-none">WebSockets.WebSocketError</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.WebSocketFragment" href="#WebSockets.WebSocketFragment"><code>WebSockets.WebSocketFragment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Represents one (received) message frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.WebSocketLogger" href="#WebSockets.WebSocketLogger"><code>WebSockets.WebSocketLogger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Differences to stdlib/Logging/ConsoleLogger:</p><pre><code class="language-none">- default timestamp on logging messages (except @info)
- a &#39;shouldlog&#39; function can be passed in. The `shouldlog_default` function filters
    on HTTP.Servers messages as well as on message_limits
- :wslog =&gt; true flag which may be used for context-sensitive output
    from &#39;show&#39; methods. This means a user can define &#39;show&#39; methods
    which are used with this logger without affecting the behaviour
    defined in other modules.
- :limited =&gt; true is included in the default IOContext. Keyword: show_limited
- string_with_env_ws is exported for easy overloading on specific types
- @info, @debug, @warn etc. will splat the first argument if it&#39;s a tuple arguments, e.g.

julia&gt; var = &quot;a&quot;
&quot;a&quot;
julia&gt; @info (1, var)
[ Info: 1a</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.WebSockets" href="#WebSockets.WebSockets"><code>WebSockets.WebSockets</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">WebSockets</code></pre><p>This module implements the WebSockets protocol. It relies on the package HTTP.jl.</p><p>Websocket|server relies on a client initiating the connection. Websocket|client initiate the connection.</p><p>The client side of the connection is most typically a browser with scripts enabled. Browsers are always the initiating, client side. But the peer can be any program, in any language, that follows the protocol. That includes another Julia session, running in a parallel process or task.</p><pre><code class="language-none">Future improvements:</code></pre><ol><li>Check rsv1 to rsv3 values. This will reduce bandwidth.</li><li>Optimize maskswitch!, possibly threaded above a certain limit.</li><li>Split messages over several frames.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.WebsocketHandler" href="#WebSockets.WebsocketHandler"><code>WebSockets.WebsocketHandler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>WebsocketHandler(f::Function) &lt;: Handler</p><p>The provided argument should be one of the forms     <code>f(WebSocket) =&gt; nothing</code>     <code>f(Request, WebSocket) =&gt; nothing</code> The latter form is intended for gatekeeping, ref. RFC 6455 section 10.1</p><p>f accepts a <code>WebSocket</code> and does interesting things with it, like reading, writing and exiting when finished.</p></div></div></section><pre><code class="language-none">WebSockets.Wslog</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets._openstream" href="#WebSockets._openstream"><code>WebSockets._openstream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Called by open with a stream connected to a server, after handshake is initiated</p></div></div></section><pre><code class="language-none">WebSockets._show</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets._uv_status_tuple" href="#WebSockets._uv_status_tuple"><code>WebSockets._uv_status_tuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For colorful printing</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.addsubproto" href="#WebSockets.addsubproto"><code>WebSockets.addsubproto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Used to specify acceptable subprotocols. See SUBProtocols</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.check_upgrade" href="#WebSockets.check_upgrade"><code>WebSockets.check_upgrade</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Throws WebSocketError if the upgrade message is not basically valid. Called from &#39;upgrade&#39; for potential server side websockets, and from `_openstream&#39; for potential client side websockets. Not normally called from user code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.checkratelimit!" href="#WebSockets.checkratelimit!"><code>WebSockets.checkratelimit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>&#39;checkratelimit!&#39; updates a dictionary of IP addresses which keeps track of their connection quota per time window.</p><p>The allowed connections per time is given in keyword argument ratelimit.</p><p>The actual ratelimit::Rational value, is normally given as a field value in ServerOpions.</p><p>&#39;checkratelimit!&#39; is the default rate limiting function for ServerWS, which passes it as the &#39;tcpisvalid&#39; argument to &#39;WebSockets.HTTP.listen&#39;. Other functions can be given as a keyword argument, as long as they adhere to this form, which WebSockets.HTTP.listen expects.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">close(ws::WebSocket)
close(ws::WebSocket, statusnumber = n)
close(ws::WebSocket, statusnumber = n, freereason = &quot;my reason&quot;)</code></pre><p>Send an OPCODE_CLOSE frame, and wait for the same response or until a reasonable amount of time, 10.0 s, has passed. Data received while closing is dropped. Status number n according to RFC 6455 7.4.1 can be included, see WebSockets.codeDesc</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.codeDesc" href="#WebSockets.codeDesc"><code>WebSockets.codeDesc</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Status codes according to RFC 6455 7.4.1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.default_metaformat" href="#WebSockets.default_metaformat"><code>WebSockets.default_metaformat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Defines a default logging message format with timestamp</p></div></div></section><pre><code class="language-none">WebSockets.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.generate_websocket_key" href="#WebSockets.generate_websocket_key"><code>WebSockets.generate_websocket_key</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">WebSocket Handshake Procedure</code></pre><p><code>generate_websocket_key(key)</code> transforms a websocket client key into the server&#39;s accept value. This is done in three steps:</p><ol><li>Concatenate key with magic string from RFC.</li><li>SHA1 hash the resulting base64 string.</li><li>Encode the resulting number in base64.</li></ol><p>This function then returns the string of the base64-encoded value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.handle_control_frame" href="#WebSockets.handle_control_frame"><code>WebSockets.handle_control_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Respond to pings, ignore pongs, respond to close.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.hasprotocol" href="#WebSockets.hasprotocol"><code>WebSockets.hasprotocol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Used in handshake. See SUBProtocols</p></div></div></section><pre><code class="language-none">WebSockets.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.init_socket" href="#WebSockets.init_socket"><code>WebSockets.init_socket</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Buffer writes to socket till flush (sock)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.is_control_frame" href="#WebSockets.is_control_frame"><code>WebSockets.is_control_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Control frames have opcodes with the highest bit = 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.is_upgrade" href="#WebSockets.is_upgrade"><code>WebSockets.is_upgrade</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Fast checking for websocket upgrade request vs content requests. Called on all new connections in &#39;_servercoroutine&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.locked_write" href="#WebSockets.locked_write"><code>WebSockets.locked_write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Write without interruptions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.maskswitch!" href="#WebSockets.maskswitch!"><code>WebSockets.maskswitch!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maskswitch!(data)
maskswitch!(data, key:: 4-element Vector{UInt8})</code></pre><p>Masks or unmasks data in-place, returns the key used. Calling twice with the same key restores data. Ref. RFC 6455 5-3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.open" href="#WebSockets.open"><code>WebSockets.open</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initiate a websocket|client connection to server defined by url. If the server accepts the connection and the upgrade to websocket, f is called with an open websocket|client</p><p>e.g. say hello, close and leave</p><pre><code class="language-julia">using WebSockets
WebSockets.open(&quot;ws://127.0.0.1:8000&quot;) do ws
    write(ws, &quot;Hello&quot;)
    println(&quot;that&#39;s it&quot;)
end;</code></pre><p>If a server is listening and accepts, &quot;Hello&quot; is sent (as a Vector{UInt8}).</p><p>On exit, a closing handshake is started. If the server is not currently reading (which is a blocking function), this side will reset the underlying connection (ECONNRESET) after a reasonable amount of time and continue execution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.origin" href="#WebSockets.origin"><code>WebSockets.origin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>origin(request) =&gt; String</code> Convenience function for checking which server / port address the client claims its code was downloaded from. The resource path can be found with target(req). E.g.</p><pre><code class="language-julia">function gatekeeper(req, ws)
    orig = WebSockets.origin(req)
        if startswith(orig, &quot;http://localhost&quot;) || startswith(orig, &quot;http://127.0.0.1&quot;)
            handlewebsocket(ws)
        end
    end
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.read" href="#Base.read"><code>Base.read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read(ws::WebSocket)</code></pre><p>Typical use:     msg = String(read(ws)) Read one non-control message from a WebSocket. Any control messages that are read will be handled by the handle<em>control</em>frame function. Only the data (contents/body/payload) of the message will be returned as a Vector{UInt8}.</p><p>This function will not return until a full non-control message has been read.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.read_frame" href="#WebSockets.read_frame"><code>WebSockets.read_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Read a frame: turn bytes from the websocket into a WebSocketFragment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.readframe_nonblocking" href="#WebSockets.readframe_nonblocking"><code>WebSockets.readframe_nonblocking</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For the closing handshake, we won&#39;t wait indefinitely for non-responsive clients. Returns a throwaway frame if the socket happens to be empty</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.readguarded" href="#WebSockets.readguarded"><code>WebSockets.readguarded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>readguarded(websocket) =&gt; (Vector, Bool)</code></p><p>Return (data::Vector, true)         or         (Vector{UInt8}(), false)</p><p>The peer can potentially disconnect at any time, but no matter the cause you will usually just want to exit your websocket handling function when you can&#39;t write to it.</p><p>E.g.</p><pre><code class="language-julia">while true
    data, success = readguarded(websocket)
    !success &amp;&amp; break
    println(String(data))
end</code></pre><p>To check the errors (if you get any), temporarily set loging min_level to Logging.debug, e.g:</p><pre><code class="language-julia">using WebSockets, Logging
global_logger(WebSocketLogger(stderr, Logging.Debug));</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.send_ping" href="#WebSockets.send_ping"><code>WebSockets.send_ping</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a ping message, optionally with data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.send_pong" href="#WebSockets.send_pong"><code>WebSockets.send_pong</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Send a pong message, optionally with data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.serve" href="#WebSockets.serve"><code>WebSockets.serve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">WebSockets.serve(server::ServerWS, port)
WebSockets.serve(server::ServerWS, host, port)
WebSockets.serve(server::ServerWS, host, port, verbose)</code></pre><p>A wrapper for WebSockets.HTTP.listen. Puts any caught error and stacktrace on the server.out channel. To stop a running server, put a byte on the server.in channel.</p><pre><code class="language-julia">    @async WebSockets.serve(server, &quot;127.0.0.1&quot;, 8080)</code></pre><p>After a suspected connection task failure:</p><pre><code class="language-julia">    if isready(myserver_WS.out)
        stack_trace = take!(myserver_WS.out)
    end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.shouldlog_default" href="#WebSockets.shouldlog_default"><code>WebSockets.shouldlog_default</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Early filtering of messages based on message id limits, silencing of HTTP.Servers if defined</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.string_with_env_ws" href="#WebSockets.string_with_env_ws"><code>WebSockets.string_with_env_ws</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Context-aware text representation of the first argument to logging macros. Made easily available for overloading on specific types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.subprotocol" href="#WebSockets.subprotocol"><code>WebSockets.subprotocol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>subprotocol(request) =&gt; String</code></p><p>Convenience function for reading upgrade request subprotocol. Acceptable subprotocols need to be predefined using addsubproto(myprotocol). No other subprotocols will pass the handshake. E.g.</p><pre><code class="language-julia">WebSockets.addsubproto(&quot;instructions&quot;)
WebSockets.addsubproto(&quot;relay_backend&quot;)
function gatekeeper(req, ws)
    subpr = WebSockets.subprotocol(req)
    if subpr == &quot;instructions&quot;
        instructions(ws)
    elseif subpr == &quot;relay_backend&quot;
        relay_backend(ws)
    end
end</code></pre><p>Then, in browser javascript (or equivalent with Julia WebSockets.open( , ))</p><pre><code class="language-javascript">function load(){
    var wsuri = document.URL.replace(&quot;http:&quot;, &quot;ws:&quot;);
    ws1 = new WebSocket(wsuri, &quot;instructions&quot;);
    ws2 = new WebSocket(wsuri, &quot;relay_backend&quot;);
    ws1.onmessage = function(e){doinstructions(e.data)};
    ...
    } // load</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.target" href="#WebSockets.target"><code>WebSockets.target</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>target(request) =&gt; String</code></p><p>Convenience function for reading upgrade request target.     E.g.</p><pre><code class="language-julia">    function gatekeeper(req, ws)
        if target(req) == &quot;/gamepad&quot;
            @spawnat 2 gamepad(ws)
        elseif target(req) == &quot;/console&quot;
            @spawnat 3 console(ws)
            ...
        end
    end</code></pre><p>Then, in browser javascript (or equivalent with Julia WebSockets.open( , ))</p><pre><code class="language-javascript">function load(){
    var wsuri = document.URL.replace(&quot;http:&quot;, &quot;ws:&quot;);
    ws1 = new WebSocket(wsuri + &quot;/gamepad&quot;);
    ws2 = new WebSocket(wsuri + &quot;/console&quot;);
    ws3 = new WebSocket(wsuri + &quot;/graphics&quot;);
    ws4 = new WebSocket(wsuri + &quot;/audiochat&quot;);
    ws1.onmessage = function(e){vibrate(e.data)}
    } // load
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.upgrade" href="#WebSockets.upgrade"><code>WebSockets.upgrade</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Used as part of a server definition. Call this if is_upgrade(stream.message) returns true.</p><p>Responds to a WebSocket handshake request. If the connection is acceptable, sends status code 101 and headers according to RFC 6455, then calls user&#39;s handler function f with the connection wrapped in a WebSocket instance.</p><p>f(ws)           is called with the websocket and no client info f(headers, ws)  also receives a dictionary of request headers for added security measures</p><p>On exit from f, a closing handshake is started. If the client is not currently reading (which is a blocking function), this side will reset the underlying connection (ECONNRESET) after a reasonable amount of time and continue execution.</p><p>If the upgrade is not accepted, responds to client with &#39;400&#39;.</p><p>e.g. server with local error handling. Combine with WebSocket.open example.</p><pre><code class="language-julia">using WebSockets

badgatekeeper(reqdict, ws) = sqrt(-2)
handlerequest(req) = WebSockets.Response(501)
const SERVERREF = Ref{Base.IOServer}()
try
    WebSockets.HTTP.listen(&quot;127.0.0.1&quot;, UInt16(8000), tcpref = SERVERREF) do stream
        if WebSockets.is_upgrade(stream.message)
            WebSockets.upgrade(badgatekeeper, stream)
        else
            WebSockets.handle_request(handlerequest, stream)
        end
    end
catch err
    showerror(stderr, err)
    println.(stacktrace(catch_backtrace())[1:4])
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write" href="#Base.write"><code>Base.write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Write text data; will be sent as one frame.</p></div></div><div><div><p>Write binary data; will be sent as one frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.write_fragment" href="#WebSockets.write_fragment"><code>WebSockets.write_fragment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">write_fragment(io, islast, opcode, hasmask, data::Array{UInt8})</code></pre><p>Write the raw frame to a bufffer. Websocket|client must set &#39;hasmask&#39;.</p></div></div></section><pre><code class="language-none">WebSockets.write_ping</code></pre><pre><code class="language-none">WebSockets.write_pong</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WebSockets.writeguarded" href="#WebSockets.writeguarded"><code>WebSockets.writeguarded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>writeguarded(websocket, message) =&gt; Bool</code></p><p>Return true if write is successful, false if not. The peer can potentially disconnect at any time, but no matter the cause you will usually just want to exit your websocket handling function when you can&#39;t write to it.</p><p>To check the errors (if you get any), temporarily set loging min_level to Logging.debug, e.g:</p><pre><code class="language-julia">using WebSockets, Logging
global_logger(WebSocketLogger(stderr, Logging.Debug));</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
