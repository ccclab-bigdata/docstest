<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · WebSockets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>WebSockets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Getting-started-1">Getting started</a></li><li><a class="toctext" href="#What-can-you-do-with-it?-1">What can you do with it?</a></li><li><a class="toctext" href="#Other-tips-1">Other tips</a></li><li><a class="toctext" href="#Further-development-and-comments-1">Further development and comments</a></li><li><a class="toctext" href="#Errors-after-updating?-1">Errors after updating?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="WebSockets.jl-1" href="#WebSockets.jl-1">WebSockets.jl</a></h1><p><em>Release version</em>:</p><p><a href="http://pkg.julialang.org/?pkg=WebSockets&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/WebSockets_0.6.svg" alt="WebSockets"/></a> <a href="https://travis-ci.org/JuliaWeb/WebSockets.jl"><img src="https://travis-ci.org/JuliaWeb/WebSockets.jl.svg" alt="Build Status"/></a>&lt;!– Enable coverage when https://github.com/JuliaCI/Coverage.jl/issues/187 is resolved. <a href="https://coveralls.io/r/JuliaWeb/WebSockets.jl"><img src="https://img.shields.io/coveralls/JuliaWeb/WebSockets.jl.svg" alt="Coverage Status"/></a>a –&gt;</p><p>Test coverage 96%</p><p><em>Development version</em>:</p><p><a href="http://pkg.julialang.org/?pkg=WebSockets&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/WebSockets_0.6.svg?branch?master" alt="WebSockets"/></a> <a href="https://travis-ci.org/JuliaWeb/WebSockets.jl"><img src="https://travis-ci.org/JuliaWeb/WebSockets.jl.svg?branch=master" alt="Build Status"/></a> &lt;!–<a href="https://coveralls.io/r/JuliaWeb/WebSockets.jl?branch=master"><img src="https://img.shields.io/coveralls/JuliaWeb/WebSockets.jl.svg?branch=master" alt="Coverage Status"/></a> <a href="https://ci.appveyor.com/project/JuliaWeb/WebSockets-jl"><img src="https://ci.appveyor.com/api/projects/status/github/JuliaWeb/WebSockets.jl?svg=true&amp;branch=master" alt="Appveyor"/></a>–&gt;</p><p>Test coverage 96%</p><p>Server and client side <a href="https://tools.ietf.org/html/rfc6455">Websockets</a> protocol in Julia. WebSockets is a small overhead message protocol layered over <a href="https://tools.ietf.org/html/rfc793">TCP</a>. It uses HTTP(S) for establishing the connections.</p><h2><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h2><p>In the package manager, add WebSockets. Then <a href="https://docs.julialang.org/en/v1/stdlib/REPL/index.html#The-Julian-mode-1">paste</a> this into a REPL:</p><pre><code class="language-julia">julia&gt; using WebSockets

julia&gt; serverWS = ServerWS(handler = (req) -&gt; WebSockets.Response(200), wshandler = (ws_server) -&gt; (writeguarded(ws_server, &quot;Hello&quot;); readguarded(ws_server)))
ServerWS(handler=&lt;span&gt;#&lt;/span&gt;7(req), wshandler=&lt;span&gt;#&lt;/span&gt;8(ws_server))

julia&gt; ta = @async WebSockets.with_logger(WebSocketLogger()) do
                WebSockets.serve(serverWS, port = 8000)
            end
Task (runnable) @0x000000000fc91cd0

julia&gt; WebSockets.HTTP.get(&quot;http://127.0.0.1:8000&quot;)
HTTP.Messages.Response:
&quot;&quot;&quot;
HTTP/1.1 200 OK
Transfer-Encoding: chunked

&quot;&quot;&quot;

julia&gt; WebSockets.open(&quot;ws://127.0.0.1:8000&quot;) do ws_client
                  data, success = readguarded(ws_client)
                  if success
                      println(stderr, ws_client, &quot; received:&quot;, String(data))
                  end
              end;
WebSocket(client, CONNECTED) received:Hello

WARNING: Workqueue inconsistency detected: popfirst!(Workqueue).state != :queued

julia&gt; put!(serverWS.in, &quot;close!&quot;)
&quot;close!&quot;

julia&gt; ta
Task (done) @0x000000000fc91cd0
</code></pre><p>Access inline documentation and have a look at the examples folder! The testing files also demonstrate a variety of uses. Benchmarks show examples of websockets and servers running on separate processes, as oposed to asyncronous tasks.</p><h3><a class="nav-anchor" id="About-this-package-1" href="#About-this-package-1">About this package</a></h3><p>Originally from 2013 and Julia 0.2, the WebSockets API has remained largely unchanged. It now depends on <a href="https://github.com/JuliaWeb/HTTP.jl">HTTP.jl</a> for establishing the http connections. That package is in ambitious development, and most functionality of this package is already implemented directly in HTTP.jl.</p><p>This more downstream package may lag behind the latest version of HTTP.jl, and in so doing perhaps avoid some borderline bugs. This is why the examples and tests do not import HTTP methods directly, but rely on the methods imported in this package. E.g. by using <code>WebSockets.HTTP.listen</code> instead of <code>HTTP.listen</code> you may possibly be using the previous release of package HTTP. The imported HTTP version is capped so as to avoid possible issues when new versions of HTTP are released.</p><h2><a class="nav-anchor" id="What-can-you-do-with-it?-1" href="#What-can-you-do-with-it?-1">What can you do with it?</a></h2><ul><li>read and write between entities you can program or know about</li><li>serve an svg file to the web browser, containing javascript for connecting back through a websocket, adding two-way interaction with graphics</li><li>enjoy very low latency and high speed with a minimum of edge case coding</li><li>implement your own &#39;if X send this, Y do that&#39; subprotocols. Typically, one subprotocol for sensor input, another for graphics or text to a display.</li><li>use registered <a href="https://www.iana.org/assignments/websocket/websocket.xml#version-number">websocket subprotocols</a> for e.g. remote controlled hardware</li><li>relay user interaction to backend simulations</li><li>build a network including browser clients and long-running relay servers</li><li>use convenience functions for gatekeeping</li></ul><p>WebSockets are well suited for user interactions via a browser or <a href="https://electronjs.org/">cross-platform applications</a> like electron. Workload and development time can be moved off Julia resources, error checking code can be reduced. Preferably use websockets for passing arguments, not code, between compiled functions on both sides; it has both speed and security advantages over passing code for evaluation.</p><h2><a class="nav-anchor" id="Other-tips-1" href="#Other-tips-1">Other tips</a></h2><ul><li>putting http handlers and websocket coroutines (&#39;handlers&#39;) in the same process can be a security advantage. It is good practice to modify web page responses to include time-limited tokens in the address, the wsuri.</li><li>Since <code>read</code> and <code>readguared</code> are blocking functions, you can easily end up reading indefinitely from any side of the connection. See the <code>close</code> function code for an example of non-blocking read with a timeout.</li><li>Compression is not currenlty implemented, but easily adaptable. On local connections, there&#39;s probably not much to gain.</li><li>If you worry about milliseconds, TCP quirks like &#39;warm-up&#39; time with low transmission speed after a pause can be avoided with heartbeats. High-performance examples are missing.</li><li>Garbage collection increases message latency at semi-random intervals, as is visible in  benchmark plots. Benchmarks should include non-memory-allocating examples.</li><li>Time prefixes in e.g. <code>@wslog</code> is not accurate. To accurately track sequences of logging messages, include the time in your logging message.</li></ul><h5><a class="nav-anchor" id="Debugging-with-WebSockets.ServeWS-servers-1" href="#Debugging-with-WebSockets.ServeWS-servers-1">Debugging with WebSockets.ServeWS servers</a></h5><p>Error messages from run-time are directed to a .out channel. See inline docs: ?Websockets.serve. When using <code>readguarded</code> or <code>writeguarded</code>, errors are logged with <code>@debug</code> statements. Set the logging level of the logger you use to &#39;Debug&#39;, as in &#39;examples/count<em>with</em>logger.jl&#39;.</p><h5><a class="nav-anchor" id="Debugging-with-WebSockets.HTTP.listen-servers-1" href="#Debugging-with-WebSockets.HTTP.listen-servers-1">Debugging with WebSockets.HTTP.listen servers</a></h5><p>Error messages may be sent as messages to the client. This may not be good practice if you&#39;re serving pages to the internet, but nice while developing locally. There are some inline comments in the source code which may be of help.</p><h2><a class="nav-anchor" id="Further-development-and-comments-1" href="#Further-development-and-comments-1">Further development and comments</a></h2><p>The issues section is used for planning development: Contributions are welcome.</p><ul><li>Version 1.3 integrates <code>WebSocketLogger</code>. It closely resembles <code>ConsoleLogger</code> from the Julia standard library. Additional features: see inline docs and &#39;examples/count<em>with</em>logger.jl&#39;. With this closer integration with Julia&#39;s core logging functionality, we also introduce <code>@debug</code> statements in <code>readguarded</code> and <code>writeguarded</code> (as well as when receiving &#39;ping&#39; or &#39;pong&#39;). The functions still return a boolean to indicate failure, but return no reason except the logger messages.</li><li>The /benchmark folder contain some code that is not currently working, pending logging facilities.</li><li>Alternative Julia packages: <a href="https://github.com/dandeliondeathray/DandelionWebSockets.jl">DandelionWebSockets</a> and the direct implementation in <a href="https://github.com/JuliaWeb/HTTP.jl">HTTP.jl</a>.</li></ul><h2><a class="nav-anchor" id="Errors-after-updating?-1" href="#Errors-after-updating?-1">Errors after updating?</a></h2><h3><a class="nav-anchor" id="To-version-1.3.0-1" href="#To-version-1.3.0-1">To version 1.3.0</a></h3><p>WebSockets additionaly exports WebSocketLogger, @wslog, Wslog.</p><h3><a class="nav-anchor" id="To-version-1.1.0-1" href="#To-version-1.1.0-1">To version 1.1.0</a></h3><p>This version is driven by large restructuring in HTTP.jl. We import more functions and types into WebSockets, e.g., WebSockets.Request. The main interface does not, intentionally, change, except for &#39;origin&#39;, which should now be qualified as WebSockets.origin.</p><h3><a class="nav-anchor" id="To-version-0.5.0-1" href="#To-version-0.5.0-1">To version 0.5.0</a></h3><p>The introduction of client side websockets to this package in version 0.5.0 may require changes in your code:</p><ul><li>The <code>WebSocket.id</code> field is no longer supported. You can generate unique counters by code similar to &#39;bencmark/functions<em>open</em>browsers.jl&#39; COUNTBROWSER.</li><li>You may want to modify you error handling code. Examine WebSocketsClosedError.message.</li><li>You may want to use <code>readguarded</code> and <code>writeguarded</code> to save on error handling code.</li><li><code>Server</code> -&gt; <code>WebSockets.ServerWS</code></li><li><code>WebSocketHandler</code> -&gt; <code>WebSockets.WebsocketHandler</code> (or just pass a function without wrapper)</li><li><code>HttpHandler</code>-&gt; <code>HTTP.HandlerFunction</code> (or just pass a function without wrapper)</li><li><code>run</code> -&gt; <code>serve</code></li><li><code>Response</code> -&gt; <code>HTTP.Response</code></li><li><code>Request</code> -&gt; <code>HTTP.Response</code></li></ul><p>You may also want to consider using <code>target</code>, <code>orgin</code>and <code>subprotocol</code>, which  are compatible with both of the types above.</p><pre><code class="language-none">::::::::::::::::
::            ::
::  Made at   ::
::            ::
::::::::::::::::
       ::
 Recurse Center
::::::::::::::::</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
