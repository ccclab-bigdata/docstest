<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CompScienceMeshes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CompScienceMeshes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">CompScienceMeshes.AbstractMapper</code></pre><pre><code class="language-none">CompScienceMeshes.CompScienceMeshes</code></pre><pre><code class="language-none">CompScienceMeshes.FlippedMesh</code></pre><pre><code class="language-none">CompScienceMeshes.FlippedMeshCellIterator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.GSubdMesh" href="#CompScienceMeshes.GSubdMesh"><code>CompScienceMeshes.GSubdMesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GSubdMesh(mesh::Mesh)

Given a linear polygon mesh, construct a data structure for subdivision surfaces</code></pre></div></div></section><pre><code class="language-none">CompScienceMeshes.JacobMatrix33</code></pre><pre><code class="language-none">CompScienceMeshes.Jacob_inv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.Loop_subdivision" href="#CompScienceMeshes.Loop_subdivision"><code>CompScienceMeshes.Loop_subdivision</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Loop_subdivsion(mesh) -&gt; refinement</code></pre><p>Construct a refinement of <code>mesh</code> by Loop subdivision scheme. Every face is subdived into four small faces and use weights to smooth the surface.</p><p>Only defined for 2D meshes.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.Mesh</code></pre><pre><code class="language-none">CompScienceMeshes.MeshPointNM</code></pre><pre><code class="language-none">CompScienceMeshes.Pt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.RectangleChart" href="#CompScienceMeshes.RectangleChart"><code>CompScienceMeshes.RectangleChart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>N: universe dimension D: manifold dimension T: coordinate type</p></div></div></section><pre><code class="language-none">CompScienceMeshes.RectangleNBD</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.ReferenceSimplex" href="#CompScienceMeshes.ReferenceSimplex"><code>CompScienceMeshes.ReferenceSimplex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReferenceSimplex{Dimension, CoordType, NumVertices}</code></pre><p>This domain is defined to bootstrap the quadrature generation strategy. The generic definition of numquads on a chart pulls back to the domain. For a limit set of reference domains, explicit quadrature rules are defined. The weights and points are then pushed forward to the configuaration space element over which integration is desired.</p><p>For more details see the implementation in quadpoints.jl</p></div></div></section><pre><code class="language-none">CompScienceMeshes.SEdge</code></pre><pre><code class="language-none">CompScienceMeshes.SElement</code></pre><pre><code class="language-none">CompScienceMeshes.SVertex</code></pre><pre><code class="language-none">CompScienceMeshes.SW</code></pre><pre><code class="language-none">CompScienceMeshes.SW1</code></pre><pre><code class="language-none">CompScienceMeshes.SW10</code></pre><pre><code class="language-none">CompScienceMeshes.SW11</code></pre><pre><code class="language-none">CompScienceMeshes.SW12</code></pre><pre><code class="language-none">CompScienceMeshes.SW13</code></pre><pre><code class="language-none">CompScienceMeshes.SW14</code></pre><pre><code class="language-none">CompScienceMeshes.SW15</code></pre><pre><code class="language-none">CompScienceMeshes.SW16</code></pre><pre><code class="language-none">CompScienceMeshes.SW17</code></pre><pre><code class="language-none">CompScienceMeshes.SW18</code></pre><pre><code class="language-none">CompScienceMeshes.SW19</code></pre><pre><code class="language-none">CompScienceMeshes.SW2</code></pre><pre><code class="language-none">CompScienceMeshes.SW20</code></pre><pre><code class="language-none">CompScienceMeshes.SW21</code></pre><pre><code class="language-none">CompScienceMeshes.SW22</code></pre><pre><code class="language-none">CompScienceMeshes.SW23</code></pre><pre><code class="language-none">CompScienceMeshes.SW24</code></pre><pre><code class="language-none">CompScienceMeshes.SW25</code></pre><pre><code class="language-none">CompScienceMeshes.SW26</code></pre><pre><code class="language-none">CompScienceMeshes.SW27</code></pre><pre><code class="language-none">CompScienceMeshes.SW28</code></pre><pre><code class="language-none">CompScienceMeshes.SW29</code></pre><pre><code class="language-none">CompScienceMeshes.SW3</code></pre><pre><code class="language-none">CompScienceMeshes.SW30</code></pre><pre><code class="language-none">CompScienceMeshes.SW4</code></pre><pre><code class="language-none">CompScienceMeshes.SW5</code></pre><pre><code class="language-none">CompScienceMeshes.SW6</code></pre><pre><code class="language-none">CompScienceMeshes.SW7</code></pre><pre><code class="language-none">CompScienceMeshes.SW8</code></pre><pre><code class="language-none">CompScienceMeshes.SW9</code></pre><pre><code class="language-none">CompScienceMeshes.SX</code></pre><pre><code class="language-none">CompScienceMeshes.SX1</code></pre><pre><code class="language-none">CompScienceMeshes.SX10</code></pre><pre><code class="language-none">CompScienceMeshes.SX11</code></pre><pre><code class="language-none">CompScienceMeshes.SX12</code></pre><pre><code class="language-none">CompScienceMeshes.SX13</code></pre><pre><code class="language-none">CompScienceMeshes.SX14</code></pre><pre><code class="language-none">CompScienceMeshes.SX15</code></pre><pre><code class="language-none">CompScienceMeshes.SX16</code></pre><pre><code class="language-none">CompScienceMeshes.SX17</code></pre><pre><code class="language-none">CompScienceMeshes.SX18</code></pre><pre><code class="language-none">CompScienceMeshes.SX19</code></pre><pre><code class="language-none">CompScienceMeshes.SX2</code></pre><pre><code class="language-none">CompScienceMeshes.SX20</code></pre><pre><code class="language-none">CompScienceMeshes.SX21</code></pre><pre><code class="language-none">CompScienceMeshes.SX22</code></pre><pre><code class="language-none">CompScienceMeshes.SX23</code></pre><pre><code class="language-none">CompScienceMeshes.SX24</code></pre><pre><code class="language-none">CompScienceMeshes.SX25</code></pre><pre><code class="language-none">CompScienceMeshes.SX26</code></pre><pre><code class="language-none">CompScienceMeshes.SX27</code></pre><pre><code class="language-none">CompScienceMeshes.SX28</code></pre><pre><code class="language-none">CompScienceMeshes.SX29</code></pre><pre><code class="language-none">CompScienceMeshes.SX3</code></pre><pre><code class="language-none">CompScienceMeshes.SX30</code></pre><pre><code class="language-none">CompScienceMeshes.SX4</code></pre><pre><code class="language-none">CompScienceMeshes.SX5</code></pre><pre><code class="language-none">CompScienceMeshes.SX6</code></pre><pre><code class="language-none">CompScienceMeshes.SX7</code></pre><pre><code class="language-none">CompScienceMeshes.SX8</code></pre><pre><code class="language-none">CompScienceMeshes.SX9</code></pre><pre><code class="language-none">CompScienceMeshes.SY</code></pre><pre><code class="language-none">CompScienceMeshes.SY1</code></pre><pre><code class="language-none">CompScienceMeshes.SY10</code></pre><pre><code class="language-none">CompScienceMeshes.SY11</code></pre><pre><code class="language-none">CompScienceMeshes.SY12</code></pre><pre><code class="language-none">CompScienceMeshes.SY13</code></pre><pre><code class="language-none">CompScienceMeshes.SY14</code></pre><pre><code class="language-none">CompScienceMeshes.SY15</code></pre><pre><code class="language-none">CompScienceMeshes.SY16</code></pre><pre><code class="language-none">CompScienceMeshes.SY17</code></pre><pre><code class="language-none">CompScienceMeshes.SY18</code></pre><pre><code class="language-none">CompScienceMeshes.SY19</code></pre><pre><code class="language-none">CompScienceMeshes.SY2</code></pre><pre><code class="language-none">CompScienceMeshes.SY20</code></pre><pre><code class="language-none">CompScienceMeshes.SY21</code></pre><pre><code class="language-none">CompScienceMeshes.SY22</code></pre><pre><code class="language-none">CompScienceMeshes.SY23</code></pre><pre><code class="language-none">CompScienceMeshes.SY24</code></pre><pre><code class="language-none">CompScienceMeshes.SY25</code></pre><pre><code class="language-none">CompScienceMeshes.SY26</code></pre><pre><code class="language-none">CompScienceMeshes.SY27</code></pre><pre><code class="language-none">CompScienceMeshes.SY28</code></pre><pre><code class="language-none">CompScienceMeshes.SY29</code></pre><pre><code class="language-none">CompScienceMeshes.SY3</code></pre><pre><code class="language-none">CompScienceMeshes.SY30</code></pre><pre><code class="language-none">CompScienceMeshes.SY4</code></pre><pre><code class="language-none">CompScienceMeshes.SY5</code></pre><pre><code class="language-none">CompScienceMeshes.SY6</code></pre><pre><code class="language-none">CompScienceMeshes.SY7</code></pre><pre><code class="language-none">CompScienceMeshes.SY8</code></pre><pre><code class="language-none">CompScienceMeshes.SY9</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.SegmentedAxis" href="#CompScienceMeshes.SegmentedAxis"><code>CompScienceMeshes.SegmentedAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This type conforms to the mesh interface but is specialised for the case of a segment of the real axis subdived in equally sized intervals. Typical use is a discretisation of the time axis.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.Simplex</code></pre><pre><code class="language-none">CompScienceMeshes.SphereChart</code></pre><pre><code class="language-none">CompScienceMeshes.SphereNeighborhood</code></pre><pre><code class="language-none">CompScienceMeshes.ThetaPhiPlane</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss105a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss105b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss105w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss120a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss120b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss120w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss12a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss12b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss12c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss12w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss13a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss13b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss13c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss13w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss1a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss1b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss1c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss1w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss36a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss36b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss36w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss3a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss3b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss3c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss3w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss400a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss400b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss400w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss4a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss4b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss4c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss4w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss6a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss6b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss6c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss6w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss78a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss78b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss78w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss7a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss7b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss7c</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss7w</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss900a</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss900b</code></pre><pre><code class="language-none">CompScienceMeshes.Trianglegauss900w</code></pre><pre><code class="language-none">CompScienceMeshes.WeightPointValue</code></pre><pre><code class="language-none">CompScienceMeshes.__init__</code></pre><pre><code class="language-none">CompScienceMeshes._normals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.barycentric" href="#CompScienceMeshes.barycentric"><code>CompScienceMeshes.barycentric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the barycentric coordinates of <code>mp</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.barycentric_refinement" href="#CompScienceMeshes.barycentric_refinement"><code>CompScienceMeshes.barycentric_refinement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barycentric refinement(mesh) -&gt; refined_mesh</code></pre><p>Create the mesh obtained by inserting an extra vertex in the barycenters of all cells and recusively creating fine cells by connecting the barycenter of a k-cell to the already constructed refined (k-1)-cells on its boundary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.barytocart" href="#CompScienceMeshes.barytocart"><code>CompScienceMeshes.barytocart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barytocart(simplex, uv)</code></pre><p>Returns the point in the simplex with barycentric coordinates uv</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.bisecting_refinement" href="#CompScienceMeshes.bisecting_refinement"><code>CompScienceMeshes.bisecting_refinement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bisecting_refinement(mesh) -&gt; refinement</code></pre><p>Construct a refinement of <code>mesh</code> by inserting a new vertex on every existing edge. Every face is subdived in four small faces.</p><p>Only defined for 2D meshes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.boundary" href="#CompScienceMeshes.boundary"><code>CompScienceMeshes.boundary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">boundary(mesh)</code></pre><p>Returns the boundary of <code>mesh</code> as a mesh of lower dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.boundingbox" href="#CompScienceMeshes.boundingbox"><code>CompScienceMeshes.boundingbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the boundingbox of a patch in terms of its center and halfsize.</p><pre><code class="language-none">function boundingbox{U,D,C,N,T}(p::Simplex{U,D,C,N,T}) -&gt; center, halfsize</code></pre></div></div></section><pre><code class="language-none">CompScienceMeshes.boxspline_func</code></pre><pre><code class="language-none">CompScienceMeshes.boxspline_func_der</code></pre><pre><code class="language-none">CompScienceMeshes.boxspline_func_der2</code></pre><pre><code class="language-none">CompScienceMeshes.cartesian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.carttobary" href="#CompScienceMeshes.carttobary"><code>CompScienceMeshes.carttobary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">carttobary(simplex, point) -&gt; barycoords</code></pre><p>Compute the barycentric coordinates on &#39;simplex&#39; of &#39;point&#39;.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.cellarray</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.cellpairs" href="#CompScienceMeshes.cellpairs"><code>CompScienceMeshes.cellpairs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pairs = cellpairs(mesh, edges, dropjunctionpair=false)</code></pre><p>Given a mesh and set of oriented edges from that mesh (as generated by <code>skeleton</code>),     <code>cellpairs</code> will generate a 2 x K matrix, where K is the number of pairs     and each column contains a pair of indices in the cell array of <code>mesh</code> that have     one of the supplied edges in common.</p><p>Returns an array of pairs of indices, each pair corresponding to a pair of adjacent faces.</p><p>(If the mesh is oriented, the first row of <code>facepairs</code> will contain indices to the cell     for which the corresponding edge has a positive relative orientation.</p><p>If a edge lies on the boundary of the mesh, and only has one neighboring cell, the     second row of <code>facepairs</code> will contain <code>-k</code> with <code>k</code> the local index of the corresponding     edge in its neighboring triangle.</p><p>If an edge has more than two neighboring cells (i.e. the edge is on a junction),     all possible pairs of cells that have the junction edge in common are supplied. if     <code>dropjunctionpair == false</code> then one of the possible pairs of cells is not recorded.     This is done to avoid the creation of linearly dependent basis functions in the     construction of boundary element methods for Maxwell&#39;s equations.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.cells" href="#CompScienceMeshes.cells"><code>CompScienceMeshes.cells</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cells(mesh)</code></pre><p>Return an iterable collection containing the cells making up the mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.celltype" href="#CompScienceMeshes.celltype"><code>CompScienceMeshes.celltype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">celltype(mesh)</code></pre><p>Returns the type of the index tuples stored in the mesh.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.center</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.chart" href="#CompScienceMeshes.chart"><code>CompScienceMeshes.chart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chart(mesh, cell) -&gt; cell_chart</code></pre><p>Return a chart describing the supplied cell of <code>mesh</code>.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.clipconvex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.connectivity" href="#CompScienceMeshes.connectivity"><code>CompScienceMeshes.connectivity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connectivity(faces, cells, op=sign)</code></pre><p>Create a sparse matrix <code>D</code> of size <code>numcells(cells)</code> by <code>numcells(faces)</code> that contiains the connectivity info of the mesh. In particular <code>D[m,k]</code> is <code>op(r)</code> where <code>r</code> is the local index of face <code>k</code> in cell <code>m</code>. The sign of <code>r</code> is positive or negative depending on the relative orientation of face <code>k</code> in cell <code>m</code>.</p><p>For <code>op=sign</code>, the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.coordtype" href="#CompScienceMeshes.coordtype"><code>CompScienceMeshes.coordtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coordtype(mesh)</code></pre><p>Returns <code>eltype(vertextype(mesh))</code></p></div></div><div><div><pre><code class="language-none">coordtype(simplex)</code></pre><p>Return coordinate type used by simplex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.dimension" href="#CompScienceMeshes.dimension"><code>CompScienceMeshes.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dim = dimension(mesh)</code></pre><p>Returns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.</p></div></div><div><div><pre><code class="language-none">dimension(simplex)</code></pre><p>Return the manifold dimension of the simplex.</p></div></div><div><div><pre><code class="language-none">dimension(simplex)</code></pre><p>Return the manifold dimension of the simplex.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.domain</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.euclidianbasis" href="#CompScienceMeshes.euclidianbasis"><code>CompScienceMeshes.euclidianbasis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>euclidian_basis(type, dim)</p><p>Returns the origin and default unit vectors for Euclidian space of dimension dim</p></div></div></section><pre><code class="language-none">CompScienceMeshes.eval</code></pre><pre><code class="language-none">CompScienceMeshes.find_edges</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.find_neighbor" href="#CompScienceMeshes.find_neighbor"><code>CompScienceMeshes.find_neighbor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_neighbor(faces,edges,F,EdgesIndices,orientation,Sedges)

Given a face find out the neighbor elements (share edge) and vertices.</code></pre></div></div></section><pre><code class="language-none">CompScienceMeshes.find_neighbor2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.flip" href="#CompScienceMeshes.flip"><code>CompScienceMeshes.flip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flip(cell)</code></pre><p>Change the orientation of a cell by interchanging the first to indices.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.flipmesh</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.flipmesh!" href="#CompScienceMeshes.flipmesh!"><code>CompScienceMeshes.flipmesh!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flipmesh!(mesh)</code></pre><p>Change the orientation of a mesh</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.fliporientation" href="#CompScienceMeshes.fliporientation"><code>CompScienceMeshes.fliporientation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fliporientation(mesh)</code></pre><p>Returns a mesh of opposite orientation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.fliporientation!" href="#CompScienceMeshes.fliporientation!"><code>CompScienceMeshes.fliporientation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fliporientation(mesh)</code></pre><p>Changes the mesh orientation inplace. If non-orientatble, undefined.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.gauss_points</code></pre><pre><code class="language-none">CompScienceMeshes.gauss_quad_linear</code></pre><pre><code class="language-none">CompScienceMeshes.get_shape_curl</code></pre><pre><code class="language-none">CompScienceMeshes.getcommonedge</code></pre><pre><code class="language-none">CompScienceMeshes.getelementVertices</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.inclosure_gpredicate" href="#CompScienceMeshes.inclosure_gpredicate"><code>CompScienceMeshes.inclosure_gpredicate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Geometric predicate for determining in log(N) complexity if a the image of a chart is in the closure of mesh <code>γ</code>.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.index" href="#CompScienceMeshes.index"><code>CompScienceMeshes.index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">index(i1, i2, ...) -&gt; ids</code></pre><p>Create a tuple of vertex indices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.interior_tpredicate" href="#CompScienceMeshes.interior_tpredicate"><code>CompScienceMeshes.interior_tpredicate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a predicate that can be used to check wheter an edge is interior to a surface (true) or on its boundary (false). This predicate is based on combinatorics. In particular it expects as argument a tuple of indices pointing into the vertex buffer of <code>mesh</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.intersection" href="#CompScienceMeshes.intersection"><code>CompScienceMeshes.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersect(chartA, chartB) -&gt; [chart1, chart2, ...]</code></pre><p>Compute the intersection of two charts of equal dimension.</p><p>Compute an array of charts such that the disjoint union of those charts produces the intersection of the two charts provided as inputs. In particular the sum of integrals over the returned charts will equal the integral over the intersection of the two given charts.</p></div></div><div><div><pre><code class="language-none">intersection(triangleA, triangle B)</code></pre><p>ATTENTION: currently the implementation for triangles assumes that one of the triangles is contained in the other.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.intersectlines" href="#CompScienceMeshes.intersectlines"><code>CompScienceMeshes.intersectlines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersectline(a,b,p,q)</code></pre><p>Computes the intersection of the lines (in a 2D space) defined by points [a,b] and [p,q]</p></div></div></section><pre><code class="language-none">CompScienceMeshes.irreg_shapefun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.isinclosure" href="#CompScienceMeshes.isinclosure"><code>CompScienceMeshes.isinclosure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isinclosure(simplex, point) -&gt; Bool</code></pre><p>Determine whether point is in the closure of simplex. False positives are possible for points just outside of the simplex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.isinside" href="#CompScienceMeshes.isinside"><code>CompScienceMeshes.isinside</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isinside(chart, point) -&gt; Bool</code></pre><p>Returns true is the given point is in the image of the given chart, false otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.jacobian" href="#CompScienceMeshes.jacobian"><code>CompScienceMeshes.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A number defines a neighborhood in euclidian space</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.leftof" href="#CompScienceMeshes.leftof"><code>CompScienceMeshes.leftof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inside(p,a,b)</code></pre><p>Determines is p is on the interior side of the segment b of the boundary, assuming that the boundary is oriented counter-clockwise.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.legendre</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.load_gid_mesh" href="#CompScienceMeshes.load_gid_mesh"><code>CompScienceMeshes.load_gid_mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_gid_mesh(filename) -&gt; mesh</code></pre></div></div><div><div><pre><code class="language-none">load_gid_mesh(stream) -&gt;mesh</code></pre></div></div></section><pre><code class="language-none">CompScienceMeshes.map_ids</code></pre><pre><code class="language-none">CompScienceMeshes.mapper</code></pre><pre><code class="language-none">CompScienceMeshes.matrix_A</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.mesh" href="#CompScienceMeshes.mesh"><code>CompScienceMeshes.mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mesh(type, mdim, udim=mdim+1)</code></pre><p>Returns an empty mesh with <code>coordtype</code> equal to <code>type</code>, of dimension <code>mdim</code> and embedded in a universe of dimension <code>udim</code></p></div></div></section><pre><code class="language-none">CompScienceMeshes.meshcircle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.meshcuboid" href="#CompScienceMeshes.meshcuboid"><code>CompScienceMeshes.meshcuboid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meshcuboid(width, height, length, delta)</code></pre><p>Creates a mesh for a cuboid of width (along the x-axis) <code>width</code>, height (along     the y-axis) <code>height</code> and length (along the z-axis) <code>length</code> by parsing a .geo script     incorporating these parameters into the GMSH mesher.</p><p>The target edge size is <code>delta</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.meshrectangle" href="#CompScienceMeshes.meshrectangle"><code>CompScienceMeshes.meshrectangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meshrectangle(width, height, delta, udim)</code></pre><p>Create a mesh for a rectangle of width (along the x-axis) <code>width</code> and height (along     the y-axis) <code>height</code>.</p><p>The target edge size is <code>delta</code> and the dimension of the     embedding universe is <code>udim</code> (&gt;= 2).</p><p>The mesh is oriented such that the normal is pointing down. This is subject to change.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.meshsegment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.meshsphere" href="#CompScienceMeshes.meshsphere"><code>CompScienceMeshes.meshsphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meshsphere(radius, delta)</code></pre><p>Create a mesh of a sphere of radius <code>radius</code> by parsing a .geo script     incorporating these parameters into the GMSH mesher.</p><p>The target edge size is <code>delta</code>.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.minmaxdist</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.mirror" href="#CompScienceMeshes.mirror"><code>CompScienceMeshes.mirror</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mirror(vertex, normal, anchor)</code></pre><p>Mirror vertex across a plane defined by its normal and a containing point.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.mirrormesh</code></pre><pre><code class="language-none">CompScienceMeshes.mirrormesh!</code></pre><pre><code class="language-none">CompScienceMeshes.neighborhood</code></pre><pre><code class="language-none">CompScienceMeshes.normal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.numcells" href="#CompScienceMeshes.numcells"><code>CompScienceMeshes.numcells</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numcells(mesh)</code></pre><p>Returns the number of cells in the mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.numvertices" href="#CompScienceMeshes.numvertices"><code>CompScienceMeshes.numvertices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numvertices(mesh)</code></pre><p>Returns the number of vertices in the mesh.</p><p><em>Note</em>: this is the number of vertices in the vertex buffer and might include floatin vertices or vertices not appearing in any cell. In other words the following is not necessarily true:</p><pre><code class="language-julia">    numvertices(mesh) == numcells(skeleton(mesh,0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.octree" href="#CompScienceMeshes.octree"><code>CompScienceMeshes.octree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Store the k-cells of a mesh in an octree.</p><pre><code class="language-none">function octree{U,D,T}(mesh::Mesh{U,D,T}, kcells::Array{Int,2})</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.overlap" href="#CompScienceMeshes.overlap"><code>CompScienceMeshes.overlap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute whether two flat patches of the same dimension overlap or not</p></div></div><div><div><p>Compute whether two segments in 3D space overlap</p></div></div><div><div><p>Compute whether two triangles in 3D space overlap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.overlap_gpredicate" href="#CompScienceMeshes.overlap_gpredicate"><code>CompScienceMeshes.overlap_gpredicate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">overlap_gpredicate(γ::Mesh) -&gt; (patch -&gt; Bool)</code></pre><p>Create a predicate that for a given patch determinees if it overlaps with the provided target mesh <code>γ</code>.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.parametric</code></pre><pre><code class="language-none">CompScienceMeshes.patch</code></pre><pre><code class="language-none">CompScienceMeshes.pickmatrx_reg</code></pre><pre><code class="language-none">CompScienceMeshes.pickmtrx_irreg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.point" href="#CompScienceMeshes.point"><code>CompScienceMeshes.point</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">point(xs...)</code></pre><p>Create point of default type (double precision coordinates)</p></div></div><div><div><pre><code class="language-none">point(type, xs...)</code></pre><p>Create point of default type and supplied precision for the coordinates</p></div></div></section><pre><code class="language-none">CompScienceMeshes.pow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.quadpoints" href="#CompScienceMeshes.quadpoints"><code>CompScienceMeshes.quadpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pw = quadpoints(chart, rule)</code></pre><p>Returns a collection of (point, weight) tuples corresponding to the numerical quadrature <code>rule</code> defined on the domain of <code>chart</code>. The weights returned take into account the Jacobian determinant resulting from mapping from the reference domain to the configuration space.</p><p>Functions can be integrated like:</p><pre><code class="language-julia">PW = quadpoints(chart, rule)
I = sum(pw[2]*f(pw[1]) for pw in PW)</code></pre></div></div><div><div><pre><code class="language-none">quadpoints(refspace, charts, rules)</code></pre><p>Computed a matrix of vectors containing (weight, point, value) triples that can be used in numerical integration over the elements described by the charts. Internally, this method used <code>quadpoints(chart, rule)</code> to retrieve the points and weights for a certain quadrature rule over <code>chart</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.read_TRI_mesh" href="#CompScienceMeshes.read_TRI_mesh"><code>CompScienceMeshes.read_TRI_mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_TRI_mesh(filename) -&gt; mesh::Mesh</code></pre></div></div><div><div><pre><code class="language-none">read_TRI_mesh(mesh_filename) -&gt; mesh::Mesh</code></pre><p>Imports a surface mesh (stored in an ASCII file named <code>mesh_filename</code>) into a     <code>Mesh</code> object (i.e. node list and element list).</p><p>NOTE: The contents of <code>mesh_filename</code> must include the file extension, and the     file must be stored in the current directory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.read_gmsh_mesh" href="#CompScienceMeshes.read_gmsh_mesh"><code>CompScienceMeshes.read_gmsh_mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_gmsh_mesh(filename) -&gt; mesh::Mesh</code></pre></div></div><div><div><pre><code class="language-none">read_gmsh_mesh(iostream) -&gt; mesh::Mesh</code></pre><p>Reads the mesh nodes and elements stored in the input .msh file (<code>io</code>, output by GMSH)     into arrays of node vectors and vertex vectors respectively.</p><p>Returns an object <code>mesh</code> of type <code>Mesh</code>, comprising both vector arrays.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.readmesh" href="#CompScienceMeshes.readmesh"><code>CompScienceMeshes.readmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readmesh(filename)</code></pre><p>Reads a mesh in <em>in</em> format from <code>filename</code>. The format follows:</p><pre><code class="language-none">1
V C
x1_1    x1_2    ... x1_U
x2_1    x2_2    ... x2_U
...
xV_1    xV_2    ... xV_U
i1_1    i1_2    ... i1_D1
i2_1    i2_2    ... i2_D1
...
iC_1    iC_2    ... iC_D1</code></pre><p>where <code>U</code> is the universedimension of the mesh, <code>D1</code> the dimension of the mesh plus one, <code>V</code> the number of vertices, and <code>C</code> the number of cells in the mesh.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.reg_shapefun</code></pre><pre><code class="language-none">CompScienceMeshes.relorientation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.restriction" href="#CompScienceMeshes.restriction"><code>CompScienceMeshes.restriction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">restriction(submesh, supermesh)</code></pre><p>Computes the restriction matrix relative to a submesh <code>submesh</code> of <code>supermesh</code>.</p><p>The restriction matrix has size <code>(m,n)</code>, where</p><pre><code class="language-none">m == numcells(submesh)
n == numcells(supermesh)</code></pre><p>It has entries <code>1</code> at location <code>[i,j]</code> iff cell <code>i</code> of submesh equals cell <code>j</code> of supermesh. The remaining entries are zero.</p><p>This matrix is referred to as the restriction matrix because if it acts on an array of samples taken at the cells of <code>supermesh</code> is selects out the samples in the cells that are retained in <code>submesh</code>, taking into account any renumbering. Likewise, its transpose is sometimes referred to as the extension-by-zero operator because it maps arrays of samples taken in the cells of <code>submesh</code> into an array of samples taken in the cells of <code>supermesh</code> by inserting zeros at cells that were not retained in <code>submesh</code>.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.ring</code></pre><pre><code class="language-none">CompScienceMeshes.rings</code></pre><pre><code class="language-none">CompScienceMeshes.rotate</code></pre><pre><code class="language-none">CompScienceMeshes.rotate!</code></pre><pre><code class="language-none">CompScienceMeshes.shape_function</code></pre><pre><code class="language-none">CompScienceMeshes.shape_function_der</code></pre><pre><code class="language-none">CompScienceMeshes.shape_function_der2</code></pre><pre><code class="language-none">CompScienceMeshes.shapeder</code></pre><pre><code class="language-none">CompScienceMeshes.shapeders</code></pre><pre><code class="language-none">CompScienceMeshes.shapefuns</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.simplex" href="#CompScienceMeshes.simplex"><code>CompScienceMeshes.simplex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplex(vertices)
simplex(v1, v2, ...)
simplex(vertices, Val{D})</code></pre><p>Build a D-dimensional simplex. The vertices can be passed in an array (static or dynamic), or supplied separately. If the length of the array is not part of its type, the speed of the construction can be improved by supplying an extra Val{D} argument. In case it is not clear from the context whether the vertex array is dynamically or statically sized, use the third form as it will not incur notable performance hits.</p><p>Note that D is the dimension of the simplex, i.e. the number of vertices supplied minus one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.skeleton" href="#CompScienceMeshes.skeleton"><code>CompScienceMeshes.skeleton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skeleton(mesh, dim)</code></pre><p>Returns a mesh comprising the <code>dim</code>-dimensional sub cells of <code>mesh</code>. For example to retrieve the edges of a given surface <code>mesh</code>,</p><pre><code class="language-julia">edges = skelton(mesh, 1)</code></pre></div></div><div><div><pre><code class="language-none">skeleton(pred, mesh, dim)</code></pre><p>Like <code>skeleton(mesh, dim)</code>, but only cells for which <code>pred(cell)</code> returns true are withheld.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.sqgauss</code></pre><pre><code class="language-none">CompScienceMeshes.subdMesh</code></pre><pre><code class="language-none">CompScienceMeshes.subd_chart</code></pre><pre><code class="language-none">CompScienceMeshes.subd_point</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.submesh" href="#CompScienceMeshes.submesh"><code>CompScienceMeshes.submesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a mesh on the same vertexbuffer as the input mesh. The submesh will be a mesh of dimension k containing all the k-cells that are in mesh and that fulfill the predicate pred.</p><p><code>pred</code> is a function with signature <code>pred(cell) -&gt; Bool</code> returning true if the simplex is to be added to the submesh under construction.</p></div></div><div><div><pre><code class="language-none">submesh(selection, mesh)</code></pre><p>Create a submesh from <code>mesh</code> comprising those elements that overlap with elements from <code>selection</code>. It is assumed that <code>selection</code> and <code>mesh</code> have the same dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.sutherlandhodgman" href="#CompScienceMeshes.sutherlandhodgman"><code>CompScienceMeshes.sutherlandhodgman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sutherlandhodgman(subject, clipper)</code></pre><p>Compute the intersection of two coplanar triangles, potentially embedded in a higher dimensional space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.sutherlandhodgman2d" href="#CompScienceMeshes.sutherlandhodgman2d"><code>CompScienceMeshes.sutherlandhodgman2d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sutherlandhodgman2d(subject,clipper)</code></pre><p>Computes the intersection of the coplanar triangles subject and clipper.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.tangents</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.translate" href="#CompScienceMeshes.translate"><code>CompScienceMeshes.translate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">translate(mesh, v)</code></pre><p>Creates a new mesh by translating <code>mesh</code> over vector <code>v</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.translate!" href="#CompScienceMeshes.translate!"><code>CompScienceMeshes.translate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">translate!(mesh, v)</code></pre><p>Translates <code>mesh</code> over vector <code>v</code> inplace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.trgauss" href="#CompScienceMeshes.trgauss"><code>CompScienceMeshes.trgauss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trgauss(n) -&gt; (u,w)</code></pre><p>Returns the n-th triangle quadrature rule. Returns a Matrix u of size (Q,2) with Q the number of quadrature points and a Vector w of size (Q,) containing the quadrature weights.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.triangleGaussA</code></pre><pre><code class="language-none">CompScienceMeshes.triangleGaussB</code></pre><pre><code class="language-none">CompScienceMeshes.triangleGaussW</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.universedimension" href="#CompScienceMeshes.universedimension"><code>CompScienceMeshes.universedimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">universedimension(mesh)</code></pre><p>Returns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.</p></div></div><div><div><p>universedimension(p)</p><p>Return the dimension of the universe in which <code>p</code> is embedded.</p></div></div></section><pre><code class="language-none">CompScienceMeshes.vertexarray</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.vertextocellmap" href="#CompScienceMeshes.vertextocellmap"><code>CompScienceMeshes.vertextocellmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vertextocellmap(mesh) -&gt; vertextocells, numneighbors</code></pre><p>Computed an V×M array <code>vertextocells</code> where V is the number of vertices and M is the maximum number of cells adjacent to any given vertex such that <code>vertextocells[v,i]</code> is the index in the cells of <code>mesh</code> of the <code>i</code>th cell adjacent to teh <code>v</code>-th vertex. <code>numneighbors[v]</code> contains the number of cells adjacent to the <code>v</code>-th vertex.</p><p>This method allows e.g. for the efficient computation of the connectivity matrix of the mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.vertextype" href="#CompScienceMeshes.vertextype"><code>CompScienceMeshes.vertextype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vt = vertextype(mesh)</code></pre><p>Returns type of the vertices used to define the cells of the mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.vertices" href="#CompScienceMeshes.vertices"><code>CompScienceMeshes.vertices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vertices(mesh)</code></pre><p>Returns an indexable iterable to the vertices of the mesh</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.volume" href="#CompScienceMeshes.volume"><code>CompScienceMeshes.volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">volume(simplex)</code></pre><p>Return the volume of the simplex.</p></div></div><div><div><p>A tuple of points, aka an interval behaves trivially like a chart</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.weld" href="#CompScienceMeshes.weld"><code>CompScienceMeshes.weld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weld(mesh1, mesh2, ...) -&gt; welded_mesh</code></pre><p>Build a mesh by welding or pasting together the inputs. Vertices from different meshes that coincide up to the tolerance will be merged into one. The order cells appear in the output mesh is equal to the order in the inputs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CompScienceMeshes.writemesh" href="#CompScienceMeshes.writemesh"><code>CompScienceMeshes.writemesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writemesh(mesh, filename)</code></pre><p>Write <code>mesh</code> to <code>filename</code> in the <em>in</em> format (see <code>readmesh</code>).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
