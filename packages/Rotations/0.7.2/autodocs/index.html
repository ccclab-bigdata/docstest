<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Rotations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Rotations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.AngleAxis" href="#Rotations.AngleAxis"><code>Rotations.AngleAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct AngleAxis{T} &lt;: Rotation{3,T}
AngleAxis(Θ, x, y, z)</code></pre><p>A 3×3 rotation matrix parameterized by a 3D rotation by angle θ about an arbitrary axis <code>[x, y, z]</code>.</p><p>Note that the axis is not unique for θ = 0, and that this parameterization does not continuously map the neighbourhood of the null rotation (and therefore might not be suitable for autodifferentation and optimization purposes).</p><p>Note: by default, the constructor will renormalize the input so that the axis has length 1 (x² + y² + z² = 1).</p><p>Renormalization can be skipped by passing <code>false</code> as an additional constructor argument, in which case the user provides the guarantee that the input arguments represent a normalized rotation axis. Operations on an <code>AngleAxis</code> with a rotation axis that does not have unit norm, created by skipping renormalization in this fashion, are not guaranteed to do anything sensible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.Quat" href="#Rotations.Quat"><code>Rotations.Quat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct Quat{T} &lt;: Rotation{3,T}
Quat(w, x, y, z)</code></pre><p>The <code>Quat</code> type is a 3×3 matrix representation of a normalized quaternion. They allow you to transparently use (fast) quaternion algebra to store, compose and invert 3D rotations, while at the same time letting you apply rotations through matrix-vector multiplication.</p><p>Note: by default, the constructor will renormalize the input so that the quaternion has length 1 (w² + x² + y² + z² = 1), and the rotation matrix is orthogonal.</p><p>Renormalization can be skipped by passing <code>false</code> as an additional constructor argument, in which case the user provides the guarantee that the input arguments represent a unit quaternion. Operations on an unnormalized <code>Quat</code>, created by skipping renormalization in this fashion, are not guaranteed to do anything sensible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RodriguesVec" href="#Rotations.RodriguesVec"><code>Rotations.RodriguesVec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RodriguesVec{T} &lt;: Rotation{3,T}
RodriguesVec(sx, sy, sz)</code></pre><p>Rodrigues vector parameterization of a 3×3 rotation matrix. The direction of the vector [sx, sy, sz] defines the axis of rotation, and the rotation angle is given by its norm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotMatrix" href="#Rotations.RotMatrix"><code>Rotations.RotMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotMatrix{N,T} &lt;: Rotation{N,T}</code></pre><p>A statically-sized, N×N unitary (orthogonal) matrix.</p><p>Note: the orthonormality of the input matrix is <em>not</em> checked by the constructor.</p></div></div></section><pre><code class="language-none">Rotations.RotMatrix2</code></pre><pre><code class="language-none">Rotations.RotMatrix3</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotX" href="#Rotations.RotX"><code>Rotations.RotX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotX{T} &lt;: Rotation{3,T}
RotX(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the X axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXY" href="#Rotations.RotXY"><code>Rotations.RotXY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXY{T} &lt;: Rotation{3,T}
RotXY(theta_x, theta_y)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_y</code> about the Y axis, followed by a rotation by <code>theta_x</code> about the X axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXYX" href="#Rotations.RotXYX"><code>Rotations.RotXYX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXYX{T} &lt;: Rotation{3,T}
RotXYX(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; XYX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXYZ" href="#Rotations.RotXYZ"><code>Rotations.RotXYZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXYZ{T} &lt;: Rotation{3,T}
RotXYZ(theta1, theta2, theta3)
RotXYZ(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; XYZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XYZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXZ" href="#Rotations.RotXZ"><code>Rotations.RotXZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXZ{T} &lt;: Rotation{3,T}
RotXZ(theta_x, theta_z)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_z</code> about the Z axis, followed by a rotation by <code>theta_x</code> about the X axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXZX" href="#Rotations.RotXZX"><code>Rotations.RotXZX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXZX{T} &lt;: Rotation{3,T}
RotXZX(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; XZX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotXZY" href="#Rotations.RotXZY"><code>Rotations.RotXZY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotXZY{T} &lt;: Rotation{3,T}
RotXZY(theta1, theta2, theta3)
RotXZY(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; XZY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XZY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotY" href="#Rotations.RotY"><code>Rotations.RotY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotY{T} &lt;: Rotation{3,T}
RotY(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the Y axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYX" href="#Rotations.RotYX"><code>Rotations.RotYX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYX{T} &lt;: Rotation{3,T}
RotYX(theta_y, theta_x)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_x</code> about the X axis, followed by a rotation by <code>theta_y</code> about the Y axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYXY" href="#Rotations.RotYXY"><code>Rotations.RotYXY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYXY{T} &lt;: Rotation{3,T}
RotYXY(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; YXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYXZ" href="#Rotations.RotYXZ"><code>Rotations.RotYXZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYXZ{T} &lt;: Rotation{3,T}
RotYXZ(theta1, theta2, theta3)
RotYXZ(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; YXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YXZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYZ" href="#Rotations.RotYZ"><code>Rotations.RotYZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYZ{T} &lt;: Rotation{3,T}
RotYZ(theta_y, theta_z)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_z</code> about the Z axis, followed by a rotation by <code>theta_y</code> about the Y axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYZX" href="#Rotations.RotYZX"><code>Rotations.RotYZX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYZX{T} &lt;: Rotation{3,T}
RotYZX(theta1, theta2, theta3)
RotYZX(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; YZX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YZX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotYZY" href="#Rotations.RotYZY"><code>Rotations.RotYZY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotYZY{T} &lt;: Rotation{3,T}
RotYZY(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; YXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZ" href="#Rotations.RotZ"><code>Rotations.RotZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZ{T} &lt;: Rotation{3,T}
RotZ(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the Z axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZX" href="#Rotations.RotZX"><code>Rotations.RotZX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZX{T} &lt;: Rotation{3,T}
RotZX(theta_z, theta_x)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_x</code> about the X axis, followed by a rotation by <code>theta_z</code> about the Z axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZXY" href="#Rotations.RotZXY"><code>Rotations.RotZXY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZXY{T} &lt;: Rotation{3,T}
RotZXY(theta1, theta2, theta3)
RotZXY(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; ZXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZXY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZXZ" href="#Rotations.RotZXZ"><code>Rotations.RotZXZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZXZ{T} &lt;: Rotation{3,T}
RotZXZ(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; ZXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZY" href="#Rotations.RotZY"><code>Rotations.RotZY</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZY{T} &lt;: Rotation{3,T}
RotZY(theta_z, theta_y)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_y</code> about the Y axis, followed by a rotation by <code>theta_z</code> about the Z axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZYX" href="#Rotations.RotZYX"><code>Rotations.RotZYX</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZYX{T} &lt;: Rotation{3,T}
RotZYX(theta1, theta2, theta3)
RotZYX(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; ZYX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZYX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.RotZYZ" href="#Rotations.RotZYZ"><code>Rotations.RotZYZ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct RotZYZ{T} &lt;: Rotation{3,T}
RotZYZ(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; ZXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.Rotation" href="#Rotations.Rotation"><code>Rotations.Rotation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type Rotation{N,T} &lt;: StaticMatrix{N,N,T}</code></pre><p>An abstract type representing <code>N</code>-dimensional rotations. More abstractly, they represent unitary (orthogonal) <code>N</code>×<code>N</code> matrices.</p></div></div></section><pre><code class="language-none">Rotations.Rotations</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.SPQuat" href="#Rotations.SPQuat"><code>Rotations.SPQuat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct SPQuat{T} &lt;: Rotation{3,T}
SPQuat(x, y, z)</code></pre><p>An <code>SPQuat</code> is a 3D rotation matrix represented by the &quot;stereographic projection&quot; of a normalized quaternion (shortened to &quot;SPQuat&quot;), which is a 3-element parametrization of a unit quaternion Q formed by the intersection of a line from [-1,0,0,0] to Q, with a plane containing the origin and with normal direction [1,0,0,0]. This is a compact representation of rotations where the derivitives of the rotation matrix&#39;s elements w.r.t. the SPQuat parameters are rational functions (making them useful for optimization).</p><p>See:</p><pre><code class="language-none">[1] &quot;A Recipe on the Parameterization of Rotation Matrices for Non-Linear Optimization using Quaternions&quot;,
Terzakis, Culverhouse, Bugmann, Sharma, Sutton,
MIDAS technical report, 2011
http://www.tech.plymouth.ac.uk/sme/springerusv/2011/publications_files/Terzakis%20et%20al%202012,%20A%20Recipe%20on%20the%20Parameterization%20of%20Rotation%20Matrices...MIDAS.SME.2012.TR.004.pdf

Note 1: the singularity (origin) has been moved from [0,0,0,-1] in Ref[1] to [-1,0,0,0], so the 0 rotation quaternion [1,0,0,0] maps to [0,0,0] as opposed of to [1,0,0].
Note 2: the quaternion rotation ambiguity q = -q means there will be a rotation with ||SPQuat|| &lt;= 1 and an equivilent rotation with ||SPQuat|| &gt; 1.  This package
        uses the solution with ||SPQuat|| &lt;= 1
Note 3: it is safe to assume that the corresponding matrix is orthogonal/unitary for any input x, y, z.</code></pre></div></div></section><pre><code class="language-none">Rotations._sincos</code></pre><pre><code class="language-none">Rotations.d_cross</code></pre><pre><code class="language-none">Rotations.eval</code></pre><pre><code class="language-none">Rotations.eye</code></pre><pre><code class="language-none">Rotations.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.isrotation" href="#Rotations.isrotation"><code>Rotations.isrotation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isrotation(r)
isrotation(r, tol)</code></pre><p>Check whether <code>r</code> is a 3×3 rotation matrix, where <code>r * r&#39;</code> is within <code>tol</code> of the identity matrix (using the Frobenius norm). (<code>tol</code> defaults to <code>1000 * eps(eltype(r))</code>.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.jacobian" href="#Rotations.jacobian"><code>Rotations.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian(::Type{output_param}, R::input_param)</code></pre><p>Returns the jacobian for transforming from the input rotation parameterization to the output parameterization, centered at the value of R.</p><pre><code class="language-none">jacobian(R::rotation_type, X::AbstractVector)</code></pre><p>Returns the jacobian for rotating the vector X by R.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.perpendicular_vector" href="#Rotations.perpendicular_vector"><code>Rotations.perpendicular_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perpendicular_vector(vec)</code></pre><p>Compute a vector perpendicular to <code>vec</code> by switching the two elements with largest absolute value, flipping the sign of the second largest, and setting the remaining element to zero.</p></div></div></section><pre><code class="language-none">Rotations.rotation_angle</code></pre><pre><code class="language-none">Rotations.rotation_axis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Rotations.rotation_between" href="#Rotations.rotation_between"><code>Rotations.rotation_between</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotation_between(from, to)</code></pre><p>Compute the quaternion that rotates vector <code>from</code> so that it aligns with vector <code>to</code>, along the geodesic (shortest path).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
