var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#CrossMappings.jl-1",
    "page": "Readme",
    "title": "CrossMappings.jl",
    "category": "section",
    "text": "A Julia package for detecting causal relations between time series using various cross mapping measures. Provides essential functionality for CausalityTools.jl."
},

{
    "location": "autodocs/#CrossMappings.ccm",
    "page": "Docstrings",
    "title": "CrossMappings.ccm",
    "category": "function",
    "text": "ccm(driver,\n        response,\n        timeseries_lengths;\n        kwargs...) -> Vector{Vector{Float64}}\n\nAlgorithm\n\nCompute the cross mapping between a driver series and a response series over different timeseries_lengths.\n\nArguments\n\ndriver: The data series representing the putative driver process.\nresponse: The data series representing the putative response process.\ntimeseries_lengths: Time series length(s) for which to compute the   cross mapping(s).\n\nKeyword arguments to crossmap\n\ndim: The dimension of the state space reconstruction (delay embedding)   constructed from the response series. Default is dim = 3.\nτ: The embedding lag for the delay embedding constructed from response.   Default is τ = 1.\nν: The prediction lag to use when predicting scalar values of driver   fromthe delay embedding of response.   ν > 0 are forward lags (causal; driver\'s past influences response\'s future),   and ν < 0 are backwards lags (non-causal; driver\'s\' future influences   response\'s past). Adjust the prediction lag if you   want to performed lagged ccm   (Ye et al., 2015).   Default is ν = 0, as in   Sugihara et al. (2012).   Note: The sign of the lag ν is organized to conform with the conventions in   TransferEntropy.jl, and is opposite to the convention used in the   rEDM package   (Ye et al., 2016).\nlibsize: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are n_reps)?\nn_reps: The number of times we draw a library of libsize points from the   delay embedding of response and try to predict driver values. Equivalently,   how many times do we cross map for this value of libsize?   Default is n_reps = 100.\nreplace: Sample delay embedding points with replacement? Default is replace = true.\nexclusion_radius: How many temporal neighbors of the delay embedding   point response_embedding(t) to exclude when searching for neighbors to   determine weights for predicting the scalar point driver(t + ν).   Default is exclusion_radius = 0.\nwhich_is_surr: Which data series should be replaced by a surrogate   realization of the type given by surr_type? Must be one of the   following: :response, :driver, :none, :both.   Default is :none.\nsurr_func: A valid surrogate function from TimeseriesSurrogates.jl.\ntree_type: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   BruteTree, KDTree or BallTree.\ndistance_metric: An instance of a Metric from Distances.jl. BallTree and BruteTree work with any Metric.   KDTree only works with the axis aligned metrics Euclidean, Chebyshev,   Minkowski and Cityblock. Default is metric = Euclidean() (note the instantiation of the metric).\ncorrespondence_measure: The function that computes the correspondence   between actual values of driver and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is correspondence_measure = StatsBase.cor, which returns values on -1 1.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of 1 means perfect prediction.   Sugihara et al. (2012)   also proposes to use the root mean square deviation, for which a value of 0 would   be perfect prediction.\n\nReferences\n\nSugihara, George, et al. \"Detecting causality in complex ecosystems.\" Science (2012): 1227079. http://science.sciencemag.org/content/early/2012/09/19/science.1227079\n\nYe, Hao, et al. \"Distinguishing time-delayed causal interactions using convergent cross mapping.\" Scientific Reports 5 (2015): 14750. https://www.nature.com/articles/srep14750\n\nYe, H., et al. \"rEDM: Applications of empirical dynamic modeling from time series.\" R Package Version 0.4 7 (2016). https://cran.r-project.org/web/packages/rEDM/index.html\n\n\n\n\n\n"
},

{
    "location": "autodocs/#CrossMappings.ccm_with_summary",
    "page": "Docstrings",
    "title": "CrossMappings.ccm_with_summary",
    "category": "function",
    "text": "ccm_with_summary(driver,\n        response,\n        timeseries_lengths;\n        average_measure::Symbol = :median,\n        uncertainty_measure::Symbol = :quantile,\n        quantiles = [0.327, 0.673],\n        kwargs...)\n\nAlgorithm\n\nCompute the cross mapping between a driver series and a response series over different timeseries_lengths and return summary statistics of the results.\n\nArguments\n\ndriver: The data series representing the putative driver process. \nresponse: The data series representing the putative response process.\ntimeseries_lengths: Time series length(s) for which to compute the   cross mapping(s).\n\nSummary keyword arguments\n\naverage_measure: Either :median or :mean. Default is :median.\nuncertainty_measure: Either :quantile or :std. Default is :quantile.\nquantiles: Compute uncertainty over quantile(s) if uncertainty_measure   is :quantile. Default is [0.327, 0.673], roughly corresponding to 1s for   normally distributed data.\n\nKeyword arguments to crossmap\n\ndim: The dimension of the state space reconstruction (delay embedding)   constructed from the response series. Default is dim = 3.\nτ: The embedding lag for the delay embedding constructed from response.   Default is τ = 1.\nν: The prediction lag to use when predicting scalar values of driver   fromthe delay embedding of response.   ν > 0 are forward lags (causal; driver\'s past influences response\'s future),   and ν < 0 are backwards lags (non-causal; driver\'s\' future influences   response\'s past). Adjust the prediction lag if you   want to performed lagged ccm   (Ye et al., 2015).   Default is ν = 0, as in   Sugihara et al. (2012).   Note: The sign of the lag ν is organized to conform with the conventions in   TransferEntropy.jl, and is opposite to the convention used in the   rEDM package   (Ye et al., 2016).\nlibsize: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are n_reps)?\nn_reps: The number of times we draw a library of libsize points from the   delay embedding of response and try to predict driver values. Equivalently,   how many times do we cross map for this value of libsize?   Default is n_reps = 100.\nreplace: Sample delay embedding points with replacement? Default is replace = true.\nexclusion_radius: How many temporal neighbors of the delay embedding   point response_embedding(t) to exclude when searching for neighbors to   determine weights for predicting the scalar point driver(t + ν).   Default is exclusion_radius = 0.\nwhich_is_surr: Which data series should be replaced by a surrogate   realization of the type given by surr_type? Must be one of the   following: :response, :driver, :none, :both.   Default is :none.\nsurr_func: A valid surrogate function from TimeseriesSurrogates.jl.\ntree_type: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   BruteTree, KDTree or BallTree.\ndistance_metric: An instance of a Metric from Distances.jl. BallTree and BruteTree work with any Metric.   KDTree only works with the axis aligned metrics Euclidean, Chebyshev,   Minkowski and Cityblock. Default is metric = Euclidean() (note the instantiation of the metric).\ncorrespondence_measure: The function that computes the correspondence   between actual values of driver and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is correspondence_measure = StatsBase.cor, which returns values on -1 1.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of 1 means perfect prediction.   Sugihara et al. (2012)   also proposes to use the root mean square deviation, for which a value of 0 would   be perfect prediction.\n\nReferences\n\nSugihara, George, et al. \"Detecting causality in complex ecosystems.\" Science (2012): 1227079. http://science.sciencemag.org/content/early/2012/09/19/science.1227079\n\nYe, Hao, et al. \"Distinguishing time-delayed causal interactions using convergent cross mapping.\" Scientific Reports 5 (2015): 14750. https://www.nature.com/articles/srep14750\n\nYe, H., et al. \"rEDM: Applications of empirical dynamic modeling from time series.\" R Package Version 0.4 7 (2016). https://cran.r-project.org/web/packages/rEDM/index.html\n\n\n\n\n\n"
},

{
    "location": "autodocs/#CrossMappings.convergentcrossmap",
    "page": "Docstrings",
    "title": "CrossMappings.convergentcrossmap",
    "category": "function",
    "text": "convergentcrossmap(driver,\n        response,\n        timeseries_lengths;\n        summarise::Bool = true,\n        average_measure::Symbol = :median,\n        uncertainty_measure::Symbol = :quantile,\n        quantiles = [0.327, 0.673],\n        kwargs...)\n\nAlgorithm\n\nCompute the cross mapping between a driver series and a response series over different timeseries_lengths. If summarise = true, then call ccm_with_summary. If summarise = false, then call ccm (returns raw crossmap skills).\n\nArguments\n\ndriver: The data series representing the putative driver process.\nresponse: The data series representing the putative response process.\ntimeseries_lengths: Time series length(s) for which to compute the   cross mapping(s).\n\nSummary keyword arguments\n\nsummarise: Should cross map skills be summarised for each time series length?   Default is summarise = true.\naverage_measure: Either :median or :mean. Default is :median.\nuncertainty_measure: Either :quantile or :std. Default is :quantile.\nquantiles: Compute uncertainty over quantile(s) if uncertainty_measure   is :quantile. Default is [0.327, 0.673], roughly corresponding to 1s for   normally distributed data.\n\nKeyword arguments to crossmap\n\ndim: The dimension of the state space reconstruction (delay embedding)   constructed from the response series. Default is dim = 3.\nτ: The embedding lag for the delay embedding constructed from response.   Default is τ = 1.\nν: The prediction lag to use when predicting scalar values of driver   fromthe delay embedding of response.   ν > 0 are forward lags (causal; driver\'s past influences response\'s future),   and ν < 0 are backwards lags (non-causal; driver\'s\' future influences   response\'s past). Adjust the prediction lag if you   want to performed lagged ccm   (Ye et al., 2015).   Default is ν = 0, as in   Sugihara et al. (2012).   Note: The sign of the lag ν is organized to conform with the conventions in   TransferEntropy.jl, and is opposite to the convention used in the   rEDM package   (Ye et al., 2016).\nlibsize: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are n_reps)?\nn_reps: The number of times we draw a library of libsize points from the   delay embedding of response and try to predict driver values. Equivalently,   how many times do we cross map for this value of libsize?   Default is n_reps = 100.\nreplace: Sample delay embedding points with replacement? Default is replace = true.\nexclusion_radius: How many temporal neighbors of the delay embedding   point response_embedding(t) to exclude when searching for neighbors to   determine weights for predicting the scalar point driver(t + ν).   Default is exclusion_radius = 0.\nwhich_is_surr: Which data series should be replaced by a surrogate   realization of the type given by surr_type? Must be one of the   following: :response, :driver, :none, :both.   Default is :none.\nsurr_func: A valid surrogate function from TimeseriesSurrogates.jl.\ntree_type: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   BruteTree, KDTree or BallTree.\ndistance_metric: An instance of a Metric from Distances.jl. BallTree and BruteTree work with any Metric.   KDTree only works with the axis aligned metrics Euclidean, Chebyshev,   Minkowski and Cityblock. Default is metric = Euclidean() (note the instantiation of the metric).\ncorrespondence_measure: The function that computes the correspondence   between actual values of driver and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is correspondence_measure = StatsBase.cor, which returns values on -1 1.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of 1 means perfect prediction.   Sugihara et al. (2012)   also proposes to use the root mean square deviation, for which a value of 0 would   be perfect prediction.\n\nReferences\n\nSugihara, George, et al. \"Detecting causality in complex ecosystems.\" Science (2012): 1227079. http://science.sciencemag.org/content/early/2012/09/19/science.1227079\n\nYe, Hao, et al. \"Distinguishing time-delayed causal interactions using convergent cross mapping.\" Scientific Reports 5 (2015): 14750. https://www.nature.com/articles/srep14750\n\nYe, H., et al. \"rEDM: Applications of empirical dynamic modeling from time series.\" R Package Version 0.4 7 (2016). https://cran.r-project.org/web/packages/rEDM/index.html\n\n\n\n\n\n"
},

{
    "location": "autodocs/#CrossMappings.crossmap",
    "page": "Docstrings",
    "title": "CrossMappings.crossmap",
    "category": "function",
    "text": "crossmap(driver, response;\n    dim::Int = 3,\n    τ::Int = 1,\n    libsize::Int = 10,\n    replace::Bool = false,\n    n_reps::Int = 100,\n    surr_func::Function = randomshuffle,\n    which_is_surr::Symbol = :none,\n    exclusion_radius::Int = 0,\n    tree_type = NearestNeighbors.KDTree,\n    distance_metric = Distances.Euclidean(),\n    correspondence_measure = StatsBase.cor,\n    ν::Int = 0)\n\nAlgorithm\n\nCompute the cross mapping between a driver series and a response series.\n\nArguments\n\ndriver: The data series representing the putative driver process.\nresponse: The data series representing the putative response process.\ndim: The dimension of the state space reconstruction (delay embedding)   constructed from the response series. Default is dim = 3.\nτ: The embedding lag for the delay embedding constructed from response.   Default is τ = 1.\nν: The prediction lag to use when predicting scalar values of driver   fromthe delay embedding of response.   ν > 0 are forward lags (causal; driver\'s past influences response\'s future),   and ν < 0 are backwards lags (non-causal; driver\'s\' future influences   response\'s past). Adjust the prediction lag if you   want to performed lagged ccm   (Ye et al., 2015).   Default is ν = 0, as in   Sugihara et al. (2012).   Note: The sign of the lag ν is organized to conform with the conventions in   TransferEntropy.jl, and is opposite to the convention used in the   rEDM package   (Ye et al., 2016).\nlibsize: Among how many delay embedding points should we sample time indices   and look for nearest neighbours at each cross mapping realization (of which there   are n_reps)?\nn_reps: The number of times we draw a library of libsize points from the   delay embedding of response and try to predict driver values. Equivalently,   how many times do we cross map for this value of libsize?   Default is n_reps = 100.\nreplace: Sample delay embedding points with replacement? Default is replace = true.\nexclusion_radius: How many temporal neighbors of the delay embedding   point response_embedding(t) to exclude when searching for neighbors to   determine weights for predicting the scalar point driver(t + ν).   Default is exclusion_radius = 0.\nwhich_is_surr: Which data series should be replaced by a surrogate   realization of the type given by surr_type? Must be one of the   following: :response, :driver, :none, :both.   Default is :none.\nsurr_func: A valid surrogate function from TimeseriesSurrogates.jl.\ntree_type: The type of tree to build when looking for nearest neighbors.   Must be a tree type from NearestNeighbors.jl. For now, this is either   BruteTree, KDTree or BallTree.\ndistance_metric: An instance of a Metric from Distances.jl. BallTree and BruteTree work with any Metric.   KDTree only works with the axis aligned metrics Euclidean, Chebyshev,   Minkowski and Cityblock. Default is metric = Euclidean() (note the instantiation of the metric).\ncorrespondence_measure: The function that computes the correspondence   between actual values of driver and predicted values. Can be any   function returning a similarity measure between two vectors of values.   Default is correspondence_measure = StatsBase.cor, which returns values on -1 1.   In this case, any negative values are usually filtered out (interpreted as zero coupling) and   a value of 1 means perfect prediction.   Sugihara et al. (2012)   also proposes to use the root mean square deviation, for which a value of 0 would   be perfect prediction.\n\nReferences\n\nSugihara, George, et al. \"Detecting causality in complex ecosystems.\" Science (2012): 1227079. http://science.sciencemag.org/content/early/2012/09/19/science.1227079\n\nYe, Hao, et al. \"Distinguishing time-delayed causal interactions using convergent cross mapping.\" Scientific Reports 5 (2015): 14750. https://www.nature.com/articles/srep14750\n\nYe, H., et al. \"rEDM: Applications of empirical dynamic modeling from time series.\" R Package Version 0.4 7 (2016). https://cran.r-project.org/web/packages/rEDM/index.html\n\n\n\n\n\n"
},

{
    "location": "autodocs/#CrossMappings.predict_point!",
    "page": "Docstrings",
    "title": "CrossMappings.predict_point!",
    "category": "function",
    "text": "predict_point!(predictions, i, driver_values, u, w, dists, dim)\n\nThe prediction part of the convergent cross mapping algorithm.\n\nAlgorithm\n\nConsider the point in the delay embedding of response point with time index i. Denote the time indices of its nearest neighbors t_1 t_2 ldots t_dim+1. Denote the scalar values of driver at those time indices y_1 y_2 ldots y_dim+1.\n\nGiven distances d_1 d_2 ldots d_dim+1 from the i-th point to its nearest neighbors, we compute the weights w from the cross mapping algorithm (Sugihara et al, 2012; supplementary material, page 4). The weights w and coefficients u are stored in pre-allocated vectors.\n\nA prediction for the observation with time index i in the driver timeseries, call it haty(i), is computed as the sum\n\nhaty(i) = sum_j=1^dim+1 w_j y_j\n\nWe store the prediction haty(i) in position i of the pre-allocated vector predictions.\n\nArguments\n\npredictions: A pre-allocated vector in which to store the   prediction for the scalar value of the driver series.\ni: The time index of the point of the driver series being   predicted. The prediction is stored in predictions[i].\ndriver_values: Let t_1 t_2 ldots t_dim + 1 be   the time indices of   the nearest neighbors to the delay embedding point with time   index i. driver_values contains the scalar values of the   driver series at those time indices.\nu: A pre-allocated vector of length dim + 1 that holds the   normalisation coefficients for computing the weights in the   cross mapping algorithm.\nw: A pre-allocated vector of length dim + 1 that holds   the computed weights for the cross mapping algorithm.\ndists: The distances from delay embedding point with time index   i to its dim + 1 nearest neighbors, in order of increasing   distances.\ndim: The dimension of the delay embedding.\n\nReferences\n\nSugihara, George, et al. \"Detecting causality in complex ecosystems.\" Science (2012): 1227079. http://science.sciencemag.org/content/early/2012/09/19/science.1227079\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "CrossMappings.CrossMappingsCrossMappings.ccmCrossMappings.ccm_with_summaryCrossMappings.convergentcrossmapCrossMappings.crossmapCrossMappings.evalCrossMappings.find_nearest!CrossMappings.includeCrossMappings.predict_point!CrossMappings.validate_average_measureCrossMappings.validate_embedding!CrossMappings.validate_embedding_paramsCrossMappings.validate_exclusion_radius!CrossMappings.validate_libsizeCrossMappings.validate_output_selectionCrossMappings.validate_surrCrossMappings.validate_uncertainty_measure"
},

]}
