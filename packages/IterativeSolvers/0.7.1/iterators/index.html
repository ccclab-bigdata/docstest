<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The iterator approach Â· IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting started</a></li><li><a class="toctext" href="../preconditioning/">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="../linear_systems/cg/">Conjugate Gradients</a></li><li><a class="toctext" href="../linear_systems/chebyshev/">Chebyshev iteration</a></li><li><a class="toctext" href="../linear_systems/minres/">MINRES</a></li><li><a class="toctext" href="../linear_systems/bicgstabl/">BiCGStab(l)</a></li><li><a class="toctext" href="../linear_systems/idrs/">IDR(s)</a></li><li><a class="toctext" href="../linear_systems/gmres/">Restarted GMRES</a></li><li><a class="toctext" href="../linear_systems/lsmr/">LSMR</a></li><li><a class="toctext" href="../linear_systems/lsqr/">LSQR</a></li><li><a class="toctext" href="../linear_systems/stationary/">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="../eigenproblems/power_method/">Power method</a></li><li><a class="toctext" href="../eigenproblems/lobpcg/">LOBPCG</a></li></ul></li><li><a class="toctext" href="../svd/svdl/">SVDL</a></li><li class="current"><a class="toctext" href>The iterator approach</a><ul class="internal"><li><a class="toctext" href="#How-iterators-are-implemented-1">How iterators are implemented</a></li><li><a class="toctext" href="#Example:-avoiding-unnecessary-initialization-1">Example: avoiding unnecessary initialization</a></li><li><a class="toctext" href="#Other-use-cases-1">Other use cases</a></li></ul></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/CONTRIBUTING/">Contributing</a></li><li><a class="toctext" href="../about/license/">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The iterator approach</a></li></ul></nav><hr/><div id="topbar"><span>The iterator approach</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Iterators-1" href="#Iterators-1">Iterative solvers as iterators</a></h1><p>In advanced use cases you might want to access the internal data structures of the solver, inject code to be run after each iteration, have total control over allocations or reduce overhead in initialization. The iterator approach of IterativeSolvers.jl makes this possible.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>At this point <a href="../linear_systems/bicgstabl/#BiCGStabl-1">BiCGStab(l)</a>, <a href="../linear_systems/cg/#CG-1">CG</a>, <a href="../linear_systems/chebyshev/#Chebyshev-1">Chebyshev</a>, <a href="../linear_systems/gmres/#GMRES-1">GMRES</a>, <a href="../linear_systems/minres/#MINRES-1">MINRES</a> and the <a href="../linear_systems/stationary/#Stationary-1">stationary methods</a> are implemented as iterators. However, the package does not yet export the iterators and helper methods themselves.</p></div></div><h2><a class="nav-anchor" id="How-iterators-are-implemented-1" href="#How-iterators-are-implemented-1">How iterators are implemented</a></h2><p>The solvers listed above are basically a thin wrapper around an iterator. Among other things, they initialize the iterable, loop through the iterator and return the result:</p><pre><code class="language-julia">function my_solver!(x, A, b)
    iterable = MySolverIterable(x, A, b)
    for item in iterable end
    return iterable.x
end</code></pre><p>Rather than calling <code>my_solver!(x, A, b)</code>, you could also initialize the iterable yourself and perform the <code>for</code> loop.</p><h2><a class="nav-anchor" id="Example:-avoiding-unnecessary-initialization-1" href="#Example:-avoiding-unnecessary-initialization-1">Example: avoiding unnecessary initialization</a></h2><p>The Jacobi method for <code>SparseMatrixCSC</code> has some overhead in intialization; not only do we need to allocate a temporary vector, we also have to search for indices of the diagonal (and check their values are nonzero). The current implementation initializes the iterable as:</p><pre><code class="language-julia">jacobi_iterable(x, A::SparseMatrixCSC, b; maxiter::Int = 10) =
    JacobiIterable{eltype(x), typeof(x)}(OffDiagonal(A, DiagonalIndices(A)), x, similar(x), b, maxiter)</code></pre><p>Now if you apply Jacobi iteration multiple times with the same matrix for just a few iterations, it makes sense to initialize the iterable only once and reuse it afterwards:</p><pre><code class="language-julia">A = sprand(10_000, 10_000, 10 / 10_000) + 20I
b1 = rand(10_000)
b2 = rand(10_000)
x = rand(10_000)

my_iterable = IterativeSolvers.jacobi_iterable(x, A, b1, maxiter = 4)

for item in my_iterable 
    println(&quot;Iteration for rhs 1&quot;)
end

@show norm(b1 - A * x) / norm(b1)

# Copy the next right-hand side into the iterable
copyto!(my_iterable.b, b2)

for item in my_iterable
    println(&quot;Iteration for rhs 2&quot;)
end

@show norm(b2 - A * x) / norm(b2)</code></pre><p>This would output:</p><pre><code class="language-none">Iteration for rhs 1
Iteration for rhs 1
Iteration for rhs 1
Iteration for rhs 1
norm(b1 - A * x) / norm(b1) = 0.08388528015119746
Iteration for rhs 2
Iteration for rhs 2
Iteration for rhs 2
Iteration for rhs 2
norm(b2 - A * x) / norm(b2) = 0.0003681972775644809</code></pre><h2><a class="nav-anchor" id="Other-use-cases-1" href="#Other-use-cases-1">Other use cases</a></h2><p>Other use cases include: </p><ul><li>computing the (harmonic) Ritz values from the Hessenberg matrix in GMRES;</li><li>comparing the approximate residual of methods such as GMRES and BiCGStab(l) with the true residual during the iterations;</li><li>updating a preconditioner in flexible methods.</li></ul><footer><hr/><a class="previous" href="../svd/svdl/"><span class="direction">Previous</span><span class="title">SVDL</span></a><a class="next" href="../about/CONTRIBUTING/"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
