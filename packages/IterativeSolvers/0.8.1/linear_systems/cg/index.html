<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conjugate Gradients · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting started</a></li><li><a class="toctext" href="../../preconditioning/">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li class="current"><a class="toctext" href>Conjugate Gradients</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#On-the-GPU-1">On the GPU</a></li><li><a class="toctext" href="#Implementation-details-1">Implementation details</a></li></ul></li><li><a class="toctext" href="../chebyshev/">Chebyshev iteration</a></li><li><a class="toctext" href="../minres/">MINRES</a></li><li><a class="toctext" href="../bicgstabl/">BiCGStab(l)</a></li><li><a class="toctext" href="../idrs/">IDR(s)</a></li><li><a class="toctext" href="../gmres/">Restarted GMRES</a></li><li><a class="toctext" href="../lsmr/">LSMR</a></li><li><a class="toctext" href="../lsqr/">LSQR</a></li><li><a class="toctext" href="../stationary/">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="../../eigenproblems/power_method/">Power method</a></li><li><a class="toctext" href="../../eigenproblems/lobpcg/">LOBPCG</a></li></ul></li><li><a class="toctext" href="../../svd/svdl/">SVDL</a></li><li><a class="toctext" href="../../iterators/">The iterator approach</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../../about/CONTRIBUTING/">Contributing</a></li><li><a class="toctext" href="../../about/license/">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Linear systems</li><li><a href>Conjugate Gradients</a></li></ul></nav><hr/><div id="topbar"><span>Conjugate Gradients</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CG-1" href="#CG-1">Conjugate Gradients (CG)</a></h1><p>Conjugate Gradients solves <span>$Ax = b$</span> approximately for <span>$x$</span> where <span>$A$</span> is a symmetric, positive-definite linear operator and <span>$b$</span> the right-hand side vector. The method uses short recurrences and therefore has fixed memory costs and fixed computational costs per iteration.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.cg" href="#IterativeSolvers.cg"><code>IterativeSolvers.cg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cg(A, b; kwargs...) -&gt; x, [history]</code></pre><p>Same as <a href="#IterativeSolvers.cg!"><code>cg!</code></a>, but allocates a solution vector <code>x</code> initialized with zeros.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.cg!" href="#IterativeSolvers.cg!"><code>IterativeSolvers.cg!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cg!(x, A, b; kwargs...) -&gt; x, [history]</code></pre><p><strong>Arguments</strong></p><ul><li><code>x</code>: Initial guess, will be updated in-place;</li><li><code>A</code>: linear operator;</li><li><code>b</code>: right-hand side.</li></ul><p><strong>Keywords</strong></p><ul><li><code>statevars::CGStateVariables</code>: Has 3 arrays similar to <code>x</code> to hold intermediate results;</li><li><code>initially_zero::Bool</code>: If <code>true</code> assumes that <code>iszero(x)</code> so that one matrix-vector product can be saved when computing the initial residual vector;</li><li><code>Pl = Identity()</code>: left preconditioner of the method. Should be symmetric, positive-definite like <code>A</code>;</li><li><code>tol::Real = sqrt(eps(real(eltype(b))))</code>: tolerance for stopping condition <code>|r_k| / |r_0| ≤ tol</code>;</li><li><code>maxiter::Int = size(A,2)</code>: maximum number of iterations;</li><li><code>verbose::Bool = false</code>: print method information;</li><li><code>log::Bool = false</code>: keep track of the residual norm in each iteration.</li></ul><p><strong>Output</strong></p><p><strong>if <code>log</code> is <code>false</code></strong></p><ul><li><code>x</code>: approximated solution.</li></ul><p><strong>if <code>log</code> is <code>true</code></strong></p><ul><li><code>x</code>: approximated solution.</li><li><code>ch</code>: convergence history.</li></ul><p><strong>ConvergenceHistory keys</strong></p><ul><li><code>:tol</code> =&gt; <code>::Real</code>: stopping tolerance.</li><li><code>:resnom</code> =&gt; <code>::Vector</code>: residual norm at each iteration.</li></ul></div></div></section><h2><a class="nav-anchor" id="On-the-GPU-1" href="#On-the-GPU-1">On the GPU</a></h2><p>The method should work fine on the GPU. As a minimal working example, consider:</p><pre><code class="language-julia">using LinearAlgebra, CuArrays, IterativeSolvers

n = 100
A = cu(rand(n, n))
A = A + A&#39; + 2*n*I
b = cu(rand(n))
x = cg(A, b)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Make sure that all state vectors are stored on the GPU. For instance when calling <code>cg!(x, A, b)</code>, one might have an issue when <code>x</code> is stored on the GPU, while <code>b</code> is stored on the CPU – IterativeSolvers.jl does not copy the vectors to the same device.</p></div></div><h2><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h2><p>The current implementation follows a rather standard approach. Note that preconditioned CG (or PCG) is slightly different from ordinary CG, because the former must compute the residual explicitly, while it is available as byproduct in the latter. Our implementation of CG ensures the minimal number of vector operations.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>CG can be used as an <a href="../../iterators/#Iterators-1">iterator</a>.</p></div></div><footer><hr/><a class="previous" href="../../preconditioning/"><span class="direction">Previous</span><span class="title">Preconditioning</span></a><a class="next" href="../chebyshev/"><span class="direction">Next</span><span class="title">Chebyshev iteration</span></a></footer></article></body></html>
