<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fast Evaluation · FixedPolynomials.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FixedPolynomials.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../reference/">Polynomial</a></li><li class="current"><a class="toctext" href>Fast Evaluation</a><ul class="internal"><li><a class="toctext" href="#Evaluation-1">Evaluation</a></li><li><a class="toctext" href="#Derivatives-1">Derivatives</a></li><li><a class="toctext" href="#Systems-1">Systems</a></li><li><a class="toctext" href="#DiffResults-1">DiffResults</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Fast Evaluation</a></li></ul></nav><hr/><div id="topbar"><span>Fast Evaluation</span><a class="fa fa-bars" href="#"></a></div></header><p>In order to achieve a fast evaluation we need to precompute some things and also preallocate intermediate storage. For this we have</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.config" href="#FixedPolynomials.config"><code>FixedPolynomials.config</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">config(F::Polynomial, x)</code></pre><p>Construct a <code>GradientConfig</code> for the evaluation of <code>f</code> with values like <code>x</code>.</p></div></div><div><div><pre><code class="language-none">config(F::System, x)</code></pre><p>Construct a <code>JacobianConfig</code> for the evaluation of <code>F</code> with values like <code>x</code>.</p></div></div></section><h2><a class="nav-anchor" id="Evaluation-1" href="#Evaluation-1">Evaluation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.evaluate" href="#FixedPolynomials.evaluate"><code>FixedPolynomials.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate(p::Polynomial{T}, x::AbstractVector{T})</code></pre><p>Evaluates <code>p</code> at <code>x</code>, i.e. <span>$p(x)$</span>. <code>Polynomial</code> is also callable, i.e. you can also evaluate it via <code>p(x)</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(g, x, cfg::GradientConfig [, precomputed=false])</code></pre><p>Evaluate <code>g</code> at <code>x</code> using the precomputated values in <code>cfg</code>. Note that this is usually signifcant faster than <code>evaluate(g, x)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g)
evaluate(g, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>gradient</code> with the same <code>x</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(F, x, cfg::JacobianConfig [, precomputed=false])</code></pre><p>Evaluate the system <code>F</code> at <code>x</code> using the precomputated values in <code>cfg</code>. Note that this is usually signifcant faster than <code>map(f -&gt; evaluate(f, x), F)</code>. The return vector is constructed using <code>similar(x, T)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = JacobianConfig(F)
evaluate(F, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>jacobian</code> with the same <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.evaluate!" href="#FixedPolynomials.evaluate!"><code>FixedPolynomials.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate!(u, F, x, cfg::JacobianConfig [, precomputed=false])</code></pre><p>Evaluate the system <code>F</code> at <code>x</code> using the precomputated values in <code>cfg</code> and store the result in <code>u</code>. Note that this is usually signifcant faster than <code>map!(u, f -&gt; evaluate(f, x), F)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = JacobianConfig(F)
evaluate!(u, F, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>jacobian</code> with the same <code>x</code>.</p></div></div></section><h2><a class="nav-anchor" id="Derivatives-1" href="#Derivatives-1">Derivatives</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.gradient" href="#FixedPolynomials.gradient"><code>FixedPolynomials.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gradient(g, x, cfg::GradientConfig[, precomputed=false])</code></pre><p>Compute the gradient of <code>g</code> at <code>x</code> using the precomputated values in <code>cfg</code>. The return vector is constructed using <code>similar(x, T)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g)
gradient(g, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>gradient</code> with the same <code>x</code>.</p></div></div><div><div><pre><code class="language-none">gradient(r::GradientDiffResult)</code></pre><p>Get the currently stored gradient in <code>r</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.gradient!" href="#FixedPolynomials.gradient!"><code>FixedPolynomials.gradient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gradient!(u, g, x, cfg::GradientConfig [, precomputed=false])</code></pre><p>Compute the gradient of <code>g</code> at <code>x</code> using the precomputated values in <code>cfg</code> and store thre result in u.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g)
gradient(u, g, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>gradient</code> with the same <code>x</code>.</p></div></div><div><div><pre><code class="language-none">gradient!(r::GradientDiffResult, g, x, cfg::GradientConfig)</code></pre><p>Compute <span>$g(x)$</span> and the gradient of <code>g</code> at <code>x</code> at once using the precomputated values in <code>cfg</code> and store thre result in <code>r</code>. This is faster than calling both values separetely.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g)
r = GradientDiffResult(r)
gradient!(r, g, x, cfg)

value(r) == g(x)
gradient(r) == gradient(g, x, cfg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.jacobian" href="#FixedPolynomials.jacobian"><code>FixedPolynomials.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian(u, F, x, cfg::JacobianConfig [, precomputed=false])</code></pre><p>Evaluate the jacobian of <code>F</code> at <code>x</code> using the precomputated values in <code>cfg</code>. The return matrix is constructed using <code>similar(x, T, m, n)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = JacobianConfig(F)
jacobian(F, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>jacobian</code> with the same <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.jacobian!" href="#FixedPolynomials.jacobian!"><code>FixedPolynomials.jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jacobian!(u, F, x, cfg::JacobianConfig [, precomputed=false])</code></pre><p>Evaluate the jacobian of <code>F</code> at <code>x</code> using the precomputated values in <code>cfg</code> and store the result in <code>u</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = JacobianConfig(F)
jacobian!(u, F, x, cfg)</code></pre><p>With <code>precomputed=true</code> we rely on the previous intermediate results in <code>cfg</code>. Therefore the result is only correct if you previouls called <code>evaluate</code>, or <code>jacobian</code> with the same <code>x</code>.</p></div></div><div><div><pre><code class="language-none">jacobian!(r::JacobianDiffResult, F, x, cfg::JacobianConfig)</code></pre><p>Compute <span>$F(x)$</span> and the jacobian of <code>F</code> at <code>x</code> at once using the precomputated values in <code>cfg</code> and store thre result in <code>r</code>. This is faster than computing both values separetely.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g)
r = GradientDiffResult(cfg)
gradient!(r, g, x, cfg)

value(r) == g(x)
gradient(r) == gradient(g, x, cfg)</code></pre></div></div></section><h2><a class="nav-anchor" id="Systems-1" href="#Systems-1">Systems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.System" href="#FixedPolynomials.System"><code>FixedPolynomials.System</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">System(polys [, variables])</code></pre><p>Construct a system of polynomials from the given polynomials <code>polys</code>.</p></div></div></section><p>Systems have the additional functions</p><pre><code class="language-none">evaluate_and_jacobian!
evaluate_and_jacobian</code></pre><h2><a class="nav-anchor" id="DiffResults-1" href="#DiffResults-1">DiffResults</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.GradientDiffResult" href="#FixedPolynomials.GradientDiffResult"><code>FixedPolynomials.GradientDiffResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GradientDiffResult(cfg::GradientConfig)</code></pre><p>During the computation of <span>$∇g(x)$</span> we compute nearly everything we need for the evaluation of <span>$g(x)$</span>. GradientDiffResult allocates memory to hold both values. This structure also signals <code>gradient!</code> to store <span>$g(x)$</span> and <span>$∇g(x)$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = GradientConfig(g, x)
r = GradientDiffResult(cfg)
gradient!(r, g, x, cfg)

value(r) == g(x)
gradient(r) == gradient(g, x, cfg)</code></pre><pre><code class="language-none">GradientDiffResult(grad::AbstractVector)</code></pre><p>Allocate the memory to hold the gradient by yourself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.JacobianDiffResult" href="#FixedPolynomials.JacobianDiffResult"><code>FixedPolynomials.JacobianDiffResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JacobianDiffResult(cfg::GradientConfig)</code></pre><p>During the computation of the jacobian <span>$J_F(x)$</span> we compute nearly everything we need for the evaluation of <span>$F(x)$</span>. <code>JacobianDiffResult</code> allocates memory to hold both values. This structure also signals <code>jacobian!</code> to store <span>$F(x)$</span> and <span>$J_F(x)$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = JacobianConfig(F, x)
r = JacobianDiffResult(cfg)
jacobian!(r, F, x, cfg)

value(r) == map(f -&gt; f(x), F)
jacobian(r) == jacobian(F, x, cfg)</code></pre><pre><code class="language-none">JacobianDiffResult(value::AbstractVector, jacobian::AbstractMatrix)</code></pre><p>Allocate the memory to hold the value and the jacobian by yourself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedPolynomials.value" href="#FixedPolynomials.value"><code>FixedPolynomials.value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value(r::GradientDiffResult)</code></pre><p>Get the currently stored value in <code>r</code>.</p></div></div></section><footer><hr/><a class="previous" href="../reference/"><span class="direction">Previous</span><span class="title">Polynomial</span></a></footer></article></body></html>
