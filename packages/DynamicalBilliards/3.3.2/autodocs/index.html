<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · DynamicalBilliards.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynamicalBilliards.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.AbstractParticle" href="#DynamicalBilliards.AbstractParticle"><code>DynamicalBilliards.AbstractParticle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractParticle</code></pre><p>Particle supertype.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Antidot" href="#DynamicalBilliards.Antidot"><code>DynamicalBilliards.Antidot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Antidot{T&lt;:AbstractFloat} &lt;: Circular{T}</code></pre><p>Disk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.</p><p><strong>Fields:</strong></p><ul><li><code>c::SVector{2,T}</code> : Center.</li><li><code>r::T</code> : Radius.</li><li><code>pflag::Bool</code> : Flag that keeps track of where the particle is currently propagating (<code>pflag</code> = propagation-flag). <code>true</code> stands for <em>outside</em> the disk, <code>false</code> for <em>inside</em> the disk. Defaults to <code>true</code>.</li><li><code>name::String</code> : Name of the obstacle given for user convenience. Defaults to &quot;Antidot&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Billiard" href="#DynamicalBilliards.Billiard"><code>DynamicalBilliards.Billiard</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Billiard(obstacles...)</code></pre><p>Construct a <code>Billiard</code> from given <code>obstacles</code> (tuple, vector, varargs).</p><p>For functions like <a href="#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, it is expected (if possible) that the obstacles of the billiard are sorted, such that the arc-coordinate <code>ξ</code> around the billiard is increasing counter-clockwise.</p><p><code>ξ</code> is measured as:</p><ul><li>the distance from start point to end point in <code>Wall</code>s</li><li>the arc length measured counterclockwise from the open face in <code>Semicircle</code>s</li><li>the arc length measured counterclockwise from the rightmost point in <code>Circular</code>s</li></ul></div></div></section><pre><code class="language-none">DynamicalBilliards.CLAMPING_ANGLE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Circular" href="#DynamicalBilliards.Circular"><code>DynamicalBilliards.Circular</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Circular{T&lt;:AbstractFloat} &lt;: Obstacle{T}</code></pre><p>Circular obstacle supertype.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Disk" href="#DynamicalBilliards.Disk"><code>DynamicalBilliards.Disk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Disk{T&lt;:AbstractFloat}  &lt;: Circular{T}</code></pre><p>Disk-like obstacle with propagation allowed outside of the circle (immutable type).</p><p><strong>Fields:</strong></p><ul><li><code>c::SVector{2,T}</code> : Center.</li><li><code>r::T</code> : Radius.</li><li><code>name::String</code> : Some name given for user convenience. Defaults to &quot;Disk&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.DynamicalBilliards" href="#DynamicalBilliards.DynamicalBilliards"><code>DynamicalBilliards.DynamicalBilliards</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A Julia package for dynamical billiard systems in two dimensions.</p><p>The goals of the package is to provide a flexible, easy-to-use and intuitive framework for fast implementation of billiard systems of arbitrary construction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Ellipse" href="#DynamicalBilliards.Ellipse"><code>DynamicalBilliards.Ellipse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Ellipse{T&lt;:AbstractFloat}  &lt;: Obstacle{T}</code></pre><p>Ellipse obstacle that also allows ray-splitting. The ellipse is always oriented on the x and y axis (although you can make whichever you want the major one).</p><p><strong>Fields:</strong></p><ul><li><code>c::SVector{2,T}</code> : Center.</li><li><code>a::T</code> : x semi-axis.</li><li><code>b::T</code> : y semi-axis.</li><li><code>pflag::Bool</code> : Flag that keeps track of where the particle is currently propagating. <code>true</code> (default) is associated with being outside the ellipse.</li><li><code>name::String</code> : Some name given for user convenience. Defaults to <code>&quot;Ellipse&quot;</code>.</li></ul><p>The ellipse equation is given by</p><div>\[\left(\frac{x - c[1]}{a} \right)^2+ \left(\frac{y - c[2]}{b}\right)^2 = 1\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.FiniteWall" href="#DynamicalBilliards.FiniteWall"><code>DynamicalBilliards.FiniteWall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FiniteWall{T&lt;:AbstractFloat} &lt;: Wall{T}</code></pre><p>Wall obstacle imposing specular reflection during collision (immutable type). Slower than <a href="#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a>, meant to be used for non-convex billiards.</p><p>Giving a <code>true</code> value to the field <code>isdoor</code> designates this obstacle to be a <code>Door</code>. This is used in <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a> function. A <code>Door</code> is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.</p><p><strong>Fields:</strong></p><ul><li><code>sp::SVector{2,T}</code> : Starting point of the Wall.</li><li><code>ep::SVector{2,T}</code> : Ending point of the Wall.</li><li><code>normal::SVector{2,T}</code> : Normal vector to the wall, pointing to where the particle <em>will come from before a collision</em> (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.</li><li><code>isdoor::Bool</code> : Flag of whether this <code>FiniteWall</code> instance is a &quot;Door&quot;.</li><li><code>name::String</code> : Name of the obstacle, given for user convenience. Defaults to &quot;Finite Wall&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.InfiniteWall" href="#DynamicalBilliards.InfiniteWall"><code>DynamicalBilliards.InfiniteWall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InfiniteWall{T&lt;:AbstractFloat} &lt;: Wall{T}</code></pre><p>Wall obstacle imposing specular reflection during collision (immutable type). Faster than <a href="#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a>, meant to be used for convex billiards.</p><p><strong>Fields:</strong></p><ul><li><code>sp::SVector{2,T}</code> : Starting point of the Wall.</li><li><code>ep::SVector{2,T}</code> : Ending point of the Wall.</li><li><code>normal::SVector{2,T}</code> : Normal vector to the wall, pointing to where the particle <em>will come from before a collision</em> (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.</li><li><code>name::String</code> : Name of the obstacle, given for user convenience. Defaults to &quot;Wall&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.MagneticParticle" href="#DynamicalBilliards.MagneticParticle"><code>DynamicalBilliards.MagneticParticle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]
MagneticParticle(x0, y0, φ0, ω)
MagneticParticle(pos::SVector, vel::SVector, ω)
MagneticParticle(p::AbstractParticle, ω)</code></pre><p>Create a <em>magnetic</em> particle with initial conditions <code>x0, y0, φ0</code> and angular velocity <code>ω</code>. It propagates as a circle instead of a line, with radius <code>1/abs(ω)</code>.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.MushroomTools" href="#DynamicalBilliards.MushroomTools"><code>DynamicalBilliards.MushroomTools</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MushroomTools</code></pre><p>Module containing many functions helpful in simulating (perfect) mushroom billiards, see <a href="#DynamicalBilliards.billiard_mushroom"><code>billiard_mushroom</code></a>. Contains stuff like initializing efficiently regular or chaotic particles and functions that return the corresponding chaotic or regular phase-space volumes or portions. The functions <a href="@ref"><code>V_3D_tot</code></a> and <a href="@results"><code>V_3D_reg</code></a> use equations derived in ref. [1].</p><p>Made by Lukas Hupe.</p><p><strong>References</strong></p><p>[1] A. Barnett &amp; T. Betcke, <a href="https://doi.org/10.1063/1.2816946">Chaos <strong>17</strong>, 043125 (2007)</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Obstacle" href="#DynamicalBilliards.Obstacle"><code>DynamicalBilliards.Obstacle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Obstacle{&lt;:AbstractFloat}</code></pre><p>Obstacle supertype.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Particle" href="#DynamicalBilliards.Particle"><code>DynamicalBilliards.Particle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]
Particle(x0, y0, φ0)
Particle(pos::SVector, vel::SVector)</code></pre><p>Create a particle with initial conditions <code>x0, y0, φ0</code>. It propagates as a straight line.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.PeriodicWall" href="#DynamicalBilliards.PeriodicWall"><code>DynamicalBilliards.PeriodicWall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PeriodicWall{T&lt;:AbstractFloat} &lt;: Wall{T}</code></pre><p>Wall obstacle that imposes periodic boundary conditions upon collision (immutable type).</p><p><strong>Fields:</strong></p><ul><li><code>sp::SVector{2,T}</code> : Starting point of the Wall.</li><li><code>ep::SVector{2,T}</code> : Ending point of the Wall.</li><li><code>normal::SVector{2,T}</code> : Normal vector to the wall, pointing to where the particle <em>will come from</em> (to the inside the billiard). The size of the vector is <strong>important</strong>! This vector is added to a particle&#39;s <code>pos</code> during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.</li><li><code>name::String</code> : Name of the obstacle, given for user convenience. Defaults to &quot;Periodic wall&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.RandomDisk" href="#DynamicalBilliards.RandomDisk"><code>DynamicalBilliards.RandomDisk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RandomDisk{T&lt;:AbstractFloat} &lt;: Circular{T}</code></pre><p>Disk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.</p><p><strong>Fields:</strong></p><ul><li><code>c::SVector{2,T}</code> : Center.</li><li><code>r::T</code> : Radius.</li><li><code>name::String</code> : Some name given for user convenience. Defaults to &quot;Random disk&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.RandomWall" href="#DynamicalBilliards.RandomWall"><code>DynamicalBilliards.RandomWall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RandomWall{T&lt;:AbstractFloat} &lt;: Wall{T}</code></pre><p>Wall obstacle imposing (uniformly) random reflection during collision (immutable type).</p><p><strong>Fields:</strong></p><ul><li><code>sp::SVector{2,T}</code> : Starting point of the Wall.</li><li><code>ep::SVector{2,T}</code> : Ending point of the Wall.</li><li><code>normal::SVector{2,T}</code> : Normal vector to the wall, pointing to where the particle <em>is expected to come from</em> (pointing towards the inside of the billiard).</li><li><code>name::String</code> : Name of the obstacle, given for user convenience. Defaults to &quot;Random wall&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.RaySplitter" href="#DynamicalBilliards.RaySplitter"><code>DynamicalBilliards.RaySplitter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RaySplitter(idxs, transmission, refraction [, newangular]; affect)</code></pre><p>Return a <code>RaySplitter</code> instance, used to perform raysplitting. <code>idxs</code> is a <code>Vector{Int}</code> with the indices of the obstacles that this <code>RaySplitter</code> corresponds to.</p><p><code>transmission</code>, <code>refraction</code> and <code>newangular</code> are <strong>functions</strong>. Let <code>φ</code> be the angle of incidence and <code>ω</code> be the angular velocity and <code>pflag</code> the propagation flag (before transmission). The functions have the following signatures:</p><ol><li><code>transmission(φ, pflag, ω) -&gt; T</code>, transmission probability.</li><li><code>refraction(φ, pflag, ω) -&gt; θ</code>, refraction angle. This angle is <em>relative</em> to the normal vector.</li><li><code>newangular(ω, pflag) -&gt; newω</code>, new angular velocity after transmission.</li></ol><p>The above three functions use the <strong>same convention</strong>: the argument <code>pflag</code> is the one the obstacle has <strong>before transmission</strong>. For example, if a particle is outside an <a href="#DynamicalBilliards.Antidot"><code>Antidot</code></a> (with <code>pflag = true</code> here) and is transmitted inside the <code>Antidot</code> (<code>pflag</code> becomes <code>false</code> here), then all three functions will be given their second argument (the Boolean one) as <code>true</code>!</p><p><code>affect</code> is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle <code>i</code> (for which obstacles should the field <code>pflag</code> be reversed). Defaults to <code>idxs = (i) -&gt; i</code>, i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write <code>idxs = (i) -&gt; SVector(2,3,5)</code>, etc. Keep in mind that the only values of <code>i</code> that can be passed into this function are the ones that are given in the argument <code>idxs</code>!</p></div></div></section><pre><code class="language-none">DynamicalBilliards.SV</code></pre><pre><code class="language-none">DynamicalBilliards.SVector</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Semicircle" href="#DynamicalBilliards.Semicircle"><code>DynamicalBilliards.Semicircle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Semicircle{T&lt;:AbstractFloat} &lt;: Circular{T}</code></pre><p>Obstacle that represents half a circle. Propagation is allowed only inside the semicircle.</p><p><strong>Fields:</strong></p><ul><li><code>c::SVector{2,T}</code> : Center.</li><li><code>r::T</code> : Radius.</li><li><code>facedir::SVector{2,T}</code> : Direction where the open face of the Semicircle is facing.</li><li><code>name::String</code> : Name of the obstacle given for user convenience. Defaults to &quot;Semicircle&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.SplitterWall" href="#DynamicalBilliards.SplitterWall"><code>DynamicalBilliards.SplitterWall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SplitterWall{T&lt;:AbstractFloat} &lt;: Wall{T}</code></pre><p>Wall obstacle imposing allowing for ray-splitting (mutable type).</p><p><strong>Fields:</strong></p><ul><li><code>sp::SVector{2,T}</code> : Starting point of the Wall.</li><li><code>ep::SVector{2,T}</code> : Ending point of the Wall.</li><li><code>normal::SVector{2,T}</code> : Normal vector to the wall, pointing to where the particle <em>will come from before a collision</em>. The size of the vector is irrelevant.</li><li><code>pflag::Bool</code> : Flag that keeps track of where the particle is currently propagating (<code>pflag</code> = propagation flag). <code>true</code> is associated with the <code>normal</code> vector the wall is instantiated with. Defaults to <code>true</code>.</li><li><code>name::String</code> : Name of the obstacle, given for user convenience. Defaults to &quot;Splitter wall&quot;.</li></ul></div></div></section><pre><code class="language-none">DynamicalBilliards.Testing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.Wall" href="#DynamicalBilliards.Wall"><code>DynamicalBilliards.Wall</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Wall{T&lt;:AbstractFloat} &lt;: Obstacle{T}</code></pre><p>Wall obstacle supertype.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.__init__</code></pre><pre><code class="language-none">DynamicalBilliards._get_name</code></pre><pre><code class="language-none">DynamicalBilliards._getval</code></pre><pre><code class="language-none">DynamicalBilliards._okay</code></pre><pre><code class="language-none">DynamicalBilliards._randominside</code></pre><pre><code class="language-none">DynamicalBilliards._reset_ispinned</code></pre><pre><code class="language-none">DynamicalBilliards._retinit</code></pre><pre><code class="language-none">DynamicalBilliards._ξ</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.acceptable_raysplitter" href="#DynamicalBilliards.acceptable_raysplitter"><code>DynamicalBilliards.acceptable_raysplitter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acceptable_raysplitter(raysplitters, bd::Billiard)</code></pre><p>Return <code>true</code> if the given <code>raysplitters</code> can be used in conjuction with given billiard <code>bd</code>.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.accuracy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.acos1mx" href="#DynamicalBilliards.acos1mx"><code>DynamicalBilliards.acos1mx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Approximate arccos(1 - x) for x very close to 0.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.allaffected</code></pre><pre><code class="language-none">DynamicalBilliards.angleclamp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.arcintervals" href="#DynamicalBilliards.arcintervals"><code>DynamicalBilliards.arcintervals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arcintervals(bd::Billiard) -&gt; s</code></pre><p>Generate a vector <code>s</code>, with entries being the delimiters of the arclengths of the obstacles of the billiard. The arclength from <code>s[i]</code> to <code>s[i+1]</code> is the arclength spanned by the <code>i</code>th obstacle.</p><p><code>s</code> is used to transform an arc-coordinate <code>ξ</code> from local to global and vice-versa. A local <code>ξ</code> becomes global by adding <code>s[i]</code> (where <code>i</code> is the index of current obstacle). A global <code>ξ</code> becomes local by subtracting <code>s[i]</code>.</p><p>See also <a href="#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, <a href="#DynamicalBilliards.to_bcoords"><code>to_bcoords</code></a>, <a href="#DynamicalBilliards.from_bcoords"><code>from_bcoords</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_bunimovich" href="#DynamicalBilliards.billiard_bunimovich"><code>DynamicalBilliards.billiard_bunimovich</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_hexagonal_sinai" href="#DynamicalBilliards.billiard_hexagonal_sinai"><code>DynamicalBilliards.billiard_hexagonal_sinai</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_hexagonal_sinai(r, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Create a sinai-like billiard, which is a hexagon of outer radius <code>R</code>, containing at its center (given by <code>center</code>) a disk of radius <code>r</code>. The <code>setting</code> keyword is passed to <code>billiard_polygon</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_iris" href="#DynamicalBilliards.billiard_iris"><code>DynamicalBilliards.billiard_iris</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_iris(a=0.2, b=0.4, w=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a billiard that is a square of side <code>w</code> enclosing at its center an ellipse with semi axes <code>a</code>, <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_logo" href="#DynamicalBilliards.billiard_logo"><code>DynamicalBilliards.billiard_logo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25) -&gt; bd, ray</code></pre><p>Create the billiard used as logo of <code>DynamicalBilliards</code> and return it along with the tuple of raysplitters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_lorentz" href="#DynamicalBilliards.billiard_lorentz"><code>DynamicalBilliards.billiard_lorentz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_lorentz(r=0.25, x=1.0, y=1.0)</code></pre><p>Alias for <code>billiard_sinai(r,x,y; setting = &quot;periodic&quot;)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_mushroom" href="#DynamicalBilliards.billiard_mushroom"><code>DynamicalBilliards.billiard_mushroom</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)</code></pre><p>Create a mushroom billiard with stem length <code>sl</code>, stem width <code>sw</code> and cap radius <code>cr</code>. The center of the cap (which is Semicircle) is always at <code>[0, sl]</code>. The center of the stem is located at <code>sloc</code>.</p><p>Optionally, the bottom-most <code>Wall</code> is a <code>Door</code> (see <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_polygon" href="#DynamicalBilliards.billiard_polygon"><code>DynamicalBilliards.billiard_polygon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_polygon(n::Int, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a regular-polygonal billiard with <code>n</code> sides, radius <code>r</code> and given <code>center</code>.</p><p>Note: <code>R</code> denotes the so-called outer radius, not the inner one.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries. Only available for <code>n=4</code> or <code>n=6</code>.</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_raysplitting_showcase" href="#DynamicalBilliards.billiard_raysplitting_showcase"><code>DynamicalBilliards.billiard_raysplitting_showcase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -&gt; bd, rayspl</code></pre><p>Showcase example billiard for ray-splitting processes. A rectangle <code>(x,y)</code> with a SplitterWall at <code>x/2</code> and two disks at each side, with respective radii <code>r1</code>, <code>r2</code>.</p><p><strong>Notice</strong>: This function returns a billiard <code>bd</code> as well as a <code>rayspl</code> dictionary!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_rectangle" href="#DynamicalBilliards.billiard_rectangle"><code>DynamicalBilliards.billiard_rectangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_rectangle(x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a rectangle billiard of size (<code>x</code>, <code>y</code>).</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_sinai" href="#DynamicalBilliards.billiard_sinai"><code>DynamicalBilliards.billiard_sinai</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_sinai(r=0.25, x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a Sinai billiard of size (<code>x</code>, <code>y</code>) with a disk in its center, of radius <code>r</code>.</p><p>In the periodic case, the system is also known as &quot;Lorentz Gas&quot;.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.billiard_stadium" href="#DynamicalBilliards.billiard_stadium"><code>DynamicalBilliards.billiard_stadium</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.bounce!" href="#DynamicalBilliards.bounce!"><code>DynamicalBilliards.bounce!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel</code></pre><p>&quot;Bounce&quot; the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.</p><p>Return:</p><ul><li>index of the obstacle that the particle just collided with</li><li>the time from the previous collision until the current collision <code>t</code></li><li>position and velocity of the particle at the current collision (<em>after</em> the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do <code>pos += p.current_cell</code> for the position in real space.</li></ul><pre><code class="language-julia">bounce!(p, bd, raysplit) → i, t, pos, vel</code></pre><p>Ray-splitting version of <code>bounce!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.boundarymap" href="#DynamicalBilliards.boundarymap"><code>DynamicalBilliards.boundarymap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">boundarymap(p, bd, t [,intervals]) → bmap, arclengths</code></pre><p>Compute the boundary map of the particle <code>p</code> in the billiard <code>bd</code> by evolving the particle for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Return a vector of 2-vectors <code>bmap</code> and also <code>arclengths(bd)</code>. The first entry of each element of <code>bmap</code> is the arc-coordinate at collisions <span>$\xi$</span>, while the second  is the sine of incidence angle <span>$\sin(\phi_n)$</span>.</p><p>The measurement direction of the arclengths of the individual obstacles is dictated by their order in <code>bd</code>. The sine of the angle is computed <em>after</em> specular reflection has taken place.</p><p>The returned values of this function can be used in conjuction with the function <a href="@ref"><code>plot_boundarymap</code></a> (requires <code>using PyPlot</code>) to plot the boundary map in an intuitive way.</p><p><em>Notice</em> - this function only works for normal specular reflection. Random reflections or ray-splitting will give unexpected results.</p><p>See also <a href="#DynamicalBilliards.to_bcoords"><code>to_bcoords</code></a>, <a href="#DynamicalBilliards.boundarymap_portion"><code>boundarymap_portion</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.boundarymap_portion" href="#DynamicalBilliards.boundarymap_portion"><code>DynamicalBilliards.boundarymap_portion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">boundarymap_portion(bd::Billiard, t, p::AbstractParticle, δξ, δφ = δξ)</code></pre><p>Calculate the portion of the boundary map of the billiard <code>bd</code> covered by the particle <code>p</code> when it is evolved for time <code>t</code> (float or integer). Notice that the</p><p>The boundary map is partitioned into boxes of size <code>(δξ, δφ)</code> and as the particle evolves visited boxes are counted. The returned ratio is this count divided by the total boxes of size <code>(δξ, δφ)</code> needed to cover the boundary map.</p><p><strong>Important:</strong> This portion <strong>does not</strong> equate the portion the particle&#39;s orbit covers on the full, three dimensional phase space. Use the function <a href="#DynamicalBilliards.phasespace_portion"><code>phasespace_portion</code></a> for that!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.cellsize" href="#DynamicalBilliards.cellsize"><code>DynamicalBilliards.cellsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cellsize(bd)</code></pre><p>Return the delimiters <code>xmin, ymin, xmax, ymax</code> of the given obstacle/billiard.</p><p>Used in <code>randominside()</code>, error checking and plotting.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.collision" href="#DynamicalBilliards.collision"><code>DynamicalBilliards.collision</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collision(p::AbstractParticle, o::Obstacle) → t, cp</code></pre><p>Find the collision (if any) between given particle and obstacle. Return the time until collision and the estimated collision point <code>cp</code>.</p><p>Returns <code>Inf, SV(0, 0)</code> if the collision is not possible <em>or</em> if the collision happens backwards in time.</p><p><strong>It is the duty of <code>collision</code> to avoid incorrect collisions when the particle is on top of the obstacle (or very close).</strong></p></div></div></section><pre><code class="language-none">DynamicalBilliards.cossin</code></pre><pre><code class="language-none">DynamicalBilliards.cross2D</code></pre><pre><code class="language-none">DynamicalBilliards.curvature</code></pre><pre><code class="language-none">DynamicalBilliards.cyclotron</code></pre><pre><code class="language-none">DynamicalBilliards.default_affect</code></pre><pre><code class="language-none">DynamicalBilliards.default_angular</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.distance" href="#DynamicalBilliards.distance"><code>DynamicalBilliards.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">distance(p::AbstractParticle, o::Obstacle)</code></pre><p>Return the <strong>signed</strong> distance between particle <code>p</code> and obstacle <code>o</code>, based on <code>p.pos</code>. Positive distance corresponds to the particle being on the <em>allowed</em> region of the <code>Obstacle</code>. E.g. for a <code>Disk</code>, the distance is positive when the particle is outside of the disk, negative otherwise.</p><pre><code class="language-none">distance(p::AbstractParticle, bd::Billiard)</code></pre><p>Return minimum <code>distance(p, obst)</code> for all <code>obst</code> in <code>bd</code>. If the <code>distance(p, bd)</code> is negative this means that the particle is outside the billiard.</p><p>All <code>distance</code> functions can also be given a position (vector) instead of a particle.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.distance_init</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.ellipse_arclength" href="#DynamicalBilliards.ellipse_arclength"><code>DynamicalBilliards.ellipse_arclength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ellipse_arclength(θ, e::Ellipse)</code></pre><p>Return the arclength of the ellipse that spans angle <code>θ</code> (in normal coordinates, not in the ellipse parameterization). Expects <code>θ</code> to be in <code>[0, 2π]</code>.</p><p>After properly calculating the</p><div>\[d=b\,E\bigl(\tan^{-1}(a/b\,\tan(\theta))\,\big|\,1-(a/b)^2\bigr)\]</div></div></div></section><pre><code class="language-none">DynamicalBilliards.escapeind</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.escapetime" href="#DynamicalBilliards.escapetime"><code>DynamicalBilliards.escapetime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">escapetime([p,] bd, t; warning = false)</code></pre><p>Calculate the escape time of a particle <code>p</code> in the billiard <code>bd</code>, which is the time until colliding with any &quot;door&quot; in <code>bd</code>. As a &quot;door&quot; is considered any <a href="#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a> with field <code>isdoor = true</code>.</p><p>If the particle evolves for more than <code>t</code> (integer or float) without colliding with the <code>Door</code> (i.e. escaping) the returned result is <code>Inf</code>.</p><p>A warning can be thrown if the result is <code>Inf</code>. Enable this using the keyword <code>warning = true</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.escapetime!</code></pre><pre><code class="language-none">DynamicalBilliards.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.evolve" href="#DynamicalBilliards.evolve"><code>DynamicalBilliards.evolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evolve(p, args...)</code></pre><p>Same as <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a> but copies the particle instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.evolve!" href="#DynamicalBilliards.evolve!"><code>DynamicalBilliards.evolve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evolve!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code>. If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Return the states of the particle between collisions.</p><p>This function mutates the particle, use <code>evolve</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p><strong>Return</strong></p><ul><li><code>ct::Vector{T}</code> : Collision times.</li><li><code>poss::Vector{SVector{2,T}}</code> : Positions at the collisions.</li><li><code>vels::Vector{SVector{2,T}})</code> : Velocities exactly after the collisions.</li><li><code>ω</code>, either <code>T</code> or <code>Vector{T}</code> : Angular velocity/ies (returned only for magnetic particles).</li></ul><p>The time <code>ct[i+1]</code> is the time necessary to reach state <code>poss[i+1], vels[i+1]</code> starting from the state <code>poss[i], vels[i]</code>. That is why <code>ct[1]</code> is always 0 since <code>poss[1], vels[1]</code> are the initial conditions. The angular velocity <code>ω[i]</code> is the one the particle has while propagating from state <code>poss[i], vels[i]</code> to <code>i+1</code>.</p><p>Notice that at any point, the velocity vector <code>vels[i]</code> is the one obdained <em>after</em> the specular reflection of the <code>i-1</code>th collision.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">evolve!(p, bd, t, raysplitters)</code></pre><p>To implement ray-splitting, the <code>evolve!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>evolve</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.extrapolate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.find_cyclotron" href="#DynamicalBilliards.find_cyclotron"><code>DynamicalBilliards.find_cyclotron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_cyclotron(p::MagneticParticle)</code></pre><p>Return the center of cyclotron motion of the particle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.from_bcoords" href="#DynamicalBilliards.from_bcoords"><code>DynamicalBilliards.from_bcoords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">from_bcoords(ξ, sφ, o::Obstacle) -&gt; pos, vel</code></pre><p>Convert the boundary coordinates <code>ξ, sφ</code> on the obstacle to real coordinates <code>pos, vel</code>.</p><p>Note that <code>vel</code> always points away from the obstacle.</p><p>This function is the inverse of <a href="#DynamicalBilliards.to_bcoords"><code>to_bcoords</code></a>.</p></div></div><div><div><pre><code class="language-none">from_bcoords(ξ, sφ, bd::Billiard, intervals = arcintervals(bd))</code></pre><p>Same as above, but now <code>ξ</code> is considered to be the global arclength, parameterizing the entire billiard, instead of a single obstacle.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.incidence_angle</code></pre><pre><code class="language-none">DynamicalBilliards.include</code></pre><pre><code class="language-none">DynamicalBilliards.increment_counter</code></pre><pre><code class="language-none">DynamicalBilliards.isdoor</code></pre><pre><code class="language-none">DynamicalBilliards.isperiodic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.isphysical" href="#DynamicalBilliards.isphysical"><code>DynamicalBilliards.isphysical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isphysical(raysplitter(s))</code></pre><p>Return <code>true</code> if the given <code>raysplitters</code> have physically plausible properties.</p><p>Specifically, check if (φ is the incidence angle, θ the refraction angle):</p><ul><li>Critical angle means total reflection: If θ(φ) ≥ π/2 then Tr(φ) = 0</li><li>Transmission probability is even function: Tr(φ) ≈ Tr(-φ) at ω = 0</li><li>Refraction angle is odd function: θ(φ) ≈ -θ(-φ) at ω = 0</li><li>Ray reversal is true: θ(θ(φ, pflag, ω), !pflag, ω) ≈ φ</li><li>Magnetic conservation is true: (ω<em>new(ω</em>new(ω, pflag), !pflag) ≈ ω</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.ispinned" href="#DynamicalBilliards.ispinned"><code>DynamicalBilliards.ispinned</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ispinned(p::MagneticParticle, bd::Billiard)</code></pre><p>Return <code>true</code> if the particle is pinned with respect to the billiard. Pinned particles either have no valid collisions (go in circles forever) or all their valid collisions are with periodic walls, which again means that they go in cirles for ever.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.istransmitted</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.law_of_refraction" href="#DynamicalBilliards.law_of_refraction"><code>DynamicalBilliards.law_of_refraction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">law_of_refraction(n1, n2 = 1.0) -&gt; t, r</code></pre><p>Create transmission and refraction functions <code>t, r</code> that follow Snell&#39;s law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection. </p><p><code>n1</code> is the index of refraction for the <code>pflag = false</code> side of an obstacle, while <code>n2</code> is the index of refraction for <code>pflag = true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.lyapunovspectrum" href="#DynamicalBilliards.lyapunovspectrum"><code>DynamicalBilliards.lyapunovspectrum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyapunovspectrum([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Returns the finite time lyapunov exponents (averaged over time <code>t</code>) for a given particle in a billiard table using the method outlined in [1].</p><p>Returns zeros for pinned particles.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p><p>[1] : Ch. Dellago <em>et al</em>, <a href="http://link.aps.org/doi/10.1103/PhysRevE.53.1485">Phys. Rev. E <strong>53</strong> (1996)</a></p></div></div></section><pre><code class="language-none">DynamicalBilliards.lyapunovspectrum!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.meancollisiontime" href="#DynamicalBilliards.meancollisiontime"><code>DynamicalBilliards.meancollisiontime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meancollisiontime([p,] bd, t) → κ</code></pre><p>Compute the mean collision time <code>κ</code> of the particle <code>p</code> in the billiard <code>bd</code> by evolving for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Collision times are counted only between obstacles that are <em>not</em> <a href="#DynamicalBilliards.PeriodicWall"><code>PeriodicWall</code></a>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.meancollisiontime!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.next_collision" href="#DynamicalBilliards.next_collision"><code>DynamicalBilliards.next_collision</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next_collision(p::AbstractParticle, bd::Billiard) -&gt; i, tmin, cp</code></pre><p>Compute the <a href="#DynamicalBilliards.collision"><code>collision</code></a> across all obstacles in <code>bd</code> and find the minimum one. Return the index of colliding obstacle, the time and the collision point.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.nocollision</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.normalvec" href="#DynamicalBilliards.normalvec"><code>DynamicalBilliards.normalvec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalvec(obst::Obstacle, position)</code></pre><p>Return the vector normal to the obstacle&#39;s boundary at the given position (which is assumed to be very close to the obstacle&#39;s boundary).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.parallelize" href="#DynamicalBilliards.parallelize"><code>DynamicalBilliards.parallelize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parallelize(f, bd::Billiard, t, particles; partype = :threads)</code></pre><p>Parallelize function <code>f</code> across the available particles. The parallelization type can be <code>:threads</code> or <code>:pmap</code>, which use threads or a worker pool initialized with <code>addprocs</code> <em>before</em> <code>using DynamicalBilliards</code>.</p><p><code>particles</code> can be:</p><ul><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>. This uses <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</li></ul><p>The functions usable here are:</p><ul><li><a href="#DynamicalBilliards.meancollisiontime"><code>meancollisiontime</code></a></li><li><a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a></li><li><a href="#DynamicalBilliards.lyapunovspectrum"><code>lyapunovspectrum</code></a> (returns only the maximal exponents)</li><li><a href="#DynamicalBilliards.boundarymap"><code>boundarymap</code></a> (returns vector of vectors of 2-vectors <em>and</em> <code>arcintervals</code>)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.periodicity!" href="#DynamicalBilliards.periodicity!"><code>DynamicalBilliards.periodicity!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">periodicity!(p::AbstractParticle, w::PeriodicWall)</code></pre><p>Perform periodicity conditions of <code>w</code> on <code>p</code>.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.pertubationevolution</code></pre><pre><code class="language-none">DynamicalBilliards.perturbationevolution</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.perturbationgrowth" href="#DynamicalBilliards.perturbationgrowth"><code>DynamicalBilliards.perturbationgrowth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perturbationgrowth([p,] bd, t) -&gt; ts, Rs, is</code></pre><p>Calculate the evolution of the perturbation vector <code>Δ</code> along the trajectory of <code>p</code> in <code>bd</code> for total time <code>t</code>. <code>Δ</code> is initialised as <code>[1,1,1,1]</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. Returns empty lists for pinned particles.</p><p><strong>Description</strong></p><p>This function <em>safely</em> computes the time evolution of a perturbation vector using the linearized dynamics of the system, as outlined by [1]. Because the dynamics are linear, we can safely re-normalize the perturbation vector after every collision (otherwise the perturbations grow to infinity).</p><p>Immediately before <em>and after</em> every collison, this function computes</p><ul><li>the current time.</li><li>the element-wise ratio of Δ with its previous value</li><li>the obstacle index of the current obstacle</li></ul><p>and returns these in three vectors <code>ts, Rs, is</code>.</p><p>To obtain the <em>actual</em> evolution of the perturbation vector you can use the function <code>perturbationevolution(Rs)</code> which simply does</p><pre><code class="language-julia">Δ = Vector{SVector{4,Float64}}(undef, length(R))
Δ[1] = R[1]
for i in 2:length(R)
    Δ[i] = R[i] .* Δ[i-1]
end</code></pre><p>[1] : Ch. Dellago <em>et al</em>, <a href="http://link.aps.org/doi/10.1103/PhysRevE.53.1485">Phys. Rev. E <strong>53</strong> (1996)</a></p></div></div></section><pre><code class="language-none">DynamicalBilliards.perturbationgrowth!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.phasespace_portion" href="#DynamicalBilliards.phasespace_portion"><code>DynamicalBilliards.phasespace_portion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phasespace_portion(bd::Billiard, t, p::AbstractParticle, δξ, δφ = δξ)</code></pre><p>Calculate the portion of the phase space of the billiard <code>bd</code> covered by the particle <code>p</code> when it is evolved for time <code>t</code> (float or integer).</p><p>This function extends <a href="#DynamicalBilliards.boundarymap_portion"><code>boundarymap_portion</code></a> using a novel approach. For each visited box of the boundary map, <a href="#DynamicalBilliards.bounce!"><code>bounce!</code></a> attributes a third dimension (the collision time, equal to collision distance) which expands the two dimensions of the boundary map to the three dimensions of the phase space.</p><p>The true phase space portion is then the weighted portion of boxes visited by the particle, divided by the total weighted sum of boxes. The weights of the boxes are the collision times.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.pmap_pl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.project_to_line" href="#DynamicalBilliards.project_to_line"><code>DynamicalBilliards.project_to_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">project_to_line(point, c, n)</code></pre><p>Project given <code>point</code> to line that contains point <code>c</code> and has <strong>normal vector</strong> <code>n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.propagate!" href="#DynamicalBilliards.propagate!"><code>DynamicalBilliards.propagate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">propagate!(p::AbstractParticle, t)</code></pre><p>Propagate the particle <code>p</code> for given time <code>t</code>, changing appropriately the the <code>p.pos</code> and <code>p.vel</code> fields.</p><pre><code class="language-none">propagate!(p, position, t)</code></pre><p>Do the same, but take advantage of the already calculated <code>position</code> that the particle should end up at.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.propagate_offset!" href="#DynamicalBilliards.propagate_offset!"><code>DynamicalBilliards.propagate_offset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">propagate_offset!(offset::MArray{Tuple{4,4},T}, p::AbstractParticle)</code></pre><p>Computes the linearized evolution of the offset vectors during propagation for a time interval <code>t</code></p></div></div></section><pre><code class="language-none">DynamicalBilliards.propagate_posvel</code></pre><pre><code class="language-none">DynamicalBilliards.proper_ellipse_arclength</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.psos" href="#DynamicalBilliards.psos"><code>DynamicalBilliards.psos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">psos(bd::Billiard, plane::InfiniteWall, t, particles)</code></pre><p>Compute the Poincaré section of the <code>particles</code> with the given <code>plane</code>, by evolving each one for time <code>t</code> (either integer or float) inside <code>bd</code>.</p><p>The <code>plane</code> can be an <a href="#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a> of <em>any</em> orientation, however only crossings of the <code>plane</code> such that <code>dot(velocity, normal) &lt; 0</code> are allowed, with <code>normal</code> the normal unit vector of the <code>plane</code>.</p><p><code>particles</code> can be:</p><ul><li>A single particle.</li><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>.</li></ul><p>Return the positions <code>poss</code> and velocities <code>vels</code> at the instances of crossing the <code>plane</code>. If given more than one particle, the result is a vector of vectors of vectors.</p><p><em>Notice</em> - This function can handle pinned particles. If a pinned particle can intersect with the <code>plane</code>, then an intersection is returned. If however it can&#39;t then empty vectors are returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.randominside" href="#DynamicalBilliards.randominside"><code>DynamicalBilliards.randominside</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randominside(bd::Billiard [, ω])</code></pre><p>Return a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is <code>MagneticParticle</code>, with angular velocity <code>ω</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.raysplit_indices" href="#DynamicalBilliards.raysplit_indices"><code>DynamicalBilliards.raysplit_indices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">raysplit_indices(bd::Billiard, raysplitters::Tuple)</code></pre><p>Create a vector of integers. The <code>i</code>th entry tells you which entry of the <code>raysplitters</code> tuple is associated with the <code>i</code>th obstacle of the billiard.</p><p>If the <code>i</code>th entry is <code>0</code>, this means that the obstacle does not do raysplitting.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.real_pos" href="#DynamicalBilliards.real_pos"><code>DynamicalBilliards.real_pos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">real_pos(ξ, o::Obstacle)</code></pre><p>Converts the arclength coordinate <code>ξ</code> relative to the obstacle <code>o</code> into a real space position vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.realangle" href="#DynamicalBilliards.realangle"><code>DynamicalBilliards.realangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">realangle(p::MagneticParticle, o::Obstacle, I) -&gt; θ</code></pre><p>Given the intersection point <code>I</code> of the trajectory of a magnetic particle <code>p</code> with some obstacle <code>o</code>, find the real angle that will be spanned until the particle collides with the obstacle.</p><p>The function also takes care of problems that may arise when particles are very close to the obstacle&#39;s boundaries, due to floating-point precision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.relocate!" href="#DynamicalBilliards.relocate!"><code>DynamicalBilliards.relocate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">relocate!(p::AbstractParticle, o::Obstacle, t, cp)</code></pre><p>Propagate the particle to <code>cp</code> and propagate velocities for time <code>t</code>. Check if it is on the correct side of the obstacle. If not, change the particle position by <a href="#DynamicalBilliards.distance"><code>distance</code></a> along the <a href="#DynamicalBilliards.normalvec"><code>normalvec</code></a> of the obstacle.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.relocate_rayspl!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.reset_billiard!" href="#DynamicalBilliards.reset_billiard!"><code>DynamicalBilliards.reset_billiard!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reset_billiard!(bd)</code></pre><p>Sets the <code>pflag</code> field of all ray-splitting obstacles of a billiard table to <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.resolvecollision!" href="#DynamicalBilliards.resolvecollision!"><code>DynamicalBilliards.resolvecollision!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resolvecollision!(p::AbstractParticle, o::Obstacle)</code></pre><p>Resolve the collision between particle <code>p</code> and obstacle <code>o</code>, depending on the type of <code>o</code> (do <code>specular!</code> or <code>periodicity!</code>).</p><pre><code class="language-none">resolvecollision!(p, o, T::Function, θ::Function, new_ω::Function)</code></pre><p>This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to <code>evolve!()</code>. For a calculated incidence angle φ, if T(φ) &gt; rand(), ray-splitting occurs.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.sixsqrt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.specular!" href="#DynamicalBilliards.specular!"><code>DynamicalBilliards.specular!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">specular!(p::AbstractParticle, o::Obstacle)</code></pre><p>Perform specular reflection based on the normal vector of the Obstacle.</p><p>In the case where the given obstacle is a <code>RandomObstacle</code>, the specular reflection randomizes the velocity instead (within -π/2+ε to π/2-ε of the normal vector).</p></div></div></section><pre><code class="language-none">DynamicalBilliards.supports_raysplitting</code></pre><pre><code class="language-none">DynamicalBilliards.threads_pl</code></pre><pre><code class="language-none">DynamicalBilliards.timeprec_rayspl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.timeseries" href="#DynamicalBilliards.timeseries"><code>DynamicalBilliards.timeseries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timeseries(p, args...; kwargs...)</code></pre><p>Non-mutating version of <a href="#DynamicalBilliards.timeseries!"><code>timeseries!</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.timeseries!" href="#DynamicalBilliards.timeseries!"><code>DynamicalBilliards.timeseries!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)</code></pre><p>Evolves the given particle <code>p</code> inside the billiard <code>bd</code>.  If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Returns the time series for position and velocity as well as the time vector.</p><p>This function mutates the particle, use <code>timeseries</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p>The keyword argument <code>dt</code> is the time step used for interpolating the time series in between collisions. <code>dt</code> is capped by the collision time, as the interpolation <em>always</em> stops at collisions. For straight propagation <code>dt = Inf</code>, while for magnetic <code>dt = 0.01</code>.</p><p>For pinned magnetic particles, <code>timeseries!</code> issues a warning and returns the trajectory of the particle. If <code>t</code> is integer, the trajectory is evolved for one full circle only</p><p>Return:</p><ul><li>x position time-series</li><li>y position time-series</li><li>x velocity time-series</li><li>y velocity time-series</li><li>time vector</li></ul><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">timeseries!(p, bd, t, raysplitters; ...)</code></pre><p>To implement ray-splitting, the <code>timeseries!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>timeseries</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.to_bcoords" href="#DynamicalBilliards.to_bcoords"><code>DynamicalBilliards.to_bcoords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_bcoords(pos, vel, o::Obstacle) -&gt; ξ, sφ</code></pre><p>Convert the real coordinates <code>pos, vel</code> to boundary coordinates (also known as Birkhoff coordinates) <code>ξ, sφ</code>, assuming that <code>pos</code> is on the obstacle.</p><p><code>ξ</code> is the arc-coordinate, i.e. it parameterizes the arclength of the obstacle. <code>sφ</code> is the sine of the angle between the velocity vector and the vector normal to the obstacle.</p><p>The arc-coordinate <code>ξ</code> is measured as:</p><ul><li>the distance from start point to end point in <code>Wall</code>s</li><li>the arc length measured counterclockwise from the open face in <code>Semicircle</code>s</li><li>the arc length measured counterclockwise from the rightmost point in <code>Circular</code>/<code>Ellipse</code>s</li></ul><p>Notice that this function returns the <em>local</em> arclength. To get the global arclength parameterizing an entire billiard, simply do <code>ξ += arcintervals(bd)[i]</code> if the index of obstacle <code>o</code> is <code>i</code>.</p><p>See also <a href="#DynamicalBilliards.from_bcoords"><code>from_bcoords</code></a>, which is the inverse function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.totallength" href="#DynamicalBilliards.totallength"><code>DynamicalBilliards.totallength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">totallength(o::Obstacle)</code></pre><p>Return the total boundary length of <code>o</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicalBilliards.translate" href="#DynamicalBilliards.translate"><code>DynamicalBilliards.translate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">translate(obst::Obstacle, vector)</code></pre><p>Create a copy of the given obstacle with its position translated by <code>vector</code>.</p></div></div></section><pre><code class="language-none">DynamicalBilliards.δpind</code></pre><pre><code class="language-none">DynamicalBilliards.δqind</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
