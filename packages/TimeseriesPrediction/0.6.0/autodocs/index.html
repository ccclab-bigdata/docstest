<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · TimeseriesPrediction.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TimeseriesPrediction.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">TimeseriesPrediction.@SMatrix</code></pre><pre><code class="language-none">TimeseriesPrediction.@SVector</code></pre><pre><code class="language-none">TimeseriesPrediction.@pack_PredictionParameters</code></pre><pre><code class="language-none">TimeseriesPrediction.@pack_PredictionParameters!</code></pre><pre><code class="language-none">TimeseriesPrediction.@unpack_PredictionParameters</code></pre><pre><code class="language-none">TimeseriesPrediction.ASE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.AbstractBoundaryCondition" href="#TimeseriesPrediction.AbstractBoundaryCondition"><code>TimeseriesPrediction.AbstractBoundaryCondition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractBoundaryCondition</code></pre><p>Super-type of boundary conditions for <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a>. Use <code>subtypes(AbstractBoundaryCondition)</code> for available methods.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.AbstractDataset</code></pre><pre><code class="language-none">TimeseriesPrediction.AbstractEmbedding</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.AbstractLocalModel" href="#TimeseriesPrediction.AbstractLocalModel"><code>TimeseriesPrediction.AbstractLocalModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractLocalModel</code></pre><p>Supertype of methods for making a prediction of a query point <code>q</code> using local models, following the methods of [1]. Concrete subtypes are <code>AverageLocalModel</code> and <code>LinearLocalModel</code>.</p><p>All models weight neighbors with a chosen function, so that distant neighbors have smaller impact on the prediction and so that the interpolation is smooth. The default weighting function we use is</p><div>\[\begin{aligned}
ω_i(d_i,d_{max}) = \left[ 1- \left(\frac{d_i}{d_{max}}\right)^2\right]^4
\end{aligned}\]</div><p>with <span>$d_i = ||x_{nn,i} -q||_2$</span> being the distance of each neighbor from the query point.</p><p>You can also provide your own function or give <code>ω_safe(d, dmax) = dmax &gt; 0 ? (1.1 - (d/dmax)^2)^4 : 1.0</code> for a safe version of <span>$ω$</span> that takes into acount edge cases. Finally you can also give <code>nothing</code> in place of <code>ω</code>. In that case no weighting is done and direct average of neighbors is returned.</p><p><strong>Average Local Model</strong></p><pre><code class="language-none">AverageLocalModel(ω)</code></pre><p>The prediction is simply the weighted average of the images <span>$y_{nn, i}$</span> of the neighbors <span>$x_{nn, i}$</span> of the query point <code>q</code>, weighting using given function <code>ω</code></p><div>\[\begin{aligned}
y_{pred} = \frac{\sum{\omega_i y_{nn,i}}}{\sum{\omega_i}}
\end{aligned}\]</div><p><strong>Linear Local Model</strong></p><pre><code class="language-none">LinearLocalModel([ω ], μ::Real=2.])
LinearLocalModel([ω ], s_min::Real, s_max::Real)</code></pre><p>The prediction is a weighted linear regression over the neighbors <span>$x_{nn, i}$</span> of the query and their images <span>$y_{nn,i}$</span> as shown in [1].</p><p>Giving either <code>μ</code> or <code>s_min</code> and <code>s_max</code> determines which type of regularization is applied.</p><ul><li><code>μ</code> : Ridge Regression<div>\[\begin{aligned}
f(\sigma) = \frac{\sigma^2}{\mu^2 + \sigma^2}
\end{aligned}\]</div></li><li><code>s_min</code>, <code>s_max</code> : Soft Threshold<div>\[\begin{aligned}
f(\sigma) = \begin{cases} 0, &amp; \sigma &lt; s_{min}\\
\left(1 - \left( \frac{s_{max}-\sigma}{s_{max}-s_{min}}\right)^2 \right)^2,
&amp;s_{min} \leq \sigma \leq s_{max} \\
1, &amp; \sigma &gt; s_{max}\end{cases}
\end{aligned}\]</div></li></ul><p><strong>References</strong></p><p>[1] : D. Engster &amp; U. Parlitz, <em>Handbook of Time Series Analysis</em> Ch. 1, VCH-Wiley (2006)</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.AbstractNeighborhood</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.AbstractSpatialEmbedding" href="#TimeseriesPrediction.AbstractSpatialEmbedding"><code>TimeseriesPrediction.AbstractSpatialEmbedding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractSpatialEmbedding &lt;: AbstractEmbedding</code></pre><p>Super-type of spatiotemporal embedding methods. Valid subtypes:</p><ul><li><code>SpatioTemporalEmbedding</code></li><li><code>PCAEmbedding</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.AverageLocalModel" href="#TimeseriesPrediction.AverageLocalModel"><code>TimeseriesPrediction.AverageLocalModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AverageLocalModel(ω::Function = ω_unsafe)</code></pre><p>See <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.CDS_KWARGS</code></pre><pre><code class="language-none">TimeseriesPrediction.Chebyshev</code></pre><pre><code class="language-none">TimeseriesPrediction.Cityblock</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.ConstantBoundary" href="#TimeseriesPrediction.ConstantBoundary"><code>TimeseriesPrediction.ConstantBoundary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstantBoundary(c) &lt;: AbstractBoundaryCondition</code></pre><p>Constant boundary condition type. Enforces constant boundary conditions when passed to <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a> by filling missing out-of-bounds values in the reconstruction with parameter <code>c</code>.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.ContinuousDynamicalSystem</code></pre><pre><code class="language-none">TimeseriesPrediction.Dataset</code></pre><pre><code class="language-none">TimeseriesPrediction.DelayEmbedding</code></pre><pre><code class="language-none">TimeseriesPrediction.DelayEmbeddings</code></pre><pre><code class="language-none">TimeseriesPrediction.DiscreteDynamicalSystem</code></pre><pre><code class="language-none">TimeseriesPrediction.DynamicalSystem</code></pre><pre><code class="language-none">TimeseriesPrediction.DynamicalSystemsBase</code></pre><pre><code class="language-none">TimeseriesPrediction.Euclidean</code></pre><pre><code class="language-none">TimeseriesPrediction.FixedMassNeighborhood</code></pre><pre><code class="language-none">TimeseriesPrediction.FixedSizeNeighborhood</code></pre><pre><code class="language-none">TimeseriesPrediction.KDTree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.LinearLocalModel" href="#TimeseriesPrediction.LinearLocalModel"><code>TimeseriesPrediction.LinearLocalModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinearLocalModel([ω ], μ::Real=2.])
LinearLocalModel([ω ], s_min::Real, s_max::Real)</code></pre><p>See <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.MSE1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.MSEp" href="#TimeseriesPrediction.MSEp"><code>TimeseriesPrediction.MSEp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MSEp(R::AbstractDataset{D,T}, R_test, p; method, ntype, stepsize) -&gt; error</code></pre><p>Compute mean squared error of iterated predictions of length <code>p</code> using test set <code>R_test</code>.</p><p><strong>Description</strong></p><p>This error measure takes in a prediction model consisting of <code>R</code>, <code>method</code>, <code>ntype</code> and <code>stepsize</code> and evaluates its performance. The test set <code>R_test</code> is a delay reconstruction with the same delay <code>τ</code> and dimension <code>D</code> as <code>R</code>. For each subset of <code>R_test</code> with length <code>p</code> it calls <code>localmodel_tsp</code>. The model error is then defined as</p><div>\[\begin{aligned}
MSE_p = \frac{1}{p|T_{ref}|}\sum_{t\in T_{ref}}\sum_{i=1}^{p} \left(y_{t+i}
- y_{pred,t+i} \right)^2
\end{aligned}\]</div><p>where <span>$|T_{ref}|$</span> is the number of subsets of <code>R_test</code> used.</p><p><strong>References</strong></p><p>See <a href="#TimeseriesPrediction.localmodel_tsp"><code>localmodel_tsp</code></a>.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.MTDelayEmbedding</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.PCAEmbedding" href="#TimeseriesPrediction.PCAEmbedding"><code>TimeseriesPrediction.PCAEmbedding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PCAEmbedding(s, em::SpatioTemporalEmbedding; kwargs...) → embedding</code></pre><p>A spatio temporal delay coordinates structure with Principal Component Analysis as a means of dimension reduction, <code>embedding</code> can be used as a functor:</p><pre><code class="language-julia">embedding(rvec, s, t, α)</code></pre><p>which operates inplace on <code>rvec</code> and reconstructs vector from spatial time series <code>s</code> at timestep <code>t</code> and cartesian index <code>α</code>.</p><p>To instantiate this <code>embedding</code>, give the data to be reconstructed <code>s</code> as well as an instance of <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a> to <code>PCAEmbedding</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>pratio = 0.99</code> : Ratio of variances that needs to be preserved in low-dimensional PCA-reconstruction.</li><li><code>maxoutdim = 25</code>: Upper limit for output dimension. May break <code>pratio</code> criterion.</li><li><code>every_t = 1</code> : Speed up computation by only using every n-th point in time.</li><li><code>every_α = 1</code> : Speed up computation further by only using every n-th point in space (linear indexing).</li></ul><p>To set the output dimension to a certain value <code>X</code>, pass <code>pratio=1, maxoutdim=X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.PeriodicBoundary" href="#TimeseriesPrediction.PeriodicBoundary"><code>TimeseriesPrediction.PeriodicBoundary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PeriodicBoundary &lt;: AbstractBoundaryCondition</code></pre><p>Periodic boundary condition struct. Enforces periodic boundary conditions when passed to <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a> in the reconstruction.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.PredictionParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.Region" href="#TimeseriesPrediction.Region"><code>TimeseriesPrediction.Region</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Region{Φ}</code></pre><p>Internal struct for efficiently keeping track of region far from boundaries of field. Used to speed up reconstruction process.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.SMatrix</code></pre><pre><code class="language-none">TimeseriesPrediction.STE</code></pre><pre><code class="language-none">TimeseriesPrediction.SVector</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.SpatioTemporalEmbedding" href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>TimeseriesPrediction.SpatioTemporalEmbedding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SpatioTemporalEmbedding{T,Φ,BC,X} → embedding</code></pre><p>A spatio temporal delay coordinates structure to be used as a functor. Applies to data of <code>Φ</code> spatial dimensions and gives an embedding of dimensionality <code>X</code>.</p><pre><code class="language-none">embedding(rvec, s, t, α)</code></pre><p>Operates inplace on <code>rvec</code> (of length <code>X</code>) and reconstructs vector from spatial timeseries <code>s</code> at timestep <code>t</code> and cartesian index <code>α</code>. Note that there are no bounds checks for <code>t</code>.</p><p>It is assumed that <code>s</code> is a <code>Vector{&lt;:AbstractArray{T,Φ}}</code>.</p><p><strong>Constructors</strong></p><p>There are some convenience constructors that return intuitive embeddings here:</p><ul><li><a href="#TimeseriesPrediction.cubic_shell_embedding"><code>cubic_shell_embedding</code></a></li><li><a href="#TimeseriesPrediction.light_cone_embedding"><code>light_cone_embedding</code></a></li></ul><p>The &quot;main&quot; constructor is</p><pre><code class="language-none">SpatioTemporalEmbedding{X}(τ, β, bc, fsize)</code></pre><p>which allows full control over the spatio-temporal embedding.</p><ul><li><code>Χ == length(τ) == length(β)</code> : dimensionality of resulting reconstructed space.</li><li><code>τ::Vector{Int}</code> = Vector of temporal delays <em>for each entry</em> of the reconstructed space (sorted in ascending order).</li><li><code>β::Vector{CartesianIndex{Φ}}</code> = vector of <em>relative</em> indices of spatial delays <em>for each entry</em> of the reconstructed space.</li><li><code>bc::BC</code> : boundary condition.</li><li><code>fsize::NTuple{Φ, Int}</code> : Size of each state in the timeseries.</li></ul></div></div></section><pre><code class="language-none">TimeseriesPrediction.Systems</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.TimeseriesPrediction" href="#TimeseriesPrediction.TimeseriesPrediction"><code>TimeseriesPrediction.TimeseriesPrediction</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Prediction of timeseries using methods of nonlinear dynamics and timeseries analysis</p></div></div></section><pre><code class="language-none">TimeseriesPrediction._localmodel_tsp</code></pre><pre><code class="language-none">TimeseriesPrediction.autocor</code></pre><pre><code class="language-none">TimeseriesPrediction.columns</code></pre><pre><code class="language-none">TimeseriesPrediction.compute_pca</code></pre><pre><code class="language-none">TimeseriesPrediction.convert_idx</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.crossprediction" href="#TimeseriesPrediction.crossprediction"><code>TimeseriesPrediction.crossprediction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">crossprediction(source_train, target_train, source_pred,
                em::AbstractSpatialEmbedding; kwargs...)</code></pre><p>Perform a spatio-temporal timeseries cross-prediction for <code>target</code> from <code>source</code>, using local weighted modeling [1]. This can be used for example when there are coupled spatial fields and one is used to predict the other. It is assumed that <code>source_train</code>, <code>target_train</code>, <code>source_pred</code> are all of the same type, <code>AbstractVector{&lt;:AbstractArray{T, Φ}}</code>.</p><p>The spatio temporal delay embedding process is defined by <code>em</code>. See <a href="#TimeseriesPrediction.AbstractSpatialEmbedding"><code>AbstractSpatialEmbedding</code></a> for available methods and interfaces.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ttype = KDTree</code> : Type/Constructor of tree structure. So far only tested with <code>KDTree</code>.</li><li><code>method = AverageLocalModel(ω_safe)</code> : Subtype of <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</li><li><code>ntype = FixedMassNeighborhood(3)</code> : Subtype of <a href="@ref"><code>AbstractNeighborhood</code></a>.</li><li><code>progress = true</code> : To print progress done.</li></ul><p><strong>Description</strong></p><p>The reconstructed state of <code>source_train[t][i,j,...]</code> is associated with the output value <code>target_train[t][i,j,...]</code>. This establishes a &quot;connection&quot; between <code>target</code> and <code>source</code>. Taking a reconstructed state of <code>source_pred</code> as query point, the function finds its neighbors in the reconstructed space of <code>source_train</code> using neighborhood <code>ntype</code>. Then, the neighbor <em>indices</em> are used to make a prediction for the corresponding value of the <code>target</code>, using the established &quot;connection&quot; between fields.</p><p><strong>Additional Interfaces</strong></p><p>To save computation time in the case of repeated predictions with the same training set and embedding parameters we provide an additional interface that allows the user to provide an existing reconstruction and tree structure.</p><pre><code class="language-julia">R = reconstruct(train_in, em)
tree = ttype(R)
params = PredictionParams(em, method, ntype, ttype)
sol = crossprediction(params, train_out, pred_in, R, tree; progress=true)</code></pre><p>where <code>params</code> is an internal container with all relevant parameters.</p><p><strong>Performance Notes</strong></p><p>Be careful when choosing embedding parameters as memory usage and computation time depend strongly on the resulting embedding dimension.</p><p><strong>References</strong></p><p>[1] : U. Parlitz &amp; C. Merkwirth, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.84.1890">Phys. Rev. Lett. <strong>84</strong>, pp 1890 (2000)</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.cubic_shell_embedding" href="#TimeseriesPrediction.cubic_shell_embedding"><code>TimeseriesPrediction.cubic_shell_embedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cubic_shell_embedding(s, D, τ, B, k, bc) → embedding</code></pre><p>Create a <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a> instance that includes spatial neighbors in hypercubic <em>shells</em>. The embedding is to be used with data from <code>s</code>.</p><p><strong>Description</strong></p><p>Points are participating in the embedding by forming hypercubic shells around the current point. The total shells formed are <code>B</code>. The points on the shells have spatial distance <code>k ≥ 1</code> (distance in indices, like a cityblock metric). <code>k = 1</code> means that all points of the shell participate. The points of the hypercubic grid can be separated by <code>k ≥ 1</code> points apart (i.e. dropping <code>k-1</code> in-between points). In short, in each spatial dimension of the system the cartesian offset indices are <code>-B*k : k : k*B</code>.</p><p><code>D</code> is the number of temporal steps in the past to be included in the embedding, where each step in the past has additional delay time <code>τ::Int</code>. <code>D=0</code> corresponds to using only the present. Notice that <strong>all</strong> embedded time frames have the same spatial structure, in contrast to <a href="#TimeseriesPrediction.light_cone_embedding"><code>light_cone_embedding</code></a>.</p><p>As an example, consider one of the <code>D</code> embedded frames (all are the same) of a system with 2 spatial dimensions (<code>□</code> = current point, (included <em>by definition</em> in the embedding), <code>n</code> = included points in the embedding coming from <code>n</code>-th shell, <code>.</code> = points not included in the embedding)</p><pre><code class="language-none">      B = 2,  k = 1        |        B = 1,  k = 2        |        B = 2,  k = 2
                           |                             |
.  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .  |  2  .  2  .  2  .  2  .  2
.  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .
.  .  2  2  2  2  2  .  .  |  .  .  1  .  1  .  1  .  .  |  2  .  1  .  1  .  1  .  2
.  .  2  1  1  1  2  .  .  |  .  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .
.  .  2  1  □  1  2  .  .  |  .  .  1  .  □  .  1  .  .  |  2  .  1  .  □  .  1  .  2
.  .  2  1  1  1  2  .  .  |  .  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .
.  .  2  2  2  2  2  .  .  |  .  .  1  .  1  .  1  .  .  |  2  .  1  .  1  .  1  .  2
.  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .
.  .  .  .  .  .  .  .  .  |  .  .  .  .  .  .  .  .  .  |  2  .  2  .  2  .  2  .  2</code></pre></div></div></section><pre><code class="language-none">TimeseriesPrediction.cut_off_beginning!</code></pre><pre><code class="language-none">TimeseriesPrediction.dimension</code></pre><pre><code class="language-none">TimeseriesPrediction.embed</code></pre><pre><code class="language-none">TimeseriesPrediction.estimate_delay</code></pre><pre><code class="language-none">TimeseriesPrediction.estimate_dimension</code></pre><pre><code class="language-none">TimeseriesPrediction.eval</code></pre><pre><code class="language-none">TimeseriesPrediction.exponential_decay_fit</code></pre><pre><code class="language-none">TimeseriesPrediction.gen_queries</code></pre><pre><code class="language-none">TimeseriesPrediction.get_deviations</code></pre><pre><code class="language-none">TimeseriesPrediction.get_num_pt</code></pre><pre><code class="language-none">TimeseriesPrediction.get_state</code></pre><pre><code class="language-none">TimeseriesPrediction.get_usable_idxs</code></pre><pre><code class="language-none">TimeseriesPrediction.get_τmax</code></pre><pre><code class="language-none">TimeseriesPrediction.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.indices_within_sphere" href="#TimeseriesPrediction.indices_within_sphere"><code>TimeseriesPrediction.indices_within_sphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">indices_within_sphere(r, Φ) → β</code></pre><p>Return all cartesian indices within a hypersphere or radius <code>r</code> and dimension <code>Φ</code>.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.inner_region</code></pre><pre><code class="language-none">TimeseriesPrediction.integrator</code></pre><pre><code class="language-none">TimeseriesPrediction.jacobian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.light_cone_embedding" href="#TimeseriesPrediction.light_cone_embedding"><code>TimeseriesPrediction.light_cone_embedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">light_cone_embedding(s, D, τ, r₀, c, bc) → embedding</code></pre><p>Create a <a href="#TimeseriesPrediction.SpatioTemporalEmbedding"><code>SpatioTemporalEmbedding</code></a> instance that includes spatial and temporal neighbors of a point based on the notion of a <em>light cone</em>.</p><p>The embedding is to be used with data from <code>s</code>.</p><p><strong>Description</strong></p><p>Information does not travel instantly but with some finite speed <code>c ≥ 0.0</code>. This constructor creates a cone-like embedding including all points in space and time, whose value can influence a prediction based on the information speed <code>c</code>. <code>D</code> is the number of temporal steps in the past to be included in the embedding, where each step in the past has additional delay time <code>τ::Int</code>. <code>D=0</code> corresponds to using only the present. <code>r₀</code> is the initial radius at the top of the cone, i.e. the radius of influence at the present. <code>bc</code> is the boundary condition.</p><p>The radius of the light cone evolves as: <code>r = i*τ*c + r₀</code> for each step <code>i ∈ 0:D</code>.</p><p>As an example, in a one-dimensional system with <code>D = 1, τ = 2, r₀ = 1</code>, the embedding looks like (<code>□</code> = current point (included <em>by definition</em> in the embedding), <code>o</code> point to be predicted using <a href="#TimeseriesPrediction.temporalprediction"><code>temporalprediction</code></a>, <code>x</code> = points included in the embedding, <code>.</code> = points not included in the embedding)</p><pre><code class="language-none">time  | c = 1.0               | c = 2.0               | c = 0.0

n + 1 | ..........o.......... | ..........o.......... | ..........o..........
n     | .........x□x......... | .........x□x......... | .........x□x.........
n - 1 | ..................... | ..................... | .....................
n - τ | .......xxxxxxx....... | .....xxxxxxxxxx...... | .........xxx.........</code></pre><p>Besides this example, in the official documentation we show a function <code>explain_light_cone</code> which produces a plot of the light cone for 2 spatial dimensions (great for understanding!).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.localmodel_cp" href="#TimeseriesPrediction.localmodel_cp"><code>TimeseriesPrediction.localmodel_cp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">localmodel_cp(source_pool, target_pool, source_pred,  D, τ; kwargs...)</code></pre><p>Perform a cross prediction from  <em>source</em> to <em>target</em>, using local weighted modeling [1]. <code>source_pred</code> is the input for the prediction and <code>source_pool</code> and <code>target_pool</code> are used as pooling/training data for the predictions. The function always returns an object of the same type as <code>target_pool</code>, which can be either a timeseries (vector) or an <code>AbstractDataset</code> (trajectory).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>method = AverageLocalModel(ω_unsafe)</code> : Subtype of <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</li><li><code>ntype = FixedMassNeighborhood(2)</code> : Subtype of <a href="@ref"><code>AbstractNeighborhood</code></a>.</li><li><code>stepsize = 1</code> : Prediction step size.</li></ul><p>Instead of passing <code>D</code> &amp; <code>τ</code> for reconstruction one may also give existing <a href="@ref"><code>Dataset</code></a>s as <code>source_pool</code> and <code>source_pred</code>. In this case an additional keyword argument <code>y_idx_shift::Int=0</code> may be necessary to account for the index shift introduced in the reconstruction process.</p><p><strong>Description</strong></p><p>Given a query point, the function finds its neighbors using neighborhood <code>ntype</code>. Then, the neighbors <code>xnn</code> and their images <code>ynn</code> are used to make a prediction for the image of the query point, using the provided <code>method</code>.</p><p><strong>References</strong></p><p>[1] : D. Engster &amp; U. Parlitz, <em>Handbook of Time Series Analysis</em> Ch. 1, VCH-Wiley (2006)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.localmodel_tsp" href="#TimeseriesPrediction.localmodel_tsp"><code>TimeseriesPrediction.localmodel_tsp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">localmodel_tsp(s, D::Int, τ, p::Int; method, ntype, stepsize)
localmodel_tsp(s, p::Int; method, ntype, stepsize)</code></pre><p>Perform a timeseries prediction for <code>p</code> points, using local weighted modeling [1]. The function always returns an object of the same type as <code>s</code>, which can be either a timeseries (vector) or an <code>AbstractDataset</code> (trajectory), and the returned data always contains the final point of <code>s</code> as starting point. This means that the returned data has length of <code>p + 1</code>.</p><p>If given <code>(s, D, τ)</code>, it first calls <a href="#DelayEmbeddings.reconstruct"><code>reconstruct</code></a> on <code>s</code> with dimension <code>D</code> and delay <code>τ</code>. If given only <code>s</code> then no reconstruction is done.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>method = AverageLocalModel(ω_unsafe)</code> : Subtype of <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</li><li><code>ntype = FixedMassNeighborhood(2)</code> : Subtype of <a href="@ref"><code>AbstractNeighborhood</code></a>.</li><li><code>stepsize = 1</code> : Prediction step size.</li></ul><p><strong>Description</strong></p><p>Given a query point, the function finds its neighbors using neighborhood <code>ntype</code>. Then, the neighbors <code>xnn</code> and their images <code>ynn</code> are used to make a prediction for the future of the query point, using the provided <code>method</code>. The images <code>ynn</code> are the points <code>xnn</code> shifted by <code>stepsize</code> into the future.</p><p>The algorithm is applied iteratively until a prediction of length <code>p</code> has been created, starting with the query point to be the last point of the timeseries.</p><p><strong>References</strong></p><p>[1] : D. Engster &amp; U. Parlitz, <em>Handbook of Time Series Analysis</em> Ch. 1, VCH-Wiley (2006)</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.maxima</code></pre><pre><code class="language-none">TimeseriesPrediction.mcnames_reg</code></pre><pre><code class="language-none">TimeseriesPrediction.min_pairwise_distance</code></pre><pre><code class="language-none">TimeseriesPrediction.minima</code></pre><pre><code class="language-none">TimeseriesPrediction.minmaxima</code></pre><pre><code class="language-none">TimeseriesPrediction.mutualinformation</code></pre><pre><code class="language-none">TimeseriesPrediction.neighborhood</code></pre><pre><code class="language-none">TimeseriesPrediction.neighborhood_and_distances</code></pre><pre><code class="language-none">TimeseriesPrediction.orthonormal</code></pre><pre><code class="language-none">TimeseriesPrediction.outdim</code></pre><pre><code class="language-none">TimeseriesPrediction.parallel_integrator</code></pre><pre><code class="language-none">TimeseriesPrediction.project_inside</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayEmbeddings.reconstruct" href="#DelayEmbeddings.reconstruct"><code>DelayEmbeddings.reconstruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reconstruct(s::AbstractArray{&lt;:AbstractArray{T,Φ}}, em)</code></pre><p>Reconstruct the spatial timeseries <code>s</code> represented by a <code>Vector</code> of <code>AbstractArray</code> states using the embedding struct <code>em</code> of type <a href="#TimeseriesPrediction.AbstractSpatialEmbedding"><code>AbstractSpatialEmbedding</code></a>.</p><p>Returns the reconstruction in the form of a <a href="@ref"><code>Dataset</code></a> where each row is a reconstructed state and they are ordered first through linear indexing into each state and then incrementing in time.</p></div></div></section><pre><code class="language-none">TimeseriesPrediction.reinit!</code></pre><pre><code class="language-none">TimeseriesPrediction.ridge_reg</code></pre><pre><code class="language-none">TimeseriesPrediction.set_deviations!</code></pre><pre><code class="language-none">TimeseriesPrediction.set_parameter!</code></pre><pre><code class="language-none">TimeseriesPrediction.set_state!</code></pre><pre><code class="language-none">TimeseriesPrediction.step!</code></pre><pre><code class="language-none">TimeseriesPrediction.stochastic_indicator</code></pre><pre><code class="language-none">TimeseriesPrediction.tangent_integrator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeseriesPrediction.temporalprediction" href="#TimeseriesPrediction.temporalprediction"><code>TimeseriesPrediction.temporalprediction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">temporalprediction(U, em::AbstractSpatialEmbedding, tsteps; kwargs...)</code></pre><p>Perform a spatio-temporal time series prediction for <code>tsteps</code> iterations, using local weighted modeling [1] give a time series of the form <code>U::AbstractVector{&lt;:AbstractArray{T, Φ}}</code>.</p><p>The returned data always contains the final state of <code>U</code> as starting point (total returned length is <code>tsteps+1</code>). The reconstruction process is defined by <code>em</code>. For available methods and interfaces see <a href="#TimeseriesPrediction.AbstractSpatialEmbedding"><code>AbstractSpatialEmbedding</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ttype = KDTree</code> : Type/Constructor of tree structure. So far only tested with <code>KDTree</code>.</li><li><code>method = AverageLocalModel(ω_safe)</code> : Subtype of <a href="#TimeseriesPrediction.AbstractLocalModel"><code>AbstractLocalModel</code></a>.</li><li><code>ntype = FixedMassNeighborhood(3)</code> : Subtype of <a href="@ref"><code>AbstractNeighborhood</code></a>.</li><li><code>initial_ts = U</code> : Initial states for prediction (same type as <code>U</code>).  Must have at least as many states as the maximum delay time used. Defaults to the training set <code>U</code>.</li><li><code>progress = true</code> : To print progress done.</li></ul><p><strong>Description</strong></p><p>This method works similarly to <a href="#TimeseriesPrediction.localmodel_tsp"><code>localmodel_tsp</code></a>, by expanding the concept of delay embedding to spatially extended systems. Instead of reconstructing complete states of the system, local states are used. See <a href="#TimeseriesPrediction.AbstractSpatialEmbedding"><code>AbstractSpatialEmbedding</code></a> for details on the embedding. Predictions are then performed frame by frame and point py point. Once all values for a new frame are found, the frame is added to the end of the timeseries and used to generate new prediction queries for the next time step.</p><p><strong>Performance Notes</strong></p><p>Be careful when choosing embedding parameters as memory usage and computation time depend strongly on the resulting embedding dimension.</p><p><strong>References</strong></p><p>[1] : U. Parlitz &amp; C. Merkwirth, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.84.1890">Phys. Rev. Lett. <strong>84</strong>, pp 1890 (2000)</a></p></div></div></section><pre><code class="language-none">TimeseriesPrediction.trajectory</code></pre><pre><code class="language-none">TimeseriesPrediction.working_ts</code></pre><pre><code class="language-none">TimeseriesPrediction.ω_safe</code></pre><pre><code class="language-none">TimeseriesPrediction.ω_unsafe</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
