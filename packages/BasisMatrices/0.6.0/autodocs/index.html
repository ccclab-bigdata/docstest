<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BasisMatrices.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BasisMatrices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BasisMatrices.ABSR</code></pre><pre><code class="language-none">BasisMatrices.AbstractBasisMatrixRep</code></pre><pre><code class="language-none">BasisMatrices.Basis</code></pre><pre><code class="language-none">BasisMatrices.BasisFamily</code></pre><pre><code class="language-none">BasisMatrices.BasisMatrices</code></pre><pre><code class="language-none">BasisMatrices.BasisMatrix</code></pre><pre><code class="language-none">BasisMatrices.BasisParams</code></pre><pre><code class="language-none">BasisMatrices.BasisStructure</code></pre><pre><code class="language-none">BasisMatrices.Cheb</code></pre><pre><code class="language-none">BasisMatrices.ChebParams</code></pre><pre><code class="language-none">BasisMatrices.Degree</code></pre><pre><code class="language-none">BasisMatrices.Derivative</code></pre><pre><code class="language-none">BasisMatrices.Direct</code></pre><pre><code class="language-none">BasisMatrices.Expanded</code></pre><pre><code class="language-none">BasisMatrices.IntSorV</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.Interpoland" href="#BasisMatrices.Interpoland"><code>BasisMatrices.Interpoland</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Construct an Interpoland from a function.</p><p>The function must have the signature <code>f(::AbstractMatrix)::AbstractArray</code> where each column of the input matrix is a vector of values along a single dimension</p></div></div></section><pre><code class="language-none">BasisMatrices.Lin</code></pre><pre><code class="language-none">BasisMatrices.LinParams</code></pre><pre><code class="language-none">BasisMatrices.Permuter</code></pre><pre><code class="language-none">BasisMatrices.RKSS</code></pre><pre><code class="language-none">BasisMatrices.RowKron</code></pre><pre><code class="language-none">BasisMatrices.Smolyak</code></pre><pre><code class="language-none">BasisMatrices.SmolyakParams</code></pre><pre><code class="language-none">BasisMatrices.Spline</code></pre><pre><code class="language-none">BasisMatrices.SplineParams</code></pre><pre><code class="language-none">BasisMatrices.SplineSparse</code></pre><pre><code class="language-none">BasisMatrices.Tensor</code></pre><pre><code class="language-none">BasisMatrices.TensorX</code></pre><pre><code class="language-none">BasisMatrices._Basis</code></pre><pre><code class="language-none">BasisMatrices._Basis2</code></pre><pre><code class="language-none">BasisMatrices._all_sparse</code></pre><pre><code class="language-none">BasisMatrices._allocate_row_kron_out</code></pre><pre><code class="language-none">BasisMatrices._check_cdprodx</code></pre><pre><code class="language-none">BasisMatrices._check_order</code></pre><pre><code class="language-none">BasisMatrices._checkx</code></pre><pre><code class="language-none">BasisMatrices._chk_evalbase</code></pre><pre><code class="language-none">BasisMatrices._funeval</code></pre><pre><code class="language-none">BasisMatrices._get_TP</code></pre><pre><code class="language-none">BasisMatrices._get_coefs_deep</code></pre><pre><code class="language-none">BasisMatrices._ncol</code></pre><pre><code class="language-none">BasisMatrices._nnz_per_row</code></pre><pre><code class="language-none">BasisMatrices._nrows</code></pre><pre><code class="language-none">BasisMatrices._param</code></pre><pre><code class="language-none">BasisMatrices._prep_evalbase</code></pre><pre><code class="language-none">BasisMatrices._row_kron_sparse_out_nnz</code></pre><pre><code class="language-none">BasisMatrices._spdiagm</code></pre><pre><code class="language-none">BasisMatrices._unscale</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.a_chain" href="#BasisMatrices.a_chain"><code>BasisMatrices.a_chain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Finds all of the unidimensional disjoint sets of Chebychev extrema that are used to construct the grid.  It improves on past algorithms by noting  that <span>$A_{n} = S_{n}$</span> [evens] except for <span>$A_1= \{0\}$</span>  and <span>$A_2 = \{-1, 1\}$</span>. Additionally, <span>$A_{n} = A_{n+1}$</span> [odds] This prevents the calculation of these nodes repeatedly. Thus we only need to calculate biggest of the S<em>n&#39;s to build the sequence of ``A</em>n`` &#39;s</p><p>See section 3.2 of the paper...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.basis_eltype" href="#BasisMatrices.basis_eltype"><code>BasisMatrices.basis_eltype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis_eltype(p::Union{BasisParams,Type{&lt;:BasisParams}, x)</code></pre><p>Return the eltype of the Basis matrix that would be obtained by calling <code>evalbase(p, x)</code></p></div></div></section><pre><code class="language-none">BasisMatrices.bmat_type</code></pre><pre><code class="language-none">BasisMatrices.build_B</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.build_B!" href="#BasisMatrices.build_B!"><code>BasisMatrices.build_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the matrix <code>B(pts)</code> from equation 22 in JMMV 2013. This is the basis matrix</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.build_grid" href="#BasisMatrices.build_grid"><code>BasisMatrices.build_grid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Use disjoint Smolyak sets to construct Smolyak grid of degree <code>d</code> and density parameter <code>mu</code></p></div></div></section><pre><code class="language-none">BasisMatrices.cartprod</code></pre><pre><code class="language-none">BasisMatrices.cdprodx</code></pre><pre><code class="language-none">BasisMatrices.cheby2n</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.cheby2n!" href="#BasisMatrices.cheby2n!"><code>BasisMatrices.cheby2n!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes first <code>n</code> Chebychev polynomials of the <code>kind</code> kind evaluated at each point in <code>x</code> and places them in <code>out</code>. The trailing dimension of <code>out</code> indexes the chebyshev polynomials. All inner dimensions correspond to points in <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.check_basis_structure" href="#BasisMatrices.check_basis_structure"><code>BasisMatrices.check_basis_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Do common transformations to all constructor of <code>BasisMatrix</code></p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of dimensions in the corresponding <code>Basis</code></li><li><code>x::AbstractArray</code>: The points for which the <code>BasisMatrix</code> should be</li></ul><p>constructed</p><ul><li><code>order::Array{Int}</code>: The order of evaluation for each dimension of the basis</li></ul><p><strong>Returns</strong></p><ul><li><code>m::Int</code>: the total number of derivative order basis functions to compute.</li></ul><p>This will be the number of rows in the matrix form of <code>order</code></p><ul><li><code>order::Matrix{Int}</code>: A <code>m × N</code> matrix that, for each of the <code>m</code> desired</li></ul><p>specifications, gives the derivative order along all <code>N</code> dimensions</p><ul><li><code>minorder::Matrix{Int}</code>: A <code>1 × N</code> matrix specifying the minimum desired</li></ul><p>derivative order along each dimension</p><ul><li><code>numbases::Matrix{Int}</code>: A <code>1 × N</code> matrix specifying the total number of</li></ul><p>distinct derivative orders along each dimension</p><ul><li><code>x::AbstractArray</code>: The properly transformed points at which to evaluate</li></ul><p>the basis</p></div></div></section><pre><code class="language-none">BasisMatrices.check_convert</code></pre><pre><code class="language-none">BasisMatrices.check_funfit</code></pre><pre><code class="language-none">BasisMatrices.chunk_len</code></pre><pre><code class="language-none">BasisMatrices.ckron</code></pre><pre><code class="language-none">BasisMatrices.ckronx</code></pre><pre><code class="language-none">BasisMatrices.ckronxi</code></pre><pre><code class="language-none">BasisMatrices.col_ix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.complete_polynomial" href="#BasisMatrices.complete_polynomial"><code>BasisMatrices.complete_polynomial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Construct basis matrix for complete polynomial of degree <code>d</code>, given input data <code>z</code>. <code>z</code> is assumed to be the degree 1 realization of each variable. For example, if variables are <code>q</code>, <code>r</code>, and <code>s</code>, then <code>z</code> should be <code>z = [q r s]</code></p><p>Output is a basis matrix. In our example, with <code>d</code> set to 2 we would have</p><pre><code class="language-julia">out = [ones(size(z,1)) q q.^2 q.*r q.*s r r.^2 r.*s s s.^2]</code></pre><p>TODO: Currently a bit more code repetition than is desireable. It would be       nice to cut down on the repetition between the <code>complete_polynomial</code>       functions TODO: Current algorithm for computing derivatives is kind of slow – Is       there any obvious ways to improve this?</p></div></div></section><pre><code class="language-none">BasisMatrices.complete_polynomial!</code></pre><pre><code class="language-none">BasisMatrices.complete_polynomial_impl!</code></pre><pre><code class="language-none">BasisMatrices.cube2dom</code></pre><pre><code class="language-none">BasisMatrices.cube2dom!</code></pre><pre><code class="language-none">BasisMatrices.derivative_op</code></pre><pre><code class="language-none">BasisMatrices.dom2cube</code></pre><pre><code class="language-none">BasisMatrices.dom2cube!</code></pre><pre><code class="language-none">BasisMatrices.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.evalbase" href="#BasisMatrices.evalbase"><code>BasisMatrices.evalbase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Evaluate spline basis matrices for a certain order derivative at x</p><p><strong>Arguments</strong></p><ul><li><code>p::SplineParams</code>: A <code>SplineParams</code> summarizing spline properties</li><li><code>x(nodes(p))</code> : the nodes at which to evaluate the basis matrices</li><li><code>order(0)</code> : The order(s) of derivative for which to evaluate the basis</li></ul><p>matrices. <code>order=0</code> corresponds to the function itself, negative numbers correspond to integrals.</p><p><strong>Returns</strong></p><ul><li><code>B::SparseMatrixCSC</code> : Matrix containing the evaluation of basis functions</li></ul><p>at each point in <code>x</code>. Each column represents a basis function.</p><ul><li><code>x</code>: Points at which the functions were evaluated</li></ul></div></div></section><pre><code class="language-none">BasisMatrices.evalbasex</code></pre><pre><code class="language-none">BasisMatrices.evalbasex!</code></pre><pre><code class="language-none">BasisMatrices.evaluate</code></pre><pre><code class="language-none">BasisMatrices.family</code></pre><pre><code class="language-none">BasisMatrices.family_name</code></pre><pre><code class="language-none">BasisMatrices.fit!</code></pre><pre><code class="language-none">BasisMatrices.funeval</code></pre><pre><code class="language-none">BasisMatrices.funfitf</code></pre><pre><code class="language-none">BasisMatrices.funfitxy</code></pre><pre><code class="language-none">BasisMatrices.get_coefs</code></pre><pre><code class="language-none">BasisMatrices.gridmake</code></pre><pre><code class="language-none">BasisMatrices.gridmake!</code></pre><pre><code class="language-none">BasisMatrices.include</code></pre><pre><code class="language-none">BasisMatrices.ind_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.lookup" href="#BasisMatrices.lookup"><code>BasisMatrices.lookup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lookup(table::AbstractVector, x, p::Int=0)</code></pre><p>For a sorted vector <code>table</code>, return the index of the <em>last</em> point smaller than <code>x</code>. <code>p</code> specifies endpoint adjustments and takes one of 4 values:</p><ol><li><code>p=0</code>: no adjustment made</li><li><code>p=1</code>: if <code>x &lt; minimum(table)</code>, then return <code>sum(table .== table[1])</code></li><li><code>p=2</code>: if <code>x &gt; maximum(table)</code>, then return <code>length(table)-sum(table .== table[end])</code></li><li><code>p=3</code>: do both adjustments 1 and 2</li></ol><p>If <code>p &gt; 3</code>, the <code>p=3</code> case is applied</p><p>When <code>x</code> is a vector, a vector of integers is returned</p></div></div></section><pre><code class="language-none">BasisMatrices.m_i</code></pre><pre><code class="language-none">BasisMatrices.n_chunks</code></pre><pre><code class="language-none">BasisMatrices.n_complete</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.nodes" href="#BasisMatrices.nodes"><code>BasisMatrices.nodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Construct interpolation nodes, given SplineParams</p><p>Note that <code>p.k - 1</code> additional nodes will be inserted</p><p><strong>Arguments</strong></p><ul><li><code>p::SplineParams</code>: <code>SplineParams</code> instance</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Vector</code>: The Vector of 1d interpolation nodes.</li></ul></div></div></section><pre><code class="language-none">BasisMatrices.nodeunif</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.phi_chain" href="#BasisMatrices.phi_chain"><code>BasisMatrices.phi_chain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For each number in 1 to <code>n</code>, compute the Smolyak indices for the corresponding basis functions. This is the <span>$n$</span> in <span>$\phi_n$</span>. The output is A dictionary whose keys are the Smolyak index <code>n</code> and values are ranges containing all basis polynomial subscripts for that Smolyak index</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.poly_inds" href="#BasisMatrices.poly_inds"><code>BasisMatrices.poly_inds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Build indices specifying all the Cartesian products of Chebychev polynomials needed to build Smolyak polynomial</p></div></div></section><pre><code class="language-none">BasisMatrices.row_kron</code></pre><pre><code class="language-none">BasisMatrices.row_kron!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.s_n" href="#BasisMatrices.s_n"><code>BasisMatrices.s_n</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Finds the set <code>S_n</code> , which is the <code>n</code>th Smolyak set of Chebychev extrema</p></div></div></section><pre><code class="language-none">BasisMatrices.shape_c_expr</code></pre><pre><code class="language-none">BasisMatrices.sizes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisMatrices.smol_inds" href="#BasisMatrices.smol_inds"><code>BasisMatrices.smol_inds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">smol_inds(d::Int, mu::Int)</code></pre><p>Finds all of the indices that satisfy the requirement that <span>$d \leq \sum_{i=1}^d \leq d + \mu$</span>.</p></div></div><div><div><pre><code class="language-none">smol_inds(d::Int, mu::AbstractVector{Int})</code></pre><p>Finds all of the indices that satisfy the requirement that <span>$d \leq \sum_{i=1}^d \leq d + \mu_i$</span>.</p><p>This is the anisotropic version of the method that allows mu to vary for each dimension</p></div></div></section><pre><code class="language-none">BasisMatrices.tensor_prod</code></pre><pre><code class="language-none">BasisMatrices.update_coefs!</code></pre><pre><code class="language-none">BasisMatrices.val_ix</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
