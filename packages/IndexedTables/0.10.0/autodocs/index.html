<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · IndexedTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IndexedTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">IndexedTables.@cols</code></pre><pre><code class="language-none">IndexedTables.AbstractIndexedTable</code></pre><pre><code class="language-none">IndexedTables.AbstractNDSparse</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.All" href="#IndexedTables.All"><code>IndexedTables.All</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">All(cols::Union{Symbol, Int}...)</code></pre><p>Select the union of the selections in <code>cols</code>. If <code>cols == ()</code>, select all columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], [0, 0, 0, 0], names=[:a,:b,:c,:d])
select(t, All(:a, (:b, :c)))
select(t, All())</code></pre></div></div></section><pre><code class="language-none">IndexedTables.ApplyColwise</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Between" href="#IndexedTables.Between"><code>IndexedTables.Between</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Between(first, last)</code></pre><p>Select the columns between <code>first</code> and <code>last</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], 1:4, &#39;a&#39;:&#39;d&#39;, names=[:a,:b,:c,:d])
select(t, Between(:b, :d))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ColDict" href="#IndexedTables.ColDict"><code>IndexedTables.ColDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">d = ColDict(t)</code></pre><p>Create a mutable dictionary of columns in <code>t</code>.</p><p>To get the immutable iterator of the same type as <code>t</code> call <code>d[]</code></p></div></div></section><pre><code class="language-none">IndexedTables.Columns</code></pre><pre><code class="language-none">IndexedTables.Dataset</code></pre><pre><code class="language-none">IndexedTables.DimName</code></pre><pre><code class="language-none">IndexedTables.GroupBy</code></pre><pre><code class="language-none">IndexedTables.GroupReduce</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.IndexedTable" href="#IndexedTables.IndexedTable"><code>IndexedTables.IndexedTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A tabular data structure that extends <a href="@ref"><code>Columns</code></a>.  Create an <code>IndexedTable</code> with the  <a href="#IndexedTables.table"><code>table</code></a> function.</p></div></div></section><pre><code class="language-none">IndexedTables.IndexedTables</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Keys" href="#IndexedTables.Keys"><code>IndexedTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Keys()</code></pre><p>Select the primary keys.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Keys())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.NDSparse" href="#IndexedTables.NDSparse"><code>IndexedTables.NDSparse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>NDSparse(columns...; names=Symbol[...], kwargs...)</code></p><p>Construct an NDSparse array from columns. The last argument is the data column, and the rest are index columns. The <code>names</code> keyword argument optionally specifies names for the index columns (dimensions).</p></div></div></section><pre><code class="language-none">IndexedTables.NextTable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Not" href="#IndexedTables.Not"><code>IndexedTables.Not</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Not(cols::Union{Symbol, Int}...)</code></pre><p>Select the complementary of the selection in <code>cols</code>. <code>Not</code> can accept several arguments, in which case it returns the complementary of the union of the selections.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Not(:a))
select(t, Not(:a, (:a, :b)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Perm" href="#IndexedTables.Perm"><code>IndexedTables.Perm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A permutation</p><p><strong>Fields:</strong></p><ul><li><code>columns</code>: The columns being indexed as a vector of integers (column numbers)</li><li><code>perm</code>: the permutation - an array or iterator which has the sorted permutation</li></ul></div></div></section><pre><code class="language-none">IndexedTables.SpecialSelector</code></pre><pre><code class="language-none">IndexedTables.Tup</code></pre><pre><code class="language-none">IndexedTables._append!</code></pre><pre><code class="language-none">IndexedTables._apply</code></pre><pre><code class="language-none">IndexedTables._apply_with_key</code></pre><pre><code class="language-none">IndexedTables._bcast_loop!</code></pre><pre><code class="language-none">IndexedTables._broadcast!</code></pre><pre><code class="language-none">IndexedTables._broadcast_trailing!</code></pre><pre><code class="language-none">IndexedTables._colindex</code></pre><pre><code class="language-none">IndexedTables._cols</code></pre><pre><code class="language-none">IndexedTables._cols_tuple</code></pre><pre><code class="language-none">IndexedTables._convert</code></pre><pre><code class="language-none">IndexedTables._dep_message_NextTable</code></pre><pre><code class="language-none">IndexedTables._dep_message_dropna</code></pre><pre><code class="language-none">IndexedTables._flatten!</code></pre><pre><code class="language-none">IndexedTables._fwd</code></pre><pre><code class="language-none">IndexedTables._getindex</code></pre><pre><code class="language-none">IndexedTables._getindex_scalar</code></pre><pre><code class="language-none">IndexedTables._impl</code></pre><pre><code class="language-none">IndexedTables._in</code></pre><pre><code class="language-none">IndexedTables._ismissing</code></pre><pre><code class="language-none">IndexedTables._join!</code></pre><pre><code class="language-none">IndexedTables._map</code></pre><pre><code class="language-none">IndexedTables._map_params</code></pre><pre><code class="language-none">IndexedTables._mapslices_itable!</code></pre><pre><code class="language-none">IndexedTables._mapslices_itable_singleton!</code></pre><pre><code class="language-none">IndexedTables._mapslices_scalar!</code></pre><pre><code class="language-none">IndexedTables._merge</code></pre><pre><code class="language-none">IndexedTables._merge!</code></pre><pre><code class="language-none">IndexedTables._promote_op</code></pre><pre><code class="language-none">IndexedTables._push!</code></pre><pre><code class="language-none">IndexedTables._reduce</code></pre><pre><code class="language-none">IndexedTables._reduce_select</code></pre><pre><code class="language-none">IndexedTables._reduce_select_init</code></pre><pre><code class="language-none">IndexedTables._row_in</code></pre><pre><code class="language-none">IndexedTables._setindex!</code></pre><pre><code class="language-none">IndexedTables._setindex_scalar!</code></pre><pre><code class="language-none">IndexedTables._sizehint!</code></pre><pre><code class="language-none">IndexedTables._strip_pair</code></pre><pre><code class="language-none">IndexedTables._tuple_type_head</code></pre><pre><code class="language-none">IndexedTables._tuple_type_tail</code></pre><pre><code class="language-none">IndexedTables.addname</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate!" href="#IndexedTables.aggregate!"><code>IndexedTables.aggregate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">aggregate!(f::Function, arr::NDSparse)</code></pre><p>Combine adjacent rows with equal indices using the given 2-argument reduction function, in place.</p></div></div></section><pre><code class="language-none">IndexedTables.antijoin</code></pre><pre><code class="language-none">IndexedTables.append_n!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.arrayof" href="#IndexedTables.arrayof"><code>IndexedTables.arrayof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arrayof(T)</code></pre><p>Returns the type of <code>Columns</code> or <code>Vector</code> suitable to store values of type T. Nested tuples beget nested Columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin" href="#IndexedTables.asofjoin"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">asofjoin(left::NDSparse, right::NDSparse)</code></pre><p>Join rows from <code>left</code> with the &quot;most recent&quot; value from <code>right</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using Dates
akey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
akey2 = [Date(2017,11,11), Date(2017,11,12), Date(2017,11,11), Date(2017,11,12)]
avals = collect(1:4)

bkey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
bkey2 = [Date(2017,11,12), Date(2017,11,13), Date(2017,11,10), Date(2017,11,13)]
bvals = collect(5:8)

a = ndsparse((akey1, akey2), avals)
b = ndsparse((bkey1, bkey2), bvals)

asofjoin(a, b)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.astuple</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.best_perm_estimate" href="#IndexedTables.best_perm_estimate"><code>IndexedTables.best_perm_estimate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns: (n, perm) where n is the number of columns in the beginning of <code>cols</code>, <code>perm</code> is one possible permutation of those first <code>n</code> columns.</p></div></div></section><pre><code class="language-none">IndexedTables.cacheperm!</code></pre><pre><code class="language-none">IndexedTables.canonname</code></pre><pre><code class="language-none">IndexedTables.cmpelts</code></pre><pre><code class="language-none">IndexedTables.colindex</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.collect_columns" href="#IndexedTables.collect_columns"><code>IndexedTables.collect_columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect_columns(itr)</code></pre><p>Collect an iterable as a <code>Columns</code> object if it iterates <code>Tuples</code> or <code>NamedTuples</code>, as a normal <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">s = [(1,2), (3,4)]
collect_columns(s)

s2 = Iterators.filter(isodd, 1:8)
collect_columns(s2)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.collect_columns_flattened</code></pre><pre><code class="language-none">IndexedTables.collect_columns_flattened!</code></pre><pre><code class="language-none">IndexedTables.collect_empty_columns</code></pre><pre><code class="language-none">IndexedTables.collect_to_columns!</code></pre><pre><code class="language-none">IndexedTables.collectiontype</code></pre><pre><code class="language-none">IndexedTables.colname</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.colnames" href="#IndexedTables.colnames"><code>IndexedTables.colnames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colnames(itr)</code></pre><p>Returns the names of the &quot;columns&quot; in <code>itr</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">colnames(1:3)
colnames(Columns([1,2,3], [3,4,5]))
colnames(table([1,2,3], [3,4,5]))
colnames(Columns(x=[1,2,3], y=[3,4,5]))
colnames(table([1,2,3], [3,4,5], names=[:x,:y]))
colnames(ndsparse(Columns(x=[1,2,3]), Columns(y=[3,4,5])))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns([1,2,3], [4,5,6]), Columns(x=[6,7,8])))
colnames(ndsparse(Columns(x=[1,2,3]), Columns([3,4,5],[6,7,8])))</code></pre></div></div></section><pre><code class="language-none">IndexedTables.column</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns" href="#IndexedTables.columns"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">columns(itr, select::Selection = All())</code></pre><p>Select one or more columns from an iterable of rows as a tuple of vectors.</p><p><code>select</code> specifies which columns to select. Refer to the <a href="#IndexedTables.select"><code>select</code></a> function for the  available selection options and syntax.</p><p><code>itr</code> can be <code>NDSparse</code>, <code>Columns</code>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:2, 3:4; names = [:x, :y])

columns(t)
columns(t, :x)
columns(t, (:x,))
columns(t, (:y, :x =&gt; -))</code></pre></div></div></section><pre><code class="language-none">IndexedTables.colwise_group_fast</code></pre><pre><code class="language-none">IndexedTables.compact_mem</code></pre><pre><code class="language-none">IndexedTables.concat_cols</code></pre><pre><code class="language-none">IndexedTables.concat_tup</code></pre><pre><code class="language-none">IndexedTables.concat_tup_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim" href="#IndexedTables.convertdim"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>convertdim(x::NDSparse, d::DimName, xlate; agg::Function, vecagg::Function, name)</code></p><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> or <code>vecagg</code> is used to aggregate the results. If <code>agg</code> is passed, it is used as a 2-argument reduction function over the data. If <code>vecagg</code> is passed, it is used as a vector-to-scalar function to aggregate the data. <code>name</code> optionally specifies a new name for the translated dimension.</p></div></div></section><pre><code class="language-none">IndexedTables.convertkey</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertmissing" href="#IndexedTables.convertmissing"><code>IndexedTables.convertmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convertmissing(tbl, missingtype)</code></pre><p>Convert the missing value representation in <code>tbl</code> to be of type <code>missingtype</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using IndexedTables, DataValues
t = table([1,2,missing], [1,missing,3])
IndexedTables.convertmissing(t, DataValue)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.copyelt!</code></pre><pre><code class="language-none">IndexedTables.copyrow!</code></pre><pre><code class="language-none">IndexedTables.count_overlap</code></pre><pre><code class="language-none">IndexedTables.dedup_names</code></pre><pre><code class="language-none">IndexedTables.default_initializer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dimlabels" href="#IndexedTables.dimlabels"><code>IndexedTables.dimlabels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dimlabels(t::NDSparse)</code></p><p>Returns an array of integers or symbols giving the labels for the dimensions of <code>t</code>. <code>ndims(t) == length(dimlabels(t))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dropmissing" href="#IndexedTables.dropmissing"><code>IndexedTables.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing(t        )
dropmissing(t, select)</code></pre><p>Drop rows of table <code>t</code> which contain missing values (either <code>Missing</code> or <code>DataValue</code>),  optionally only using the columns in <code>select</code>.  Column types will be converted to  non-missing types.  For example:</p><ul><li><code>Vector{Union{Int, Missing}}</code> -&gt; <code>Vector{Int}</code></li><li><code>DataValueArray{Int}</code> -&gt; Vector{Int}</li></ul><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.1,0.5,missing,0.7], [2,missing,4,5], [missing,6,missing,7], names=[:t,:x,:y])
dropmissing(t)
dropmissing(t, (:t, :x))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dropna" href="#IndexedTables.dropna"><code>IndexedTables.dropna</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing(t        )
dropmissing(t, select)</code></pre><p>Drop rows of table <code>t</code> which contain missing values (either <code>Missing</code> or <code>DataValue</code>),  optionally only using the columns in <code>select</code>.  Column types will be converted to  non-missing types.  For example:</p><ul><li><code>Vector{Union{Int, Missing}}</code> -&gt; <code>Vector{Int}</code></li><li><code>DataValueArray{Int}</code> -&gt; Vector{Int}</li></ul><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.1,0.5,missing,0.7], [2,missing,4,5], [missing,6,missing,7], names=[:t,:x,:y])
dropmissing(t)
dropmissing(t, (:t, :x))</code></pre></div></div></section><pre><code class="language-none">IndexedTables.eltypes</code></pre><pre><code class="language-none">IndexedTables.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.excludecols" href="#IndexedTables.excludecols"><code>IndexedTables.excludecols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">excludecols(itr, cols) -&gt; Tuple of Int</code></pre><p>Names of all columns in <code>itr</code> except <code>cols</code>. <code>itr</code> can be any of <code>Table</code>, <code>NDSparse</code>, <code>Columns</code>, or <code>AbstractVector</code></p><p><strong>Examples</strong></p><pre><code class="language-none">using IndexedTables: excludecols

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

excludecols(t, (:x,))
excludecols(t, (2,))
excludecols(t, pkeynames(t))
excludecols([1,2,3], (1,))</code></pre></div></div></section><pre><code class="language-none">IndexedTables.fastmap</code></pre><pre><code class="language-none">IndexedTables.fieldindex</code></pre><pre><code class="language-none">IndexedTables.fieldstupletype</code></pre><pre><code class="language-none">IndexedTables.fieldtypes</code></pre><pre><code class="language-none">IndexedTables.filt_by_col!</code></pre><pre><code class="language-none">IndexedTables.find_corresponding</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flatten" href="#IndexedTables.flatten"><code>IndexedTables.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flatten(t::Table, col=length(columns(t)))</code></pre><p>Flatten <code>col</code> column which may contain a vector of vectors while repeating the other fields. If column argument is not provided, default to last column.</p><p><strong>Examples:</strong></p><pre><code class="language-none">x = table([1,2], [[3,4], [5,6]], names=[:x, :y])
flatten(x, 2)

t1 = table([3,4],[5,6], names=[:a,:b])
t2 = table([7,8], [9,10], names=[:a,:b])
x = table([1,2], [t1, t2], names=[:x, :y]);
flatten(x, :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flush!" href="#IndexedTables.flush!"><code>IndexedTables.flush!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>flush!(arr::NDSparse)</code></p><p>Commit queued assignment operations, by sorting and merging the internal temporary buffer.</p></div></div></section><pre><code class="language-none">IndexedTables.foreach</code></pre><pre><code class="language-none">IndexedTables.getsubfields</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupby" href="#IndexedTables.groupby"><code>IndexedTables.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupby(f, t, by = pkeynames(t); select, flatten=false)</code></pre><p>Apply <code>f</code> to the <code>select</code>-ed columns (see <a href="#IndexedTables.select"><code>select</code></a>) in groups defined by the  unique values of <code>by</code>. </p><p>If <code>f</code> returns a vector, split it into multiple columns with <code>flatten = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t=table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6], names=[:x,:y,:z])

groupby(mean, t, :x, select=:z)
groupby(identity, t, (:x, :y), select=:z)
groupby(mean, t, (:x, :y), select=:z)

groupby((mean, std, var), t, :y, select=:z)
groupby((q25=z-&gt;quantile(z, 0.25), q50=median, q75=z-&gt;quantile(z, 0.75)), t, :y, select=:z)

# apply different aggregation functions to different columns
groupby((ymean = :y =&gt; mean, zmean = :z =&gt; mean), t, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupjoin" href="#IndexedTables.groupjoin"><code>IndexedTables.groupjoin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupjoin(left, right; kw...)
groupjoin(f, left, right; kw...)</code></pre><p>Join <code>left</code> and <code>right</code> creating groups of values with matching keys.</p><p>For keyword argument options, see <a href="@ref"><code>join</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">l = table([1,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:c], pkey=(:a, :b))
r = table([0,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:d], pkey=(:a, :b))

groupjoin(l, r)
groupjoin(l, r; how = :left)
groupjoin(l, r; how = :outer)
groupjoin(l, r; how = :anti)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupreduce" href="#IndexedTables.groupreduce"><code>IndexedTables.groupreduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupreduce(f, t, by = pkeynames(t); select)</code></pre><p>Calculate a <a href="@ref"><code>reduce</code></a> operation <code>f</code> over table <code>t</code> on groups defined by the values  in selection <code>by</code>.  The result is put in a table keyed by the unique <code>by</code> values.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,1,2,2,2], 1:6, names=[:x, :y])
groupreduce(+,        t, :x; select = :y)
groupreduce((sum=+,), t, :x; select = :y)  # change output column name to :sum

t2 = table([1,1,1,2,2,2], [1,1,2,2,3,3], 1:6, names = [:x, :y, :z])
groupreduce(+, t2, (:x, :y), select = :z)

# different reducers for different columns
groupreduce((sumy = :y =&gt; +, sumz = :z =&gt; +), t2, :x)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.grow_to_columns!</code></pre><pre><code class="language-none">IndexedTables.hascolumns</code></pre><pre><code class="language-none">IndexedTables.include</code></pre><pre><code class="language-none">IndexedTables.init_first</code></pre><pre><code class="language-none">IndexedTables.init_func</code></pre><pre><code class="language-none">IndexedTables.init_funcs</code></pre><pre><code class="language-none">IndexedTables.init_inputs</code></pre><pre><code class="language-none">IndexedTables.init_join_output</code></pre><pre><code class="language-none">IndexedTables.innerjoin</code></pre><pre><code class="language-none">IndexedTables.insertafter!</code></pre><pre><code class="language-none">IndexedTables.insertbefore!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcol" href="#IndexedTables.insertcol"><code>IndexedTables.insertcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">insertcol(t, position::Integer, name, x)</code></pre><p>Insert a column <code>x</code> named <code>name</code> at <code>position</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcol(t, 2, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolafter" href="#IndexedTables.insertcolafter"><code>IndexedTables.insertcolafter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">insertcolafter(t, after, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> after <code>after</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolafter(t, :t, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolbefore" href="#IndexedTables.insertcolbefore"><code>IndexedTables.insertcolbefore</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">insertcolbefore(t, before, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> before <code>before</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolbefore(t, :x, :w, [0,1])</code></pre></div></div></section><pre><code class="language-none">IndexedTables.is_approx_uniqs_less_than</code></pre><pre><code class="language-none">IndexedTables.isconstrange</code></pre><pre><code class="language-none">IndexedTables.ismissingtype</code></pre><pre><code class="language-none">IndexedTables.isshared</code></pre><pre><code class="language-none">IndexedTables.ith_all</code></pre><pre><code class="language-none">IndexedTables.joinequalblock</code></pre><pre><code class="language-none">IndexedTables.left</code></pre><pre><code class="language-none">IndexedTables.leftgroupjoin</code></pre><pre><code class="language-none">IndexedTables.leftjoin</code></pre><pre><code class="language-none">IndexedTables.lowerselection</code></pre><pre><code class="language-none">IndexedTables.map_params</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.map_rows" href="#IndexedTables.map_rows"><code>IndexedTables.map_rows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map_rows(f, c...)</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise. Collect output as <code>Columns</code> if <code>f</code> returns <code>Tuples</code> or <code>NamedTuples</code> with constant fields, as <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">map_rows(i -&gt; (exp = exp(i), log = log(i)), 1:5)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.mapped_type</code></pre><pre><code class="language-none">IndexedTables.match_indices</code></pre><pre><code class="language-none">IndexedTables.missing_indxs</code></pre><pre><code class="language-none">IndexedTables.missing_instance</code></pre><pre><code class="language-none">IndexedTables.missingtype2type</code></pre><pre><code class="language-none">IndexedTables.namedtuple</code></pre><pre><code class="language-none">IndexedTables.naturalgroupjoin</code></pre><pre><code class="language-none">IndexedTables.naturaljoin</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ncols" href="#IndexedTables.ncols"><code>IndexedTables.ncols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ncols(itr)</code></pre><p>Returns the number of columns in <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">ncols([1,2,3]) == 1
ncols(rows(([1,2,3],[4,5,6]))) == 2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ndsparse" href="#IndexedTables.ndsparse"><code>IndexedTables.ndsparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ndsparse(keys, values; kw...)</code></pre><p>Construct an NDSparse array with the given <code>keys</code> and <code>values</code> columns. On construction,  the keys and data are sorted in lexicographic order of the <code>keys</code>.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>agg = nothing</code> – Function to aggregate values with duplicate keys.</li><li><code>presorted = false</code> – Are the key columns already sorted?</li><li><code>copy = true</code> – Should the columns in <code>keys</code> and <code>values</code> be copied?</li><li><code>chunks = nothing</code> – Provide an integer to distribute data into <code>chunks</code> chunks.<ul><li>A good choice is <code>nworkers()</code> (after <code>using Distributed</code>)</li><li>See also: <a href="@ref"><code>distribute</code></a></li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">x = ndsparse([&quot;a&quot;,&quot;b&quot;], [3,4])
keys(x)
values(x)
x[&quot;a&quot;]

# Dimensions are named if constructed with a named tuple of columns 
x = ndsparse((index = 1:10,), rand(10))
x[1]

# Multiple dimensions by passing a (named) tuple of columns
x = ndsparse((x = 1:10, y = 1:2:20), rand(10))
x[1, 1]

# Value columns can also have names via named tuples
x = ndsparse(1:10, (x=rand(10), y=rand(10)))</code></pre></div></div></section><pre><code class="language-none">IndexedTables.nicename</code></pre><pre><code class="language-none">IndexedTables.nullrow</code></pre><pre><code class="language-none">IndexedTables.opt_vcat</code></pre><pre><code class="language-none">IndexedTables.outergroupjoin</code></pre><pre><code class="language-none">IndexedTables.outerjoin</code></pre><pre><code class="language-none">IndexedTables.outvec</code></pre><pre><code class="language-none">IndexedTables.permcache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeynames" href="#IndexedTables.pkeynames"><code>IndexedTables.pkeynames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pkeynames(t::Table)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2], [3,4]);
pkeynames(t)

t = table([1,2], [3,4], pkey=1);
pkeynames(t)

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2));
pkeynames(t)</code></pre></div></div><div><div><pre><code class="language-none">pkeynames(t::NDSparse)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">x = ndsparse([1,2],[3,4])
pkeynames(x)

x = ndsparse((x=1:10, y=1:2:20), rand(10))
pkeynames(x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeys" href="#IndexedTables.pkeys"><code>IndexedTables.pkeys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pkeys(itr::IndexedTable)</code></pre><p>Primary keys of the table. If Table doesn&#39;t have any designated primary key columns (constructed without <code>pkey</code> argument) then a default key of tuples <code>(1,):(n,)</code> is generated.</p><p><strong>Example</strong></p><pre><code class="language-none">a = table([&quot;a&quot;,&quot;b&quot;], [3,4]) # no pkey
pkeys(a)

a = table([&quot;a&quot;,&quot;b&quot;], [3,4], pkey=1)
pkeys(a)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.popcol" href="#IndexedTables.popcol"><code>IndexedTables.popcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">popcol(t, cols...)</code></pre><p>Remove the column(s) <code>cols</code> from the table. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
popcol(t, :x)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.primaryperm</code></pre><pre><code class="language-none">IndexedTables.product</code></pre><pre><code class="language-none">IndexedTables.promote_union</code></pre><pre><code class="language-none">IndexedTables.promoted_similar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pushcol" href="#IndexedTables.pushcol"><code>IndexedTables.pushcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pushcol(t, name, x)</code></pre><p>Push a column <code>x</code> to the end of the table. <code>name</code> is the name for the new column. Returns a new table.</p><pre><code class="language-none">pushcol(t, map::Pair...)</code></pre><p>Push many columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
pushcol(t, :z, [1//2, 3//4])
pushcol(t, :z =&gt; [1//2, 3//4])</code></pre></div></div></section><pre><code class="language-none">IndexedTables.pushrow!</code></pre><pre><code class="language-none">IndexedTables.range_estimate</code></pre><pre><code class="language-none">IndexedTables.reduced_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec" href="#IndexedTables.reducedim_vec"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>reducedim_vec(f::Function, arr::NDSparse, dims)</code></p><p>Like <code>reduce</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reindex" href="#IndexedTables.reindex"><code>IndexedTables.reindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reindex(t::IndexedTable, by)
reindex(t::IndexedTable, by, select)</code></pre><p>Reindex table <code>t</code> with new primary key <code>by</code>, optionally keeping a subset of columns via <code>select</code>.  For <a href="#IndexedTables.NDSparse"><code>NDSparse</code></a>, use <a href="#IndexedTables.selectkeys"><code>selectkeys</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

t2 = reindex(t, (:y, :z))

pkeynames(t2)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.rename!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.renamecol" href="#IndexedTables.renamecol"><code>IndexedTables.renamecol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">renamecol(t, col, newname)</code></pre><p>Set <code>newname</code> as the new name for column <code>col</code> in <code>t</code>. Returns a new table.</p><pre><code class="language-none">renamecol(t, map::Pair...)</code></pre><p>Rename multiple columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], names=[:t, :x])
renamecol(t, :t, :time)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.right</code></pre><pre><code class="language-none">IndexedTables.row_asof</code></pre><pre><code class="language-none">IndexedTables.row_in</code></pre><pre><code class="language-none">IndexedTables.rowcmp</code></pre><pre><code class="language-none">IndexedTables.roweq</code></pre><pre><code class="language-none">IndexedTables.rowless</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.rows" href="#IndexedTables.rows"><code>IndexedTables.rows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rows(itr, select = All())</code></pre><p>Select one or more fields from an iterable of rows as a vector of their values.  Refer to  the <a href="#IndexedTables.select"><code>select</code></a> function for selection options and syntax.</p><p><code>itr</code> can be <a href="#IndexedTables.NDSparse"><code>NDSparse</code></a>, <a href="@ref"><code>Columns</code></a>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2],[3,4], names=[:x,:y])
rows(t)
rows(t, :x)
rows(t, (:x,))
rows(t, (:y, :x =&gt; -))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.select" href="#IndexedTables.select"><code>IndexedTables.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">select(t::Table, which::Selection)</code></pre><p>Select all or a subset of columns, or a single column from the table.</p><p><code>Selection</code> is a type union of many types that can select from a table. It can be:</p><ol><li><code>Integer</code> – returns the column at this position.</li><li><code>Symbol</code> – returns the column with this name.</li><li><code>Pair{Selection =&gt; Function}</code> – selects and maps a function over the selection, returns the result.</li><li><code>AbstractArray</code> – returns the array itself. This must be the same length as the table.</li><li><code>Tuple</code> of <code>Selection</code> – returns a table containing a column for every selector in the tuple. The tuple may also contain the type <code>Pair{Symbol, Selection}</code>, which the selection a name. The most useful form of this when introducing a new column.</li><li><code>Regex</code> – returns the columns with names that match the regular expression.</li><li><code>Type</code> – returns columns with elements of the given type.</li></ol><p><strong>Examples:</strong></p><pre><code class="language-none">t = table(1:10, randn(10), rand(Bool, 10); names = [:x, :y, :z])

# select the :x vector
select(t, 1)
select(t, :x)

# map a function to the :y vector
select(t, 2 =&gt; abs)
select(t, :y =&gt; x -&gt; x &gt; 0 ? x : -x)

# select the table of :x and :z
select(t, (:x, :z))
select(t, r&quot;(x|z)&quot;)

# map a function to the table of :x and :y
select(t, (:x, :y) =&gt; row -&gt; row[1] + row[2])
select(t, (1, :y) =&gt; row -&gt; row.x + row.y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectkeys" href="#IndexedTables.selectkeys"><code>IndexedTables.selectkeys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selectkeys(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of keys.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectvalues" href="#IndexedTables.selectvalues"><code>IndexedTables.selectvalues</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selectvalues(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of values</p></div></div></section><pre><code class="language-none">IndexedTables.set!</code></pre><pre><code class="language-none">IndexedTables.set_show_compact!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.setcol" href="#IndexedTables.setcol"><code>IndexedTables.setcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setcol(t::Table, col::Union{Symbol, Int}, x::Selection)</code></pre><p>Sets a <code>x</code> as the column identified by <code>col</code>. Returns a new table.</p><pre><code class="language-none">setcol(t::Table, map::Pair{}...)</code></pre><p>Set many columns at a time.</p><p><strong>Examples:</strong></p><pre><code class="language-none">t = table([1,2], [3,4], names=[:x, :y])

# change second column to [5,6]
setcol(t, 2 =&gt; [5,6])
setcol(t, :y , :y =&gt; x -&gt; x + 2)

# add [5,6] as column :z 
setcol(t, :z =&gt; 5:6)
setcol(t, :z, :y =&gt; x -&gt; x + 2)

# replacing the primary key results in a re-sorted copy
t = table([0.01, 0.05], [1,2], [3,4], names=[:t, :x, :y], pkey=:t)
t2 = setcol(t, :t, [0.1,0.05])</code></pre></div></div></section><pre><code class="language-none">IndexedTables.show_compact_when_wide</code></pre><pre><code class="language-none">IndexedTables.showmeta</code></pre><pre><code class="language-none">IndexedTables.showtable</code></pre><pre><code class="language-none">IndexedTables.sort_int_range_sub_by!</code></pre><pre><code class="language-none">IndexedTables.sort_sub_by!</code></pre><pre><code class="language-none">IndexedTables.sortperm_fast</code></pre><pre><code class="language-none">IndexedTables.sortperm_int_range</code></pre><pre><code class="language-none">IndexedTables.sortpermby</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.stack" href="#IndexedTables.stack"><code>IndexedTables.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stack(t, by = pkeynames(t); select = Not(by), variable = :variable, value = :value)`</code></pre><p>Reshape a table from the wide to the long format. Columns in <code>by</code> are kept as indexing columns. Columns in <code>select</code> are stacked. In addition to the id columns, two additional columns labeled  <code>variable</code> and <code>value</code> are added, containing the column identifier and the stacked columns. See also <a href="#IndexedTables.unstack"><code>unstack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, names = [:x], pkey=:x)
t = pushcol(t, :xsquare, :x =&gt; x -&gt; x^2)
t = pushcol(t, :xcube  , :x =&gt; x -&gt; x^3)

stack(t)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.strip_unionall</code></pre><pre><code class="language-none">IndexedTables.strip_unionall_params</code></pre><pre><code class="language-none">IndexedTables.subscriptprint</code></pre><pre><code class="language-none">IndexedTables.subtable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.summarize" href="#IndexedTables.summarize"><code>IndexedTables.summarize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">summarize(f, t, by = pkeynames(t); select = Not(by), stack = false, variable = :variable)</code></pre><p>Apply summary functions column-wise to a table. Return a <code>NamedTuple</code> in the non-grouped case and a table in the grouped case. Use <code>stack=true</code> to stack results of the same summary function  for different columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t = table([1, 2, 3], [1, 1, 1], names = [:x, :y])

summarize((mean, std), t)
summarize((m = mean, s = std), t)
summarize(mean, t; stack=true)
summarize((mean, std), t; select = :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.table" href="#IndexedTables.table"><code>IndexedTables.table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">table(cols; kw...)</code></pre><p>Create a table from a (named) tuple of AbstractVectors.</p><pre><code class="language-none">table(cols::AbstractVector...; names::Vector{Symbol}, kw...)</code></pre><p>Create a table from the provided <code>cols</code>, optionally with <code>names</code>.</p><pre><code class="language-none">table(cols::Columns; kw...)</code></pre><p>Construct a table from a vector of tuples. See <a href="#IndexedTables.rows"><code>rows</code></a> and <a href="@ref"><code>Columns</code></a>.</p><pre><code class="language-none">table(t::Union{IndexedTable, NDSparse}; kw...)</code></pre><p>Copy a Table or NDSparse to create a new table. The same primary keys as the input are used.</p><pre><code class="language-none">table(x; kw...)</code></pre><p>Create an <code>IndexedTable</code> from any object <code>x</code> that follows the <code>Tables.jl</code> interface.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>pkey</code>: select columns to sort by and be the primary key.</li><li><code>presorted = false</code>: is the data pre-sorted by primary key columns? </li><li><code>copy = true</code>: creates a copy of the input vectors if <code>true</code>. Irrelevant if <code>chunks</code> is specified.</li><li><code>chunks::Integer</code>: distribute the table.  Options are:<ul><li><code>Int</code> – (number of chunks) a safe bet is <code>nworkers()</code> after <code>using Distributed</code>.</li><li><code>Vector{Int}</code> – Number of elements in each of the <code>length(chunks)</code> chunks.</li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">table(rand(10), rand(10), names = [:x, :y], pkey = :x)

table(rand(Bool, 20), rand(20), rand(20), pkey = [1,2])

table((x = 1:10, y = randn(10)))

table([(1,2), (3,4)])</code></pre></div></div></section><pre><code class="language-none">IndexedTables.type2missingtype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.unstack" href="#IndexedTables.unstack"><code>IndexedTables.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unstack(t, by = pkeynames(t); variable = :variable, value = :value)</code></pre><p>Reshape a table from the long to the wide format. Columns in <code>by</code> are kept as indexing columns. Keyword arguments <code>variable</code> and <code>value</code> denote which column contains the column identifier and which the corresponding values.  See also <a href="#IndexedTables.stack"><code>stack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, [1, 4, 9, 16], [1, 8, 27, 64], names = [:x, :xsquare, :xcube], pkey = :x);

long = stack(t)

unstack(long)</code></pre></div></div></section><pre><code class="language-none">IndexedTables.unwrap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.update!" href="#IndexedTables.update!"><code>IndexedTables.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>update!(f::Function, arr::NDSparse, indices...)</code></p><p>Replace data values <code>x</code> with <code>f(x)</code> at each location that matches the given indices.</p></div></div></section><pre><code class="language-none">IndexedTables.valuenames</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.where" href="#IndexedTables.where"><code>IndexedTables.where</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>where(arr::NDSparse, indices...)</code></p><p>Returns an iterator over data items where the given indices match. Accepts the same index arguments as <code>getindex</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
