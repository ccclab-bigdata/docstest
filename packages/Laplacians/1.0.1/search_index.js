var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#Laplacians.jl-1",
    "page": "Readme",
    "title": "Laplacians.jl",
    "category": "section",
    "text": "(Image: Build Status) (Image: codecov) (Image: )(Image: Laplacians) (Image: Laplacians)Laplacians is a package containing graph algorithms, with an emphasis on tasks related to spectral and algebraic graph theory. It contains (and will contain more) code for solving systems of linear equations in graph Laplacians, low stretch spanning trees, sparsifiation, clustering, local clustering, and optimization on graphs.All graphs are represented by sparse adjacency matrices. This is both for speed, and because our main concerns are algebraic tasks. It does not handle dynamic graphs. It would be very slow to implement dynamic graphs this way.The documentation may be found by clicking on one of the \"docs\" links above."
},

{
    "location": "#Current-Development-Version-1",
    "page": "Readme",
    "title": "Current Development Version",
    "category": "section",
    "text": "To get the current version of the master branch, run pkg> add Laplacians#masterChanges:Added latin_square_graph and latin_square.\nAllow plot_graph to plot in 3D. \nFixed performance bug due to lazy matrix transpose."
},

{
    "location": "#Version-1.0.0-1",
    "page": "Readme",
    "title": "Version 1.0.0",
    "category": "section",
    "text": "This version works with Julia version 1.0.0."
},

{
    "location": "#Verson-0.3.1-1",
    "page": "Readme",
    "title": "Verson 0.3.1",
    "category": "section",
    "text": "Changes:The major change in this version is to the chimera and wted_chimera graph generators.  They are now faster, and incorporate two-lifts and thickening.  The old versions, using the pseudorandom generator from Julia V0.6 and Versions 0.2 of Laplacians, may be accessed by using the flag ver=Laplacians.V06, as in\na = chimera(2000, 1, ver=Laplacians.V06)\nThere do seem to be differences in the very low order bits of graphs generated by wted_chimera with the V06 option and those generated in Julia V0.6.  Not sure why. \nThe old generator is obtained by using the RandomV06 package for Julia.\nChanged the names of many functions to bring closer to the Julia standard naming scheme.  New names are emptygraph, pathgraph, ringgraph, completegraph, generalizedring, randgenring, productgraph, joingraphs, twolift ...  Set deprecation warnings for the old names.\nMoved lex.jl to the directory buggy, as on further testing we found bugs in it.\ndropped wGrid3, as it produced a 4d grid so probably wasn\'t being used anyway.  Dropped wGrid2 also."
},

{
    "location": "#Version-0.3.0,-July-18-(or-so),-2017-1",
    "page": "Readme",
    "title": "Version 0.3.0, July 18 (or so), 2017",
    "category": "section",
    "text": "This is the first version that is compatible with Julia 0.7.  Other changes:Dropped support for samplingSDDM and samplingLap solvers.\nThe behavior of rand in Julia 0.7 is different, and this has changed the behavior of chimera.  So, the chimera graphs generated in Version 0.3.0 and beyond will be different from those before."
},

{
    "location": "#Version-0.2.2,-December-28,-2017-1",
    "page": "Readme",
    "title": "Version 0.2.2, December 28, 2017",
    "category": "section",
    "text": "Fixed two bugs: one in shortestPaths, and one that prevented passing some parameters to approxCholSddm.  Improved the documentation for solving linear equations."
},

{
    "location": "#Version-0.2.1,-September-18,-2017-1",
    "page": "Readme",
    "title": "Version 0.2.1, September 18, 2017",
    "category": "section",
    "text": "Fixed a bug in approxCholSddm that caused it to be slow."
},

{
    "location": "#Version-0.2.0,-July-17,-2017-1",
    "page": "Readme",
    "title": "Version 0.2.0, July 17, 2017",
    "category": "section",
    "text": "This version is compatible with Julia 0.6.  It will not work with Julia 0.5.X.Changes:Added approxCholSddm, a wrapper of approxCholLap that solves SDDM systems."
},

{
    "location": "#Version-0.1.4,-June-6,-2017-1",
    "page": "Readme",
    "title": "Version 0.1.4, June 6, 2017",
    "category": "section",
    "text": "This is the current version.  It is what you retrieve when you run Pkg.add(\"Laplacians\"). Changes:Added sparsify, an implementation of sparsification by effective resistance sampling, following Spielman and Srivastava.\nAdded approxQual and conditionNumber for checking how well one graph approximates another.\nFixed a bug in the solution of Laplacian systems in disconnected graphs."
},

{
    "location": "#Version-0.1.3,-June-2,-2017-1",
    "page": "Readme",
    "title": "Version 0.1.3, June 2, 2017",
    "category": "section",
    "text": "Major Changes:Changed the name of the approximate Cholesky solver from edgeElimLap to approxCholLap.  Made improvements in this solver.\nImproved PCG so that it can now detect stagnation.  Made options to do this even better when using it with a good preconditioner, like approxCholLap.\nAdded in code for comparing the running times of solvers.  The difficulty here is that we need to stop them if they run too long.  Added code to do this with threads inside Julia, and with gtimeout when calling Matlab to use icc, CMG, or LAMG."
},

{
    "location": "#Version-0.1.2,-April-2,-2017-1",
    "page": "Readme",
    "title": "Version 0.1.2, April 2, 2017",
    "category": "section",
    "text": "Major Changes:added edgeElimLap - a fast Laplacian solver.\nfixed a bug in the unweighted version of akpw. "
},

{
    "location": "#Version-0.1.1,-December-26,-2016-1",
    "page": "Readme",
    "title": "Version 0.1.1, December 26, 2016",
    "category": "section",
    "text": "Changelist:All of the linear equation solvers now have the same interface, and the Laplacian solvers work for disconnected graphs. \nSome support for calling solvers from Matlab has been added.\nDocumentation is now through Documenter.jl."
},

{
    "location": "#Version-0.0.3-/-0.1.0,-November-20,-2016-1",
    "page": "Readme",
    "title": "Version 0.0.3 / 0.1.0, November 20, 2016",
    "category": "section",
    "text": "Versions 0.0.3 and 0.1.0 are the same. These versions works with Julia 0.5.Warning: the behavior of chimera and wtedChimera differs between Julia 0.4 and Julia 0.5 because randperm acts differently in these."
},

{
    "location": "#Version-0.0.2,-November-19,-2016-1",
    "page": "Readme",
    "title": "Version 0.0.2, November 19, 2016",
    "category": "section",
    "text": "This is the version that works with Julia 0.4. It was captured right before the upgrade to Julia 0.5"
},

{
    "location": "#Acknowledgements-1",
    "page": "Readme",
    "title": "Acknowledgements",
    "category": "section",
    "text": "The development of this package has been supported in part by the National Science Foundation Award CCF-1562041  and by the Office of Naval Research Award N00014-16-1-2374."
},

{
    "location": "autodocs/#Laplacians.ApproxCholPQ",
    "page": "Docstrings",
    "title": "Laplacians.ApproxCholPQ",
    "category": "type",
    "text": "An approximate priority queue.   Items are bundled together into doubly-linked lists with all approximately the same key.   minlist is the min list we know to be non-empty.   It should always be a lower bound.   keyMap maps keys to lists\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ApproxCholParams",
    "page": "Docstrings",
    "title": "Laplacians.ApproxCholParams",
    "category": "type",
    "text": "params = ApproxCholParams(order, output)\n\norder can be one of\n\n:deg (by degree, adaptive),\n:wdeg (by original wted degree, nonadaptive),\n:given\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ErdosRenyi",
    "page": "Docstrings",
    "title": "Laplacians.ErdosRenyi",
    "category": "function",
    "text": "graph = ErdosRenyi(n::Integer, m::Integer; ver=Vcur)\n\nGenerate a random graph on n vertices with m edges. The actual number of edges will probably be smaller, as we sample with replacement\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ErdosRenyiCluster",
    "page": "Docstrings",
    "title": "Laplacians.ErdosRenyiCluster",
    "category": "function",
    "text": "graph = ErdosRenyiCluster(n::Integer, k::Integer; ver=Vcur)\n\nGenerate an ER graph with average degree k, and then return the largest component. Will probably have fewer than n vertices. If you want to add a tree to bring it back to n, try ErdosRenyiClusterFix.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ErdosRenyiClusterFix",
    "page": "Docstrings",
    "title": "Laplacians.ErdosRenyiClusterFix",
    "category": "function",
    "text": "graph = ErdosRenyiClusterFix(n::Integer, k::Integer; ver=Vcur)\n\nLike an Erdos-Renyi cluster, but add back a tree so it has n vertices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.FastSampler",
    "page": "Docstrings",
    "title": "Laplacians.FastSampler",
    "category": "type",
    "text": "s = FastSampler(p)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.IJV",
    "page": "Docstrings",
    "title": "Laplacians.IJV",
    "category": "type",
    "text": "ijv = IJV(A::SparseMatrixCSC)\n\nConvert a sparse matrix to an IJV.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.KMPLapSolver",
    "page": "Docstrings",
    "title": "Laplacians.KMPLapSolver",
    "category": "function",
    "text": "lapSolver = KMPLapSolver(A; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)\n\nSolves linear equations in the Laplacian of graph with adjacency matrix A.\n\nBased on the paper \"Approaching optimality for solving SDD systems\" by Koutis, Miller, and Peng, <i>SIAM Journal on Computing</i>, 2014.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.KMPParams",
    "page": "Docstrings",
    "title": "Laplacians.KMPParams",
    "category": "type",
    "text": "Parameters for the KMP solver\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.KMPSDDMSolver",
    "page": "Docstrings",
    "title": "Laplacians.KMPSDDMSolver",
    "category": "function",
    "text": "sddmSolver = KMPSDDMSolver(mat; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)\n\nSolves linear equations in symmetric, diagonally dominant matrices with non-positive off-diagonals.  Based on the paper \"Approaching optimality for solving SDD systems\" by Koutis, Miller, and Peng, <i>SIAM Journal on Computing</i>, 2014.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.LDLinv",
    "page": "Docstrings",
    "title": "Laplacians.LDLinv",
    "category": "type",
    "text": "LDLinv contains the information needed to solve the Laplacian systems.   It does it by applying Linv, then Dinv, then Linv (transpose).   But, it is specially constructed for this particular solver.   It does not explicitly make the matrix triangular.   Rather, col[i] is the name of the ith col to be eliminated\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.LLmatp",
    "page": "Docstrings",
    "title": "Laplacians.LLmatp",
    "category": "type",
    "text": "LLmatp is the data structure used to maintain the matrix during elimination.   It stores the elements in each column in a singly linked list (only next ptrs)   Each element is an LLp (linked list pointer).   The head of each column is pointed to by cols.\n\nWe probably can get rid of degs - as it is only used to store initial degrees.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.LLp",
    "page": "Docstrings",
    "title": "Laplacians.LLp",
    "category": "type",
    "text": "LLp elements are all in the same column.   row tells us the row, and val is the entry.   val is set to zero for some edges that we should remove.   next gives the next in the column.  It points to itself to terminate.   reverse is the index into lles of the other copy of this edge,   since every edge is stored twice as we do not know the order of elimination in advance.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.LapSolvers",
    "page": "Docstrings",
    "title": "Laplacians.LapSolvers",
    "category": "constant",
    "text": "A list containing Laplacian linear system solvers. They take in an adjacency matrix plus tol, maxits and maxtime parameters.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.Laplacians",
    "page": "Docstrings",
    "title": "Laplacians.Laplacians",
    "category": "module",
    "text": "A package for graph computations related to graph Laplacians\n\nGraphs are represented by sparse adjacency matrices, etc.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.SDDMSolvers",
    "page": "Docstrings",
    "title": "Laplacians.SDDMSolvers",
    "category": "constant",
    "text": "A list containing SDDM linear system solvers. They take in a SDDM matrix plus tol, maxits and maxtime parameters.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.SolverTest",
    "page": "Docstrings",
    "title": "Laplacians.SolverTest",
    "category": "type",
    "text": "SolverTest(solver, name)\n\nEncloses a solver with its name, so that we can compare it in tests\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.addToGPrime",
    "page": "Docstrings",
    "title": "Laplacians.addToGPrime",
    "category": "function",
    "text": "Add a new vertex to GPrime \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.adj",
    "page": "Docstrings",
    "title": "Laplacians.adj",
    "category": "function",
    "text": "a,d = adj(sddm)\n\nCreate an adjacency matrix and a diagonal vector from an SDD M-matrix. That is, from a Laplacian with added diagonal weights\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.akpw",
    "page": "Docstrings",
    "title": "Laplacians.akpw",
    "category": "function",
    "text": "tree = akpw(graph; ver=0)\n\nComputes a low stretch spanning tree of graph, and returns it as a graph. The default version is 0.  In event of emergency, one can try ver=2.  It is usually slower, but might have slightly better stretch.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.akpwU",
    "page": "Docstrings",
    "title": "Laplacians.akpwU",
    "category": "function",
    "text": "tree = akpwU(graph)\n\nComputes a low stretch spanning tree of an unweighted graph, and returns it as a graph.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxCholPQDec!",
    "page": "Docstrings",
    "title": "Laplacians.approxCholPQDec!",
    "category": "function",
    "text": "Decrement the key of element i\nThis could crash if i exceeds the maxkey\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxCholPQInc!",
    "page": "Docstrings",
    "title": "Laplacians.approxCholPQInc!",
    "category": "function",
    "text": "Increment the key of element i\nThis could crash if i exceeds the maxkey\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxQual",
    "page": "Docstrings",
    "title": "Laplacians.approxQual",
    "category": "function",
    "text": "eps = approxQual(graph1, graph2; tol=1e-5, verbose=false)\n\nComputes the eps for which graph1 and graph2 are eps approximations of each other. That is, L1 <= (1+eps) L2, and vice versa.\n\nIt is randomized, so you might want to run it again if you don\'t trust the answers.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxchol_lap",
    "page": "Docstrings",
    "title": "Laplacians.approxchol_lap",
    "category": "function",
    "text": "solver = approxchol_lap(a); x = solver(b);\nsolver = approxchol_lap(a; tol::Real=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())\n\nA heuristic by Daniel Spielman inspired by the linear system solver in https://arxiv.org/abs/1605.02353 by Rasmus Kyng and Sushant Sachdeva.  Whereas that paper eliminates vertices one at a time, this eliminates edges one at a time.  It is probably possible to analyze it. The ApproxCholParams let you choose one of three orderings to perform the elimination.\n\nApproxCholParams(:given) - in the order given.   This is the fastest for construction the preconditioner, but the slowest solve.\nApproxCholParams(:deg) - always eliminate the node of lowest degree.   This is the slowest build, but the fastest solve.\nApproxCholParams(:wdeg) - go by a perturbed order of wted degree.  \n\nFor more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxchol_lapChol",
    "page": "Docstrings",
    "title": "Laplacians.approxchol_lapChol",
    "category": "function",
    "text": "This variation of approxChol creates a cholesky factor to do the elimination. It has not yet been optimized, and does not yet make the cholesky factor lower triangular\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.approxchol_sddm",
    "page": "Docstrings",
    "title": "Laplacians.approxchol_sddm",
    "category": "function",
    "text": "solver = approxchol_sddm(sddm); x = solver(b);\nsolver = approxchol_sddm(sddm; tol=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())\n\nSolves sddm systems by wrapping approxchol_lap. Not yet optimized directly for sddm.\n\nFor more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.apr",
    "page": "Docstrings",
    "title": "Laplacians.apr",
    "category": "function",
    "text": "Computes an approximate page rank vector from a starting set s, an alpha and an epsilon The algorithm follows the Anderson,Chung,Lang paper and Dan Spielman\'s lecture notes\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ask_cholmod",
    "page": "Docstrings",
    "title": "Laplacians.ask_cholmod",
    "category": "function",
    "text": "nnzL, flops = ask_cholmod(mat)\n\nEstimate the number of nonzeros in the cholfact factorization of mat,  along with the number of flops needed to compute it. Does this through a call to the analyze routine of cholmod. Note that this is much faster than actually computing the factorization\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augTreeLap",
    "page": "Docstrings",
    "title": "Laplacians.augTreeLap",
    "category": "function",
    "text": "solver = augTreeLap(A; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params=AugTreeParams())\n\nAn \"augmented spanning tree\" solver for Laplacians.  It works by adding edges to a low stretch spanning tree.  It calls augTreePrecon to form the preconditioner.  params has entries\n\nparams.treeAlg default to akpw\nparams.opt if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augTreeLapPrecon",
    "page": "Docstrings",
    "title": "Laplacians.augTreeLapPrecon",
    "category": "function",
    "text": "pre = augTreeLapPrecon{Tv,Ti}(A; params=AugTreeParams())\n\nThis is an augmented spanning tree preconditioner for Laplacians. It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via augmentTree: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call augTreeLapSolver.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augTreePrecon",
    "page": "Docstrings",
    "title": "Laplacians.augTreePrecon",
    "category": "function",
    "text": "pre = augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti}; params=AugTreeParams())\n\nThis is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via augmentTree: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call augTreeSolver.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augTreeSddm",
    "page": "Docstrings",
    "title": "Laplacians.augTreeSddm",
    "category": "function",
    "text": "solver = augTreeSddm(sddm; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[],  params=AugTreeParams())\n\nAn \"augmented spanning tree\" solver for positive definite diagonally dominant matrices.  It works by adding edges to a low stretch spanning tree.  It calls augTreePrecon to form the preconditioner.  params has entries\n\nparams.treeAlg default to akpw\nparams.opt if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augmentTree",
    "page": "Docstrings",
    "title": "Laplacians.augmentTree",
    "category": "function",
    "text": "B = augmentTree{Tv,Ti}(tree, A, k)\n\nTakes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch.\n\nThis is the old alg.  We now recommend using augmentTreeOpt.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.augmentTreeOpt",
    "page": "Docstrings",
    "title": "Laplacians.augmentTreeOpt",
    "category": "function",
    "text": "B = augmentTreeOpt{Tv,Ti}(tree, A, params)\n\nTakes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It uses cholmod to decide how many edge to add back, shooting for nnzLfac times n entries in the factored augmented tree, with a number of flops to factor equal to nnz(a)*flopsfac. The edges to add back are then choen at random.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.backIndices",
    "page": "Docstrings",
    "title": "Laplacians.backIndices",
    "category": "function",
    "text": "Computes the back indices in a graph in O(M+N). works if for every edge (u,v), (v,u) is also in the graph \n\n\n\n\n\nSame as the above, but now the graph is in adjacency list form \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.biggestComp",
    "page": "Docstrings",
    "title": "Laplacians.biggestComp",
    "category": "function",
    "text": "Return the biggest component in a graph, as a graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.blockSample",
    "page": "Docstrings",
    "title": "Laplacians.blockSample",
    "category": "function",
    "text": "s = blockSample(p; k = length(p))\n\nCompute numbers sampled with probability proportional to the vector p. They are returned in order. If need be, they can be permuted with randperm.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.blockSolver",
    "page": "Docstrings",
    "title": "Laplacians.blockSolver",
    "category": "function",
    "text": "Apply the ith solver on the ith component\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.cg",
    "page": "Docstrings",
    "title": "Laplacians.cg",
    "category": "function",
    "text": "x = cg(mat, b; tol, maxits, maxtime, verbose, pcgIts)\n\nsolves a symmetric linear system mat x = b.\n\nArguments\n\ntol is set to 1e-6 by default,\nmaxits defaults to Inf\nmaxtime defaults to Inf.  It measures seconds.\nverbose defaults to false\npcgIts is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.cgLapSolver",
    "page": "Docstrings",
    "title": "Laplacians.cgLapSolver",
    "category": "function",
    "text": "x = cgLapSolver(A::AbstractMatrix; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])\n\nCreate a solver that uses cg to solve Laplacian systems in the laplacian of A. This just exists to satisfy our interface. It does nothing more than create the Laplacian and call cg on each connected component.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.cgSolver",
    "page": "Docstrings",
    "title": "Laplacians.cgSolver",
    "category": "function",
    "text": "x = cgSolver(mat; tol, maxits, maxtime, verbose, pcgIts)\n\ncreates a solver for a PSD system mat. The parameters are as described in cg.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.chimera",
    "page": "Docstrings",
    "title": "Laplacians.chimera",
    "category": "function",
    "text": "graph = chimera(n::Integer; verbose=false, ver=Vcur)\n\nBuilds a chimeric graph on n vertices. The components come from pureRandomGraph, connected by joinGraphs, productGraph and generalizedNecklace\n\n\n\n\n\ngraph = chimera(n::Integer, k::Integer; verbose=false, ver=Vcur)\n\nBuilds the kth chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.chol_lap",
    "page": "Docstrings",
    "title": "Laplacians.chol_lap",
    "category": "function",
    "text": "solver = chol_lap(A::AbstractArray)\n\nUses Cholesky Factorization to solve systems in Laplacians.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.chol_sddm",
    "page": "Docstrings",
    "title": "Laplacians.chol_sddm",
    "category": "function",
    "text": "solveSDDM = chol_sddm(sddm::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[])\n\nThis functions wraps cholfact so that it satsfies our interface. It ignores all the keyword arguments.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.cholmod_perm",
    "page": "Docstrings",
    "title": "Laplacians.cholmod_perm",
    "category": "function",
    "text": "p = cholmod_perm(mat)\n\nReturn the permutation that cholmod would apply.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.compConductance",
    "page": "Docstrings",
    "title": "Laplacians.compConductance",
    "category": "function",
    "text": "Returns the quality of the cut for a given graph and a given cut set s.   the result will be |outgoing edges| / min(|vertices in set|, |N - vertices in set|)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.comp_stretches",
    "page": "Docstrings",
    "title": "Laplacians.comp_stretches",
    "category": "function",
    "text": "Compute the stretched of every edge in mat with respect to the tree tree. Returns the answer as a sparse matrix with the same nonzero structure as mat. Assumes that mat is symmetric. tree should be the adjacency matrix of a spanning tree.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.complete_binary_tree",
    "page": "Docstrings",
    "title": "Laplacians.complete_binary_tree",
    "category": "function",
    "text": "graph = completeBinaryTree(n::Int64)\n\nThe complete binary tree on n vertices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.complete_graph",
    "page": "Docstrings",
    "title": "Laplacians.complete_graph",
    "category": "function",
    "text": "graph = complete_graph(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.complete_graph_ijv",
    "page": "Docstrings",
    "title": "Laplacians.complete_graph_ijv",
    "category": "function",
    "text": "ijv = complete_graph_ijv(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.components",
    "page": "Docstrings",
    "title": "Laplacians.components",
    "category": "function",
    "text": "Computes the connected components of a graph. Returns them as a vector of length equal to the number of vertices. The vector numbers the components from 1 through the maximum number. For example,\n\ngr = ErdosRenyi(10,11)\nc = components(gr)\n\n10-element Array{Int64,1}:\n 1\n 1\n 1\n 1\n 2\n 1\n 1\n 1\n 3\n 2\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.condNumber",
    "page": "Docstrings",
    "title": "Laplacians.condNumber",
    "category": "function",
    "text": "cn = condNumber(a, ldli; verbose=false)\n\nGiven an adjacency matrix a and an ldli computed by approxChol, this computes the condition number.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.conditionNumber",
    "page": "Docstrings",
    "title": "Laplacians.conditionNumber",
    "category": "function",
    "text": "kapps = conditionNumber(graph1, graph2; tol=1e-5, verbose=false)\n\nComputes the relative condition number of graph1 and graph2.\n\nIt is randomized, so you might want to run it again if you don\'t trust the answers.\n\n\n\n\n\nkappa = conditionNumber(graph, precon; tol=1e-5, verbose=false)\n\nComputes the relative condition number of graph and a preconditioning function.\n\nIt is randomized, so you might want to run it again if you don\'t trust the answers.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.diagmat",
    "page": "Docstrings",
    "title": "Laplacians.diagmat",
    "category": "function",
    "text": "d = diagmat(a)\n\nReturns the diagonal weighted degree matrix(as a sparse matrix) of a graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.dirEdgeVertexMat",
    "page": "Docstrings",
    "title": "Laplacians.dirEdgeVertexMat",
    "category": "function",
    "text": "The signed edge-vertex adjacency matrix\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.disjoin",
    "page": "Docstrings",
    "title": "Laplacians.disjoin",
    "category": "function",
    "text": "graph = disjoin(a,b)\n\nCreate a disjoint union of graphs a and b,   with no edges between them.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.dumbRefineCut",
    "page": "Docstrings",
    "title": "Laplacians.dumbRefineCut",
    "category": "function",
    "text": "Modify a cluster by passing through all the vertices exactly once and \nadding/removing them based on the value of (Deg_external - Deg_Internal).\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.edgeVertexMat",
    "page": "Docstrings",
    "title": "Laplacians.edgeVertexMat",
    "category": "function",
    "text": "U = edgeVertexMat(a)\n\nThe signed edge-vertex adjacency matrix\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.empty_graph",
    "page": "Docstrings",
    "title": "Laplacians.empty_graph",
    "category": "function",
    "text": "ijv = empty_graph(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.empty_graph_ijv",
    "page": "Docstrings",
    "title": "Laplacians.empty_graph_ijv",
    "category": "function",
    "text": "ijv = empty_graph_ijv(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.extendMatrix",
    "page": "Docstrings",
    "title": "Laplacians.extendMatrix",
    "category": "function",
    "text": "Add a new vertex to a with weights to the other vertices corresponding to diagonal surplus weight.\n\nThis is an efficient way of writing [a d; d\' 0]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.findEntries",
    "page": "Docstrings",
    "title": "Laplacians.findEntries",
    "category": "function",
    "text": "Similar to findnz, but also returns 0 entries that have an edge in the sparse matrix \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.firstn",
    "page": "Docstrings",
    "title": "Laplacians.firstn",
    "category": "function",
    "text": "b = firstn(a::IJV, n::Integer)\n\nOnly keep the first n vertices of a.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.flipIndex",
    "page": "Docstrings",
    "title": "Laplacians.flipIndex",
    "category": "function",
    "text": "For a symmetric matrix, this gives the correspondance between pairs of entries in an ijv. So, ai[ind] = aj[flip[ind]].  For example, \n\n(ai,aj,av) = findnz(a);\nfl = flipIndex(a)\nind = 10\n@show backind = fl[10]\n@show [ai[ind], aj[ind], av[ind]]\n@show [ai[backind], aj[backind], av[backind]];\n\nbackind = fl[10] = 4\n[ai[ind],aj[ind],av[ind]] = [2.0,4.0,0.7]\n[ai[backind],aj[backind],av[backind]] = [4.0,2.0,0.7]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.floatGraph",
    "page": "Docstrings",
    "title": "Laplacians.floatGraph",
    "category": "function",
    "text": "graph = floatGraph(a::SparseMatrixCSC)\n\nConvert the nonzero entries in a graph to Float64.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.forceLap",
    "page": "Docstrings",
    "title": "Laplacians.forceLap",
    "category": "function",
    "text": "la = forceLap(a)\n\nCreate a Laplacian matrix from an adjacency matrix. If the input looks like a Laplacian, throw a warning and convert it.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.generalizedNecklace",
    "page": "Docstrings",
    "title": "Laplacians.generalizedNecklace",
    "category": "function",
    "text": "graph = generalizedNecklace(A, H, k::Int64)\n\nConstructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.generalized_ring",
    "page": "Docstrings",
    "title": "Laplacians.generalized_ring",
    "category": "function",
    "text": "graph = generalized_ring(n, gens)\n\nA generalization of a ring graph. The vertices are integers modulo n. Two are connected if their difference is in gens. For example,\n\ngeneralized_ring(17, [1 5])\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.getCutSet",
    "page": "Docstrings",
    "title": "Laplacians.getCutSet",
    "category": "function",
    "text": "Get the min cut from the source - return all vertices in the cut besides the source \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.getObound",
    "page": "Docstrings",
    "title": "Laplacians.getObound",
    "category": "function",
    "text": "Computes the number of edges leaving s \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.getVolume",
    "page": "Docstrings",
    "title": "Laplacians.getVolume",
    "category": "function",
    "text": "Computes the volume of subset s in an unweighted graph G \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.grid2",
    "page": "Docstrings",
    "title": "Laplacians.grid2",
    "category": "function",
    "text": "graph = grid2(n::Int64, m::Int64; isotropy=1)\n\nAn n-by-m grid graph.  iostropy is the weighting on edges in one direction.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.grid2coords",
    "page": "Docstrings",
    "title": "Laplacians.grid2coords",
    "category": "function",
    "text": "graph = grid2coords(n::Int64, m::Int64)\ngraph = grid2coords(n::Int64)\n\nCoordinates for plotting the vertices of the n-by-m grid graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.grid3",
    "page": "Docstrings",
    "title": "Laplacians.grid3",
    "category": "function",
    "text": "graph = grid3(n1, n2, n3)\ngraph = grid3(n)\n\nAn n1-by-n2-by-n3 grid graph.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.grown_graph",
    "page": "Docstrings",
    "title": "Laplacians.grown_graph",
    "category": "function",
    "text": "graph = grown_graph(n, k; ver=Vcur)\n\nCreate a graph on n vertices. For each vertex, give it k edges to randomly chosen prior vertices. This is a variety of a preferential attachment graph.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.grown_graph_d",
    "page": "Docstrings",
    "title": "Laplacians.grown_graph_d",
    "category": "function",
    "text": "graph = grown_graph_d(n::Integer, k::Integer; ver=Vcur)\n\nLike a grownGraph, but it forces the edges to all be distinct. It starts out with a k+1 clique on the first k vertices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.hypercube",
    "page": "Docstrings",
    "title": "Laplacians.hypercube",
    "category": "function",
    "text": "graph = hyperCube(d::Int64)\n\nThe d dimensional hypercube.  Has 2^d vertices and d*2^(d-1) edges.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.initDictCol!",
    "page": "Docstrings",
    "title": "Laplacians.initDictCol!",
    "category": "function",
    "text": "initDictCol!(dic, name, typ)\n\nFor a dictionary in which each key indexes an array. If dic does not contain an entry of name, create with set to Array(typ,0).\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.initGPrime",
    "page": "Docstrings",
    "title": "Laplacians.initGPrime",
    "category": "function",
    "text": "Initialize GPrime with the set A and edges of type s->u\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.isConnected",
    "page": "Docstrings",
    "title": "Laplacians.isConnected",
    "category": "function",
    "text": "Returns true if graph is connected.  Calls components.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.johnlind",
    "page": "Docstrings",
    "title": "Laplacians.johnlind",
    "category": "function",
    "text": "Johnson Lindenstrauss effective resistance upperbounding. If retXhat is set to true, returns the vectors necessary for computing the effective resistance bounds instead of the actual bounds.\n\n	johnlind(a::SparseMatrixCSC{Tv,Ti}; eps::Tv = 0.5, solver=(la -> augTreeSddm(la,tol=1e-1,maxits=1000,maxtime=10)), retXhat::Bool = false)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.join_graphs",
    "page": "Docstrings",
    "title": "Laplacians.join_graphs",
    "category": "function",
    "text": "graph = joinGraphs(a, b, k::Integer)\n\nCreate a disjoint union of graphs a and b,  and then put k random edges between them\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.join_graphs!",
    "page": "Docstrings",
    "title": "Laplacians.join_graphs!",
    "category": "function",
    "text": "graph = join_graphs!(a::IJV, b::IJV, k::Integer)\n\nCreate a disjoint union of graphs a and b,  and then put k random edges between them, merging b into a.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.kruskal",
    "page": "Docstrings",
    "title": "Laplacians.kruskal",
    "category": "function",
    "text": "(kruskal::SparseMatrixCSC; kind=:max) Uses Kruskal\'s algorithm to compute a minimum (or maximum) spanning tree. Set kind=:min if you want the min spanning tree. It returns it a a graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.lap",
    "page": "Docstrings",
    "title": "Laplacians.lap",
    "category": "function",
    "text": "l = lap(a)\n\nCreate a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.lapWrapComponents",
    "page": "Docstrings",
    "title": "Laplacians.lapWrapComponents",
    "category": "function",
    "text": "f = lapWrapComponents(solver, a::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)\n\nApplies a Laplacian solver that satisfies our interface to each connected component of the graph with adjacency matrix a. Passes kwargs on the solver.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.lapWrapConnected",
    "page": "Docstrings",
    "title": "Laplacians.lapWrapConnected",
    "category": "function",
    "text": "f = lapWrapConnected(sddmSolver, a::AbstractMatrix; kwargs...)\n\nApplies a sddmSolver to the Laplacian of the adjacency matrix a of a connected graph. Passes on kwargs to the solver. sddmSolver should be a solver that obeys the interface.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.lapWrapSDDM",
    "page": "Docstrings",
    "title": "Laplacians.lapWrapSDDM",
    "category": "function",
    "text": "f = lapWrapSDDM(sddmSolver, A::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)\nf = lapWrapSDDM(sddmSolver)\n\nUses a sddmSolver to solve systems of linear equations in Laplacian matrices.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.latin_square",
    "page": "Docstrings",
    "title": "Laplacians.latin_square",
    "category": "function",
    "text": "S = latin_square(n)\n\nComputes a random (but not uniformly random) n-by-n latin square.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.latin_square_graph",
    "page": "Docstrings",
    "title": "Laplacians.latin_square_graph",
    "category": "function",
    "text": "a = latin_square_graph(S::Matrix{Int})\na = latin_square_graph(n::Int)\n\nConstruct the adjacency matrix of the latin square graph for the latin square S. If only n is provided, construct a latin square graph of dimension n.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ldli2Chol",
    "page": "Docstrings",
    "title": "Laplacians.ldli2Chol",
    "category": "function",
    "text": "L = ldli2Chol(ldli)\n\nThis produces a matrix L so that L L^T approximate the original Laplacians. It is not quite a Cholesky factor, because it is off by a perm (and the all-1s vector orthogonality.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.localBlockFlow",
    "page": "Docstrings",
    "title": "Laplacians.localBlockFlow",
    "category": "function",
    "text": "Compute block flow between s and t\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.localFlow",
    "page": "Docstrings",
    "title": "Laplacians.localFlow",
    "category": "function",
    "text": "The LocalFlow function, from the Orecchia-Zhu paper \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.localImprove",
    "page": "Docstrings",
    "title": "Laplacians.localImprove",
    "category": "function",
    "text": "localImprove{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, A::Array{Int64,1}; epsSigma=-1.0, err=1e-10, maxSize = max(G.n, G.m)\n\nThe LocalImprove function, from the Orrechia-Zhu paper. Given a graph and an initial set, finds a set of smaller conductance based on the starting set using a localized version of max-flow.\n\nSmall discussion: When adding in the neighbors of the initial component, if the resulting  conductance is worse than the initial one,  the algorithm will add more and more vertices until hitting a better conductance. However, if we fix a certain  maximum size for our component,  it might be the case that this new conductance will always be worse than what we had initially. Thus, if we run the algorithm with a small maxSize,  our initial conductance might be the best solution we can raech.\n\nG is the given graph, A is the initial set \nepsSigma is a measure of the quality of the returning set (the smaller the better). It\'s defaulted to volume(A) / volume(V - A)\nerr is the numerical error considered throughout the algorithm. It\'s defaulted to 1e-10\nmaxSize is the maximum allowed size for the flow graph at any iteration of the algorithm. It\'s defaulted to |V|\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.mapweight",
    "page": "Docstrings",
    "title": "Laplacians.mapweight",
    "category": "function",
    "text": "b = mapweight(a, x->rand())\n\nCreate a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.maxflow",
    "page": "Docstrings",
    "title": "Laplacians.maxflow",
    "category": "function",
    "text": "implementation of Dinic\'s algorithm. computes the maximum flow and min-cut in G between s and t    we consider the adjacency matrix to be the capacity matrix \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.path_graph",
    "page": "Docstrings",
    "title": "Laplacians.path_graph",
    "category": "function",
    "text": "graph = path_graph(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.path_graph_ijv",
    "page": "Docstrings",
    "title": "Laplacians.path_graph_ijv",
    "category": "function",
    "text": "ijv = path_graph_ijv(n::Int64)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pcg",
    "page": "Docstrings",
    "title": "Laplacians.pcg",
    "category": "function",
    "text": "x = pcg(mat, b, pre; tol, maxits, maxtime, verbose, pcgIts, stag_test)`\n\nsolves a symmetric linear system using preconditioner pre.\n\nArguments\n\npre can be a function or a matrix.  If a matrix, a function to solve it is created with cholFact.\ntol is set to 1e-6 by default,\nmaxits defaults to Inf\nmaxtime defaults to Inf.  It measures seconds.\nverbose defaults to false\npcgIts is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.\nstag_test=k stops the code if rho[it] > (1-1/k) rho[it-k].  Set to 0 to deactivate.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pcgLapSolver",
    "page": "Docstrings",
    "title": "Laplacians.pcgLapSolver",
    "category": "function",
    "text": "x = pcgLapSolver(A, B; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])\n\nCreate a solver that uses pcg to solve Laplacian systems in A Specialized for the case when the preconditioner the Laplacian matrix of B. It solves the preconditioner by Cholesky Factorization.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pcgSolver",
    "page": "Docstrings",
    "title": "Laplacians.pcgSolver",
    "category": "function",
    "text": "x = pcgSolver(mat, pre; tol, maxits, maxtime, verbose, pcgIts)\n\ncreates a solver for a PSD system using preconditioner pre. The parameters are as described in pcg.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.plot_graph",
    "page": "Docstrings",
    "title": "Laplacians.plot_graph",
    "category": "function",
    "text": "plot_graph(gr,x,y;color=[0,0,1],dots=true,setaxis=true,number=false)\n\nPlots graph gr with coordinates (x,y)\n\n\n\n\n\nplot_graph(gr,x,y,z;color=[0,0,1],dots=true,setaxis=true,number=false)\n\nPlots graph gr with coordinates (x,y,z)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.power",
    "page": "Docstrings",
    "title": "Laplacians.power",
    "category": "function",
    "text": "ap = power(a::SparseMatrixCSC, k::Int)\n\nReturns the kth power of a.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pref_attach",
    "page": "Docstrings",
    "title": "Laplacians.pref_attach",
    "category": "function",
    "text": "graph = pref_attach(n::Int64, k::Int64, p::Float64; ver=Vcur)\n\nA preferential attachment graph in which each vertex has k edges to those that come before.  These are chosen with probability p to be from a random vertex, and with probability 1-p to come from the endpoint of a random edge. It begins with a k-clique on the first k+1 vertices.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.prim",
    "page": "Docstrings",
    "title": "Laplacians.prim",
    "category": "function",
    "text": "prim(mat::SparseMatrixCSC; kind=:max) Compute a maximum spanning tree of the matrix mat.   If kind=:min, computes a minimum spanning tree.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.print_ll_col",
    "page": "Docstrings",
    "title": "Laplacians.print_ll_col",
    "category": "function",
    "text": "Print a column in an LLmatp matrix.   This is here for diagnostics.\n\n\n\n\n\nPrint a column in an LLMatOrd matrix.   This is here for diagnostics.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.prn",
    "page": "Docstrings",
    "title": "Laplacians.prn",
    "category": "function",
    "text": "prn{Tv, Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, phi::Float64, b::Int64)\n\nThe PageRank-Nibble cutting algorithm from the Anderson/Chung/Lang paper\n\ns is a set of starting vertices, phi is a constant in (0, 1], and b is an integer in [1, [log m]]\n\nphi is a bound on the quality of the conductance of the cut - the smaller the phi, the higher the quality.  b is used to handle precision throughout the algorithm - the higher the b, the greater the precision.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.product_graph",
    "page": "Docstrings",
    "title": "Laplacians.product_graph",
    "category": "function",
    "text": "aprod = productGraph(a0, a1)\n\nThe Cartesian product of two graphs.  When applied to two paths, it gives a grid.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pure_random_graph",
    "page": "Docstrings",
    "title": "Laplacians.pure_random_graph",
    "category": "function",
    "text": "graph = pure_random_graph(n::Integer; verbose=false, ver=Vcur)\n\nGenerate a random graph with n vertices from one of our natural distributions\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pure_random_ijv",
    "page": "Docstrings",
    "title": "Laplacians.pure_random_ijv",
    "category": "function",
    "text": "a = pure_random_ijv(n::Integer; verbose=false, prefix=\"\", ver=Vcur)\n\nChooses among pathgraph, ringgraph, gridgraph, completebinarytree, randgenring, growngraph and ErdosRenyiClusterFix. It can produce a disconnected graph. For code that always produces a connected graph (and is the same as with Julia v0.6, use purerandomijv_v6)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.pushSpeedResult!",
    "page": "Docstrings",
    "title": "Laplacians.pushSpeedResult!",
    "category": "function",
    "text": "ret is the answer returned by a speed test. This pushed it into the dictionary on which we are storing the tests.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.rand_gen_ring",
    "page": "Docstrings",
    "title": "Laplacians.rand_gen_ring",
    "category": "function",
    "text": "graph = rand_gen_ring(n, k; verbose = false, ver=Vcur)\n\nA random generalized ring graph of degree k. Gens always contains 1, and the other k-1 edge types are chosen from an exponential distribution\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.rand_matching",
    "page": "Docstrings",
    "title": "Laplacians.rand_matching",
    "category": "function",
    "text": "graph = rand_matching(n::Integer; ver=Vcur)\n\nA random matching on n vertices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.rand_regular",
    "page": "Docstrings",
    "title": "Laplacians.rand_regular",
    "category": "function",
    "text": "graph = rand_regular(n, k; ver=Vcur)\n\nA sum of k random matchings on n vertices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.rand_regular_bipartite",
    "page": "Docstrings",
    "title": "Laplacians.rand_regular_bipartite",
    "category": "function",
    "text": "a = rand_regular_bipartite(n,k)\n\nRandom k-regular bipartite graph between two sets of n vertices. No repeat edges, so can take a long time to build of k is close to n.\n\nReturns a (possibly) asymmetric matrix that contains the upper-right block.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.rand_weight",
    "page": "Docstrings",
    "title": "Laplacians.rand_weight",
    "category": "function",
    "text": "graph = randWeight(graph; ver=Vcur)\n\nApplies one of a number of random weighting schemes to the edges of the graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.randishKruskal",
    "page": "Docstrings",
    "title": "Laplacians.randishKruskal",
    "category": "function",
    "text": "tree = randishKruskal(A)\n\nA heuristic for computing low-stretch spanning trees.  Where Kruskal\'s MST algorithm adds edges in order of weight, this algorithm adds them at random with probability proportional to their weight.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.randishPrim",
    "page": "Docstrings",
    "title": "Laplacians.randishPrim",
    "category": "function",
    "text": "tree = randishPrim(A)\n\nA heuristic for computing low-stretch spanning trees.  Where Prim\'s MST algorithm grows a cluster by always adding the edge on the boundary of maximum weight, this algorithm adds a boundary edge with probability proportional to its weight.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Random.randperm",
    "page": "Docstrings",
    "title": "Random.randperm",
    "category": "function",
    "text": "graph = randperm(mat::AbstractMatrix)\n        randperm(f::Expr)\n\nRandomly permutes the vertex indices\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.readIJ",
    "page": "Docstrings",
    "title": "Laplacians.readIJ",
    "category": "function",
    "text": "To read a simple edge list, each line being an (i, j) pair\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.readIJV",
    "page": "Docstrings",
    "title": "Laplacians.readIJV",
    "category": "function",
    "text": "To read a simple edge list, each line being an (i, j, v) pair. The parens should not be there in the format, just commas separating. To generate this format in Matlab, you just need to be careful to write the vertex indices with sufficient precision.  For example, you can do this\n\n>> [ai,aj,av] = find(triu(a));\n>> dlmwrite(\'graph.txt\',[ai,aj,av],\'precision\',9);\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.refineCut",
    "page": "Docstrings",
    "title": "Laplacians.refineCut",
    "category": "function",
    "text": "Modify a cluster by adding or removing vertices by picking at each step \nthe vertex that has the maximum value of (Deg_external - Deg_Internal).\nEach vertex can be added in/removed only once.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ring_graph",
    "page": "Docstrings",
    "title": "Laplacians.ring_graph",
    "category": "function",
    "text": "graph = ring_graph(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.ring_graph_ijv",
    "page": "Docstrings",
    "title": "Laplacians.ring_graph_ijv",
    "category": "function",
    "text": "ijv = ring_graph_ijv(n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.sampleByWeight",
    "page": "Docstrings",
    "title": "Laplacians.sampleByWeight",
    "category": "function",
    "text": "ind = sampleByWeight(wt; ver=Vcur)\n\nsample an index with probability proportional to its weight given here\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.sddmWrapLap",
    "page": "Docstrings",
    "title": "Laplacians.sddmWrapLap",
    "category": "function",
    "text": "f = sddmWrapLap(lapSolver, sddm::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)\n\nUses a lapSolver to solve systems of linear equations in sddm matrices.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.semiwted_chimera",
    "page": "Docstrings",
    "title": "Laplacians.semiwted_chimera",
    "category": "function",
    "text": "graph = semiwted_chimera(n::Integer; verbose=false, ver=Vcur)\n\nA Chimera graph with some weights.  The weights just appear when graphs are combined. For more interesting weights, use wted_chimera\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.setValue",
    "page": "Docstrings",
    "title": "Laplacians.setValue",
    "category": "function",
    "text": "Sets the value of a certain edge in a sparse graph; value can be 0 without the edges dissapearing \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.shortIntGraph",
    "page": "Docstrings",
    "title": "Laplacians.shortIntGraph",
    "category": "function",
    "text": "graph = shortIntGraph(a::SparseMatrixCSC)\n\nConvert the indices in a graph to 32-bit ints. This takes less storage, but does not speed up much.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.shortestPathTree",
    "page": "Docstrings",
    "title": "Laplacians.shortestPathTree",
    "category": "function",
    "text": "Computes the shortest path tree, and returns it as a sparse matrix. Treats edge weights as reciprocals of lengths. For example:\n\na = [0 2 1; 2 0 3; 1 3 0]\ntr = full(shortestPathTree(sparse(a),1))\n\n3x3 Array{Float64,2}:\n 0.0  2.0  0.0\n 2.0  0.0  3.0\n 0.0  3.0  0.0\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.shortestPaths",
    "page": "Docstrings",
    "title": "Laplacians.shortestPaths",
    "category": "function",
    "text": "Computes the lenghts of shortest paths from start. Returns both a vector of the lenghts, and the parent array in the shortest path tree.\n\nThis algorithm treats edge weights as reciprocals of distances. DOC BETTER\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.sortSet",
    "page": "Docstrings",
    "title": "Laplacians.sortSet",
    "category": "function",
    "text": "Given a set of integers, set between 1 and n, return a sorted version of them\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.sparsify",
    "page": "Docstrings",
    "title": "Laplacians.sparsify",
    "category": "function",
    "text": "as = sparsify(a; ep=0.5)\n\nApply Spielman-Srivastava sparsification: sampling by effective resistances. ep should be less than 1.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.spectral_coords",
    "page": "Docstrings",
    "title": "Laplacians.spectral_coords",
    "category": "function",
    "text": "spectral_coords(a)\n\nComputes the spectral coordinates of a graph\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.spectral_drawing",
    "page": "Docstrings",
    "title": "Laplacians.spectral_drawing",
    "category": "function",
    "text": "spectral_drawing(a)\n\nComputes spectral coordinates, and then uses plotGraph to draw\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.speedTestLapSolvers",
    "page": "Docstrings",
    "title": "Laplacians.speedTestLapSolvers",
    "category": "function",
    "text": "function speedTestLapSolvers{Tv,Ti}(solvers, dic, a::SparseMatrixCSC{Tv,Ti}, b::Array{Tv,1}; tol::Real=1e-2, maxits=Inf, maxtime=Inf, verbose=false)\n\nRuns many Laplacians solvers.  Puts the build and solve time results into a dictionary dic.  It would be easiest to look at it via DataFrame(dic).  Returns the answer from the last solver.  solvers should be an array of SolverTest.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.submatrixCSC",
    "page": "Docstrings",
    "title": "Laplacians.submatrixCSC",
    "category": "function",
    "text": "For a the submatrix of a with the entries of ijv indexed by list.  The list must be sorted. This is equivalent to\n\n(ai,aj,av) = findnz(a)\nsparse(ai[list],aj[list],av[list],a.m,a.n)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.subsampleEdges",
    "page": "Docstrings",
    "title": "Laplacians.subsampleEdges",
    "category": "function",
    "text": "graph = subsampleEdges(a::SparseMatrixCSC, p::Float64)\n\nCreate a new graph from the old, but keeping edge edge with probability p\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.support",
    "page": "Docstrings",
    "title": "Laplacians.support",
    "category": "function",
    "text": "sup12, sup21 = support(graph1, graph2; tol=1e-5)\n\nComputes the support of graph1 wrt graph2, and the other way around. It is randomized, so you might want to run it again if you don\'t trust the answers.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.symPermuteCSC",
    "page": "Docstrings",
    "title": "Laplacians.symPermuteCSC",
    "category": "function",
    "text": "Permute the rows and columns of a symmetric matrix, a little faster than the default routine in Julia.  It basically does a radix sort on rows than columns. It does require a to be symmetrix.  But, the same ideas could probably speed up many sparse matrix routines. sympermute(a, perm) is the same as a[perm,perm].\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.symTransposeCSC",
    "page": "Docstrings",
    "title": "Laplacians.symTransposeCSC",
    "category": "function",
    "text": "Compute the transpose of a matrix with symmetric nonzero structure\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.testZeroDiag",
    "page": "Docstrings",
    "title": "Laplacians.testZeroDiag",
    "category": "function",
    "text": "testZeroDiag(a)\n\nReturns true if a has zero diagonal, false otherwise\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.thicken",
    "page": "Docstrings",
    "title": "Laplacians.thicken",
    "category": "function",
    "text": "a_new = thicken(A,k)\n\nCreate a new graph with at least k times as many edges as A By connecting nodes with common neighbors at random. When this stops working (not enough new edges), repeat on the most recently produced graph. If k is too big, it is decreased so the average degree will not be pushed much above n/2.\n\nWhen called without k, it just runs thicken_once.\n\nFor example:\n\na = grid2(5)\na2 = thicken(a,3)\n(x,y) = grid2coords(5,5);\nplotGraph(a2,x,y)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.thicken_once",
    "page": "Docstrings",
    "title": "Laplacians.thicken_once",
    "category": "function",
    "text": "a_new = thicken_once(a)\n\nCreates one edge for every vertex in a of degree > 1 by connecting two of its random neighbors. To use this to thicken a, return unweight(a + a_new).\n\na = grid2(5)\na2 = unweight(a + thicken_once(a))\n(x,y) = grid2coords(5,5);\nplotGraph(a2,x,y)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.treeDepthDFS",
    "page": "Docstrings",
    "title": "Laplacians.treeDepthDFS",
    "category": "function",
    "text": "Compute the vector of depths in a tree that is in DFS order, with the root at the first position, and the leaves at the end\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.two_lift",
    "page": "Docstrings",
    "title": "Laplacians.two_lift",
    "category": "function",
    "text": "graph = two_lift(a, flip::AbstractArray{Bool,1})\ngraph = two_lift(a)\ngraph = two_lift(a, k::Integer)\n\nCreats a 2-lift of a.  flip is a boolean indicating which edges cross. In the third version, k is the number of edges that cross.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.uniformWeight!",
    "page": "Docstrings",
    "title": "Laplacians.uniformWeight!",
    "category": "function",
    "text": "uniformWeight!(a)\n\nSet the weight of every edge to random uniform [0,1]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.uniformWeight_ver",
    "page": "Docstrings",
    "title": "Laplacians.uniformWeight_ver",
    "category": "function",
    "text": "wted = uniformWeight(unwted)\n\nPut a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.unweight",
    "page": "Docstrings",
    "title": "Laplacians.unweight",
    "category": "function",
    "text": "wt1 = unweight(a)\n\nCreate a new graph in that is the same as the original, but with all edge weights 1\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.unweight!",
    "page": "Docstrings",
    "title": "Laplacians.unweight!",
    "category": "function",
    "text": "unweight!(a)\n\nChange the weight of every edge in a to 1\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.vecToComps",
    "page": "Docstrings",
    "title": "Laplacians.vecToComps",
    "category": "function",
    "text": "This turns a component vector, like that generated by components, into an array of arrays of indices of vertices in each component.  For example,\n\ncomps = vecToComps(c)\n\n3-element Array{Array{Int64,1},1}:\n [1,2,3,4,6,7,8]\n [5,10]\n [9]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wdeg",
    "page": "Docstrings",
    "title": "Laplacians.wdeg",
    "category": "function",
    "text": "Finds the weighted degree of a vertex in the graph \n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wrapCapture",
    "page": "Docstrings",
    "title": "Laplacians.wrapCapture",
    "category": "function",
    "text": "f = wrapCapture(solver::Function, mats, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)\n\nThis wraps a solver so that we can capture all the matrices that it solves and all the right-hand-sides. Those are pushed into the arrays mats and rhss. For example\n\njulia> mats = []\njulia> rhss = []\njulia> solver = wrapCapture(approxchol_lap, mats, rhss)\njulia> a = chimera(10)\njulia> f = solver(a);\njulia> size(mats[1])\n(10,10)\njulia> b = randn(10)\njulia> x = f(b);\njulia> rhss\n1-element Array{Any,1}:\n [0.404962,-0.827718,0.704616,-0.403223,0.204891,-0.505589,0.907015,1.90266,-0.438115,0.0464351]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wrapCaptureRhs",
    "page": "Docstrings",
    "title": "Laplacians.wrapCaptureRhs",
    "category": "function",
    "text": "f = wrapCaptureRhs(sola::Function, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)\n\nCaptures all the right-hand-sides that are passed to the solver sola.  It pushes them into an array called rhhs. For example\n\njulia> rhss = []\njulia> a = wted_chimera(100)\njulia> sola = approxchol_lap(a)\njulia> wrappedSolver = wrapCaptureRhs(sola,rhss)\njulia> b = randn(100)\njulia> x = wrappedSolver(b,verbose=true)\n\nPCG BLAS stopped after: 0.0 seconds and 11 iterations with relative error 3.160275810360986e-7.\n\njulia> length(rhss[1])\n\n100\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wrapInterface",
    "page": "Docstrings",
    "title": "Laplacians.wrapInterface",
    "category": "function",
    "text": "solveA = wrapInterface(solver::Function, A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)\nsolverConstructor = wrapInterface(A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)\n\nReturns a function that discards tol, maxits, maxtime and verbose, sets pcgIts to 0 (because it might not be using pcg), and passes whatever params are left to the solver.\n\nExamples\n\njulia> a = randn(5,5);\njulia> a = a * a\';\njulia> solvea = wrapInterface(X->cholesky(X,Val(true)), a, maxits=100, verbose=true);\njulia> b = randn(5,1);\njulia> norm(a*solvea(b, verbose=false)-b)\n1.575705319704736e-14\n\njulia> f = wrapInterface(X->cholesky(X,Val(true)))\njulia> solvea = f(a, maxits=1000, maxtime = 1)\njulia> norm(a*solvea(b, verbose=false, maxtime = 10)-b)\n1.575705319704736e-14\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.writeIJV",
    "page": "Docstrings",
    "title": "Laplacians.writeIJV",
    "category": "function",
    "text": "Writes the upper portion of a matrix in ijv format, one row for each edge, separated by commas.  Only writes the upper triangular portion. The result can be read from Matlab like this:\n\n>> dl = dlmread(\'graph.txt\');\n>> a = sparse(dl(:,1),dl(:,2),dl(:,3));\n>> n = max(size(a))\n>> a(n,n) = 0;\n>> a = a + a\';\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wtedEdgeVertexMat",
    "page": "Docstrings",
    "title": "Laplacians.wtedEdgeVertexMat",
    "category": "function",
    "text": "U = wtedEdgeVertexMat(a)\n\nThe signed and weighted edge-vertex adjacency matrix, so U\'*U = L\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Laplacians.wted_chimera",
    "page": "Docstrings",
    "title": "Laplacians.wted_chimera",
    "category": "function",
    "text": "graph = wted_chimera(n::Integer, k::Integer; verbose=false, ver=Vcur)\n\nBuilds the kth wted chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.\n\n\n\n\n\ngraph = wted_chimera(n::Integer)\n\nGenerate a chimera, and then apply a random weighting scheme\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Laplacians.ApproxCholPQLaplacians.ApproxCholPQElemLaplacians.ApproxCholParamsLaplacians.AugTreeParamsLaplacians.AugTreeParamsOldLaplacians.ErdosRenyiLaplacians.ErdosRenyiClusterLaplacians.ErdosRenyiClusterFixLaplacians.ErdosRenyiClusterFix_ijvLaplacians.ErdosRenyiCluster_ijvLaplacians.ErdosRenyi_ijvLaplacians.FastSamplerLaplacians.HeapEntryLaplacians.IJVLaplacians.IJVSLaplacians.IJVindLaplacians.IJVindGraphLaplacians.IJVindListLaplacians.KMPLapPreconLaplacians.KMPLapPreconSubLaplacians.KMPLapSolverLaplacians.KMPLapSolver1Laplacians.KMPParamsLaplacians.KMPSDDMSolverLaplacians.LDLinvLaplacians.LDLsolverLaplacians.LLMatOrdLaplacians.LLcolLaplacians.LLmatpLaplacians.LLordLaplacians.LLpLaplacians.LapSolversLaplacians.LaplaciansLaplacians.LinkedListStorageLaplacians.RootedTreeLaplacians.SDDMSolversLaplacians.SamplerLaplacians.SolverTestLaplacians.SqLinOpLaplacians.V06Laplacians.V07Laplacians.VcurLaplacians.__init__Laplacians.addToGPrimeLaplacians.adjLaplacians.akpwLaplacians.akpwSub2Laplacians.akpwSub5Laplacians.akpwULaplacians.akpwUsubLaplacians.approxCholLaplacians.approxCholLapLaplacians.approxCholPQDec!Laplacians.approxCholPQInc!Laplacians.approxCholPQMove!Laplacians.approxCholPQPop!Laplacians.approxCholSDDMLaplacians.approxQualLaplacians.approxchol_lapLaplacians.approxchol_lap1Laplacians.approxchol_lapCholLaplacians.approxchol_lapGivenLaplacians.approxchol_lapGreedyLaplacians.approxchol_lapWdegLaplacians.approxchol_sddmLaplacians.aprLaplacians.ask_cholmodLaplacians.augTreeFactorLaplacians.augTreeLapLaplacians.augTreeLap1Laplacians.augTreeLapPreconLaplacians.augTreePreconLaplacians.augTreeSddmLaplacians.augmentTreeLaplacians.augmentTreeOptLaplacians.axpy2!Laplacians.backIndicesLaplacians.backSolveLaplacians.backward!Laplacians.bfsFromSeedLaplacians.bfsOrderLaplacians.biggestCompLaplacians.blockSampleLaplacians.blockSolverLaplacians.bzbeta!Laplacians.cbt_ijvLaplacians.cgLaplacians.cgBLASLaplacians.cgLapSolverLaplacians.cgLapSolver1Laplacians.cgSlowLaplacians.cgSolverLaplacians.chimeraLaplacians.chimera_ijvLaplacians.cholLapLaplacians.cholSDDMLaplacians.chol_lapLaplacians.chol_sddmLaplacians.cholmod_permLaplacians.cluster!Laplacians.combineMultiGLaplacians.compConductanceLaplacians.compDepthLaplacians.compGraphLaplacians.compGraphULaplacians.compStretchesLaplacians.comp_stretchesLaplacians.completeBinaryTreeLaplacians.completeGraphLaplacians.complete_binary_treeLaplacians.complete_graphLaplacians.complete_graph_ijvLaplacians.componentsLaplacians.compressLaplacians.compressCol!Laplacians.compressIndices!Laplacians.computeCNLaplacians.condNumberLaplacians.conditionNumberLaplacians.defaultKMPParamsLaplacians.degLaplacians.dfsOrderLaplacians.diagmatLaplacians.dijkstraFromSeedLaplacians.dirEdgeVertexMatLaplacians.disjoinLaplacians.disjoin!Laplacians.dumbRefineCutLaplacians.edgeVertexMatLaplacians.elementLaplacians.elimDeg12Laplacians.elimDeg2NodeLaplacians.elimLeafNodeLaplacians.empty_graphLaplacians.empty_graph_ijvLaplacians.evalLaplacians.extendMatrixLaplacians.fastPairQueueLaplacians.fastQueueLaplacians.findEntriesLaplacians.firstnLaplacians.flipIndexLaplacians.floatGraphLaplacians.forceLapLaplacians.forward!Laplacians.forwardSolveLaplacians.generalizedNecklaceLaplacians.generalizedRingLaplacians.generalized_necklaceLaplacians.generalized_ringLaplacians.generalized_ring_ijvLaplacians.getCutSetLaplacians.getOboundLaplacians.getVolumeLaplacians.get_ll_colLaplacians.grid2Laplacians.grid2_ijvLaplacians.grid2coordsLaplacians.grid3Laplacians.grid3_ijvLaplacians.grownGraphLaplacians.grownGraphDLaplacians.grown_graphLaplacians.grown_graph_dLaplacians.grown_graph_d_ijvLaplacians.grown_graph_ijvLaplacians.hasMoreLaplacians.hyperCubeLaplacians.hypercubeLaplacians.hypercube_ijvLaplacians.incSizeLaplacians.includeLaplacians.initDictCol!Laplacians.initGPrimeLaplacians.intHeapLaplacians.intHeapAdd!Laplacians.intHeapDown!Laplacians.intHeapPop!Laplacians.intHeapSet!Laplacians.intHeapSortLaplacians.intHeapUp!Laplacians.isConnectedLaplacians.johnlindLaplacians.join_graphsLaplacians.join_graphs!Laplacians.keyMapLaplacians.kidsLaplacians.kruskalLaplacians.lapLaplacians.lapWrapComponentsLaplacians.lapWrapConnectedLaplacians.lapWrapSDDMLaplacians.latin_squareLaplacians.latin_square_graphLaplacians.ldli2CholLaplacians.llsAddLaplacians.llsInitLaplacians.llsPurgeLaplacians.localBlockFlowLaplacians.localFlowLaplacians.localImproveLaplacians.mapweightLaplacians.matToTreeLaplacians.matToTreeDepthLaplacians.match_walkLaplacians.maxflowLaplacians.moduloNextLaplacians.nbriLaplacians.nbrsLaplacians.nullSolverLaplacians.pathFromParentsLaplacians.pathGraphLaplacians.path_graphLaplacians.path_graph_ijvLaplacians.pcgLaplacians.pcgBLASLaplacians.pcgLapSolverLaplacians.pcgSlowLaplacians.pcgSolverLaplacians.plotGraphLaplacians.plot_graphLaplacians.powerLaplacians.powerIterationLaplacians.prefAttachLaplacians.pref_attachLaplacians.pref_attach_ijvLaplacians.primLaplacians.print_ll_colLaplacians.printijvLaplacians.prnLaplacians.productGraphLaplacians.product_graphLaplacians.pull!Laplacians.pure_random_graphLaplacians.pure_random_ijvLaplacians.pure_random_ijv_v6Laplacians.pure_random_ijv_v7Laplacians.pushSpeedResult!Laplacians.randGenRingLaplacians.randMatchingLaplacians.randRegularLaplacians.randSetLaplacians.randWeightLaplacians.randWeightSubLaplacians.rand_gen_ringLaplacians.rand_gen_ring_ijvLaplacians.rand_matchingLaplacians.rand_matching_ijvLaplacians.rand_regularLaplacians.rand_regular_bipartiteLaplacians.rand_regular_ijvLaplacians.rand_weightLaplacians.rand_weight_subLaplacians.randishKruskalLaplacians.randishPrimLaplacians.randpermLaplacians.randperm_ver!Laplacians.readIJLaplacians.readIJVLaplacians.refineCutLaplacians.regular_bipartite_matchingLaplacians.remove!Laplacians.reset!Laplacians.reusableIntMapLaplacians.ringGraphLaplacians.ring_graphLaplacians.ring_graph_ijvLaplacians.sampleLaplacians.sampleByWeightLaplacians.sampleManyLaplacians.sddmWrapLapLaplacians.semiWtedChimeraLaplacians.semiwted_chimeraLaplacians.semiwted_chimera_ijvLaplacians.semiwted_chimera_ijv_v6Laplacians.semiwted_chimera_ijv_v7Laplacians.set!Laplacians.setValueLaplacians.shortIntGraphLaplacians.shortestPathTreeLaplacians.shortestPathsLaplacians.sortIJVindLaplacians.sortSetLaplacians.sparsifyLaplacians.spectralCoordsLaplacians.spectralDrawingLaplacians.spectral_coordsLaplacians.spectral_drawingLaplacians.speedTestLapSolversLaplacians.stretchSampleLaplacians.subMean!Laplacians.submatrixCSCLaplacians.subsampleEdgesLaplacians.supportLaplacians.symPermuteCSCLaplacians.symTransposeCSCLaplacians.tarjanStretchLaplacians.tarjanStretchSubLaplacians.testIdLaplacians.testSolverLaplacians.testZeroDiagLaplacians.test_latin_squareLaplacians.test_regular_bipartiteLaplacians.thickenLaplacians.thickenOnceLaplacians.thicken_onceLaplacians.toposortLaplacians.treeDepthDFSLaplacians.twoLiftLaplacians.two_liftLaplacians.uniformWeightLaplacians.uniformWeight!Laplacians.uniformWeight_verLaplacians.uniformWeight_ver!Laplacians.unweightLaplacians.unweight!Laplacians.vecToCompsLaplacians.wdegLaplacians.weightiLaplacians.weightsLaplacians.wrapCaptureLaplacians.wrapCaptureRhsLaplacians.wrapInterfaceLaplacians.writeIJVLaplacians.wtedChimeraLaplacians.wtedEdgeVertexMatLaplacians.wted_chimera"
},

]}
