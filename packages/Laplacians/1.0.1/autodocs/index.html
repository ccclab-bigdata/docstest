<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Laplacians.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Laplacians.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ApproxCholPQ" href="#Laplacians.ApproxCholPQ"><code>Laplacians.ApproxCholPQ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An approximate priority queue.   Items are bundled together into doubly-linked lists with all approximately the same key.   minlist is the min list we know to be non-empty.   It should always be a lower bound.   keyMap maps keys to lists</p></div></div></section><pre><code class="language-none">Laplacians.ApproxCholPQElem</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ApproxCholParams" href="#Laplacians.ApproxCholParams"><code>Laplacians.ApproxCholParams</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">params = ApproxCholParams(order, output)</code></pre><p>order can be one of</p><ul><li>:deg (by degree, adaptive),</li><li>:wdeg (by original wted degree, nonadaptive),</li><li>:given</li></ul></div></div></section><pre><code class="language-none">Laplacians.AugTreeParams</code></pre><pre><code class="language-none">Laplacians.AugTreeParamsOld</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ErdosRenyi" href="#Laplacians.ErdosRenyi"><code>Laplacians.ErdosRenyi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = ErdosRenyi(n::Integer, m::Integer; ver=Vcur)</code></pre><p>Generate a random graph on n vertices with m edges. The actual number of edges will probably be smaller, as we sample with replacement</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ErdosRenyiCluster" href="#Laplacians.ErdosRenyiCluster"><code>Laplacians.ErdosRenyiCluster</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = ErdosRenyiCluster(n::Integer, k::Integer; ver=Vcur)</code></pre><p>Generate an ER graph with average degree k, and then return the largest component. Will probably have fewer than n vertices. If you want to add a tree to bring it back to n, try ErdosRenyiClusterFix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ErdosRenyiClusterFix" href="#Laplacians.ErdosRenyiClusterFix"><code>Laplacians.ErdosRenyiClusterFix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = ErdosRenyiClusterFix(n::Integer, k::Integer; ver=Vcur)</code></pre><p>Like an Erdos-Renyi cluster, but add back a tree so it has n vertices</p></div></div></section><pre><code class="language-none">Laplacians.ErdosRenyiClusterFix_ijv</code></pre><pre><code class="language-none">Laplacians.ErdosRenyiCluster_ijv</code></pre><pre><code class="language-none">Laplacians.ErdosRenyi_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.FastSampler" href="#Laplacians.FastSampler"><code>Laplacians.FastSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">s = FastSampler(p)</code></pre></div></div></section><pre><code class="language-none">Laplacians.HeapEntry</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.IJV" href="#Laplacians.IJV"><code>Laplacians.IJV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ijv = IJV(A::SparseMatrixCSC)</code></pre><p>Convert a sparse matrix to an IJV.</p></div></div></section><pre><code class="language-none">Laplacians.IJVS</code></pre><pre><code class="language-none">Laplacians.IJVind</code></pre><pre><code class="language-none">Laplacians.IJVindGraph</code></pre><pre><code class="language-none">Laplacians.IJVindList</code></pre><pre><code class="language-none">Laplacians.KMPLapPrecon</code></pre><pre><code class="language-none">Laplacians.KMPLapPreconSub</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPLapSolver" href="#Laplacians.KMPLapSolver"><code>Laplacians.KMPLapSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lapSolver = KMPLapSolver(A; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in the Laplacian of graph with adjacency matrix <code>A</code>.</p><p>Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div></div></section><pre><code class="language-none">Laplacians.KMPLapSolver1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPParams" href="#Laplacians.KMPParams"><code>Laplacians.KMPParams</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parameters for the KMP solver</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPSDDMSolver" href="#Laplacians.KMPSDDMSolver"><code>Laplacians.KMPSDDMSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sddmSolver = KMPSDDMSolver(mat; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in symmetric, diagonally dominant matrices with non-positive off-diagonals.  Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LDLinv" href="#Laplacians.LDLinv"><code>Laplacians.LDLinv</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LDLinv contains the information needed to solve the Laplacian systems.   It does it by applying Linv, then Dinv, then Linv (transpose).   But, it is specially constructed for this particular solver.   It does not explicitly make the matrix triangular.   Rather, col[i] is the name of the ith col to be eliminated</p></div></div></section><pre><code class="language-none">Laplacians.LDLsolver</code></pre><pre><code class="language-none">Laplacians.LLMatOrd</code></pre><pre><code class="language-none">Laplacians.LLcol</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LLmatp" href="#Laplacians.LLmatp"><code>Laplacians.LLmatp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LLmatp is the data structure used to maintain the matrix during elimination.   It stores the elements in each column in a singly linked list (only next ptrs)   Each element is an LLp (linked list pointer).   The head of each column is pointed to by cols.</p><p>We probably can get rid of degs - as it is only used to store initial degrees.</p></div></div></section><pre><code class="language-none">Laplacians.LLord</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LLp" href="#Laplacians.LLp"><code>Laplacians.LLp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LLp elements are all in the same column.   row tells us the row, and val is the entry.   val is set to zero for some edges that we should remove.   next gives the next in the column.  It points to itself to terminate.   reverse is the index into lles of the other copy of this edge,   since every edge is stored twice as we do not know the order of elimination in advance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LapSolvers" href="#Laplacians.LapSolvers"><code>Laplacians.LapSolvers</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A list containing Laplacian linear system solvers. They take in an adjacency matrix plus tol, maxits and maxtime parameters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.Laplacians" href="#Laplacians.Laplacians"><code>Laplacians.Laplacians</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A package for graph computations related to graph Laplacians</p><p>Graphs are represented by sparse adjacency matrices, etc.</p></div></div></section><pre><code class="language-none">Laplacians.LinkedListStorage</code></pre><pre><code class="language-none">Laplacians.RootedTree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.SDDMSolvers" href="#Laplacians.SDDMSolvers"><code>Laplacians.SDDMSolvers</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A list containing SDDM linear system solvers. They take in a SDDM matrix plus tol, maxits and maxtime parameters.</p></div></div></section><pre><code class="language-none">Laplacians.Sampler</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.SolverTest" href="#Laplacians.SolverTest"><code>Laplacians.SolverTest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SolverTest(solver, name)</code></pre><p>Encloses a solver with its name, so that we can compare it in tests</p></div></div></section><pre><code class="language-none">Laplacians.SqLinOp</code></pre><pre><code class="language-none">Laplacians.V06</code></pre><pre><code class="language-none">Laplacians.V07</code></pre><pre><code class="language-none">Laplacians.Vcur</code></pre><pre><code class="language-none">Laplacians.__init__</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.addToGPrime" href="#Laplacians.addToGPrime"><code>Laplacians.addToGPrime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Add a new vertex to GPrime </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.adj" href="#Laplacians.adj"><code>Laplacians.adj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a,d = adj(sddm)</code></pre><p>Create an adjacency matrix and a diagonal vector from an SDD M-matrix. That is, from a Laplacian with added diagonal weights</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.akpw" href="#Laplacians.akpw"><code>Laplacians.akpw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tree = akpw(graph; ver=0)</code></pre><p>Computes a low stretch spanning tree of <code>graph</code>, and returns it as a graph. The default version is 0.  In event of emergency, one can try <code>ver=2</code>.  It is usually slower, but might have slightly better stretch.</p></div></div></section><pre><code class="language-none">Laplacians.akpwSub2</code></pre><pre><code class="language-none">Laplacians.akpwSub5</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.akpwU" href="#Laplacians.akpwU"><code>Laplacians.akpwU</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tree = akpwU(graph)</code></pre><p>Computes a low stretch spanning tree of an unweighted <code>graph</code>, and returns it as a graph.</p></div></div></section><pre><code class="language-none">Laplacians.akpwUsub</code></pre><pre><code class="language-none">Laplacians.approxChol</code></pre><pre><code class="language-none">Laplacians.approxCholLap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxCholPQDec!" href="#Laplacians.approxCholPQDec!"><code>Laplacians.approxCholPQDec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Decrement the key of element i
This could crash if i exceeds the maxkey</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxCholPQInc!" href="#Laplacians.approxCholPQInc!"><code>Laplacians.approxCholPQInc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Increment the key of element i
This could crash if i exceeds the maxkey</code></pre></div></div></section><pre><code class="language-none">Laplacians.approxCholPQMove!</code></pre><pre><code class="language-none">Laplacians.approxCholPQPop!</code></pre><pre><code class="language-none">Laplacians.approxCholSDDM</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxQual" href="#Laplacians.approxQual"><code>Laplacians.approxQual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eps = approxQual(graph1, graph2; tol=1e-5, verbose=false)</code></pre><p>Computes the eps for which graph1 and graph2 are eps approximations of each other. That is, L1 &lt;= (1+eps) L2, and vice versa.</p><p>It is randomized, so you might want to run it again if you don&#39;t trust the answers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_lap" href="#Laplacians.approxchol_lap"><code>Laplacians.approxchol_lap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = approxchol_lap(a); x = solver(b);
solver = approxchol_lap(a; tol::Real=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>A heuristic by Daniel Spielman inspired by the linear system solver in https://arxiv.org/abs/1605.02353 by Rasmus Kyng and Sushant Sachdeva.  Whereas that paper eliminates vertices one at a time, this eliminates edges one at a time.  It is probably possible to analyze it. The <code>ApproxCholParams</code> let you choose one of three orderings to perform the elimination.</p><ul><li>ApproxCholParams(:given) - in the order given.   This is the fastest for construction the preconditioner, but the slowest solve.</li><li>ApproxCholParams(:deg) - always eliminate the node of lowest degree.   This is the slowest build, but the fastest solve.</li><li>ApproxCholParams(:wdeg) - go by a perturbed order of wted degree.  </li></ul><p>For more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html</p></div></div></section><pre><code class="language-none">Laplacians.approxchol_lap1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_lapChol" href="#Laplacians.approxchol_lapChol"><code>Laplacians.approxchol_lapChol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This variation of approxChol creates a cholesky factor to do the elimination. It has not yet been optimized, and does not yet make the cholesky factor lower triangular</p></div></div></section><pre><code class="language-none">Laplacians.approxchol_lapGiven</code></pre><pre><code class="language-none">Laplacians.approxchol_lapGreedy</code></pre><pre><code class="language-none">Laplacians.approxchol_lapWdeg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_sddm" href="#Laplacians.approxchol_sddm"><code>Laplacians.approxchol_sddm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = approxchol_sddm(sddm); x = solver(b);
solver = approxchol_sddm(sddm; tol=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>Solves sddm systems by wrapping approxchol_lap. Not yet optimized directly for sddm.</p><p>For more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.apr" href="#Laplacians.apr"><code>Laplacians.apr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes an approximate page rank vector from a starting set s, an alpha and an epsilon The algorithm follows the Anderson,Chung,Lang paper and Dan Spielman&#39;s lecture notes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ask_cholmod" href="#Laplacians.ask_cholmod"><code>Laplacians.ask_cholmod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>nnzL, flops = ask_cholmod(mat)</p><p>Estimate the number of nonzeros in the cholfact factorization of mat,  along with the number of flops needed to compute it. Does this through a call to the analyze routine of cholmod. Note that this is much faster than actually computing the factorization</p></div></div></section><pre><code class="language-none">Laplacians.augTreeFactor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeLap" href="#Laplacians.augTreeLap"><code>Laplacians.augTreeLap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = augTreeLap(A; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for Laplacians.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div></div></section><pre><code class="language-none">Laplacians.augTreeLap1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeLapPrecon" href="#Laplacians.augTreeLapPrecon"><code>Laplacians.augTreeLapPrecon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pre = augTreeLapPrecon{Tv,Ti}(A; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for Laplacians. It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via <code>augmentTree</code>: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeLapSolver</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreePrecon" href="#Laplacians.augTreePrecon"><code>Laplacians.augTreePrecon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pre = augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti}; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via augmentTree: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeSolver</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeSddm" href="#Laplacians.augTreeSddm"><code>Laplacians.augTreeSddm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = augTreeSddm(sddm; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[],  params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for positive definite diagonally dominant matrices.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augmentTree" href="#Laplacians.augmentTree"><code>Laplacians.augmentTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">B = augmentTree{Tv,Ti}(tree, A, k)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch.</p><p>This is the old alg.  We now recommend using augmentTreeOpt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augmentTreeOpt" href="#Laplacians.augmentTreeOpt"><code>Laplacians.augmentTreeOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">B = augmentTreeOpt{Tv,Ti}(tree, A, params)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It uses cholmod to decide how many edge to add back, shooting for nnzL<em>fac times n entries in the factored augmented tree, with a number of flops to factor equal to nnz(a)*flops</em>fac. The edges to add back are then choen at random.</p></div></div></section><pre><code class="language-none">Laplacians.axpy2!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.backIndices" href="#Laplacians.backIndices"><code>Laplacians.backIndices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the back indices in a graph in O(M+N). works if for every edge (u,v), (v,u) is also in the graph </p></div></div><div><div><p>Same as the above, but now the graph is in adjacency list form </p></div></div></section><pre><code class="language-none">Laplacians.backSolve</code></pre><pre><code class="language-none">Laplacians.backward!</code></pre><pre><code class="language-none">Laplacians.bfsFromSeed</code></pre><pre><code class="language-none">Laplacians.bfsOrder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.biggestComp" href="#Laplacians.biggestComp"><code>Laplacians.biggestComp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the biggest component in a graph, as a graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.blockSample" href="#Laplacians.blockSample"><code>Laplacians.blockSample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = blockSample(p; k = length(p))</code></pre><p>Compute numbers sampled with probability proportional to the vector p. They are returned in order. If need be, they can be permuted with randperm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.blockSolver" href="#Laplacians.blockSolver"><code>Laplacians.blockSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply the ith solver on the ith component</p></div></div></section><pre><code class="language-none">Laplacians.bzbeta!</code></pre><pre><code class="language-none">Laplacians.cbt_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cg" href="#Laplacians.cg"><code>Laplacians.cg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = cg(mat, b; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>solves a symmetric linear system <code>mat x = b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li></ul></div></div></section><pre><code class="language-none">Laplacians.cgBLAS</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cgLapSolver" href="#Laplacians.cgLapSolver"><code>Laplacians.cgLapSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = cgLapSolver(A::AbstractMatrix; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses cg to solve Laplacian systems in the laplacian of A. This just exists to satisfy our interface. It does nothing more than create the Laplacian and call cg on each connected component.</p></div></div></section><pre><code class="language-none">Laplacians.cgLapSolver1</code></pre><pre><code class="language-none">Laplacians.cgSlow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cgSolver" href="#Laplacians.cgSolver"><code>Laplacians.cgSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = cgSolver(mat; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system <code>mat</code>. The parameters are as described in cg.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.chimera" href="#Laplacians.chimera"><code>Laplacians.chimera</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = chimera(n::Integer; verbose=false, ver=Vcur)</code></pre><p>Builds a chimeric graph on n vertices. The components come from pureRandomGraph, connected by joinGraphs, productGraph and generalizedNecklace</p></div></div><div><div><pre><code class="language-none">graph = chimera(n::Integer, k::Integer; verbose=false, ver=Vcur)</code></pre><p>Builds the kth chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p></div></div></section><pre><code class="language-none">Laplacians.chimera_ijv</code></pre><pre><code class="language-none">Laplacians.cholLap</code></pre><pre><code class="language-none">Laplacians.cholSDDM</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.chol_lap" href="#Laplacians.chol_lap"><code>Laplacians.chol_lap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = chol_lap(A::AbstractArray)</code></pre><p>Uses Cholesky Factorization to solve systems in Laplacians.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.chol_sddm" href="#Laplacians.chol_sddm"><code>Laplacians.chol_sddm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solveSDDM = chol_sddm(sddm::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[])</code></pre><p>This functions wraps cholfact so that it satsfies our interface. It ignores all the keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cholmod_perm" href="#Laplacians.cholmod_perm"><code>Laplacians.cholmod_perm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>p = cholmod_perm(mat)</p><p>Return the permutation that cholmod would apply.</p></div></div></section><pre><code class="language-none">Laplacians.cluster!</code></pre><pre><code class="language-none">Laplacians.combineMultiG</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.compConductance" href="#Laplacians.compConductance"><code>Laplacians.compConductance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the quality of the cut for a given graph and a given cut set s.   the result will be |outgoing edges| / min(|vertices in set|, |N - vertices in set|)</p></div></div></section><pre><code class="language-none">Laplacians.compDepth</code></pre><pre><code class="language-none">Laplacians.compGraph</code></pre><pre><code class="language-none">Laplacians.compGraphU</code></pre><pre><code class="language-none">Laplacians.compStretches</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.comp_stretches" href="#Laplacians.comp_stretches"><code>Laplacians.comp_stretches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the stretched of every edge in <code>mat</code> with respect to the tree <code>tree</code>. Returns the answer as a sparse matrix with the same nonzero structure as <code>mat</code>. Assumes that <code>mat</code> is symmetric. <code>tree</code> should be the adjacency matrix of a spanning tree.</p></div></div></section><pre><code class="language-none">Laplacians.completeBinaryTree</code></pre><pre><code class="language-none">Laplacians.completeGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.complete_binary_tree" href="#Laplacians.complete_binary_tree"><code>Laplacians.complete_binary_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = completeBinaryTree(n::Int64)</code></pre><p>The complete binary tree on n vertices</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.complete_graph" href="#Laplacians.complete_graph"><code>Laplacians.complete_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = complete_graph(n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.complete_graph_ijv" href="#Laplacians.complete_graph_ijv"><code>Laplacians.complete_graph_ijv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ijv = complete_graph_ijv(n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.components" href="#Laplacians.components"><code>Laplacians.components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the connected components of a graph. Returns them as a vector of length equal to the number of vertices. The vector numbers the components from 1 through the maximum number. For example,</p><pre><code class="language-julia">gr = ErdosRenyi(10,11)
c = components(gr)

10-element Array{Int64,1}:
 1
 1
 1
 1
 2
 1
 1
 1
 3
 2</code></pre></div></div></section><pre><code class="language-none">Laplacians.compress</code></pre><pre><code class="language-none">Laplacians.compressCol!</code></pre><pre><code class="language-none">Laplacians.compressIndices!</code></pre><pre><code class="language-none">Laplacians.computeCN</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.condNumber" href="#Laplacians.condNumber"><code>Laplacians.condNumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cn = condNumber(a, ldli; verbose=false)</code></pre><p>Given an adjacency matrix a and an ldli computed by approxChol, this computes the condition number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.conditionNumber" href="#Laplacians.conditionNumber"><code>Laplacians.conditionNumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kapps = conditionNumber(graph1, graph2; tol=1e-5, verbose=false)</code></pre><p>Computes the relative condition number of graph1 and graph2.</p><p>It is randomized, so you might want to run it again if you don&#39;t trust the answers.</p></div></div><div><div><pre><code class="language-none">kappa = conditionNumber(graph, precon; tol=1e-5, verbose=false)</code></pre><p>Computes the relative condition number of graph and a preconditioning function.</p><p>It is randomized, so you might want to run it again if you don&#39;t trust the answers.</p></div></div></section><pre><code class="language-none">Laplacians.defaultKMPParams</code></pre><pre><code class="language-none">Laplacians.deg</code></pre><pre><code class="language-none">Laplacians.dfsOrder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.diagmat" href="#Laplacians.diagmat"><code>Laplacians.diagmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">d = diagmat(a)</code></pre><p>Returns the diagonal weighted degree matrix(as a sparse matrix) of a graph</p></div></div></section><pre><code class="language-none">Laplacians.dijkstraFromSeed</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.dirEdgeVertexMat" href="#Laplacians.dirEdgeVertexMat"><code>Laplacians.dirEdgeVertexMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The signed edge-vertex adjacency matrix</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.disjoin" href="#Laplacians.disjoin"><code>Laplacians.disjoin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = disjoin(a,b)</code></pre><p>Create a disjoint union of graphs a and b,   with no edges between them.</p></div></div></section><pre><code class="language-none">Laplacians.disjoin!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.dumbRefineCut" href="#Laplacians.dumbRefineCut"><code>Laplacians.dumbRefineCut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Modify a cluster by passing through all the vertices exactly once and 
adding/removing them based on the value of (Deg_external - Deg_Internal).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.edgeVertexMat" href="#Laplacians.edgeVertexMat"><code>Laplacians.edgeVertexMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">U = edgeVertexMat(a)</code></pre><p>The signed edge-vertex adjacency matrix</p></div></div></section><pre><code class="language-none">Laplacians.element</code></pre><pre><code class="language-none">Laplacians.elimDeg12</code></pre><pre><code class="language-none">Laplacians.elimDeg2Node</code></pre><pre><code class="language-none">Laplacians.elimLeafNode</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.empty_graph" href="#Laplacians.empty_graph"><code>Laplacians.empty_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ijv = empty_graph(n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.empty_graph_ijv" href="#Laplacians.empty_graph_ijv"><code>Laplacians.empty_graph_ijv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ijv = empty_graph_ijv(n)</code></pre></div></div></section><pre><code class="language-none">Laplacians.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.extendMatrix" href="#Laplacians.extendMatrix"><code>Laplacians.extendMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Add a new vertex to a with weights to the other vertices corresponding to diagonal surplus weight.</p><p>This is an efficient way of writing [a d; d&#39; 0]</p></div></div></section><pre><code class="language-none">Laplacians.fastPairQueue</code></pre><pre><code class="language-none">Laplacians.fastQueue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.findEntries" href="#Laplacians.findEntries"><code>Laplacians.findEntries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Similar to findnz, but also returns 0 entries that have an edge in the sparse matrix </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.firstn" href="#Laplacians.firstn"><code>Laplacians.firstn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">b = firstn(a::IJV, n::Integer)</code></pre><p>Only keep the first n vertices of a.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.flipIndex" href="#Laplacians.flipIndex"><code>Laplacians.flipIndex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For a symmetric matrix, this gives the correspondance between pairs of entries in an ijv. So, ai[ind] = aj[flip[ind]].  For example, </p><pre><code class="language-none">(ai,aj,av) = findnz(a);
fl = flipIndex(a)
ind = 10
@show backind = fl[10]
@show [ai[ind], aj[ind], av[ind]]
@show [ai[backind], aj[backind], av[backind]];

backind = fl[10] = 4
[ai[ind],aj[ind],av[ind]] = [2.0,4.0,0.7]
[ai[backind],aj[backind],av[backind]] = [4.0,2.0,0.7]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.floatGraph" href="#Laplacians.floatGraph"><code>Laplacians.floatGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>graph = floatGraph(a::SparseMatrixCSC)</p><p>Convert the nonzero entries in a graph to Float64.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.forceLap" href="#Laplacians.forceLap"><code>Laplacians.forceLap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">la = forceLap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. If the input looks like a Laplacian, throw a warning and convert it.</p></div></div></section><pre><code class="language-none">Laplacians.forward!</code></pre><pre><code class="language-none">Laplacians.forwardSolve</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.generalizedNecklace" href="#Laplacians.generalizedNecklace"><code>Laplacians.generalizedNecklace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = generalizedNecklace(A, H, k::Int64)</code></pre><p>Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.</p></div></div></section><pre><code class="language-none">Laplacians.generalizedRing</code></pre><pre><code class="language-none">Laplacians.generalized_necklace</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.generalized_ring" href="#Laplacians.generalized_ring"><code>Laplacians.generalized_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = generalized_ring(n, gens)</code></pre><p>A generalization of a ring graph. The vertices are integers modulo n. Two are connected if their difference is in gens. For example,</p><pre><code class="language-none">generalized_ring(17, [1 5])</code></pre></div></div></section><pre><code class="language-none">Laplacians.generalized_ring_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.getCutSet" href="#Laplacians.getCutSet"><code>Laplacians.getCutSet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the min cut from the source - return all vertices in the cut besides the source </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.getObound" href="#Laplacians.getObound"><code>Laplacians.getObound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the number of edges leaving s </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.getVolume" href="#Laplacians.getVolume"><code>Laplacians.getVolume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the volume of subset s in an unweighted graph G </p></div></div></section><pre><code class="language-none">Laplacians.get_ll_col</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.grid2" href="#Laplacians.grid2"><code>Laplacians.grid2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = grid2(n::Int64, m::Int64; isotropy=1)</code></pre><p>An n-by-m grid graph.  iostropy is the weighting on edges in one direction.</p></div></div></section><pre><code class="language-none">Laplacians.grid2_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.grid2coords" href="#Laplacians.grid2coords"><code>Laplacians.grid2coords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = grid2coords(n::Int64, m::Int64)
graph = grid2coords(n::Int64)</code></pre><p>Coordinates for plotting the vertices of the n-by-m grid graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.grid3" href="#Laplacians.grid3"><code>Laplacians.grid3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = grid3(n1, n2, n3)
graph = grid3(n)</code></pre><p>An n1-by-n2-by-n3 grid graph.</p></div></div></section><pre><code class="language-none">Laplacians.grid3_ijv</code></pre><pre><code class="language-none">Laplacians.grownGraph</code></pre><pre><code class="language-none">Laplacians.grownGraphD</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.grown_graph" href="#Laplacians.grown_graph"><code>Laplacians.grown_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = grown_graph(n, k; ver=Vcur)</code></pre><p>Create a graph on n vertices. For each vertex, give it k edges to randomly chosen prior vertices. This is a variety of a preferential attachment graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.grown_graph_d" href="#Laplacians.grown_graph_d"><code>Laplacians.grown_graph_d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = grown_graph_d(n::Integer, k::Integer; ver=Vcur)</code></pre><p>Like a grownGraph, but it forces the edges to all be distinct. It starts out with a k+1 clique on the first k vertices</p></div></div></section><pre><code class="language-none">Laplacians.grown_graph_d_ijv</code></pre><pre><code class="language-none">Laplacians.grown_graph_ijv</code></pre><pre><code class="language-none">Laplacians.hasMore</code></pre><pre><code class="language-none">Laplacians.hyperCube</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.hypercube" href="#Laplacians.hypercube"><code>Laplacians.hypercube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = hyperCube(d::Int64)</code></pre><p>The d dimensional hypercube.  Has 2^d vertices and d*2^(d-1) edges.</p></div></div></section><pre><code class="language-none">Laplacians.hypercube_ijv</code></pre><pre><code class="language-none">Laplacians.incSize</code></pre><pre><code class="language-none">Laplacians.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.initDictCol!" href="#Laplacians.initDictCol!"><code>Laplacians.initDictCol!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initDictCol!(dic, name, typ)</code></pre><p>For a dictionary in which each key indexes an array. If dic does not contain an entry of <code>name</code>, create with set to <code>Array(typ,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.initGPrime" href="#Laplacians.initGPrime"><code>Laplacians.initGPrime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialize GPrime with the set A and edges of type s-&gt;u</p></div></div></section><pre><code class="language-none">Laplacians.intHeap</code></pre><pre><code class="language-none">Laplacians.intHeapAdd!</code></pre><pre><code class="language-none">Laplacians.intHeapDown!</code></pre><pre><code class="language-none">Laplacians.intHeapPop!</code></pre><pre><code class="language-none">Laplacians.intHeapSet!</code></pre><pre><code class="language-none">Laplacians.intHeapSort</code></pre><pre><code class="language-none">Laplacians.intHeapUp!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.isConnected" href="#Laplacians.isConnected"><code>Laplacians.isConnected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns true if graph is connected.  Calls components.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.johnlind" href="#Laplacians.johnlind"><code>Laplacians.johnlind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Johnson Lindenstrauss effective resistance upperbounding. If retXhat is set to true, returns the vectors necessary for computing the effective resistance bounds instead of the actual bounds.</p><pre><code class="language-julia">	johnlind(a::SparseMatrixCSC{Tv,Ti}; eps::Tv = 0.5, solver=(la -&gt; augTreeSddm(la,tol=1e-1,maxits=1000,maxtime=10)), retXhat::Bool = false)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.join_graphs" href="#Laplacians.join_graphs"><code>Laplacians.join_graphs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = joinGraphs(a, b, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.join_graphs!" href="#Laplacians.join_graphs!"><code>Laplacians.join_graphs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = join_graphs!(a::IJV, b::IJV, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them, merging b into a.</p></div></div></section><pre><code class="language-none">Laplacians.keyMap</code></pre><pre><code class="language-none">Laplacians.kids</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.kruskal" href="#Laplacians.kruskal"><code>Laplacians.kruskal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>(kruskal::SparseMatrixCSC; kind=:max)</code> Uses Kruskal&#39;s algorithm to compute a minimum (or maximum) spanning tree. Set kind=:min if you want the min spanning tree. It returns it a a graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lap" href="#Laplacians.lap"><code>Laplacians.lap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">l = lap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapComponents" href="#Laplacians.lapWrapComponents"><code>Laplacians.lapWrapComponents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = lapWrapComponents(solver, a::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Applies a Laplacian <code>solver</code> that satisfies our interface to each connected component of the graph with adjacency matrix <code>a</code>. Passes kwargs on the solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapConnected" href="#Laplacians.lapWrapConnected"><code>Laplacians.lapWrapConnected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = lapWrapConnected(sddmSolver, a::AbstractMatrix; kwargs...)</code></pre><p>Applies a <code>sddmSolver</code> to the Laplacian of the adjacency matrix <code>a</code> of a connected graph. Passes on kwargs to the solver. <code>sddmSolver</code> should be a solver that obeys the interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapSDDM" href="#Laplacians.lapWrapSDDM"><code>Laplacians.lapWrapSDDM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = lapWrapSDDM(sddmSolver, A::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)
f = lapWrapSDDM(sddmSolver)</code></pre><p>Uses a <code>sddmSolver</code> to solve systems of linear equations in Laplacian matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.latin_square" href="#Laplacians.latin_square"><code>Laplacians.latin_square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">S = latin_square(n)</code></pre><p>Computes a random (but not uniformly random) n-by-n latin square.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.latin_square_graph" href="#Laplacians.latin_square_graph"><code>Laplacians.latin_square_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a = latin_square_graph(S::Matrix{Int})
a = latin_square_graph(n::Int)</code></pre><p>Construct the adjacency matrix of the latin square graph for the latin square S. If only n is provided, construct a latin square graph of dimension n.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ldli2Chol" href="#Laplacians.ldli2Chol"><code>Laplacians.ldli2Chol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">L = ldli2Chol(ldli)</code></pre><p>This produces a matrix L so that L L^T approximate the original Laplacians. It is not quite a Cholesky factor, because it is off by a perm (and the all-1s vector orthogonality.</p></div></div></section><pre><code class="language-none">Laplacians.llsAdd</code></pre><pre><code class="language-none">Laplacians.llsInit</code></pre><pre><code class="language-none">Laplacians.llsPurge</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localBlockFlow" href="#Laplacians.localBlockFlow"><code>Laplacians.localBlockFlow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute block flow between s and t</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localFlow" href="#Laplacians.localFlow"><code>Laplacians.localFlow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The LocalFlow function, from the Orecchia-Zhu paper </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localImprove" href="#Laplacians.localImprove"><code>Laplacians.localImprove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">localImprove{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, A::Array{Int64,1}; epsSigma=-1.0, err=1e-10, maxSize = max(G.n, G.m)</code></pre><p>The LocalImprove function, from the Orrechia-Zhu paper. Given a graph and an initial set, finds a set of smaller conductance based on the starting set using a localized version of max-flow.</p><p>Small discussion: When adding in the neighbors of the initial component, if the resulting  conductance is worse than the initial one,  the algorithm will add more and more vertices until hitting a better conductance. However, if we fix a certain  maximum size for our component,  it might be the case that this new conductance will always be worse than what we had initially. Thus, if we run the algorithm with a small maxSize,  our initial conductance might be the best solution we can raech.</p><ul><li>G is the given graph, A is the initial set </li><li>epsSigma is a measure of the quality of the returning set (the smaller the better). It&#39;s defaulted to volume(A) / volume(V - A)</li><li>err is the numerical error considered throughout the algorithm. It&#39;s defaulted to 1e-10</li><li>maxSize is the maximum allowed size for the flow graph at any iteration of the algorithm. It&#39;s defaulted to |V|</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.mapweight" href="#Laplacians.mapweight"><code>Laplacians.mapweight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">b = mapweight(a, x-&gt;rand())</code></pre><p>Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write.</p></div></div></section><pre><code class="language-none">Laplacians.matToTree</code></pre><pre><code class="language-none">Laplacians.matToTreeDepth</code></pre><pre><code class="language-none">Laplacians.match_walk</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.maxflow" href="#Laplacians.maxflow"><code>Laplacians.maxflow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>implementation of Dinic&#39;s algorithm. computes the maximum flow and min-cut in G between s and t    we consider the adjacency matrix to be the capacity matrix </p></div></div></section><pre><code class="language-none">Laplacians.moduloNext</code></pre><pre><code class="language-none">Laplacians.nbri</code></pre><pre><code class="language-none">Laplacians.nbrs</code></pre><pre><code class="language-none">Laplacians.nullSolver</code></pre><pre><code class="language-none">Laplacians.pathFromParents</code></pre><pre><code class="language-none">Laplacians.pathGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.path_graph" href="#Laplacians.path_graph"><code>Laplacians.path_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = path_graph(n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.path_graph_ijv" href="#Laplacians.path_graph_ijv"><code>Laplacians.path_graph_ijv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ijv = path_graph_ijv(n::Int64)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcg" href="#Laplacians.pcg"><code>Laplacians.pcg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = pcg(mat, b, pre; tol, maxits, maxtime, verbose, pcgIts, stag_test)`</code></pre><p>solves a symmetric linear system using preconditioner <code>pre</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pre</code> can be a function or a matrix.  If a matrix, a function to solve it is created with cholFact.</li><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li><li><code>stag_test=k</code> stops the code if rho[it] &gt; (1-1/k) rho[it-k].  Set to 0 to deactivate.</li></ul></div></div></section><pre><code class="language-none">Laplacians.pcgBLAS</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcgLapSolver" href="#Laplacians.pcgLapSolver"><code>Laplacians.pcgLapSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = pcgLapSolver(A, B; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses pcg to solve Laplacian systems in <code>A</code> Specialized for the case when the preconditioner the Laplacian matrix of <code>B</code>. It solves the preconditioner by Cholesky Factorization.</p></div></div></section><pre><code class="language-none">Laplacians.pcgSlow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcgSolver" href="#Laplacians.pcgSolver"><code>Laplacians.pcgSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = pcgSolver(mat, pre; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system using preconditioner <code>pre</code>. The parameters are as described in pcg.</p></div></div></section><pre><code class="language-none">Laplacians.plotGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.plot_graph" href="#Laplacians.plot_graph"><code>Laplacians.plot_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">plot_graph(gr,x,y;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y)</p></div></div><div><div><pre><code class="language-none">plot_graph(gr,x,y,z;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y,z)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.power" href="#Laplacians.power"><code>Laplacians.power</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ap = power(a::SparseMatrixCSC, k::Int)</code></pre><p>Returns the kth power of a.</p></div></div></section><pre><code class="language-none">Laplacians.powerIteration</code></pre><pre><code class="language-none">Laplacians.prefAttach</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pref_attach" href="#Laplacians.pref_attach"><code>Laplacians.pref_attach</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = pref_attach(n::Int64, k::Int64, p::Float64; ver=Vcur)</code></pre><p>A preferential attachment graph in which each vertex has k edges to those that come before.  These are chosen with probability p to be from a random vertex, and with probability 1-p to come from the endpoint of a random edge. It begins with a k-clique on the first k+1 vertices.</p></div></div></section><pre><code class="language-none">Laplacians.pref_attach_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.prim" href="#Laplacians.prim"><code>Laplacians.prim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>prim(mat::SparseMatrixCSC; kind=:max)</code> Compute a maximum spanning tree of the matrix <code>mat</code>.   If <code>kind=:min</code>, computes a minimum spanning tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.print_ll_col" href="#Laplacians.print_ll_col"><code>Laplacians.print_ll_col</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Print a column in an LLmatp matrix.   This is here for diagnostics.</p></div></div><div><div><p>Print a column in an LLMatOrd matrix.   This is here for diagnostics.</p></div></div></section><pre><code class="language-none">Laplacians.printijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.prn" href="#Laplacians.prn"><code>Laplacians.prn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>prn{Tv, Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, phi::Float64, b::Int64)</p><p>The PageRank-Nibble cutting algorithm from the Anderson/Chung/Lang paper</p><p>s is a set of starting vertices, phi is a constant in (0, 1], and b is an integer in [1, [log m]]</p><p>phi is a bound on the quality of the conductance of the cut - the smaller the phi, the higher the quality.  b is used to handle precision throughout the algorithm - the higher the b, the greater the precision.</p></div></div></section><pre><code class="language-none">Laplacians.productGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.product_graph" href="#Laplacians.product_graph"><code>Laplacians.product_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">aprod = productGraph(a0, a1)</code></pre><p>The Cartesian product of two graphs.  When applied to two paths, it gives a grid.</p></div></div></section><pre><code class="language-none">Laplacians.pull!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pure_random_graph" href="#Laplacians.pure_random_graph"><code>Laplacians.pure_random_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = pure_random_graph(n::Integer; verbose=false, ver=Vcur)</code></pre><p>Generate a random graph with n vertices from one of our natural distributions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pure_random_ijv" href="#Laplacians.pure_random_ijv"><code>Laplacians.pure_random_ijv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a = pure_random_ijv(n::Integer; verbose=false, prefix=&quot;&quot;, ver=Vcur)</code></pre><p>Chooses among path<em>graph, ring</em>graph, grid<em>graph, complete</em>binary<em>tree, rand</em>gen<em>ring, grown</em>graph and ErdosRenyiClusterFix. It can produce a disconnected graph. For code that always produces a connected graph (and is the same as with Julia v0.6, use pure<em>random</em>ijv_v6)</p></div></div></section><pre><code class="language-none">Laplacians.pure_random_ijv_v6</code></pre><pre><code class="language-none">Laplacians.pure_random_ijv_v7</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pushSpeedResult!" href="#Laplacians.pushSpeedResult!"><code>Laplacians.pushSpeedResult!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ret</code> is the answer returned by a speed test. This pushed it into the dictionary on which we are storing the tests.</p></div></div></section><pre><code class="language-none">Laplacians.randGenRing</code></pre><pre><code class="language-none">Laplacians.randMatching</code></pre><pre><code class="language-none">Laplacians.randRegular</code></pre><pre><code class="language-none">Laplacians.randSet</code></pre><pre><code class="language-none">Laplacians.randWeight</code></pre><pre><code class="language-none">Laplacians.randWeightSub</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_gen_ring" href="#Laplacians.rand_gen_ring"><code>Laplacians.rand_gen_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = rand_gen_ring(n, k; verbose = false, ver=Vcur)</code></pre><p>A random generalized ring graph of degree k. Gens always contains 1, and the other k-1 edge types are chosen from an exponential distribution</p></div></div></section><pre><code class="language-none">Laplacians.rand_gen_ring_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_matching" href="#Laplacians.rand_matching"><code>Laplacians.rand_matching</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = rand_matching(n::Integer; ver=Vcur)</code></pre><p>A random matching on n vertices</p></div></div></section><pre><code class="language-none">Laplacians.rand_matching_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_regular" href="#Laplacians.rand_regular"><code>Laplacians.rand_regular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = rand_regular(n, k; ver=Vcur)</code></pre><p>A sum of k random matchings on n vertices</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_regular_bipartite" href="#Laplacians.rand_regular_bipartite"><code>Laplacians.rand_regular_bipartite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a = rand_regular_bipartite(n,k)</code></pre><p>Random k-regular bipartite graph between two sets of n vertices. No repeat edges, so can take a long time to build of k is close to n.</p><p>Returns a (possibly) asymmetric matrix that contains the upper-right block.</p></div></div></section><pre><code class="language-none">Laplacians.rand_regular_ijv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_weight" href="#Laplacians.rand_weight"><code>Laplacians.rand_weight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = randWeight(graph; ver=Vcur)</code></pre><p>Applies one of a number of random weighting schemes to the edges of the graph</p></div></div></section><pre><code class="language-none">Laplacians.rand_weight_sub</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.randishKruskal" href="#Laplacians.randishKruskal"><code>Laplacians.randishKruskal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tree = randishKruskal(A)</code></pre><p>A heuristic for computing low-stretch spanning trees.  Where Kruskal&#39;s MST algorithm adds edges in order of weight, this algorithm adds them at random with probability proportional to their weight.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.randishPrim" href="#Laplacians.randishPrim"><code>Laplacians.randishPrim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tree = randishPrim(A)</code></pre><p>A heuristic for computing low-stretch spanning trees.  Where Prim&#39;s MST algorithm grows a cluster by always adding the edge on the boundary of maximum weight, this algorithm adds a boundary edge with probability proportional to its weight.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Random.randperm" href="#Random.randperm"><code>Random.randperm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = randperm(mat::AbstractMatrix)
        randperm(f::Expr)</code></pre><p>Randomly permutes the vertex indices</p></div></div></section><pre><code class="language-none">Laplacians.randperm_ver!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.readIJ" href="#Laplacians.readIJ"><code>Laplacians.readIJ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>To read a simple edge list, each line being an (i, j) pair</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.readIJV" href="#Laplacians.readIJV"><code>Laplacians.readIJV</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>To read a simple edge list, each line being an (i, j, v) pair. The parens should not be there in the format, just commas separating. To generate this format in Matlab, you just need to be careful to write the vertex indices with sufficient precision.  For example, you can do this</p><pre><code class="language-none">&gt;&gt; [ai,aj,av] = find(triu(a));
&gt;&gt; dlmwrite(&#39;graph.txt&#39;,[ai,aj,av],&#39;precision&#39;,9);</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.refineCut" href="#Laplacians.refineCut"><code>Laplacians.refineCut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Modify a cluster by adding or removing vertices by picking at each step 
the vertex that has the maximum value of (Deg_external - Deg_Internal).
Each vertex can be added in/removed only once.</code></pre></div></div></section><pre><code class="language-none">Laplacians.regular_bipartite_matching</code></pre><pre><code class="language-none">Laplacians.remove!</code></pre><pre><code class="language-none">Laplacians.reset!</code></pre><pre><code class="language-none">Laplacians.reusableIntMap</code></pre><pre><code class="language-none">Laplacians.ringGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ring_graph" href="#Laplacians.ring_graph"><code>Laplacians.ring_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = ring_graph(n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ring_graph_ijv" href="#Laplacians.ring_graph_ijv"><code>Laplacians.ring_graph_ijv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ijv = ring_graph_ijv(n)</code></pre></div></div></section><pre><code class="language-none">Laplacians.sample</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sampleByWeight" href="#Laplacians.sampleByWeight"><code>Laplacians.sampleByWeight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ind = sampleByWeight(wt; ver=Vcur)</code></pre><p>sample an index with probability proportional to its weight given here</p></div></div></section><pre><code class="language-none">Laplacians.sampleMany</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sddmWrapLap" href="#Laplacians.sddmWrapLap"><code>Laplacians.sddmWrapLap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = sddmWrapLap(lapSolver, sddm::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Uses a <code>lapSolver</code> to solve systems of linear equations in sddm matrices.</p></div></div></section><pre><code class="language-none">Laplacians.semiWtedChimera</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.semiwted_chimera" href="#Laplacians.semiwted_chimera"><code>Laplacians.semiwted_chimera</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = semiwted_chimera(n::Integer; verbose=false, ver=Vcur)</code></pre><p>A Chimera graph with some weights.  The weights just appear when graphs are combined. For more interesting weights, use <code>wted_chimera</code></p></div></div></section><pre><code class="language-none">Laplacians.semiwted_chimera_ijv</code></pre><pre><code class="language-none">Laplacians.semiwted_chimera_ijv_v6</code></pre><pre><code class="language-none">Laplacians.semiwted_chimera_ijv_v7</code></pre><pre><code class="language-none">Laplacians.set!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.setValue" href="#Laplacians.setValue"><code>Laplacians.setValue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Sets the value of a certain edge in a sparse graph; value can be 0 without the edges dissapearing </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.shortIntGraph" href="#Laplacians.shortIntGraph"><code>Laplacians.shortIntGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = shortIntGraph(a::SparseMatrixCSC)</code></pre><p>Convert the indices in a graph to 32-bit ints. This takes less storage, but does not speed up much.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.shortestPathTree" href="#Laplacians.shortestPathTree"><code>Laplacians.shortestPathTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the shortest path tree, and returns it as a sparse matrix. Treats edge weights as reciprocals of lengths. For example:</p><pre><code class="language-julia">a = [0 2 1; 2 0 3; 1 3 0]
tr = full(shortestPathTree(sparse(a),1))

3x3 Array{Float64,2}:
 0.0  2.0  0.0
 2.0  0.0  3.0
 0.0  3.0  0.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.shortestPaths" href="#Laplacians.shortestPaths"><code>Laplacians.shortestPaths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the lenghts of shortest paths from <code>start</code>. Returns both a vector of the lenghts, and the parent array in the shortest path tree.</p><p>This algorithm treats edge weights as reciprocals of distances. DOC BETTER</p></div></div></section><pre><code class="language-none">Laplacians.sortIJVind</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sortSet" href="#Laplacians.sortSet"><code>Laplacians.sortSet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a set of integers, <code>set</code> between 1 and n, return a sorted version of them</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sparsify" href="#Laplacians.sparsify"><code>Laplacians.sparsify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">as = sparsify(a; ep=0.5)</code></pre><p>Apply Spielman-Srivastava sparsification: sampling by effective resistances. <code>ep</code> should be less than 1.</p></div></div></section><pre><code class="language-none">Laplacians.spectralCoords</code></pre><pre><code class="language-none">Laplacians.spectralDrawing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.spectral_coords" href="#Laplacians.spectral_coords"><code>Laplacians.spectral_coords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spectral_coords(a)</code></pre><p>Computes the spectral coordinates of a graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.spectral_drawing" href="#Laplacians.spectral_drawing"><code>Laplacians.spectral_drawing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spectral_drawing(a)</code></pre><p>Computes spectral coordinates, and then uses plotGraph to draw</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.speedTestLapSolvers" href="#Laplacians.speedTestLapSolvers"><code>Laplacians.speedTestLapSolvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function speedTestLapSolvers{Tv,Ti}(solvers, dic, a::SparseMatrixCSC{Tv,Ti}, b::Array{Tv,1}; tol::Real=1e-2, maxits=Inf, maxtime=Inf, verbose=false)</code></pre><p>Runs many Laplacians solvers.  Puts the build and solve time results into a dictionary dic.  It would be easiest to look at it via DataFrame(dic).  Returns the answer from the last solver.  <code>solvers</code> should be an array of <code>SolverTest</code>.</p></div></div></section><pre><code class="language-none">Laplacians.stretchSample</code></pre><pre><code class="language-none">Laplacians.subMean!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.submatrixCSC" href="#Laplacians.submatrixCSC"><code>Laplacians.submatrixCSC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For a the submatrix of a with the entries of ijv indexed by list.  The list must be sorted. This is equivalent to</p><pre><code class="language-none">(ai,aj,av) = findnz(a)
sparse(ai[list],aj[list],av[list],a.m,a.n)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.subsampleEdges" href="#Laplacians.subsampleEdges"><code>Laplacians.subsampleEdges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = subsampleEdges(a::SparseMatrixCSC, p::Float64)</code></pre><p>Create a new graph from the old, but keeping edge edge with probability <code>p</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.support" href="#Laplacians.support"><code>Laplacians.support</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sup12, sup21 = support(graph1, graph2; tol=1e-5)</code></pre><p>Computes the support of graph1 wrt graph2, and the other way around. It is randomized, so you might want to run it again if you don&#39;t trust the answers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.symPermuteCSC" href="#Laplacians.symPermuteCSC"><code>Laplacians.symPermuteCSC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Permute the rows and columns of a symmetric matrix, a little faster than the default routine in Julia.  It basically does a radix sort on rows than columns. It does require <code>a</code> to be symmetrix.  But, the same ideas could probably speed up many sparse matrix routines. <code>sympermute(a, perm)</code> is the same as <code>a[perm,perm]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.symTransposeCSC" href="#Laplacians.symTransposeCSC"><code>Laplacians.symTransposeCSC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the transpose of a matrix with symmetric nonzero structure</p></div></div></section><pre><code class="language-none">Laplacians.tarjanStretch</code></pre><pre><code class="language-none">Laplacians.tarjanStretchSub</code></pre><pre><code class="language-none">Laplacians.testId</code></pre><pre><code class="language-none">Laplacians.testSolver</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.testZeroDiag" href="#Laplacians.testZeroDiag"><code>Laplacians.testZeroDiag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">testZeroDiag(a)</code></pre><p>Returns true if <code>a</code> has zero diagonal, false otherwise</p></div></div></section><pre><code class="language-none">Laplacians.test_latin_square</code></pre><pre><code class="language-none">Laplacians.test_regular_bipartite</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.thicken" href="#Laplacians.thicken"><code>Laplacians.thicken</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_new = thicken(A,k)</code></pre><p>Create a new graph with at least k times as many edges as A By connecting nodes with common neighbors at random. When this stops working (not enough new edges), repeat on the most recently produced graph. If k is too big, it is decreased so the average degree will not be pushed much above n/2.</p><p>When called without k, it just runs thicken_once.</p><p>For example:</p><pre><code class="language-none">a = grid2(5)
a2 = thicken(a,3)
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div></div></section><pre><code class="language-none">Laplacians.thickenOnce</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.thicken_once" href="#Laplacians.thicken_once"><code>Laplacians.thicken_once</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_new = thicken_once(a)</code></pre><p>Creates one edge for every vertex in a of degree &gt; 1 by connecting two of its random neighbors. To use this to thicken a, return unweight(a + a_new).</p><pre><code class="language-none">a = grid2(5)
a2 = unweight(a + thicken_once(a))
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div></div></section><pre><code class="language-none">Laplacians.toposort</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.treeDepthDFS" href="#Laplacians.treeDepthDFS"><code>Laplacians.treeDepthDFS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the vector of depths in a tree that is in DFS order, <em>with the root at the first position, and the leaves at the end</em></p></div></div></section><pre><code class="language-none">Laplacians.twoLift</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.two_lift" href="#Laplacians.two_lift"><code>Laplacians.two_lift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = two_lift(a, flip::AbstractArray{Bool,1})
graph = two_lift(a)
graph = two_lift(a, k::Integer)</code></pre><p>Creats a 2-lift of a.  <code>flip</code> is a boolean indicating which edges cross. In the third version, k is the number of edges that cross.</p></div></div></section><pre><code class="language-none">Laplacians.uniformWeight</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.uniformWeight!" href="#Laplacians.uniformWeight!"><code>Laplacians.uniformWeight!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uniformWeight!(a)</code></pre><p>Set the weight of every edge to random uniform [0,1]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.uniformWeight_ver" href="#Laplacians.uniformWeight_ver"><code>Laplacians.uniformWeight_ver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wted = uniformWeight(unwted)</code></pre><p>Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.</p></div></div></section><pre><code class="language-none">Laplacians.uniformWeight_ver!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.unweight" href="#Laplacians.unweight"><code>Laplacians.unweight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wt1 = unweight(a)</code></pre><p>Create a new graph in that is the same as the original, but with all edge weights 1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.unweight!" href="#Laplacians.unweight!"><code>Laplacians.unweight!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unweight!(a)</code></pre><p>Change the weight of every edge in a to 1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.vecToComps" href="#Laplacians.vecToComps"><code>Laplacians.vecToComps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This turns a component vector, like that generated by components, into an array of arrays of indices of vertices in each component.  For example,</p><pre><code class="language-julia">comps = vecToComps(c)

3-element Array{Array{Int64,1},1}:
 [1,2,3,4,6,7,8]
 [5,10]
 [9]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wdeg" href="#Laplacians.wdeg"><code>Laplacians.wdeg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Finds the weighted degree of a vertex in the graph </p></div></div></section><pre><code class="language-none">Laplacians.weighti</code></pre><pre><code class="language-none">Laplacians.weights</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapCapture" href="#Laplacians.wrapCapture"><code>Laplacians.wrapCapture</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = wrapCapture(solver::Function, mats, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>This wraps a solver so that we can capture all the matrices that it solves and all the right-hand-sides. Those are pushed into the arrays <code>mats</code> and <code>rhss</code>. For example</p><pre><code class="language-julia">julia&gt; mats = []
julia&gt; rhss = []
julia&gt; solver = wrapCapture(approxchol_lap, mats, rhss)
julia&gt; a = chimera(10)
julia&gt; f = solver(a);
julia&gt; size(mats[1])
(10,10)
julia&gt; b = randn(10)
julia&gt; x = f(b);
julia&gt; rhss
1-element Array{Any,1}:
 [0.404962,-0.827718,0.704616,-0.403223,0.204891,-0.505589,0.907015,1.90266,-0.438115,0.0464351]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapCaptureRhs" href="#Laplacians.wrapCaptureRhs"><code>Laplacians.wrapCaptureRhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = wrapCaptureRhs(sola::Function, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Captures all the right-hand-sides that are passed to the solver <code>sola</code>.  It pushes them into an array called rhhs. For example</p><pre><code class="language-julia">julia&gt; rhss = []
julia&gt; a = wted_chimera(100)
julia&gt; sola = approxchol_lap(a)
julia&gt; wrappedSolver = wrapCaptureRhs(sola,rhss)
julia&gt; b = randn(100)
julia&gt; x = wrappedSolver(b,verbose=true)

PCG BLAS stopped after: 0.0 seconds and 11 iterations with relative error 3.160275810360986e-7.

julia&gt; length(rhss[1])

100</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapInterface" href="#Laplacians.wrapInterface"><code>Laplacians.wrapInterface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solveA = wrapInterface(solver::Function, A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)
solverConstructor = wrapInterface(A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)</code></pre><p>Returns a function that discards <code>tol</code>, <code>maxits</code>, <code>maxtime</code> and <code>verbose</code>, sets <code>pcgIts</code> to 0 (because it might not be using pcg), and passes whatever <code>params</code> are left to the solver.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; a = randn(5,5);
julia&gt; a = a * a&#39;;
julia&gt; solvea = wrapInterface(X-&gt;cholesky(X,Val(true)), a, maxits=100, verbose=true);
julia&gt; b = randn(5,1);
julia&gt; norm(a*solvea(b, verbose=false)-b)
1.575705319704736e-14

julia&gt; f = wrapInterface(X-&gt;cholesky(X,Val(true)))
julia&gt; solvea = f(a, maxits=1000, maxtime = 1)
julia&gt; norm(a*solvea(b, verbose=false, maxtime = 10)-b)
1.575705319704736e-14</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.writeIJV" href="#Laplacians.writeIJV"><code>Laplacians.writeIJV</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Writes the upper portion of a matrix in ijv format, one row for each edge, separated by commas.  Only writes the upper triangular portion. The result can be read from Matlab like this:</p><pre><code class="language-none">&gt;&gt; dl = dlmread(&#39;graph.txt&#39;);
&gt;&gt; a = sparse(dl(:,1),dl(:,2),dl(:,3));
&gt;&gt; n = max(size(a))
&gt;&gt; a(n,n) = 0;
&gt;&gt; a = a + a&#39;;</code></pre></div></div></section><pre><code class="language-none">Laplacians.wtedChimera</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wtedEdgeVertexMat" href="#Laplacians.wtedEdgeVertexMat"><code>Laplacians.wtedEdgeVertexMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">U = wtedEdgeVertexMat(a)</code></pre><p>The signed and weighted edge-vertex adjacency matrix, so U&#39;*U = L</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wted_chimera" href="#Laplacians.wted_chimera"><code>Laplacians.wted_chimera</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph = wted_chimera(n::Integer, k::Integer; verbose=false, ver=Vcur)</code></pre><p>Builds the kth wted chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p></div></div><div><div><pre><code class="language-none">graph = wted_chimera(n::Integer)</code></pre><p>Generate a chimera, and then apply a random weighting scheme</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
