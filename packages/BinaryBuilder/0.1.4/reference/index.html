<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · BinaryBuilder.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BinaryBuilder.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../build_tips/">Building Packages</a></li><li><a class="toctext" href="../FAQ/">FAQ</a></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../rootfs/">RootFS</a></li><li><a class="toctext" href="../environment_variables/">Environment Variables</a></li><li><a class="toctext" href="../tricksy_gotchas/">Tricksy Gotchas</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Internals</li><li><a href>Reference</a></li></ul></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-reference-1" href="#API-reference-1">API reference</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.DockerRunner" href="#BinaryBuilder.DockerRunner"><code>BinaryBuilder.DockerRunner</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DockerRunner</code></pre><p>A <code>DockerRunner</code> represents Elliot&#39;s bowing of his head to the inevitability that the QemuRunner just isn&#39;t ready for primetime yet, and he needs something to use while he&#39;s on the plane to JuliaCon to whip up said JuliaCon presentation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.QemuRunner" href="#BinaryBuilder.QemuRunner"><code>BinaryBuilder.QemuRunner</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">QemuRunner</code></pre><p>A <code>QemuRunner</code> represents an &quot;execution context&quot;, an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use <code>run()</code> to actually run commands within the <code>QemuRunner</code>, and <code>runshell()</code> as a quick way to get an interactive shell within the crossbuild environment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.UserNSRunner" href="#BinaryBuilder.UserNSRunner"><code>BinaryBuilder.UserNSRunner</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UserNSRunner</code></pre><p>A <code>UserNSRunner</code> represents an &quot;execution context&quot;, an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use <code>run()</code> to actually run commands within the <code>UserNSRunner</code>, and <code>runshell()</code> as a quick way to get an interactive shell within the crossbuild environment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.WizardState" href="#BinaryBuilder.WizardState"><code>BinaryBuilder.WizardState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WizardState</code></pre><p>Building large dependencies can take a lot of time. This state object captures all relevant state of this function. It can be passed back to the function to resume where we left off. This can aid debugging when code changes are necessary.  It also holds all necessary metadata such as input/output streams.</p></div></div></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.audit-Tuple{Prefix}" href="#BinaryBuilder.audit-Tuple{Prefix}"><code>BinaryBuilder.audit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">audit(prefix::Prefix; platform::Platform = platform_key_abi();
                      verbose::Bool = false,
                      silent::Bool = false,
                      autofix::Bool = false)</code></pre><p>Audits a prefix to attempt to find deployability issues with the binary objects that have been installed within.  This auditing will check for relocatability issues such as dependencies on libraries outside of the current <code>prefix</code>, usage of advanced instruction sets such as AVX2 that may not be usable on many platforms, linkage against newer glibc symbols, etc...</p><p>This method is still a work in progress, only some of the above list is actually implemented, be sure to actually inspect <code>Auditor.jl</code> to see what is and is not currently in the realm of fantasy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.autobuild-Tuple{AbstractString,AbstractString,VersionNumber,Array{T,1} where T,AbstractString,Array{T,1} where T,Function,Array{T,1} where T}" href="#BinaryBuilder.autobuild-Tuple{AbstractString,AbstractString,VersionNumber,Array{T,1} where T,AbstractString,Array{T,1} where T,Function,Array{T,1} where T}"><code>BinaryBuilder.autobuild</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">autobuild(dir::AbstractString, src_name::AbstractString,
          src_version::VersionNumber, sources::Vector,
          script::AbstractString, platforms::Vector,
          products::Function, dependencies::Vector;
          verbose::Bool = true, kwargs...)</code></pre><p>Runs the boiler plate code to download, build, and package a source package for a list of platforms.  <code>src_name</code> represents the name of the source package being built (and will set the name of the built tarballs), <code>platforms</code> is a list of platforms to build for, <code>sources</code> is a list of tuples giving <code>(url, hash)</code> of all sources to download and unpack before building begins, <code>script</code> is a string representing a <code>bash</code> script to run to build the desired products, which are listed as <code>Product</code> objects within the vector returned by the <code>products</code> function. <code>dependencies</code> gives a list of dependencies that provide <code>build.jl</code> files that should be installed before building begins to allow this build process to depend on the results of another build process. Setting <code>debug</code> to <code>true</code> will cause a failed build to drop into an interactive shell so that the build can be inspected easily.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.build_tarballs-NTuple{8,Any}" href="#BinaryBuilder.build_tarballs-NTuple{8,Any}"><code>BinaryBuilder.build_tarballs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build_tarballs(ARGS, src_name, src_version, sources, script, platforms,
               products, dependencies; kwargs...)</code></pre><p>This should be the top-level function called from a <code>build_tarballs.jl</code> file. It takes in the information baked into a <code>build_tarballs.jl</code> file such as the <code>sources</code> to download, the <code>products</code> to build, etc... and will automatically download, build and package the tarballs, generating a <code>build.jl</code> file when appropriate.  Note that <code>ARGS</code> should be the top-level Julia <code>ARGS</code> command- line arguments object.  This function does some rudimentary parsing of the <code>ARGS</code>, call it with <code>--help</code> in the <code>ARGS</code> to see what it can do.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.collapse_symlinks-Tuple{Array{String,1}}" href="#BinaryBuilder.collapse_symlinks-Tuple{Array{String,1}}"><code>BinaryBuilder.collapse_symlinks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">collapse_symlinks(files::Vector{String})</code></pre><p>Given a list of files, prune those that are symlinks pointing to other files within the list.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.collect_files" href="#BinaryBuilder.collect_files"><code>BinaryBuilder.collect_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect_files(path::AbstractString, predicate::Function = f -&gt; true)</code></pre><p>Find all files that satisfy <code>predicate()</code> when the full path to that file is passed in, returning the list of file paths.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.expand_gcc_versions-Tuple{Platform}" href="#BinaryBuilder.expand_gcc_versions-Tuple{Platform}"><code>BinaryBuilder.expand_gcc_versions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">expand_gcc_versions(p::Platform)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>gcc_version</code> member of the <code>CompilerABI</code> struct within the <code>Platform</code>.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given <code>Platform</code> already specifies a GCC version (as opposed to <code>:gcc_any</code>) only that <code>Platform</code> is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.product_hashes_from_github_release-Tuple{AbstractString,AbstractString}" href="#BinaryBuilder.product_hashes_from_github_release-Tuple{AbstractString,AbstractString}"><code>BinaryBuilder.product_hashes_from_github_release</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If you have a sharded build on Github, it would be nice if we could get an auto-generated <code>build.jl</code> just like if we build serially.  This function eases the pain by reconstructing it from a releases page.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.supported_platforms-Tuple{}" href="#BinaryBuilder.supported_platforms-Tuple{}"><code>BinaryBuilder.supported_platforms</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">supported_platforms()</code></pre><p>Return the list of supported platforms as an array of <code>Platform</code>s.  These are the platforms we officially support building for, if you see a mapping in <code>get_shard_hash()</code> that isn&#39;t represented here, it&#39;s probably because that platform is still considered &quot;in beta&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P&lt;:Platform" href="#BinaryBuilder.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P&lt;:Platform"><code>BinaryBuilder.abi_agnostic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">abi_agnostic(p::Platform)</code></pre><p>Strip out the CompilerABI portion of a Platform, making it &quot;ABI agnostic&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle,Platform}" href="#BinaryBuilder.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle,Platform}"><code>BinaryBuilder.analyze_instruction_set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">analyze_instruction_set(oh::ObjectHandle, platform::Platform; verbose::Bool = false)</code></pre><p>Analyze the instructions within the binary located at the given path for which minimum instruction set it requires, taking note of groups of instruction sets used such as <code>avx</code>, <code>sse4.2</code>, <code>i486</code>, etc....</p><p>Some binary files (such as libopenblas) contain multiple versions of functions, internally determining which version to call by using the <code>cpuid</code> instruction to determine processor support.  In an effort to detect this, we make note of any usage of the <code>cpuid</code> instruction, disabling our minimum instruction set calculations if such an instruction is found, and notifying the user of this if <code>verbose</code> is set to <code>true</code>.</p><p>Note that this function only really makes sense for x86/x64 binaries.  Don&#39;t run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.canonicalize_file_url-Tuple{Any}" href="#BinaryBuilder.canonicalize_file_url-Tuple{Any}"><code>BinaryBuilder.canonicalize_file_url</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Canonicalize URL to a file within a GitHub repo</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.canonicalize_source_url-Tuple{Any}" href="#BinaryBuilder.canonicalize_source_url-Tuple{Any}"><code>BinaryBuilder.canonicalize_source_url</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Canonicalize a GitHub repository URL</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.change_script!-Tuple{Any,Any}" href="#BinaryBuilder.change_script!-Tuple{Any,Any}"><code>BinaryBuilder.change_script!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Change the script. This will invalidate all platforms to make sure we later
verify that they still build with the new script.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.choose_shards-Tuple{Platform}" href="#BinaryBuilder.choose_shards-Tuple{Platform}"><code>BinaryBuilder.choose_shards</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">choose_shards(p::Platform; rootfs_build, bcs_build, GCC_builds,
                           LLVM_builds, archive_type)</code></pre><p>This method chooses, given a <code>Platform</code>, which shards to download, extract and mount, returning a list of <code>CompilerShard</code> objects.  At the moment, this always consists of four shards, but that may not always be the case.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.chown_cleanup-Tuple{BinaryBuilder.DockerRunner}" href="#BinaryBuilder.chown_cleanup-Tuple{BinaryBuilder.DockerRunner}"><code>BinaryBuilder.chown_cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">chown_cleanup(dr::DockerRunner)</code></pre><p>On Linux, the user id inside of the docker container doesn&#39;t correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to <code>chown -R $(id -u):$(id -g) $prefix</code>, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.dir_name-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.dir_name-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.dir_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dir_name(cs::CompilerShard)</code></pre><p>Return a &quot;directory name&quot; for a compiler shard; used by e.g. <code>extraction_path()</code> or <code>mount_path()</code>, to create names like &quot;Rootfs.v2018.08.27-x86_64-linux-gnu&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.download_all_shards-Tuple{}" href="#BinaryBuilder.download_all_shards-Tuple{}"><code>BinaryBuilder.download_all_shards</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">download_all_shards(; verbose::Bool=false)</code></pre><p>Helper function to download all (.tar.gz AND .squashfs) shards, so that no matter what happens, you don&#39;t need an internet connection to build your precious, precious binaries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.download_path-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.download_path-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.download_path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">download_path(cs::CompilerShard)</code></pre><p>Return the location this shard will be downloaded to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.download_source-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.download_source-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.download_source</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">download_source(state::WizardState)</code></pre><p>Ask the user where the source code is coming from, then download and record the relevant parameters, returning the source <code>url</code>, the local <code>path</code> it is stored at after download, and a <code>hash</code> identifying the version of the code. In the case of a <code>git</code> source URL, the <code>hash</code> will be a git treeish identifying the exact commit used to build the code, in the case of a tarball, it is the <code>sha256</code> hash of the tarball itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.edit_script-Tuple{BinaryBuilder.WizardState,AbstractString}" href="#BinaryBuilder.edit_script-Tuple{BinaryBuilder.WizardState,AbstractString}"><code>BinaryBuilder.edit_script</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">edit_script(state::WizardState, script::AbstractString)</code></pre><p>For consistency (and security), use the sandbox for editing a script, launching <code>vi</code> within an interactive session to edit a buildscript.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.filename-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.filename-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filename(cs::CompilerShard)</code></pre><p>Return the filename of this shard.  Used by e.g. <code>url()</code> or <code>download_path()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.filter_object_files-Tuple{Any}" href="#BinaryBuilder.filter_object_files-Tuple{Any}"><code>BinaryBuilder.filter_object_files</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filter_object_files(files)</code></pre><p>Given a list of files, filter out any that cannot be opened by <code>readmeta()</code> from <code>ObjectFile</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.getgid-Tuple{}" href="#BinaryBuilder.getgid-Tuple{}"><code>BinaryBuilder.getgid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getgid()</code></pre><p>Wrapper around libc&#39;s <code>getgid()</code> function</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.getuid-Tuple{}" href="#BinaryBuilder.getuid-Tuple{}"><code>BinaryBuilder.getuid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getuid()</code></pre><p>Wrapper around libc&#39;s <code>getuid()</code> function</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.hash-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.hash-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.hash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash(cs::CompilerShard)</code></pre><p>Return the integrity hash for this compiler shard, for ensuring it has been downloaded properly/has not been tampered with.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.import_docker_image-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.import_docker_image-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.import_docker_image</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">import_docker_image(rootfs::CompilerShard; verbose::Bool = false)</code></pre><p>Checks to see if the given rootfs has been imported into docker yet; if it hasn&#39;t, then do so so that we can run things like:</p><pre><code class="language-none">docker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash</code></pre><p>Which, after all, is the foundation upon which this whole doodad is built.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.init_git_config-Tuple{Any,Any}" href="#BinaryBuilder.init_git_config-Tuple{Any,Any}"><code>BinaryBuilder.init_git_config</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">init_git_config(repo, state)</code></pre><p>Ask the user for their username and password for a repository-local <code>.git/config</code> file.  This is used during an interactive wizard session.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.instruction_mnemonics-Tuple{AbstractString,Platform}" href="#BinaryBuilder.instruction_mnemonics-Tuple{AbstractString,Platform}"><code>BinaryBuilder.instruction_mnemonics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">instruction_mnemonics(path::AbstractString, platform::Platform)</code></pre><p>Dump a binary object with <code>objdump</code>, returning a list of instruction mnemonics for further analysis with <code>analyze_instruction_set()</code>.</p><p>Note that this function only really makes sense for x86/x64 binaries.  Don&#39;t run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.</p><p>This function returns the list of mnemonics as well as the counts of each, binned by the mapping defined within <code>instruction_categories</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.interactive_build-Tuple{BinaryBuilder.WizardState,Prefix,BinaryBuilder.Runner,AbstractString}" href="#BinaryBuilder.interactive_build-Tuple{BinaryBuilder.WizardState,Prefix,BinaryBuilder.Runner,AbstractString}"><code>BinaryBuilder.interactive_build</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interactive_build(state::WizardState, prefix::Prefix,
                  ur::Runner, build_path::AbstractString)

Runs the interactive shell for building, then captures bash history to save
reproducible steps for building this source. Shared between steps 3 and 5</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.is_ecryptfs-Tuple{AbstractString}" href="#BinaryBuilder.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilder.is_ecryptfs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_ecryptfs(path::AbstractString; verbose::Bool=false)</code></pre><p>Checks to see if the given <code>path</code> (or any parent directory) is placed upon an <code>ecryptfs</code> mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603</p><p>This method returns whether it is encrypted or not, and what mountpoint it used to make that decision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.is_for_platform-Tuple{ObjectFile.ObjectHandle,Platform}" href="#BinaryBuilder.is_for_platform-Tuple{ObjectFile.ObjectHandle,Platform}"><code>BinaryBuilder.is_for_platform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_for_platform(h::ObjectHandle, platform::Platform)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> refers to an object of the given <code>platform</code>; E.g. if the given <code>platform</code> is for AArch64 Linux, then <code>h</code> must be an <code>ELFHandle</code> with <code>h.header.e_machine</code> set to <code>ELF.EM_AARCH64</code>.</p><p>In particular, this method and <code>platform_for_object()</code> both exist because the latter is not smart enough to deal with <code>:glibc</code> and <code>:musl</code> yet.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.is_mounted-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.is_mounted-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.is_mounted</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_mounted(cs::CompilerShard)</code></pre><p>Return true if the given shard is mounted.  Uses <code>run()</code> so will error out if something goes awry.  Note that if you ask if a <code>.tar.gz</code> shard is mounted, this method will return true if the <code>.squashfs</code> version is mounted.  This is actually desirable, as we use this to see if we should unmount the <code>.squashfs</code> version before unpacking the <code>.tar.gz</code> version into the same place.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.map_target-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.map_target-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.map_target</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_target(cs::CompilerShard)</code></pre><p>Return the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.match_files-Tuple{BinaryBuilder.WizardState,Prefix,Platform,Array{T,1} where T}" href="#BinaryBuilder.match_files-Tuple{BinaryBuilder.WizardState,Prefix,Platform,Array{T,1} where T}"><code>BinaryBuilder.match_files</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">match_files(state::WizardState, prefix::Prefix,
            platform::Platform, files::Vector; silent::Bool = false)</code></pre><p>Inspects all binary files within a prefix, matching them with a given list of <code>files</code>, complaining if there are any files that are not properly matched and returning the set of normalized names that were not matched, or an empty set if all names were properly matched.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.minimum_instruction_set-Tuple{Dict,Bool}" href="#BinaryBuilder.minimum_instruction_set-Tuple{Dict,Bool}"><code>BinaryBuilder.minimum_instruction_set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">minimum_instruction_set(counts::Dict, is_64bit::Bool)</code></pre><p>This function returns the minimum instruction set required, depending on whether the object file being pointed to is a 32-bit or 64-bit one:</p><ul><li><p>For 32-bit object files, this returns one of [:pentium4, :prescott]</p></li><li><p>For 64-bit object files, this returns one of [:core2, :sandybridge, :haswell]</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.mount-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.mount-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.mount</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mount(cs::CompilerShard)</code></pre><p>Mount a compiler shard, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a <code>.squashfs</code> shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.mount_path-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.mount_path-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.mount_path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mount_path(cs::CompilerShard)</code></pre><p>Return the location this shard will be mounted to.  For <code>.tar.gz</code> shards, this is also the location it will be extracted to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.normalize_name-Tuple{AbstractString}" href="#BinaryBuilder.normalize_name-Tuple{AbstractString}"><code>BinaryBuilder.normalize_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">normalize_name(file::AbstractString)</code></pre><p>Given a filename, normalize it, stripping out extensions.  E.g. the file path <code>&quot;foo/libfoo.tar.gz&quot;</code> would get mapped to <code>&quot;libfoo&quot;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.pick_preferred_platform-Tuple{Any}" href="#BinaryBuilder.pick_preferred_platform-Tuple{Any}"><code>BinaryBuilder.pick_preferred_platform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Pick the first platform for use to run on. We prefer Linux x86_64 because
that&#39;s generally the host platform, so it&#39;s usually easiest. After that we
go by the following preferences:
    - OS (in order): Linux, Windows, OSX
    - Architecture: x86_64, i686, aarch64, powerpc64le, armv7l
    - The first remaining after this selection</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.platform_envs" href="#BinaryBuilder.platform_envs"><code>BinaryBuilder.platform_envs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">platform_envs(platform::Platform)</code></pre><p>Given a <code>platform</code>, generate a <code>Dict</code> mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are <code>PATH</code>, <code>CC</code>, <code>RANLIB</code>, as well as nonstandard things like <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.platform_for_object-Tuple{ObjectFile.ObjectHandle}" href="#BinaryBuilder.platform_for_object-Tuple{ObjectFile.ObjectHandle}"><code>BinaryBuilder.platform_for_object</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">platform_for_object(oh::ObjectHandle)</code></pre><p>Returns the platform the given <code>ObjectHandle</code> should run on.  E.g. if the given <code>ObjectHandle</code> is an x86<em>64 Linux ELF object, this function will return `Linux(:x86</em>64)<code>.  This function does not yet distinguish between different libc&#39;s such as</code>:glibc<code>and</code>:musl`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.prepare_shard-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.prepare_shard-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.prepare_shard</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare_shard(cs::CompilerShard; mount_squashfs = true, verbose = false)</code></pre><p>Download and mount the given compiler shard.  If it is a <code>.tar.gz</code> shard, it will be unpacked into the directory given by <code>mount_path(cs)</code>.  If it is a <code>.squashfs</code> shard, it will be mounted into the directory given by <code>mount_path(cs)</code> (unless <code>mount_squashfs</code> is set to <code>false</code>.  This is done by the QEMU runner, for instance, as it prefers to read the <code>.squashfs</code> files directly, so no need to try mounting things).</p><p>If it is a macOS shard, you must have accepted the Xcode license before it will be downloaded or mounted.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.print_autoconf_hint-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.print_autoconf_hint-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.print_autoconf_hint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">print_autoconf_hint(state::WizardState)</code></pre><p>Print a hint for projets that use autoconf to have a good <code>./configure</code> line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.provide_hints-Tuple{BinaryBuilder.WizardState,AbstractString}" href="#BinaryBuilder.provide_hints-Tuple{BinaryBuilder.WizardState,AbstractString}"><code>BinaryBuilder.provide_hints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">provide_hints(state::WizardState, path::AbstractString)</code></pre><p>Given an unpacked source directory, provide hints on how a user might go about building the binary bounty they so richly desire.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.rewrite_squashfs_uids-Tuple{Any,Any}" href="#BinaryBuilder.rewrite_squashfs_uids-Tuple{Any,Any}"><code>BinaryBuilder.rewrite_squashfs_uids</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rewrite_squashfs_uids(path, new_uid)</code></pre><p>In order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unpriviledged user. Unfortunately there is no mount-time option to do this for us. However, fortunately, squashfs is simple enough that if the id table is uncompressed, we can just manually patch the uids to be what we need. This functions performs this operation, by rewriting all uids/gids to new_uid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.runshell" href="#BinaryBuilder.runshell"><code>BinaryBuilder.runshell</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">runshell(platform::Platform = platform_key_abi())</code></pre><p>Launch an interactive shell session within the user namespace, with environment setup to target the given <code>platform</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.set_global_git_config-Tuple{Any,Any}" href="#BinaryBuilder.set_global_git_config-Tuple{Any,Any}"><code>BinaryBuilder.set_global_git_config</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_global_git_config(username, email)</code></pre><p>Sets up a <code>~/.gitconfig</code> with the given <code>username</code> and <code>email</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.setup_travis-Tuple{Any}" href="#BinaryBuilder.setup_travis-Tuple{Any}"><code>BinaryBuilder.setup_travis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Sets up travis for an existing repository</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.setup_workspace" href="#BinaryBuilder.setup_workspace"><code>BinaryBuilder.setup_workspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setup_workspace(build_path::String, src_paths::Vector,
                src_hashes::Vector, platform::Platform,
                extra_env::Dict{String, String};
                verbose::Bool = false, tee_stream::IO = stdout,
                downloads_dir = nothing)</code></pre><p>Sets up a workspace within <code>build_path</code>, creating the directory structure needed by further steps, unpacking the source within <code>build_path</code>, and defining the environment variables that will be defined within the sandbox environment.</p><p>This method returns the <code>Prefix</code> to install things into, and the runner that can be used to launch commands within this workspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.shard_mappings-Tuple{Array{BinaryBuilder.CompilerShard,1}}" href="#BinaryBuilder.shard_mappings-Tuple{Array{BinaryBuilder.CompilerShard,1}}"><code>BinaryBuilder.shard_mappings</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shard_mappings(shards::Vector{CompilerShard})</code></pre><p>Return the default mappings for a set of compiler shards</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step1-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.step1-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.step1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step1(state::WizardState)</code></pre><p>It all starts with a single step, the unabashed ambition to leave your current stability and engage with the universe on a quest to create something new, and beautiful and unforseen.  It all ends with compiler errors.</p><p>This step selets the relevant platform(s) for the built binaries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step2-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.step2-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.step2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step2(state::WizardState)</code></pre><p>This step obtains the source code to be built and required binary dependencies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step34-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.step34-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.step34</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step34(state::WizardState)</code></pre><p>Starts initial build for Linux x86_64, which is our initial test target platform.  Sources that build properly for this platform continue on to attempt builds for more complex platforms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step3_audit-Tuple{BinaryBuilder.WizardState,Platform,Prefix}" href="#BinaryBuilder.step3_audit-Tuple{BinaryBuilder.WizardState,Platform,Prefix}"><code>BinaryBuilder.step3_audit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step3_audit(state::WizardState, platform::Platform, prefix::Prefix)</code></pre><p>Audit the <code>prefix</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step3_interactive-Tuple{BinaryBuilder.WizardState,Prefix,Platform,BinaryBuilder.Runner,AbstractString}" href="#BinaryBuilder.step3_interactive-Tuple{BinaryBuilder.WizardState,Prefix,Platform,BinaryBuilder.Runner,AbstractString}"><code>BinaryBuilder.step3_interactive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step3_interactive(state::WizardState, prefix::Prefix, platform::Platform,
                  ur::Runner, build_path::AbstractString)</code></pre><p>The interactive portion of step3, moving on to either rebuild with an edited script or proceed to step 4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step3_retry-Tuple{BinaryBuilder.WizardState}" href="#BinaryBuilder.step3_retry-Tuple{BinaryBuilder.WizardState}"><code>BinaryBuilder.step3_retry</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step3_retry(state::WizardState)</code></pre><p>Rebuilds the initial Linux x86_64 build after things like editing the script file manually, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.step4-Tuple{BinaryBuilder.WizardState,BinaryBuilder.Runner,Platform,AbstractString,Prefix}" href="#BinaryBuilder.step4-Tuple{BinaryBuilder.WizardState,BinaryBuilder.Runner,Platform,AbstractString,Prefix}"><code>BinaryBuilder.step4</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step4(state::WizardState, ur::Runner, platform::Platform,
      build_path::AbstractString, prefix::Prefix)</code></pre><p>The fourth step selects build products after the first build is done</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.translate_symlinks-Tuple{AbstractString}" href="#BinaryBuilder.translate_symlinks-Tuple{AbstractString}"><code>BinaryBuilder.translate_symlinks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">translate_symlinks(root::AbstractString; verbose::Bool=false)</code></pre><p>Walks through the root directory given within <code>root</code>, finding all symlinks that point to an absolute path within <code>root</code>, and rewriting them to be a relative symlink instead, increasing relocatability.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.uname-Tuple{}" href="#BinaryBuilder.uname-Tuple{}"><code>BinaryBuilder.uname</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">uname()</code></pre><p>On Linux systems, return the strings returned by the <code>uname()</code> function in libc</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.unmount-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.unmount-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.unmount</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unmount(cs::CompilerShard)</code></pre><p>Unmount a compiler shard, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a <code>.squashfs</code> shard, on Linux.  All other combinations of shard archive type and platform result in a no-op from this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.update_linkage-Tuple{Prefix,Platform,AbstractString,Any,Any}" href="#BinaryBuilder.update_linkage-Tuple{Prefix,Platform,AbstractString,Any,Any}"><code>BinaryBuilder.update_linkage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">update_linkage(prefix::Prefix, platform::Platform, path::AbstractString,
               old_libpath, new_libpath; verbose::Bool = false)</code></pre><p>Given a binary object located at <code>path</code> within <code>prefix</code>, update its dynamic linkage to point to <code>new_libpath</code> instead of <code>old_libpath</code>.  This is done using a tool within the cross-compilation environment such as <code>install_name_tool</code> on MacOS or <code>patchelf</code> on Linux.  Windows platforms are completely skipped, as they do not encode paths or RPaths within their executables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.update_qemu-Tuple{}" href="#BinaryBuilder.update_qemu-Tuple{}"><code>BinaryBuilder.update_qemu</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">update_qemu(;verbose::Bool = false)</code></pre><p>Update our QEMU and Linux kernel installations, downloading and installing both into <code>&lt;storage_dir&gt;/qemu</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.url-Tuple{BinaryBuilder.CompilerShard}" href="#BinaryBuilder.url-Tuple{BinaryBuilder.CompilerShard}"><code>BinaryBuilder.url</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">url(cs::CompilerShard)</code></pre><p>Return the URL from which this shard can be downloaded.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.versioninfo-Tuple{}" href="#BinaryBuilder.versioninfo-Tuple{}"><code>BinaryBuilder.versioninfo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">versioninfo()</code></pre><p>Helper function to print out some debugging information</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryBuilder.yn_prompt" href="#BinaryBuilder.yn_prompt"><code>BinaryBuilder.yn_prompt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">yn_prompt(state::WizardState, question::AbstractString, default = :y)</code></pre><p>Perform a <code>[Y/n]</code> or <code>[y/N]</code> question loop, using <code>default</code> to choose between the prompt styles, and looping until a proper response (e.g. <code>&quot;y&quot;</code>, <code>&quot;yes&quot;</code>, <code>&quot;n&quot;</code> or <code>&quot;no&quot;</code>) is received.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.detect_libgfortran_abi-Tuple{ObjectFile.ObjectHandle,Platform}" href="#BinaryProvider.detect_libgfortran_abi-Tuple{ObjectFile.ObjectHandle,Platform}"><code>BinaryProvider.detect_libgfortran_abi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">detect_libgfortran_abi(oh::ObjectHandle, platform::Platform)</code></pre><p>Given an ObjectFile, examine its dynamic linkage to discover which (if any) <code>libgfortran</code> it&#39;s linked against.  The major SOVERSION will determine which GCC version we&#39;re restricted to.</p></div></div></section><footer><hr/><a class="previous" href="../tricksy_gotchas/"><span class="direction">Previous</span><span class="title">Tricksy Gotchas</span></a></footer></article></body></html>
