<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public Interface · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Public Interface</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#URIs-1">URIs</a></li><li><a class="toctext" href="#Cookies-1">Cookies</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#Server-/-Handlers-1">Server / Handlers</a></li></ul></li><li><a class="toctext" href="../internal_architecture/">Internal Architecture</a></li><li><a class="toctext" href="../internal_interface/">Internal Interfaces</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Public Interface</a></li></ul></nav><hr/><div id="topbar"><span>Public Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h1><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}" href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">HTTP.request(method, url [, headers [, body]]; &lt;keyword arguments&gt;]) -&gt; HTTP.Response</code></pre><p>Send a HTTP Request Message and recieve a HTTP Response Message.</p><p>e.g.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><code>headers</code> can be any collection where <code>[string(k) =&gt; string(v) for (k,v) in headers]</code> yields <code>Vector{Pair}</code>. e.g. a <code>Dict()</code>, a <code>Vector{Tuple}</code>, a <code>Vector{Pair}</code> or an iterator.</p><p><code>body</code> can take a number of forms:</p><ul><li>a <code>String</code>, a <code>Vector{UInt8}</code> or any <code>T</code> accepted by <code>write(::IO, ::T)</code></li><li>a collection of <code>String</code> or <code>AbstractVector{UInt8}</code> or <code>IO</code> streams or items of any type <code>T</code> accepted by <code>write(::IO, ::T...)</code></li><li>a readable <code>IO</code> stream or any <code>IO</code>-like type <code>T</code> for which <code>eof(T)</code> and <code>readavailable(T)</code> are defined.</li></ul><p>The <code>HTTP.Response</code> struct contains:</p><ul><li><code>status::Int16</code> e.g. <code>200</code></li><li><code>headers::Vector{Pair{String,String}}</code>  e.g. [&quot;Server&quot; =&gt; &quot;Apache&quot;, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;]</li><li><code>body::Vector{UInt8}</code>, the Response Body bytes  (empty if a <code>response_stream</code> was specified in the <code>request</code>).</li></ul><p>Functions <code>HTTP.get</code>, <code>HTTP.put</code>, <code>HTTP.post</code> and <code>HTTP.head</code> are defined as shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>, etc.</p><p><code>HTTP.request</code> and <code>HTTP.open</code> also accept optional keyword parameters.</p><p>e.g.</p><pre><code class="language-julia">HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;; retries=4, cookies=true)

HTTP.get(&quot;http://s3.us-east-1.amazonaws.com/&quot;; aws_authorization=true)

conf = (readtimeout = 10,
        pipeline_limit = 4,
        retry = false,
        redirect = false)

HTTP.get(&quot;http://httpbin.org/ip&quot;; conf..)
HTTP.put(&quot;http://httpbin.org/put&quot;, [], &quot;Hello&quot;; conf..)</code></pre><p>URL options</p><ul><li><code>query = nothing</code>, replaces the query part of <code>url</code>.</li></ul><p>Streaming options</p><ul><li><code>response_stream = nothing</code>, a writeable <code>IO</code> stream or any <code>IO</code>-like  type <code>T</code> for which <code>write(T, AbstractVector{UInt8})</code> is defined.</li><li><code>verbose = 0</code>, set to <code>1</code> or <code>2</code> for extra message logging.</li></ul><p>Connection Pool options</p><ul><li><code>connection_limit = 8</code>, number of concurrent connections to each host:port.</li><li><code>pipeline_limit = 16</code>, number of concurrent requests per connection.</li><li><code>reuse_limit = nolimit</code>, number of times a connection is reused after the                          first request.</li><li><code>socket_type = TCPSocket</code></li></ul><p>Timeout options</p><ul><li><code>readtimeout = 60</code>, close the connection if no data is recieved for this many seconds. Use <code>readtimeout = 0</code> to disable.</li></ul><p>Retry options</p><ul><li><code>retry = true</code>, retry idempotent requests in case of error.</li><li><code>retries = 4</code>, number of times to retry.</li><li><code>retry_non_idempotent = false</code>, retry non-idempotent requests too. e.g. POST.</li></ul><p>Redirect options</p><ul><li><code>redirect = true</code>, follow 3xx redirect responses.</li><li><code>redirect_limit = 3</code>, number of times to redirect.</li><li><code>forwardheaders = true</code>, forward original headers on redirect.</li></ul><p>Status Exception options</p><ul><li><code>status_exception = true</code>, throw <code>HTTP.StatusError</code> for response status &gt;= 300.</li></ul><p>SSLContext options</p><ul><li><code>require_ssl_verification = false</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></li><li><code>sslconfig = SSLConfig(require_ssl_verification)</code></li></ul><p>Basic Authenticaiton options</p><ul><li>basic_authorization=false, add <code>Authorization: Basic</code> header using credentials from url userinfo.</li></ul><p>AWS Authenticaiton options</p><ul><li><code>aws_authorization = false</code>, enable AWS4 Authentication.</li><li><code>aws_service = split(url.host, &quot;.&quot;)[1]</code></li><li><code>aws_region = split(url.host, &quot;.&quot;)[2]</code></li><li><code>aws_access_key_id = ENV[&quot;AWS_ACCESS_KEY_ID&quot;]</code></li><li><code>aws_secret_access_key = ENV[&quot;AWS_SECRET_ACCESS_KEY&quot;]</code></li><li><code>aws_session_token = get(ENV, &quot;AWS_SESSION_TOKEN&quot;, &quot;&quot;)</code></li><li><code>body_sha256 = digest(MD_SHA256, body)</code>,</li><li><code>body_md5 = digest(MD_MD5, body)</code>,</li></ul><p>Cookie options</p><ul><li><code>cookies = false</code>, enable cookies.</li><li><code>cookiejar::Dict{String, Set{Cookie}}=default_cookiejar</code></li></ul><p>Cananoincalization options</p><ul><li><code>canonicalize_headers = false</code>, rewrite request and response headers in Canonical-Camel-Dash-Format.</li></ul><p><strong>Request Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)</code></pre><p>Stream body from file:</p><pre><code class="language-julia">io = open(&quot;post_data.txt&quot;, &quot;r&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], io)</code></pre><p>Generator body:</p><pre><code class="language-julia">chunks = (&quot;chunk$i&quot; for i in 1:1000)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p>Collection body:</p><pre><code class="language-julia">chunks = [preamble_chunk, data_chunk, checksum(data_chunk)]
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p><code>open() do io</code> body:</p><pre><code class="language-julia">HTTP.open(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;) do io
    write(io, preamble_chunk)
    write(io, data_chunk)
    write(io, checksum(data_chunk))
end</code></pre><p><strong>Response Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;)
println(String(r.body))</code></pre><p>Stream body to file:</p><pre><code class="language-julia">io = open(&quot;get_data.txt&quot;, &quot;w&quot;)
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)
println(read(&quot;get_data.txt&quot;))</code></pre><p>Stream body through buffer:</p><pre><code class="language-julia">io = Base.BufferStream()
@async while !eof(io)
    bytes = readavailable(io))
    println(&quot;GET data: $bytes&quot;)
end
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)</code></pre><p>Stream body through <code>open() do io</code>:</p><pre><code class="language-julia">r = HTTP.open(&quot;GET&quot;, &quot;http://httpbin.org/stream/10&quot;) do io
   while !eof(io)
       println(String(readavailable(io)))
   end
end

using HTTP.IOExtras

HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    n = 0
    r = startread(http)
    l = parse(Int, header(r, &quot;Content-Length&quot;))
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        while !eof(http)
            bytes = readavailable(http)
            write(vlc, bytes)
            n += length(bytes)
            println(&quot;streamed $n-bytes $((100*n)÷l)%\u1b[1A&quot;)
        end
    end
end</code></pre><p><strong>Request and Response Body Examples</strong></p><p>String bodies:</p><pre><code class="language-julia">r = HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)
println(String(r.body))</code></pre><p>Interfacing with RESTful JSON APIs:</p><pre><code class="language-julia">using JSON
params = Dict(&quot;user&quot;=&gt;&quot;RAO...tjN&quot;, &quot;token&quot;=&gt;&quot;NzU...Wnp&quot;, &quot;message&quot;=&gt;&quot;Hello!&quot;)
base_url = &quot;http://api.domain.com&quot;
endpoint = &quot;/1/messages.json&quot;
url = base_url * endpoint
r = HTTP.request(&quot;POST&quot;, url,
             [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;],
             JSON.json(params))
println(JSON.parse(String(r.body)))</code></pre><p>Stream bodies from and to files:</p><pre><code class="language-julia">in = open(&quot;foo.png&quot;, &quot;r&quot;)
out = open(&quot;foo.jpg&quot;, &quot;w&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://convert.com/png2jpg&quot;, [], in, response_stream=out)</code></pre><p>Stream bodies through: <code>open() do io</code>:</p><pre><code class="language-julia">using HTTP.IOExtras

HTTP.open(&quot;POST&quot;, &quot;http://music.com/play&quot;) do io
    write(io, JSON.json([
        &quot;auth&quot; =&gt; &quot;12345XXXX&quot;,
        &quot;song_id&quot; =&gt; 7,
    ]))
    r = startread(io)
    @show r.status
    while !eof(io)
        bytes = readavailable(io))
        play_audio(bytes)
    end
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.open" href="#HTTP.open"><code>HTTP.open</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HTTP.open(method, url, [,headers]) do io
    write(io, body)
    [startread(io) -&gt; HTTP.Response]
    while !eof(io)
        readavailable(io) -&gt; AbstractVector{UInt8}
    end
end -&gt; HTTP.Response</code></pre><p>The <code>HTTP.open</code> API allows the Request Body to be written to (and/or the Response Body to be read from) an <code>IO</code> stream.</p><p>e.g. Streaming an audio file to the <code>vlc</code> player:</p><pre><code class="language-julia">HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HTTP.get(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>. See <a href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.put" href="#HTTP.put"><code>HTTP.put</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HTTP.put(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PUT&quot;, ...)</code>. See <a href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.post" href="#HTTP.post"><code>HTTP.post</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HTTP.post(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;POST&quot;, ...)</code>. See <a href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.head" href="#HTTP.head"><code>HTTP.head</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HTTP.head(url; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;HEAD&quot;, ...)</code>. See <a href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div></div></section><p>Request functions may throw the following exceptions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.StatusError" href="#HTTP.ExceptionRequest.StatusError"><code>HTTP.ExceptionRequest.StatusError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>Response</code> has a <code>4xx</code>, <code>5xx</code> or unrecognised status code.</p><p>Fields:</p><ul><li><code>status::Int16</code>, the response status code.</li><li><code>response</code> the <a href="../internal_interface/#HTTP.Messages.Response"><code>HTTP.Response</code></a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.ParseError" href="#HTTP.Parsers.ParseError"><code>HTTP.Parsers.ParseError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parser input was invalid.</p><p>Fields:</p><ul><li><code>code</code>, error code</li><li><code>bytes</code>, the offending input.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.IOError" href="#HTTP.IOExtras.IOError"><code>HTTP.IOExtras.IOError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The request terminated with due to an IO-related error.</p><p>Fields:</p><ul><li><code>e</code>, the error.</li></ul></div></div></section><pre><code class="language-none">Sockets.DNSError</code></pre><h2><a class="nav-anchor" id="URIs-1" href="#URIs-1">URIs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.URI" href="#HTTP.URIs.URI"><code>HTTP.URIs.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HTTP.URI(; scheme=&quot;&quot;, host=&quot;&quot;, port=&quot;&quot;, etc...)
HTTP.URI(str) = parse(HTTP.URI, str::String)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>The <code>URI</code> struct stores the compelte URI in the <code>uri::String</code> field and the component parts in the following <code>SubString</code> fields:</p><ul><li><code>scheme</code>, e.g. <code>&quot;http&quot;</code> or <code>&quot;https&quot;</code></li><li><code>userinfo</code>, e.g. <code>&quot;username:password&quot;</code></li><li><code>host</code> e.g. <code>&quot;julialang.org&quot;</code></li><li><code>port</code> e.g. <code>&quot;80&quot;</code> or <code>&quot;&quot;</code></li><li><code>path</code> e.g <code>&quot;/&quot;</code></li><li><code>query</code> e.g. <code>&quot;Foo=1&amp;Bar=2&quot;</code></li><li><code>fragment</code></li></ul><p>The <code>HTTP.resource(::URI)</code> function returns a target-resource string for the URI <a href="https://tools.ietf.org/html/rfc7230#section-5.3">RFC7230 5.3</a>. e.g. <code>&quot;$path?$query#$fragment&quot;</code>.</p><p>The <code>HTTP.queryparams(::URI)</code> function returns a <code>Dict</code> containing the <code>query</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.escapeuri" href="#HTTP.URIs.escapeuri"><code>HTTP.URIs.escapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>percent-encode a string, dict, or pair for a uri</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.unescapeuri" href="#HTTP.URIs.unescapeuri"><code>HTTP.URIs.unescapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>unescape a percent-encoded uri/url</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.splitpath" href="#HTTP.URIs.splitpath"><code>HTTP.URIs.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{HTTP.URIs.URI}" href="#Base.isvalid-Tuple{HTTP.URIs.URI}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div></div></section><h2><a class="nav-anchor" id="Cookies-1" href="#Cookies-1">Cookies</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><code>name</code>: name of the cookie</li><li><code>value</code>: value of the cookie</li><li><code>path</code>: applicable path for the cookie</li><li><code>domain</code>: applicable domain for the cookie</li><li><code>expires</code>: a <code>Dates.DateTime</code> representing when the cookie should expire</li><li><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</li><li><code>secure::Bool</code>: secure cookie attribute</li><li><code>httponly::Bool</code>: httponly cookie attribute</li><li><code>hostonly::Bool</code>: hostonly cookie attribute</li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div></div></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Strings.escapehtml" href="#HTTP.Strings.escapehtml"><code>HTTP.Strings.escapehtml</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div></div></section><h2><a class="nav-anchor" id="Server-/-Handlers-1" href="#Server-/-Handlers-1">Server / Handlers</a></h2><pre><code class="language-none">HTTP.listen
HTTP.serve
HTTP.Handlers
HTTP.handle
HTTP.RequestHandlerFunction
HTTP.StreamHandlerFunction
HTTP.Router
HTTP.@register</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../internal_architecture/"><span class="direction">Next</span><span class="title">Internal Architecture</span></a></footer></article></body></html>
