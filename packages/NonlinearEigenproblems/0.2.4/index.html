<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Getting-started-1">Getting started</a></li><li class="toplevel"><a class="toctext" href="#Accessing-more-complicated-applications-1">Accessing more complicated applications</a></li><li class="toplevel"><a class="toctext" href="#A-model-of-a-neuron-1">A model of a neuron</a></li><li class="toplevel"><a class="toctext" href="#The-&quot;gun&quot;-benchmark-problem-1">The &quot;gun&quot; benchmark problem</a></li><li class="toplevel"><a class="toctext" href="#Your-own-NEP-nonlinearity-1">Your own NEP nonlinearity</a></li><li class="toplevel"><a class="toctext" href="#What-now?-1">What now?</a></li></ul></li><li><a class="toctext" href="methods/">NEP Methods</a></li><li><a class="toctext" href="types/">NEP Types</a></li><li><a class="toctext" href="linsolvers/">LinSolver</a></li><li><a class="toctext" href="transformations/">NEP Transformations</a></li><li><a class="toctext" href="gallery/">NEP Gallery</a></li><li><a class="toctext" href="movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="bemtutorial/">Tutorial 2 (BEM)</a></li><li><a class="toctext" href="deflate_tutorial/">Tutorial 3 (Deflation)</a></li><li><a class="toctext" href="tutorial_call_python/">Tutorial 4 (Python NEP)</a></li><li><a class="toctext" href="tutorial_matlab1/">Tutorial 5 (MATLAB 1)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NEP-PACK-1" href="#NEP-PACK-1">NEP-PACK</a></h1><p>NEP-PACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find <span>$(λ,v)\in\mathbb{C}\times\mathbb{C}^n$</span> such that</p><div>\[M(λ)v=0\]</div><p>and <span>$v\neq 0$</span>.</p><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>Install it as a registered  package in Julia&#39;s REPL package mode by typing <code>] add Nonline...</code>:</p><pre><code class="language-none">julia&gt; ]
(v1.0) pkg&gt; add NonlinearEigenproblems</code></pre><p>Then we can start to load the NEP-PACK package</p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems</code></pre><p>As a first example we will solve the NEP associated with the matrix polynomial</p><div>\[M(λ)=\begin{bmatrix}1&amp;3\newline5&amp;6\end{bmatrix}+
λ\begin{bmatrix}3&amp;4\newline6&amp;6\end{bmatrix}+
λ^2\begin{bmatrix}1&amp;0\newline0&amp;1\end{bmatrix}\]</div><p>The following code creates this NEP, by constructing an object called <a href="types/#PEP-1"><code>PEP</code></a>, an abbreviation for polynomial eigenvalue problem. It subsequencly solves it using the NEP solution method implemented in <a href="methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];
julia&gt; nep=PEP([A0,A1,A2])
PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])
julia&gt; λ,v=polyeig(nep)
(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])</code></pre><p>You have now solved your first nonlinear eigenvalue problem with NEP-PACK.</p><p>In order to verify that we have a solution, we can check that  <span>$M(λ)$</span> is singular, with a singular vector <span>$v$</span> such that <span>$M(λ)v=0$</span>:</p><pre><code class="language-julia-repl">julia&gt; λ1=λ[1]; v1=v[:,1];
julia&gt; using LinearAlgebra # the norm-function is in this Julia package
julia&gt; norm(A0*v1+λ1*A1*v1+λ1^2*v1)/norm(v1)
1.1502634749464687e-14</code></pre><h1><a class="nav-anchor" id="Accessing-more-complicated-applications-1" href="#Accessing-more-complicated-applications-1">Accessing more complicated applications</a></h1><p>We have made benchmark examples available through the function <a href="gallery/#NonlinearEigenproblems.nep_gallery"><code>nep_gallery</code></a>:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; size(nep)
(100, 100)
julia&gt; λ,v=mslp(nep,tol=1e-10);
julia&gt; λ
0.23169217667341738 - 2.1866254654451488e-16im
julia&gt; size(v)
(100,)
julia&gt; resnorm=norm(compute_Mlincomb(nep,λ,v))
3.124042808475689e-14</code></pre><p>Information about the gallery can be found by typing <code>?nep_gallery</code>. The second arument in the call to <code>nep_gallery</code> is a problem parameter, in this case specifying that the  size of the problem should be <code>100</code>. The example solves the problem with the NEP-algorithm <a href="methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>MSLP</code></a>. The parameter <code>tol</code> specifies the tolerance for iteration termination. Type <code>?mslp</code> for more information about this NEP-algorithm.</p><h1><a class="nav-anchor" id="A-model-of-a-neuron-1" href="#A-model-of-a-neuron-1">A model of a neuron</a></h1><p>The following (delay) differential equation models a neuron</p><div>\[\dot{x}_1(t)=-\kappa x_1(t)+\beta\tanh(x_1(t-\tau_3))+a_1\tanh(x_2(t-\tau_2))\]</div><div>\[\dot{x}_2(t)=-\kappa x_2(t)+\beta\tanh(x_2(t-\tau_3))+a_2\tanh(x_1(t-\tau_1))\]</div><p>See <a href="https://www.jstor.org/stable/3061744?seq=1#page_scan_tab_contents">L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673–700, 2000</a>. It is also available as a first demo in <a href="https://sourceforge.net/projects/ddebiftool/">DDE-BIFTOOL</a>. The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue eigenvalue problem</p><div>\[M(λ)=-λI+A_0+A_1e^{-\tau_1λ}+A_2e^{-\tau_2λ}+A_3e^{-\tau_3λ}\]</div><p>where the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are</p><pre><code class="language-julia-repl">kappa=0.5; a2=2.34; a1=1; beta=-1;
A0=-kappa*[1 0; 0 1];
A1=a2*[0 0; 1 0];
A2=a1*[0 1; 0 0];
A3=beta*[1 0; 0 1];</code></pre><p>We can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem</p><pre><code class="language-julia-repl">julia&gt; tauv=[0;0.2;0.2;1.5];
julia&gt; dep=DEP([A0, A1,   A2, A3],tauv);</code></pre><p>The constructor  <a href="types/#DEP-1"><code>DEP</code></a> is an abbreviation for a delay eigenvalue problem, which is a NEP with exponential terms stemming from the stability analysis of a delay-differential equation. See <a href="types/"><code>types</code></a> for other NEP-types. You can now solve this NEP, for instance, with the <a href="methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev">infinite Arnoldi method</a>:</p><pre><code class="language-julia-repl">julia&gt; λ,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler</code></pre><p>The figure in a demo of DDE-BIFTOOL <a href="http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3">http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3</a> can be directly generated by</p><div><pre><code class="language-julia">using PyPlot
plot(real(λ),imag(λ),&quot;*&quot;);
xlabel(&quot;real(λ)&quot;); ylabel(&quot;imag(λ)&quot;);</code></pre></div><p><img src="neuron_eigvals.svg" alt/></p><p>This problem is also available in the <code>Gallery</code> by calling <code>dep=nep_gallery(&quot;neuron0&quot;)</code>.</p><h1><a class="nav-anchor" id="The-&quot;gun&quot;-benchmark-problem-1" href="#The-&quot;gun&quot;-benchmark-problem-1">The &quot;gun&quot; benchmark problem</a></h1><p>One of the most common benchmark problems for NEPs is the so-called &quot;gun&quot;-problem. It models an electromagnetic cavity, and it is directly available in the <code>Gallery</code>. (See <code>?nep_gallery</code> for references.) This is how you can solve it with the <a href="methods/#NonlinearEigenproblems.NEPSolver.blocknewton">block Newton method</a>:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; n=size(nep,1)
julia&gt; S=150^2*[1.0 0; 0 1]; V=[[1 0; 0 1]; zeros(n-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,displaylevel=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15</code></pre><p>This algorithm returns a partial Schur factorization of the NEP, and therefore the eigenvalues of the small matrix <code>Z</code> are eigenvalues of the problem. An eigenpair of the NEP can be extracted by diagonalizing:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra
julia&gt; (Λ,P)=eigen(Z);
julia&gt; VV=X*P;  # Construct the eigenvector matrix
julia&gt; v=VV[:,1]; λ=Λ[1]
61330.208714730004 + 63185.15983933589im
julia&gt; norm(compute_Mlincomb(nep,λ,v)) # Very small residual
1.8270553408452648e-16</code></pre><p>If you use the NEP-algorithms for research, please to give the author of the algorithm credit by citiation. The recommended citation can be found in the function documentation, e.g., <code>?blocknewton</code>.</p><h1><a class="nav-anchor" id="Your-own-NEP-nonlinearity-1" href="#Your-own-NEP-nonlinearity-1">Your own NEP nonlinearity</a></h1><p>As an application researcher, we recommend that you first try to express your problem in the following form since it gives access to several efficient routines associated with the NEP, in turn making it possible to use many NEP-solvers. A problem that can be expressed as a (short) sum of products of matrices and functions is called by objects of the type <a href="types/#SPMF-1"><code>SPMF</code></a> in NEP-PACK. For instance, a problem with three terms</p><div>\[M(λ) = A+λB+e^{\sin(λ/2)}C\]</div><p>can be created by</p><pre><code class="language-julia-repl">julia&gt; A=(1:4)*(1:4)&#39;+I; B=diagm(1 =&gt; [1,2,3]); C=ones(4,4);
julia&gt; f1= λ-&gt; one(λ);
julia&gt; f2= λ-&gt; λ;
julia&gt; f3= λ-&gt; exp(sin(λ/2))
julia&gt; nep=SPMF_NEP([A,B,C],[f1,f2,f3]);</code></pre><p>The NEP can now be solved with many algorithms, e.g.,</p><pre><code class="language-julia-repl">julia&gt; λ,v=quasinewton(nep,λ=3)
(3.176099007141426 + 0.0im, Complex{Float64}[37.1759+0.0im, -21.3016+0.0im, 0.0937992+0.0im, -1.15711+0.0im])</code></pre><p>Note that the functions <code>f1</code>,<code>f2</code> and <code>f3</code> have to be defined for scalar values and for matrices (in the matrix function sense, not elementwise sense). This is the reason <code>f1</code> needs to be defined as <code>one(λ)</code>, instead of just <code>1</code>.</p><p>As usual, you can check that we computed a sensible solution:</p><pre><code class="language-julia-repl">julia&gt; (A+B*λ+C*exp(sin(λ/2)))*v
4-element Array{Complex{Float64},1}:
  -6.586145128765412e-14 + 0.0im
  2.8285461200559146e-14 + 0.0im
 -4.1550357082583515e-14 + 0.0im
  -8.815768150428286e-15 + 0.0im</code></pre><h1><a class="nav-anchor" id="What-now?-1" href="#What-now?-1">What now?</a></h1><p>Now you are ready to try out <a href="movebc_tutorial/">the tutorial on artificial boundary conditions</a> or on <a href="bemtutorial/">the boundary element method</a> or have a look at the examples in <a href="methods/">NEP methods</a> and  <a href="gallery/">NEP Gallery</a>.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC" alt="To the top"/></p><footer><hr/><a class="next" href="methods/"><span class="direction">Next</span><span class="title">NEP Methods</span></a></footer></article></body></html>
