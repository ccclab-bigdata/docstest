<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NEP Types · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li class="current"><a class="toctext" href>NEP Types</a><ul class="internal"><li><a class="toctext" href="#The-basic-type-1">The basic type</a></li><li><a class="toctext" href="#SPMF-1">SPMF</a></li><li><a class="toctext" href="#PEP-1">PEP</a></li><li><a class="toctext" href="#DEP-1">DEP</a></li><li><a class="toctext" href="#REP-1">REP</a></li><li><a class="toctext" href="#SumNEP-1">SumNEP</a></li><li class="toplevel"><a class="toctext" href="#Accessing-the-NEP-1">Accessing the NEP</a></li></ul></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 2 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 3 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 4 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 5 (MATLAB 1)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>NEP Types</a></li></ul></nav><hr/><div id="topbar"><span>NEP Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NEPTypes-1" href="#NEPTypes-1">NEPTypes</a></h1><h2><a class="nav-anchor" id="The-basic-type-1" href="#The-basic-type-1">The basic type</a></h2><p>The basic class is the abstract class <code>NEP</code> which represents a NEP. All other defined NEPs should inherit from <code>NEP</code>, or from a more specialized version; see, e.g., <a href="../transformations/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a> or <a href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>AbstractSPMF</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.NEP" href="#NonlinearEigenproblems.NEPCore.NEP"><code>NonlinearEigenproblems.NEPCore.NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract NEP</code></pre><p>A <code>NEP</code> object represents a nonlinear eigenvalue problem. All NEPs should implement</p><pre><code class="language-julia-repl">size(nep::NEP,d)</code></pre><p>and at least one of the following</p><ul><li>M = <a href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder(nep::NEP,λ::Number,i::Integer=0)</code></a></li><li>V = <a href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb!"><code>compute_Mlincomb!(nep::NEP,λ::Number,V::AbstractVecOrMat,a::Vector)</code></a></li><li>MM = <a href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM(nep::NEP,S,V)</code></a></li></ul></div></div></section><p>Below we list the most common types built-in to NEP-PACK, and further down how you can <a href="#accessNEP">access the NEP</a>. However, the structure is made for extendability, and hence it is possible for you to extend with your own class of NEPs.</p><h2><a class="nav-anchor" id="SPMF-1" href="#SPMF-1">SPMF</a></h2><p>One of the most common problem types is the <code>SPMF_NEP</code>. SPMF is short for Sum of Products of Matrices and Functions and the NEP is described by</p><div>\[M(λ) = \sum_{i} A_i f_i(λ).\]</div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.SPMF_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct SPMF_NEP{T&lt;:AbstractMatrix,Ftype}  &lt;: AbstractSPMF{T}</code></pre><p>An SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,</p><div>\[M(λ)=∑_i A_i f_i(λ).\]</div><p>All of the matrices <span>$A_0,...$</span> are of size <span>$n×n$</span> and <span>$f_i$</span> are a functions. The  functions <span>$f_i$</span> must be defined for matrices in the standard matrix function sense.</p></div></div></section><p>In order to construct an <code>SPMF_NEP</code>, we need to provide the matrices and the functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMF_NEP-Tuple{Array{#s3516,1} where #s3516&lt;:(AbstractArray{T,2} where T),Array{#s3515,1} where #s3515&lt;:Function}" href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP-Tuple{Array{#s3516,1} where #s3516&lt;:(AbstractArray{T,2} where T),Array{#s3515,1} where #s3515&lt;:Function}"><code>NonlinearEigenproblems.NEPTypes.SPMF_NEP</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> SPMF_NEP(AA, fii, check_consistency, Schur_fact = false, align_sparsity_patterns = false, , Ftype)</code></pre><p>Creates a <code>SPMF_NEP</code> consisting of matrices <code>AA</code> and functions <code>fii</code>. The <code>SPMF_NEP</code> is defined by a sum of products of matrices and functions</p><div>\[M(λ)=∑_i A_i f_i(λ).\]</div><p>All of the matrices <span>$A_0,...$</span> are of size <span>$n×n$</span> and <span>$f_i$</span> are a functions. The  functions <span>$f_i$</span> must be defined for matrices in the standard matrix function sense.</p><p><strong>Parameters</strong></p><ul><li><p><code>AA</code> is a <code>Vector</code> of matrices. The matrices have to be of the same type. If you need a NEP with different types you can use <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a> to construct a sum of two <code>SPMF_NEP</code>.</p></li><li><p><code>fii</code> is a <code>Vector</code> of functions. Each function takes one parameter <code>S</code>. The functions must be available both as a scalar valid function and a matrix function. If <code>S</code> is a square matrix, <code>fii[k](S)</code> musst also be a square matrix. If <code>S</code> is a scalar <code>fii[k](S)</code> is a scalar.</p></li><li><p><code>check_consistency</code> (default <code>true</code>) determines if we should initiate by running tests to verify that the <code>fii</code> satisfies the conditions that every function is valid both for matrices and scalars. This is done by using <code>@code_typed</code> and the functions need to be type-stable in that sense.</p></li><li><p><code>align_sparsity_patterns</code> (default <code>false</code>) has effect only for sparse matrices (<code>SparseMatrixCSC</code>). If <code>align_sparsity_patterns=true</code> the <code>SparseMatrixCSC</code> matrices will be replaced by equivalent <code>SparseMatrixCSC</code> matrices where the <code>colptr</code> and <code>rowval</code> are identical. This increases the speed of some functions, e.g., <code>compute_Mder</code>. If <code>align_sparsity_patterns=true</code> the matrices in the NEP should be considered read only. If the sparsity patterns are completely or mostly distinct, it may be more efficient to set this flag to false.</p></li><li><p><code>Ftype</code> (default <code>ComplexF64</code>) determines an underlying type of the functions. The output of any function should be &quot;smaller&quot; than the promoted type of the input and <code>Ftype</code>. More precisely, if <code>F=fii[k]</code>, then the type logic is as follows <code>eltype(F(λ))=promote_type(eltype(λ),Ftype)</code>.</p></li><li><p><code>Schur_fact</code> (default <code>false</code>) determines if the <code>compute_MM</code> function should tridiagonalize the matrix before carrying out the computation. This can be faster for large matrices.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A0=[1 3; 4 5]; A1=[3 4; 5 6];
julia&gt; id_op=S -&gt; one(S) # Note: We use one(S) to be valid both for matrices and scalars
julia&gt; exp_op=S -&gt; exp(S)
julia&gt; nep=SPMF_NEP([A0,A1],[id_op,exp_op]);
julia&gt; compute_Mder(nep,1)-(A0+A1*exp(1))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre></div></div></section><h3><a class="nav-anchor" id="Abstract-SPMFs-1" href="#Abstract-SPMFs-1">Abstract SPMFs</a></h3><p>Many problems can be described in the class of SPMF. There might be more specialized and efficient implementations such as, e.g. <code>PEP</code>, <code>DEP</code> or <code>REP</code>. However, on an abstract level it may still be important to recognize the similarities. Hence there is an abstract class <code>AbstractSPMF</code>, which in itself inherits from <a href="../transformations/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.AbstractSPMF" href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>NonlinearEigenproblems.NEPTypes.AbstractSPMF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract  AbstractSPMF &lt;: ProjectableNEP</code></pre><p>An AbstractSPMF is an abstract class representing NEPs which can be represented as a Sum of products of matrices and functions <span>$M(λ)=Σ_i A_i f_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size n times n and f_i are functions.</p><p>Any AbstractSPMF has to have implementations of <a href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>get_Av()</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>get_fv()</code></a> which return the functions and matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_Av" href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>NonlinearEigenproblems.NEPTypes.get_Av</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an array of matrices <span>$A_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_fv" href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>NonlinearEigenproblems.NEPTypes.get_fv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an Array of functions (that can be evaluated both as scalar and matrix functions) <span>$f_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div></div></section><h2><a class="nav-anchor" id="PEP-1" href="#PEP-1">PEP</a></h2><p>The Polynomial Eigenvalue Problem is described by</p><div>\[M(λ) = \sum_{i} A_i λ^i.\]</div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.PEP" href="#NonlinearEigenproblems.NEPTypes.PEP"><code>NonlinearEigenproblems.NEPTypes.PEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct PEP &lt;: AbstractSPMF</code></pre><p>A polynomial eigenvalue problem (PEP) is defined by the sum the sum <span>$Σ_i A_i λ^i$</span>, where i = 0,1,2,..., and  all of the matrices are of size n times n.</p></div></div></section><p>In order to construct a <code>PEP</code>, we only need to provide the matrices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.PEP-Tuple{Array}" href="#NonlinearEigenproblems.NEPTypes.PEP-Tuple{Array}"><code>NonlinearEigenproblems.NEPTypes.PEP</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PEP(AA::Array)</code></pre><p>Creates a polynomial eigenvalue problem with monomial matrices specified in AA, which is an array of matrices.</p><pre><code class="language-julia-repl">julia&gt; A0=[1 3; 4 5]; A1=A0.+one(2); A2=ones(2,2);
julia&gt; pep=PEP([A0,A1,A2])
julia&gt; compute_Mder(pep,3)-(A0+A1*3+A2*9)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre></div></div></section><h2><a class="nav-anchor" id="DEP-1" href="#DEP-1">DEP</a></h2><p>The Delay Eigenvalue Problem is described by</p><div>\[M(λ) = -λI + \sum_{i} A_i e^{-τ_i λ}.\]</div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DEP" href="#NonlinearEigenproblems.NEPTypes.DEP"><code>NonlinearEigenproblems.NEPTypes.DEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">type DEP &lt;: AbstractSPMF</code></pre><p>A DEP (Delay Eigenvalue problem) is defined by the sum  <span>$-λI + Σ_i A_i exp(-tau_i λ)$</span> where all of the matrices are of size n times n.<br/>Constructor: <code>DEP(AA,tauv)</code> where <code>AA</code> is an array of the matrices <span>$A_i$</span>, and <code>tauv</code> is a vector of the values  <span>$tau_i$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; A0=randn(3,3); A1=randn(3,3);
julia&gt; tauv=[0,0.2] # Vector with delays
julia&gt; dep=DEP([A0,A1],tauv)
julia&gt; λ=3.0;
julia&gt; M1=compute_Mder(dep,λ)
julia&gt; M2=-λ*I+A0+A1*exp(-tauv[2]*λ)
julia&gt; norm(M1-M2)
0.0</code></pre></div></div></section><h2><a class="nav-anchor" id="REP-1" href="#REP-1">REP</a></h2><p>The Rational Eigenvalue Problem is described by:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.REP" href="#NonlinearEigenproblems.NEPTypes.REP"><code>NonlinearEigenproblems.NEPTypes.REP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct REP &lt;: AbstractSPMF</code></pre><p>A REP represents a rational eigenvalue problem. The REP is defined by the sum <span>$Σ_i A_i s_i(λ)/q_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size n times n and s<em>i and q</em>i are polynomials.</p></div></div></section><p>The constructor is called as:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.REP-Tuple{Any,Array{#s3516,1} where #s3516&lt;:Number}" href="#NonlinearEigenproblems.NEPTypes.REP-Tuple{Any,Array{#s3516,1} where #s3516&lt;:Number}"><code>NonlinearEigenproblems.NEPTypes.REP</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">REP(A,poles)</code></pre><p>Creates a rational eigenvalue problem. The constructor takes the matrices A_i and a sequence of poles as input (not complete).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A0=[1 2; 3 4]; A1=[3 4; 5 6];
julia&gt; nep=REP([A0,A1],[1,3]);
julia&gt; compute_Mder(nep,3)
2×2 Array{Float64,2}:
 NaN  NaN
 NaN  NaN</code></pre></div></div></section><h2><a class="nav-anchor" id="SumNEP-1" href="#SumNEP-1">SumNEP</a></h2><p>It is also possible to consider NEPs that are summs of other NEPs. For such situations there are SumNEPs. Specifically <code>GenericSumNEP</code> and <code>SPMFSumNEP</code>. Both are constructed using the function <code>SumNEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SumNEP" href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>NonlinearEigenproblems.NEPTypes.SumNEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SumNEP{nep1::NEP,nep2::NEP}
SumNEP{nep1::AbstractSPMF,nep2::AbstractSPMF}</code></pre><p>SumNEP is a function creating an object that corresponds to a sum of two NEPs, i.e., if nep is created by SumNEP it is defined by</p><div>\[M(λ)=M_1(λ)+M_2(λ)\]</div><p>where M<em>1 and M</em>2 are defined by <code>nep1</code> and <code>nep2</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep1=DEP([ones(3,3),randn(3,3)])
julia&gt; nep2=PEP([ones(3,3),randn(3,3),randn(3,3)])
julia&gt; sumnep=SumNEP(nep1,nep2);
julia&gt; s=3.0;
julia&gt; M=compute_Mder(sumnep,s);
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828
julia&gt; M1=compute_Mder(nep1,s);
julia&gt; M2=compute_Mder(nep2,s);
julia&gt; M1+M2  # Same as M
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.GenericSumNEP" href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>NonlinearEigenproblems.NEPTypes.GenericSumNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct GenericSumNEP{NEP1&lt;:NEP,NEP2&lt;:NEP}  &lt;: NEP</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMFSumNEP" href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>NonlinearEigenproblems.NEPTypes.SPMFSumNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct SPMFSumNEP{NEP1&lt;:AbstractSPMF,NEP2&lt;:AbstractSPMF}  &lt;: AbstractSPMF{AbstractMatrix}</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div></div></section><h1><a class="nav-anchor" id="Accessing-the-NEP-1" href="#Accessing-the-NEP-1">Accessing the NEP</a></h1><p>The nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions, <code>compute_Mder</code> <code>compute_Mlincomb</code> and <code>compute_MM</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_Mder(nep::NEP,λ::Number [,i::Integer=0])</code></pre><p>Computes the ith derivative of <code>nep</code> evaluated in <code>λ</code>.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder(nep,λ,1)</code> gives the first derivative.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; ϵ=1e-5;
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aplus=compute_Mder(nep,λ+ϵ);
julia&gt; opnorm((Aplus-Aminus)/(2ϵ)-compute_Mder(nep,λ,1))
1.990970375089371e-11</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb!" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb!"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_Mlincomb(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)
compute_Mlincomb!(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)</code></pre><p>Computes the linear combination of derivatives<br/><span>$Σ_i a_i M^{(i)}(λ) v_i$</span> starting from derivative <code>startder</code>. The function <code>compute_Mlincomb!</code> does the same but may modify the <code>V</code> matrix/array.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder</code> gives a result consistent with <code>compute_Mlincomb</code>. Note that <code>compute_Mlincomb</code> is in general faster since no matrix needs to be constructed.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; v=ones(size(nep,1)); λ=-1+1im;
julia&gt; norm(compute_Mder(nep,λ,1)*v-compute_Mlincomb(nep,λ,hcat(v,v),[0,1]))
1.0778315928076987e-15
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_MM" href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>NonlinearEigenproblems.NEPCore.compute_MM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_MM(nep::NEP,S,V)</code></pre><p>Computes the sum <span>$Σ_i M_i V f_i(S)$</span> for a NEP, where <span>$S$</span> and <span>$V$</span> are matrices, and the NEP satisfies <span>$M(λ)=Σ_i M_i f_i(λ)$</span>.</p><p><strong>Example</strong></p><p>This example shows that for diagonal <code>S</code>, the result of <code>compute_MM</code> can also be computed with <code>compute_Mlincomb</code></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; D=diagm(0 =&gt; [1,2])
2×2 Array{Int64,2}:
 1  0
 0  2
julia&gt; V=ones(size(n,1),2);
julia&gt; W=compute_MM(nep,D,V);
julia&gt; norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))
1.1102230246251565e-16
julia&gt; norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))
0.0</code></pre><p><strong>Reference</strong></p><p>Properties of the quantity <span>$Σ_i M_i V f_i(S)$</span> for non-polynomial nonlinear eigenvalue problems were extensively used in:</p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div></div></section><footer><hr/><a class="previous" href="../methods/"><span class="direction">Previous</span><span class="title">NEP Methods</span></a><a class="next" href="../linsolvers/"><span class="direction">Next</span><span class="title">LinSolver</span></a></footer></article></body></html>
