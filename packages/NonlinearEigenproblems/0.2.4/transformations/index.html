<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NEP Transformations · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li class="current"><a class="toctext" href>NEP Transformations</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Projection-1">Projection</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Associated-functions-1">Associated functions</a></li><li class="toplevel"><a class="toctext" href="#Deflation-1">Deflation</a></li></ul></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 2 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 3 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 4 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 5 (MATLAB 1)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>NEP Transformations</a></li></ul></nav><hr/><div id="topbar"><span>NEP Transformations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Transforming-NEPs-1" href="#Transforming-NEPs-1">Transforming NEPs</a></h1><p>There are various ways to transform NEPs into other NEPs. The simplest example is the function <code>shift_and_scale()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.shift_and_scale" href="#NonlinearEigenproblems.NEPTypes.shift_and_scale"><code>NonlinearEigenproblems.NEPTypes.shift_and_scale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shift_and_scale(orgnep::NEP;shift=0,scale=1)</code></pre><p>Transforms the orgnep by defining a new NEP from the relation T(λ)=M(scale * λ+shift) where M is the orgnep. This function tries  to preserve the NEP type, e.g., a shift<em>and</em>scale operation on an SPMF-object, return an SPMF object. If it cannot preserve the type, it will return a nep of the struct <code>ShiftScaledNEP</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep0=nep_gallery(&quot;pep0&quot;)
julia&gt; σ=3; α=10;
julia&gt; nep1=shift_and_scale(nep0,shift=σ,scale=α)
julia&gt; opnorm(compute_Mder(nep0,α*(4+4im)+σ)-compute_Mder(nep1,4+4im))
8.875435870738592e-12</code></pre></div></div></section><p>Similarly <code>mobius_transform()</code> is more general than <code>shift_and_scale</code> which transform the problem using a Möbius transformation. The function <code>taylor_exp</code> create new PEP by doing truncating a Taylor expansion.</p><h1><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h1><p>Several methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:</p><div>\[N(λ)=W^HM(λ)V,\]</div><p>where <span>$V,W\in\mathbb{C}^{n\times p}$</span> and the corresponding projected problem</p><div>\[N(λ)u=0.\]</div><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>NEPs for which this projection can be computed inherit from <code>ProjectableNEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ProjectableNEP" href="#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>NonlinearEigenproblems.NEPTypes.ProjectableNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract ProjectableNEP &lt;: NEP</code></pre><p>A ProjectableNEP is a NEP which can be projected, i.e., one can construct the problem <span>$W&#39;*M(λ)Vw=0$</span> with the <a href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a>. A NEP which is of this must have the function <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP(orgnep::ProjectableNEP)</code></a> implemented. This function must return a <code>Proj_NEP</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; typeof(nep)
DEP{Float64,Array{Float64,2}}
julia&gt; isa(nep,ProjectableNEP)
true
julia&gt; projnep=create_proj_NEP(nep);
julia&gt; e1 = Matrix(1.0*I,size(nep,1),1);
julia&gt; set_projectmatrices!(projnep,e1,e1);
julia&gt; compute_Mder(nep,3.0)[1,1]
-2.315345215259418
julia&gt; compute_Mder(projnep,3.0)
1×1 Array{Float64,2}:
 -2.315345215259418</code></pre></div></div></section><p>The result of the projection is represented in a <code>Proj_NEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type Proj_NEP &lt;: NEP</code></pre><p><code>Proj_NEP</code> represents a projected NEP. The projection is defined as the NEP</p><div>\[N(λ)=W^HM(λ)V\]</div><p>where <span>$M(λ)$</span> is a base NEP and <code>W</code> and <code>V</code> rectangular matrices representing a basis of the projection spaces. Instances are created with <code>create_proj_NEP</code>. See <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a> for examples.</p><p>Any <code>Proj_NEP</code> needs to implement two functions to manipulate the projection:</p><ul><li><a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>: Set matrices <code>W</code> and <code>V</code></li><li><a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>: Effectively expand the matrices <code>W</code> and <code>V</code> with one column.</li></ul></div></div></section><p>One explicit instance is the <code>Proj_SPMF_NEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct Proj_SPMF_NEP &lt;: Proj_NEP</code></pre><p>This type represents the (generic) way to project NEPs which are <code>AbstractSPMF</code>. See examples in <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Associated-functions-1" href="#Associated-functions-1">Associated functions</a></h2><p>You can create a projected NEP with <code>create_proj_NEP</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.create_proj_NEP" href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>NonlinearEigenproblems.NEPTypes.create_proj_NEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pnep=create_proj_NEP(orgnep::ProjectableNEP[,maxsize [,T]])</code></pre><p>Create a NEP representing a projected problem <span>$N(λ)=W^HM(λ)V$</span>,  where the  base NEP is represented by <code>orgnep</code>. The optional parameter <code>maxsize::Int</code> determines how large the projected problem can be and <code>T</code> is the Number type used for the projection matrices (default <code>ComplexF64</code>). These are needed for memory preallocation reasons. Use <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>  to specify projection matrices <span>$V$</span> and <span>$W$</span>.</p><p><strong>Example:</strong></p><p>The following example illustrates that a projection of a <code>NEP</code> is also a <code>NEP</code> and we can for instance call <code>compute_Mder</code> on it:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; V=Matrix(1.0*I,size(nep,1),2);
julia&gt; W=Matrix(1.0*I,size(nep,1),2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Complex{Float64},2}:
 -2.03662+0.0im   13.9777+0.0im
 -1.35069+0.0im  -13.0975+0.0im
julia&gt; W&#39;*compute_Mder(nep,3.0)*V  # Gives the same result
2×2 Array{Float64,2}:
 -2.03662   13.9777
 -1.35069  -13.0975</code></pre><p>If you know that you will only use real projection matrices, you can specify this in at the creation:</p><pre><code class="language-julia-repl">julia&gt; pnep=create_proj_NEP(nep,2,Float64);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Float64,2}:
 -2.03662   13.9777
 -1.35069  -13.0975</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.set_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.set_projectmatrices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_projectmatrices!(pnep::Proj_NEP,W,V)</code></pre><p>Set the projection matrices for the NEP to W and V, i.e., corresponding the NEP: <span>$N(λ)=W^HM(λ)V$</span>. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p><p><strong>Example</strong></p><p>This illustrates if <code>W</code> and <code>V</code> are vectors of ones, the projected problem becomes the sum of the rows and columns of the original NEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; V=ones(200,1);  W=ones(200,1);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
1×1 Array{Complex{Float64},2}:
 48.948104019482756 + 0.0im
julia&gt; sum(compute_Mder(nep,0),dims=[1,2])
1×1 Array{Float64,2}:
 48.948104019482955</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.expand_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.expand_projectmatrices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expand_projectmatrices!(nep::Proj_SPMF_NEP, Wnew, Vnew)</code></pre><p>The projected NEP is updated by adding the last column of <code>Wnew</code> and <code>Vnew</code> to the basis. Note that <code>Wnew</code> and <code>Vnew</code> contain also the &quot;old&quot; basis vectors. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a></p><p><strong>Example:</strong></p><p>In the following example you see that the expanded projected problem has one row and column more, and the leading subblock is the same as the smaller projected NEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;); n=size(nep,1);
julia&gt; V=Matrix(1.0*I,n,2); W=Matrix(1.0*I,n,2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
2×2 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im
 0.828413+0.0im  0.0646768+0.0im
julia&gt; Vnew=[V ones(n)]
julia&gt; Wnew=[W ones(n)]
julia&gt; expand_projectmatrices!(pnep,Wnew,Vnew);
julia&gt; compute_Mder(pnep,0)
3×3 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im  -12.1418+0.0im
 0.828413+0.0im  0.0646768+0.0im   16.3126+0.0im
 -17.1619+0.0im   -10.1628+0.0im   48.9481+0.0im</code></pre></div></div></section><h1><a class="nav-anchor" id="Deflation-1" href="#Deflation-1">Deflation</a></h1><p>Due to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of <code>effenberger_deflation</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.effenberger_deflation" href="#NonlinearEigenproblems.NEPTypes.effenberger_deflation"><code>NonlinearEigenproblems.NEPTypes.effenberger_deflation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">effenberger_deflation(nep::NEP,S0,V0)</code></pre><p>This function creates a deflated NEP based on (S0,V0), which are assumed to an invariant pair of <code>nep</code>. Effectively, the function should return a NEP which has the same solutions as orgnep, except those corresponding to (S0,V0).</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; (λ,v)=newton(nep);
julia&gt; n=size(nep,1);
julia&gt; S0=reshape([λ],1,1);
julia&gt; V0=reshape(v,n,1);
julia&gt; dnep=effenberger_deflation(nep,S0,V0)
julia&gt; (λ2,v2)=augnewton(dnep);  # this converges to different eigval
julia&gt; minimum(svdvals(compute_Mder(nep,λ2)))
9.323003321058995e-17</code></pre><p><strong>References</strong></p><ul><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div></div></section><footer><hr/><a class="previous" href="../linsolvers/"><span class="direction">Previous</span><span class="title">LinSolver</span></a><a class="next" href="../gallery/"><span class="direction">Next</span><span class="title">NEP Gallery</span></a></footer></article></body></html>
