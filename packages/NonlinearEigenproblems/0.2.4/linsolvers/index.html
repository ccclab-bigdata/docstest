<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LinSolver · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li class="current"><a class="toctext" href>LinSolver</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#EigSolvers-1">EigSolvers</a></li></ul></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 2 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 3 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 4 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 5 (MATLAB 1)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>LinSolver</a></li></ul></nav><hr/><div id="topbar"><span>LinSolver</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LinSolvers-1" href="#LinSolvers-1">LinSolvers</a></h1><p>Most NEP-algorithms need to solve the linear system associated with <code>M(λ)</code>. We provide an interface to specify which solver to use or define your own solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.LinSolver" href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>NonlinearEigenproblems.LinSolvers.LinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type LinSolver</code></pre><p>Structs inheriting from this type are able to solve linear systems associated with a NEP, for a specific <code>λ</code>-value. The most common are direct solvers such as <a href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolver"><code>DefaultLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a> and iterative solvers such as <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>.</p><p>The LinSolver objects are usually created by the NEP-algorithms through creator functions, which are passed as parameters.</p><p><strong>Example</strong></p><p>The most common usecase is that you want to pass a <code>linsolvercreator</code>-function as parameter to the NEP-algorithm. This example shows how you can solvers based on backslash or <code>factorize()</code>. In the example, <code>BackslashLinSolver</code> does not exploit that the system matrix remains the same throughout the algorithm and is therefore slower.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; using BenchmarkTools
julia&gt; v0=ones(size(nep,1));
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=default_linsolvercreator);
  199.540 ms (4929 allocations: 59.83 MiB)
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=backslash_linsolvercreator);
  1.632 s (6137 allocations: 702.85 MiB)</code></pre><p><strong>Example</strong></p><p>The <code>LinSolver</code>s are constructed for extendability. This example creates our own <code>LinSolver</code> which uses an explicit formula for the inverse if the NEP has dimension 2x2.</p><p>Create the types and a creator.</p><pre><code class="language-julia">julia&gt; using LinearAlgebra
julia&gt; struct MyLinSolver &lt;: LinSolver
   M::Matrix{ComplexF64}
end
julia&gt; function my_linsolvercreator(nep,λ)
   M=compute_Mder(nep,λ);
   return MyLinSolver(M);
end</code></pre><p>Explicit import <code>lin_solve</code> to show how to solve a linear system.</p><pre><code class="language-julia-repl">julia&gt; import NonlinearEigenproblems.LinSolvers.lin_solve;
julia&gt; function lin_solve(solver::MyLinSolver,b::AbstractVecOrMat;tol=0)
   M=solver.M;
   invM=(1/(det(M)))*[M[2,2] -M[1,2];-M[2,1] M[1,1]]
   return invM*b
end
julia&gt; nep=SPMF_NEP([[1.0 3.0; 4.0 5.0], [2.0 1.0; -1 2.0]], [S-&gt;S^2,S-&gt;exp(S)])
julia&gt; λ,v=quasinewton(nep,λ=-1,v=[1;1],linsolvercreator=my_linsolvercreator);</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>lin_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolver"><code>DefaultLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.default_linsolvercreator"><code>default_linsolvercreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator"><code>backslash_linsolvercreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator"><code>gmres_linsolvercreator</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.lin_solve" href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>NonlinearEigenproblems.LinSolvers.lin_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lin_solve(solver::LinSolver, b::AbstractVecOrMat; tol=0)</code></pre><p>This function solves the linear system represented in <code>solver::LinSolver</code> with a right-hand side <code>b</code>. The <code>tol</code> kwarg is controlling how accurate the linear system needs to be solved. A NEP-algorithm will call this solver every time a linear system associated with <code>M(λ)</code> needs to be solved.</p><p>This function must be overloaded if a user wants to define their own way of solving linear systems. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> for examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DefaultLinSolver" href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolver"><code>NonlinearEigenproblems.LinSolvers.DefaultLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DefaultLinSolver &lt;: LinSolver</code></pre><p>This represents the linear solver associated with julia <code>factorize()</code>. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.default_linsolvercreator"><code>default_linsolvercreator</code></a> for examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.default_linsolvercreator" href="#NonlinearEigenproblems.LinSolvers.default_linsolvercreator"><code>NonlinearEigenproblems.LinSolvers.default_linsolvercreator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">default_linsolvercreator(nep::NEP, λ; umfpack_refinements = 2)</code></pre><p>Create a linear solver of type <code>DefaultLinSolver</code> for the NEP evaluated in point <code>λ</code>. For sparse matrices (the underlying solver is usually UMFPACK) the maximum number of iterative refinements can be changed to trade accuracy for performance with the parameter <code>umfpack_refinements</code>. UMFPACK defaults to a maximum of 2 iterative refinements.</p><p>For examples see <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolver"><code>DefaultLinSolver</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.BackslashLinSolver" href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>NonlinearEigenproblems.LinSolvers.BackslashLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct BackslashLinSolver &lt;: LinSolver</code></pre><p>This represents a linear solver corresponding to the backslash operator (no pre-factorization).</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator"><code>backslash_linsolvercreator</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator" href="#NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator"><code>NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">backslash_linsolvercreator(nep::NEP, λ)</code></pre><p>Create a linear solver of type <code>BackslashLinSolver</code> evaluated in <code>λ</code>.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.GMRESLinSolver" href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>NonlinearEigenproblems.LinSolvers.GMRESLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct GMRESLinSolver &lt;: LinSolver</code></pre><p>This represents a solver done with the julia GMRES implementation.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator"><code>gmres_linsolvercreator</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator" href="#NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator"><code>NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gmres_linsolvercreator(nep::NEP, λ, kwargs=())</code></pre><p>Create a linear solver of type <code>GMRESLinSolver</code>. The <code>kwargs</code> are passed as parameter to Julia-built-in-GMRES.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a></p></div></div></section><h1><a class="nav-anchor" id="EigSolvers-1" href="#EigSolvers-1">EigSolvers</a></h1><p>Some NEP-algorithms need to solve an associated linear eigenvalue problem. associated with <code>M(λ)</code>. You will likely only need the native eigensolvers in Julia. Nevertheless, we provide an interface to specify which solver to use or define your own solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.EigSolver" href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>NonlinearEigenproblems.LinSolvers.EigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type EigSolver</code></pre><p>Structs inheriting from this type are able to solve linear eigenvalue problems arising in certain methods, such as, e.g., <code>mslp</code>, <code>sgiter</code>, and <code>polyeig</code>.</p><p>The <code>EigSolver</code> objects are passed as types to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>.</p><p><strong>Example</strong></p><p>The most common usecase is that you do not want to specify anything in particular, since the <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a> will use a dense or a sparse method depending on you problem. However, this example shows how you can force <code>mslp</code> to use the sparse solver.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v = mslp(nep, eigsolvertype=NativeEigSSolver);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.0324139764567768e-15</code></pre><p><strong>Example</strong></p><p>The <code>EigSolver</code>s are constructed for extendability. As an illustartion this example creates a naive <code>EigSolver</code> which casts the problem to a standard linear eigenproblem and calls the built-in function to solve it.</p><p>Create the types and a creator.</p><pre><code class="language-julia-repl">julia&gt; struct MyEigSolver &lt;: EigSolver
   A
   E
   function MyEigSolver(A,E)
      return new(A,E)
   end
end

julia&gt; import NonlinearEigenproblems.LinSolvers.eig_solve;
julia&gt; function eig_solve(solver::MyEigSolver;nev = 1, target = 0)
   M = solver.E \ solver.A
   eig = eigen(M)
   i = argmin(abs.(eig.values))
   return eig.values[i], eig.vectors[:,i]
end
julia&gt; nep=nep_gallery(&quot;dep0&quot;, 50);
julia&gt; λ,v = mslp(nep, eigsolvertype=MyEigSolver, tol=1e-5);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
3.0777795031319117e-10</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NativeEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NativeEigSSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.eig_solve" href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>NonlinearEigenproblems.LinSolvers.eig_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eig_solve(solver::EigSolver; [nev,] [target,])</code></pre><p>This function solves the linear eigenvalue problem represented in <code>solver::EigSolver</code>. The <code>nev</code> kwarg is controlling the number of eigenvalues aimed for, and <code>target</code> specifies around which point the eigenvalues are computed. The former has a defalut value equalt to the seize of the problem, and the latter has a defalut value 0.</p><p>Return values are of the form (Vector, Matrix) where the former contains the eigenvalues and the latter the eigenvectors.</p><p>This function must be overloaded if a user wants to define their own way of solving linear eigenvalue problems. See <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> for examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DefaultEigSolver" href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>NonlinearEigenproblems.LinSolvers.DefaultEigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DefaultEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls checks for sparsity and accordingly assigns an appropriate solver.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NativeEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NativeEigSSolver</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.NativeEigSolver" href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NonlinearEigenproblems.LinSolvers.NativeEigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct NativeEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls Julia&#39;s in-built eigen()</p><p>Constructed as <code>NativeEigSolver(A, [B,])</code>, and solves the problem</p><div>\[Ax = λBx\]</div><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.NativeEigSSolver" href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NonlinearEigenproblems.LinSolvers.NativeEigSSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct NativeEigSSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver for large and sparse problems that calls Julia&#39;s in-built eigs()</p><p>Constructed as <code>NativeEigSSolver(A, [B,])</code>, and solves the problem</p><div>\[Ax = λBx\]</div><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">NEP Types</span></a><a class="next" href="../transformations/"><span class="direction">Next</span><span class="title">NEP Transformations</span></a></footer></article></body></html>
