<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cuckoo filter Â· Probably.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Probably.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="hyperloglog.html">HyperLogLog</a></li><li><a class="toctext" href="countmin.html">Count-min sketch</a></li><li class="current"><a class="toctext" href="cuckoo.html">Cuckoo filter</a><ul class="internal"><li><a class="toctext" href="#What-it-is-1">What it is</a></li><li><a class="toctext" href="#Usage-example-1">Usage example</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li></ul></li><li><a class="toctext" href="bloom.html">Bloom filter</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="cuckoo.html">Cuckoo filter</a></li></ul></nav><hr/><div id="topbar"><span>Cuckoo filter</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Cuckoo-filter-1" href="#Cuckoo-filter-1">Cuckoo filter</a></h1><p><em>Reference: Fan, Andersen, Kaminsky &amp; Mitzenmacher: &quot;Cuckoo Filter: Practically Better Than Bloom&quot;</em></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>See also the page: <a href="cuckoo_v_bloom.html#Cuckoo-versus-bloom-filters-1">Cuckoo versus bloom filters</a></p></div></div><hr/><h2><a class="nav-anchor" id="What-it-is-1" href="#What-it-is-1">What it is</a></h2><p>A cuckoo filter is conceptually similar to a bloom filter, even though the underlying algorithm is quite different.</p><p>The cuckoo filter is similar to a <code>Set</code>. Hashable objects can be pushed into the filter, but objects cannot be extracted from the filter. Querying the filter, i.e. asking whether an object is in a filter is fast, but cuckoo filters has a certain probability of falsely returning <code>true</code> when querying about an object not actually in the filter. When querying an object that is in the filter, it is guaranteed to return <code>true</code>.</p><p>A cuckoo filter is defined by two parameters, <code>F</code> and its length <code>L</code>. Memory usage is <code>F*L/2</code> bytes plus 50-ish bytes of overhead, and the false positive rate is approximately <code>9*(N/L)*(2^-F)</code> where N is the number of elements in the filter.</p><h3><a class="nav-anchor" id="Querying-(in)-1" href="#Querying-(in)-1">Querying (<code>in</code>)</a></h3><p>Querying takes one cache access plus either 1 or 2 random memory access depending on the values of N, <code>F</code> and <code>L</code>, and so can be thought of as being constant. When querying about an object in the filter, it is guaranteed to return <code>true</code>, unless deletion operations have been done on the filrter. Querying about objects not in the filter returns <code>true</code> with a probability approximately to <code>9*(N/L)*(2^-F)</code>.</p><p>In general, two distinct objects A and B will have a <code>1/(2^F-1)</code> chance of sharing so-called &quot;fingerprints&quot;. Independently, each object is assigned two &quot;buckets&quot; in the range <code>1:L/4</code>, and inserted in an arbitrary of the two buckets. If objects A and B share fingerprints, and object A is in one of B&#39;s buckets, the existence of A will make a query for B return <code>true</code>, even when it&#39;s not in the filter.</p><h3><a class="nav-anchor" id="Pushing-(push!)-1" href="#Pushing-(push!)-1">Pushing (<code>push!</code>)</a></h3><p>Only hashable objects can be inserted into the filter. Inserting time is stochastic, but its expected duration is proportional to <code>1/(1 - N/L)</code>. To avoid infinite insertion times as N approaches <code>L</code>, an insert operation may fail if the filter is too full. A failed push operation returns <code>false</code>.</p><p>Pushing may yield false positives: If an object A exists in the filter, and querying for object B would falsely return <code>true</code>, then pushing B to the filter has a probability <code>1/2 + 1/2 * N/L</code> of returning <code>true</code> while doing nothing, because B is falsely believed to already be in the filter.</p><h3><a class="nav-anchor" id="Deletion-(pop!)-1" href="#Deletion-(pop!)-1">Deletion (<code>pop!</code>)</a></h3><p>Objects can be deleted from the filter. Deleting operation also exhibits false positives: If B has been pushed to the filter, falsely returning success, then deleting A will also delete B.</p><p>Deletion of objects is fast and constant time, except if the filter is at full capacity. In that case, it will attempt to self-organize after a deletion to allow new objects to be pushed. This might take up to 200 microseconds.</p><h3><a class="nav-anchor" id="FastCuckoo-and-SmallCuckoo-1" href="#FastCuckoo-and-SmallCuckoo-1"><code>FastCuckoo</code> and <code>SmallCuckoo</code></a></h3><p>Probably.jl comes with two different implementations of the cuckoo filter: <code>FastCuckoo</code> and <code>SmallCuckoo</code>. The latter uses a more complicated encoding scheme to achieve a slightly smaller memory footprint, but which also make all operations slower. The following plot shows how the speed of pushing objects depend on the load factor, i.e. how full the filter is, and how <code>FastCuckoo</code>s are ~2.5x faster than <code>SmallCuckoo</code>s, but that the <code>SmallCuckoo</code> uses about 10% less memory. FastCuckoo is displayed in blue, SmallCuckoo in orange.</p><p><img src="cuckooperformance.png" alt/></p><h2><a class="nav-anchor" id="Usage-example-1" href="#Usage-example-1">Usage example</a></h2><p>For this example, let&#39;s say I have a stream of <a href="https://en.wikipedia.org/wiki/K-mer">kmers</a> that I want to count. Of course I use BioJulia, so these kmers are represented by a <code>DNAKmer{31}</code> object. I suspect my stream has up to 2 billion different kmers, so keeping a counting Dict would use up all my memory. However, most kmers are measurement errors that only appear once and that I do not need spend memory on keeping count of. So I keep track of which kmers I&#39;ve seen using a Cuckoo filter. If I see a kmer more than once, I add it to the Dict.</p><pre><code class="language-none">params = constrain(SmallCuckoo, fpr=0.02, capacity=2_000_000_000)
if params.memory &gt; 4e9 # I&#39;m only comfortable using 4 GB of memory for this
    error(&quot;Too little memory :(&quot;)
end
filter = SmallCuckoo{params.F}(params.nfingerprints)
counts = Dict{Kmer, UInt8}() # Don&#39;t need to count higher than 255

for kmer in each(DNAKmer{31}, fastq_parser)
    if kmer in filter
        # Only add kmers we&#39;ve seen before
        count = min(0xfe, get(counts, kmer, 0x01)) # No integer overflow
        counts[kmer] = count + 0x01
    else
        push!(filter, kmer)
    end
end</code></pre><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><h3><a class="nav-anchor" id="Construction-1" href="#Construction-1">Construction</a></h3><p>A cuckoo filter can be constructed directly from the two parameters <code>F</code> and <code>L</code>, where L is the number of fingerprint slots in the fingerprint. Remember that <code>L</code> should be a power-of-two:</p><p><code>julia&gt; FastCuckoo{12}(2^32) # F=12, L=2^32, about 6 GiB in size</code></p><p>However, typically, one wants to construct cuckoo filters under some kind of constrains: Perhaps I need to store at least 1.1 billion distinct elements, with a maximal false positive rate of 0.004. For this purpose, use the <code>constrain</code> function.</p><p>This function takes a type and two of three keyword arguments:</p><ul><li><code>fpr</code>: Maximal false positive rate</li><li><code>memory</code>: Maximal memory usage</li><li><code>capacity</code>: Minimum number of distinct elements it can contain</li></ul><p>It returns a <code>NamedTuple</code> with the parameters for an object of the specified type which fits the criteria:</p><pre><code class="language-none">julia&gt; constrain(SmallCuckoo, fpr=0.004, capacity=1.1e9)
(F = 11, nfingerprints = 2147483648, fpr = 0.002196371220581028, memory = 2952790074, capacity = 2040109466)</code></pre><p>Having passed false positive rate and capacity, the function determined the smallest possible <code>SmallCuckoo</code> that fits these criteria. We can see from the fields <code>F</code> and <code>nfingerprints</code> that such a <code>SmallCuckoo</code> can be constructed with:</p><p><code>SmallCuckoo{11}(2147483648)</code></p><p>Furthermore, we can also see that those particular constrains were quite unlucky: The actual false positive rate of this filter will be ~0.0022 (at full capacity), and its actual capacity will be ~2 billion elements. It is not possible to create a smaller <code>SmallCuckoo</code> which fits the given criteria.</p><h3><a class="nav-anchor" id="Central-functions-1" href="#Central-functions-1">Central functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{Any,AbstractCuckooFilter}" href="#Base.in-Tuple{Any,AbstractCuckooFilter}"><code>Base.in</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">in(item, filter::AbstractCuckooFilter)</code></pre><p>Check if an item is in the cuckoo filter. This can sometimes erroneously return <code>true</code>, but never erroneously returns <code>false</code>, unless a <code>pop!</code> operation has been performed on the filter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{AbstractCuckooFilter,Any}" href="#Base.push!-Tuple{AbstractCuckooFilter,Any}"><code>Base.push!</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(filter::AbstractCuckooFilter, items...)</code></pre><p>Insert one or more items into the cuckoo filter. Returns <code>true</code> if all inserts was successful and <code>false</code> otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Tuple{AbstractCuckooFilter,Any}" href="#Base.pop!-Tuple{AbstractCuckooFilter,Any}"><code>Base.pop!</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop!(filter::AbstractCuckooFilter, item)</code></pre><p>Delete an item from the cuckoo filter, returning the filter. Does not throw an error if the item does not exist. Has a risk of deleting other items if they collide with the target item in the filter.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = FastCuckoo{12}(2^4); push!(a, 1); push!(a, 868)
julia&gt; pop!(a, 1); # Remove 1, this accidentally deletes 868 also
julia&gt; isempty(a)
true</code></pre></div></div></section><h3><a class="nav-anchor" id="Misc-functions-1" href="#Misc-functions-1">Misc functions</a></h3><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Cuckoo filters supports the following operations, which have no cuckoo-specific docstring because they behave as stated in the documentation in Base:</p></div></div><pre><code class="language-none">Base.copy!
Base.copy
Base.sizeof # This one includes the underlying array</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCuckooFilter}" href="#Base.isempty-Tuple{AbstractCuckooFilter}"><code>Base.isempty</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(x::AbstractCuckooFilter)</code></pre><p>Test if the filter contains no elements. Guaranteed to be correct.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = FastCuckoo{12}(1&lt;&lt;12); isempty(a)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!-Tuple{AbstractCuckooFilter}" href="#Base.empty!-Tuple{AbstractCuckooFilter}"><code>Base.empty!</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">empty!(x::AbstractCuckooFilter)</code></pre><p>Removes all objects from the cuckoo filter, resetting it to initial state.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = FastCuckoo{12}(1&lt;&lt;12); push!(a, &quot;Hello&quot;); isempty(a)
false

julia&gt; empty!(a); isempty(a)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union!-Tuple{AbstractCuckooFilter}" href="#Base.union!-Tuple{AbstractCuckooFilter}"><code>Base.union!</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">union!(dest::HyperLogLog{P}, src::HyperLogLog{P})</code></pre><p>Overwrite <code>dest</code> with the same result as <code>union(dest, src)</code>, returning <code>dest</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; # length(c) â¥ length(b) is not guaranteed, but overwhelmingly likely
julia&gt; c = union!(a, b); c === a &amp;&amp; length(c) â¥ length(b)
true</code></pre></div></div><div><div><pre><code class="language-none">union!(dst::AbstractCuckooFilter{F}, src::AbstractCuckooFilter{F})</code></pre><p>Attempt to add all elements of source filter to destination filter. If destination runs out of space, abort the copying and return <code>(destination, false</code>). Else, return <code>(destination, true)</code>. Both filters must have the same length and F value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union-Tuple{AbstractCuckooFilter}" href="#Base.union-Tuple{AbstractCuckooFilter}"><code>Base.union</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">union(x::HyperLogLog{P}, y::HyperLogLog{P})</code></pre><p>Create a new HLL identical to an HLL which has seen the union of the elements <code>x</code> and <code>y</code> has seen.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; # That c is longer than a or b is not guaranteed, but overwhelmingly likely
julia&gt; c = union(a, b); length(c) â¥ length(a) &amp;&amp; length(c) â¥ length(b)
true</code></pre></div></div><div><div><pre><code class="language-none">union(x::AbstractCuckooFilter{F}, y::AbstractCuckooFilter{F})</code></pre><p>Attempt to create a new cuckoo fitler with the same length and F value as x and y, and with the union of their elements. If the new array does not have enough space, returns <code>(newfilter, false)</code>, else returns <code>(newfilter, true)</code>. Both filters must have the same length and F value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Probably.loadfactor-Tuple{AbstractCuckooFilter}" href="#Probably.loadfactor-Tuple{AbstractCuckooFilter}"><code>Probably.loadfactor</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">loadfactor(x::AbstractCuckooFilter)</code></pre><p>Returns fraction of filled fingerprint slots, i.e. how full the filter is.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = FastCuckoo{12}(1&lt;&lt;12);
julia&gt; for i in 1:1&lt;&lt;11 push!(i, a) end; loadfactor(a)
0.5</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Probably.fprof" href="#Probably.fprof"><code>Probably.fprof</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fprof(::Type{AbstractCuckooFilter{F}}) where {F}
fprof(x::AbstractCuckooFilter)</code></pre><p>Get the false positive rate for a fully filled AbstractCuckooFilter{F}. The FPR is proportional to the fullness (a.k.a load factor).</p></div></div><div><div><pre><code class="language-none">fprof(sketch::CountMinSketch)</code></pre><p>Estimate the probability of miscounting an element in the sketch.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Probably.capacityof" href="#Probably.capacityof"><code>Probably.capacityof</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">capacityof(filter::AbstractCuckooFilter)</code></pre><p>Estimate the number of distinct elements that can be pushed to the filter before adding more will fail. Since push failures are probabilistic, this is not accurate, but for filters with a capacity of thousands or more, this is rarely more than 1% off.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Probably.constrain-Tuple{Type{AbstractCuckooFilter}}" href="#Probably.constrain-Tuple{Type{AbstractCuckooFilter}}"><code>Probably.constrain</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constrain(T&lt;:AbstractCuckooFilter; fpr=nothing, mem=nothing, capacity=nothing)</code></pre><p>Given a subtype of <code>AbstractCuckooFilter</code> and two of three keyword arguments, as constrains, optimize the elided keyword argument. Returns a NamedTuple with (F, nfingerprints, fpr, memory, capacity), which applies to an instance of the optimized CuckooFilter.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; # FastCuckoo with FPR â¤ 0.001, and memory usage â¤ 250_000_000 bytes

julia&gt; c = constrain(FastCuckoo, fpr=0.001, memory=250_000_000)
(F = 14, nfingerprints = 134217728, fpr = 0.0005492605216655955, memory = 234881081,
capacity = 127506842)

julia&gt; x = FastCuckoo{c.F}(c.nfingerprints); # capacity optimized

julia&gt; fprof(x), sizeof(x), capacityof(x) # not always exactly the estimate
(0.0005492605216655955, 234881081, 127506842)</code></pre></div></div></section><footer><hr/><a class="previous" href="countmin.html"><span class="direction">Previous</span><span class="title">Count-min sketch</span></a><a class="next" href="bloom.html"><span class="direction">Next</span><span class="title">Bloom filter</span></a></footer></article></body></html>
