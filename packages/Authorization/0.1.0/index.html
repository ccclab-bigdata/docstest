<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Authorization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Authorization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Resources-1">Resources</a></li><li><a class="toctext" href="#Clients-1">Clients</a></li><li><a class="toctext" href="#Permissions-1">Permissions</a></li><li><a class="toctext" href="#Accessing-Resources-1">Accessing Resources</a></li><li><a class="toctext" href="#Use-Cases-1">Use Cases</a></li><li><a class="toctext" href="#Developing-a-new-client-1">Developing a new client</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Authorization.jl-1" href="#Authorization.jl-1">Authorization.jl</a></h1><p>A small but flexible API for controlling an <strong>authenticated</strong> client&#39;s access to resources.</p><p>Some use cases are listed at the bottom of this README.</p><h2><a class="nav-anchor" id="Resources-1" href="#Resources-1">Resources</a></h2><p>All resources (subtypes of <code>AbstractResource</code>) have an <code>id</code>. Resources may also have fields other than <code>id</code>.</p><h2><a class="nav-anchor" id="Clients-1" href="#Clients-1">Clients</a></h2><p>A client is a type (subtype of <code>AbstractClient</code>) that represents an entity wishing to access some resources. Clients may represent users, web apps, data storage clients, etc.</p><h2><a class="nav-anchor" id="Permissions-1" href="#Permissions-1">Permissions</a></h2><p>A client&#39;s access to a resource is determined by its <code>Permission</code> for the resource. The <code>Permission</code> type is defined as:</p><pre><code class="language-julia">struct Permission
    create::Bool
    read::Bool
    update::Bool
    delete::Bool
    expiry::DateTime
end</code></pre><p>Permissions created without an expiry are given an (almost) infinite expiry.</p><p>A client can loosely be thought of as a mapping from resources to <code>Permission</code>s.</p><p>More precisely, the mapping is a hierarchy of 3 maps.</p><p>As we move up the hierarchy:</p><ul><li>Each level maps a smaller set of resources to permissions than the previous level.</li><li>The permissions override those specified at the previous level.</li></ul><p>The levels are:</p><ol><li><p>At the bottom of the hierarchy is the map from resource type to permission. This allows the same permission to be applied to all resources with the same type. For example a client may have read-only access to the entire local system. In this case the resources are directories and files and the associated permission is <code>Permission(false, true, false, false, expiry)</code>.</p></li><li><p>In the middle of the hierarchy is the map from resource ID pattern (<code>Regex</code>s) to permission. This mapping overrides the permissions specified in the type-to-permission mapping. Continuing our file system example, the same client could also have write access to a particular directory using this mapping.</p></li><li><p>At the top of the hierarchy is the map from resource ID to permission. This mapping allows access control for specific resources.</p></li></ol><p>This framework allows both fine-grained and somewhat coarse access control within the same client, provided the permissions don&#39;t conflict within a level of the hierarchy (test for conflicts via <code>permissions_conflict(client, resourceid)</code>).</p><p>Here&#39;s a quick sample of the API:</p><pre><code class="language-julia"># Allow cRud (read-only) access without expiry to resources with type resource_type
setpermission!(client, resource_type, Permission(false, true, false, false))

# Allow CRUD (read/write) access for 5 minutes to resources with IDs starting with &quot;mycollection/&quot;
setpermission!(client, r&quot;mycollection/*&quot;, Permission(true, true, true, true, now() + Minute(5)))

p = getpermission(client, resource)  # Get the permission settings for the specific resource
setexpiry!(client, now() + Hour(1))  # Set an expiry for all the resources that the client has access to

haspermission(client, resource, :create)    # True if the client has :create access to the resource
permissions_conflict(client, &quot;myresource&quot;)  # True if the rules that define the client&#39;s access to the resource with ID &quot;myresource&quot; conflict</code></pre><h2><a class="nav-anchor" id="Accessing-Resources-1" href="#Accessing-Resources-1">Accessing Resources</a></h2><p>Use <code>haspermission(client, resource, action)</code> to determine whether the client has permission to act on the resource (create/read/update/delete). Here the <code>action</code> is one of <code>:create</code>, <code>:read</code>, <code>:update</code>, <code>:delete</code>.</p><p>This package also provides <code>create!</code>, <code>read</code>, <code>update!</code> and <code>delete!</code>. Each has the same signature, namely <code>(client, resource, args...)</code>. Each works as follows:</p><ul><li>Check whether the client has permission to act on the resource.<ul><li>If so, act on the resource.<ul><li>If all is well, return <code>nothing</code> when creating/updating/deleting, and return <code>(true, value)</code> when reading</li><li>Else return an error message when creating/updating/deleting, and return <code>(false, error message)</code> when reading</li></ul></li><li>Else return an error message when creating/updating/deleting, and return <code>(false, error message)</code> when reading</li></ul></li></ul><h2><a class="nav-anchor" id="Use-Cases-1" href="#Use-Cases-1">Use Cases</a></h2><h3><a class="nav-anchor" id="Object-Storage-1" href="#Object-Storage-1">Object Storage</a></h3><p>In object storage, data is stored as objects and objects are grouped into buckets. The <a href="https://github.com/JockLawrie/ObjectStores.jl">ObjectStores</a> package defines a common API for object storage that allows the storage back-end to be swapped without changing any code.</p><p>Examples of object stores include:</p><ul><li><a href="https://github.com/JockLawrie/LocalDiskObjectStores.jl">LocalDiskObjectStores.jl</a>, which uses the local file system to store objects (files) in buckets (directories).</li><li><a href="https://github.com/JockLawrie/GCSObjectStores.jl">GCSObjectStores.jl</a>, which uses Google Cloud Storage as the storage back-end.</li></ul><p>This authorization framework is used to control access to buckets and objects.</p><h3><a class="nav-anchor" id="Web-app-authorization-1" href="#Web-app-authorization-1">Web app authorization</a></h3><p>Authorization.jl can be used to implement web-app sessions.</p><p>Suppose a user&#39;s access is determined by his/her subscription to an app. </p><p>Then, for example, <code>setpermission!(client, App, permission)</code> sets permissions for all resources related to the app with type <code>App</code>. Also, <code>setexpiry(client, expiry)</code> can be used to set an expiry on all resources to which the client has access. The client can then be used as the session object. When a request comes in, the client and requested resource can be identified from the request (and perhaps server state). Determining whether the client has permission to access the resource is then a matter of calling <code>haspermission</code>.</p><h2><a class="nav-anchor" id="Developing-a-new-client-1" href="#Developing-a-new-client-1">Developing a new client</a></h2><p>If you are developing a new client for some resources and would like to use this framework:</p><ol><li><p>Ensure that the type of your client is a subtype of <code>AbstractClient</code>. Concrete subtypes are required to include some mandatory fields - see the <code>AbstractClient</code> dosctring. You can also include fields that are specific to your client type.</p></li><li><p>Similarly, ensure that the types of your resources are subtypes of <code>AbstractResource</code>. Also ensure that your concrete subtypes of <code>AbstractResource</code> have an <code>id::String</code> field.</p></li></ol><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
