<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · NeighbourLists.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NeighbourLists.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">NeighbourLists.AbstractIterator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.CellList" href="#NeighbourLists.CellList"><code>NeighbourLists.CellList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CellList</code> : store atoms in cells / bins. Mostly used internally to construct PairLists.</p></div></div></section><pre><code class="language-none">NeighbourLists.MAX_THREADS</code></pre><pre><code class="language-none">NeighbourLists.NBodyIterator</code></pre><pre><code class="language-none">NeighbourLists.NeighbourLists</code></pre><pre><code class="language-none">NeighbourLists.PairIterator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.PairList" href="#NeighbourLists.PairList"><code>NeighbourLists.PairList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PairList</code> stores a neighbourlist as a list of pairs</p><pre><code class="language-none">PairList(X, cutoff, cell, pbc)
PairList(nlist::CellList)</code></pre><p>where</p><ul><li><code>X</code> : positions, either as 3 x N matrix or as <code>Vector{SVec}</code></li><li><code>cutoff</code> : positive real value</li><li><code>cell</code> : 3 x 3 matrix, with rows denoting the cell vectors</li><li><code>pbc</code> : 3-tuple or array, storing periodicity information</li></ul><p><strong>Kw-args:</strong></p><ul><li><code>int_type</code> : default is <code>Int</code></li><li><code>store_first</code> : whether to store the array of first indices, default <code>true</code></li><li><code>sorted</code> : whether to sort the <code>j</code> vector, default <code>false</code></li></ul><p><strong>PairList fields</strong></p><p><code>X, cutoff, i, j, r, R, first</code>, where</p><p><code>(i[n], j[n])</code> denotes the indices of a neighbour pair, <code>r[n]</code> the distance between those atoms, <code>R[n]</code> the vectorial distance, note this is identical to <code>X[i[n]]-X[j[n]]</code> without periodic b.c.s, but with periodic boundary conditions it is different. <code>first[m]</code> contains the index to the first <code>(i[n], j[n])</code> for which <code>i[n] == first[m]</code>, i.e., <code>(j, first)</code> essentially defines a compressed column storage of the adjacancy matrix.</p></div></div></section><pre><code class="language-none">NeighbourLists.SMat</code></pre><pre><code class="language-none">NeighbourLists.SVec</code></pre><pre><code class="language-none">NeighbourLists.SiteIterator</code></pre><pre><code class="language-none">NeighbourLists._celllist_</code></pre><pre><code class="language-none">NeighbourLists._find_neighbours_!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists._find_next_" href="#NeighbourLists._find_next_"><code>NeighbourLists._find_next_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>function _find_next_(j, n, first)</code></p><ul><li><code>j</code> : array of neighbour indices</li><li><code>n</code> : current site index</li><li><code>first</code> : array of first indices</li></ul><p>return the first index <code>first[n] &lt;= m &lt; first[n+1]</code> such that <code>j[m] &gt; n</code>; and returns 0 if no such index exists</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists._fix_cell_" href="#NeighbourLists._fix_cell_"><code>NeighbourLists._fix_cell_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_fix_cell_(X::Vector{SVec{T}}, C::SMat{T}, pbc)</code></p><p>produces new <code>X</code>, <code>C</code> such that PBC are respected, but all positions are inside the cell. This Potentially involves</p><ul><li>wrapping atom positions in the pbc directions</li><li>shifting atom positions in the non-pbc directions</li><li>enlarging the cell</li></ul><p>If either <code>X</code> or <code>C</code> are modified, then they will be copied.</p></div></div></section><pre><code class="language-none">NeighbourLists._item</code></pre><pre><code class="language-none">NeighbourLists._mt_map_!</code></pre><pre><code class="language-none">NeighbourLists._pairlist_</code></pre><pre><code class="language-none">NeighbourLists._sub2ind</code></pre><pre><code class="language-none">NeighbourLists.analyze_cell</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.bin_trunc" href="#NeighbourLists.bin_trunc"><code>NeighbourLists.bin_trunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Map i back to the interval [0,n) by assigning edge value if outside interval</p></div></div><div><div><p>apply bin_trunc only if open bdry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.bin_wrap" href="#NeighbourLists.bin_wrap"><code>NeighbourLists.bin_wrap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Map i back to the interval [0,n) by shifting by integer multiples of n</p></div></div><div><div><p>apply bin_wrap only if periodic bdry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.bin_wrap_or_trunc" href="#NeighbourLists.bin_wrap_or_trunc"><code>NeighbourLists.bin_wrap_or_trunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>applies bin<em>trunc to open bdry and bin</em>wrap to periodic bdry</p></div></div></section><pre><code class="language-none">NeighbourLists.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.get_first" href="#NeighbourLists.get_first"><code>NeighbourLists.get_first</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_first(i::Vector{TI}, nat::Integer) -&gt; first::Vector{TI} where TI &lt;: Integer</code></p><p>Assumes that <code>i</code> is sorted in ascending order. For <code>n = 1, . . ., nat</code>, <code>first[n]</code> will be the index to the first element of <code>i</code> with value <code>n</code>. Further, <code>first[nat+1]</code> will be <code>length(i) + 1</code>.</p><p>If <code>first[n] == first[n+1]</code> then this means that <code>i</code> contains no element <code>n</code>.</p></div></div></section><pre><code class="language-none">NeighbourLists.inc</code></pre><pre><code class="language-none">NeighbourLists.include</code></pre><pre><code class="language-none">NeighbourLists.lengths</code></pre><pre><code class="language-none">NeighbourLists.maptosites!</code></pre><pre><code class="language-none">NeighbourLists.maptosites_d!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.maptosites_d_inner!" href="#NeighbourLists.maptosites_d_inner!"><code>NeighbourLists.maptosites_d_inner!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>mapreduce_antisym!{T}(out::AbstractVector{SVec{T}}, df, it::PairIterator{T})</code></p><p>anti-symmetric variant of <code>mapreduce!{S, T}(out::AbstractVector{S}, ...)</code>, summing only over bonds (i,j) with i &lt; j and adding f(R<em>ij) to site j and -f(R</em>ij) to site i.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.maptosites_inner!" href="#NeighbourLists.maptosites_inner!"><code>NeighbourLists.maptosites_inner!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>mapreduce_sym!{S, T}(out::AbstractVector{S}, f, it::PairIterator{T})</code></p><p>symmetric variant of <code>mapreduce!{S, T}(out::AbstractVector{S}, ...)</code>, summing only over bonds (i,j) with i &lt; j and adding f(R_ij) to both sites i, j.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.max_neigs" href="#NeighbourLists.max_neigs"><code>NeighbourLists.max_neigs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>max_neigs(nlist::PairList) -&gt; Integer</code></p><p>returns the maximum number of neighbours that any atom in the neighbourlist has.</p></div></div></section><pre><code class="language-none">NeighbourLists.mt_split</code></pre><pre><code class="language-none">NeighbourLists.mt_split_interlaced</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.nbodies" href="#NeighbourLists.nbodies"><code>NeighbourLists.nbodies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>nbodies(N, nlist::PairList)</code></p><p>creates an N-body iterator, e.g., <code>nbodies(3, nlist)</code> will create an iterator over permutation-symmetric 3-body terms. Use <code>mapreduce_sym!</code> and <code>map_reduce_sym_d!</code> to carry out the iterations.</p></div></div></section><pre><code class="language-none">NeighbourLists.npairs</code></pre><pre><code class="language-none">NeighbourLists.nsites</code></pre><pre><code class="language-none">NeighbourLists.pairs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.position_to_cell_index" href="#NeighbourLists.position_to_cell_index"><code>NeighbourLists.position_to_cell_index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Map particle position to a (cartesian) cell index</p></div></div></section><pre><code class="language-none">NeighbourLists.set_maxthreads!</code></pre><pre><code class="language-none">NeighbourLists.setup_mt</code></pre><pre><code class="language-none">NeighbourLists.site</code></pre><pre><code class="language-none">NeighbourLists.sites</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NeighbourLists.sort_neigs!" href="#NeighbourLists.sort_neigs!"><code>NeighbourLists.sort_neigs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sort_neigs!(j, r, R, first)</code></p><p>sorts each sub-range of <code>j</code> corresponding to one site  in ascending order and applies the same permutation to <code>r, R, S</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
