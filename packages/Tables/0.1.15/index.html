<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Tables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Tables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#First:-1">First:</a></li><li><a class="toctext" href="#To-support-Rows:-1">To support <code>Rows</code>:</a></li><li><a class="toctext" href="#To-support-Columns:-1">To support <code>Columns</code>:</a></li><li><a class="toctext" href="#Sinks-(transferring-data-from-one-table-to-another)-1">Sinks (transferring data from one table to another)</a></li><li><a class="toctext" href="#Functions-that-input-and-output-tables:-1">Functions that input and output tables:</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h3><a class="nav-anchor" id="Tables.jl-1" href="#Tables.jl-1">Tables.jl</a></h3><p>The Tables.jl package provides simple, yet powerful interface functions for working with all kinds tabular data through predictable access patterns.</p><pre><code class="language-julia">    Tables.rows(table) =&gt; Rows
    Tables.columns(table) =&gt; Columns</code></pre><p>Where <code>Rows</code> and <code>Columns</code> are the duals of each other:</p><ul><li><code>Rows</code> is an iterator of property-accessible objects (any type that supports <code>propertynames(row)</code> and <code>getproperty(row, nm::Symbol</code>)</li><li><code>Columns</code> is a property-accessible object of iterators (i.e. each column is an iterator)</li></ul><p>In addition to these <code>Rows</code> and <code>Columns</code> objects, it&#39;s useful to be able to query properties of these objects:</p><ul><li><code>Tables.schema(x::Union{Rows, Columns}) =&gt; Union{Tables.Schema, Nothing}</code>: returns a <code>Tables.Schema</code> object, or <code>nothing</code> if the table&#39;s schema is unknown</li><li>For the <code>Tables.Schema</code> object:<ul><li>column names can be accessed as a tuple of Symbols like <code>sch.names</code></li><li>column types can be accessed as a tuple of types like <code>sch.types</code></li><li>See <code>?Tables.Schema</code> for more details on this type</li></ul></li></ul><p>A big part of the power in these simple interface functions is that each (<code>Tables.rows</code> &amp; <code>Tables.columns</code>) is defined for any table type, even if the table type only explicitly implements one interface function or the other. This is accomplished by providing performant, generic fallback definitions in Tables.jl itself (though obviously nothing prevents a table type from implementing each interface function directly).</p><p>With these simple definitions, powerful workflows are enabled:</p><ul><li>A package providing data cleansing, manipulation, visualization, or analysis can automatically handle any number of decoupled input table types</li><li>A tabular file format can have automatic integration with in-memory structures and translation to other file formats</li></ul><h1><a class="nav-anchor" id="Tables-Interface-1" href="#Tables-Interface-1">Tables Interface</a></h1><p>So how does one go about satisfying the Tables.jl interface functions? It mainly depends on what you&#39;ve already defined and the natural access patterns of your table:</p><h2><a class="nav-anchor" id="First:-1" href="#First:-1">First:</a></h2><ul><li><code>Tables.istable(::Type{&lt;:MyTable}) = true</code>: this provides an explicit affirmation that your type implements the Tables interface</li></ul><h2><a class="nav-anchor" id="To-support-Rows:-1" href="#To-support-Rows:-1">To support <code>Rows</code>:</a></h2><ul><li>Define <code>Tables.rowaccess(::Type{&lt;:MyTable}) = true</code>: this signals to other types that <code>MyTable</code> supports valid <code>Row</code>-iteration</li><li>Define <code>Tables.rows(x::MyTable)</code>: return a <code>Row</code>-iterator object (perhaps the table itself if already defined)</li><li>Define <code>Tables.schema(Tables.rows(x::MyTable))</code> to either return a <code>Tables.Schema</code> object, or <code>nothing</code> if the schema is unknown or non-inferrable for some reason</li></ul><h2><a class="nav-anchor" id="To-support-Columns:-1" href="#To-support-Columns:-1">To support <code>Columns</code>:</a></h2><ul><li>Define <code>Tables.columnaccess(::Type{&lt;:MyTable}) = true</code>: this signals to other types that <code>MyTable</code> supports returning a valid <code>Columns</code> object</li><li>Define <code>Tables.columns(x::MyTable)</code>: return a <code>Columns</code>, property-accessible object (perhaps the table itself if it naturally supports property-access to columns)</li><li>Define <code>Tables.schema(Tables.columns(x::MyTable))</code> to either return a <code>Tables.Schema</code> object, or <code>nothing</code> if the schema is unknown or non-inferrable for some reason</li></ul><h2><a class="nav-anchor" id="Sinks-(transferring-data-from-one-table-to-another)-1" href="#Sinks-(transferring-data-from-one-table-to-another)-1">Sinks (transferring data from one table to another)</a></h2><p>Another question is how <code>MyTable</code> can be a &quot;sink&quot; for any other table type. The answer is quite simple: use the interface functions!</p><ul><li>Define a function or constructor that takes, at a minimum, a single, untyped argument and then calls <code>Tables.rows</code> or <code>Tables.columns</code> on that argument to construct an instance of <code>MyTable</code></li></ul><p>For example, if <code>MyTable</code> is a row-oriented format, I might define my &quot;sink&quot; function like:</p><pre><code class="language-julia">function MyTable(x)
    Tables.istable(x) || throw(ArgumentError(&quot;MyTable requires a table input&quot;))
    rows = Tables.rows(x)
    sch = Tables.schema(rows)
    names = sch.names
    types = sch.types
    # custom constructor that creates an &quot;empty&quot; MyTable according to given column names &amp; types
    # note that the &quot;unknown&quot; schema case should be considered, i.e. when `sch.types =&gt; nothing`
    mytbl = MyTable(names, types)
    for row in rows
        # a convenience function provided in Tables.jl for &quot;unrolling&quot; access to each column/property of a `Row`
        # it works by applying a provided function to each value; see `?Tables.eachcolumn` for more details
        Tables.eachcolumn(sch, row) do val, col, name
            push!(mytbl[col], val)
        end
    end
    return mytbl
end</code></pre><p>Alternatively, if <code>MyTable</code> is column-oriented, perhaps my definition would be more like:</p><pre><code class="language-julia">function MyTable(x)
    Tables.istable(x) || throw(ArgumentError(&quot;MyTable requires a table input&quot;))
    cols = Tables.columns(x)
    # here we use Tables.eachcolumn to iterate over each column in a `Columns` object
    return MyTable(collect(propertynames(cols)), [collect(col) for col in Tables.eachcolumn(cols)])
end</code></pre><p>Obviously every table type is different, but via a combination of <code>Tables.rows</code> and <code>Tables.columns</code> each table type should be able to construct an instance of itself.</p><h2><a class="nav-anchor" id="Functions-that-input-and-output-tables:-1" href="#Functions-that-input-and-output-tables:-1">Functions that input and output tables:</a></h2><p>For functions that input a table, perform some calculation, and output a new table, we need a way of constructing the preferred output table given the input.  For this purpose, <code>Tables.materializer(table)</code> returns the preferred sink function for a table (<code>Tables.columntable</code>, which creates a named tuple of AbstractVectors, is the default).  </p><p>Note that an in-memory table with a properly defined &quot;sink&quot; function can reconstruct itself with the following:</p><pre><code class="language-julia">materializer(table)(columns(table)) 

materializer(table)(rows(table))</code></pre><p>For example, we may want to select a subset of columns from a column-access table.  One way we could implement it is with the following:</p><pre><code class="language-julia">function select(table, cols::Symbol...)
    Tables.istable(table) || throw(ArgumentError(&quot;select requires a table input&quot;))
    nt = Tables.columntable(table)  # columntable(t) creates a NamedTuple of AbstractVectors
    newcols = NamedTuple{cols}(nt)
    Tables.materializer(table)(newcols)
end

# Example of selecting columns from a columntable
tbl = (x=1:100, y=rand(100), z=randn(100))
select(tbl, :x)
select(tbl, :x, :z)

tbl = [(x=1, y=&quot;a&quot;, z=1.0), (x=2, y=&quot;b&quot;, z=2.0)]
select(tbl, :z, :x)</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
