<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Tables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Tables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Tables.ColumnTable</code></pre><pre><code class="language-none">Tables.ColumnsRow</code></pre><pre><code class="language-none">Tables.EachColumn</code></pre><pre><code class="language-none">Tables.IteratorInterfaceExtensions</code></pre><pre><code class="language-none">Tables.IteratorRow</code></pre><pre><code class="language-none">Tables.IteratorWrapper</code></pre><pre><code class="language-none">Tables.MatrixRow</code></pre><pre><code class="language-none">Tables.MatrixTable</code></pre><pre><code class="language-none">Tables.NamedTupleIterator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.Row" href="#Tables.Row"><code>Tables.Row</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract row type with a simple required interface: row values are accessible via <code>getproperty(row, field)</code>; for example, a NamedTuple like <code>nt = (a=1, b=2, c=3)</code> can access its value for <code>a</code> like <code>nt.a</code> which turns into a call to the function <code>getproperty(nt, :a)</code></p></div></div></section><pre><code class="language-none">Tables.RowIterator</code></pre><pre><code class="language-none">Tables.RowTable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.Schema" href="#Tables.Schema"><code>Tables.Schema</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Tables.Schema(names, types)</code></pre><p>Create a <code>Tables.Schema</code> object that holds the column names and types for a tabular data object. <code>Tables.Schema</code> is dual-purposed: provide an easy interface for users to query these properties, as well as provide a convenient &quot;structural&quot; type for code generation.</p><p>To get a table&#39;s schema, one can call <code>Tables.schema(tbl)</code>, but also note that a table may return <code>nothing</code>, indicating that it&#39;s column names and/or column types are unknown (usually not inferrable). This is similar to the <code>Base.EltypeUnknown()</code> trait for iterators when <code>Base.IteratorEltype</code> is called. Users should account for the <code>Tables.schema(tbl) =&gt; nothing</code> case by using the properties of the results of <code>Tables.rows(x)</code> and <code>Tables.columns(x)</code> directly.</p><p>To access the names, one can simply call <code>sch.names</code> to return the tuple of Symbols. To access column types, one can similarly call <code>sch.types</code>, which will return a tuple of types (like <code>(Int64, Float64, String)</code>).</p><p>The actual type definition is</p><pre><code class="language-julia">struct Schema{names, types} end</code></pre><p>Where <code>names</code> is a tuple of Symbols, and <code>types</code> is a tuple <em>type</em> of types (like <code>Tuple{Int64, Float64, String}</code>). Encoding the names &amp; types as type parameters allows convenient use of the type in generated functions and other optimization use-cases.</p></div></div></section><pre><code class="language-none">Tables.Select</code></pre><pre><code class="language-none">Tables.SelectRow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.Table" href="#Tables.Table"><code>Tables.Table</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The Tables.jl package provides simple, yet powerful interface functions for working with all kinds tabular data through predictable access patterns.</p><pre><code class="language-julia">    Tables.rows(table) =&gt; Rows
    Tables.columns(table) =&gt; Columns</code></pre><p>Where <code>Rows</code> and <code>Columns</code> are the duals of each other:</p><ul><li><code>Rows</code> is an iterator of property-accessible objects (any type that supports <code>propertynames(row)</code> and <code>getproperty(row, nm::Symbol</code>)</li><li><code>Columns</code> is a property-accessible object of iterators (i.e. each column is an iterator)</li></ul><p>In addition to these <code>Rows</code> and <code>Columns</code> objects, it&#39;s useful to be able to query properties of these objects:</p><ul><li><code>Tables.schema(x::Union{Rows, Columns}) =&gt; Union{Tables.Schema, Nothing}</code>: returns a <code>Tables.Schema</code> object, or <code>nothing</code> if the table&#39;s schema is unknown</li><li>For the <code>Tables.Schema</code> object:<ul><li>column names can be accessed as a tuple of Symbols like <code>sch.names</code></li><li>column types can be accessed as a tuple of types like <code>sch.types</code></li><li>See <code>?Tables.Schema</code> for more details on this type</li></ul></li></ul><p>A big part of the power in these simple interface functions is that each (<code>Tables.rows</code> &amp; <code>Tables.columns</code>) is defined for any table type, even if the table type only explicitly implements one interface function or the other. This is accomplished by providing performant, generic fallback definitions in Tables.jl itself (though obviously nothing prevents a table type from implementing each interface function directly).</p><p>With these simple definitions, powerful workflows are enabled:</p><ul><li>A package providing data cleansing, manipulation, visualization, or analysis can automatically handle any number of decoupled input table types</li><li>A tabular file format can have automatic integration with in-memory structures and translation to other file formats</li></ul><p>So how does one go about satisfying the Tables.jl interface functions? It mainly depends on what you&#39;ve already defined and the natural access patterns of your table:</p><p>First:</p><ul><li><code>Tables.istable(::Type{&lt;:MyTable}) = true</code>: this provides an explicit affirmation that your type implements the Tables interface</li></ul><p>To support <code>Rows</code>:</p><ul><li>Define <code>Tables.rowaccess(::Type{&lt;:MyTable}) = true</code>: this signals to other types that <code>MyTable</code> supports valid <code>Row</code>-iteration</li><li>Define <code>Tables.rows(x::MyTable)</code>: return a <code>Row</code>-iterator object (perhaps the table itself if already defined)</li><li>Define <code>Tables.schema(Tables.rows(x::MyTable))</code> to either return a <code>Tables.Schema</code> object, or <code>nothing</code> if the schema is unknown or non-inferrable for some reason</li></ul><p>To support <code>Columns</code>:</p><ul><li>Define <code>Tables.columnaccess(::Type{&lt;:MyTable}) = true</code>: this signals to other types that <code>MyTable</code> supports returning a valid <code>Columns</code> object</li><li>Define <code>Tables.columns(x::MyTable)</code>: return a <code>Columns</code>, property-accessible object (perhaps the table itself if it naturally supports property-access to columns)</li><li>Define <code>Tables.schema(Tables.columns(x::MyTable))</code> to either return a <code>Tables.Schema</code> object, or <code>nothing</code> if the schema is unknown or non-inferrable for some reason</li></ul><p>The final question is how <code>MyTable</code> can be a &quot;sink&quot; for any other table type. The answer is quite simple: use the interface functions!</p><ul><li>Define a function or constructor that takes, at a minimum, a single, untyped argument and then calls <code>Tables.rows</code> or <code>Tables.columns</code> on that argument to construct an instance of <code>MyTable</code></li></ul><p>For example, if <code>MyTable</code> is a row-oriented format, I might define my &quot;sink&quot; function like:</p><pre><code class="language-julia">function MyTable(x)
    Tables.istable(x) || throw(ArgumentError(&quot;MyTable requires a table input&quot;))
    rows = Tables.rows(x)
    sch = Tables.schema(rows)
    names = sch.names
    types = sch.types
    # custom constructor that creates an &quot;empty&quot; MyTable according to given column names &amp; types
    # note that the &quot;unknown&quot; schema case should be considered, i.e. when `sch.types =&gt; nothing`
    mytbl = MyTable(names, types)
    for row in rows
        # a convenience function provided in Tables.jl for &quot;unrolling&quot; access to each column/property of a `Row`
        # it works by applying a provided function to each value; see `?Tables.eachcolumn` for more details
        Tables.eachcolumn(sch, row) do val, col, name
            push!(mytbl[col], val)
        end
    end
    return mytbl
end</code></pre><p>Alternatively, if <code>MyTable</code> is column-oriented, perhaps my definition would be more like:</p><pre><code class="language-julia">function MyTable(x)
    Tables.istable(x) || throw(ArgumentError(&quot;MyTable requires a table input&quot;))
    cols = Tables.columns(x)
    # here we use Tables.eachcolumn to iterate over each column in a `Columns` object
    return MyTable(collect(propertynames(cols)), [collect(col) for col in Tables.eachcolumn(cols)])
end</code></pre><p>Obviously every table type is different, but via a combination of <code>Tables.rows</code> and <code>Tables.columns</code> each table type should be able to construct an instance of itself.</p></div></div></section><pre><code class="language-none">Tables.Tables</code></pre><pre><code class="language-none">Tables.Transforms</code></pre><pre><code class="language-none">Tables.TransformsRow</code></pre><pre><code class="language-none">Tables.__init__</code></pre><pre><code class="language-none">Tables._buildcolumns</code></pre><pre><code class="language-none">Tables._eltype</code></pre><pre><code class="language-none">Tables._types</code></pre><pre><code class="language-none">Tables.add!</code></pre><pre><code class="language-none">Tables.add_or_widen!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.allocatecolumn" href="#Tables.allocatecolumn"><code>Tables.allocatecolumn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Tables.allocatecolumn(::Type{T}, len) =&gt; returns a column type (usually AbstractVector) w/ size to hold `len` elements

Custom column types can override with an appropriate &quot;scalar&quot; element type that should dispatch to their column allocator.</code></pre></div></div></section><pre><code class="language-none">Tables.allocatecolumns</code></pre><pre><code class="language-none">Tables.buildcolumns</code></pre><pre><code class="language-none">Tables.columnaccess</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.columnindex" href="#Tables.columnindex"><code>Tables.columnindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>given names and a Symbol <code>name</code>, compute the index (1-based) of the name in names</p></div></div></section><pre><code class="language-none">Tables.columns</code></pre><pre><code class="language-none">Tables.columntable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.columntype" href="#Tables.columntype"><code>Tables.columntype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>given tuple type and a Symbol <code>name</code>, compute the type of the name in the tuples types</p></div></div></section><pre><code class="language-none">Tables.ctappend</code></pre><pre><code class="language-none">Tables.datavaluetype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.eachcolumn" href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Tables.eachcolumn(f, sch, row, args...)
Tables.eachcolumn(f, names, row, args...)
Tables.eachcolumn(Tables.columns(x))

The first two definitions take a function `f`, table schema `sch` or table&#39;s column names `names` as a tuple of Symbols, a `row` type (that satisfies the Row interface), and any other `args...`;
they generate calls to get the value for each column in the row (`getproperty(row, nm)`) and then calls `f(val, col, name, args...)`, where `f` is the
user-provided function, `val` is a row&#39;s column value, `col` is the column index as an `Int`, and `name` is the row&#39;s column name as a Symbol.

While the first two definitions apply to a `Row` object, the last definition simply returns a property-iterator over a `Columns` object.
For example, one could &quot;collect&quot; every column of a `Columns` object by doing:
```julia
vectors = [collect(col) for col in Tables.eachcolumn(Tables.columns(x))]
```</code></pre></div></div></section><pre><code class="language-none">Tables.eval</code></pre><pre><code class="language-none">Tables.getarray</code></pre><pre><code class="language-none">Tables.getfunc</code></pre><pre><code class="language-none">Tables.haslength</code></pre><pre><code class="language-none">Tables.include</code></pre><pre><code class="language-none">Tables.invalidtable</code></pre><pre><code class="language-none">Tables.istable</code></pre><pre><code class="language-none">Tables.materializer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.matrix" href="#Tables.matrix"><code>Tables.matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Tables.matrix(table)</p><p>Materialize any table source input as a <code>Matrix</code>. If the table column types are not homogenous, they will be promoted to a common type in the materialized <code>Matrix</code>. Note that column names are ignored in the conversion.</p></div></div></section><pre><code class="language-none">Tables.namedtupleiterator</code></pre><pre><code class="language-none">Tables.names</code></pre><pre><code class="language-none">Tables.nondatavaluetype</code></pre><pre><code class="language-none">Tables.rowaccess</code></pre><pre><code class="language-none">Tables.rowcount</code></pre><pre><code class="language-none">Tables.rows</code></pre><pre><code class="language-none">Tables.rowtable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.runlength" href="#Tables.runlength"><code>Tables.runlength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>helper function to calculate a run-length encoding of a tuple type</p></div></div></section><pre><code class="language-none">Tables.schema</code></pre><pre><code class="language-none">Tables.select</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tables.table" href="#Tables.table"><code>Tables.table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Tables.table(m::AbstractMatrix; [header::Vector{Symbol}])</p><p>Wrap an <code>AbstractMatrix</code> (<code>Matrix</code>, <code>Adjoint</code>, etc.) in a <code>MatrixTable</code>, which satisfies the Tables.jl interface. This allows accesing the matrix via <code>Tables.rows</code> and <code>Tables.columns</code>. An optional keyword argument <code>header</code> can be passed as a <code>Vector{Symbol}</code> to be used as the column names. Note that no copy of the <code>AbstractMatrix</code> is made.</p></div></div></section><pre><code class="language-none">Tables.transform</code></pre><pre><code class="language-none">Tables.types</code></pre><pre><code class="language-none">Tables.typesubset</code></pre><pre><code class="language-none">Tables.unweakref</code></pre><pre><code class="language-none">Tables.unweakreftype</code></pre><pre><code class="language-none">Tables.unweakreftypes</code></pre><pre><code class="language-none">Tables.unwrap</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
