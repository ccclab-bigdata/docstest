<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Robotlib.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Robotlib.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.Ai" href="#Robotlib.Ai"><code>Robotlib.Ai</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is a helper method for calibPOE</p></div></div></section><pre><code class="language-none">Robotlib.Calibration</code></pre><pre><code class="language-none">Robotlib.DH</code></pre><pre><code class="language-none">Robotlib.DH2400</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.DH2twistsLPOE" href="#Robotlib.DH2twistsLPOE"><code>Robotlib.DH2twistsLPOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Takes the DH-parameters or a set of nominal transformation matrices and outputs the joint twists in local link frames</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.DH2twistsPOE" href="#Robotlib.DH2twistsPOE"><code>Robotlib.DH2twistsPOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Takes the DH-parameters or a set of nominal transformation matrices and outputs the joint twists in base frame</p></div></div></section><pre><code class="language-none">Robotlib.DH7600</code></pre><pre><code class="language-none">Robotlib.DHYuMi</code></pre><pre><code class="language-none">Robotlib.DHtest</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.Frames" href="#Robotlib.Frames"><code>Robotlib.Frames</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Frames is a module to work with coordinate systems. The central type is the <code>Frame</code> with fields <code>R</code> and <code>t</code> for the rotation matrix and translation vector respectively. Other inportnat important types include <code>Point, Points, Plane</code> and <code>Line</code></p><p>All geometric object types have a reference frame associated with them. When a geometric object is created, the reference frame is specified, e.g., <code>T_RB_T = Frame(T_RB_Tm,&quot;RB&quot;,&quot;T&quot;)</code> is a transformation between frame <code>RB</code> and frame <code>T</code>. When transofrmations are made, the reference frames are updated automatically, e.g., <code>T_RB_SEAM = T_RB_T*T_T_SEAM</code></p><p>Usage:</p><pre><code class="language-julia">using Robotlib.Frames
path = Pkg.dir(&quot;Robotlib&quot;,&quot;src&quot;,&quot;applications&quot;,&quot;frames/&quot;)
add_frame_name!(&quot;SEAM&quot;,&quot;Weld seam frame&quot;)
add_frame_name!(&quot;TAB&quot;,&quot;Table frame&quot;)

T_RB_Tm    = MAT.matread(path*&quot;T_RB_T.mat&quot;)[&quot;T_RB_T&quot;]
T_TF_TCPm  = MAT.matread(path*&quot;T_TF_TCP.mat&quot;)[&quot;T_TF_TCP&quot;]
T_T_TABm   = MAT.matread(path*&quot;T_T_Table.mat&quot;)[&quot;T_T_Table&quot;]

T_RB_T     = Frame(T_RB_Tm,&quot;RB&quot;,&quot;T&quot;)
T_S_D      = Frame(T_TF_TCPm,&quot;S&quot;,&quot;D&quot;)
T_T_TAB    = Frame(T_T_TABm,&quot;T&quot;,&quot;TAB&quot;)

cloud_seam = readcloud(path*&quot;CloudSeam_edge.txt&quot;)
plane_seam = readplane(path*&quot;PlaneSeam_edge.txt&quot;)
cloud_seam_projected = project(plane_seam,cloud_seam)
line_seam  = fitline(cloud_seam_projected)

T_T_SEAM      = framefromfeatures((&quot;z+&quot;,line_seam),(&quot;y-&quot;,plane_seam),cloud_seam_projected[1],&quot;SEAM&quot;)
T_RB_SEAM     = T_RB_T*T_T_SEAM
T_RB_TAB      = T_RB_T*T_T_TAB
T_TAB_SEAM    = inv(T_T_TAB)*T_T_SEAM

cloud_seam_RB = T_RB_T*cloud_seam
cloud_seam_projected_RB = T_RB_T*cloud_seam_projected
plane_seam_RB = T_RB_T*plane_seam
line_seam_RB  = T_RB_T*line_seam

using Plots
default(markersize=1)
plot(Frame(I4,&quot;RB&quot;,&quot;U&quot;),200, label=true)
plot!(cloud_seam_RB)
plot!(cloud_seam_projected_RB)
plot!(line_seam_RB,500,label=&quot;Line seam&quot;)
plot!(plane_seam_RB,200,label=&quot;Plane seam&quot;)
plot!(T_RB_SEAM,200, label=true)
plot!(T_RB_TAB,200, label=true)

xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)
zlabel!(&quot;z&quot;)

MAT.matwrite(path*&quot;T_TAB_SEAM.mat&quot;,[&quot;T_TAB_SEAM&quot; =&gt; T_TAB_SEAM.T])
MAT.matwrite(path*&quot;T_T_SEAM.mat&quot;,[&quot;T_T_SEAM&quot; =&gt; T_T_SEAM.T])
MAT.matwrite(path*&quot;T_RB_TAB.mat&quot;,[&quot;T_RB_TAB&quot; =&gt; T_RB_TAB.T])
println(&quot;Wrote T_TAB_SEAM, T_T_SEAM, T_RB_TAB to files in $path&quot;)</code></pre></div></div></section><pre><code class="language-none">Robotlib.I3</code></pre><pre><code class="language-none">Robotlib.I4</code></pre><pre><code class="language-none">Robotlib.Plot3Smart</code></pre><pre><code class="language-none">Robotlib.Quaternion</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.R2rpy" href="#Robotlib.R2rpy"><code>Robotlib.R2rpy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>R2rpy(R; conv=&quot;xyz&quot;, deg = false)</code></p><p>If <code>conv</code> is not <code>xyz</code>, it will be <code>zyx</code></p><p>returns a vector ∈ R3 or a matrix ∈ R3×N depending on the dimension of the input</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.Rangle" href="#Robotlib.Rangle"><code>Robotlib.Rangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Rangle(R1,R2 = I3,deg = false)</code> calculates the angle between two rotation matrices</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.Robotlib" href="#Robotlib.Robotlib"><code>Robotlib.Robotlib</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This is a library of functions to help out in the Robotlab at LTH The module imports the following files</p><p>include(&quot;utils.jl&quot;)</p><p>include(&quot;DH.jl&quot;)</p><p>include(&quot;kinematics.jl&quot;)</p><p>include(&quot;robotplot.jl&quot;)</p><p>include(&quot;Frames.jl&quot;)</p><p>include(&quot;read_log.jl&quot;)</p><p>include(&quot;csv2mat.jl&quot;)</p><p>include(&quot;posDepFric.jl&quot;)</p><p>The module includes a submodule, Frames, which is aimed at replacing the Nikon K600 software. It supports creation of frames, simple projections, fitting of planes, lines etc. and has a number of plotting options. It must be separately imported with <code>using Robotlib.Frames</code></p><p>The module includes a submodule, Calibration, which includes a number of calibration routines. It must be separately imported with <code>using Robotlib.Calibration</code></p><p>Usage: fkine, ikine, jacobian = get<em>kinematic</em>functions(&quot;yumi&quot;) data = orcalog2mat(pathopen, pathsave) q = getData(&quot;robot_0.*posRawAbs&quot;, data, 1, removeNaN = false)</p><p>For YuMi, joint angles <code>q</code> must be converted to logical order using e.g. abb2logical!(q) You must also consider the base transform of YuMi</p></div></div></section><pre><code class="language-none">Robotlib.Rt2T</code></pre><pre><code class="language-none">Robotlib.T2R</code></pre><pre><code class="language-none">Robotlib.T2t</code></pre><pre><code class="language-none">Robotlib.TrajPlot</code></pre><pre><code class="language-none">Robotlib.TrajPlot3</code></pre><pre><code class="language-none">Robotlib.abb2logical</code></pre><pre><code class="language-none">Robotlib.abb2logical!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.ad" href="#Robotlib.ad"><code>Robotlib.ad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the adjoint of a transformation matrix</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.adi" href="#Robotlib.adi"><code>Robotlib.adi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the adjoint of the inverse of a tranformation matrix T, which is also the inverse of the adjoint of T</p></div></div></section><pre><code class="language-none">Robotlib.basisParametersNd</code></pre><pre><code class="language-none">Robotlib.centralDiff</code></pre><pre><code class="language-none">Robotlib.centraldiff</code></pre><pre><code class="language-none">Robotlib.conformize</code></pre><pre><code class="language-none">Robotlib.csv2mat</code></pre><pre><code class="language-none">Robotlib.dh2Tn</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.dh2Tn!" href="#Robotlib.dh2Tn!"><code>Robotlib.dh2Tn!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes a set of local transformation matrices given the DH-parameters of a robot. Can be sent an optional joint-angle vector and a tool</p></div></div></section><pre><code class="language-none">Robotlib.dir</code></pre><pre><code class="language-none">Robotlib.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.expξ" href="#Robotlib.expξ"><code>Robotlib.expξ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>expξ(xi,q=1.0)</code> calculates the exponential map of a twist with twistcoordinates xi and joint angle q If no angle is given, q=1 is assumed</p></div></div></section><pre><code class="language-none">Robotlib.expξ!</code></pre><pre><code class="language-none">Robotlib.expξ2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.expξ2!" href="#Robotlib.expξ2!"><code>Robotlib.expξ2!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Optimized routine to modify T in place</p></div></div></section><pre><code class="language-none">Robotlib.expω</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.fkineLPOE" href="#Robotlib.fkineLPOE"><code>Robotlib.fkineLPOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fkineLPOE(Tn0,xi,q)</code> Forward kinematics using LPOE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.fkinePOE" href="#Robotlib.fkinePOE"><code>Robotlib.fkinePOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fkinePOE(xi0,q)</code> Forward kinematics using POE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.frictionRBFN" href="#Robotlib.frictionRBFN"><code>Robotlib.frictionRBFN</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>A = frictionRBFN(q, q̇, centers; sigma=zeros(2), normalized=true)</code></p><p>Returns the regressor matrix for position dependent friction estimation</p></div></div></section><pre><code class="language-none">Robotlib.getCenters</code></pre><pre><code class="language-none">Robotlib.getData</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.get_kinematic_functions" href="#Robotlib.get_kinematic_functions"><code>Robotlib.get_kinematic_functions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Run this function with a string representing the robot you want the kinematic functions for, e.g. <code>get_kinematic_functions(&quot;YuMi&quot;)</code> Currently supports YuMi and ABB IRB7600 returns <code>fkine(q), ikine(T,q0), jacobian(q)</code> TODO: implement YuMi<em>left, Yumi</em>right Tbase*ikinePOE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.ikinePOE" href="#Robotlib.ikinePOE"><code>Robotlib.ikinePOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>function ikinePOE(xi,T,q0; maxiter=100, λ = 1e0, tol = 1e-12, verbose = false, adaptive = true)</code> Iterative inverse kinematics <code>λ</code>sets the start value of the regularizing parameter (kind of like inverse step size). Bigger value means slower but more robust convergence, if adaptive is set to true, λ is adapted to speed up convergence.</p></div></div></section><pre><code class="language-none">Robotlib.include</code></pre><pre><code class="language-none">Robotlib.isrot</code></pre><pre><code class="language-none">Robotlib.isse3</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.jacobian" href="#Robotlib.jacobian"><code>Robotlib.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Jn, J0, T, Ti, Tn = jacobian(qin, DH::DH, tool=I4)</code> Calculates the jacobian in base (J0) and tool frame (Jn) as well as the forward kinematics (T), given the joint angles and the DH-parameters</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.jacobianPOE" href="#Robotlib.jacobianPOE"><code>Robotlib.jacobianPOE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>jacobianPOE(q, xi)</code> Returns The jacobian in 1) the base frame, 2) the tool frame. It can most likely be rewritten to be faster.</p></div></div></section><pre><code class="language-none">Robotlib.jacobianPOEb</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.jacobianPOEikine" href="#Robotlib.jacobianPOEikine"><code>Robotlib.jacobianPOEikine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>jacobianPOE(q, xi, T)</code> Returns The jacobian in 1) the base frame, 2) the tool frame and returns the FK. It must be handed a precomputed end transform <code>Tend = expξ2(xi[:,end-1],1)*expξ2(xi[:,end],1)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.logR" href="#Robotlib.logR"><code>Robotlib.logR</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the matrix logarithm of a rotation matrix ∈ SO(3)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.logT" href="#Robotlib.logT"><code>Robotlib.logT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the matrix logarithm of a transformation matrix ∈ SE(3) Does not seem to be very reliable for very small rotations, use logm instead, which is a bit slower.</p></div></div></section><pre><code class="language-none">Robotlib.logical2abb</code></pre><pre><code class="language-none">Robotlib.logical2abb!</code></pre><pre><code class="language-none">Robotlib.mnorm_pdf</code></pre><pre><code class="language-none">Robotlib.orcalog2mat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.plot3smart" href="#Robotlib.plot3smart"><code>Robotlib.plot3smart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>plot3smart(x,args...)</code> Makes a 3d plot of a matrix</p></div></div></section><pre><code class="language-none">Robotlib.plot3smart!</code></pre><pre><code class="language-none">Robotlib.prodad</code></pre><pre><code class="language-none">Robotlib.readmat</code></pre><pre><code class="language-none">Robotlib.rotx</code></pre><pre><code class="language-none">Robotlib.roty</code></pre><pre><code class="language-none">Robotlib.rotz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.rpy2R" href="#Robotlib.rpy2R"><code>Robotlib.rpy2R</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rpy2R(r,p,y,conv=&quot;zyx&quot;)</code> For rpy from ABB robot, use zyx For rpy from Nikon, use xyz</p></div></div></section><pre><code class="language-none">Robotlib.skew</code></pre><pre><code class="language-none">Robotlib.skew!</code></pre><pre><code class="language-none">Robotlib.skew4</code></pre><pre><code class="language-none">Robotlib.skewcoords</code></pre><pre><code class="language-none">Robotlib.smartDiff</code></pre><pre><code class="language-none">Robotlib.testJacobian</code></pre><pre><code class="language-none">Robotlib.testikine</code></pre><pre><code class="language-none">Robotlib.toOrthoNormal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.toOrthoNormal!" href="#Robotlib.toOrthoNormal!"><code>Robotlib.toOrthoNormal!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Takes a matrix R ∈ SO(3) or T ∈ SE(3) and makes the rotational part orthonormal</p></div></div></section><pre><code class="language-none">Robotlib.traj2quat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.trajplot" href="#Robotlib.trajplot"><code>Robotlib.trajplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>trajplot(T,args...)</code> Plots a trajectory of T-matrices in a single plot</p></div></div></section><pre><code class="language-none">Robotlib.trajplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.trajplot3" href="#Robotlib.trajplot3"><code>Robotlib.trajplot3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>plot_traj3(T, ls=&quot;.&quot;, plotFrame = 0)</code> Plots a trajectory of T-matrices in a 3D plot, with otional frames drawn of length <code>plotFrame</code></p></div></div></section><pre><code class="language-none">Robotlib.trajplot3!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.trinv" href="#Robotlib.trinv"><code>Robotlib.trinv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Inverts a transformation matrix ∈ SE(3)</p></div></div></section><pre><code class="language-none">Robotlib.twistcoords</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.xii" href="#Robotlib.xii"><code>Robotlib.xii</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the other helper method for calibPOE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Robotlib.xyθ" href="#Robotlib.xyθ"><code>Robotlib.xyθ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate the (signed) angle around z axis for two rotation (transformation) matrices.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
