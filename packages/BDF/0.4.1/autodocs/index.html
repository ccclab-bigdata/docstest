<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BDF.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BDF.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BDF.BDF</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.decodeStatusChannel" href="#BDF.decodeStatusChannel"><code>BDF.decodeStatusChannel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Decode the information stored in the status channel returned by <code>readBDF</code>.</p><pre><code class="language-julia">decodeStatusChannel(statusChannel)
</code></pre><p><strong>Args:</strong></p><ul><li><code>statusChannel</code>: the status channel as returned by <code>readBDF</code></li></ul><p><strong>Returns:</strong></p><ul><li>decodedStatusChannel: dictionary with five fields<ul><li>newEpoch: boolean array, <code>true</code> when a new epoch is started</li><li>speedMode: int8 array, the current speed mode</li><li>CMSInRange: boolean array, <code>true</code> when CMS is in range</li><li>batteryLow : boolean array, <code>true</code> when battery is low</li><li>isMK2: boolean array, <code>true</code> when system is MK2</li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia">dats, evtTab, trigChan, statusChan = readBDF(&quot;res1.bdf&quot;)
statusChanInfo = decodeStatusChannel(statusChanInfo)
if length(findall(statusChanInfo[&quot;CMSInRange&quot;] .== false)) &gt; 0
   println(&quot;CMS was not in range during at least some portions of the recording&quot;)
else
   println(&quot;CMS was in range during the whole recording&quot;)
end</code></pre></div></div></section><pre><code class="language-none">BDF.eval</code></pre><pre><code class="language-none">BDF.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.readBDF" href="#BDF.readBDF"><code>BDF.readBDF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Read the data from a BDF file</p><pre><code class="language-julia">readBDF(fName; from, to, channels, transposeData)
</code></pre><p><strong>Args:</strong></p><ul><li><code>fName</code>: Name of the BDF file to read.</li><li><code>from</code>: Start time of data chunk to read (seconds).</li><li><code>to</code>: End time of data chunk to read (seconds).</li><li><code>channels</code>: Channels to read (indices or channel names).</li><li><code>transposeData</code>: If <code>true</code>, return transposed version of the <code>dats</code> array. Default is <code>false</code>.</li></ul><p><strong>Returns:</strong></p><ul><li><code>dats::Array{Float32, 2}</code>: The matrix containing the data, this will be a nChannels X nDataPoints matrix if <code>transposeData</code> is <code>false</code> (default).                            If <code>transposeData</code> is <code>true</code>, however, it will be a nDataPoints X nChannels matrix.</li><li>eventTable: dictionary with three fields<ul><li>code: trigger codes</li><li>idx: trigger indexes</li><li>dur: trigger durations</li></ul></li><li>trigChannel: the raw trigger channel</li><li>syscodeChannel: the raw system codes channel</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia">dats, evtTab, trigChan, sysChan = readBDF(&quot;res1.bdf&quot;)
dats, evtTab, trigChan, sysChan = readBDF(&quot;res1.bdf&quot;, channels=[1,3]) #read only channels 1 and 3
dats, evtTab, trigChan, sysChan = readBDF(&quot;res1.bdf&quot;, channels=[&quot;Fz&quot;,&quot;RM&quot;]) #read only channels Fz and RM
dats, evtTab, trigChan, sysChan = readBDF(&quot;res1.bdf&quot;, transposeData=true) #return transposed data matrix (i.e. nDataPoints X nChannels)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.readBDFHeader" href="#BDF.readBDFHeader"><code>BDF.readBDFHeader</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Read the header of a BDF file</p><pre><code class="language-julia">readBDFHeader(fName)
</code></pre><p><strong>Args:</strong></p><ul><li>fName: Name of the BDF file to read.</li></ul><p><strong>Returns:</strong></p><ul><li><code>bdfInfo::Dict{ASCIIString,Any}</code>: dictionary with the following fields:<ul><li><code>idCode::ASCIIString</code>: Identification code</li><li><code>subjID::</code>ASCIIString`: Local subject identification</li><li><code>recID::ASCIIString</code>: Local recording identification</li><li><code>startDate::ASCIIString</code>: Recording start date</li><li><code>startTime::ASCIIString</code>: Recording start time</li><li><code>nBytes::Int</code>: Number of bytes occupied by the BDF header</li><li><code>versionDataFormat::ASCIIString</code>: Version of data format</li><li><code>nDataRecords::Int</code>: Number of data records &quot;-1&quot; if unknown</li><li><code>recordDuration::FloatingPoint</code>: Duration of a data record, in seconds</li><li><code>nChannels::Int</code>: Number of channels in data record</li><li><code>chanLabels::Array{ASCIIString,1}</code>: Channel labels</li><li><code>transducer::Array{ASCIIString,1}</code>: Transducer type</li><li><code>physDim::ASCIIString</code>: Physical dimension of channels</li><li><code>physMin::Array{Int64,1}</code>: Physical minimum in units of physical dimension</li><li><code>physMax::Array{Int64,1}</code>: Physical maximum in units of physical dimension</li><li><code>digMin::Array{Int64,1}</code>: Digital minimum</li><li><code>digMax::Array{Int64,1}</code>: Digital maximum</li><li><code>prefilt::Array{ASCIIString,1}</code>: Prefiltering</li><li><code>nSampRec::Array{Int64,1}</code>: Number of samples in each data record</li><li><code>reserved::Array{ASCIIString,1}</code>: Reserved</li><li><code>scaleFactor::Array{Float32,1}</code>: Scaling factor for digital to physical dimension</li><li><code>sampRate::Array{Int64,1}</code>: Recording sampling rate</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">bdfInfo = readBDFHeader(&quot;res1.bdf&quot;)
sampRate = bdfInfo[&quot;sampRate&quot;][1]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.splitBDFAtTime" href="#BDF.splitBDFAtTime"><code>BDF.splitBDFAtTime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split a BDF file at one or more time points into multiple files.</p><pre><code class="language-julia">splitBDFAtTime(fName, timeSeconds; from, to)
</code></pre><p><strong>Args:</strong></p><ul><li><code>fName</code>: Name of the BDF file to split.</li><li><code>timeSeconds</code>: array listing the time(s) at which the BDF file should be split, in seconds. This can be either a single number or an array of time points.</li><li><code>from</code>: Start time of data chunk to read (seconds).</li><li><code>to</code>: End time of data chunk to read (seconds).</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia">splitBDFAtTime(&quot;res1.bdf&quot;, 50)
splitBDFAtTime(&quot;res2.bdf&quot;, [50, 100, 150])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.splitBDFAtTrigger" href="#BDF.splitBDFAtTrigger"><code>BDF.splitBDFAtTrigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split a BDF file at points marked by a trigger into multiple files.</p><pre><code class="language-julia">splitBDFAtTrigger(fName, trigger; from, to, minTrigDur)
</code></pre><p><strong>Args:</strong></p><ul><li><code>fName</code>: Name of the BDF file to split.</li><li><code>trigger</code>: The trigger marking the split points.</li><li><code>from</code>: Start time of data chunk to read (seconds).</li><li><code>to</code>: End time of data chunk to read (seconds).</li><li><code>minTrigDur</code>: minimum duration of the trigger event, in seconds. Certain custom hardware configuration can generate spurious triggers that have a very short duration. The function will only split the file a triggers that last at least as long as <code>minTrigDur</code>, allowing to filter out spurious short triggers.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia">splitBDFAtTrigger(&quot;res1.bdf&quot;, 202)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BDF.writeBDF" href="#BDF.writeBDF"><code>BDF.writeBDF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Write a BDF file</p><pre><code class="language-julia">writeBDF(fName, data, trigChan, statusChan, sampRate; subjID, recID, startDate, startTime, versionDataFormat, chanLabels, transducer, physDim, physMin, physMax, prefilt, reserved)
</code></pre><p><strong>Args:</strong></p><ul><li><code>fName</code>: Name of the BDF file to write.</li><li><code>data</code>: The nChannelsXnDataPoints array to be written to the BDF file</li><li><code>trigChan</code>: The triggers to be written to the BDF file (1XnDataPoints)</li><li><code>statusChan</code>: The status channel codes to be written to the BDF file (1XnDataPoints)</li><li><code>sampRate</code>: The sampling rate of the recording</li><li><code>subjID</code>: Subject identifier (80 characters max)</li><li><code>recID</code>: Recording identifier (80 characters max)</li><li><code>startDate</code>: Start date in &quot;dd.mm.yy&quot; format</li><li><code>startTime</code>: Start time in &quot;hh.mm.ss&quot; format</li><li><code>versionDataFormat</code>: Version of data format</li><li><code>chanLabels</code>: Array of channel labels (1 for each channel)</li><li><code>transducer</code>: Array of transducer type (1 for each channel)</li><li><code>physDim</code>: Array of physical dimension of channels (1 for each channel)</li><li><code>physMin</code>: Array of physical minimum in units of physical dimension (1 for each channel)</li><li><code>physMax</code>: Array of physical maximum in units of physical dimension (1 for each channel)</li><li><code>prefilt</code>: Array of prefilter settings (1 for each channel)</li><li><code>reserved</code>: Array of &quot;reserved&quot; field (1 for each data channel + 1 for the status channel)</li></ul><p><strong>Notes:</strong></p><p>Only the first five arguments are required. The other arguments are optional and the corresponding BDF fields will be left empty or filled with defaults arguments.</p><p>Data records are written in 1-second units. If the number of data points passed to <code>writeBDF</code> is not an integer multiple of the sampling rate the data array, as well as the trigger and status channel arrays will be padded with zeros to fill the last data record before it is written to disk.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">sampRate = 2048
dats = rand(2, sampRate*10)
trigs = rand(1:255, sampRate*10)
statChan = rand(1:255, sampRate*10)
writeBDF(&quot;bdfRec.bdf&quot;, dats, trigs, statChan, sampRate)

#add date and time info
writeBDF(&quot;bdfRec.bdf&quot;, dats, trigs, statChan, sampRate, startDate=&quot;23.06.14&quot;,
startTime=&quot;10.18.19&quot;)</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
