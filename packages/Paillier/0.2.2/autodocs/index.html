<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Paillier.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Paillier.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Paillier.Ciphertext</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.Encoded" href="#Paillier.Encoded"><code>Paillier.Encoded</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A datatype for a <strong>plaintext</strong> encoded number. Returned by the <code>encode</code> methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.Encoding" href="#Paillier.Encoding"><code>Paillier.Encoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Encoding(::DataType, ::PublicKey)
Encoding(::DataType, ::PublicKey, base::Int64)</code></pre><p>A datatype for describing an encoding scheme.</p><p>The public key is included as the encoding is effected by the maximum representable integer which varies with the <code>public_key</code>. Although I could be convinced to change this.</p><p><strong>Examples</strong></p><p>Setting a base value is optional:</p><pre><code class="language-none">julia&gt; encoding = Encoding(Float64, public_key, 64)</code></pre><p>Full example showing homomorphic operations on floating point numbers:</p><pre><code class="language-julia-repl">julia&gt; keysize = 2048
julia&gt; publickey, privatekey = generate_paillier_keypair(keysize)
julia&gt; encoding = Encoding(Float32, publickey)
julia&gt; a = Float32(π)
julia&gt; enc1 = encode_and_encrypt(a, encoding)
julia&gt; decrypt_and_decode(privatekey, enc1)
3.1415927f0
julia&gt; enc1.exponent
-6
julia&gt; b = 100
julia&gt; enc2 = encode_and_encrypt(b, encoding)
julia&gt; decrypt_and_decode(privatekey, enc1 + enc2)
103.141594f0
julia&gt; decrypt_and_decode(privatekey, enc1 - 20.0)
-16.858408f0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.Encrypted" href="#Paillier.Encrypted"><code>Paillier.Encrypted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Encrypted(ciphertext, public_key)</code></pre><p>An <code>Encrypted</code> is the <code>Paillier.jl</code> library&#39;s low level encrypted type. This simple object that includes the <code>ciphertext</code>, <code>public_key</code> and tracks whether obfuscation has occurred (assumed as <code>false</code> if not provided).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.EncryptedArray" href="#Paillier.EncryptedArray"><code>Paillier.EncryptedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EncryptedArray</code></pre><p>A vector version of <a href="#Paillier.EncryptedNumber"><code>EncryptedNumber</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.EncryptedNumber" href="#Paillier.EncryptedNumber"><code>Paillier.EncryptedNumber</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EncryptedNumber(::Encrypted, ::Encoding, exponent::Int64)
EncryptedNumber(::Encoded, ::PublicKey)</code></pre><p>Datatype for representing an encrypted (and <a href="#Paillier.Encoded"><code>Encoded</code></a>) number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; EncryptedNumber(encoded_number, public_key)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.Paillier" href="#Paillier.Paillier"><code>Paillier.Paillier</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>module Paillier</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pub, priv = generate_paillier_keypair(1024)
julia&gt; c = encrypt(pub, 10)
julia&gt; decrypt(priv, add(pub, c, encrypt(pub, 20)))
30</code></pre></div></div></section><pre><code class="language-none">Paillier.PrivateKey</code></pre><pre><code class="language-none">Paillier.PublicKey</code></pre><pre><code class="language-none">Paillier._encrypt_encoded</code></pre><pre><code class="language-none">Paillier._multiply_via_inversion</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.decode" href="#Paillier.decode"><code>Paillier.decode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">decode(encoded::Encoded)
decode(encoded::BigInt, exponent::Int64, encoding::Encoding)</code></pre><p>The inverse of <a href="#Paillier.encode"><code>encode</code></a>, computes the decoding of the <code>Encoded</code> integer representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.decrease_exponent_to" href="#Paillier.decrease_exponent_to"><code>Paillier.decrease_exponent_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">decrease_exponent_to(enc, new_exponent)</code></pre><p>Compute an <a href="#Paillier.EncryptedNumber"><code>EncryptedNumber</code></a> with the same value but a lower exponent.</p><p>We multiply the <em>encoded</em> value by the <code>Encoding.base</code> and decrement the <code>EncryptedNumber.exponent</code> - such that the decoded value remains the same.</p><p>We can keep ratcheting down the <a href="#Paillier.EncryptedNumber"><code>EncryptedNumber</code></a>&#39;s exponent until the encoded integer overflows. <strong>This overflow may not be caught</strong>.</p><p>There is also a (much faster) version that acts on <a href="@ref"><code>EncodedNumber</code></a>s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.decrypt" href="#Paillier.decrypt"><code>Paillier.decrypt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">decrypt(private_key, ciphertext::Ciphertext)
decrypt(private_key, ciphertext::Encrypted)</code></pre><p>The inverse of <a href="#Paillier.encrypt"><code>encrypt</code></a>, uses the <code>private_key</code> to decrypt an encrypted message (<code>ciphertext</code>) to a positive integer less than <code>public_key.n</code>. The result is always a <code>BigInt</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; publickey, privatekey = generate_paillier_keypair(128)
julia&gt; ciphertext = encrypt(publickey, 10)
julia&gt; decrypt(privatekey, ciphertext)
10</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.decrypt_and_decode" href="#Paillier.decrypt_and_decode"><code>Paillier.decrypt_and_decode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">decrypt_and_decode(privatekey::PrivateKey, enc::EncryptedNumber)</code></pre><p>Decrypt an <code>EncryptedNumber</code> using the given <code>PrivateKey</code> and decode it using the <code>EncryptedNumber</code>&#39;s encoding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.encode" href="#Paillier.encode"><code>Paillier.encode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">encode(::Number, ::Encoding)
encode(::Number, ::Encoding, exponent::Int64)</code></pre><p>Encode a number <strong>but don&#39;t encrypt it</strong> for the given <code>Encoding</code> - producing an <code>Encoded</code>. See <a href="#Paillier.encode_and_encrypt"><code>encode_and_encrypt</code></a> for a method that also encrypts. If the exponent is not provided we attempt to match the precision of the passed julia type. See <a href="#Paillier.decode"><code>decode</code></a> to go the other direction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.encode_and_encrypt" href="#Paillier.encode_and_encrypt"><code>Paillier.encode_and_encrypt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">encode_and_encrypt(plaintext::Number, encoding::Encoding)</code></pre><p>Encode the <code>plaintext</code> number using given <code>encoding</code> and encrypt using the <code>PublicKey</code> from the <code>encoding</code>.</p></div></div><div><div><pre><code class="language-none">encode_and_encrypt(xs::Array{&lt;:Number}, encoding::Encoding)
encode_and_encrypt(xs::Array{&lt;:Number}, encoding::Encoding, exponent::Int64)</code></pre><p>Create an EncryptedArray of your plaintext numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.encrypt" href="#Paillier.encrypt"><code>Paillier.encrypt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">encrypt(public_key, message)</code></pre><p>Encrypt a message with a given public key and return an <a href="#Paillier.Encrypted"><code>Encrypted</code></a>. The <code>message</code> must be a positive integer under <code>public_key.n</code> - following Julia&#39;s Int64 type <strong>larger numbers will wrap around and not throw an error</strong>.</p><p>See <a href="#Paillier.decrypt"><code>decrypt</code></a> if you&#39;d like your original message back.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.encrypt_raw" href="#Paillier.encrypt_raw"><code>Paillier.encrypt_raw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">encrypt_raw(public_key, message)</code></pre><p>Internal version of <code>encrypt</code> that returns the raw <a href="@ref"><code>Ciphertext</code></a> - which is just a <code>BigInt</code>. Note this includes <strong>obfuscation</strong> so a directly encrypted unsigned integer is safe to share.</p></div></div></section><pre><code class="language-none">Paillier.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.find_ea" href="#Paillier.find_ea"><code>Paillier.find_ea</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>A = find_ea(As)</code> returns the first EncryptedArray among the arguments.</p></div></div></section><pre><code class="language-none">Paillier.generate_paillier_keypair</code></pre><pre><code class="language-none">Paillier.include</code></pre><pre><code class="language-none">Paillier.intrep</code></pre><pre><code class="language-none">Paillier.match_exponents</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.max_int" href="#Paillier.max_int"><code>Paillier.max_int</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">max_int(::PublicKey)</code></pre><p>The maximum signed integer for our encoding system. We use a full third of the range for overflow detection.</p></div></div></section><pre><code class="language-none">Paillier.n_bit_random_number</code></pre><pre><code class="language-none">Paillier.nbit_prime_of_size</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Paillier.obfuscate" href="#Paillier.obfuscate"><code>Paillier.obfuscate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">obfuscate(encrypted)</code></pre><p>Salt the <code>Encrypted</code> with a new random number. Required before sharing ciphertexts with another party.</p></div></div></section><pre><code class="language-none">Paillier.random_lt_n</code></pre><pre><code class="language-none">Paillier.raw_add</code></pre><pre><code class="language-none">Paillier.raw_multiply</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
