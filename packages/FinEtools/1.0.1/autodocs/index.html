<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FinEtools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ASSEMBLY" href="#FinEtools.MeshExportModule.ASSEMBLY"><code>FinEtools.MeshExportModule.ASSEMBLY</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*ASSEMBLY</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.AbaqusExporter" href="#FinEtools.MeshExportModule.AbaqusExporter"><code>FinEtools.MeshExportModule.AbaqusExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbaqusExporter</code></pre><p>Export mesh to Abaqus.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AlgoAcoustModule" href="#FinEtools.AlgoAcoustModule"><code>FinEtools.AlgoAcoustModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">AlgoAcoustModule</code></pre><p>Module for linear acoustics algorithms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AlgoBaseModule" href="#FinEtools.AlgoBaseModule"><code>FinEtools.AlgoBaseModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">AlgoBaseModule</code></pre><p>Module for base  algorithms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AlgoDeforLinearModule" href="#FinEtools.AlgoDeforLinearModule"><code>FinEtools.AlgoDeforLinearModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">AlgoDeforLinearModule</code></pre><p>Module for algorithms used in linear deformation models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AlgoHeatDiffModule" href="#FinEtools.AlgoHeatDiffModule"><code>FinEtools.AlgoHeatDiffModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">AlgoHeatDiffModule</code></pre><p>Module for algorithms in linear heat conduction/diffusion  models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule" href="#FinEtools.AssemblyModule"><code>FinEtools.AssemblyModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">AssemblyModule</code></pre><p>Module for assemblers  of system matrices and vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.BEGIN_BULK" href="#FinEtools.MeshExportModule.BEGIN_BULK"><code>FinEtools.MeshExportModule.BEGIN_BULK</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">BEGIN_BULK(self::NASTRANExporter)</code></pre><p>Terminate the Case Control section by starting the bulk section.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.BOUNDARY" href="#FinEtools.MeshExportModule.BOUNDARY"><code>FinEtools.MeshExportModule.BOUNDARY</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">BOUNDARY(self::AbaqusExporter, NSET::AbstractString,
    is_fixed::AbstractArray{B,2},  fixed_value::AbstractArray{F,2}) where {B, F}</code></pre><p>Write out the <code>*BOUNDARY</code> option.</p><p><code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, <code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed</p></div></div><div><div><pre><code class="language-none">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at zero for a node set.</p><p>Invoke at Level: Model,  Step</p><p><code>NSET</code>= node set, <code>dof</code>=Degree of freedom, 1, 2, 3</p></div></div><div><div><pre><code class="language-none">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  value::F) where {F}</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at nonzero value for a node set.</p><p><code>NSET</code>= node set, <code>dof</code>=Degree of freedom, 1, 2, 3</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.DeforModelRedModule.Blmat!" href="#FinEtools.DeforModelRedModule.Blmat!"><code>FinEtools.DeforModelRedModule.Blmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Blmat!(MR::Type{DeforModelRed1D}, B::FFltMat,
  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)</code></pre><p>Compute the strain-displacement matrix for a one-manifold element.</p><p>Compute the linear, displacement independent, strain-displacement matrix for a one-manifold element.   <em>The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.</em></p><ul><li><code>N</code> =matrix of basis function values</li><li><code>gradN</code> =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation</li><li><code>c</code> =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.</li><li><code>Rm</code> =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. <code>size(Rm)= (ndim,mdim)</code>, where <code>ndim</code> = number of spatial dimensions of the embedding space (here <code>ndim &lt;=  3</code>), and <code>mdim</code> = number of manifold dimensions (here <code>mdim == 1</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>B</code> = strain-displacement matrix, where  <code>size(B) = (nstressstrain,nnodes*dim)</code>; here <code>nstressstrain</code>= number of strains, <code>dim</code> = Number of spatial dimensions of the embedding space, and <code>nnodes</code> = number of finite element nodes on the element. The strain components are ordered as shown  in <code>stresscomponentmap</code>. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.</li></ul></div></div><div><div><pre><code class="language-none">Blmat!(MR::Type{DeforModelRed2DStrain}, B::FFltMat,
  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)</code></pre><p>Compute the strain-displacement matrix for a two-manifold element for plane-strain models.</p><p>Compute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-strain setting.   <em>The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.</em></p><ul><li><code>N</code> =matrix of basis function values</li><li><code>gradN</code> =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation</li><li><code>c</code> =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.</li><li><code>Rm</code> =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. <code>size(Rm)= (ndim,mdim)</code>, where <code>ndim</code> = number of spatial dimensions of the embedding space (here <code>ndim &lt;=  3</code>), and <code>mdim</code> = number of manifold dimensions (here <code>mdim == 2</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>B</code> = strain-displacement matrix, where  <code>size(B) = (nstressstrain,nnodes*dim)</code>; here <code>nstressstrain</code>= number of strains, <code>dim</code> = Number of spatial dimensions of the embedding space, and <code>nnodes</code> = number of finite element nodes on the element. The strain components are ordered as shown  in <code>stresscomponentmap</code>. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.</li></ul></div></div><div><div><pre><code class="language-none">Blmat!(MR::Type{DeforModelRed2DStress}, B::FFltMat,
  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)</code></pre><p>Compute the strain-displacement matrix for a two-manifold element for plane-stress models.</p><p>Compute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-stress setting.   <em>The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.</em></p><ul><li><code>N</code> =matrix of basis function values</li><li><code>gradN</code> =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation</li><li><code>c</code> =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.</li><li><code>Rm</code> =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. <code>size(Rm)= (ndim,mdim)</code>, where <code>ndim</code> = number of spatial dimensions of the embedding space (here <code>ndim &lt;=  3</code>), and <code>mdim</code> = number of manifold dimensions (here <code>mdim == 2</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>B</code> = strain-displacement matrix, where  <code>size(B) = (nstressstrain,nnodes*dim)</code>; here <code>nstressstrain</code>= number of strains, <code>dim</code> = Number of spatial dimensions of the embedding space, and <code>nnodes</code> = number of finite element nodes on the element. The strain components are ordered as shown  in <code>stresscomponentmap</code>. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.</li></ul></div></div><div><div><pre><code class="language-none">Blmat!(MR::Type{DeforModelRed2DAxisymm}, B::FFltMat,
  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)</code></pre><p>Compute the strain-displacement matrix for a two-manifold element for axially symmetric models.</p><p>Compute the linear, displacement independent, strain-displacement matrix for a two-manifold element in axially-symmetric setting.   <em>The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.</em></p><ul><li><code>N</code> =matrix of basis function values</li><li><code>gradN</code> =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation</li><li><code>c</code> =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.</li><li><code>Rm</code> =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. <code>size(Rm)= (ndim,mdim)</code>, where <code>ndim</code> = number of spatial dimensions of the embedding space (here <code>ndim &lt;=  3</code>), and <code>mdim</code> = number of manifold dimensions (here <code>mdim == 2</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>B</code> = strain-displacement matrix, where  <code>size(B) = (nstressstrain,nnodes*dim)</code>; here <code>nstressstrain</code>= number of strains, <code>dim</code> = Number of spatial dimensions of the embedding space, and <code>nnodes</code> = number of finite element nodes on the element. The strain components are ordered as shown  in <code>stresscomponentmap</code>. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.</li></ul></div></div><div><div><pre><code class="language-none">Blmat!(MR::Type{DeforModelRed3D}, B::FFltMat,
  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)</code></pre><p>Compute the strain-displacement matrix for a three-manifold element.</p><p>Compute the linear, displacement independent, strain-displacement matrix for a three-manifold element.   <em>The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.</em></p><ul><li><code>N</code> =matrix of basis function values</li><li><code>gradN</code> =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation</li><li><code>c</code> =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.</li><li><code>Rm</code> =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. <code>size(Rm)= (ndim,mdim)</code>, where <code>ndim</code> = number of spatial dimensions of the embedding space (here <code>ndim ==   3</code>), and <code>mdim</code> = number of manifold dimensions (here <code>mdim == 3</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>B</code> = strain-displacement matrix, where  <code>size(B) = (nstressstrain,nnodes*dim)</code>; here <code>nstressstrain</code>= number of strains, <code>dim</code> = Number of spatial dimensions of the embedding space, and <code>nnodes</code> = number of finite element nodes on the element. The strain components are ordered as shown  in <code>stresscomponentmap</code>. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule" href="#FinEtools.BoxModule"><code>FinEtools.BoxModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">BoxModule</code></pre><p>Module for working with bounding boxes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.CEND" href="#FinEtools.MeshExportModule.CEND"><code>FinEtools.MeshExportModule.CEND</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CEND(self::NASTRANExporter)</code></pre><p>Terminate the Executive Control section.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.CLOAD" href="#FinEtools.MeshExportModule.CLOAD"><code>FinEtools.MeshExportModule.CLOAD</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>NSET=Node set dof= 1, 2, 3, magnitude= signed multiplier</p></div></div><div><div><pre><code class="language-none">CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>nodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.COMMENT" href="#FinEtools.MeshExportModule.COMMENT"><code>FinEtools.MeshExportModule.COMMENT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">COMMENT(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>**</code> comment option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys" href="#FinEtools.CSysModule.CSys"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for coordinate system transformations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule" href="#FinEtools.CSysModule"><code>FinEtools.CSysModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">CSysModule</code></pre><p>Module for management of coordinate systems.</p></div></div></section><pre><code class="language-none">FinEtools.CTETRA</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.DENSITY" href="#FinEtools.MeshExportModule.DENSITY"><code>FinEtools.MeshExportModule.DENSITY</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">DENSITY(self::AbaqusExporter, rho)</code></pre><p>Write out the <code>*DENSITY</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.DLOAD" href="#FinEtools.MeshExportModule.DLOAD"><code>FinEtools.MeshExportModule.DLOAD</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">DLOAD(self::AbaqusExporter, ELSET::AbstractString,
  traction::AbstractVector{F}) where {F}</code></pre><p>Write out the <code>*DLOAD</code> option.</p></div></div></section><pre><code class="language-none">FinEtools.DeforModelRed</code></pre><pre><code class="language-none">FinEtools.DeforModelRed1D</code></pre><pre><code class="language-none">FinEtools.DeforModelRed2DAxisymm</code></pre><pre><code class="language-none">FinEtools.DeforModelRed2DStrain</code></pre><pre><code class="language-none">FinEtools.DeforModelRed2DStress</code></pre><pre><code class="language-none">FinEtools.DeforModelRed3D</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.DeforModelRedModule" href="#FinEtools.DeforModelRedModule"><code>FinEtools.DeforModelRedModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">DeforModelRedModule</code></pre><p>Module for  model reduction in models of deformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ELASTIC" href="#FinEtools.MeshExportModule.ELASTIC"><code>FinEtools.MeshExportModule.ELASTIC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,
  G12::F, G13::F, G23::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ENGINEERING CONSTANTS</code> option.</p></div></div><div><div><pre><code class="language-none">ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ISOTROPIC</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ELEMENT" href="#FinEtools.MeshExportModule.ELEMENT"><code>FinEtools.MeshExportModule.ELEMENT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,
  start::Integer, conn::AbstractArray{T, 2}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELEMENT</code> option.</p><p><code>TYPE</code>= element type code, <code>ELSET</code>= element set to which the elements belong, <code>start</code>= start the element numbering at this integer, <code>conn</code>= connectivity array for the elements, one row per element</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ELSET_ELSET" href="#FinEtools.MeshExportModule.ELSET_ELSET"><code>FinEtools.MeshExportModule.ELSET_ELSET</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELSET</code> option.</p><p><code>ELSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.EL_PRINT" href="#FinEtools.MeshExportModule.EL_PRINT"><code>FinEtools.MeshExportModule.EL_PRINT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)</code></pre><p>Write out the <code>*EL PRINT</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ENDDATA" href="#FinEtools.MeshExportModule.ENDDATA"><code>FinEtools.MeshExportModule.ENDDATA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ENDDATA(self::NASTRANExporter)</code></pre><p>Terminate the bulk section.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.END_ASSEMBLY" href="#FinEtools.MeshExportModule.END_ASSEMBLY"><code>FinEtools.MeshExportModule.END_ASSEMBLY</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">END_ASSEMBLY(self::AbaqusExporter)</code></pre><p>Write out the <code>*END ASSEMBLY</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.END_INSTANCE" href="#FinEtools.MeshExportModule.END_INSTANCE"><code>FinEtools.MeshExportModule.END_INSTANCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">END_INSTANCE(self::AbaqusExporter)</code></pre><p>Write out the <code>*END INSTANCE</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.END_PART" href="#FinEtools.MeshExportModule.END_PART"><code>FinEtools.MeshExportModule.END_PART</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">END_PART(self::AbaqusExporter)</code></pre><p>Write out the <code>*END PART</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.END_STEP" href="#FinEtools.MeshExportModule.END_STEP"><code>FinEtools.MeshExportModule.END_STEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">END_STEP(self::AbaqusExporter)</code></pre><p>Write out the <code>*END STEP</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ENERGY_PRINT" href="#FinEtools.MeshExportModule.ENERGY_PRINT"><code>FinEtools.MeshExportModule.ENERGY_PRINT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ENERGY_PRINT(self::AbaqusExporter)</code></pre><p>Write out the <code>*ENERGY PRINT</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.EXPANSION" href="#FinEtools.MeshExportModule.EXPANSION"><code>FinEtools.MeshExportModule.EXPANSION</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">EXPANSION(self::AbaqusExporter, CTE::F) where {F}</code></pre><p>Write out the <code>*EXPANSION</code> option.</p></div></div></section><pre><code class="language-none">FinEtools.ElementSizeWeightFunction</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField" href="#FinEtools.ElementalFieldModule.ElementalField"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ElementalField{T&lt;:Number}</code></pre><p>Elemental field.</p><p>The values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule" href="#FinEtools.ElementalFieldModule"><code>FinEtools.ElementalFieldModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">ElementalFieldModule</code></pre><p>Module for elemental fields.</p></div></div></section><pre><code class="language-none">FinEtools.FCplxFlt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FTypesModule.FDataDict" href="#FinEtools.FTypesModule.FDataDict"><code>FinEtools.FTypesModule.FDataDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FDataDict = Dict{String, Any}</code></pre><p>Type for the model-data packaging system (used by all FinEtools algorithms).  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMAbstractBase" href="#FinEtools.FEMMBaseModule.FEMMAbstractBase"><code>FinEtools.FEMMBaseModule.FEMMAbstractBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMAbstractBase</code></pre><p>Abstract base type for all finite element models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.FEMMAcoust" href="#FinEtools.FEMMAcoustModule.FEMMAcoust"><code>FinEtools.FEMMAcoustModule.FEMMAcoust</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMAcoust{S&lt;:FESet}</code></pre><p>Type for linear acoustics finite element modeling machine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule" href="#FinEtools.FEMMAcoustModule"><code>FinEtools.FEMMAcoustModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMAcoustModule</code></pre><p>Module for operations on interiors of domains to construct system matrices and system vectors for linear acoustics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf" href="#FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf"><code>FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMAcoustSurf{S&lt;:FESet, F&lt;:Function, M} &lt;: FEMMAbstractBase</code></pre><p>Class for linear acoustics finite element modeling machine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule" href="#FinEtools.FEMMAcoustSurfModule"><code>FinEtools.FEMMAcoustSurfModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMAcoustSurfModule</code></pre><p>Module for operations on boundaries of domains to construct system matrices and system vectors for linear acoustics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase" href="#FinEtools.FEMMBaseModule.FEMMBase"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMBase</code></pre><p>Class for base finite element modeling machine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule" href="#FinEtools.FEMMBaseModule"><code>FinEtools.FEMMBaseModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMBaseModule</code></pre><p>Module for comments/base operations on interiors and boundaries of domains.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearModule.FEMMDeforLinear" href="#FinEtools.FEMMDeforLinearModule.FEMMDeforLinear"><code>FinEtools.FEMMDeforLinearModule.FEMMDeforLinear</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinear{S&lt;:FESet, F&lt;:Function, P&lt;:PropertyDeformationLinear}</code></pre><p>Class for linear deformation finite element modeling machine.</p></div></div></section><pre><code class="language-none">FinEtools.FEMMDeforLinearAbstract</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearBaseModule" href="#FinEtools.FEMMDeforLinearBaseModule"><code>FinEtools.FEMMDeforLinearBaseModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinearAbstractBaseModule</code></pre><p>Base module for operations on interiors of domains to construct system matrices and system vectors for linear deformation models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearESNICEModule" href="#FinEtools.FEMMDeforLinearESNICEModule"><code>FinEtools.FEMMDeforLinearESNICEModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinearESNICEModule</code></pre><p>Formulation for the small displacement, small strain deformation model for Nodally-Integrated Continuum Elements (NICE).</p><p>The approximation is  originally from Dohrmann et al IJNME 47 (2000). The formulation was subsequently developed in Krysl, P. and Zhu, B. Locking-free continuum displacement finite elements with nodal integration, International Journal for Numerical Methods in Engineering, 76,7,1020-1043,2008.</p><p>The stabilization scheme comes from papers on energy-sampling stabilization for mean-strain elements (Krysl).</p></div></div></section><pre><code class="language-none">FinEtools.FEMMDeforLinearESNICET4</code></pre><pre><code class="language-none">FinEtools.FEMMDeforLinearMSH8</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearMSModule" href="#FinEtools.FEMMDeforLinearMSModule"><code>FinEtools.FEMMDeforLinearMSModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinearMSModule</code></pre><p>Module for operations on interiors of domains to construct system matrices and system vectors for linear deformation models:  mean-strain  formulation.</p></div></div></section><pre><code class="language-none">FinEtools.FEMMDeforLinearMST10</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearModule" href="#FinEtools.FEMMDeforLinearModule"><code>FinEtools.FEMMDeforLinearModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinearModule</code></pre><p>Module for operations on interiors of domains to construct system matrices and system vectors for linear deformation models.</p></div></div></section><pre><code class="language-none">FinEtools.FEMMDeforLinearNICEH8</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearNICEModule" href="#FinEtools.FEMMDeforLinearNICEModule"><code>FinEtools.FEMMDeforLinearNICEModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforLinearNICEModule</code></pre><p>Formulation for the small displacement, small strain deformation model for Nodally-Integrated Continuum Elements (NICE).</p><p>The approximation is  originally from Dohrmann et al IJNME 47 (2000). The formulation was subsequently developed in Krysl, P. and Zhu, B. Locking-free continuum displacement finite elements with nodal integration, International Journal for Numerical Methods in Engineering, 76,7,1020-1043,2008.</p></div></div></section><pre><code class="language-none">FinEtools.FEMMDeforLinearNICET4</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping" href="#FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping"><code>FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMDeforSurfaceDamping{S&lt;:FESet, F&lt;:Function}</code></pre><p>Type for surface damping model.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforSurfaceDampingModule" href="#FinEtools.FEMMDeforSurfaceDampingModule"><code>FinEtools.FEMMDeforSurfaceDampingModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforSurfaceDampingModule</code></pre><p>Module for operations on the damping associated with absorbing boundary  conditions (ABC) representation of the effect of infinite extent  of inviscid fluid next to the surface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler" href="#FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler"><code>FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMDeforWinkler{S&lt;:FESet, F&lt;:Function}</code></pre><p>Type for normal spring support  (Winkler).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforWinklerModule" href="#FinEtools.FEMMDeforWinklerModule"><code>FinEtools.FEMMDeforWinklerModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMDeforWinklerModule</code></pre><p>Module for operations on boundaries of domains to construct system matrices and system vectors for linear deformation models with distributed-spring supports (Winkler foundation model).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule.FEMMHeatDiff" href="#FinEtools.FEMMHeatDiffModule.FEMMHeatDiff"><code>FinEtools.FEMMHeatDiffModule.FEMMHeatDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FEMMHeatDiff(integdomain::IntegDomain{S, F}, material::M) where {S&lt;:FESet, F&lt;:Function, M&lt;:MatHeatDiff}</code></pre><p>Construct with the default orientation matrix (identity).  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule" href="#FinEtools.FEMMHeatDiffModule"><code>FinEtools.FEMMHeatDiffModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMHeatDiffModule</code></pre><p>Module for operations on interiors of domains to construct system matrices and system vectors for linear heat conduction/diffusion.</p></div></div></section><pre><code class="language-none">FinEtools.FEMMHeatDiffSurf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffSurfModule" href="#FinEtools.FEMMHeatDiffSurfModule"><code>FinEtools.FEMMHeatDiffSurfModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FEMMHeatDiffSurfModule</code></pre><p>Module for operations on boundaries of domains to construct system matrices and system vectors for linear heat diffusion/conduction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule.FENodeSet" href="#FinEtools.FENodeSetModule.FENodeSet"><code>FinEtools.FENodeSetModule.FENodeSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Finite element node set type.</code></pre><p>xyz =     Array of node locations.     Array of coordinates, the number of rows corresponds to the number of     nodes in the set and the columns corresponds to the space dimensions.     The location of node j is given by x[j,:].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule" href="#FinEtools.FENodeSetModule"><code>FinEtools.FENodeSetModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FENodeSetModule</code></pre><p>Module for the finite element node set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Map from finite element nodes to the finite elements connecting them.</p><p>For each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array <code>map</code>.         Example: fes.conn= [7,6,5;                             4,1,3;                             3,7,5];             The map reads                     map[1] = [2];                     map[2] = [];#  note that node number 2 is not referenced by the connectivity                     map[3] = [2,3];                     map[4] = [2];                     map[5] = [1,3];                     map[6] = [1];                     map[7] = [1,3]; The individual elements from the connectivity that reference node number 5 are 1 and 3, so that fes.conn(map[5],:) includes  all the nodes that are connected to node 5 (including node 5  itself).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule" href="#FinEtools.FENodeToFEMapModule"><code>FinEtools.FENodeToFEMapModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FENodeToFEMapModule</code></pre><p>Module to construct a map from finite element nodes to the finite elements.</p></div></div></section><pre><code class="language-none">FinEtools.FESet</code></pre><pre><code class="language-none">FinEtools.FESet0Manifold</code></pre><pre><code class="language-none">FinEtools.FESet1Manifold</code></pre><pre><code class="language-none">FinEtools.FESet2Manifold</code></pre><pre><code class="language-none">FinEtools.FESet3Manifold</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH20" href="#FinEtools.FESetModule.FESetH20"><code>FinEtools.FESetModule.FESetH20</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetH20</code></pre><p>Type for sets of volume-like of hexahedral finite elements with 20 nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH27" href="#FinEtools.FESetModule.FESetH27"><code>FinEtools.FESetModule.FESetH27</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetH27</code></pre><p>Type for sets of volume-like of hexahedral finite elements with 27 nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH8" href="#FinEtools.FESetModule.FESetH8"><code>FinEtools.FESetModule.FESetH8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetH8</code></pre><p>Type for sets of volume-like of hexahedral finite elements with eight nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL2" href="#FinEtools.FESetModule.FESetL2"><code>FinEtools.FESetModule.FESetL2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetL2</code></pre><p>Type for sets of curve-like of finite elements with two nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL3" href="#FinEtools.FESetModule.FESetL3"><code>FinEtools.FESetModule.FESetL3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetL3</code></pre><p>Type for sets of curve-like of finite elements with three nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule" href="#FinEtools.FESetModule"><code>FinEtools.FESetModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FESetModule</code></pre><p>Module for finite element sets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetP1" href="#FinEtools.FESetModule.FESetP1"><code>FinEtools.FESetModule.FESetP1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetP1</code></pre><p>Type for sets of point-like of finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ4" href="#FinEtools.FESetModule.FESetQ4"><code>FinEtools.FESetModule.FESetQ4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetQ4</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with four nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ8" href="#FinEtools.FESetModule.FESetQ8"><code>FinEtools.FESetModule.FESetQ8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetQ8</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with eight nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ9" href="#FinEtools.FESetModule.FESetQ9"><code>FinEtools.FESetModule.FESetQ9</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetQ9</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with nine nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT10" href="#FinEtools.FESetModule.FESetT10"><code>FinEtools.FESetModule.FESetT10</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetT10</code></pre><p>Type for sets of volume-like of tetrahedral finite elements with 10 nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT3" href="#FinEtools.FESetModule.FESetT3"><code>FinEtools.FESetModule.FESetT3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetT3</code></pre><p>Type for sets of surface-like of triangular finite elements with three nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT4" href="#FinEtools.FESetModule.FESetT4"><code>FinEtools.FESetModule.FESetT4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetT4</code></pre><p>Type for sets of volume-like of tetrahedral finite elements with four nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT6" href="#FinEtools.FESetModule.FESetT6"><code>FinEtools.FESetModule.FESetT6</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FESetT6</code></pre><p>Type for sets of surface-like of triangular finite elements with six nodes.</p></div></div></section><pre><code class="language-none">FinEtools.FFlt</code></pre><pre><code class="language-none">FinEtools.FFltMat</code></pre><pre><code class="language-none">FinEtools.FFltVec</code></pre><pre><code class="language-none">FinEtools.FInt</code></pre><pre><code class="language-none">FinEtools.FIntMat</code></pre><pre><code class="language-none">FinEtools.FIntVec</code></pre><pre><code class="language-none">FinEtools.FMat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FTypesModule" href="#FinEtools.FTypesModule"><code>FinEtools.FTypesModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FTypesModule</code></pre><p>Module to define  basic types.</p><p>These are the types of quantities used in FinEtools. They are all exported.</p><p>export FInt, FFlt, FCplxFlt, FFltVec, FIntVec, FFltMat, FIntMat, FMat, FVec export FDataDict</p></div></div></section><pre><code class="language-none">FinEtools.FVec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.Field" href="#FinEtools.FieldModule.Field"><code>FinEtools.FieldModule.Field</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Abstract field.</code></pre><p>Expected  attributes:</p><ul><li>values::FMat{T} # Array of degree of freedom parameters,  indexed by node</li><li>dofnums::FIntMat # Array of degree of freedom numbers, indexed by node</li><li>is_fixed::Matrix{Bool} # Array of Boolean flags, indexed by node</li><li>fixed_values::FMat{T} # Array of fixed values, indexed by node</li><li>nfreedofs::FInt # Total number of free degrees of freedom</li></ul><p>See the macro <code>add_Field_fields()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule" href="#FinEtools.FieldModule"><code>FinEtools.FieldModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">FieldModule</code></pre><p>Module for abstract fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FinEtools" href="#FinEtools.FinEtools"><code>FinEtools.FinEtools</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>FinEtools (C) 2017-2019, Petr Krysl</p><p>Finite Element tools.  Julia implementation  of the finite element method for continuum mechanics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity" href="#FinEtools.ForceIntensityModule.ForceIntensity"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ForceIntensity{T&lt;:Number, F&lt;:Function}</code></pre><p>Distributed force (force intensity) type. The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:</p><ul><li>force/length^3 (when applied to a 3-D solid),</li><li>force/length^2 (when applied to a surface),</li><li>force/length^1 (when applied along a curve), or </li><li>force/length^0 (when applied at a point).</li></ul><p>Signature of the function to compute the value of the force  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>forceout</code> is filled with the value  of the force.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule" href="#FinEtools.ForceIntensityModule"><code>FinEtools.ForceIntensityModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">ForceIntensityModule</code></pre><p>Module  to manage  distributed force intensity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.GRID" href="#FinEtools.MeshExportModule.GRID"><code>FinEtools.MeshExportModule.GRID</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GRID(self::NASTRANExporter, n::Int, xyz::Vector{FFlt})</code></pre><p>Write a grid-point statement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaussRule</code></pre><p>The Gauss rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField" href="#FinEtools.GeneralFieldModule.GeneralField"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GeneralField{T&lt;:Number} &lt;: Field</code></pre><p>General field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule" href="#FinEtools.GeneralFieldModule"><code>FinEtools.GeneralFieldModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">GeneralFieldModule</code></pre><p>Module for general fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20block" href="#FinEtools.MeshHexahedronModule.H20block"><code>FinEtools.MeshHexahedronModule.H20block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H20block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Create mesh of a 3-D block of H20 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20blockx" href="#FinEtools.MeshHexahedronModule.H20blockx"><code>FinEtools.MeshHexahedronModule.H20blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H20blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H20 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27block" href="#FinEtools.MeshHexahedronModule.H27block"><code>FinEtools.MeshHexahedronModule.H27block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H27block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Create mesh of a 3-D block of H27 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27blockx" href="#FinEtools.MeshHexahedronModule.H27blockx"><code>FinEtools.MeshHexahedronModule.H27blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H27blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H27 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8block" href="#FinEtools.MeshHexahedronModule.H8block"><code>FinEtools.MeshHexahedronModule.H8block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Make  a mesh  of a 3D block consisting of  eight node hexahedra.</p><p>Length, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8blockx" href="#FinEtools.MeshHexahedronModule.H8blockx"><code>FinEtools.MeshHexahedronModule.H8blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H8 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8elliphole" href="#FinEtools.MeshHexahedronModule.H8elliphole"><code>FinEtools.MeshHexahedronModule.H8elliphole</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt, T::FFlt,
    nL::FInt, nH::FInt, nW::FInt, nT::FInt)</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><p><code>xradius</code>,<code>yradius</code> = radii of the ellipse, <code>L</code>,<code>H</code> = dimensions of the plate, <code>T</code> = thickness of the plate <code>nL</code>,<code>nH</code>= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole <code>nW</code> = number of edges along the remaining straight edge (from the hole   in the radial direction),</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8extrudeQ4" href="#FinEtools.MeshHexahedronModule.H8extrudeQ4"><code>FinEtools.MeshHexahedronModule.H8extrudeQ4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8extrudeQ4(fens::FENodeSet,  fes::FESetQ4, nLayers::FInt, extrusionh::Function)</code></pre><p>Extrude a mesh of quadrilaterals into a mesh of hexahedra (H8).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8hexahedron" href="#FinEtools.MeshHexahedronModule.H8hexahedron"><code>FinEtools.MeshHexahedronModule.H8hexahedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8hexahedron(xyz::FFltMat, nL::FInt, nW::FInt, nH::FInt; blockfun=nothing)</code></pre><p>Mesh of a general hexahedron given by the location of the vertices.</p><p><code>xyz</code> = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). <code>nL</code>,  <code>nW</code>,  <code>nH</code> = number of elements in each direction <code>blockfun</code> = Optional argument: function of the block-generating mesh function      (having the signature of the function <code>H8block()</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8layeredplatex" href="#FinEtools.MeshHexahedronModule.H8layeredplatex"><code>FinEtools.MeshHexahedronModule.H8layeredplatex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec)</code></pre><p>H8 mesh for a layered block (composite plate) with specified in plane coordinates.</p><p>xs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer</p><p>The finite elements of each layer are labeled with the layer number, starting from 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8refine" href="#FinEtools.MeshHexahedronModule.H8refine"><code>FinEtools.MeshHexahedronModule.H8refine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8refine(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Refine a mesh of H8 hexahedrals by octasection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8sphere" href="#FinEtools.MeshHexahedronModule.H8sphere"><code>FinEtools.MeshHexahedronModule.H8sphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8sphere(radius::FFlt, nrefine::FInt)

Create a mesh of 1/8 of the sphere of &quot;radius&quot;. The  mesh will consist of
four hexahedral elements if &quot;nrefine==0&quot;,  or more if &quot;nrefine&gt;0&quot;.
&quot;nrefine&quot; is the number of bisections applied  to refine the mesh.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8spheren" href="#FinEtools.MeshHexahedronModule.H8spheren"><code>FinEtools.MeshHexahedronModule.H8spheren</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8spheren(radius::FFlt, nperradius::FInt)</code></pre><p>Create a solid mesh of 1/8 of sphere.</p><p>Create a solid mesh of 1/8 of the sphere of &quot;radius&quot;,  with nperradius elements per radius.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH20" href="#FinEtools.MeshHexahedronModule.H8toH20"><code>FinEtools.MeshHexahedronModule.H8toH20</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8toH20(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Convert a mesh of hexahedra H8 to hexahedra H20.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH27" href="#FinEtools.MeshHexahedronModule.H8toH27"><code>FinEtools.MeshHexahedronModule.H8toH27</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8toH27(fens::FENodeSet,  fes::FESetH8)

Convert a mesh of hexahedra H8 to hexahedra H27.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8voximg" href="#FinEtools.MeshHexahedronModule.H8voximg"><code>FinEtools.MeshHexahedronModule.H8voximg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">H8voximg(img::Array{DataT, 3}, voxdims::FFltVec,
    voxval::Array{DataT, 1}) where {DataT&lt;:Number}</code></pre><p>Generate a hexahedral mesh  from three-dimensional image.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.HEADING" href="#FinEtools.MeshExportModule.HEADING"><code>FinEtools.MeshExportModule.HEADING</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">HEADING(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>*HEADING</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.INSTANCE" href="#FinEtools.MeshExportModule.INSTANCE"><code>FinEtools.MeshExportModule.INSTANCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)</code></pre><p>Write out the <code>*INSTANCE</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelTetMeshingModule.ImageMesher" href="#FinEtools.VoxelTetMeshingModule.ImageMesher"><code>FinEtools.VoxelTetMeshingModule.ImageMesher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ImageMesher{CoordT,DataT}</code></pre><p>Tetrahedral image mesher.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain" href="#FinEtools.IntegDomainModule.IntegDomain"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IntegDomain{S&lt;:FESet, F&lt;:Function}</code></pre><p>Integration domain.</p><ul><li><code>T</code> = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.</li><li><code>F</code> = type of function to return the &quot;other&quot; dimension.</li></ul><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule" href="#FinEtools.IntegDomainModule"><code>FinEtools.IntegDomainModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">IntegDomainModule</code></pre><p>Module to manage integration domains.</p><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div></div></section><pre><code class="language-none">FinEtools.IntegRule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule" href="#FinEtools.IntegRuleModule"><code>FinEtools.IntegRuleModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>IntegRuleModule Module for numerical integration rules.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiancurve" href="#FinEtools.IntegDomainModule.Jacobiancurve"><code>FinEtools.IntegDomainModule.Jacobiancurve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Jacobiancurve(self::IntegDomain{T}, J::FFltMat,
    loc::FFltMat, conn::CC,
    N::FFltMat)::FFlt where {T&lt;:FESet0Manifold, CC}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobiancurve(self::IntegDomain{T}, J::FFltMat,
          loc::FFltMat, conn::CC,
          N::FFltMat)::FFlt where {T&lt;:FESet1Manifold, CC}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim" href="#FinEtools.IntegDomainModule.Jacobianmdim"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
  loc::FFltMat, conn::CC,
  N::FFltMat, m::FInt)::FFlt where {T&lt;:FESet0Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 0-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=0: +1</li><li>m=1: Jacobiancurve</li><li>m=2: Jacobiansurface</li><li>m=3: Jacobianvolume</li></ul></div></div><div><div><pre><code class="language-none">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
loc::FFltMat, conn::CC,
N::FFltMat, m::FInt)::FFlt where {T&lt;:FESet1Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 1-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=1: Jacobiancurve</li><li>m=2: Jacobiansurface</li><li>m=3: Jacobianvolume</li></ul></div></div><div><div><pre><code class="language-none">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat, m::FInt)::FFlt where {T&lt;:FESet2Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 2-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=2: Jacobiansurface</li><li>m=3: Jacobianvolume</li></ul></div></div><div><div><pre><code class="language-none">Jacobianmdim{T&lt;:FESet3Manifold}(self::IntegDomain, J::FFltMat,
            loc::FFltMat, conn::FIntMat, N::FFltMat, m::FInt)</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 3-dimensional cell,  the manifold Jacobian is</p><ul><li>m=3: Jacobianvolume</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianpoint" href="#FinEtools.IntegDomainModule.Jacobianpoint"><code>FinEtools.IntegDomainModule.Jacobianpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Jacobianpoint(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet0Manifold, CC}</code></pre><p>Evaluate the point Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface" href="#FinEtools.IntegDomainModule.Jacobiansurface"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet0Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the zero-dimensional cell,  the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> times the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet1Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code>.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
             N::FFltMat)::FFlt where {T&lt;:FESet2Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume" href="#FinEtools.IntegDomainModule.Jacobianvolume"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
      loc::FFltMat, conn::CC,
      N::FFltMat)::FFlt where {T&lt;:FESet0Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the zero-dimensional cell,  the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length squared).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet1Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet2Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point <code>loc</code> (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div><div><div><pre><code class="language-none">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:FESet3Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshLineModule.L2block" href="#FinEtools.MeshLineModule.L2block"><code>FinEtools.MeshLineModule.L2block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>L2block(Length::FFlt, nL::FInt)</p><p>Mesh of a 1-D block of L2 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshLineModule.L2blockx" href="#FinEtools.MeshLineModule.L2blockx"><code>FinEtools.MeshLineModule.L2blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>L2blockx(xs::FFltVec)</p><p>Graded mesh of a 1-D block, L2 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshLineModule.L3blockx" href="#FinEtools.MeshLineModule.L3blockx"><code>FinEtools.MeshLineModule.L3blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">L3blockx(xs::FFltVec)</code></pre><p>Graded mesh of a 1-D block, L2 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.MAT1" href="#FinEtools.MeshExportModule.MAT1"><code>FinEtools.MeshExportModule.MAT1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MAT1(self::NASTRANExporter, mid::Int, E::FFlt, G::FFlt, nu::FFlt, rho::FFlt, A::FFlt, TREF::FFlt, GE::FFlt)</code></pre><p>Write a statement for an isotropic elastic material.</p></div></div><div><div><pre><code class="language-none">MAT1(self::NASTRANExporter, mid::Int, E::FFlt, nu::FFlt, rho::FFlt = 0.0, A::FFlt = 0.0, TREF::FFlt = 0.0)</code></pre><p>Write a statement for an isotropic elastic material.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.MATERIAL" href="#FinEtools.MeshExportModule.MATERIAL"><code>FinEtools.MeshExportModule.MATERIAL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)</code></pre><p>Write out the <code>*MATERIAL</code> option.</p></div></div></section><pre><code class="language-none">FinEtools.MatAcoustFluid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatAcoustFluidModule" href="#FinEtools.MatAcoustFluidModule"><code>FinEtools.MatAcoustFluidModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MatAcoustFluidModule</code></pre><p>Module for acoustic-fluid  material.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.MatDefor" href="#FinEtools.MatDeforModule.MatDefor"><code>FinEtools.MatDeforModule.MatDefor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MatDefor</code></pre><p>Abstract type that represents deformable materials.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforElastIsoModule.MatDeforElastIso" href="#FinEtools.MatDeforElastIsoModule.MatDeforElastIso"><code>FinEtools.MatDeforElastIsoModule.MatDeforElastIso</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MatDeforElastIso</code></pre><p>Linear isotropic elasticity  material.</p><pre><code class="language-none">tangentmoduli!::MTAN
update!::MUPD
thermalstrain!::MTHS</code></pre></div></div></section><pre><code class="language-none">FinEtools.MatDeforElastIsoModule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho" href="#FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho"><code>FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MatDeforElastOrtho</code></pre><p>Linear orthotropic elasticity  material.</p><pre><code class="language-tangentmoduli">  ms::MatDeforElastOrthoMS, D::FFltMat,
  t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforElastOrthoModule" href="#FinEtools.MatDeforElastOrthoModule"><code>FinEtools.MatDeforElastOrthoModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MatDeforElastOrthoModule</code></pre><p>Module for  orthotropic elastic material.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule" href="#FinEtools.MatDeforModule"><code>FinEtools.MatDeforModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MatDeforModule</code></pre><p>Module to support general operations for deformation material models.</p></div></div></section><pre><code class="language-none">FinEtools.MatHeatDiff</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatHeatDiffModule" href="#FinEtools.MatHeatDiffModule"><code>FinEtools.MatHeatDiffModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MatHeatDiffModule</code></pre><p>Module for linear heat diffusion material models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatrixUtilityModule" href="#FinEtools.MatrixUtilityModule"><code>FinEtools.MatrixUtilityModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MatrixUtilityModule</code></pre><p>Module for general utility matrix product functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule" href="#FinEtools.MeshExportModule"><code>FinEtools.MeshExportModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshExportModule</code></pre><p>Module for export of meshes and data defined on meshes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshHexahedronModule" href="#FinEtools.MeshHexahedronModule"><code>FinEtools.MeshHexahedronModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshHexahedronModule</code></pre><p>Module for generation of  hexahedral meshes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshImportModule" href="#FinEtools.MeshImportModule"><code>FinEtools.MeshImportModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshImportModule</code></pre><p>Module for mesh import  functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshLineModule" href="#FinEtools.MeshLineModule"><code>FinEtools.MeshLineModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshLineModule</code></pre><p>Module  for generation of meshes composed of line (curve) elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule" href="#FinEtools.MeshModificationModule"><code>FinEtools.MeshModificationModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshModificationModule</code></pre><p>Module for mesh modification operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule" href="#FinEtools.MeshQuadrilateralModule"><code>FinEtools.MeshQuadrilateralModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshQuadrilateralModule</code></pre><p>Module  for generation of meshes composed of quadrilaterals.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule" href="#FinEtools.MeshSelectionModule"><code>FinEtools.MeshSelectionModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshSelectionModule</code></pre><p>Module for  selection of mesh entities.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule" href="#FinEtools.MeshTetrahedronModule"><code>FinEtools.MeshTetrahedronModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshTetrahedronModule</code></pre><p>Module  for generation of meshes composed of tetrahedra.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule" href="#FinEtools.MeshTriangleModule"><code>FinEtools.MeshTriangleModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshTriangleModule</code></pre><p>Module  for generation of meshes composed of triangles.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshUtilModule" href="#FinEtools.MeshUtilModule"><code>FinEtools.MeshUtilModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">MeshUtilModule</code></pre><p>Module for mesh utility functions used in other meshing modules.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRANExporter" href="#FinEtools.MeshExportModule.NASTRANExporter"><code>FinEtools.MeshExportModule.NASTRANExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>NASTRANExporter</p><p>Export mesh to Abaqus.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NODE" href="#FinEtools.MeshExportModule.NODE"><code>FinEtools.MeshExportModule.NODE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}</code></pre><p>Write out the <code>*NODE</code> option.</p><p><code>xyz</code>=array of node coordinates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NODE_PRINT" href="#FinEtools.MeshExportModule.NODE_PRINT"><code>FinEtools.MeshExportModule.NODE_PRINT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)</code></pre><p>Write out the <code>*NODE PRINT</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NSET_NSET" href="#FinEtools.MeshExportModule.NSET_NSET"><code>FinEtools.MeshExportModule.NSET_NSET</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">NSET_NSET(self::AbaqusExporter, NSET::AbstractString,
  n::AbstractVector{T}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*NSET</code> option.</p><p><code>NSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField" href="#FinEtools.NodalFieldModule.NodalField"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NodalField{T&lt;:Number}</code></pre><p>Nodal field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule" href="#FinEtools.NodalFieldModule"><code>FinEtools.NodalFieldModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">NodalFieldModule</code></pre><p>Module for nodal fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NodalSimplexRule</code></pre><p>The nodal-quadrature simplex rule.</p><p>The rule is applicable for line segments, triangles, tetrahedra.</p><p>The quadrature points must be given at the nodes in the order  in which the nodes are used in the definition of the element.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.ORIENTATION" href="#FinEtools.MeshExportModule.ORIENTATION"><code>FinEtools.MeshExportModule.ORIENTATION</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,
  a::AbstractArray{T,1}, b::AbstractArray{T,1})</code></pre><p>Write out the <code>*ORIENTATION</code> option.</p><p>Invoke at level: Part,  Part instance,  Assembly</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.PART" href="#FinEtools.MeshExportModule.PART"><code>FinEtools.MeshExportModule.PART</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PART(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*PART</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.PSOLID" href="#FinEtools.MeshExportModule.PSOLID"><code>FinEtools.MeshExportModule.PSOLID</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PSOLID(self::NASTRANExporter, pid::Int, mid::Int)</code></pre><p>Write solid-property statement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.PhysicalUnitModule" href="#FinEtools.PhysicalUnitModule"><code>FinEtools.PhysicalUnitModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">PhysicalUnitModule</code></pre><p>Module  to handle use of physical units in constant definitions.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule" href="#FinEtools.IntegRuleModule.PointRule"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PointRule</code></pre><p>Class of point quadrature rule.</p><p>Used for integration on the standard &quot;point&quot; shape.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4annulus" href="#FinEtools.MeshQuadrilateralModule.Q4annulus"><code>FinEtools.MeshQuadrilateralModule.Q4annulus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4block" href="#FinEtools.MeshQuadrilateralModule.Q4block"><code>FinEtools.MeshQuadrilateralModule.Q4block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)</code></pre><p>Mesh of a rectangle, Q4 elements.</p><p>Divided into elements: nL, nW in the first, second (x,y).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4blockx" href="#FinEtools.MeshQuadrilateralModule.Q4blockx"><code>FinEtools.MeshQuadrilateralModule.Q4blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4blockx(xs::FFltVec, ys::FFltVec)</code></pre><p>Graded mesh  of a rectangle, Q4 finite elements.</p><pre><code class="language-none">Mesh of a 2-D block, Q4 finite elements. The nodes are located at the
Cartesian product of the two intervals on the input.  This allows for
construction of graded meshes.

xs,ys - Locations of the individual planes of nodes.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4elliphole" href="#FinEtools.MeshQuadrilateralModule.Q4elliphole"><code>FinEtools.MeshQuadrilateralModule.Q4elliphole</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt,
  nL::FInt, nH::FInt, nW::FInt)</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><pre><code class="language-none">xradius,yradius = radius of the ellipse,
L,H= and dimensions of the plate,
nL,nH= numbers of edges along the side of the plate; this also happens
  to be the number of edges along the circumference of the elliptical
  hole
nW= number of edges along the remaining straight edge (from the hole
  in the direction of the length),</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4quadrilateral" href="#FinEtools.MeshQuadrilateralModule.Q4quadrilateral"><code>FinEtools.MeshQuadrilateralModule.Q4quadrilateral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4quadrilateral(xyz::FFltMat, nL::FInt, nW::FInt)</code></pre><p>Mesh of a general quadrilateral given by the location of the vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4refine" href="#FinEtools.MeshQuadrilateralModule.Q4refine"><code>FinEtools.MeshQuadrilateralModule.Q4refine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4refine(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Refine a mesh of quadrilaterals by bisection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4toQ8" href="#FinEtools.MeshQuadrilateralModule.Q4toQ8"><code>FinEtools.MeshQuadrilateralModule.Q4toQ8</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4toQ8(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Convert a mesh of quadrilateral Q4 to quadrilateral Q8.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.Q4toT3" href="#FinEtools.MeshTriangleModule.Q4toT3"><code>FinEtools.MeshTriangleModule.Q4toT3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)</code></pre><p>Convert a mesh of quadrilateral Q4&#39;s to two T3 triangles  each.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8annulus" href="#FinEtools.MeshQuadrilateralModule.Q8annulus"><code>FinEtools.MeshQuadrilateralModule.Q8annulus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q8annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl. Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8block" href="#FinEtools.MeshQuadrilateralModule.Q8block"><code>FinEtools.MeshQuadrilateralModule.Q8block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q8block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)</code></pre><p>Mesh of a rectangle of Q8 elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8blockx" href="#FinEtools.MeshQuadrilateralModule.Q8blockx"><code>FinEtools.MeshQuadrilateralModule.Q8blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q8blockx(xs::FFltVec, ys::FFltVec)</code></pre><p>Graded mesh of a 2-D block of Q8 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.RotationUtilModule" href="#FinEtools.RotationUtilModule"><code>FinEtools.RotationUtilModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">RotationUtilModule</code></pre><p>Module to handle two-dimensional and three-dimensional rotations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.SECTION_CONTROLS" href="#FinEtools.MeshExportModule.SECTION_CONTROLS"><code>FinEtools.MeshExportModule.SECTION_CONTROLS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,
  OPTIONAL::AbstractString)</code></pre><p>Write out the <code>*SECTION CONTROLS</code> option.</p><p><code>OPTIONAL</code> = string, for instance                      HOURGLASS=ENHANCED</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.SOLID_SECTION" href="#FinEtools.MeshExportModule.SOLID_SECTION"><code>FinEtools.MeshExportModule.SOLID_SECTION</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString,
  CONTROLS::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div></div><div><div><pre><code class="language-none">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div></div><div><div><pre><code class="language-none">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STEP_FREQUENCY" href="#FinEtools.MeshExportModule.STEP_FREQUENCY"><code>FinEtools.MeshExportModule.STEP_FREQUENCY</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)</code></pre><p>Write out the <code>*STEP,FREQUENCY</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STEP_PERTURBATION_BUCKLE" href="#FinEtools.MeshExportModule.STEP_PERTURBATION_BUCKLE"><code>FinEtools.MeshExportModule.STEP_PERTURBATION_BUCKLE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear buckling analysis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STEP_PERTURBATION_STATIC" href="#FinEtools.MeshExportModule.STEP_PERTURBATION_STATIC"><code>FinEtools.MeshExportModule.STEP_PERTURBATION_STATIC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">STEP_PERTURBATION_STATIC(self::AbaqusExporter)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear static analysis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STLExporter" href="#FinEtools.MeshExportModule.STLExporter"><code>FinEtools.MeshExportModule.STLExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>STLExporter</p><p>Export surface mesh as STL file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.SURFACE_SECTION" href="#FinEtools.MeshExportModule.SURFACE_SECTION"><code>FinEtools.MeshExportModule.SURFACE_SECTION</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)</code></pre><p>Write out the <code>*SURFACE SECTION</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimplexRule</code></pre><p>Simplex quadrature rule.</p><p>Used for integration on the standard triangle or the standard tetrahedron.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal" href="#FinEtools.SurfaceNormalModule.SurfaceNormal"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SurfaceNormal{F&lt;:Function}</code></pre><p>Exterior surface normal type.</p><p>Normalized to unit length. </p><p>Signature of the function to compute the value of the unit normal  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix  of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getnormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>normalout</code> is filled with the value  of the normal vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule" href="#FinEtools.SurfaceNormalModule"><code>FinEtools.SurfaceNormalModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">SurfaceNormalModule</code></pre><p>Module to evaluate surface normal vector. </p><p>The normal is assumed to be the exterior normal, and the vector is normalized to unit length.</p></div></div></section><pre><code class="language-none">FinEtools.SysmatAssemblerBase</code></pre><pre><code class="language-none">FinEtools.SysmatAssemblerSparse</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SysmatAssemblerSparseHRZLumpingSymm{T&lt;:Number} &lt;: SysmatAssemblerBase</code></pre><p>Assembler for a SYMMETRIC LUMPED square matrix  assembled from  SYMMETRIC squared matrices. </p><p>Reference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering &amp; Structural Dynamics, volume 4, number 3, 245–249, 1976. }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SysmatAssemblerSparseSymm{T&lt;:Number} &lt;: SysmatAssemblerBase</code></pre><p>Assembler for a SYMMETRIC square matrix  assembled from  SYMMETRIC squared matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SysvecAssembler</code></pre><p>Assembler for the system vector.</p></div></div></section><pre><code class="language-none">FinEtools.SysvecAssemblerBase</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10block" href="#FinEtools.MeshTetrahedronModule.T10block"><code>FinEtools.MeshTetrahedronModule.T10block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T10block(Length::FFlt, Width::FFlt, Height::FFlt,
  nL::FInt, nW::FInt, nH::FInt; orientation::Symbol=:a)</code></pre><p>Generate a tetrahedral  mesh of T10 elements  of a rectangular block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10blockx" href="#FinEtools.MeshTetrahedronModule.T10blockx"><code>FinEtools.MeshTetrahedronModule.T10blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T10blockx(xs::FFltMat, ys::FFltMat, zs::FFltMat, orientation::Symbol = :a)</code></pre><p>Generate a graded 10-node tetrahedral mesh  of a 3D block.</p><p>10-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into six tetrahedra.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10layeredplatex" href="#FinEtools.MeshTetrahedronModule.T10layeredplatex"><code>FinEtools.MeshTetrahedronModule.T10layeredplatex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T10layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec,
    orientation::Symbol = :a)</code></pre><p>T10 mesh for a layered block (composite plate) with specified in plane coordinates.</p><p>xs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer</p><p>The finite elements of each layer are labeled with the layer number, starting from 1 at the bottom.</p></div></div></section><pre><code class="language-none">FinEtools.T10refine</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T10toT4" href="#FinEtools.MeshTetrahedronModule.T10toT4"><code>FinEtools.MeshTetrahedronModule.T10toT4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T10toT4(fens::FENodeSet,  fes::FESetT4)</code></pre><p>Convert a mesh of tetrahedra of type T10 (quadratic 10-node) to tetrahedra T4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3annulus" href="#FinEtools.MeshTriangleModule.T3annulus"><code>FinEtools.MeshTriangleModule.T3annulus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T3annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3block" href="#FinEtools.MeshTriangleModule.T3block"><code>FinEtools.MeshTriangleModule.T3block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T3block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)</code></pre><p>T3 Mesh of a rectangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3blockx" href="#FinEtools.MeshTriangleModule.T3blockx"><code>FinEtools.MeshTriangleModule.T3blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T3blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)</code></pre><p>T3 Mesh of a rectangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3refine" href="#FinEtools.MeshTriangleModule.T3refine"><code>FinEtools.MeshTriangleModule.T3refine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T3refine(fens::FENodeSet,fes::FESetT3)</code></pre><p>Refine a mesh of 3-node triangles by quadrisection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3toT6" href="#FinEtools.MeshTriangleModule.T3toT6"><code>FinEtools.MeshTriangleModule.T3toT6</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T3toT6(fens::FENodeSet, fes::FESetT3)</code></pre><p>Convert a mesh of triangle T3 (three-node) to triangle T6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4block" href="#FinEtools.MeshTetrahedronModule.T4block"><code>FinEtools.MeshTetrahedronModule.T4block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4block(Length::FFlt, Width::FFlt, Height::FFlt,
   nL::FInt, nW::FInt, nH::FInt, orientation::Symbol)</code></pre><p>Generate a tetrahedral mesh  of the 3D block.</p><p>Four-node tetrahedra in a regular arrangement, with uniform spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into six tetrahedra. Range =&lt;0, Length&gt; x &lt;0, Width&gt; x &lt;0, Height&gt; Divided into elements: nL,  nW,  nH in the first,  second,  and third direction (x, y, z).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4blockx" href="#FinEtools.MeshTetrahedronModule.T4blockx"><code>FinEtools.MeshTetrahedronModule.T4blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4blockx(xs::FFltMat, ys::FFltMat, zs::FFltMat, orientation::Symbol)</code></pre><p>Generate a graded tetrahedral mesh  of a 3D block.</p><p>Four-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into six tetrahedra.</p></div></div><div><div><pre><code class="language-none">T4blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec, orientation::Symbol)</code></pre><p>Generate a graded tetrahedral mesh  of a 3D block.</p><p>Four-node tetrahedra in a regular arrangement, with non-uniform given spacing between the nodes, with a given orientation of the diagonals.</p><p>The mesh is produced by splitting each logical  rectangular cell into six tetrahedra.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4meshedges" href="#FinEtools.MeshTetrahedronModule.T4meshedges"><code>FinEtools.MeshTetrahedronModule.T4meshedges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4meshedges(t::Array{Int, 2})</code></pre><p>Compute all the edges of the 4-node triangulation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4refine" href="#FinEtools.MeshTetrahedronModule.T4refine"><code>FinEtools.MeshTetrahedronModule.T4refine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4refine(fens::FENodeSet, fes::FESetT4)</code></pre><p>Refine a mesh of 4-node tetrahedra by octasection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4toT10" href="#FinEtools.MeshTetrahedronModule.T4toT10"><code>FinEtools.MeshTetrahedronModule.T4toT10</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4toT10(fens::FENodeSet,  fes::FESetT4)</code></pre><p>Convert a mesh of tetrahedra of type T4 (four-node) to tetrahedra T10.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTetrahedronModule.T4voximg" href="#FinEtools.MeshTetrahedronModule.T4voximg"><code>FinEtools.MeshTetrahedronModule.T4voximg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T4voximg(img::Array{DataT, 3}, voxdims::FFltVec,
    voxval::Array{DataT, 1}) where {DataT&lt;:Number}</code></pre><p>Generate a tetrahedral mesh  from three-dimensional image.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6annulus" href="#FinEtools.MeshTriangleModule.T6annulus"><code>FinEtools.MeshTriangleModule.T6annulus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T6annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6block" href="#FinEtools.MeshTriangleModule.T6block"><code>FinEtools.MeshTriangleModule.T6block</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T6block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)</code></pre><p>Mesh of a rectangle of T6 elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6blockx" href="#FinEtools.MeshTriangleModule.T6blockx"><code>FinEtools.MeshTriangleModule.T6blockx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">T6blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)</code></pre><p>Graded mesh of a 2-D block of T6 finite elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.TEMPERATURE" href="#FinEtools.MeshExportModule.TEMPERATURE"><code>FinEtools.MeshExportModule.TEMPERATURE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},
  tlist::AbstractArray{F, 1}) where {I, F}</code></pre><p>Write out the <code>*TEMPERATURE</code> option.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.TetRemeshingModule" href="#FinEtools.TetRemeshingModule"><code>FinEtools.TetRemeshingModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Module for remeshing tetrahedral triangulations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TetRule</code></pre><p>Tetrahedral quadrature rule.</p><p>Used for integration on the standard tetrahedron.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TrapezoidalRule</code></pre><p>The trapezoidal rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TriRule</p><p>Triangular quadrature rule.</p><p>Used for integration on the standard triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache" href="#FinEtools.VectorCacheModule.VectorCache"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorCache{T&lt;:Number, F&lt;:Function}</code></pre><p>Type for caching vectors.</p><p><code>T</code> = type of the entries of the vector, <code>F</code> = type of the function to update the entries of the vector.</p><p>Signature of the function to fill the cache with the value of the vector at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The cache <code>cacheout</code> is filled with the value  of the vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule" href="#FinEtools.VectorCacheModule"><code>FinEtools.VectorCacheModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">VectorCacheModule</code></pre><p>Module to manage vector caches.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule" href="#FinEtools.VoxelBoxModule"><code>FinEtools.VoxelBoxModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Module for generating and manipulating voxel 3-D images (boxes of voxels).</p><p>This module may be helpful when working with CT scan and other medical images in the context of finite element analysis carried out with the package FinEtools.jl .</p></div></div></section><pre><code class="language-none">FinEtools.VoxelBoxVolume</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelTetMeshingModule" href="#FinEtools.VoxelTetMeshingModule"><code>FinEtools.VoxelTetMeshingModule</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">VoxelTetMeshingModule</code></pre><p>Module for meshing of voxel data sets with tetrahedra.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.acousticABC" href="#FinEtools.FEMMAcoustSurfModule.acousticABC"><code>FinEtools.FEMMAcoustSurfModule.acousticABC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acousticABC(self::FEMMAcoustSurf, assembler::A,
  geom::NodalField,
  Pdot::NodalField{T}) where {T&lt;:Number, A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the acoustic ABC (Absorbing Boundary Condition) matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.acousticcouplingpanels" href="#FinEtools.FEMMAcoustSurfModule.acousticcouplingpanels"><code>FinEtools.FEMMAcoustSurfModule.acousticcouplingpanels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acousticcouplingpanels(self::FEMMAcoustSurf, geom::NodalField, u::NodalField{T}) where {T}</code></pre><p>Compute the acoustic pressure-structure coupling matrix.</p><p>The acoustic pressure-nodal force matrix transforms  the pressure distributed along the surface to forces acting on the nodes of the finite element model. Its transpose transforms displacements (or velocities, or accelerations) into the normal component of the displacement (or velocity, or acceleration) along the surface.</p><p>Arguments <code>geom</code>=geometry field <code>u</code> = displacement field </p><p>Notes: – <code>n</code>=outer normal (pointing into the acoustic medium). – The pressures along the surface are assumed constant (uniform) along  each finite element –- panel. The panel pressures are assumed to be given the same numbers as the serial numbers of the finite elements in the block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.acousticmass" href="#FinEtools.FEMMAcoustModule.acousticmass"><code>FinEtools.FEMMAcoustModule.acousticmass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acousticmass(self::FEMMAcoust,
  assembler::A, geom::NodalField,
  P::NodalField{T}) where {T&lt;:Number, A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the acoustic mass matrix.</p><p>Return K as a matrix. Arguments self   =  acoustics model assembler  =  matrix assembler geom = geometry field P = acoustic (perturbation) pressure field</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.acousticstiffness" href="#FinEtools.FEMMAcoustModule.acousticstiffness"><code>FinEtools.FEMMAcoustModule.acousticstiffness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acousticstiffness(self::FEMMAcoust, assembler::A,
  geom::NodalField,
  Pddot::NodalField{T}) where {T&lt;:Number,
  A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the acoustic stiffness matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.applyebc!" href="#FinEtools.FieldModule.applyebc!"><code>FinEtools.FieldModule.applyebc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">applyebc!(self::Field)</code></pre><p>Apply EBCs (essential boundary conditions).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!" href="#FinEtools.AssemblyModule.assemble!"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assemble!(self::SysmatAssemblerSparse{T}, mat::FMat{T},
  dofnums_row::FIntMat, dofnums_col::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a rectangular matrix.</p></div></div><div><div><pre><code class="language-none">assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},
  dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a square symmetric matrix.</p></div></div><div><div><p>assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},   dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</p><p>Assemble a square symmetric matrix.</p></div></div><div><div><pre><code class="language-none">assemble!(self::SysvecAssembler{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div></div><div><div><pre><code class="language-none">assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},
  dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a HRZ-lumped square symmetric matrix.</p></div></div><div><div><pre><code class="language-none">assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},
    dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble an HRZ-lumped square symmetric matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.associategeometry!" href="#FinEtools.FEMMBaseModule.associategeometry!"><code>FinEtools.FEMMBaseModule.associategeometry!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>Compute the  correction factors to account for  the shape of the  elements.</p></div></div><div><div><pre><code class="language-none">associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>Compute the  correction factors to account for  the shape of the  elements.</p></div></div><div><div><pre><code class="language-none">associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>There may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.</p><p>Geometry field is normally passed into any routine that evaluates some  forms (integrals) over the mesh.  Whenever the geometry passed into a  routine is not consistent with the one for which <code>associategeometry!()</code>  was called before, <code>associategeometry!()</code> needs to be called with  the new geometry field.</p></div></div><div><div><pre><code class="language-none">associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>Compute the  correction factors to account for  the shape of the  elements.</p></div></div><div><div><pre><code class="language-none">associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>Compute the  correction factors to account for  the shape of the  elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.bfun" href="#FinEtools.FESetModule.bfun"><code>FinEtools.FESetModule.bfun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfun(self::T,  param_coords::FFltVec)::FFltMat where {T&lt;:FESet}</code></pre><p>Compute the values of the basis functions at a given parametric coordinate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.bfundpar" href="#FinEtools.FESetModule.bfundpar"><code>FinEtools.FESetModule.bfundpar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfundpar(self::T,  param_coords::FFltVec)::FFltMat where {T&lt;:FESet}</code></pre><p>Compute the values of the basis function gradients at a given parametric coordinate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.boundingbox" href="#FinEtools.BoxModule.boundingbox"><code>FinEtools.BoxModule.boundingbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">boundingbox(x::AbstractArray)</code></pre><p>Compute the bounding box of the points in <code>x</code>.</p><p><code>x</code> = holds points, one per row.</p><p>Returns <code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.boxesoverlap" href="#FinEtools.BoxModule.boxesoverlap"><code>FinEtools.BoxModule.boxesoverlap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">boxesoverlap(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Do the given boxes overlap?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cat(self::T,  other::T) where {T&lt;:FESet}</code></pre><p>Concatenate the connectivities of two FE sets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.centroidparametric" href="#FinEtools.FESetModule.centroidparametric"><code>FinEtools.FESetModule.centroidparametric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">centroidparametric(self::T) where {T&lt;:FESet}</code></pre><p>Return the parametric coordinates  of the centroid of the element.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">close(self::AbaqusExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div></div><div><div><pre><code class="language-none">close(self::NASTRANExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div></div><div><div><pre><code class="language-none">close(self::STLExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.compactnodes" href="#FinEtools.MeshModificationModule.compactnodes"><code>FinEtools.MeshModificationModule.compactnodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compactnodes(fens::FENodeSet, connected::Vector{Bool})</code></pre><p>Compact the finite element node set by deleting unconnected nodes.</p><p><code>fens</code> = array of finite element nodes <code>connected</code> = The array element <code>connected[j]</code> is either 0 (when <code>j</code> is an   unconnected node), or a positive number (when node <code>j</code> is connected to   other nodes by at least one finite element)</p><p><strong>Output:</strong></p><p><code>fens</code> = new set of finite element nodes <code>new_numbering</code>= array which tells where in the new <code>fens</code> array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      <code>new_numbering[5]</code> is 3.</p><p><strong>Examples:</strong></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="language-none">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactnodes(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="language-none">validate_mesh(fens, fes);</code></pre></div></div></section><pre><code class="language-none">FinEtools.complementop</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule.conductivity" href="#FinEtools.FEMMHeatDiffModule.conductivity"><code>FinEtools.FEMMHeatDiffModule.conductivity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">conductivity(self::FEMMHeatDiff,
  assembler::A, geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the conductivity matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.connasarray" href="#FinEtools.FESetModule.connasarray"><code>FinEtools.FESetModule.connasarray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connasarray(self::FESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Return the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectedelems" href="#FinEtools.MeshSelectionModule.connectedelems"><code>FinEtools.MeshSelectionModule.connectedelems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connectedelems(fes::FESet, node_list::FIntVec)</code></pre><p>Extract the list of numbers for the fes  that are connected to given nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectednodes" href="#FinEtools.MeshSelectionModule.connectednodes"><code>FinEtools.MeshSelectionModule.connectednodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connectednodes(fes::FESet)</code></pre><p>Extract the node numbers of the nodes  connected by given finite elements.</p><p>Extract the list of unique node numbers for the nodes that are connected by the finite element set <code>fes</code>. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.connectionmatrix" href="#FinEtools.FEMMBaseModule.connectionmatrix"><code>FinEtools.FEMMBaseModule.connectionmatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connectionmatrix(self::FEMM, nnodes::FInt) where {FEMM&lt;:FEMMAbstractBase}</code></pre><p>Compute the connection matrix.</p><p>The matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copyto!" href="#Base.copyto!"><code>Base.copyto!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">copyto!(DEST::F,  SRC::F) where {F&lt;:Field}</code></pre><p>Copy data from one field to another.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.count" href="#Base.count"><code>Base.count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count(self::T)::FInt where {T&lt;:FESet}</code></pre><p>Get the number of individual connectivities in the FE set.</p></div></div><div><div><pre><code class="language-none">count(self::FENodeSet)</code></pre><p>Get the number of finite element nodes in the node set.</p></div></div></section><pre><code class="language-none">FinEtools.cross2</code></pre><pre><code class="language-none">FinEtools.cross3!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforSurfaceDampingModule.dampingABC" href="#FinEtools.FEMMDeforSurfaceDampingModule.dampingABC"><code>FinEtools.FEMMDeforSurfaceDampingModule.dampingABC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dampingABC(self::FEMMDeforSurfaceDamping, assembler::A,
              geom::NodalField{FFlt}, u::NodalField{T1},
              impedance::T2, surfacenormal::SurfaceNormal) where {A&lt;:SysmatAssemblerBase, T1&lt;:Number, T2&lt;:Number}</code></pre><p>Compute the damping matrix associated with absorbing boundary conditions (ABC) representation of the effect of infinite extent of inviscid fluid next to the surface.</p></div></div></section><pre><code class="language-none">FinEtools.differenceop</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.distribloads" href="#FinEtools.FEMMBaseModule.distribloads"><code>FinEtools.FEMMBaseModule.distribloads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">distribloads(self::FEMM, assembler::A, geom::NodalField{FFlt}, P::NodalField{T},
  fi::ForceIntensity,
  m::FInt) where {FEMM&lt;:FEMMAbstractBase, T&lt;:Number, A&lt;:SysvecAssemblerBase}</code></pre><p>Compute the distributed-load vector.</p><p><code>fi</code>=force intensity object <code>m</code>= manifold dimension, 1= curve, 2= surface, 3= volume</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.elemfieldfromintegpoints" href="#FinEtools.FEMMBaseModule.elemfieldfromintegpoints"><code>FinEtools.FEMMBaseModule.elemfieldfromintegpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">elemfieldfromintegpoints(self::FEMM,
  geom::NodalField{FFlt},  u::NodalField{T},
  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;
  context...) where {FEMM&lt;:FEMMAbstractBase, T&lt;:Number}</code></pre><p>Construct nodal field from integration points.</p><p>Input arguments <code>geom</code>     - reference geometry field <code>u</code>        - displacement field <code>dT</code>       - temperature difference field <code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument            of the material update!() method. <code>component</code>- component of the &#39;quantity&#39; array: see the material update()            method. Output argument</p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div></div></section><pre><code class="language-none">FinEtools.endsolid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule.energy" href="#FinEtools.FEMMHeatDiffModule.energy"><code>FinEtools.FEMMHeatDiffModule.energy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">energy(self::FEMMHeatDiff, geom::NodalField{FFlt},  temp::NodalField{FFlt})</code></pre><p>Compute the &quot;energy&quot; integral over the interior domain.</p></div></div></section><pre><code class="language-none">FinEtools.eval</code></pre><pre><code class="language-none">FinEtools.facet</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.fieldfromintegpoints" href="#FinEtools.FEMMBaseModule.fieldfromintegpoints"><code>FinEtools.FEMMBaseModule.fieldfromintegpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fieldfromintegpoints(self::FEMM,
  geom::NodalField{FFlt},  u::NodalField{T},
  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;
  context...) where {FEMM&lt;:FEMMAbstractBase, T&lt;:Number}</code></pre><p>Construct nodal field from integration points.</p><p>Input arguments <code>geom</code>     - reference geometry field <code>u</code>        - displacement field <code>dT</code>       - temperature difference field <code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument            of the material update!() method. <code>component</code>- component of the &#39;quantity&#39; array: see the material update()            method. Keyword arguments <code>nodevalmethod</code> = <code>:invdistance</code> (the default) or <code>:averaging</code>; <code>reportat</code> = at which point should the  element quantities be reported?     This argument is interpreted inside the <code>inspectintegpoints()</code> method. Output argument</p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.fillsolid!" href="#FinEtools.VoxelBoxModule.fillsolid!"><code>FinEtools.VoxelBoxModule.fillsolid!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fillsolid!(V::VoxelBoxVolume,
    f::SolidCF, fillvalue::DataT) where {DataT&lt;:Number}</code></pre><p>Filled a solid using a solid characteristic function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.fillvolume!" href="#FinEtools.VoxelBoxModule.fillvolume!"><code>FinEtools.VoxelBoxModule.fillvolume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fillvolume!(V::VoxelBoxVolume, fillvalue::DataT) where {DataT&lt;:Number}</code></pre><p>Fill the volume with a given value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule.findunconnnodes" href="#FinEtools.MeshSelectionModule.findunconnnodes"><code>FinEtools.MeshSelectionModule.findunconnnodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findunconnnodes(fens::FENodeSet, fes::FESet)</code></pre><p>Find nodes that are not connected to any finite element.</p><p>connected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).</p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.fromarray!" href="#FinEtools.FESetModule.fromarray!"><code>FinEtools.FESetModule.fromarray!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fromarray!(self::FESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}</code></pre><p>Set  the connectivity from an integer array.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.fusenodes" href="#FinEtools.MeshModificationModule.fusenodes"><code>FinEtools.MeshModificationModule.fusenodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fusenodes(fens1::FENodeSet, fens2::FENodeSet, tolerance:: FFlt)</code></pre><p>Fuse together nodes from two node sets.</p><p>Fuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, <code>fens1</code> and <code>fens2</code>,  are fused together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the new  indexes of the nodes in the set <code>fens1</code> are returned.</p><p>The set <code>fens2</code> will be included unchanged, in the same order, in the node set <code>fens</code>. The indexes of the node set <code>fens1</code> will have changed.</p><p><strong>Example:</strong></p><p>After the call to this function we have <code>k=new_indexes_of_fens1_nodes[j]</code> is the node in the node set fens which used to be node <code>j</code> in node set <code>fens1</code>. The finite element set connectivity that used to refer to <code>fens1</code> needs to be updated to refer to the same nodes in  the set <code>fens</code> as      <code>updateconn!(fes, new_indexes_of_fens1_nodes);</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gatherdofnums!" href="#FinEtools.FieldModule.gatherdofnums!"><code>FinEtools.FieldModule.gatherdofnums!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gatherdofnums!(self::Field, dest::A, conn::CC) where {A, CC}</code></pre><p>Gather dofnums from the field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asmat!" href="#FinEtools.FieldModule.gatherfixedvalues_asmat!"><code>FinEtools.FieldModule.gatherfixedvalues_asmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gatherfixedvalues_asmat!(self::Field, dest::AbstractArray{T, 2},
    conn::CC) where {CC, T}</code></pre><p>Gather FIXED values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asvec!" href="#FinEtools.FieldModule.gatherfixedvalues_asvec!"><code>FinEtools.FieldModule.gatherfixedvalues_asvec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gatherfixedvalues_asvec!(self::Field, dest::AbstractArray{T, 1},
    conn::CC) where {CC, T}</code></pre><p>Gather FIXED values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec" href="#FinEtools.FieldModule.gathersysvec"><code>FinEtools.FieldModule.gathersysvec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gathersysvec{F&lt;:Field}(self::F)</code></pre><p>Gather values from the field for the whole system vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec!" href="#FinEtools.FieldModule.gathersysvec!"><code>FinEtools.FieldModule.gathersysvec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gathersysvec!(self::F, vec::FVec{T}) where {F&lt;:Field, T}</code></pre><p>Gather values from the field for the whole system vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asmat!" href="#FinEtools.FieldModule.gathervalues_asmat!"><code>FinEtools.FieldModule.gathervalues_asmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gathervalues_asmat!(self::Field, dest::AbstractArray{T, 2},
    conn::CC) where {CC, T}</code></pre><p>Gather values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asvec!" href="#FinEtools.FieldModule.gathervalues_asvec!"><code>FinEtools.FieldModule.gathervalues_asvec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gathervalues_asvec!(self::Field, dest::AbstractArray{T, 1},
    conn::CC) where {CC, T}</code></pre><p>Gather values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshUtilModule.gradedspace" href="#FinEtools.MeshUtilModule.gradedspace"><code>FinEtools.MeshUtilModule.gradedspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gradedspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate quadratic space.</p><p>Generate a quadratic sequence of numbers between start and finish. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.</p></div></div></section><pre><code class="language-none">FinEtools.h2libexporttri</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshImportModule.import_ABAQUS" href="#FinEtools.MeshImportModule.import_ABAQUS"><code>FinEtools.MeshImportModule.import_ABAQUS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">import_ABAQUS(filename)</code></pre><p>Import tetrahedral (4- and 10-node) or hexahedral (8- and 20-node) Abaqus mesh (.inp file).</p><p>Limitations:</p><ol><li>Only the <code>*NODE</code> and <code>*ELEMENT</code>  sections are read</li><li>Only 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 3-node triangles  are handled.</li></ol><p><strong>Return</strong></p><p>Data dictionary, with keys <code>fens</code> (finite element nodes), <code>fesets</code> (array of finite element sets).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshImportModule.import_NASTRAN" href="#FinEtools.MeshImportModule.import_NASTRAN"><code>FinEtools.MeshImportModule.import_NASTRAN</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">import_NASTRAN(filename)</code></pre><p>Import tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).</p><p>Limitations:</p><ol><li>only the GRID and CTETRA  sections are read.</li><li>Only 4-node and 10-node tetrahedra  are handled.</li><li>The file should be free-form (data separated by commas). </li></ol><p>Some fixed-format files can also be processed (large-field, but not small-field).</p><p><strong>Return</strong></p><p>Data dictionary, with keys <code>fens</code> (finite element nodes), <code>fesets</code> (array of finite element sets).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.inbox" href="#FinEtools.BoxModule.inbox"><code>FinEtools.BoxModule.inbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inbox(box::AbstractVector, x::AbstractVector)</code></pre><p>Is the given location inside the box?</p><p>Note: point on the boundary of the box is counted as being inside.</p></div></div></section><pre><code class="language-none">FinEtools.include</code></pre><pre><code class="language-none">FinEtools.inflatebox!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.initbox!" href="#FinEtools.BoxModule.initbox!"><code>FinEtools.BoxModule.initbox!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initbox!(box::AbstractVector, x::AbstractVector)</code></pre><p>Initialize a bounding box with a single point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.innerproduct" href="#FinEtools.FEMMBaseModule.innerproduct"><code>FinEtools.FEMMBaseModule.innerproduct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">innerproduct(self::FEMMHeatDiff,
  assembler::A, geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the inner-product (Gram) matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.inparametric" href="#FinEtools.FESetModule.inparametric"><code>FinEtools.FESetModule.inparametric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inparametric(self::FESet, param_coords::FFltVec)</code></pre><p>Are given parametric coordinates inside the element parametric domain?</p><p>Returns a Boolean: is the point inside, true or false?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.inspectintegpoints" href="#FinEtools.FEMMBaseModule.inspectintegpoints"><code>FinEtools.FEMMBaseModule.inspectintegpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>inspectintegpoints(self::FEMMDeforLinear,      geom::NodalField{FFlt},  u::NodalField{T},      dT::NodalField{FFlt},      felist::FIntVec,      inspector::F,  idat, quantity=:Cauchy;      context...) where {T&lt;:Number, F&lt;:Function}</p><p>Inspect integration point quantities.</p><p><code>geom</code> - reference geometry field <code>u</code> - displacement field <code>dT</code> - temperature difference field <code>felist</code> - indexes of the finite elements that are to be inspected:     The fes to be included are: <code>fes[felist]</code>. <code>context</code>    - structure: see the update!() method of the material. <code>inspector</code> - functionwith the signature        idat = inspector(idat, j, conn, x, out, loc);   where    <code>idat</code> - a structure or an array that the inspector may           use to maintain some state,  for instance minimum or maximum of           stress, <code>j</code> is the element number, <code>conn</code> is the element connectivity,           <code>out</code> is the output of the update!() method,  <code>loc</code> is the location           of the integration point in the <em>reference</em> configuration.</p><p><strong>Return</strong></p><p>The updated inspector data is returned.</p></div></div><div><div><pre><code class="language-none">inspectintegpoints(self::FEMM, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {FEMM&lt;:FEMMAbstractBase, T&lt;:Number, F&lt;:Function}</code></pre><p>Inspect integration points.  </p></div></div><div><div><pre><code class="language-none">inspectintegpoints(self::FEMMDeforLinearAbstract,
  geom::NodalField{FFlt},  u::NodalField{T},
  dT::NodalField{FFlt},
  felist::FIntVec,
  inspector::F,  idat, quantity=:Cauchy;
  context...) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Inspect integration point quantities.</p><p><code>geom</code> - reference geometry field <code>u</code> - displacement field <code>dT</code> - temperature difference field <code>felist</code> - indexes of the finite elements that are to be inspected:      The fes to be included are: <code>fes[felist]</code>. <code>context</code>    - structure: see the update!() method of the material. <code>inspector</code> - functionwith the signature         idat = inspector(idat, j, conn, x, out, loc);    where     <code>idat</code> - a structure or an array that the inspector may            use to maintain some state,  for instance minimum or maximum of            stress, <code>j</code> is the element number, <code>conn</code> is the element connectivity,            <code>out</code> is the output of the update!() method,  <code>loc</code> is the location            of the integration point in the <em>reference</em> configuration.</p><p><strong>Return</strong></p><p>The updated inspector data is returned.</p></div></div><div><div><pre><code class="language-none">inspectintegpoints(self::FEMMHeatDiff, geom::NodalField{FFlt}, u::NodalField{T}, temp::NodalField{FFlt}, felist::FIntVec, inspector::F, idat, quantity=:heatflux; context...) where {F&lt;:Function}</code></pre><p>Inspect integration point quantities.</p><p><strong>Inputs</strong></p><ul><li><code>geom</code> - reference geometry field</li><li><code>u</code> - displacement field (ignored)</li><li><code>temp</code> - temperature field</li><li><code>felist</code> - indexes of the finite elements that are to be inspected: The fes to be included are: <code>fes[felist]</code>.</li><li><code>context</code>    - structure: see the update!() method of the material.</li><li><code>inspector</code> - function with the signature       <code>idat = inspector(idat, j, conn, x, out, loc);</code>  where   <code>idat</code> - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, <code>j</code> is the element number, <code>conn</code> is the element connectivity,          <code>out</code> is the output of the update!() method,  <code>loc</code> is the location          of the integration point in the <em>reference</em> configuration.</li></ul><p><strong>Return</strong></p><p>The updated inspector data is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefieldfunction" href="#FinEtools.FEMMBaseModule.integratefieldfunction"><code>FinEtools.FEMMBaseModule.integratefieldfunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integratefieldfunction(self::FEMMAbstractBase,
    geom::NodalField{FFlt},  afield::FL, fh::F,  initial::R;
    m::FInt=-1) where {T&lt;:Number, FL&lt;:NodalField{T}, R, F&lt;:Function}</code></pre><p>Integrate a nodal-field function over the discrete manifold.</p><p><code>afield</code> = NODAL field to be supply the values  <code>fh</code> = function taking position and the field value as arguments, returning value of type <code>R</code>.</p><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>.    </p></div></div><div><div><pre><code class="language-none">integratefieldfunction(self::FEMMAbstractBase,
    geom::NodalField{FFlt},  afield::FL, fh::F, initial::R;
    m::FInt=-1) where {T&lt;:Number, FL&lt;:ElementalField{T}, R, F&lt;:Function}</code></pre><p>Integrate a elemental-field function over the discrete manifold.</p><p><code>afield</code> = ELEMENTAL field to be supply the values  <code>fh</code> = function taking position and the field value as arguments, returning value of type <code>R</code>.</p><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefunction" href="#FinEtools.FEMMBaseModule.integratefunction"><code>FinEtools.FEMMBaseModule.integratefunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integratefunction(self::FEMMAbstractBase,
    geom::NodalField{FFlt}, fh::F, m::FInt = -1) where {F&lt;:Function}</code></pre><p>Integrate a function over the discrete manifold.</p><p>Integrate some scalar function over the geometric cells. The function takes a single argument, the position vector.</p><p>When the scalar function returns just +1 (such as <code>(x) -&gt;  1.0</code>), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.</p><p><strong>Example:</strong></p><p>Compute the volume of the mesh and then its center of gravity:</p><pre><code class="language-none">V = integratefunction(femm, geom, (x) -&gt;  1.0)
Sx = integratefunction(femm, geom, (x) -&gt;  x[1])
Sy = integratefunction(femm, geom, (x) -&gt;  x[2])
Sz = integratefunction(femm, geom, (x) -&gt;  x[3])
CG = vec([Sx Sy Sz]/V)</code></pre><p>Compute the moments of inertia:</p><pre><code class="language-none">% Now compute the moments of inertia
Ixx = measure(femm,geom,@(x)(norm(x-CG)^2*eye(3)-(x-CG)&#39;*(x-CG)))
mass = V*rhos;
Inertia = I*rhos;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.integrationdata" href="#FinEtools.IntegDomainModule.integrationdata"><code>FinEtools.IntegDomainModule.integrationdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrationdata(self::IntegDomain)</code></pre><p>Calculate the data needed for  numerical quadrature for the integration rule     stored by the integration domain.</p></div></div><div><div><pre><code class="language-none">integrationdata(self::IntegDomain, integration_rule::T) where {T&lt;:IntegRule}</code></pre><p>Calculate the data needed for numerical quadrature.</p><p>For given integration domain, compute the quantities needed for numerical integration.</p><p><strong>Return</strong></p><p><code>npts</code>, <code>Ns</code>, <code>gradNparams</code>, <code>w</code>, <code>pc</code> = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.interior2boundary" href="#FinEtools.MeshModificationModule.interior2boundary"><code>FinEtools.MeshModificationModule.interior2boundary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">interior2boundary(interiorconn::Array{Int, 2}, extractb::Array{Int, 2})</code></pre><p>Extract the boundary connectivity from the connectivity of the interior.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.intersectboxes" href="#FinEtools.BoxModule.intersectboxes"><code>FinEtools.BoxModule.intersectboxes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersectboxes(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Compute the intersection of two boxes.  </p><p>The function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned. </p></div></div></section><pre><code class="language-none">FinEtools.intersectionop</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshUtilModule.linearspace" href="#FinEtools.MeshUtilModule.linearspace"><code>FinEtools.MeshUtilModule.linearspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linearspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate linear space.</p><p>Generate a linear sequence of numbers between start and top (i. e. sequence  of number with uniform intervals inbetween).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!" href="#FinEtools.AssemblyModule.makematrix!"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">makematrix!(self::SysmatAssemblerSparse)</code></pre><p>Make a sparse matrix.</p></div></div><div><div><pre><code class="language-none">makematrix!(self::SysmatAssemblerSparseSymm)</code></pre><p>Make a sparse SYMMETRIC SQUARE matrix.</p></div></div><div><div><pre><code class="language-none">makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)</code></pre><p>Make a sparse SYMMETRIC SQUARE matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!" href="#FinEtools.AssemblyModule.makevector!"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">makevector!(self::SysvecAssembler)</code></pre><p>Make the global vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.manifdim" href="#FinEtools.FESetModule.manifdim"><code>FinEtools.FESetModule.manifdim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">manifdim(me)</code></pre><p>Get the manifold dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.map2parametric" href="#FinEtools.FESetModule.map2parametric"><code>FinEtools.FESetModule.map2parametric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map2parametric(self::T, x::FFltMat, pt::FFltVec;
    tolerance = 0.001, maxiter =5) where {T&lt;:FESet}</code></pre><p>Map a spatial location to parametric coordinates.</p><ul><li><code>x</code>=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,</li><li><code>c</code>= spatial location</li><li><code>tolerance</code> = tolerance in parametric coordinates; default is 0.001.</li></ul><p><strong>Return</strong></p><ul><li><code>success</code> = Boolean flag, true if successful, false otherwise.</li><li><code>pc</code> = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearBaseModule.mass" href="#FinEtools.FEMMDeforLinearBaseModule.mass"><code>FinEtools.FEMMDeforLinearBaseModule.mass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mass(self::FEMMDeforLinearAbstract,  assembler::A,
  geom::NodalField{FFlt},
  u::NodalField{T}) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</code></pre><p>Compute the consistent mass matrix</p><p>This is a general routine for the abstract linear-deformation  FEMM.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergemeshes" href="#FinEtools.MeshModificationModule.mergemeshes"><code>FinEtools.MeshModificationModule.mergemeshes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mergemeshes(fens1::FENodeSet, fes1::T1,
  fens2::FENodeSet, fes2::T2, tolerance::FFlt) where {T1&lt;:FESet,T2&lt;:FESet}</code></pre><p>Merge together two meshes.</p><p>Merge two meshes together by gluing together nodes within tolerance. The two meshes, <code>fens1</code>, <code>fes1</code>, and <code>fens2</code>, <code>fes2</code>, are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.</p><p>The merged node set, <code>fens</code>, and the two finite element sets with renumbered  connectivities are returned.</p><p>Important notes: On entry into this function the connectivity of <code>fes1</code> point into <code>fens1</code> and the connectivity of <code>fes2</code> point into <code>fens2</code>. After this function returns the connectivity of both <code>fes1</code> and <code>fes2</code> point into <code>fens</code>. The order of the nodes of the node set <code>fens1</code> in the resulting set <code>fens</code> will have changed, whereas the order of the nodes of the node set <code>fens2</code> is are guaranteed to be the same. Therefore, the connectivity of <code>fes2</code> will in fact remain the same.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenmeshes" href="#FinEtools.MeshModificationModule.mergenmeshes"><code>FinEtools.MeshModificationModule.mergenmeshes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mergenmeshes(meshes::Array{Tuple{FENodeSet, FESet}}, tolerance::FFlt)</code></pre><p>Merge several meshes together.</p><p>The meshes are glued together by merging the nodes that fall within  a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of  nodes is performed; the nodes from the meshes are simply concatenated together.</p><p><strong>Output</strong></p><p>The merged node set, <code>fens</code>, and an array of finite element sets with renumbered  connectivities are returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenodes" href="#FinEtools.MeshModificationModule.mergenodes"><code>FinEtools.MeshModificationModule.mergenodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mergenodes(fens::FENodeSet, fes::FESet, tolerance::FFlt)</code></pre><p>Merge together  nodes of a single node set.</p><p>Merge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the finite element set, <code>fes</code>, with renumbered  connectivities are returned.</p><p>Warning: This tends to be an expensive operation!</p></div></div><div><div><pre><code class="language-none">mergenodes(fens::FENodeSet, fes::FESet, tolerance::FFlt, candidates::FIntVec)</code></pre><p>Merge together  nodes of a single node set.</p><p>Similar to <code>mergenodes(fens::FENodeSet, fes::FESet, tolerance::FFlt)</code>, but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelTetMeshingModule.mesh!" href="#FinEtools.VoxelTetMeshingModule.mesh!"><code>FinEtools.VoxelTetMeshingModule.mesh!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mesh!(self::ImageMesher, stretch::FFlt = 1.2)</code></pre><p>Perform a meshing step.  </p><p>If  no mesh exists,  the initial mesh is created; otherwise a coarsening sequence of coarsen surface -&gt; smooth -&gt; coarsen volume -&gt; smooth is performed.</p><p>After meshing the vertices, tetrahedra, and material identifiers,  can be retrieved as <code>self.v</code>, <code>self.t</code>, and <code>self.tmid</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshboundary" href="#FinEtools.MeshModificationModule.meshboundary"><code>FinEtools.MeshModificationModule.meshboundary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>meshboundary(fes::T) where {T&lt;:FESet}</p><p>Extract the boundary finite elements from a mesh.</p><p>Extract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshsmoothing" href="#FinEtools.MeshModificationModule.meshsmoothing"><code>FinEtools.MeshModificationModule.meshsmoothing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meshsmoothing(fens::FENodeSet, fes::T; options...) where {T&lt;:FESet}</code></pre><p>General smoothing of meshes.</p><p><strong>Keyword options:</strong></p><p><code>method</code> = :taubin (default) or :laplace <code>fixedv</code> = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) <code>npass</code> = number of passes (default 2)</p><p><strong>Return</strong></p><p>The modified  node set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.mirrormesh" href="#FinEtools.MeshModificationModule.mirrormesh"><code>FinEtools.MeshModificationModule.mirrormesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mirrormesh(fens::FENodeSet, fes::T, Normal::FFltVec,
  Point::FFltVec; kwargs...) where {T&lt;:FESet}</code></pre><p>Mirror a 2-D mesh in a plane given by its normal and one point.</p><p>Warning: The code to relies on the numbering of the cells: to reverse the orientation of the mirrored cells, the connectivity is listed in reverse order.   If the mirrored cells do not follow this rule (for instance hexahedra for quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.</p><p>For instance: H8 elements require  the renumbering function to be supplied as fens1,gcells1 = mirror_mesh(fens, gcells,...           [-1,0,0], [0,0,0], @(c)c([1, 4, 3, 2, 5, 8, 7, 6]));</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.ndofs" href="#FinEtools.FieldModule.ndofs"><code>FinEtools.FieldModule.ndofs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ndofs{F&lt;:Field}(self::T)</code></pre><p>Dimension of the degree of freedom parameters (i. e.  how many degrees of freedom per entity).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.nelems" href="#FinEtools.ElementalFieldModule.nelems"><code>FinEtools.ElementalFieldModule.nelems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nelems(self::ElementalField)::FInt = nents(self)</code></pre><p>Provide the number of elements  in the elemental field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.nents" href="#FinEtools.FieldModule.nents"><code>FinEtools.FieldModule.nents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nents{F&lt;:Field}(self::F)</code></pre><p>Number of nodes associated with the field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.nnodes" href="#FinEtools.NodalFieldModule.nnodes"><code>FinEtools.NodalFieldModule.nnodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nnodes(self::NodalField)::FInt = nents(self)</code></pre><p>Provide the number of nodes  in the nodal field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning" href="#FinEtools.MeshModificationModule.nodepartitioning"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>nincluded</code> = Boolean array: is the node to be included in the partitioning or     not? <code>npartitions</code> = number of partitions, but note that the actual number of     partitions is going to be a power of two.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-Dollar(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end 
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; DollarFile`)</code></pre></div></div><div><div><pre><code class="language-none">nodepartitioning(fens::FENodeSet, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>npartitions</code> = number of partitions, but note that the actual number of partitions is going to be a power of two.</p><p>In this variant all the nodes are to be included in the partitioning.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-Dollar(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end 
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; DollarFile`)</code></pre></div></div><div><div><pre><code class="language-none">nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>fesarr</code> = array of finite element sets that represent regions <code>npartitions</code> = array of the number of partitions in each region. However  note that the actual number of partitions is going to be a power of two.</p><p>The partitioning itself is carried out by <code>nodepartitioning()</code> with  a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to  the elements of that region, but not to elements that belong to  any of the previous regions, 1…I-1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.nodesperelem" href="#FinEtools.FESetModule.nodesperelem"><code>FinEtools.FESetModule.nodesperelem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nodesperelem(fes::FESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Provide the number of nodes per element.  </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.DeforModelRedModule.nstressstrain" href="#FinEtools.DeforModelRedModule.nstressstrain"><code>FinEtools.DeforModelRedModule.nstressstrain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nstressstrain(::Type{DeforModelRed})::FInt</code></pre><p>Return the number of stress components involved in the balance equation (and how many strain components) are there for each model reduction type?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.DeforModelRedModule.nthermstrain" href="#FinEtools.DeforModelRedModule.nthermstrain"><code>FinEtools.DeforModelRedModule.nthermstrain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nthermstrain(::Type{DeforModelRed1D})::FInt</code></pre><p>How many thermal strain components are there for each model reduction type?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.numberdofs!" href="#FinEtools.FieldModule.numberdofs!"><code>FinEtools.FieldModule.numberdofs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numberdofs!(self::Field)</code></pre><p>Number the degrees of freedom.</p><p>The free components in the field are numbered consecutively. No effort is made to optimize the numbering in any way. If you&#39;d like to optimize the numbering of the degrees of freedom, use the above form that sets the permutation of the degrees of freedom, or the permutation of the nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.nzebcloadsacousticmass" href="#FinEtools.FEMMAcoustModule.nzebcloadsacousticmass"><code>FinEtools.FEMMAcoustModule.nzebcloadsacousticmass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzebcloadsacousticmass(self::FEMMAcoust, assembler::A,
  geom::NodalField, P::NodalField{T}) where {T&lt;:Number,
  A&lt;:SysvecAssemblerBase}</code></pre><p>Compute load vector for nonzero EBC for fixed pressure..</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.nzebcloadsacousticstiffness" href="#FinEtools.FEMMAcoustModule.nzebcloadsacousticstiffness"><code>FinEtools.FEMMAcoustModule.nzebcloadsacousticstiffness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzebcloadsacousticstiffness(self::FEMMAcoust, assembler::A,
  geom::NodalField,
  Pddot::NodalField{T}) where {T&lt;:Number,
  A&lt;:SysvecAssemblerBase}</code></pre><p>Compute load vector for nonzero EBC for fixed second-order pressure rate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule.nzebcloadsconductivity" href="#FinEtools.FEMMHeatDiffModule.nzebcloadsconductivity"><code>FinEtools.FEMMHeatDiffModule.nzebcloadsconductivity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzebcloadsconductivity(self::FEMMHeatDiff,
  assembler::A,  geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:SysvecAssemblerBase}</code></pre><p>Compute load vector for nonzero EBC of prescribed temperature.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness" href="#FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness"><code>FinEtools.FEMMDeforLinearBaseModule.nzebcloadsstiffness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>nzebcloadsstiffness(self::FEMMDeforLinearAbstract,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A&lt;:SysvecAssemblerBase, T&lt;:Number}</p><p>Compute load vector for nonzero EBC for fixed displacement.</p></div></div><div><div><pre><code class="language-none">nzebcloadsstiffness(self::FEMMDeforLinearAbstract,  assembler::A,
  geom::NodalField{FFlt},
  u::NodalField{T}) where {A&lt;:SysvecAssemblerBase, T&lt;:Number}</code></pre><p>Compute load vector for nonzero EBC for fixed displacement.</p></div></div><div><div><p>nzebcloadsstiffness(self::FEMMDeforLinearAbstract,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A&lt;:SysvecAssemblerBase, T&lt;:Number}</p><p>Compute load vector for nonzero EBC for fixed displacement.</p></div></div><div><div><p>nzebcloadsstiffness(self::FEMMDeforLinearAbstract,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A&lt;:SysvecAssemblerBase, T&lt;:Number}</p><p>Compute load vector for nonzero EBC for fixed displacement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads" href="#FinEtools.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads"><code>FinEtools.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzebcsurfacetransferloads(self::FEMMHeatDiffSurf, assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A&lt;:SysvecAssemblerBase}</code></pre><p>Compute load vector for nonzero EBC for fixed temperature.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.otherdimensionunity" href="#FinEtools.IntegDomainModule.otherdimensionunity"><code>FinEtools.IntegDomainModule.otherdimensionunity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt
          where {CC}</code></pre><p>Evaluate the other dimension: default is 1.0.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.pad" href="#FinEtools.VoxelBoxModule.pad"><code>FinEtools.VoxelBoxModule.pad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pad(V::VoxelBoxVolume, ipad, jpad, kpad, padvalue)</code></pre><p>Pad voxel box with a constant value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.PhysicalUnitModule.phun" href="#FinEtools.PhysicalUnitModule.phun"><code>FinEtools.PhysicalUnitModule.phun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phun(str::String; system_of_units = :SI, base_time_units = :SEC)</code></pre><p>Evaluate an expression in physical units.</p><p><strong>Example</strong></p><pre><code class="language-none">pu = ustring -&gt; phun(ustring; system_of_units = :SIMM)
E1s = 130.0*pu(&quot;GPa&quot;)</code></pre><p>yields 1.3e+5 (in mega Pascal) whereas</p><pre><code class="language-none">130.0*phun(&quot;GPa&quot;; system_of_units = :SI)</code></pre><p>yields 1.3e+11 (in Pascal)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.pressure2resultantforce" href="#FinEtools.FEMMAcoustSurfModule.pressure2resultantforce"><code>FinEtools.FEMMAcoustSurfModule.pressure2resultantforce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pressure2resultantforce(self::FEMMAcoustSurf, assembler::A,
  geom::NodalField,
  P::NodalField{T},
   Force::Field) where {T&lt;:Number, A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the rectangular coupling matrix that transcribes given pressure on the surface into the resultant force acting on the surface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.pressure2resultanttorque" href="#FinEtools.FEMMAcoustSurfModule.pressure2resultanttorque"><code>FinEtools.FEMMAcoustSurfModule.pressure2resultanttorque</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pressure2resultanttorque(self::FEMMAcoustSurf, assembler::A,
  geom::NodalField,
  P::NodalField{T},
  Torque::GeneralField, CG::FFltVec) where {T&lt;:Number, A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the rectangular coupling matrix that transcribes given pressure on the surface into the resultant torque acting on the surface with respect to the CG.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshModificationModule.renumberconn!" href="#FinEtools.MeshModificationModule.renumberconn!"><code>FinEtools.MeshModificationModule.renumberconn!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">renumberconn!(fes::FESet, new_numbering::FIntVec)</code></pre><p>Renumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.</p><p><code>fes</code> =finite element set <code>new_numbering</code> = new serial numbers for the nodes.  The connectivity           should be changed as <code>conn[j]</code> –&gt; <code>new_numbering[conn[j]]</code></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="language-none">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactfens(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="language-julia">validate_mesh(fens, fes);</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.RotationUtilModule.rotmat3!" href="#FinEtools.RotationUtilModule.rotmat3!"><code>FinEtools.RotationUtilModule.rotmat3!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotmat3!(Rmout::FFltMat, a::FFltVec)</code></pre><p>Compute a 3D rotation matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.rotstressvec" href="#FinEtools.MatDeforModule.rotstressvec"><code>FinEtools.MatDeforModule.rotstressvec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotstressvec(::Type{DeforModelRed3D},  outstress::FFltVec,
  instress::FFltVec, Rm::FFltMat)</code></pre><p>Rotate the stress vector by the supplied rotation matrix.</p><p>Calculate the rotation of the stress vector to the &#39;bar&#39; coordinate system given by the columns of the rotation matrix <code>Rm</code>.</p><p><code>Rm</code> = columns are components of &#39;bar&#39; basis vectors on the &#39;plain&#39;      basis vectors</p></div></div><div><div><pre><code class="language-none">rotstressvec(::Type{DeforModelRed2DStrain},  outstress::FFltVec,
  instress::FFltVec,  Rm::FFltMat)</code></pre><p>Rotate the stress vector by the supplied rotation matrix.</p><p>Calculate the rotation of the stress vector to the &#39;bar&#39; coordinate system given by the columns of the rotation matrix <code>Rm</code>.</p><p><code>Rm</code> = columns are components of &#39;bar&#39; basis vectors on the &#39;plain&#39;      basis vectors</p></div></div><div><div><pre><code class="language-none">rotstressvec(::Type{DeforModelRed2DStress},  outstress::FFltVec,
  instress::FFltVec,  Rm::FFltMat)</code></pre><p>Rotate the stress vector by the supplied rotation matrix.</p><p>Calculate the rotation of the stress vector to the &#39;bar&#39; coordinate system given by the columns of the rotation matrix <code>Rm</code>.</p><p><code>Rm</code> = columns are components of &#39;bar&#39; basis vectors on the &#39;plain&#39;      basis vectors</p></div></div><div><div><pre><code class="language-none">rotstressvec(::Type{DeforModelRed2DAxisymm},  outstress::FFltVec,
  instress::FFltVec,  Rm::FFltMat)</code></pre><p>Rotate the stress vector by the supplied rotation matrix.</p><p>Calculate the rotation of the stress vector to the &#39;bar&#39; coordinate system given by the columns of the rotation matrix <code>Rm</code>.</p><p><code>Rm</code> = columns are components of &#39;bar&#39; basis vectors on the &#39;plain&#39;      basis vectors</p></div></div><div><div><pre><code class="language-none">rotstressvec(::Type{DeforModelRed2DAxisymm},  outstress::FFltVec,
  instress::FFltVec,  Rm::FFltMat)</code></pre><p>Rotate the stress vector by the supplied rotation matrix.</p><p>Calculate the rotation of the stress vector to the &#39;bar&#39; coordinate system given by the columns of the rotation matrix <code>Rm</code>.</p><p><code>Rm</code> = columns are components of &#39;bar&#39; basis vectors on the &#39;plain&#39;      basis vectors</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.savecsv" href="#FinEtools.MeshExportModule.savecsv"><code>FinEtools.MeshExportModule.savecsv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">savecsv(name::String; kwargs...)</code></pre><p>Save arrays as a CSV file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.scattersysvec!" href="#FinEtools.FieldModule.scattersysvec!"><code>FinEtools.FieldModule.scattersysvec!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scattersysvec!(self::Field, vec::FVec{T}) where {T&lt;:Number}</code></pre><p>Scatter values to the field from a system vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectelem" href="#FinEtools.MeshSelectionModule.selectelem"><code>FinEtools.MeshSelectionModule.selectelem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selectelem(fens::FENodeSet, fes::T; kwargs...) where {T&lt;:FESet}</code></pre><p>Select finite elements.</p><p><strong>Selection criteria</strong></p><p><strong>facing</strong></p><p>Select all &quot;boundary&quot; elements that &quot;face&quot; a certain direction.</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);</code></pre><p>or</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);</code></pre><p>where</p><pre><code class="language-none">function dout(xyz)
    return xyz/norm(xyz)
end</code></pre><p>and <code>xyz</code> is the location of the centroid  of  a boundary element. Here the finite element is considered &quot;facing&quot; in the given direction if the dot product of its normal and the direction vector is greater than <code>dotmin</code>. The default value for <code>dotmin</code> is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).</p><p>This selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).</p><p><strong>label</strong></p><p>Select elements based on their label.</p><pre><code class="language-none">rl1 = selectelem(fens, fes, label=1)</code></pre><p><strong>box, distance</strong></p><p>Select elements based on some criteria that their nodes satisfy.  See the function <code>selectnode()</code>.</p><p>Example: Select all  elements whose nodes are closer than <code>R+inflate</code> from the point <code>from</code>.</p><pre><code class="language-none">linner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],
  inflate = tolerance)</code></pre><p>Example:</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes,
   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);</code></pre><p><strong>flood</strong></p><p>Select all FEs connected together, starting from a given node.</p><p>Example: Select all FEs connected together (Starting from node 13):</p><pre><code class="language-julia">l = selectelem(fens, fes, flood = true, startnode = 13)</code></pre><p><strong>Optional keyword arguments</strong></p><p>Should we consider the element only if all its nodes are in? <code>allin</code> = Boolean: if true, then all nodes of an element must satisfy the     criterion; otherwise  one is enough.</p><p><strong>Output</strong></p><p><code>felist</code> = list of finite elements from the set that satisfy the criteria</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectnode" href="#FinEtools.MeshSelectionModule.selectnode"><code>FinEtools.MeshSelectionModule.selectnode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selectnode(fens::FENodeSet; kwargs...)</code></pre><p>Select nodes using some criterion.</p><p>See the function <code>vselect()</code> for examples of the criteria.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.setebc!" href="#FinEtools.FieldModule.setebc!"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec, is_fixed::Bool, comp::FInt,
  val::FVec{T}) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec, is_fixed::Bool, comp::FInt,
  val::T) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type T</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec, comp::FInt,
  val::FVec{T}) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec, comp::FInt;
  val::T=0.0) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type T</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec, is_fixed::Bool, comp::FInt;
  val::T=0.0) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type T</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenids::FIntVec)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given nodes.</p><p><code>fenids</code>         - array of N node identifiers</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field, fenid::FInt)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given node.</p><p><code>fenid</code>         - One integer as a node identifier</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div><div><div><pre><code class="language-none">setebc!(self::Field)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>All essential boundary conditions are CLEARED.</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.setlabel!" href="#FinEtools.FESetModule.setlabel!"><code>FinEtools.FESetModule.setlabel!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setlabel!(self::T, val::FInt) where {T&lt;:FESet}</code></pre><p>Set the label of the entire finite elements set.</p></div></div><div><div><pre><code class="language-none">setlabel!(self::T, val::FIntVec) where {T&lt;:FESet}</code></pre><p>Set the labels of individual elements.</p></div></div></section><pre><code class="language-none">FinEtools.size</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.RotationUtilModule.skewmat!" href="#FinEtools.RotationUtilModule.skewmat!"><code>FinEtools.RotationUtilModule.skewmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skewmat!(S, theta)</code></pre><p>Compute skew-symmetric matrix.</p></div></div></section><pre><code class="language-none">FinEtools.solid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.solidbox" href="#FinEtools.VoxelBoxModule.solidbox"><code>FinEtools.VoxelBoxModule.solidbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solidbox(corner1::Tuple{CoordT, CoordT, CoordT},
    corner2::Tuple{CoordT, CoordT, CoordT}) where {CoordT&lt;:Number}</code></pre><p>Solid box  with faces aligned with the global Cartesian axes.</p></div></div></section><pre><code class="language-none">FinEtools.solidcylinder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.solidhalfspace" href="#FinEtools.VoxelBoxModule.solidhalfspace"><code>FinEtools.VoxelBoxModule.solidhalfspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solidhalfspace(center::Tuple{CoordT, CoordT, CoordT},
    normal::Tuple{CoordT, CoordT, CoordT}) where {CoordT&lt;:Number}</code></pre><p>Solid halfspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.solidsphere" href="#FinEtools.VoxelBoxModule.solidsphere"><code>FinEtools.VoxelBoxModule.solidsphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solidsphere(center::Tuple{CoordT, CoordT, CoordT}, r::CoordT) where {CoordT&lt;:Number}</code></pre><p>Solid sphere.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule.spacedim" href="#FinEtools.FENodeSetModule.spacedim"><code>FinEtools.FENodeSetModule.spacedim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spacedim(self::FENodeSet)</code></pre><p>Number of dimensions of the space in which the node lives, 1, 2, or 3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!" href="#FinEtools.AssemblyModule.startassembly!"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">startassembly!(self::SysmatAssemblerSparse{T},
  elem_mat_nrows::FInt, elem_mat_ncols::FInt, elem_mat_nmatrices::FInt,
  ndofs_row::FInt, ndofs_col::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a global matrix.</p></div></div><div><div><pre><code class="language-none">startassembly!(self::SysmatAssemblerSparseSymm{T},
  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,
  ndofs::FInt, ignore2::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a SYMMETRIC square global matrix.</p></div></div><div><div><pre><code class="language-none">startassembly!(self::SysvecAssembler{T},
  ndofs_row::FInt) where {T&lt;:Number}</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble. <code>ndofs_row</code>= Total number of degrees of freedom.</p></div></div><div><div><pre><code class="language-none">startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},
  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,
  ndofs::FInt, ignore2::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a SYMMETRIC LUMPED square global matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearBaseModule.stiffness" href="#FinEtools.FEMMDeforLinearBaseModule.stiffness"><code>FinEtools.FEMMDeforLinearBaseModule.stiffness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>stiffness(self::FEMMDeforLinearAbstractMS, assembler::A,       geom::NodalField{FFlt},       u::NodalField{T}) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</p><p>Compute and assemble  stiffness matrix.</p></div></div><div><div><pre><code class="language-none">stiffness(self::FEMMDeforLinearAbstract, assembler::A,
      geom::NodalField{FFlt},
      u::NodalField{T}) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</code></pre><p>Compute and assemble  stiffness matrix.</p></div></div><div><div><pre><code class="language-none">stiffness(self::FEMMDeforLinearAbstractNICE, assembler::A,
  geom::NodalField{FFlt},
  u::NodalField{T}) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</code></pre><p>Compute and assemble  stiffness matrix.</p></div></div><div><div><pre><code class="language-none">stiffness(self::FEMMDeforLinearAbstractNICE, assembler::A,
  geom::NodalField{FFlt},
  u::NodalField{T}) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</code></pre><p>Compute and assemble  stiffness matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain2x2tto3v!" href="#FinEtools.MatDeforModule.strain2x2tto3v!"><code>FinEtools.MatDeforModule.strain2x2tto3v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain2x2tto3v!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a matrix of 2x2 strain components  into a 3-component vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain3vto2x2t!" href="#FinEtools.MatDeforModule.strain3vto2x2t!"><code>FinEtools.MatDeforModule.strain3vto2x2t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain3vto2x2t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain3x3tto6v!" href="#FinEtools.MatDeforModule.strain3x3tto6v!"><code>FinEtools.MatDeforModule.strain3x3tto6v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain3x3tto6v!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a matrix of 3x3 strain components to a 6-component vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain3x3tto9v!" href="#FinEtools.MatDeforModule.strain3x3tto9v!"><code>FinEtools.MatDeforModule.strain3x3tto9v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain3x3tto9v!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a matrix of 3x3 strain components to a 9-component vector.</p><p>The  strain components are in the order      ex, ey, ez, gxy, gyx, gyz, gzy, gxz, gzx</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain6vto3x3t!" href="#FinEtools.MatDeforModule.strain6vto3x3t!"><code>FinEtools.MatDeforModule.strain6vto3x3t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain6vto3x3t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a strain 6-vector to a  matrix of 3x3 strain components (symmetric tensor)..</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain6vto9v!" href="#FinEtools.MatDeforModule.strain6vto9v!"><code>FinEtools.MatDeforModule.strain6vto9v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain6vto9v!(t::FFltVec, v::FFltVec)</code></pre><p>Convert a strain 6-vector to a  strain 9-vector components (tensor).</p><p>The  strain components are in the order      ex, ey, ez, gxy/2, gxy/2, gyz/2, gyz/2, gxz/2, gxz/2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain9vto3x3t!" href="#FinEtools.MatDeforModule.strain9vto3x3t!"><code>FinEtools.MatDeforModule.strain9vto3x3t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain9vto3x3t!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a matrix of 3x3 strain components to a 9-component vector.</p><p>The  strain components are in the order      ex, ey, ez, gxy, gyx, gyz, gzy, gxz, gzx</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.strain9vto6v!" href="#FinEtools.MatDeforModule.strain9vto6v!"><code>FinEtools.MatDeforModule.strain9vto6v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strain9vto6v!(t::FFltVec, v::FFltVec)</code></pre><p>Convert a strain 9-vector to a  strain 6-vector components (tensor).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress2x2to3v!" href="#FinEtools.MatDeforModule.stress2x2to3v!"><code>FinEtools.MatDeforModule.stress2x2to3v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress2x2to3v!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a symmetric matrix of 2x2 stress components to a 3-component vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress3vto2x2t!" href="#FinEtools.MatDeforModule.stress3vto2x2t!"><code>FinEtools.MatDeforModule.stress3vto2x2t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress3vto2x2t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a 3-vector to a  matrix of 2x2 stress components (symmetric tensor).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress3vto3x3t!" href="#FinEtools.MatDeforModule.stress3vto3x3t!"><code>FinEtools.MatDeforModule.stress3vto3x3t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress3vto3x3t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a 3-vector to a matrix of 3x3 stress components (symmetric tensor).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress3x3tto6v!" href="#FinEtools.MatDeforModule.stress3x3tto6v!"><code>FinEtools.MatDeforModule.stress3x3tto6v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress3x3tto6v!(v::FFltVec, t::FFltMat)</code></pre><p>Convert a matrix of 3x3 stress components to a 6-component vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress4vto3x3t!" href="#FinEtools.MatDeforModule.stress4vto3x3t!"><code>FinEtools.MatDeforModule.stress4vto3x3t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress4vto3x3t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a 4-vector to a  matrix of 3x3 stress components (tensor).</p><p>Convert a 4-vector to a <em>symmetric</em> matrix of 3x3 stress components (tensor).  This is conversion routine that would be useful for plane strain or axially symmetric conditions. The stress vector components need to be ordered as:     sigmax, sigmay, tauxy, sigmaz, which is the ordering used for the plane-strain model reduction. Therefore, for axially symmetric analysis the components need to be reordered, as from the constitutive equation they come out as sigmax, sigmay, sigmaz, tauxy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress6vto3x3t!" href="#FinEtools.MatDeforModule.stress6vto3x3t!"><code>FinEtools.MatDeforModule.stress6vto3x3t!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress6vto3x3t!(t::FFltMat, v::FFltVec)</code></pre><p>Convert a 6-vector to a  matrix of 3x3 stress components (symmetric tensor).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress6vto9v!" href="#FinEtools.MatDeforModule.stress6vto9v!"><code>FinEtools.MatDeforModule.stress6vto9v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress6vto9v!(t::FFltVec, v::FFltVec)</code></pre><p>Convert a stress 6-vector to a  stress 9-vector components (tensor).</p><p>The  stress components are in the order      sigx, sigy, sigz, tauxy, tauxy, tauyz, tauyz, tauxz, tauxz</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.stress9vto6v!" href="#FinEtools.MatDeforModule.stress9vto6v!"><code>FinEtools.MatDeforModule.stress9vto6v!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stress9vto6v!(t::FFltVec, v::FFltVec)</code></pre><p>Convert a stress 9-vector (tensor) to a  stress 6-vector components.</p><p>The  stress components are in the order      sigx, sigy, sigz, tauxy, tauxy, tauyz, tauyz, tauxz, tauxz</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.DeforModelRedModule.stresscomponentmap" href="#FinEtools.DeforModelRedModule.stresscomponentmap"><code>FinEtools.DeforModelRedModule.stresscomponentmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stresscomponentmap(::Type{DeforModelRed1D})</code></pre><p>Construct a dictionary to map from stress-component symbols to indexes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.subset" href="#FinEtools.FESetModule.subset"><code>FinEtools.FESetModule.subset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subset(self::T, L::FIntVec) where {T&lt;:FESet}</code></pre><p>Extract a subset of the finite elements from the given finite element set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforWinklerModule.surfacenormalspringstiffness" href="#FinEtools.FEMMDeforWinklerModule.surfacenormalspringstiffness"><code>FinEtools.FEMMDeforWinklerModule.surfacenormalspringstiffness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">surfacenormalspringstiffness(self::FEMMDeforWinkler, assembler::A,
    geom::NodalField{FFlt}, u::NodalField{T},
    springconstant::FFlt, surfacenormal::SurfaceNormal) where {A&lt;:SysmatAssemblerBase, T&lt;:Number}</code></pre><p>Compute the stiffness matrix of surface normal spring. Rationale: consider continuously distributed springs between the surface of the solid body and the &#39;ground&#39;, in the direction normal to the surface. If the spring coefficient becomes large, we have an approximate method of enforcing the normal displacement to the surface.gas</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffSurfModule.surfacetransfer" href="#FinEtools.FEMMHeatDiffSurfModule.surfacetransfer"><code>FinEtools.FEMMHeatDiffSurfModule.surfacetransfer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">surfacetransfer(self::FEMMHeatDiffSurf,  assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A&lt;:SysmatAssemblerBase}</code></pre><p>Compute the surface heat transfer matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffSurfModule.surfacetransferloads" href="#FinEtools.FEMMHeatDiffSurfModule.surfacetransferloads"><code>FinEtools.FEMMHeatDiffSurfModule.surfacetransferloads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">surfacetransferloads(self::FEMMHeatDiffSurf,  assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt},
  ambtemp::NodalField{FFlt}) where {A&lt;:SysvecAssemblerBase}</code></pre><p>Compute the load vector corresponding to surface heat transfer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearBaseModule.thermalstrainloads" href="#FinEtools.FEMMDeforLinearBaseModule.thermalstrainloads"><code>FinEtools.FEMMDeforLinearBaseModule.thermalstrainloads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">thermalstrainloads(self::FEMMDeforLinearAbstract, assembler::A,
    geom::NodalField{FFlt}, u::NodalField{T},
    dT::NodalField{FFlt}) where {A&lt;:SysvecAssemblerBase, T&lt;:Number}</code></pre><p>Compute the thermal-strain load vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.threshold" href="#FinEtools.VoxelBoxModule.threshold"><code>FinEtools.VoxelBoxModule.threshold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">threshold(V, threshold_value, voxel_below, voxel_above)</code></pre><p>Threshold the data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.transferfield!" href="#FinEtools.FEMMBaseModule.transferfield!"><code>FinEtools.FEMMBaseModule.transferfield!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transferfield!(ff::F, fensf::FENodeSet, fesf::FESet,
    fc::F, fensc::FENodeSet, fesc::FESet, tolerance::FFlt
    )  where {T&lt;:Number, F&lt;:NodalField{T}}</code></pre><p>Transfer a nodal field from a coarse mesh to a finer one.</p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>geometricaltolerance</code> = tolerance in physical space for searches of the adjacent nodes</li><li><code>parametrictolerance</code> = tolerance in parametric space for for check whether node is inside an element</li></ul></div></div><div><div><pre><code class="language-none">transferfield!(ff::F, fensf::FENodeSet, fesf::FESet, fc::F,
    fensc::FENodeSet, fesc::FESet, geometricaltolerance::FFlt;
    parametrictolerance::FFlt = 0.01 )  where {T&lt;:Number,
    F&lt;:ElementalField{T}}</code></pre><p>Transfer an elemental field from a coarse mesh to a finer one.</p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>tolerance</code> = tolerance in physical space for searches of the adjacent nodes</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.trim" href="#FinEtools.VoxelBoxModule.trim"><code>FinEtools.VoxelBoxModule.trim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trim(V::VoxelBoxVolume, emptyvalue)</code></pre><p>Trim off pieces of the volume that consist only of the empty value.</p></div></div></section><pre><code class="language-none">FinEtools.unionop</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.BoxModule.updatebox!" href="#FinEtools.BoxModule.updatebox!"><code>FinEtools.BoxModule.updatebox!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updatebox!(box::AbstractVector, x::AbstractArray)</code></pre><p>Update a box with another location, or create a new box.</p><p>If the  <code>box</code> does not have  the correct dimensions,  it is correctly sized.</p><p><code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code>     The <code>box</code> is expanded to include the     supplied location <code>x</code>.   The variable <code>x</code>  can hold multiple points in rows.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.updateconn!" href="#FinEtools.FESetModule.updateconn!"><code>FinEtools.FESetModule.updateconn!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updateconn!(self::T, newids::FIntVec) where {T&lt;:FESet}</code></pre><p>Update the connectivity after the IDs of nodes changed.</p><p><code>newids</code>= new node IDs. Note that indexes in the conn array point <em>into</em> the  <code>newids</code> array. After the connectivity was updated this is no longer true!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.updatecsmat!" href="#FinEtools.CSysModule.updatecsmat!"><code>FinEtools.CSysModule.updatecsmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function updatecsmat!(self::CSys, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the coordinate system orientation matrix.</p><p>The  coordinate system matrix is updated based upon the location <code>XYZ</code> of the evaluation point, and possibly on the Jacobian matrix <code>tangents</code> within the element in which the coordinate system matrix is evaluated,  or perhaps on the label <code>fe_label</code> of the finite element.</p><p>After this function returns, the coordinate system matrix can be retrieved from the buffer as <code>self.csmat</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.updateforce!" href="#FinEtools.ForceIntensityModule.updateforce!"><code>FinEtools.ForceIntensityModule.updateforce!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updateforce!(self::ForceIntensity, ndofn::FInt, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the force intensity vector.</p><p>Returns a vector (stored in the cache <code>self.cache</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.updatenormal!" href="#FinEtools.SurfaceNormalModule.updatenormal!"><code>FinEtools.SurfaceNormalModule.updatenormal!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updatenormal!(self::SurfaceNormal, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the surface normal vector.</p><p>Returns a vector (stored in the cache).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.updateretrieve!" href="#FinEtools.VectorCacheModule.updateretrieve!"><code>FinEtools.VectorCacheModule.updateretrieve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updateretrieve!(self::VectorCache, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the cache and retrieve the vector.</p><p>After the return from this function the updated vector can be read from the cache as <code>self.cache</code> (also returned).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelTetMeshingModule.volumes" href="#FinEtools.VoxelTetMeshingModule.volumes"><code>FinEtools.VoxelTetMeshingModule.volumes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">volumes(self::ImageMesher)</code></pre><p>Compute tetrahedral volumes in the current mesh.  </p></div></div></section><pre><code class="language-none">FinEtools.voxeldims</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VoxelBoxModule.vtkexport" href="#FinEtools.VoxelBoxModule.vtkexport"><code>FinEtools.VoxelBoxModule.vtkexport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vtkexport(theFile::String, V::VoxelBoxVolume{CoordT,DataT}) where {CoordT&lt;:Number,DataT&lt;:Number}</code></pre><p>Compute.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.vtkexportmesh" href="#FinEtools.MeshExportModule.vtkexportmesh"><code>FinEtools.MeshExportModule.vtkexportmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T&lt;:FESet}</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p><code>opts</code> = keyword argument list, where <code>scalars</code> = array of tuples, (name, data) <code>vectors</code> = array of tuples, (name, data)</p><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div></div><div><div><pre><code class="language-none">vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;
    vectors=nothing, scalars=nothing)</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p><code>opts</code> = keyword argument list, where <code>scalars</code> = array of tuples, (name, data) <code>vectors</code> = array of tuples, (name, data)</p><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.wipe!" href="#FinEtools.FieldModule.wipe!"><code>FinEtools.FieldModule.wipe!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wipe!(self::Field)</code></pre><p>Wipe all the data from the field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule.xyz3" href="#FinEtools.FENodeSetModule.xyz3"><code>FinEtools.FENodeSetModule.xyz3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xyz3(self::FENodeSet)</code></pre><p>Get the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
