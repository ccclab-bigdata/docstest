<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · Mux.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Mux.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Technical-Overview-1">Technical Overview</a></li><li><a class="toctext" href="#Serving-static-files-from-a-package-1">Serving static files from a package</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mux.jl-1" href="#Mux.jl-1">Mux.jl</a></h1><p><a href="https://travis-ci.org/JuliaWeb/Mux.jl"><img src="https://travis-ci.org/JuliaWeb/Mux.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/shashi/mux-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/iuyp5jrre7s905ay/branch/master?svg=true" alt="Build status"/></a> <a href="https://codecov.io/github/JuliaWeb/Mux.jl?branch=master"><img src="https://codecov.io/github/JuliaWeb/Mux.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p><a href="http://pkg.julialang.org/?pkg=Mux"><img src="http://pkg.julialang.org/badges/Mux_0.3.svg" alt="Mux"/></a> <a href="http://pkg.julialang.org/?pkg=Mux"><img src="http://pkg.julialang.org/badges/Mux_0.4.svg" alt="Mux"/></a></p><pre><code class="language-jl">Pkg.add(&quot;Mux&quot;)</code></pre><p>Mux.jl gives your Julia web services some closure. Mux allows you to define servers in terms of highly modular and composable components called middleware, with the aim of making both simple and complex servers as simple as possible to throw together.</p><p>For example:</p><pre><code class="language-jl">using Mux

@app test = (
  Mux.defaults,
  page(respond(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;)),
  page(&quot;/about&quot;,
       probabilty(0.1, respond(&quot;&lt;h1&gt;Boo!&lt;/h1&gt;&quot;)),
       respond(&quot;&lt;h1&gt;About Me&lt;/h1&gt;&quot;)),
  page(&quot;/user/:user&quot;, req -&gt; &quot;&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;&quot;),
  Mux.notfound())

serve(test)</code></pre><p>You can run this demo by entering the successive forms into the Julia REPL. The code displays a &quot;hello, world&quot; at <code>localhost:8000</code>, with an about page at <code>/about</code> and another hello at <code>/user/[your name]</code>.</p><p>The <code>@app</code> macro allows the server to be redefined on the fly, and you can test this by editing the <code>hello</code> text and re-evaluating. (don&#39;t re-evalute <code>serve(test)</code>)</p><h2><a class="nav-anchor" id="Technical-Overview-1" href="#Technical-Overview-1">Technical Overview</a></h2><p>Mux.jl is at heart a control flow library, with a <a href="https://github.com/one-more-minute/Mux.jl/blob/master/src/Mux.jl#L7-L16">very small core</a>. It&#39;s not important to understand that code exactly as long as you understand what it achieves.</p><p>There are three concepts core to Mux.jl: Middleware (which should be familiar from the web libraries of other languages), stacking, and branching.</p><h3><a class="nav-anchor" id="Apps-and-Middleware-1" href="#Apps-and-Middleware-1">Apps and Middleware</a></h3><p>An <em>app</em> or <em>endpoint</em> is simply a function of a request which produces a response:</p><pre><code class="language-jl">function myapp(req)
  return &quot;&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;&quot;
end</code></pre><p>In principle this should say &quot;hi&quot; to our lovely user. But we have a problem – where does the user&#39;s name come from? Ideally, our app function doesn&#39;t need to know – it&#39;s simply handled at some point up the chain (just the same as we don&#39;t parse the raw HTTP data, for example).</p><p>One way to solve this is via <em>middleware</em>. Say we get <code>:user</code> from a cookie:</p><pre><code class="language-jl">function username(app, req)
  req[:params][:user] = req[:cookies][:user]
  return app(req) # We could also alter the response, but don&#39;t want to here
end</code></pre><p>Middleware simply takes our request and modifies it appropriately, so that data needed later on is available. This example is pretty trivial, but we could equally have middleware which handles authentication and encryption, processes cookies or file uploads, provides default headers, and more.</p><p>We can then call our new version of the app like this:</p><pre><code class="language-jl">username(myapp, req)</code></pre><p>In fact, we can generate a whole new version of the app which has username support built in:</p><pre><code class="language-jl">function app2(req)
  return username(myapp, req)
end</code></pre><p>But if we have a lot of middleware, we&#39;re going to end up with a lot of <code>appX</code> functions. For that reason we can use the <code>mux</code> function instead, which creates the new app for us:</p><pre><code class="language-jl">mux(username, myapp)</code></pre><p>This returns a <em>new</em> function which is equivalent to <code>app2</code> above. We just didn&#39;t have to write it by hand.</p><h3><a class="nav-anchor" id="Stacking-1" href="#Stacking-1">Stacking</a></h3><p>Now suppose you have lots of middleware – one to parse the HTTP request into a dict of properties, one to check user authentication, one to catches errors, etc. <code>mux</code> handles this too – just pass it multiple arguments:</p><pre><code class="language-jl">mux(todict, auth, catch_errors, app)</code></pre><p>Again, <code>mux</code> returns a whole new app (a <code>request -&gt; response</code> function) for us, this time wrapped with the three middlewares we provided. <code>todict</code> will be the first to make changes to the incoming request, and the last to alter the outgoing response.</p><p>Another neat thing we can do is to compose middleware into more middleware:</p><pre><code class="language-jl">mymidware = stack(todict, auth, catch_errors)
mux(mymidware, app)</code></pre><p>This is effectively equivalent to the <code>mux</code> call above, but creating a new middleware function from independent parts means we&#39;re able to factor out our service to make things more readable. For example, Mux provides the <code>Mux.default</code> middleware which is actually just a stack of useful tools.</p><p><code>stack</code> is self-flattening, i.e.</p><pre><code class="language-jl">stack(a, b, c, d) == stack(a, stack(b, c), d) == stack(stack(a, b, c), d)</code></pre><p>etc.</p><h3><a class="nav-anchor" id="Branching-1" href="#Branching-1">Branching</a></h3><p>Mux.jl goes further with middleware, and expresses routing and decisions as middleware themselves. The key to this is the <code>branch</code> function, which takes</p><ol><li>a predicate to apply to the incoming request, and</li><li>an endpoint to run on the request if the predicate returns true.</li></ol><p>For example:</p><pre><code class="language-jl">mux(branch(_ -&gt; rand() &lt; 0.1, respond(&quot;Hello&quot;)),
    respond(&quot;Hi&quot;))</code></pre><p>In this example, we ignore the request and simply return true 10% of the time. You can test this in the repl by calling</p><pre><code class="language-jl">mux(branch(_ -&gt; rand() &lt; 0.1, respond(&quot;Hello&quot;)),
    respond(&quot;Hi&quot;))(nothing)</code></pre><p>(since the request is ignored anyway, it doesn&#39;t matter if we set it to <code>nothing</code>).</p><p>We can also define a function to wrap the branch</p><pre><code class="language-jl">probabilty(x, app) = branch(_ -&gt; rand() &lt; x, app)</code></pre><h3><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h3><p>Despite the fact that endpoints and middleware are so important in Mux, it&#39;s common to not write them by hand. For example, <code>respond(&quot;hi&quot;)</code> creates a function <code>_ -&gt; &quot;hi&quot;</code> which can be used as an endpoint. Equally, functions like <code>status(404)</code> will create middleware which applies the given status to the response. Mux.jl&#39;s &quot;not found&quot; endpoint is therefore defined as</p><pre><code class="language-jl">notfound(s = &quot;Not found&quot;) = mux(status(404), respond(s))</code></pre><p>which is a much more declarative approach.</p><p>For example:</p><ul><li><code>respond(x)</code> – creates an endpoint that responds with <code>x</code>, regardless of the request.</li><li><code>route(&quot;/path/here&quot;, app)</code> – branches to <code>app</code> if the request location matches <code>&quot;/path/here&quot;</code>.</li><li><code>page(&quot;/path/here&quot;, app)</code> – branches to <code>app</code> if the request location <em>exactly</em> matches <code>&quot;/path/here&quot;</code></li></ul><h2><a class="nav-anchor" id="Serving-static-files-from-a-package-1" href="#Serving-static-files-from-a-package-1">Serving static files from a package</a></h2><p>The <code>Mux.pkgfiles</code> middleware (included in <code>Mux.defaults</code>) serves static files under the <code>assets</code> directory in any Julia package at <code>/pkg/&lt;PACKAGE&gt;/</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
