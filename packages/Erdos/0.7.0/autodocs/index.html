<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Erdos.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Erdos.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ADiGraph" href="#Erdos.ADiGraph"><code>Erdos.ADiGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract ADiGraph</code></pre><p>Abstract directed graph type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ADiNetwork" href="#Erdos.ADiNetwork"><code>Erdos.ADiNetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type ADiNetwork &lt;: ADiGraph end</code></pre><p>An abstract directed graph with the additional possibility to attach properties to vertices and edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AEdge" href="#Erdos.AEdge"><code>Erdos.AEdge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AEdge end</code></pre><p>An abstract edge type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AEdgeMap" href="#Erdos.AEdgeMap"><code>Erdos.AEdgeMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AEdgeMap{T} end</code></pre><p>Type representing an abstract edge map with value type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AGraph" href="#Erdos.AGraph"><code>Erdos.AGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AGraph end</code></pre><p>Abstract undirected graph type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AGraphOrDiGraph" href="#Erdos.AGraphOrDiGraph"><code>Erdos.AGraphOrDiGraph</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">const AGraphOrDiGraph = Union{AGraph, ADiGraph}</code></pre><p>Union of <a href="#Erdos.AGraph"><code>AGraph</code></a> and <a href="#Erdos.ADiGraph"><code>ADiGraph</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AIndexedEdge" href="#Erdos.AIndexedEdge"><code>Erdos.AIndexedEdge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AIndexedEdge &lt;: AEdge end</code></pre><p>Edge types with unique indexes, accessed by <a href="#Erdos.idx"><code>idx</code></a></p></div></div></section><pre><code class="language-none">Erdos.ANetOrDiNet</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ANetwork" href="#Erdos.ANetwork"><code>Erdos.ANetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type ANetwork &lt;: AGraph end</code></pre><p>An abstract graph with the additional possibility to attach properties to vertices and edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AVertexMap" href="#Erdos.AVertexMap"><code>Erdos.AVertexMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AVertexMap{T} end</code></pre><p>Type representing an abstract vertex map with value type <code>T</code>.</p></div></div></section><pre><code class="language-none">Erdos.AbstractDijkstraState</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AbstractFlowAlgorithm" href="#Erdos.AbstractFlowAlgorithm"><code>Erdos.AbstractFlowAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>abstract type that allows users to pass in their preferred Algorithm</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.AbstractMultirouteFlowAlgorithm" href="#Erdos.AbstractMultirouteFlowAlgorithm"><code>Erdos.AbstractMultirouteFlowAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>abstract type that allows users to pass in their preferred Algorithm</p></div></div></section><pre><code class="language-none">Erdos.AbstractPathState</code></pre><pre><code class="language-none">Erdos.BellmanFordState</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.BinaryTree" href="#Erdos.BinaryTree"><code>Erdos.BinaryTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">BinaryTree(levels, G=Graph)</code></pre><p>Creates a binary tree with k-levels vertices are numbered 1:2^levels-1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.BoundedMinkowskiCost" href="#Erdos.BoundedMinkowskiCost"><code>Erdos.BoundedMinkowskiCost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Similar to MinkowskiCost, but ensures costs smaller than 2τ.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.BoykovKolmogorovAlgorithm" href="#Erdos.BoykovKolmogorovAlgorithm"><code>Erdos.BoykovKolmogorovAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.</p></div></div></section><pre><code class="language-none">Erdos.BullGraph</code></pre><pre><code class="language-none">Erdos.ChvatalGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CliqueGraph" href="#Erdos.CliqueGraph"><code>Erdos.CliqueGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CliqueGraph(k, n, G=Graph)</code></pre><p>This function generates a graph with <code>n</code> <code>k</code>-cliques connected circularly by <code>n</code> edges.</p></div></div></section><pre><code class="language-none">Erdos.CombinatorialAdjacency</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CompleteBipartiteGraph" href="#Erdos.CompleteBipartiteGraph"><code>Erdos.CompleteBipartiteGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CompleteBipartiteGraph(n1, n2, G = Graph)</code></pre><p>Creates a complete bipartite graph with <code>n1+n2</code> vertices. It has edges connecting each pair of vertices in the two sets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CompleteDiGraph" href="#Erdos.CompleteDiGraph"><code>Erdos.CompleteDiGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CompleteDiGraph(n, G = DiGraph)</code></pre><p>Creates a complete digraph with <code>n</code> vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CompleteGraph" href="#Erdos.CompleteGraph"><code>Erdos.CompleteGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CompleteGraph(n, G = Graph)</code></pre><p>Creates a complete graph of type <code>G</code> with <code>n</code> vertices. A complete graph has edges connecting each pair of vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ConstEdgeMap" href="#Erdos.ConstEdgeMap"><code>Erdos.ConstEdgeMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ConstEdgeMap{T} &lt;: SimpleEdgeMap{T}
    val::T
end</code></pre><p>A type representing a constant vector map. Any attempt to change the internal value, e.g. <code>emap[u,v] = 4</code>, will fail silently.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ConstVertexMap" href="#Erdos.ConstVertexMap"><code>Erdos.ConstVertexMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct ConstVertexMap{T} &lt;: AVertexMap{T}
    val::T
end</code></pre><p>A type representing a constant vector map. Any attempt to change the internal value, e.g. <code>vm[1] = 4</code>, will fail silently.</p></div></div></section><pre><code class="language-none">Erdos.CubicalGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CycleDiGraph" href="#Erdos.CycleDiGraph"><code>Erdos.CycleDiGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a cycle digraph with <code>n</code> vertices. A cycle digraph is a closed path digraph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.CycleGraph" href="#Erdos.CycleGraph"><code>Erdos.CycleGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CycleGraph(n, G=Graph)</code></pre><p>Creates a cycle graph with <code>n</code> vertices. A cycle graph is a closed path graph.</p></div></div></section><pre><code class="language-none">Erdos.DATASETS_DIR</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.DefaultCapacity" href="#Erdos.DefaultCapacity"><code>Erdos.DefaultCapacity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type that returns 1 if a forward edge exists, and 0 otherwise</p></div></div></section><pre><code class="language-none">Erdos.DefaultEditHeuristic</code></pre><pre><code class="language-none">Erdos.DesarguesGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.DiGraph" href="#Erdos.DiGraph"><code>Erdos.DiGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct DiGraph{T&lt;:Integer} &lt;: ADiGraph
    ne::Int
    fadjlist::Vector{Vector{T}}
    badjlist::Vector{Vector{T}}
end</code></pre><p>A simple digraph type based on two adjacency lists (forward and backward).</p><pre><code class="language-none">DiGraph{T}(n=0)
DiGraph(n=0) = DiGraph{Int}(n)</code></pre><p>Construct a <code>DiGraph</code> with <code>n</code> vertices and no edges.</p><pre><code class="language-none">DiGraph{T}(adjmx::AbstractMatrix; selfedges=true)</code></pre><p>Construct a <code>DiGraph{T}</code> from the adjacency matrix <code>adjmx</code>, placing an edge in correspondence to each nonzero element of <code>adjmx</code>. If <code>selfedges=false</code> the diagonal elements of <code>adjmx</code> are ignored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.DiNetwork" href="#Erdos.DiNetwork"><code>Erdos.DiNetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct DiNetwork &lt;: ADiNetwork
    ne::Int
    edge_index_range::Int
    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist
    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist

    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges
                                    # the first in the pair is the vertex
                                    # with lower index

    free_indexes::Vector{Int}       # indexes of deleted edges to be used up
                                    # for new edges to avoid very large
                                    # indexes, and unnecessary property map
                                    # memory use
    props::PropertyStore
end</code></pre><p>A type representing an directed graph with indexed edges.</p><pre><code class="language-none">DiNetwork(n=0)</code></pre><p>Construct a <code>DiNetwork</code> with <code>n</code> vertices and no edges.</p><pre><code class="language-none">DiNetwork(adjmx::AbstractMatrix; selfedges=true)</code></pre><p>Construct a <code>DiNetwork</code> from the adjacency matrix <code>adjmx</code>. If <code>selfedges=false</code> the diagonal elements of <code>adjmx</code> are ignored.</p></div></div></section><pre><code class="language-none">Erdos.DiamondGraph</code></pre><pre><code class="language-none">Erdos.DijkstraHeapEntry</code></pre><pre><code class="language-none">Erdos.DijkstraState</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.DinicAlgorithm" href="#Erdos.DinicAlgorithm"><code>Erdos.DinicAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the maximum_flow function to use Dinic&#39;s algorithm.</p></div></div></section><pre><code class="language-none">Erdos.DodecahedralGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.DoubleBinaryTree" href="#Erdos.DoubleBinaryTree"><code>Erdos.DoubleBinaryTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">DoubleBinaryTree(levels, G=Graph)</code></pre><p>Create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.Edge" href="#Erdos.Edge"><code>Erdos.Edge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct Edge
    src::Int
    dst::Int
end</code></pre><p>A type representing an edge between two vertices of a graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.EdgeMap" href="#Erdos.EdgeMap"><code>Erdos.EdgeMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct EdgeMap{G &lt;: AGraphOrDiGraph, T, D} &lt;: AEdgeMap{T}
    g::G
    vtype::Type{T}
    data::D
end</code></pre><p>Type implementing an edge map. The underlying container <code>data</code> can be a dictionary, a matrix or a vector (for graphs with indexed edges).</p><pre><code class="language-none">EdgeMap{T}(g, ::Type{T})</code></pre><p>Returns a map that associates values of type <code>T</code> to the vertices of  graph <code>g</code>. The underlying storage structures is chosen accordingly.</p><pre><code class="language-none">EdgeMap(g, data)</code></pre><p>Construct a EdgeMap with <code>data</code> as underlying storage. The storage type can be a matrix or an associative <code>edg =&gt; val</code> type or a vector for graph with indexed edges.</p><pre><code class="language-none">EdgeMap(g, f)</code></pre><p>Construct an edge map with value <code>f(e)</code> for each <code>e</code> in <code>edges(g)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.EdmondsKarpAlgorithm" href="#Erdos.EdmondsKarpAlgorithm"><code>Erdos.EdmondsKarpAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the maximum_flow function to use the Edmonds–Karp algorithm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.Erdos" href="#Erdos.Erdos"><code>Erdos.Erdos</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A graph and network analysis package for julia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ExtendedMultirouteFlowAlgorithm" href="#Erdos.ExtendedMultirouteFlowAlgorithm"><code>Erdos.ExtendedMultirouteFlowAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.</p></div></div></section><pre><code class="language-none">Erdos.FloydWarshallState</code></pre><pre><code class="language-none">Erdos.FruchtGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.Graph" href="#Erdos.Graph"><code>Erdos.Graph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct Graph{T&lt;:Integer} &lt;: AGraph
    ne::Int
    fadjlist::Vector{Vector{T}}
end</code></pre><p>A simple graph type based on an adjacency list.</p><pre><code class="language-none">Graph{T}(n=0)
Graph(n=0) = Graph{Int}(n)</code></pre><p>Construct a <code>Graph</code> with <code>n</code> vertices and no edges.</p><pre><code class="language-none">Graph{T}(adjmx::AbstractMatrix; upper=false, selfedges=true)</code></pre><p>Construct a <code>Graph{T}</code> from the adjacency matrix <code>adjmx</code>, placing an edge in correspondence to each nonzero element of <code>adjmx</code>. If <code>selfedges=false</code> the diagonal elements of <code>adjmx</code> are ignored. If <code>upper=true</code> only the upper triangular part of <code>adjmx</code> is considered.</p></div></div></section><pre><code class="language-none">Erdos.GraphOrDiGraph</code></pre><pre><code class="language-none">Erdos.GreaterThan2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.Grid" href="#Erdos.Grid"><code>Erdos.Grid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Grid(dims::AbstractVector, G=Graph; periodic=false)</code></pre><p>Creates a <code>d</code>-dimensional cubic lattice, with <code>d=length(dims)</code> and length  <code>dims[i]</code> in dimension <code>i</code>. If <code>periodic=true</code> the resulting lattice will have periodic boundary condition in each dimension.</p></div></div></section><pre><code class="language-none">Erdos.HeawoodGraph</code></pre><pre><code class="language-none">Erdos.HouseGraph</code></pre><pre><code class="language-none">Erdos.HouseXGraph</code></pre><pre><code class="language-none">Erdos.IcosahedralGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.IndexedEdge" href="#Erdos.IndexedEdge"><code>Erdos.IndexedEdge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct IndexedEdge &lt;: AIndexedEdge
    src::Int
    dst::Int
    idx::Int
end</code></pre><p>An indexed edge type</p><pre><code class="language-none">IndexedEdge(u, v) = IndexedEdge(u,v,-1)</code></pre><p>Creates an edge with invalid index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.KishimotoAlgorithm" href="#Erdos.KishimotoAlgorithm"><code>Erdos.KishimotoAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the multiroute_flow function to use the Kishimoto algorithm.</p></div></div></section><pre><code class="language-none">Erdos.KrackhardtKiteGraph</code></pre><pre><code class="language-none">Erdos.KruskalHeapEntry</code></pre><pre><code class="language-none">Erdos.LessThan2</code></pre><pre><code class="language-none">Erdos.MaximumAdjacency</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.MinkowskiCost" href="#Erdos.MinkowskiCost"><code>Erdos.MinkowskiCost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.</p></div></div></section><pre><code class="language-none">Erdos.MoebiusKantorGraph</code></pre><pre><code class="language-none">Erdos.NI</code></pre><pre><code class="language-none">Erdos.NegativeCycleError</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.NeighComm" href="#Erdos.NeighComm"><code>Erdos.NeighComm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type to record neighbor labels and their counts.</p></div></div></section><pre><code class="language-none">Erdos.NetOrDiNet</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.Network" href="#Erdos.Network"><code>Erdos.Network</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct Network &lt;: ANetwork
    ne::Int
    edge_index_range::Int
    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist
    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges
    free_indexes::Vector{Int}       # indexes of deleted edges to be used up
                                    # for new edges to avoid very large
                                    # indexes, and unnecessary property map
                                    # memory used
    props::PropertyStore
end</code></pre><p>A type representing a directed graph with indexed edges.</p><pre><code class="language-none">Network(n=0)</code></pre><p>Construct a <code>Network</code> with <code>n</code> vertices and no edges.</p><pre><code class="language-none">Network(adjmx::AbstractMatrix; selfedges=true, upper=false)</code></pre><p>Construct a <code>Network</code> from the adjacency matrix <code>adjmx</code>, placing an edge in correspondence to each nonzero element of <code>adjmx</code>. If <code>selfedges=false</code> the diagonal elements of <code>adjmx</code> are ignored. If <code>upper=true</code> only the upper triangular part of <code>adjmx</code> is considered.</p></div></div></section><pre><code class="language-none">Erdos.Num</code></pre><pre><code class="language-none">Erdos.OctahedralGraph</code></pre><pre><code class="language-none">Erdos.PappusGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.PathDiGraph" href="#Erdos.PathDiGraph"><code>Erdos.PathDiGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PathDiGraph(n, G = DiGraph)</code></pre><p>Creates a path digraph with <code>n</code> vertices. A path graph connects each successive vertex by a single directed edge.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.PathGraph" href="#Erdos.PathGraph"><code>Erdos.PathGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PathGraph(n, G = Graph)</code></pre><p>Creates a path graph with <code>n</code> vertices. A path graph connects each successive vertex by a single edge.</p></div></div></section><pre><code class="language-none">Erdos.PetersenGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.PropertyStore" href="#Erdos.PropertyStore"><code>Erdos.PropertyStore</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct PropertyStore
    gmaps::Dict{String, Any}
    emaps::Dict{String,AEdgeMap}
    vmaps::Dict{String,AVertexMap}
end</code></pre><p>A type storing properties associated to networks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.PushRelabelAlgorithm" href="#Erdos.PushRelabelAlgorithm"><code>Erdos.PushRelabelAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Forces the maximum_flow function to use the Push-Relabel algorithm.</p></div></div></section><pre><code class="language-none">Erdos.PushRelabelHeap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.RoachGraph" href="#Erdos.RoachGraph"><code>Erdos.RoachGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The Roach Graph from Guattery and Miller 1998</p></div></div></section><pre><code class="language-none">Erdos.SedgewickMazeGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.StarDiGraph" href="#Erdos.StarDiGraph"><code>Erdos.StarDiGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a star digraph with <code>n</code> vertices. A star digraph has a central vertex with directed edges to every other vertex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.StarGraph" href="#Erdos.StarGraph"><code>Erdos.StarGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">StarGraph(n, G = Graph)</code></pre><p>Creates a star graph with <code>n</code> vertices. A star graph has a central vertex with edges to each other vertex.</p></div></div></section><pre><code class="language-none">Erdos.StochasticBlockModel</code></pre><pre><code class="language-none">Erdos.TetrahedralGraph</code></pre><pre><code class="language-none">Erdos.TruncatedCubeGraph</code></pre><pre><code class="language-none">Erdos.TruncatedTetrahedronDiGraph</code></pre><pre><code class="language-none">Erdos.TruncatedTetrahedronGraph</code></pre><pre><code class="language-none">Erdos.TutteGraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.VertexMap" href="#Erdos.VertexMap"><code>Erdos.VertexMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct VertexMap{G &lt;: AGraphOrDiGraph, T, D} &lt;: AVertexMap{T}
    g::G
    vtype::Type{T}
    data::D
end</code></pre><p>Type implementing an edge map. The underlying container <code>data</code> can be a dictionary or a vector.</p><pre><code class="language-none">VertexMap{T}(g, ::Type{T})</code></pre><p>Returns a map that associates values of type <code>T</code> to the vertices of  graph <code>g</code>. The underlying storage structures is chosen accordingly.</p><pre><code class="language-none">VertexMap(g, data)</code></pre><p>Construct a VertexMap with <code>data</code> as underlying storage.</p><pre><code class="language-none">VertexMap(g, f)</code></pre><p>Construct a vertex map with value <code>f(u)</code> for each <code>u=1:nv(g)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.WheelDiGraph" href="#Erdos.WheelDiGraph"><code>Erdos.WheelDiGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a wheel digraph with <code>n</code> vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.WheelGraph" href="#Erdos.WheelGraph"><code>Erdos.WheelGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">WheelGraph(n, G=Graph)</code></pre><p>Creates a wheel graph with <code>n</code> vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.</p></div></div></section><pre><code class="language-none">Erdos._accumulate_basic!</code></pre><pre><code class="language-none">Erdos._accumulate_endpoints!</code></pre><pre><code class="language-none">Erdos._bfs_parents</code></pre><pre><code class="language-none">Erdos._build_subnetwork!</code></pre><pre><code class="language-none">Erdos._build_subraph!</code></pre><pre><code class="language-none">Erdos._complete</code></pre><pre><code class="language-none">Erdos._construct_fitness</code></pre><pre><code class="language-none">Erdos._create_static_fitness_graph!</code></pre><pre><code class="language-none">Erdos._degree_centrality</code></pre><pre><code class="language-none">Erdos._dfs_parents</code></pre><pre><code class="language-none">Erdos._graph_from_matr!</code></pre><pre><code class="language-none">Erdos._insert_and_dedup!</code></pre><pre><code class="language-none">Erdos._magic</code></pre><pre><code class="language-none">Erdos._myrand</code></pre><pre><code class="language-none">Erdos._neighborhood</code></pre><pre><code class="language-none">Erdos._printstrvec</code></pre><pre><code class="language-none">Erdos._readgml</code></pre><pre><code class="language-none">Erdos._readnetgml</code></pre><pre><code class="language-none">Erdos._rem_vertices!</code></pre><pre><code class="language-none">Erdos._rescale!</code></pre><pre><code class="language-none">Erdos._sort</code></pre><pre><code class="language-none">Erdos._suitable</code></pre><pre><code class="language-none">Erdos._try_creation_rrg</code></pre><pre><code class="language-none">Erdos._version</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.a_star" href="#Erdos.a_star"><code>Erdos.a_star</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_star(g, s, t, distmx=weights(g), heuristic = n-&gt;0)</code></pre><p>Computes the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.</p></div></div></section><pre><code class="language-none">Erdos.a_star_impl!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.add_edge!" href="#Erdos.add_edge!"><code>Erdos.add_edge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_edge!(g, e) -&gt; (ok, new_edge)</code></pre><p>Add to <code>g</code> the edge <code>e</code>.</p><pre><code class="language-none">add_edge!(g, u, v) -&gt; (ok, new_edge)</code></pre><p>Add to <code>g</code> an edge from <code>u</code> to <code>v</code>.</p><p><code>ok=false</code> if add fails (e.g. if vertices are not in the graph or the edge is already present) and <code>true</code> otherwise. <code>new_edge</code> is the descriptor of the new edge.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.add_edge_property!" href="#Erdos.add_edge_property!"><code>Erdos.add_edge_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_edge_property!(g, name, T)
add_edge_property!(g, name, emap)</code></pre><p>Add the edge property  <code>name</code> to <code>g</code>.</p><p>If a type <code>T</code> is given as an input, an edge map with valtype <code>T</code> is created and stored into <code>g</code>.</p><p>As an alternative, an existing edge map <code>emap</code> can be stored into <code>g</code>.</p><p><a href="#Erdos.eprop!"><code>eprop!</code></a> is the short form of this function.</p><p><strong>Example</strong></p><pre><code class="language-julia">g = random_regular_graph(10, 3, Network)

add_edge_property!(g, &quot;weight&quot;, Float64)
# or equivalently
eprop!(g, &quot;weight&quot;, Float64)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.add_vertex!" href="#Erdos.add_vertex!"><code>Erdos.add_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_vertex!(g)</code></pre><p>Add a new vertex to the graph <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.add_vertex_property!" href="#Erdos.add_vertex_property!"><code>Erdos.add_vertex_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_vertex_property!(g, name, T)
add_vertex_property!(g, name, vmap)</code></pre><p>Add the vertex property  <code>name</code> to <code>g</code>.</p><p>If a type <code>T</code> is given as an input, a vertex map with valtype <code>T</code> is created and stored into <code>g</code>.</p><p>As an alternative, an existing vertex map <code>vmap</code> can be stored into <code>g</code>.</p><p><a href="#Erdos.vprop!"><code>vprop!</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.add_vertices!" href="#Erdos.add_vertices!"><code>Erdos.add_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_vertices!(g, n)</code></pre><p>Add <code>n</code> new vertices to the graph <code>g</code>. Returns the final number of vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.adjacency_list" href="#Erdos.adjacency_list"><code>Erdos.adjacency_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">adjacency_list(g::AGraph)
adjacency_list(g::ADiGraph, dir=:out)</code></pre><p>Returns the adjacency list <code>a</code> of a graph (a vector of vector of ints). The <code>i</code>-th element of the adjacency list is a vector containing the neighbors of <code>i</code> in <code>g</code>.</p><p>For directed graphs a second optional argument can be specified (<code>:out</code> or <code>:in</code>). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.</p><p>The elements of  <code>a[i]</code> have the same order as in the iterator <code>(out_/in_)neighbors(g,i)</code>.</p><p><em>Attention</em>: For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.adjacency_matrix" href="#Erdos.adjacency_matrix"><code>Erdos.adjacency_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">adjacency_matrix(g, dir=:out, T::DataType=Int)</code></pre><p>Returns a sparse boolean adjacency matrix for a graph, indexed by <code>[u, v]</code> vertices. <code>true</code> values indicate an edge between <code>u</code> and <code>v</code>. Users may specify a direction (<code>:in</code>, <code>:out</code>, or <code>:all</code> are currently supported; <code>:out</code> is default for both directed and undirected graphs) and a data type for the matrix (defaults to <code>Int</code>).</p></div></div></section><pre><code class="language-none">Erdos.adjacency_spectrum</code></pre><pre><code class="language-none">Erdos.adopt!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.all_edges" href="#Erdos.all_edges"><code>Erdos.all_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">all_edges(g, v)</code></pre><p>Iterates over all in and out edges of vertex <code>v</code> in <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.all_neighbors" href="#Erdos.all_neighbors"><code>Erdos.all_neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">all_neighbors(g, v)</code></pre><p>Iterates over all distinct in/out neighbors of vertex <code>v</code> in <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.attracting_components" href="#Erdos.attracting_components"><code>Erdos.attracting_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">attracting_components(g)</code></pre><p>Return a vector of vectors of integers representing lists of attracting components in the directed graph <code>g</code>.</p><p>The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; attracting_components(g)
1-element Array{Array{Int64,1},1}:
 [4, 5]</code></pre></div></div></section><pre><code class="language-none">Erdos.augment!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.augment_path!" href="#Erdos.augment_path!"><code>Erdos.augment_path!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the amount by which flow can be augmented in the given path. Augments the flow and returns the augment value. Requires arguments:</p><ul><li>path::Vector{Int}                      # input path</li><li>flow_matrix::AbstractMatrix{T}        # the current flow matrix</li><li>capacity_matrix::AbstractMatrix{T}    # edge flow capacities</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.auxiliaryPoints" href="#Erdos.auxiliaryPoints"><code>Erdos.auxiliaryPoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Output a set of (point,slope) that compose the restricted max-flow function. One point by possible slope is enough (hence O(λ×max_flow) complexity). Requires arguments:</p><ul><li>flow_graph::ADiGraph                    # the input graph</li><li>source::Int                            # the source vertex</li><li>target::Int                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}   # edge flow capacities</li></ul></div></div></section><pre><code class="language-none">Erdos.badj</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.barabasi_albert" href="#Erdos.barabasi_albert"><code>Erdos.barabasi_albert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barabasi_albert(n, k, G=Graph; seed=-1)
barabasi_albert(n, n0, k, G=Graph; seed=-1)</code></pre><p>Creates a random graph of type <code>G</code> with <code>n</code> vertices according to <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a>. It is grown by adding new vertices to an initial graph with <code>n0</code> vertices (<code>n0=k</code> if not specified). Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment. The initial graph is empty by default.</p><p>Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. <code>DiGraph</code>).</p><p>See also <a href="#Erdos.barabasi_albert!"><code>barabasi_albert!</code></a> for growing a given graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.barabasi_albert!" href="#Erdos.barabasi_albert!"><code>Erdos.barabasi_albert!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barabasi_albert!(g, n::Int, k::Int; seed::Int = -1)</code></pre><p>Grows the graph <code>g</code> according to <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert</a> process into a graph with <code>n</code> vertices. At each step a new vertex is attached by preferential attachment to <code>k</code> different vertices already present in the graph.</p><p>See also <a href="#Erdos.barabasi_albert"><code>barabasi_albert</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.bellman_ford_shortest_paths" href="#Erdos.bellman_ford_shortest_paths"><code>Erdos.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, sources, distmx=weights(g))</code></pre><p>Uses the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a> to compute shortest paths of all vertices of a <code>g</code> from a source vertex <code>s</code> (or a set of source vertices <code>sources</code>). Returns a <code>BellmanFordState</code> with relevant traversal information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.betweenness_centrality" href="#Erdos.betweenness_centrality"><code>Erdos.betweenness_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">betweenness_centrality(g; normalize=true, endpoints=false, approx=-1)</code></pre><p>Calculates the <a href="https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality">betweenness centrality</a> of the vertices of graph <code>g</code>.</p><p>Betweenness centrality for vertex <code>v</code> is defined as:</p><div>\[bc(v) = \frac{1}{\mathcal{N}} \sum_{s \neq t \neq v}
        \frac{\sigma_{st}(v)}{\sigma_{st}},\]</div><p>where <span>$\sigma _{st}} \sigma_{st}$</span> is the total number of shortest paths from node <code>s</code> to node <code>t</code> and <span>$\sigma_{st}(v)$</span> is the number of those paths that pass through <code>v</code>.</p><p>If <code>endpoints=true</code>, endpoints are included in the shortest path count.</p><p>If <code>normalize=true</code>, the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if <code>((n-1)*(n-2))/2</code> and for a directed graph, <code>(n-1)*(n-2)</code> where <code>n</code> is the number of vertices in the graph.</p><p>If  an integer argument <code>approx &gt; 0</code> is given, returns an approximation of the betweenness centrality of each vertex of the graph involving <code>approx</code> randomly chosen vertices.</p><p><strong>References</strong></p><p>[1] Brandes 2001 &amp; Brandes 2008</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.bfs_parents" href="#Erdos.bfs_parents"><code>Erdos.bfs_parents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.bfs_tree" href="#Erdos.bfs_tree"><code>Erdos.bfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.bipartite_map" href="#Erdos.bipartite_map"><code>Erdos.bipartite_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bipartite_map(g) -&gt; Vector{UInt8}</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or <span>$c_i == 2$</span>). If <code>g</code> is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x01
 0x01

julia&gt; add_vertices!(g, 3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x02
 0x01</code></pre></div></div></section><pre><code class="language-none">Erdos.blockcounts</code></pre><pre><code class="language-none">Erdos.blockfractions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.blocking_flow!" href="#Erdos.blocking_flow!"><code>Erdos.blocking_flow!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Uses BFS to identify a blocking flow in the input graph and then backtracks from the targetto the source, aumenting flow along all possible paths.</p><p>Requires arguments: residual<em>graph::ADiGraph                # the input graph source::Int                            # the source vertex target::Int                            # the target vertex capacity</em>matrix::AbstractMatrix{T}    # edge flow capacities flow_matrix::AbstractMatrix{T}        # the current flow matrix</p></div></div><div><div><p>blocking<em>flow! Preallocated version of blocking</em>flow.Uses BFS to identify a blocking flow in the input graph and then backtracks from the target to the source, aumenting flow along all possible paths.</p><p>Requires arguments: residual<em>graph::ADiGraph                # the input graph source::Int                            # the source vertex target::Int                            # the target vertex capacity</em>matrix::AbstractMatrix{T}    # edge flow capacities flow_matrix::AbstractMatrix{T}        # the current flow matrix P::AbstractVector{Int}               # Parent vector to store Level Graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.boykov_kolmogorov_impl" href="#Erdos.boykov_kolmogorov_impl"><code>Erdos.boykov_kolmogorov_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the max-flow/min-cut between source and target using Boykov-Kolmogorov algorithm.</p><p>Returns the maximum flow in the network, the flow matrix and the partition {S,T} in the form of a vector of 1&#39;s and 2&#39;s. The partition vector may also contain 0&#39;s. These can be assigned any label (1 or 2), it is a user choice.</p><p>For further details, please refer to the paper:</p><p>BOYKOV, Y.; KOLMOGOROV, V., 2004. An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision.</p><p>Uses a default capacity of 1 when the capacity matrix isn&#39;t specified.</p><p>Requires arguments: residual<em>graph::ADiGraph                # the input graph source::Int                            # the source vertex target::Int                            # the target vertex capacity</em>matrix::AbstractMatrix{T}    # edge flow capacities</p><p>Author: Júlio Hoffimann Mendes (juliohm@stanford.edu)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.breakingPoints" href="#Erdos.breakingPoints"><code>Erdos.breakingPoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the breaking of the restricted max-flow from a set of auxiliary points. Requires arguments:</p><ul><li>flow_graph::ADiGraph                    # the input graph</li><li>source::Int                            # the source vertex</li><li>target::Int                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}   # edge flow capacities</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.cartesian_product" href="#Erdos.cartesian_product"><code>Erdos.cartesian_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cartesian_product(g, h)</code></pre><p>Returns the (cartesian product)[https://en.wikipedia.org/wiki/Cartesian<em>product</em>of_graphs] of <code>g</code> and <code>h</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.center" href="#Erdos.center"><code>Erdos.center</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">center(g, distmx=weights(g))
center(all_ecc)</code></pre><p>Returns the set of all vertices whose eccentricity is equal to the graph&#39;s radius (that is, the set of vertices with the smallest eccentricity).</p><p>Eventually a vector <code>all_ecc</code> contain the eccentricity of each node can be passed as argument.</p><p>See <a href="#Erdos.eccentricities"><code>eccentricities</code></a>.</p></div></div></section><pre><code class="language-none">Erdos.ci</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.clean_vertex!" href="#Erdos.clean_vertex!"><code>Erdos.clean_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clean_vertex!(g, v)</code></pre><p>Remove all incident edges on vertex <code>v</code> in <code>g</code>.</p></div></div></section><pre><code class="language-none">Erdos.close_vertex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.closeness_centrality" href="#Erdos.closeness_centrality"><code>Erdos.closeness_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the <a href="https://en.wikipedia.org/wiki/Centrality#Closeness_centrality">closeness centrality</a> of the graph <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.community_detection_bethe" href="#Erdos.community_detection_bethe"><code>Erdos.community_detection_bethe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">community_detection_bethe(g::AGraph, k=-1; kmax=15)</code></pre><p>Community detection using the spectral properties of the Bethe Hessian matrix associated to <code>g</code> (see <a href="http://papers.nips.cc/paper/5520-spectral-clustering-of-graphs-with-the-bethe-hessian">Saade et al.</a>). <code>k</code> is the number of communities to detect. If omitted or if <code>k &lt; 1</code> the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by <code>kmax</code>. Returns a vector containing the vertex assignments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.community_detection_nback" href="#Erdos.community_detection_nback"><code>Erdos.community_detection_nback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">community_detection_nback(g, k)</code></pre><p>Community detection using the spectral properties of the non-backtracking matrix of graph <code>g</code> (see <a href="http://www.pnas.org/content/110/52/20935.short">Krzakala et al.</a>). <code>k</code> is the number of communities to detect.</p><p>See also <a href="#Erdos.community_detection_bethe"><code>community_detection_bethe</code></a> for a related community ddetection algorithm.</p><p>Returns a vector with the vertex assignments in the communities.</p></div></div></section><pre><code class="language-none">Erdos.community_detection_threshold</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.complement" href="#Erdos.complement"><code>Erdos.complement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">complement(g)</code></pre><p>Produces the <a href="https://en.wikipedia.org/wiki/Complement_graph">graph complement</a> of a graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.complete" href="#Erdos.complete"><code>Erdos.complete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">complete(g::ADiGraph)</code></pre><p>Returns a digraph containing both the edges <code>(u, v)</code> of <code>g</code> and their reverse <code>(v, u)</code>. See also <a href="#Erdos.complete!"><code>complete!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.complete!" href="#Erdos.complete!"><code>Erdos.complete!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">complete!(g::ADiGraph)</code></pre><p>For each edge <code>(u, v)</code> in <code>g</code>, adds to <code>g</code> its reverse, i.e. <code>(v, u)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.components" href="#Erdos.components"><code>Erdos.components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">components(labels)</code></pre><p>Given a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.components_dict" href="#Erdos.components_dict"><code>Erdos.components_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">components_dict(labels)</code></pre><p>Convert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.condensation" href="#Erdos.condensation"><code>Erdos.condensation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">condensation(g[, scc])</code></pre><p>Return the condensation graph of the strongly connected components <code>scc</code> in the directed graph <code>g</code>. If <code>scc</code> is missing, generate the strongly connected components first.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; foreach(println, edges(condensation(g)))
Edge 2 =&gt; 1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.connected_components" href="#Erdos.connected_components"><code>Erdos.connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connected_components(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected components</a> of an undirected graph <code>g</code> as a vector of components, with each element a vector of vertices belonging to the component.</p><p>For directed graphs, see <a href="#Erdos.strongly_connected_components"><code>strongly_connected_components</code></a> and <a href="#Erdos.weakly_connected_components"><code>weakly_connected_components</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = Graph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]

julia&gt; g = Graph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; connected_components(g)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.connected_components!" href="#Erdos.connected_components!"><code>Erdos.connected_components!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connected_components!(label, g)</code></pre><p>Fill <code>label</code> with the <code>id</code> of the connected component in the undirected graph <code>g</code> to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.</p><p><strong>Performance</strong></p><p>This algorithm is linear in the number of edges of the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.contract!" href="#Erdos.contract!"><code>Erdos.contract!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contract!(g, vs)
contract!(g, v1, v2, ....)</code></pre><p>Merge the vertices in <code>vs</code> into a unique vertex.</p></div></div></section><pre><code class="language-none">Erdos.coo_sparse</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.core_periphery_deg" href="#Erdos.core_periphery_deg"><code>Erdos.core_periphery_deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">core_periphery_deg(g)</code></pre><p>A simple degree-based core-periphery detection algorithm (see <a href="http://arxiv.org/abs/1102.5511">Lip</a>). Returns the vertex assignments (1 for core and 2 for periphery).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.cores" href="#Erdos.cores"><code>Erdos.cores</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cores(g)</code></pre><p>Returns a vector <code>deg</code> such that if <code>deg[v]=k</code> then the vertex <code>v</code> belongs to the <code>k</code>-core of <code>g</code> and not to the <code>k+1</code>-core.</p><p>See also <a href="#Erdos.kcore"><code>kcore</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.count_spanning_trees" href="#Erdos.count_spanning_trees"><code>Erdos.count_spanning_trees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count_spanning_trees(g::AGraph)</code></pre><p>Returns the number of spanning trees of <code>g</code>, computed through <a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem">Kirchhoff&#39;s theorem</a>. The return type is a float, since the number can be very large.</p></div></div></section><pre><code class="language-none">Erdos.countfirst</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.crosspath" href="#Erdos.crosspath"><code>Erdos.crosspath</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">crosspath(g::AGraph, n::Integer)</code></pre><p>Replicate <code>n</code> times <code>g</code> and connect each vertex with its copies in a path.</p></div></div></section><pre><code class="language-none">Erdos.cut_labels</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.degree" href="#Erdos.degree"><code>Erdos.degree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">degree(g, v)</code></pre><p>Return the number of edges  from the vertex <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.degree_centrality" href="#Erdos.degree_centrality"><code>Erdos.degree_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the <a href="https://en.wikipedia.org/wiki/Centrality#Degree_centrality">degree centrality</a> of the graph <code>g</code>, with optional (default) normalization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.density" href="#Erdos.density"><code>Erdos.density</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">density(g)</code></pre><p>Density is defined as the ratio of the number of actual edges to the number of possible edges. This is <span>$|v| |v-1|$</span> for directed graphs and <span>$(|v| |v-1|) / 2$</span> for undirected graphs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dfs_parents" href="#Erdos.dfs_parents"><code>Erdos.dfs_parents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dfs_parents(g, s[; dir=:out])</code></pre><p>Perform a depth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Implementation Notes</strong></p><p>This version of DFS is iterative.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dfs_tree" href="#Erdos.dfs_tree"><code>Erdos.dfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.diameter" href="#Erdos.diameter"><code>Erdos.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diameter(g, distmx=weights(g))</code></pre><p>Returns the maximum distance between any two vertices in <code>g</code>. Distances  between two adjacent nodes are given by <code>distmx</code>.</p><p>See also <a href="#Erdos.eccentricities"><code>eccentricities</code></a>, <a href="#Erdos.radius"><code>radius</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.difference" href="#Erdos.difference"><code>Erdos.difference</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">difference(g, h)</code></pre><p>Produces a graph with all the edges in graph <code>g</code> that are not in graph <code>h</code>.</p><p>Note that this function may produce a graph with 0-degree vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.digraph" href="#Erdos.digraph"><code>Erdos.digraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">digraph{G&lt;:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},
    G = Graph)</code></pre><p>Build a digraph with <code>n</code> vertices, type <code>G</code>, and given <code>edgelist</code>.</p></div></div><div><div><pre><code class="language-none">digraph(s::Symbol, G = DiGraph)</code></pre><p>Creates a notorious digraph <code>s</code> of type <code>G</code>. Admissible values for <code>s</code> are:</p><table><tr><th><code>s</code></th><th>graph type</th></tr><tr><td>:truncatedtetrahedron</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron digraph</a>.</td></tr></table></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.digraphtype" href="#Erdos.digraphtype"><code>Erdos.digraphtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">digraphtype{G&lt;:AGraphOrDiGraph}(::Type{G})</code></pre><p>The digraph type corresponding to <code>G</code>. If <code>G&lt;:ADiGraph</code> returns <code>G</code>, if <code>G&lt;:AGraph</code> returns a type <code>H&lt;:ADiGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dijkstra_shortest_paths" href="#Erdos.dijkstra_shortest_paths"><code>Erdos.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dijkstra_shortest_paths(g, s, distmx=weights(g); allpaths=false)
dijkstra_shortest_paths(g, sources, distmx=weights(g); allpaths=false)</code></pre><p>Performs <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between a source vertex <code>s</code> (or a vector <code>sources</code>)  and all other veritces. Returns a <code>DijkstraState</code> that contains various traversal information.</p><p>With <code>allpaths=true</code>, returns a <code>DijkstraState</code> that keeps track of all predecessors of a given vertex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dinic_impl" href="#Erdos.dinic_impl"><code>Erdos.dinic_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the maximum flow between the source and target vertexes in a flow graph using <a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm">Dinic&#39;s Algorithm</a> Returns the value of the maximum flow as well as the final flow matrix.</p><p>Use a default capacity of 1 when the capacity matrix isn&#39;t specified.</p><p>Requires arguments: residual<em>graph::ADiGraph                # the input graph source::Int                            # the source vertex target::Int                            # the target vertex capacity</em>matrix::AbstractMatrix{T}    # edge flow capacities</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.discharge!" href="#Erdos.discharge!"><code>Erdos.discharge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Drains the excess flow out of a vertex. Runs the gap heuristic or relabels the vertex if the excess remains non-zero.</p><p>Requires arguments:</p><ul><li>g::ADiGraph                 # the input graph</li><li>v                                  # vertex to be discharged</li><li>capacity_matrix::AbstractMatrix{T}</li><li>flow_matrix::AbstractMatrix{T}</li><li>excess::AbstractVector{T}</li><li>height::AbstractVector{Int}</li><li>active::AbstractVector{Bool}</li><li>count::AbstractVector{Int}</li><li>Q::PushRelabelHeap</li></ul></div></div></section><pre><code class="language-none">Erdos.discover_vertex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dismantle_ci" href="#Erdos.dismantle_ci"><code>Erdos.dismantle_ci</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)</code></pre><p>Applies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter <code>l</code> (tipically <code>l=3,4</code>). Removes a maximum of <code>nrem</code> vertices from <code>g</code>, trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.</p><p>Set <code>verbose</code> to <code>true</code> for info printing in each iteration.</p><p>Returns <code>(gnew, vmap, remlist)</code>, where <code>gnew</code> is the reduced graph, <code>vmap</code> is a vertex map of the vertices of <code>gnew</code> to the old ones (see also <a href="#Erdos.rem_vertices!"><code>rem_vertices!</code></a>) and <code>remlist</code> contains the removed vertices by removal order.</p><p>For more fine grained control see <a href="#Erdos.dismantle_ci_init"><code>dismantle_ci_init</code></a> and <a href="#Erdos.dismantle_ci_oneiter!"><code>dismantle_ci_oneiter!</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-julia">g = Graph(100, 1000)
l=3
nrem=10
gnew, vmap, remlist = dismantle_ci(g, l, nrem)

# or equivalently
gnew, heap, lneigs = dismantle_ci_init(g, l)

for it=1:nrem
    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)
    irem &lt;= 0 &amp;&amp; break
    push!(remlist, irem)
    println(&quot;Size Max Component: &quot;, maximum(length, connected_components(g)))
end
vmap = rem_vertices!(gnew, remlist)</code></pre><p>[1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dismantle_ci_init" href="#Erdos.dismantle_ci_init"><code>Erdos.dismantle_ci_init</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dismantle_ci_init(g, l)</code></pre><p>Initialization part of <a href="#Erdos.dismantle_ci"><code>dismantle_ci</code></a> algorithm. Returns <code>(gnew, heap, lneigs)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dismantle_ci_oneiter!" href="#Erdos.dismantle_ci_oneiter!"><code>Erdos.dismantle_ci_oneiter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dismantle_ci_oneiter!(g, heap, lneigs, l)</code></pre><p>One step of <a href="#Erdos.dismantle_ci"><code>dismantle_ci</code></a> algorithm. To be called after <a href="#Erdos.dismantle_ci_init"><code>dismantle_ci_init</code></a> Returns the cleaned vertex if any (see <a href="#Erdos.clean_vertex!"><code>clean_vertex!</code></a>), -1 otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.dst" href="#Erdos.dst"><code>Erdos.dst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dst(e)</code></pre><p>Returns the destination of an edge.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.eccentricities" href="#Erdos.eccentricities"><code>Erdos.eccentricities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eccentricities(g, distmx=weights(g))
eccentricities(g, vs, distmx=weights(g))</code></pre><p>Returns <code>[eccentricity(g,v,distmx) for v in vs]</code>. When <code>vs</code> it is not supplied, considers all node in the graph.</p><p>See also <a href="#Erdos.eccentricity"><code>eccentricity</code></a>.</p><p>Note: the eccentricity vector returned by <code>eccentricity</code> may be eventually used as input in some eccentricity related measures (<a href="#Erdos.periphery"><code>periphery</code></a>, <a href="#Erdos.center"><code>center</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.eccentricity" href="#Erdos.eccentricity"><code>Erdos.eccentricity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eccentricity(g, v, distmx=weights(g))</code></pre><p>Calculates the eccentricity[ies] of a vertex <code>v</code>, An optional matrix of edge distances may be supplied.</p><p>The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edge" href="#Erdos.edge"><code>Erdos.edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edge(g, u, v)</code></pre><p>Returns an edge from &#39;u&#39; to &#39;v&#39;. The edge doesn&#39;t necessarily exists in <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edge_property" href="#Erdos.edge_property"><code>Erdos.edge_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edge_property(g, name)</code></pre><p>Return an edge map corresponding to property <code>name</code> of edges in <code>g</code>.</p><pre><code class="language-none">edge_property(g)</code></pre><p>Returns a dictionary with elements <code>property_name =&gt; edge_map</code>.</p><pre><code class="language-none">edge_property(g, e)</code></pre><p>Returns a dictionary of the form <code>name =&gt; val</code> containing all the properties associated to edge <code>e</code>.</p><p><a href="#Erdos.eprop"><code>eprop</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edgemap2adjlist" href="#Erdos.edgemap2adjlist"><code>Erdos.edgemap2adjlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edgemap2adjlist(emap)</code></pre><p>Returns a vector of vectors containing the values of the edge map <code>emap</code> on graph <code>g</code> following the same ordering of <a href="#Erdos.adjacency_list"><code>adjacency_list</code></a><code>(g)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edges" href="#Erdos.edges"><code>Erdos.edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edges(g, v)</code></pre><p>Returns an iterator to the edges in <code>g</code> coming from vertex <code>v</code>. <code>v == src(e)</code> for each returned edge <code>e</code>.</p><p>It is equivalent to <a href="#Erdos.out_edges"><code>out_edges</code></a>.</p><p>For digraphs, use <a href="#Erdos.all_edges"><code>all_edges</code></a> to iterate over both in and out edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edgetype" href="#Erdos.edgetype"><code>Erdos.edgetype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edgetype(g)
edgetype(G)</code></pre><p>Returns the type of edges of graph <code>g</code> (or graph type <code>G</code>), i. e. the element type returned of the iterator <code>edges(g)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edit_distance" href="#Erdos.edit_distance"><code>Erdos.edit_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">edit_distance(G₁, G₂;
       insert_cost::Function=v-&gt;1.0,
       delete_cost::Function=u-&gt;1.0,
       subst_cost::Function=(u,v)-&gt;0.5,
       heuristic::Function=DefaultEditHeuristic)</code></pre><p>Computes the edit distance between graphs G₁ and G₂.</p><p>Returns the minimum edit cost and edit path to transform graph G₁ into graph G₂. An edit path consists of a sequence of pairs of vertices (u,v) ∈ [0,|G₁|] × [0,|G₂|] representing vertex operations:</p><ul><li>(0,v): insertion of vertex v ∈ G₂</li><li>(u,0): deletion of vertex u ∈ G₁</li><li>(u&gt;0,v&gt;0): substitution of vertex u ∈ G₁ by vertex v ∈ G₂</li></ul><p>By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:</p><pre><code class="language-none">edit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))</code></pre><p>A custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: ––––––––-</p><ul><li>Given two graphs <span>$|G₁| &lt; |G₂|$</span>, <code>edit_distance(G₁, G₂)</code> is faster to</li></ul><p>compute than <code>edit_distance(G₂, G₁)</code>. Consider swapping the arguments if involved costs are <code>symmetric</code>.</p><ul><li>The use of simple Minkowski costs can improve performance considerably.</li><li>Exploit vertex attributes when designing operation costs.</li></ul><p>For further details, please refer to:</p><p>RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)</p><p>Author: Júlio Hoffimann Mendes (juliohm@stanford.edu)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.edmonds_karp_impl" href="#Erdos.edmonds_karp_impl"><code>Erdos.edmonds_karp_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the maximum flow between the source and target vertexes in a flow graph using the <a href="https://en.wikipedia.org/wiki/Edmondss%E2%80%93Karp_algorithm">Edmonds-Karp algorithm</a>. Returns the value of the maximum flow as well as the final flow matrix. Use a default capacity of 1 when the capacity matrix isn&#39;t specified. Requires arguments:</p><ul><li>residual_graph::ADiGraph                # the input graph</li><li>source                            # the source vertex</li><li>target                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}    # edge flow capacities</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.egonet" href="#Erdos.egonet"><code>Erdos.egonet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">egonet(g, v::Int, d::Int; dir=:out)</code></pre><p>Returns the subgraph of <code>g</code> induced by the neighbors of <code>v</code> up to distance <code>d</code>. If <code>g</code> is a <code>DiGraph</code> the <code>dir</code> optional argument specifies the edge direction the edge direction with respect to <code>v</code> (i.e. <code>:in</code> or <code>:out</code>) to be considered. This is equivalent to <a href="#Erdos.subgraph"><code>subgraph</code></a><code>(g, neighborhood(g, v, d, dir=dir))[1].</code></p></div></div></section><pre><code class="language-none">Erdos.empty_flow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.emrf" href="#Erdos.emrf"><code>Erdos.emrf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the maximum multiroute flow (for any real number of routes) between the source and target vertexes in a flow graph using the <a href="http://dx.doi.org/10.1016/j.disopt.2016.05.002">Extended Multiroute Flow algorithm</a>. If a number of routes is given, returns the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if Boykov-Kolmogorov max-flow algorithm is used as a subroutine. Otherwise, it returns the vector of breaking points of the parametric multiroute flow function. Use a default capacity of 1 when the capacity matrix isn&#39;t specified. Requires arguments:</p><ul><li>flow_graph::ADiGraph                    # the input graph</li><li>source::Int                            # the source vertex</li><li>target::Int                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}   # edge flow capacities</li><li>flow_algorithm::AbstractFlowAlgorithm  # keyword argument for algorithm</li><li>routes::Int                            # keyword argument for routes</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.enqueue_vertex!" href="#Erdos.enqueue_vertex!"><code>Erdos.enqueue_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pushes inactive nodes into the queue and activates them.</p><p>Requires arguments:</p><ul><li>Q::PushRelabelHeap</li><li>v</li><li>active::AbstractVector{Bool}</li><li>excess::AbstractVector{T}</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.enumerate_paths" href="#Erdos.enumerate_paths"><code>Erdos.enumerate_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enumerate_paths(state::AbstractPathState)
enumerate_paths(state::AbstractPathState, dest)</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code> (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex <code>v</code>, a set of destination vertices <code>vs</code>, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.eprop" href="#Erdos.eprop"><code>Erdos.eprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.edge_property"><code>edge_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.eprop!" href="#Erdos.eprop!"><code>Erdos.eprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.add_edge_property!"><code>add_edge_property!</code></a></p></div></div></section><pre><code class="language-none">Erdos.eprop_names</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.erdos_renyi" href="#Erdos.erdos_renyi"><code>Erdos.erdos_renyi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">erdos_renyi(n::Int, p::Real, G=Graph; seed=-1)
erdos_renyi(n::Int, m::Int, G=Graph; seed=-1)</code></pre><p>Creates an <a href="http://en.wikipedia.org/wiki/Erdős–Rényi_model">Erdős–Rényi</a> random graph of type <code>G</code> with <code>n</code> vertices. Edges are added between pairs of vertices with probability <code>p</code> in the first method. In the second method <code>m</code> edges are randomly chosen insted.</p><p>Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. <code>DiGraph</code>)</p><p>Note also that Erdős–Rényi graphs may be generated quickly using <code>erdos_renyi(n, ne)</code> or the  <code>Graph(nv, ne)</code> constructor, which randomly select <code>ne</code> edges among all the potential edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.euclidean_graph" href="#Erdos.euclidean_graph"><code>Erdos.euclidean_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">euclidean_graph(points::Matrix, G; L=1., p=2., cutoff=Inf, bc=:periodic)</code></pre><p>Given the <code>d×N</code> matrix <code>points</code> builds an Euclidean graph of <code>N</code> vertices according to the following procedure.</p><p>Defining the <code>d</code>-dimensional vectors <code>x[i] = points[:,i]</code>, an edge between vertices <code>i</code> and <code>j</code> is inserted if <code>norm(x[i]-x[j], p) &lt; cutoff</code>. In case of negative <code>cutoff</code> instead every edge is inserted. For <code>p=2</code> we have the standard Euclidean distance. Set <code>bc=:periodic</code> to impose periodic boundary conditions in the box <span>$[0,L]^d$</span>. Set <code>bc=:open</code> for open boundary condition. In this case the keyword argument <code>L</code> will be ignored.</p><p>Returns a graph and Dict containing the distance on each edge.</p></div></div></section><pre><code class="language-none">Erdos.eval</code></pre><pre><code class="language-none">Erdos.examine_neighbor!</code></pre><pre><code class="language-none">Erdos.fadj</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.fetch_path" href="#Erdos.fetch_path"><code>Erdos.fetch_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Uses Bidirectional BFS to look for augmentable-paths. Returns the vertex where the two BFS searches intersect, the Parent table of the path, the Successor table of the path found, and a flag indicating success Flag Values: 0 =&gt; success 1 =&gt; No Path to target 2 =&gt; No Path to source</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.fetch_path!" href="#Erdos.fetch_path!"><code>Erdos.fetch_path!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A preallocated version of fetch<em>paths. The parent and successor tables are pre-allocated. Uses Bidirectional BFS to look for augmentable-paths. Returns the vertex where the two BFS searches intersect, the Parent table of the path, the Successor table of the path found, and a flag indicating success Flag Values: 0 =&gt; success 1 =&gt; No Path to target 2 =&gt; No Path to source Requires arguments:     residual</em>graph::ADiGraph                # the input graph     source                            # the source vertex     target                            # the target vertex     flow<em>matrix::AbstractMatrix{T}        # the current flow matrix     capacity</em>matrix::AbstractMatrix{T}    # edge flow capacities     P::Vector{Int}                         # parent table of path init to -1s     S::Vector{Int}                         # successor table of path init to -1s</p></div></div></section><pre><code class="language-none">Erdos.filemap</code></pre><pre><code class="language-none">Erdos.fill_mat_from_map!</code></pre><pre><code class="language-none">Erdos.find_path!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.floyd_warshall_shortest_paths" href="#Erdos.floyd_warshall_shortest_paths"><code>Erdos.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">floyd_warshall_shortest_paths(g, distmx=weights(g))</code></pre><p>Uses the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute shortest paths between all pairs of vertices in graph <code>g</code>. Returns a <code>FloydWarshallState</code> with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.</p><p>Note that this algorithm may return a large amount of data (it will allocate on the order of <span>$O(nv^2)$</span>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.gap!" href="#Erdos.gap!"><code>Erdos.gap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the gap heuristic. Relabels all vertices above a cutoff height. Reduces the number of relabels required.</p><p>Requires arguments:</p><ul><li>g::ADiGraph                # the input graph</li><li>h                                 # cutoff height</li><li>excess::AbstractVector{T}</li><li>height::AbstractVector{Int}</li><li>active::AbstractVector{Bool}</li><li>count::AbstractVector{Int}</li><li>Q::PushRelabelHeap</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.gdistances" href="#Erdos.gdistances"><code>Erdos.gdistances</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.gdistances!" href="#Erdos.gdistances!"><code>Erdos.gdistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div></section><pre><code class="language-none">Erdos.getRNG</code></pre><pre><code class="language-none">Erdos.getchild</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.getchild!" href="#Erdos.getchild!"><code>Erdos.getchild!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>adds a child <code>s</code> to <code>el</code> if it doesn&#39;t exist</p></div></div></section><pre><code class="language-none">Erdos.gexf_read_one_graph!</code></pre><pre><code class="language-none">Erdos.gexf_read_one_net!</code></pre><pre><code class="language-none">Erdos.gexf_types</code></pre><pre><code class="language-none">Erdos.gexf_types_rev</code></pre><pre><code class="language-none">Erdos.gexfparse</code></pre><pre><code class="language-none">Erdos.gexfstring</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.global_clustering_coefficient" href="#Erdos.global_clustering_coefficient"><code>Erdos.global_clustering_coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">global_clustering_coefficient(g)</code></pre><p>Computes the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">global clustering coefficient</a>.</p></div></div></section><pre><code class="language-none">Erdos.gmlprintval</code></pre><pre><code class="language-none">Erdos.gmltypeof</code></pre><pre><code class="language-none">Erdos.gmlval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.gprop" href="#Erdos.gprop"><code>Erdos.gprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.graph_property"><code>graph_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.gprop!" href="#Erdos.gprop!"><code>Erdos.gprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.set_graph_property!"><code>set_graph_property!</code></a></p></div></div></section><pre><code class="language-none">Erdos.gprop_names</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.graph" href="#Erdos.graph"><code>Erdos.graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph{G&lt;:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},
    G = Graph)</code></pre><p>Build a graph with <code>n</code> vertices, of type <code>G</code>, and given <code>edgelist</code>.</p></div></div><div><div><pre><code class="language-none">graph(s::Symbol, G = Graph)</code></pre><p>Creates a notorious graph <code>s</code> of type <code>G</code>. Admissible values for <code>s</code> are:</p><table><tr><th><code>s</code></th><th>graph type</th></tr><tr><td>:bull</td><td>A <a href="https://en.wikipedia.org/wiki/Bull_graph">bull graph</a>.</td></tr><tr><td>:chvatal</td><td>A <a href="https://en.wikipedia.org/wiki/Chvátal_graph">Chvátal graph</a>.</td></tr><tr><td>:cubical</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic cubical graph</a>.</td></tr><tr><td>:desargues</td><td>A <a href="https://en.wikipedia.org/wiki/Desargues_graph">Desarguesgraph</a>.</td></tr><tr><td>:diamond</td><td>A <a href="http://en.wikipedia.org/wiki/Diamond_graph">diamond graph</a>.</td></tr><tr><td>:dodecahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic dodecahedral  graph</a>.</td></tr><tr><td>:frucht</td><td>A <a href="https://en.wikipedia.org/wiki/Frucht_graph">Frucht graph</a>.</td></tr><tr><td>:heawood</td><td>A <a href="https://en.wikipedia.org/wiki/Heawood_graph">Heawood graph</a>.</td></tr><tr><td>:house</td><td>A graph mimicing the classic outline of a house.</td></tr><tr><td>:housex</td><td>A house graph, with two edges crossing the bottom square.</td></tr><tr><td>:icosahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic icosahedral   graph</a>.</td></tr><tr><td>:krackhardtkite</td><td>A <a href="http://mathworld.wolfram.com/KrackhardtKite.html">Krackhardt-Kite social network  graph</a>.</td></tr><tr><td>:moebiuskantor</td><td>A <a href="http://en.wikipedia.org/wiki/Möbius–Kantor_graph">Möbius-Kantor graph</a>.</td></tr><tr><td>:octahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic octahedral graph</a>.</td></tr><tr><td>:pappus</td><td>A <a href="http://en.wikipedia.org/wiki/Pappus_graph">Pappus graph</a>.</td></tr><tr><td>:petersen</td><td>A <a href="http://en.wikipedia.org/wiki/Petersen_graph">Petersen graph</a>.</td></tr><tr><td>:sedgewickmaze</td><td>A simple maze graph used in Sedgewick&#39;s <em>Algorithms in C++: Graph  Algorithms (3rd ed.)</em></td></tr><tr><td>:tetrahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic tetrahedral  graph</a>.</td></tr><tr><td>:truncatedcube</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_cube">truncated cube graph</a>.</td></tr><tr><td>:truncatedtetrahedron</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron  graph</a>.</td></tr><tr><td>:tutte</td><td>A <a href="https://en.wikipedia.org/wiki/Tutte_graph">Tutte graph</a>.</td></tr></table><p>A collection of real world graphs is available through the <a href="#Erdos.readgraph"><code>readgraph</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.graph_property" href="#Erdos.graph_property"><code>Erdos.graph_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graph_property(g, name)</code></pre><p>Return the property <code>name</code> of <code>g</code>.</p><pre><code class="language-none">graph_property(g)</code></pre><p>Returns a dictionary with elements <code>property_name =&gt; property_value</code></p><p><a href="#Erdos.gprop"><code>gprop</code></a> is the short form of this function.</p></div></div></section><pre><code class="language-none">Erdos.graphml_read_one_graph!</code></pre><pre><code class="language-none">Erdos.graphml_read_one_net!</code></pre><pre><code class="language-none">Erdos.graphml_types</code></pre><pre><code class="language-none">Erdos.graphml_types_rev</code></pre><pre><code class="language-none">Erdos.graphmlparse</code></pre><pre><code class="language-none">Erdos.graphmlstring</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.graphtype" href="#Erdos.graphtype"><code>Erdos.graphtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">graphtype{G&lt;:AGraphOrDiGraph}(::Type{G})</code></pre><p>The graph type corresponding to <code>G</code>. If <code>G&lt;:AGraph</code> returns <code>G</code>, if <code>G&lt;:ADiGraph</code> returns a type <code>H&lt;:AGraph</code>.</p></div></div></section><pre><code class="language-none">Erdos.gtpropmap</code></pre><pre><code class="language-none">Erdos.has_cycles</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_cycycles" href="#Erdos.has_cycycles"><code>Erdos.has_cycycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_cycles(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_edge" href="#Erdos.has_edge"><code>Erdos.has_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_edge(g, e)
has_edge(g, u, v)</code></pre><p>Returns true if the graph <code>g</code> has an edge <code>e</code> (from <code>u</code> to <code>v</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_edge_property" href="#Erdos.has_edge_property"><code>Erdos.has_edge_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_edge_property(g, name)
has_edge_property(g, name, e)</code></pre><p>Check if network  <code>g</code> has an edge property named <code>name</code>. The second method checks also if edge <code>e</code> has an assigned value for that property.</p><p><a href="#Erdos.has_eprop"><code>has_eprop</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_eprop" href="#Erdos.has_eprop"><code>Erdos.has_eprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.has_edge_property"><code>has_edge_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_gprop" href="#Erdos.has_gprop"><code>Erdos.has_gprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.has_graph_property"><code>has_graph_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_graph_property" href="#Erdos.has_graph_property"><code>Erdos.has_graph_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_graph_property(g, name)</code></pre><p>Check if network  <code>g</code> has a graph property named <code>name</code>.</p><p><a href="#Erdos.has_gprop"><code>has_gprop</code></a> is the short form of this function.</p></div></div></section><pre><code class="language-none">Erdos.has_negative_edge_cycle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_path" href="#Erdos.has_path"><code>Erdos.has_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_self_loops" href="#Erdos.has_self_loops"><code>Erdos.has_self_loops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_self_loops(g)</code></pre><p>Returns true if <code>g</code> has any self loops.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_vertex" href="#Erdos.has_vertex"><code>Erdos.has_vertex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_vertex(g, v)</code></pre><p>Return true if <code>v</code> is a vertex of <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_vertex_property" href="#Erdos.has_vertex_property"><code>Erdos.has_vertex_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_vertex_property(g, name, v)</code></pre><p>Check if network  <code>g</code> has a vertex property named <code>name</code>. The second method checks also if vertex <code>v</code> has an assigned value for that property.</p><p><a href="#Erdos.has_vprop"><code>has_vprop</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.has_vprop" href="#Erdos.has_vprop"><code>Erdos.has_vprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.has_vertex_property"><code>has_vertex_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.idx" href="#Erdos.idx"><code>Erdos.idx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">idx(e::AIndexedEdge)</code></pre><p>Returns the index of edge <code>e</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.in_adjlist" href="#Erdos.in_adjlist"><code>Erdos.in_adjlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">in_adjlist(g)</code></pre><p>Returns the backward adjacency list of a graph. For each vertex the vector of neighbors though incoming edges.</p><pre><code class="language-none">in_adjlist(g) == [collect(in_neighbors(i)) for i=1:nv(g)]</code></pre><p>It is the same as <a href="@ref"><code>adjlist</code></a> and <a href="#Erdos.out_adjlist"><code>out_adjlist</code></a> for undirected graphs.</p><p>NOTE: returns a reference, not a copy. Do not modify result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.in_degree" href="#Erdos.in_degree"><code>Erdos.in_degree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">in_degree(g, v)</code></pre><p>Returns the number of edges which start at vertex <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.in_degree_centrality" href="#Erdos.in_degree_centrality"><code>Erdos.in_degree_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the <a href="https://en.wikipedia.org/wiki/Centrality#Degree_centrality">degree centrality</a> of the graph <code>g</code>, with optional (default) normalization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.in_edges" href="#Erdos.in_edges"><code>Erdos.in_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">in_edges(g, v)</code></pre><p>Returns an iterator to the edges in <code>g</code> going to vertex <code>v</code>. <code>v == dst(e)</code> for each returned edge <code>e</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.in_neighbors" href="#Erdos.in_neighbors"><code>Erdos.in_neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">in_neighbors(g, v)</code></pre><p>Returns an iterable to all neighbors connected to vertex <code>v</code> by an incoming edge.</p><p>NOTE: it may return a reference, not a copy. Do not modify result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.incidence_matrix" href="#Erdos.incidence_matrix"><code>Erdos.incidence_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidence_matrix(g::AGraphOrDiGraph, T::DataType=Int; oriented=false)</code></pre><p>Returns a sparse node-arc incidence matrix for a graph, indexed by <code>[v, i]</code>, where <code>i</code> is in <code>1:ne(g)</code>, indexing an edge <code>e</code>. For directed graphs, a value of <code>-1</code> indicates that <code>src(e) == v</code>, while a value of <code>1</code> indicates that <code>dst(e) == v</code>. Otherwise, the value is <code>0</code>.</p><p>For undirected graphs, both entries are <code>1</code> if <code>oriented=false</code>, otherwise <code>[v, i] -&gt; -1</code> and <code>[u, i] -&gt; 1</code> if <code>v &lt; u</code>.</p></div></div></section><pre><code class="language-none">Erdos.include</code></pre><pre><code class="language-none">Erdos.indegree</code></pre><pre><code class="language-none">Erdos.induced_subgraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersect(g, h)</code></pre><p>Produces a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p><p>Note that this function may produce a graph with 0-degree vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.intersection" href="#Erdos.intersection"><code>Erdos.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the intersection between:</p><ol><li>Two lines</li><li>A set of segments and a linear function of slope k passing by the origin.</li></ol><p>Requires argument:</p><ol><li><ul><li>x1, y1, a1, x2, y2, a2::T&lt;:AbstractFloat # Coordinates/slopes</li></ul></li><li><ul><li>points::Vector{Tuple{T, T, Int}}         # vector of points with T&lt;:AbstractFloat</li><li>k::R&lt;:Real                             # number of routes (slope of the line)</li></ul></li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_bipartite" href="#Erdos.is_bipartite"><code>Erdos.is_bipartite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; is_bipartite(g)
true

julia&gt; add_edge!(g, 1, 3);

julia&gt; is_bipartite(g)
false</code></pre></div></div></section><pre><code class="language-none">Erdos.is_complete_path</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_connected" href="#Erdos.is_connected"><code>Erdos.is_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_connected(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is connected. For directed graphs, return <code>true</code> if graph <code>g</code> is weakly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = Graph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; is_connected(g)
true

julia&gt; g = Graph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; is_connected(g)
false

julia&gt; g = DiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_connected(g)
true</code></pre></div></div></section><pre><code class="language-none">Erdos.is_cyclic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_directed" href="#Erdos.is_directed"><code>Erdos.is_directed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_directed(g)</code></pre><p>Check if <code>g</code> a graph with directed edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_graphical" href="#Erdos.is_graphical"><code>Erdos.is_graphical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_graphical(degs::Vector{Int})</code></pre><p>Check whether the degree sequence <code>degs</code> is graphical, according to <a href="http://mathworld.wolfram.com/GraphicSequence.html">Erdös-Gallai condition</a>.</p><p>Time complexity: O(length(degs)^2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_strongly_connected" href="#Erdos.is_strongly_connected"><code>Erdos.is_strongly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_strongly_connected(g)</code></pre><p>Return <code>true</code> if directed graph <code>g</code> is strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_strongly_connected(g)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.is_weakly_connected" href="#Erdos.is_weakly_connected"><code>Erdos.is_weakly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_weakly_connected(g)</code></pre><p>Return <code>true</code> if the graph <code>g</code> is weakly connected. If <code>g</code> is undirected, this function is equivalent to <a href="#Erdos.is_connected"><code>is_connected(g)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_weakly_connected(g)
true

julia&gt; g = DiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; is_connected(g)
true

julia&gt; is_strongly_connected(g)
false

julia&gt; is_weakly_connected(g)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.isgraphical" href="#Erdos.isgraphical"><code>Erdos.isgraphical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isgraphical(degs)</code></pre><p>Return true if the degree sequence <code>degs</code> is graphical, according to <a href="http://mathworld.wolfram.com/GraphicSequence.html">Erdös-Gallai condition</a>.</p><p><strong>Performance</strong></p><pre><code class="language-none">Time complexity: ``\mathcal{O}(|degs|^2)``</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(g, h)</code></pre><p>Merges graphs <code>g</code> and <code>h</code> using <code>blockdiag</code> and then adds all the edges between  the vertices in <code>g</code> and those in <code>h</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.katz_centrality" href="#Erdos.katz_centrality"><code>Erdos.katz_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the <a href="https://en.wikipedia.org/wiki/Katz_centrality">Katz centrality</a> of the graph <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.kcore" href="#Erdos.kcore"><code>Erdos.kcore</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kcore(g, k) -&gt; (gnew, vmap)</code></pre><p>Returns the <code>k</code>-core  of <code>g</code> along with a vertex map associating the mutated vertex indexes to the old ones (as in <a href="#Erdos.rem_vertices!"><code>rem_vertices!</code></a>).</p><p>See also <a href="#Erdos.cores"><code>cores</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.kishimoto" href="#Erdos.kishimoto"><code>Erdos.kishimoto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the maximum multiroute flow (for an integer number of routes) between the source and target vertexes in a flow graph using the <a href="http://dx.doi.org/10.1109/ICCS.1992.255031">Kishimoto algorithm</a>. Returns the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if Boykov-Kolmogorov is used as a subroutine. Use a default capacity of 1 when the capacity matrix isn&#39;t specified. Requires arguments:</p><ul><li>flow_graph::ADiGraph                    # the input graph</li><li>source::Int                            # the source vertex</li><li>target::Int                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}   # edge flow capacities</li><li>flow_algorithm::AbstractFlowAlgorithm, # keyword argument for algorithm</li><li>routes::Int                            # keyword argument for routes</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.label_propagation" href="#Erdos.label_propagation"><code>Erdos.label_propagation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">label_propagation(g; maxiter=1000)</code></pre><p>Community detection using the label propagation algorithm (see <a href="http://arxiv.org/abs/0709.2938">Raghavan et al.</a>). <code>g</code> is the input Graph, <code>maxiter</code> is the  maximum number of iterations. Returns a vertex assignments and the convergence history</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.laplacian_matrix" href="#Erdos.laplacian_matrix"><code>Erdos.laplacian_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">laplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)</code></pre><p>Returns a sparse <a href="https://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian matrix</a> for a graph <code>g</code>, indexed by <code>[u, v]</code> vertices. <code>dir</code> has to be <code>:in, :out</code> or <code>:all</code>.</p></div></div></section><pre><code class="language-none">Erdos.laplacian_spectrum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.local_clustering" href="#Erdos.local_clustering"><code>Erdos.local_clustering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">local_clustering(g, v)</code></pre><p>Returns a tuple <code>(a,b)</code>, where <code>a</code> is the number of triangles in the neighborhood of <code>v</code> and <code>b</code> is the maximum number of possible triangles. It is related to the local clustering coefficient  by <code>r=a/b</code>.</p></div></div><div><div><pre><code class="language-none">local_clustering(g, vlist = vertices(g))</code></pre><p>Returns two vectors, respectively containing  the first and second result of <code>local_clustering_coefficients(g, v)</code> for each <code>v</code> in <code>vlist</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.local_clustering_coefficient" href="#Erdos.local_clustering_coefficient"><code>Erdos.local_clustering_coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">local_clustering_coefficient(g, v)</code></pre><p>Computes the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">local clustering coefficient</a> for node <code>v</code>.</p></div></div><div><div><pre><code class="language-none">local_clustering_coefficient(g, vlist = vertices(g))</code></pre><p>Returns a vector containing  the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">local clustering coefficients</a> for vertices <code>vlist</code>.</p></div></div></section><pre><code class="language-none">Erdos.longshow</code></pre><pre><code class="language-none">Erdos.make_edgestream</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.maximal_cliques" href="#Erdos.maximal_cliques"><code>Erdos.maximal_cliques</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Finds all maximal cliques of an undirected graph.</p><pre><code class="language-none">julia&gt; using Erdos
julia&gt; g = Graph(3)
julia&gt; add_edge!(g, 1, 2)
julia&gt; add_edge!(g, 2, 3)
julia&gt; maximal_cliques(g)
2-element Array{Array{Int64,N},1}:
 [2,3]
 [2,1]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.maximum_adjacency_visit" href="#Erdos.maximum_adjacency_visit"><code>Erdos.maximum_adjacency_visit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maximum_adjacency_visit(g[, distmx][, log][, io])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.maximum_flow" href="#Erdos.maximum_flow"><code>Erdos.maximum_flow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maximum_flow{T&lt;:Number}(
                    g::ADiGraph,
                    source::Int,
                    target::Int,
                    capacity_matrix::AbstractMatrix{T} =
                        DefaultCapacity(g);
                    algorithm::AbstractFlowAlgorithm  =
                        PushRelabelAlgorithm(),
                    restriction::T = zero(T)
                )</code></pre><p>Generic maximum<em>flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity</em>matrix.</p><p>All algorithms return a tuple with</p><ol><li>the maximum flow</li><li>the flow matrix</li><li>the labelling associated to the minimum cut</li></ol><p>Available algorithms are <code>DinicAlgorithm</code>, <code>EdmondsKarpAlgorithm</code>, <code>BoykovKolmogorovAlgorithm</code> and <code>PushRelabelAlgorithm</code>.</p><p>Time complexity is O(V²√E) for the push relabel algorithm.</p><p><strong>Usage Example:</strong></p><pre><code class="language-julia">
# Create a flow-graph and a capacity matrix
g = DiGraph(8)
flow_edges = [
    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),
    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),
    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)
]
capacity_matrix = zeros(Int, 8, 8)
for e in flow_edges
    u, v, f = e
    add_edge!(g, u, v)
    capacity_matrix[u,v] = f
end

# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).
f, F, labels = maximum_flow(g, 1, 8)

# Run Endmonds-Karp algorithm
f, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.minimum_cut" href="#Erdos.minimum_cut"><code>Erdos.minimum_cut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">minimum_cut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div></div><div><div><pre><code class="language-none">minimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)</code></pre><p>Finds the <code>s-t cut</code> of minimal weight according to the <code>capacities</code> matrix on the directed graph <code>g</code>. The solution is found through a maximal flow algorithm. See <a href="#Erdos.maximum_flow"><code>maximum_flow</code></a> for the optional arguments.</p><p>Returns a triple <code>(f, cut, labels)</code>, where <code>f</code> is the weight of the cut, <code>cut</code> is a vector of the edges in the cut, and <code>labels</code> gives a partitioning of the vertices in two sets, according to the cut.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.minimum_spanning_tree" href="#Erdos.minimum_spanning_tree"><code>Erdos.minimum_spanning_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">minimum_spanning_tree{T&lt;:Real}(
    g, distmx::AbstractMatrix{T} = weights(g)
)</code></pre><p>Performs <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal&#39;s algorithm</a> on a connected, undirected graph <code>g</code>, having adjacency matrix <code>distmx</code>, and computes minimum spanning tree. Returns a <code>Vector{KruskalHeapEntry}</code>, that contains the containing edges and its weights.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.minmaxCapacity" href="#Erdos.minmaxCapacity"><code>Erdos.minmaxCapacity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Function to get the nonzero min and max function of a Matrix.</p><p>Note: this is more efficient than maximum() / minimum() / extrema() since we have to ignore zero values.since we have to ignore zero values.</p><p>Requires argument:</p><ul><li>capacity_matrix::AbstractMatrix{T}   # edge flow capacities</li></ul></div></div></section><pre><code class="language-none">Erdos.minutype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.modularity" href="#Erdos.modularity"><code>Erdos.modularity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modularity(g, c)</code></pre><p>Computes Newman&#39;s modularity <code>Q</code> for graph <code>g</code> given the partitioning <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.multiroute_flow" href="#Erdos.multiroute_flow"><code>Erdos.multiroute_flow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The generic multiroute_flow function will output three kinds of results:</p><ul><li>When the number of routes is 0 or non-specified, the set of breaking points of</li></ul><p>the multiroute flow is returned.</p><ul><li>When the input is limited to a set of breaking points and a route value k,</li></ul><p>only the value of the k-route flow is returned</p><ul><li>Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the</li></ul><p>max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.</p><p>When the input is a network, it requires the following arguments:</p><ul><li>flow_graph::ADiGraph                   # the input graph</li><li>source::Int                           # the source vertex</li><li>target::Int                           # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}  # edge flow capacities with T&lt;:Real</li><li>flow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm</li><li>mrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm</li><li>routes::R&lt;:Real                       # keyword argument for the number of routes</li></ul><p>When the input is only the set of (breaking) points and the number of route, it requires the following arguments:</p><ul><li>breakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points</li><li>routes::R&lt;:Real,                             # number of routes</li></ul><p>When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:</p><ul><li>breakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1&lt;:Real)</li><li>routes::R&lt;:Real                            # number of routes</li><li>flow_graph::ADiGraph                        # the input graph</li><li>source::Int                                # the source vertex</li><li>target::Int                                # the target vertex</li><li>capacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2&lt;:Real)</li><li>flow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm</li></ul><p>The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.</p><p>The mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:</p><ul><li>The number of routes is non-integer</li><li>The number of routes is 0 or non-specified</li></ul><p><strong>Usage Example :</strong></p><p>(please consult the  max<em>flow section for options about flow</em>algorithm and capacity_matrix)</p><pre><code class="language-julia">
# Create a flow-graph and a capacity matrix
flow_graph = DiGraph(8)
flow_edges = [
    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),
    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),
    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)
]
capacity_matrix = zeros(Int, 8, 8)
for e in flow_edges
    u, v, f = e
    add_edge!(flow_graph, u, v)
    capacity_matrix[u, v] = f
end

# Run default multiroute_flow with an integer number of routes = 2
f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)

# Run default multiroute_flow with a noninteger number of routes = 1.5
f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)

# Run default multiroute_flow for all the breaking points values
points = multiroute_flow(flow_graph, 1, 8, capacity_matrix)
# Then run multiroute flow algorithm for any positive number of routes
f, F = multiroute_flow(points, 1.5)
f = multiroute_flow(points, 1.5, valueonly = true)

# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine
f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,
               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)
</code></pre></div></div></section><pre><code class="language-none">Erdos.myrand</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.ne" href="#Erdos.ne"><code>Erdos.ne</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ne(g)</code></pre><p>The number of edges in <code>g</code>.</p><p>Time Complexity: O(1)</p></div></div></section><pre><code class="language-none">Erdos.nearbipartiteSBM</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.neighborhood" href="#Erdos.neighborhood"><code>Erdos.neighborhood</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood(g, v, d, distmx=weights(g); dir=:out)</code></pre><p>Return a vector of each vertex in <code>g</code> at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>. </p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood(g, 1, 2)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; neighborhood(g, 1, 3)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Int64,1}:
 1
 2
 3
 4
 5</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.neighborhood_dists" href="#Erdos.neighborhood_dists"><code>Erdos.neighborhood_dists</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood_dists(g, v, d, distmx=weights(g))</code></pre><p>Return a tuple of each vertex at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>, along with its distance from <code>v</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood_dists(g, 1, 3)
4-element Array{Tuple{Int64,Int64},1}:
 (1, 0)
 (2, 1)
 (3, 2)
 (4, 3)

julia&gt; neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Tuple{Int64,Float64},1}:
 (1, 0.0)
 (2, 1.0)
 (3, 2.0)
 (4, 2.25)
 (5, 2.5)

julia&gt; neighborhood_dists(g, 4, 3)
2-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (5, 1)

julia&gt; neighborhood_dists(g, 4, 3, dir=:in)
5-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (3, 1)
 (5, 1)
 (2, 2)
 (1, 3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.neighbors" href="#Erdos.neighbors"><code>Erdos.neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighbors(g, v)</code></pre><p>Returns a list of all neighbors from vertex <code>v</code> in <code>g</code>.</p><p>For directed graph, this is equivalent to <a href="#Erdos.out_neighbors"><code>out_neighbors</code></a>(g, v).</p><p>NOTE: it may return a reference, not a copy. Do not modify result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.nonbacktrack_embedding" href="#Erdos.nonbacktrack_embedding"><code>Erdos.nonbacktrack_embedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nonbacktrack_embedding(g::AGraph, k::Int)</code></pre><p>Spectral embedding of the non-backtracking matrix of <code>g</code> (see <a href="http://www.pnas.org/content/110/52/20935.short">Krzakala et al.</a>).</p><pre><code class="language-none">`g`: imput Graph
`k`: number of dimensions in which to embed</code></pre><p>Returns  a matrix <code>ϕ</code> where <code>ϕ[:,i]</code> are the coordinates for vertex <code>i</code>.</p><p>Note:  does not explicitly construct the <a href="#Erdos.nonbacktracking_matrix"><code>nonbacktracking_matrix</code></a>. See <a href="#Erdos.nonbacktracking_matrix"><code>nonbacktracking_matrix</code></a> for details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.nonbacktracking_matrix" href="#Erdos.nonbacktracking_matrix"><code>Erdos.nonbacktracking_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nonbacktracking_matrix(g)</code></pre><p>Return a non-backtracking matrix <code>B</code> and an edgemap storing the oriented edges&#39; positions in <code>B</code>. Given two arcs <span>$A_{i j}` and `A_{k l}` in `g`, the non-backtraking matrix$</span>B<span>$is defined as$</span>B<em>{A</em>{i j}, A<em>{k l}} = δ</em>{j k} * (1 - δ_{i l})``</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.nonbacktracking_randomwalk" href="#Erdos.nonbacktracking_randomwalk"><code>Erdos.nonbacktracking_randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nonbacktracking_randomwalk(g, s, niter)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.num_self_loops" href="#Erdos.num_self_loops"><code>Erdos.num_self_loops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num_self_loops(g)</code></pre><p>Returns the number of self loops in <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.nv" href="#Erdos.nv"><code>Erdos.nv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nv(g)</code></pre><p>The number of vertices in <code>g</code>.</p></div></div></section><pre><code class="language-none">Erdos.open_vertex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.out_adjlist" href="#Erdos.out_adjlist"><code>Erdos.out_adjlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">out_adjlist(g)</code></pre><p>Returns the forward adjacency list of a graph, i.e. a vector of vectors containing for each vertex the neighbors trhough outgoing edges.</p><pre><code class="language-none">out_adjlist(g) == [collect(out_neighbors(i)) for i=1:nv(g)]</code></pre><p>The adjacency list is be pre-calculated for most graph types. It is the same as <a href="@ref"><code>adjlist</code></a> and <a href="#Erdos.in_adjlist"><code>in_adjlist</code></a> for undirected graphs and the same as <a href="@ref"><code>adjlist</code></a> for directed ones.</p><p>NOTE: It may return a reference, not a copy. Do not modify result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.out_degree" href="#Erdos.out_degree"><code>Erdos.out_degree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">out_degree(g, v)</code></pre><p>Returns the number of edges which end at vertex <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.out_degree_centrality" href="#Erdos.out_degree_centrality"><code>Erdos.out_degree_centrality</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the <a href="https://en.wikipedia.org/wiki/Centrality#Degree_centrality">degree centrality</a> of the graph <code>g</code>, with optional (default) normalization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.out_edges" href="#Erdos.out_edges"><code>Erdos.out_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">out_edges(g, v)</code></pre><p>Returns an iterator to the edges in <code>g</code> coming from vertex <code>v</code>. <code>v == src(e)</code> for each returned edge <code>e</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.out_neighbors" href="#Erdos.out_neighbors"><code>Erdos.out_neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">out_neighbors(g::AGraphOrDiGraph, v)</code></pre><p>Returns an iterable to all neighbors connected to vertex <code>v</code> by an outgoing edge.</p><p>NOTE: it may return a reference, not a copy. Do not modify result.</p></div></div></section><pre><code class="language-none">Erdos.outdegree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.pagerank" href="#Erdos.pagerank"><code>Erdos.pagerank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pagerank(g::ADiGraph, α=0.85, n=100, ϵ = 1.0e-6)</code></pre><p>Calculates the <a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> of the graph <code>g</code>. Can optionally specify a different damping factor (<code>α</code>), number of iterations (<code>n</code>), and convergence threshold (<code>ϵ</code>). If convergence is not reached within <code>n</code> iterations, an error will be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.period" href="#Erdos.period"><code>Erdos.period</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">period(g)</code></pre><p>Return the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; period(g)
3</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.periphery" href="#Erdos.periphery"><code>Erdos.periphery</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">periphery(g, distmx=weights(g))
periphery(all_ecc)</code></pre><p>Returns the set of all vertices whose eccentricity is equal to the graph&#39;s diameter (that is, the set of vertices with the largest eccentricity).</p><p>Eventually a vector <code>all_ecc</code> contain the eccentricity of each node can be passed as argument.</p><p>See <a href="#Erdos.eccentricities"><code>eccentricities</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.pop_vertex!" href="#Erdos.pop_vertex!"><code>Erdos.pop_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop_vertex!(g)</code></pre><p>Remove the last vertex of <code>g</code>. Equivalent to rem_vertex!(g, nv(g)).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.poslist" href="#Erdos.poslist"><code>Erdos.poslist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>pl[i][k]</code> is the position of vertex <code>i</code> in the adjlist of its neighbour <code>j=fadj[i][k]</code>, i.e. <code>i == adj[j][pl[i][k]]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.push_flow!" href="#Erdos.push_flow!"><code>Erdos.push_flow!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pushes as much flow as possible through the given edge.</p><p>Requires arguements:</p><ul><li>g::ADiGraph              # the input graph</li><li>u                               # input from-vertex</li><li>v                               # input to-vetex</li><li>capacity_matrix::AbstractMatrix{T}</li><li>flow_matrix::AbstractMatrix{T}</li><li>excess::AbstractVector{T}</li><li>height::AbstractVector{Int}</li><li>active::AbstractVector{Bool}</li><li>Q::PushRelabelHeap</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.push_relabel_impl" href="#Erdos.push_relabel_impl"><code>Erdos.push_relabel_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implementation of the push relabel algorithm with gap and highest excess heuristics. Takes O(V²√E) time.</p><p>Maintains the following auxillary arrays:</p><ul><li>height -&gt; Stores the labels of all vertices</li><li>count  -&gt; Stores the number of vertices at each height</li><li>excess -&gt; Stores the difference between incoming and outgoing flow for all vertices</li><li>active -&gt; Stores the status of all vertices. (e(v)&gt;0 =&gt; active[v] = true)</li><li>Q      -&gt; The heap that stores active vertices waiting to be discharged.</li></ul><p>Requires arguments:</p><ul><li>g::ADiGraph                # the input graph</li><li>source                            # the source vertex</li><li>target                            # the target vertex</li><li>capacity_matrix::AbstractMatrix{T}    # edge flow capacities</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.quick_find!" href="#Erdos.quick_find!"><code>Erdos.quick_find!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Performs <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Quick-Find algorithm</a> on a given pair of nodes <code>p</code>and <code>q</code>, and makes a connection between them in the vector <code>nodes</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.radius" href="#Erdos.radius"><code>Erdos.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radius(g, distmx=weights(g))</code></pre><p>Returns the minimum distance between any two vertices in <code>g</code>. Distances  between two adjacent nodes are given by <code>distmx</code>.</p><p>See <a href="#Erdos.eccentricities"><code>eccentricities</code></a>, <a href="#Erdos.diameter"><code>diameter</code></a>.</p></div></div></section><pre><code class="language-none">Erdos.randbinomial</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.random_configuration_model" href="#Erdos.random_configuration_model"><code>Erdos.random_configuration_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">random_configuration_model(n::Int, k::Vector{Int}; seed=-1, check_graphical=false)</code></pre><p>Creates a random undirected graph according to the <a href="http://tuvalu.santafe.edu/~aaronc/courses/5352/fall2013/csci5352_2013_L11.pdf">configuraton model</a>. It contains <code>n</code> vertices, the vertex <code>i</code> having degree <code>k[i]</code>.</p><p>Defining <code>c = mean(k)</code>, it allocates an array of <code>nc</code> <code>Int</code>s, and takes approximately <span>$nc^2$</span> time.</p><p>If <code>check_graphical=true</code> makes sure that <code>k</code> is a graphical sequence (see <code>is_graphical</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.random_regular_digraph" href="#Erdos.random_regular_digraph"><code>Erdos.random_regular_digraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)</code></pre><p>Creates a random directed <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>. The degree (in or out) can be specified using <code>dir=:in</code> or <code>dir=:out</code>. The default is <code>dir=:out</code>.</p><p>For directed graphs, allocates an <span>$n 	imes n$</span> sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.random_regular_graph" href="#Erdos.random_regular_graph"><code>Erdos.random_regular_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">random_regular_graph(n::Int, k::Int; seed=-1)</code></pre><p>Creates a random undirected <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>.</p><p>For undirected graphs, allocates an array of <code>nk</code> <code>Int</code>s, and takes approximately <span>$nk^2$</span> time. For <span>$k &gt; n/2$</span>, generates a graph of degree <code>n-k-1</code> and returns its complement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.randomwalk" href="#Erdos.randomwalk"><code>Erdos.randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randomwalk(g, s, niter)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.range_shuffle!" href="#Erdos.range_shuffle!"><code>Erdos.range_shuffle!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Fast shuffle Array <code>a</code> in UnitRange <code>r</code> inplace.</p></div></div></section><pre><code class="language-none">Erdos.readgexf</code></pre><pre><code class="language-none">Erdos.readgml</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.readgraph" href="#Erdos.readgraph"><code>Erdos.readgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readgraph(filename, G=Graph)
readgraph(filename, t, G=Graph; compressed=false)</code></pre><p>Reads a graph from  <code>filename</code> in the format <code>t</code>. Returns a graph of type <code>G</code> or the corresponding digraph/graph type. Compressed files can eventually be read.</p><p>Supported formats are <code>:gml, :dot, :graphml, :gexf, :net, :gt</code>.</p><p>If no format is provided, it will be inferred from <code>filename</code>.</p><pre><code class="language-none">readgraph(s::Symbol, G=Graph)</code></pre><p>Read a graph identified by <code>s</code> from Erdos datasets collection (e.g. <code>s=:karate</code>). They are stored in the <code>gt</code> binary format in the <code>datasets</code> directory of the package. For a list of available graph refer to the documentation.</p></div></div></section><pre><code class="language-none">Erdos.readgraphml</code></pre><pre><code class="language-none">Erdos.readgt</code></pre><pre><code class="language-none">Erdos.readgt_adj!</code></pre><pre><code class="language-none">Erdos.readgt_prop</code></pre><pre><code class="language-none">Erdos.readgt_props!</code></pre><pre><code class="language-none">Erdos.readnetgexf</code></pre><pre><code class="language-none">Erdos.readnetgml</code></pre><pre><code class="language-none">Erdos.readnetgraphml</code></pre><pre><code class="language-none">Erdos.readnetgt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.readnetwork" href="#Erdos.readnetwork"><code>Erdos.readnetwork</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readnetwork(filename, G=Graph)
readnetwork(filename, t, G=Graph; compressed=false)</code></pre><p>Reads a graph from  <code>filename</code> in the format <code>t</code>. Returns a graph of type <code>G</code> or the corresponding digraph/graph type. Compressed files can eventually be read.</p><p>Supported formats are <code>:gml, :dot, :graphml, :gexf, :net, :gt</code>.</p><p>If no format is provided, it will be inferred from <code>filename</code>.</p><pre><code class="language-none">readnetwork(s::Symbol, G=Graph)</code></pre><p>Read a graph identified by <code>s</code> from Erdos datasets collection (e.g. <code>s=:karate</code>). They are stored in the <code>gt</code> binary format in the <code>datasets</code> directory of the package. For a list of available graph refer to the documentation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.readpajek" href="#Erdos.readpajek"><code>Erdos.readpajek</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readpajek{G}(f::IO, ::Type{G})</code></pre><p>Reads a graph from file <code>f</code> in the <a href="http://gephi.github.io/users/supported-graph-formats/pajek-net-format/">Pajek .net</a> format. Returns 1 (number of graphs written).</p></div></div></section><pre><code class="language-none">Erdos.readpajek_edges!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rebuild!" href="#Erdos.rebuild!"><code>Erdos.rebuild!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rebuild!(g)</code></pre><p>Check and restore the structure of <code>g</code>, which could be corrupted by the use of unsafe functions (e. g. <a href="#Erdos.unsafe_add_edge!"><code>unsafe_add_edge!</code></a>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.relabel!" href="#Erdos.relabel!"><code>Erdos.relabel!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Relabels a vertex with respect to its neighbors, to produce an admissable edge.</p><p>Requires arguments:</p><ul><li>g::ADiGraph                 # the input graph</li><li>v                                  # input vertex to be relabeled</li><li>capacity_matrix::AbstractMatrix{T}</li><li>flow_matrix::AbstractMatrix{T}</li><li>excess::AbstractVector{T}</li><li>height::AbstractVector{Int}</li><li>active::AbstractVector{Bool}</li><li>count::AbstractVector{Int}</li><li>Q::AbstractVector{Int}</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_edge!" href="#Erdos.rem_edge!"><code>Erdos.rem_edge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_edge!(g, e)</code></pre><p>Remove the edge <code>e</code>.</p><pre><code class="language-none">rem_edge!(g, u, v)</code></pre><p>Remove the edge from <code>u</code> to <code>v</code>.</p><p>Returns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_edge_property!" href="#Erdos.rem_edge_property!"><code>Erdos.rem_edge_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_edge_property!(g, name)</code></pre><p>Remove the edge property  <code>name</code> from <code>g</code>.</p><p><a href="#Erdos.rem_eprop!"><code>rem_eprop!</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_eprop!" href="#Erdos.rem_eprop!"><code>Erdos.rem_eprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.rem_edge_property!"><code>rem_edge_property!</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_gprop!" href="#Erdos.rem_gprop!"><code>Erdos.rem_gprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.rem_graph_property!"><code>rem_graph_property!</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_graph_property!" href="#Erdos.rem_graph_property!"><code>Erdos.rem_graph_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_graph_property!(g, name)</code></pre><p>Remove the property <code>name</code> from <code>g</code>.</p><p><a href="#Erdos.rem_gprop!"><code>rem_gprop!</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_vertex!" href="#Erdos.rem_vertex!"><code>Erdos.rem_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_vertex!(g, v)</code></pre><p>Remove the vertex <code>v</code> from graph <code>g</code>. It will change the label of the last vertex of the old graph to <code>v</code>.</p><p>See also <a href="#Erdos.rem_vertices!"><code>rem_vertices!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_vertex_property!" href="#Erdos.rem_vertex_property!"><code>Erdos.rem_vertex_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_vertex_property!(g, name)</code></pre><p>Remove the vertex property  <code>name</code> from <code>g</code>.</p><p><a href="#Erdos.rem_vprop!"><code>rem_vprop!</code></a> is the short form of this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_vertices!" href="#Erdos.rem_vertices!"><code>Erdos.rem_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_vertices!(g, vs)
rem_vertices!(g, v1, v2, ....)</code></pre><p>Remove the vertices in <code>vs</code> from graph <code>g</code>.</p><p>Some vertices of <code>g</code> may be reindexed during the removal. To keep track of the reindexing, a vertex map is returned, associating vertices with changed indexes to their old indexes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.rem_vprop!" href="#Erdos.rem_vprop!"><code>Erdos.rem_vprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.rem_vertex_property!"><code>rem_vertex_property!</code></a></p></div></div></section><pre><code class="language-none">Erdos.renumber_labels!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.residual_graph" href="#Erdos.residual_graph"><code>Erdos.residual_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">residual_graph{G&lt;:ADiGraph}(g::G, capacity, flow)</code></pre><p>Computers the residual graph of <code>g</code> associated to given <code>flow</code> and <code>capacity</code>. See wikipedia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverse(e)</code></pre><p>Returns an edge with swapped <code>src(e)</code> and <code>dst(e)</code>.</p></div></div><div><div><pre><code class="language-none">reverse(g::ADiGraph)</code></pre><p>Produces a graph where all edges are reversed from the original.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverse!(g::DiGraph)</code></pre><p>In-place reverse (modifies the original graph).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.sample!" href="#Erdos.sample!"><code>Erdos.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>sample!([rng,] a, k; exclude = ())</p><p>Sample <code>k</code> element from array <code>a</code> without repetition and eventually excluding elements in <code>exclude</code>. Pay attention, it changes the order of the elements in <code>a</code>.</p></div></div></section><pre><code class="language-none">Erdos.seed_dsfmt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.self_avoiding_randomwalk" href="#Erdos.self_avoiding_randomwalk"><code>Erdos.self_avoiding_randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">self_avoiding_randomwalk(g, s, niter)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.set_graph_property!" href="#Erdos.set_graph_property!"><code>Erdos.set_graph_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_graph_property!(g, name, x)</code></pre><p>Set the property <code>name</code> to value <code>x</code> to <code>g</code>. Creates the property if it doesn&#39;t exist. <a href="#Erdos.gprop!"><code>gprop!</code></a> can be conveniently used as a short form of this function.</p><p><strong>Example</strong></p><pre><code class="language-julia">g = Network(10, 20)
set_graph_property!(g, &quot;label&quot;, &quot;My Network&quot;)
# or equivalently
gprop!(g, &quot;label&quot;, &quot;My Network&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.shortest_paths" href="#Erdos.shortest_paths"><code>Erdos.shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shortest_paths(g, x...; kws...)</code></pre><p>Computes shortest paths using Dijkstra&#39;s algorithm. See <a href="ref"><code>dijkstra_shortest_paths</code></a>.</p></div></div></section><pre><code class="language-none">Erdos.shortshow</code></pre><pre><code class="language-none">Erdos.signedtype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.slope" href="#Erdos.slope"><code>Erdos.slope</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Function to get the slope of the restricted flow. The slope is initialized at 0 and is incremented for each non saturated edge in the restricted min-cut. Requires argument:   flow<em>graph::ADiGraph,                   # the input graph   capacity</em>matrix::AbstractMatrix{T},  # edge flow capacities   cut::Vector{Int},                      # cut information for vertices   restriction::T                         # value of the restriction</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.spectral_distance" href="#Erdos.spectral_distance"><code>Erdos.spectral_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spectral_distance(G₁, G₂ [, k])</code></pre><p>Compute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k ≤ n greatest eigenvalues. If k is ommitted, uses full spectrum.</p><p>For further details, please refer to:</p><p>JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations</p></div></div></section><pre><code class="language-none">Erdos.splitgml</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.src" href="#Erdos.src"><code>Erdos.src</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">src(e)</code></pre><p>Returns the source of an edge.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.static_fitness_model" href="#Erdos.static_fitness_model"><code>Erdos.static_fitness_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">static_fitness_model(m, fitness, G=Graph; seed=-1)
static_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)</code></pre><p>Generates a random graph with <code>length(fitness)</code> nodes and <code>m</code> edges, in which the probability of the existence of edge <code>(i, j)</code> is proportional to <code>fitness[i]*fitness[j]</code>. Time complexity is O(|V| + |E| log |E|).</p><p>In and out fitness have to be supplied for generating directed graphs.</p><p>Reference:</p><ul><li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution</li></ul><p>in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.static_scale_free" href="#Erdos.static_scale_free"><code>Erdos.static_scale_free</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function static_scale_free(n, m, α, G=Graph;
        seed=-1, finite_size_correction=true)</code></pre><p>Generates a random graph with <code>n</code> vertices, <code>m</code> edges and expected power-law degree distribution with exponent <code>α</code>. <code>finite_size_correction</code> determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the <code>static_fitness_model function</code>. Time complexity is O(|V| + |E| log |E|).</p><pre><code class="language-none">function static_scale_free(n, m, α_out, α_in, G=DiGraph;
        seed=-1, finite_size_correction=true)</code></pre><p>Generates a random digraph</p><p>References:</p><ul><li><p>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</p></li><li><p>Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.</p></li><li><p>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.stochastic_block_model" href="#Erdos.stochastic_block_model"><code>Erdos.stochastic_block_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)
stochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)</code></pre><p>Returns a Graph generated according to the Stochastic Block Model (SBM).</p><p><code>c[a,b]</code> : Mean number of neighbors of a vertex in block <code>a</code> belonging to block <code>b</code>.            Only the upper triangular part is considered, since the lower traingular is            determined by <span>$c[b,a] = c[a,b] * n[a]/n[b]$</span>. <code>n[a]</code> : Number of vertices in block <code>a</code></p><p>The second form samples from a SBM with <code>c[a,a]=cin</code>, and <code>c[a,b]=coff</code>.</p><p>For a dynamic version of the SBM see the <code>StochasticBlockModel</code> type and related functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.strongly_connected_components" href="#Erdos.strongly_connected_components"><code>Erdos.strongly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strongly_connected_components(g)</code></pre><p>Compute the strongly connected components of a directed graph <code>g</code>.</p><p>Return an array of arrays, each of which is the entire connected component.</p><p><strong>Implementation Notes</strong></p><p>The order of the components is not part of the API contract.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [3]
 [1, 2]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.subgraph" href="#Erdos.subgraph"><code>Erdos.subgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subgraph(g, vlist) -&gt; sg, vlist
subgraph(g, elist) -&gt; sg, vlist</code></pre><p>Returns the subgraph of <code>g</code> induced by the vertices in  <code>vlist</code> or by the edges in <code>elist</code>, along with <code>vlist</code> itself (a newly created vector for the second method).</p><p>The returned graph has <code>length(vlist)</code> vertices, with the new vertex <code>i</code> corresponding to the vertex of the original graph in the <code>i</code>-th position of <code>vlist</code>.</p><p>For easy subgraph creation also <code>g[vlist]</code> or <code>g[elist]</code> can be used.</p><p>If <code>g</code> is a network, vector and edge properties won&#39;t be converved <code>sg</code>. You can preserve properties using the <a href="#Erdos.subnetwork"><code>subnetwork</code></a> method.</p><p><strong>Usage Examples:</strong></p><pre><code class="language-julia">g = CompleteGraph(10)
sg, vlist = subgraph(g, 5:8)
@assert g[5:8] == sg
@assert nv(sg) == 4
@assert ne(sg) == 6
@assert vm[4] == 8

sg, vlist = subgraph(g, [2,8,3,4])
@asssert sg == g[[2,8,3,4]]

elist = [Edge(1,2), Edge(3,4), Edge(4,8)]
sg, vlist = subgraph(g, elist)
@asssert sg == g[elist]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.subnetwork" href="#Erdos.subnetwork"><code>Erdos.subnetwork</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subnetwork(g, vlist) -&gt; sg, vlist
subnetwork(g, elist) -&gt; sg, vlist</code></pre><p>Equivalent to <a href="#Erdos.subgraph"><code>subgraph</code></a> but preserves vertex and edge properties when <code>g</code> is a network.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.swap_vertices!" href="#Erdos.swap_vertices!"><code>Erdos.swap_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">swap_vertices!(g, u, v)</code></pre><p>Swap the labels of vertices <code>u</code> and <code>v</code>. In the new graph all old neighbors of vertex <code>u</code> will be neighbors of <code>v</code> and viceversa.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.symmetric_difference" href="#Erdos.symmetric_difference"><code>Erdos.symmetric_difference</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symmetric_difference(g, h)</code></pre><p>Produces a graph with edges from graph <code>g</code> that do not exist in graph <code>h</code>, and vice versa.</p><p>Note that this function may produce a graph with 0-degree vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.tensor_product" href="#Erdos.tensor_product"><code>Erdos.tensor_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tensor_product(g, h)</code></pre><p>Returns the (tensor product)[https://en.wikipedia.org/wiki/Tensor<em>product</em>of_graphs] of <code>g</code> and <code>h</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.topological_sort_by_dfs" href="#Erdos.topological_sort_by_dfs"><code>Erdos.topological_sort_by_dfs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">topological_sort_by_dfs(g)</code></pre><p>Return a <a href="https://en.wikipedia.org/wiki/Topological_sorting">toplogical sort</a> of a directed graph <code>g</code> as a vector of vertices in topological order.</p></div></div></section><pre><code class="language-none">Erdos.traverse_graph!</code></pre><pre><code class="language-none">Erdos.traverse_graph_withlog</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.tree" href="#Erdos.tree"><code>Erdos.tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tree(parents)</code></pre><p>Convert a parents array into a directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.triangles" href="#Erdos.triangles"><code>Erdos.triangles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">triangles(g, v)</code></pre><p>Returns the number of triangles in the neighborhood for node <code>v</code>.</p></div></div><div><div><pre><code class="language-none">triangles(g, vlist = vertices(g))</code></pre><p>Returns a vector containing the number of triangles for vertices <code>vlist</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union(g, h)</code></pre><p>Merges graphs <code>g</code> and <code>h</code> by taking the set union of all vertices and edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.unsafe_add_edge!" href="#Erdos.unsafe_add_edge!"><code>Erdos.unsafe_add_edge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_add_edge!(g, u, v)</code></pre><p>Possibly faster and unsafer version of <a href="#Erdos.add_edge!"><code>add_edge!</code></a>, which doesn&#39;t guarantee some graph invariant properties.</p><p>For example, some graph types (e.g. <code>Graph</code>) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such <code>has_edge(g, u, v)</code> could give incorrect results.</p><p>To restore the correct behaviour, call <a href="#Erdos.rebuild!"><code>rebuild!</code></a>(g) after the last call to <code>unsafe_add_edge!</code>.</p></div></div></section><pre><code class="language-none">Erdos.updateheap!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vertex_property" href="#Erdos.vertex_property"><code>Erdos.vertex_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vertex_property(g, name)</code></pre><p>Return an vertex map corresponding to property <code>name</code> of vertices in <code>g</code>.</p><pre><code class="language-none">vertex_property(g)</code></pre><p>Returns a dictionary with elements <code>property_name =&gt; vertex_map</code>.</p><pre><code class="language-none">vertex_property(g, v)</code></pre><p>Returns a dictionary of the form <code>name =&gt; val</code> containing all the properties associated to vertex <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vertextype" href="#Erdos.vertextype"><code>Erdos.vertextype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vertextype(g)
vertextype(G)</code></pre><p>Returns the integer type of vertices of graph <code>g</code> (or graph type <code>G</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vertices" href="#Erdos.vertices"><code>Erdos.vertices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vertices(g)</code></pre><p>Returns an iterator to the vertices of a graph (i.e. 1:nv(g))</p></div></div></section><pre><code class="language-none">Erdos.visited_vertices</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vote!" href="#Erdos.vote!"><code>Erdos.vote!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the most frequency label.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vprop" href="#Erdos.vprop"><code>Erdos.vprop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.vertex_property"><code>vertex_property</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.vprop!" href="#Erdos.vprop!"><code>Erdos.vprop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See <a href="#Erdos.add_vertex_property!"><code>add_vertex_property!</code></a></p></div></div></section><pre><code class="language-none">Erdos.vprop_names</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.watts_strogatz" href="#Erdos.watts_strogatz"><code>Erdos.watts_strogatz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">watts_strogatz(n, k, β, G=Graph; seed=-1)</code></pre><p>Creates a <a href="https://en.wikipedia.org/wiki/Watts_and_Strogatz_model">Watts-Strogatz</a> small model random graph with <code>n</code> vertices, each with degree <code>k</code>. Edges are randomized per the model based on probability <code>β</code>.</p><p>Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. <code>DiGraph</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.weakly_connected_components" href="#Erdos.weakly_connected_components"><code>Erdos.weakly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weakly_connected_components(g)</code></pre><p>Return the weakly connected components of the graph <code>g</code>. This is equivalent to the connected components of the undirected equivalent of <code>g</code>. For undirected graphs this is equivalent to the <a href="#Erdos.connected_components"><code>connected_components</code></a> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = DiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; weakly_connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.weights" href="#Erdos.weights"><code>Erdos.weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weights(g)</code></pre><p>Returns an edge map containing the &quot;weights&quot; associated to edges. For simple graphs, the return value is ConstEdgeMap(g, 1). For networks, returns the &quot;weights&quot; edge property if defined, otherwise the constant map.</p><p>Notice that the edge map returned by <code>weights</code> is the default value for the edge weights used in many flow and  distance on graph algorithms.</p></div></div></section><pre><code class="language-none">Erdos.writedot</code></pre><pre><code class="language-none">Erdos.writegexf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.writegml" href="#Erdos.writegml"><code>Erdos.writegml</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writegml(f, g)</code></pre><p>Writes a graph <code>g</code> to a file <code>f</code> in the <a href="https://en.wikipedia.org/wiki/Graph_Modelling_Language">GML</a> format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.writegraph" href="#Erdos.writegraph"><code>Erdos.writegraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writegraph(file, g)
writegraph(file, g, t; compress=false)</code></pre><p>Save a graph <code>g</code> to <code>file</code> in the format <code>t</code>.</p><p>Eventually the resulting file can be compressed in the gzip format.</p><p>Currently supported formats are <code>:gml, :graphml, :gexf, :dot, :net, :gt</code>.</p><p>If no format is provided, it will be inferred from <code>file</code> along with compression.</p></div></div></section><pre><code class="language-none">Erdos.writegraphml</code></pre><pre><code class="language-none">Erdos.writegt</code></pre><pre><code class="language-none">Erdos.writegt_adj</code></pre><pre><code class="language-none">Erdos.writegt_prop</code></pre><pre><code class="language-none">Erdos.writegt_props</code></pre><pre><code class="language-none">Erdos.writenetgexf</code></pre><pre><code class="language-none">Erdos.writenetgml</code></pre><pre><code class="language-none">Erdos.writenetgraphml</code></pre><pre><code class="language-none">Erdos.writenetgt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.writenetwork" href="#Erdos.writenetwork"><code>Erdos.writenetwork</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writenetwork(file, g)
writenetwork(file, g, t; compress=false)</code></pre><p>Save a graph <code>g</code> to <code>file</code> in the format <code>t</code>.</p><p>Eventually the resulting file can be compressed in the gzip format.</p><p>Currently supported formats are <code>:gml, :graphml, :gexf, :dot, :net, :gt</code>.</p><p>If no format is provided, it will be inferred from <code>file</code> along with compression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Erdos.writepajek" href="#Erdos.writepajek"><code>Erdos.writepajek</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Writes a graph <code>g</code> to a file <code>f</code> in the <a href="http://gephi.github.io/users/supported-graph-formats/pajek-net-format/">Pajek .net</a> format. Returns 1 (number of graphs written).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
