<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background and Motivation Â· LossFunctions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LossFunctions.jl logo"/></a><h1>LossFunctions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Introduction</span><ul><li><a class="toctext" href="../gettingstarted/">Getting Started</a></li><li class="current"><a class="toctext" href>Background and Motivation</a><ul class="internal"><li><a class="toctext" href="#Terminology-1">Terminology</a></li><li><a class="toctext" href="#Definitions-1">Definitions</a></li><li><a class="toctext" href="#Alternative-Viewpoints-1">Alternative Viewpoints</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></li><li><span class="toctext">User&#39;s Guide</span><ul><li><a class="toctext" href="../../user/interface/">Working with Losses</a></li><li><a class="toctext" href="../../user/aggregate/">Efficient Sum and Mean</a></li></ul></li><li><span class="toctext">Available Losses</span><ul><li><a class="toctext" href="../../losses/distance/">Distance-based Losses</a></li><li><a class="toctext" href="../../losses/margin/">Margin-based Losses</a></li></ul></li><li><span class="toctext">Advances Topics</span><ul><li><a class="toctext" href="../../advanced/extend/">Altering existing Losses</a></li><li><a class="toctext" href="../../advanced/developer/">Developer Documentation</a></li></ul></li><li><a class="toctext" href="../../acknowledgements/">Acknowledgements</a></li><li><a class="toctext" href="../../LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li>Introduction</li><li><a href>Background and Motivation</a></li></ul></nav><hr/><div id="topbar"><span>Background and Motivation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Background-and-Motivation-1" href="#Background-and-Motivation-1">Background and Motivation</a></h1><p>In this section we will discuss the concept &quot;loss function&quot; in more detail. We will start by introducing some terminology and definitions. However, please note that we won&#39;t attempt to give a complete treatment of loss functions and the math involved (unlike a book or a lecture could do). So this section won&#39;t be a substitution for proper literature on the topic. While we will try to cover all the basics necessary to get a decent intuition of the ideas involved, we do assume basic knowledge about Machine Learning.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This section and its sub-sections serve soley as to explain the underyling theory and concepts and further to motivate the solution provided by this package. As such, this section is <strong>not</strong> intended as a guide on how to apply this package.</p></div></div><h2><a class="nav-anchor" id="Terminology-1" href="#Terminology-1">Terminology</a></h2><p>To start off, let us go over some basic terminology. In <strong>Machine Learning</strong> (ML) we are primarily interested in automatically learning meaningful patterns from data. For our purposes it suffices to say that in ML we try to teach the computer to solve a task by induction rather than by definition. This package is primarily concerned with the subset of Machine Learning that falls under the umbrella of <strong>Supervised Learning</strong>. There we are interested in teaching the computer to predict a specific output for some given input. In contrast to unsupervised learning the teaching process here involves showing the computer what the predicted output is supposed to be; i.e. the &quot;true answer&quot; if you will.</p><p>How is this relevant for this package? Well, it implies that we require some meaningful way to show the true answers to the computer so that it can learn from &quot;seeing&quot; them. More importantly, we have to somehow put the true answer into relation to what the computer currently predicts the answer should be. This would provide the basic information needed for the computer to be able to improve; that is what loss functions are for.</p><p>When we say we want our computer to learn something that is able to make predictions, we are talking about a <strong>prediction function</strong>, denoted as <span>$h$</span> and sometimes called &quot;fitted hypothesis&quot;, or &quot;fitted model&quot;. Note that we will avoid the term hypothesis for the simple reason that it is widely used in statistics for something completely different. We don&#39;t consider a prediction <em>function</em> as the same thing as a prediction <em>model</em>, because we think of a <strong>prediction model</strong> as a family of prediction functions. What that boils down to is that the prediction model represents the set of possible prediction functions, while the final prediction function is the chosen function that best solves the prediction problem. So in a way a prediction model can be thought of as the manifestation of our assumptions about the problem, because it restricts the solution to a specific family of functions. For example a linear prediction model for two features represents all possible linear functions that have two coefficients. A prediction function would in that scenario be a concrete linear function with a particular fixed set of coefficients.</p><p>The purpose of a prediction function is to take some input and produce a corresponding output. That output should be as faithful as possible to the true answer. In the context of this package we will refer to the &quot;true answer&quot; as the <strong>true target</strong>, or short &quot;target&quot;. During training, and only during training, inputs and targets can both be considered as part of our data set. We say &quot;only during training&quot; because in a production setting we don&#39;t actually have the targets available to us (otherwise there would be no prediction problem to solve in the first place). In essence we can think of our data as two entities with a 1-to-1 connection in each observation, the inputs, which we call <strong>features</strong>, and the corresponding desired outputs, which we call <strong>true targets</strong>.</p><p>Let us be a little more concrete with the two terms we really care about in this package.</p><ul><li><p><strong>True Targets</strong>:</p><p>A true target (singular) represents the &quot;desired&quot; output for the input features of a single observation. The targets are often referred to as &quot;ground truth&quot; and we will denote a single target as <span>$y \in Y$</span>. While <span>$y$</span> can be a scalar or some array, the key is that it represents the target of a single observation. When we talk about an array (e.g. a vector) of <strong>multiple</strong> targets, we will print it in bold as <span>$\mathbf{y}$</span>. What the set <span>$Y$</span> is will depend on the subdomain of supervised learning that you are working in.</p><ul><li>Real-valued Regression: <span>$Y \subseteq \mathbb{R}$</span>.</li><li>Multioutput Regression: <span>$Y \subseteq \mathbb{R}^k$</span>.</li><li>Margin-based Classification: <span>$Y = \{1,-1\}$</span>.</li><li>Probabilistic Classification: <span>$Y = \{1,0\}$</span>.</li><li>Multiclass Classification: <span>$Y = \{1,2,\dots,k\}$</span>.</li></ul><p>See <a href="https://mllabelutilsjl.readthedocs.io/en/latest/api/targets.html">MLLabelUtils</a> for more information on classification targets.</p></li><li><p><strong>Predicted Outputs</strong>:</p><p>A predicted output (singular) is the result of our prediction function given the features of some observation. We will denote a single output as <span>$\hat{y} \in \mathbb{R}$</span> (pronounced as &quot;why hat&quot;). When we talk about an array of outputs for multiple observations, we will print it in bold as <span>$\mathbf{\hat{y}}$</span>. Note something unintuitive but important: The variables <span>$y$</span> and <span>$\hat{y}$</span> don&#39;t have to be of the same set. Even in a classification setting where <span>$y \in \{1,-1\}$</span>, it is typical that <span>$\hat{y} \in \mathbb{R}$</span>.</p><p>The fact that in classification the predictions can be fundamentally different than the targets is important to know. The reason for restricting the targets to specific numbers when doing classification is mathematical convenience for loss functions. So loss functions have this knowledge build in.</p></li></ul><p>In a classification setting, the predicted outputs and the true targets are usually of different form and type. For example, in margin-based classification it could be the case that the target <span>$y=-1$</span> and the predicted output <span>$\hat{y} = -1000$</span>. It would seem that the prediction is not really reflecting the target properly, but in this case we would actually have a perfectly correct prediction. This is because in margin-based classification the main thing that matters about the predicted output is that the sign agrees with the true target.</p><p>Even though we talked about prediction functions and features, we will see that for computing loss functions all we really care about are the true targets and the predicted outputs, regardless of how the outputs were produced.</p><h2><a class="nav-anchor" id="Definitions-1" href="#Definitions-1">Definitions</a></h2><p>We base most of our definitions on the work presented in <a href="#footnote-STEINWART2008">[STEINWART2008]</a>. Note, however, that we will adapt or simplify in places at our discretion. We do this in situations where it makes sense to us considering the scope of this package or because of implementation details.</p><p>Let us again consider the term <strong>prediction function</strong>. More formally, a prediction function <span>$h$</span> is a function that maps an input from the feature space <span>$X$</span> to the real numbers <span>$\mathbb{R}$</span>. So invoking <span>$h$</span> with some features <span>$x \in X$</span> will produce the prediction <span>$\hat{y} \in \mathbb{R}$</span>.</p><div>\[h : X \rightarrow \mathbb{R}\]</div><p>This resulting prediction <span>$\hat{y}$</span> is what we want to compare to the target <span>$y$</span> in order to asses how bad the prediction is. The function we use for such an assessment will be of a family of functions we refer to as supervised losses. We think of a <strong>supervised loss</strong> as a function of two parameters, the true target <span>$y \in Y$</span> and the predicted output <span>$\hat{y} \in \mathbb{R}$</span>. The result of computing such a loss will be a non-negative real number. The larger the value of the loss, the worse the prediction.</p><div>\[L : Y \times \mathbb{R} \rightarrow [0,\infty)\]</div><p>Note a few interesting things about supervised loss functions.</p><ul><li><p>The absolute value of a loss is often (but not always) meaningless and doesn&#39;t offer itself to a useful interpretation. What we usually care about is that the loss is as small as it can be.</p></li><li><p>In general the loss function we use is not the function we are actually interested in minimizing. Instead we are minimizing what is referred to as a &quot;surrogate&quot;. For binary classification for example we are really interested in minimizing the ZeroOne loss (which simply counts the number of misclassified predictions). However, that loss is difficult to minimize given that it is not convex nor continuous. That is why we use other loss functions, such as the hinge loss or logistic loss. Those losses are &quot;classification calibrated&quot;, which basically means they are good enough surrogates to solve the same problem. Additionally, surrogate losses tend to have other nice properties.</p></li><li><p>For classification it does not need to be the case that a &quot;correct&quot; prediction has a loss of zero. In fact some classification calibrated losses are never truly zero.</p></li></ul><p>There are two sub-families of supervised loss-functions that are of particular interest, namely <strong>margin-based</strong> losses and <strong>distance-based</strong> losses. These two categories of loss functions are especially useful for the two basic sub-domains of supervised learning: Classification and Regression.</p><h3><a class="nav-anchor" id="Margin-based-Losses-for-Classification-1" href="#Margin-based-Losses-for-Classification-1">Margin-based Losses for Classification</a></h3><p>Margin-based losses are mainly utilized for binary classification problems where the goal is to predict a categorical value. They assume that the set of targets <span>$Y$</span> is restricted to <span>$Y = \{1,-1\}$</span>. These two possible values for the target denote the positive class in the case of <span>$y = 1$</span>, and the negative class in the case of <span>$y = -1$</span>. In contrast to other formalism, they do not natively provide probabilities as output.</p><p>More formally, we call a supervised loss function <span>$L : Y \times \mathbb{R} \rightarrow [0, \infty)$</span> <strong>margin-based</strong> if there exists a representing function <span>$\psi : \mathbb{R} \rightarrow [0, \infty)$</span> such that</p><div>\[L(y, \hat{y}) = \psi (y \cdot \hat{y}),  \qquad  y \in Y, \hat{y} \in \mathbb{R}\]</div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Throughout the codebase we refer to the result of <span>$y \cdot \hat{y}$</span> as <em>agreement</em>. The discussion that lead to this convention can be found <a href="https://github.com/JuliaML/LossFunctions.jl/issues/9#issuecomment-190321549">issue #9</a></p></div></div><h3><a class="nav-anchor" id="Distance-based-Losses-for-Regression-1" href="#Distance-based-Losses-for-Regression-1">Distance-based Losses for Regression</a></h3><p>Distance-based losses are usually used in regression settings where the goal is to predict some real valued variable. The goal there is that the prediction is as close as possible to the true target. In such a scenario it is quite sensible to penalize the distance between the prediction and the target in some way.</p><p>More formally, a supervised loss function <span>$L : Y \times \mathbb{R} \rightarrow [0, \infty)$</span> is said to be <strong>distance-based</strong>, if there exists a representing function <span>$\psi : \mathbb{R} \rightarrow [0, \infty)$</span> satisfying <span>$\psi (0) = 0$</span> and</p><div>\[L(y, \hat{y}) = \psi (\hat{y} - y),  \qquad  y \in Y, \hat{y} \in \mathbb{R}\]</div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In the literature that this package is partially based on, the convention for the distance-based losses is that <span>$r = y - \hat{y}$</span> (see <a href="#footnote-STEINWART2008">[STEINWART2008]</a> p. 38). We chose to diverge from this definition because it would force a difference of the sign between the results for the unary and the binary version of the derivative. That difference would be a introduced by the chain rule, since the inner derivative would result in <span>$\frac{\partial}{\partial \hat{y}} (y - \hat{y}) = -1$</span>.</p></div></div><h2><a class="nav-anchor" id="Alternative-Viewpoints-1" href="#Alternative-Viewpoints-1">Alternative Viewpoints</a></h2><p>While the term &quot;loss function&quot; is usually used in the same context throughout the literature, the specifics differ from one textbook to another. For that reason we would like to mention alternative definitions of what a &quot;loss function&quot; is. Note that we will only give a partial and thus very simplified description of these. Please refer to the listed sources for more specifics.</p><p>In <a href="#footnote-SHALEV2014">[SHALEV2014]</a> the authors consider a loss function as a higher-order function of two parameters, a prediction model and an observation tuple. So in that definition a loss function and the prediction function are tightly coupled. This way of thinking about it makes a lot of sense, considering the process of how a prediction model is usually fit to the data. For gradient descent to do its job it needs the, well, gradient of the empirical risk. This gradient is computed using the chain rule for the inner loss and the prediction model. If one views the loss and the prediction model as one entity, then the gradient can sometimes be simplified immensely. That said, we chose to not follow this school of thought, because from a software-engineering standpoint it made more sense to us to have small modular pieces. So in our implementation the loss functions don&#39;t need to know that prediction functions even exist. This makes the package easier to maintain, test, and reason with. Given Julia&#39;s ability for multiple dispatch we don&#39;t even lose the ability to simplify the gradient if need be.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><div class="footnote" id="footnote-STEINWART2008"><a href="#footnote-STEINWART2008"><strong>[STEINWART2008]</strong></a><p>Steinwart, Ingo, and Andreas Christmann. <a href="https://www.springer.com/us/book/9780387772417">&quot;Support vector machines&quot;</a>. Springer Science &amp; Business Media, 2008.</p></div><div class="footnote" id="footnote-SHALEV2014"><a href="#footnote-SHALEV2014"><strong>[SHALEV2014]</strong></a><p>Shalev-Shwartz, Shai, and Shai Ben-David. <a href="http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/">&quot;Understanding machine learning: From theory to algorithms&quot;</a>. Cambridge University Press, 2014.</p></div><footer><hr/><a class="previous" href="../gettingstarted/"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="../../user/interface/"><span class="direction">Next</span><span class="title">Working with Losses</span></a></footer></article></body></html>
