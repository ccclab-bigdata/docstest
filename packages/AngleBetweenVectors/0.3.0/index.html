<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · AngleBetweenVectors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AngleBetweenVectors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="AngleBetweenVectors.jl-1" href="#AngleBetweenVectors.jl-1">AngleBetweenVectors.jl</a></h1><h4><a class="nav-anchor" id="When-computing-the-arc-separating-two-cartesian-vectors,-this-is-robustly-stable;-others-are-not.-1" href="#When-computing-the-arc-separating-two-cartesian-vectors,-this-is-robustly-stable;-others-are-not.-1">When computing the arc separating two cartesian vectors, this is robustly stable; others are not.</a></h4><hr/><h4><a class="nav-anchor" id="Copyright-and-thinsp;2018-by-Jeffrey-Sarnoff.-and-nbsp;-and-nbsp;-This-work-is-released-under-The-MIT-License.-1" href="#Copyright-and-thinsp;2018-by-Jeffrey-Sarnoff.-and-nbsp;-and-nbsp;-This-work-is-released-under-The-MIT-License.-1">Copyright ©&amp;thinsp;2018 by Jeffrey Sarnoff. &amp;nbsp;&amp;nbsp; This work is released under The MIT License.</a></h4><hr/><p><a href="https://travis-ci.org/JeffreySarnoff/AngleBetweenVectors.jl"><img src="https://travis-ci.org/JeffreySarnoff/AngleBetweenVectors.jl.svg?branch=master" alt="Build Status"/></a></p><hr/><p><a href="https://github.com/JeffreySarnoff/AngleBetweenVectors.jl">AngleBetweenVectors</a> exports <code>angle</code>. <code>angle(point1, point2)</code> determines the angle of their separation.   The smaller of the two solutions is used.  <code>π</code> obtains If the points are opposed, [(1,0), (-1,0)]; so <code>0 &lt;= angle(p1, p2) &lt;= pi</code>.</p><p>This function expects two points from a 2D, 3D .. ManyD space, in Cartesian coordinates.  Tuples and Vectors are handled immediately (prefer Tuples for speed). To use another point representations, just define a <code>Tuple</code> constructor for it.  NamedTuples and SVectors have this already.</p><p>Most software uses <code>acos(dot(p1, p2) / sqrt(norm(p1) norm(p2))</code> instead.  While they coincide often; it is exceedingly easy to find cases where <code>angle</code> is more accurate and then, usually they differ by a few ulps. Not always.</p><hr/><h3><a class="nav-anchor" id="provides-1" href="#provides-1">provides</a></h3><ul><li><code>angle( point₁, point₂ )</code><ul><li>points are given as Cartesian coordinates</li><li>points may be of any finite dimension &gt;= 2</li><li>points may be any type with a Tuple constructor defined</li></ul></li></ul><h4><a class="nav-anchor" id="point-representations-that-just-work-1" href="#point-representations-that-just-work-1">point representations that just work</a></h4><ul><li>points as Tuples</li><li>points as NamedTuples</li><li>points as Vectors</li><li>points as SVectors     (StaticArrays)</li></ul><h4><a class="nav-anchor" id="working-with-other-point-representations-1" href="#working-with-other-point-representations-1">working with other point representations</a></h4><p>Just define a <code>Tuple</code> constructor for the representation.  That&#39;s all.</p><pre><code class="language-julia"># working with this?
struct Point3D{T}
    x::T
    y::T
    z::T
end

#  define this:
Base.Tuple(a::Point3D{T}) where {T} = (a.x, a.y, a.z)

#  this just works:
angle(point1::Point3D{T}, point2::Point3D{T})  where {T}</code></pre><h3><a class="nav-anchor" id="why-use-it-1" href="#why-use-it-1">why use it</a></h3><p>This implementation is more robustly accurate than the usual method.</p><p>You can work with points in 2D, 3D, .. 1000D .. ?.</p><hr/><h3><a class="nav-anchor" id="notes-1" href="#notes-1">notes</a></h3><ul><li><p>The shorter of two angle solutions is returned as an unoriented magnitude (0 &lt;= radians &lt; π).</p></li><li><p>Vectors are given by their Cartesian coordinates in 2D, 3D or .. N-dimensions.</p></li><li><p>This follows a note by Professor Kahan in <a href=" https:/people.eecs.berkeley.edu/%7Ewkahan/MathH110/Cross.pdf">Computing Cross-Products and Rotations</a> (pg 15): &quot;More uniformly accurate .. valid for  Euclidean  spaces of any dimension,   it never errs by more than a modest multiple of ε.&quot;  </p></li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
