<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · PowerDynSolve.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerDynSolve.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>-</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>-</a></li></ul></nav><hr/><div id="topbar"><span>-</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.no_internal_differentials" href="#PowerDynBase.no_internal_differentials"><code>PowerDynBase.no_internal_differentials</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A variable to be used when no internal differentials are present for a node dynamics type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.no_internal_masses" href="#PowerDynBase.no_internal_masses"><code>PowerDynBase.no_internal_masses</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A variable to be used when no internal masses are present for a node dynamics type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNodeParameters" href="#PowerDynBase.AbstractNodeParameters"><code>PowerDynBase.AbstractNodeParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node parameter types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.FourthEq" href="#PowerDynBase.FourthEq"><code>PowerDynBase.FourthEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$\theta$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$\phi$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>T_d_dash</code>: time constant of d-axis</li><li><code>T_q_dash</code>: time constant of q-axis</li><li><code>X_d_dash</code>: transient reactance of d-axis</li><li><code>X_q_dash</code>: transient reactance of q-axis</li><li><code>X_d</code>: reactance of d-axis</li><li><code>X_d</code>: reactance of q-axis</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u)\]</div><p>The fourth-order equations read (according to Sauer, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
     \frac{d\omega}{dt} = P-D\omega - p -(x&#39;_q-x&#39;_d)i_d i_q\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (x_d - x&#39;_d) i_{d}+ e_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (x_q - x&#39;_q) i_{q})  \\\]</div><p>With the PowerDynamics.jl \time{naming conventions} of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.GridDynamics" href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all abstract grid dynamics types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.GridDynamics-Tuple{AbstractArray{#s20487,1} where #s20487&lt;:AbstractNodeParameters,Vararg{Any,N} where N}" href="#PowerDynBase.GridDynamics-Tuple{AbstractArray{#s20487,1} where #s20487&lt;:AbstractNodeParameters,Vararg{Any,N} where N}"><code>PowerDynBase.GridDynamics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridDynamics(nodes::AbstractVector{&lt;:AbstractNodeParameters}, args...; kwargs...)</code></pre><p>Convert all subtypes of <a href="#PowerDynBase.AbstractNodeParameters"><code>PowerDynBase.AbstractNodeParameters</code></a> to the corresponding subtypes of <a href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> and then call <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a> again.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.GridDynamics-Tuple{AbstractArray{#s20487,N} where N where #s20487&lt;:PowerDynBase.AbstractNodeDynamics,AbstractArray{T,2} where T}" href="#PowerDynBase.GridDynamics-Tuple{AbstractArray{#s20487,N} where N where #s20487&lt;:PowerDynBase.AbstractNodeDynamics,AbstractArray{T,2} where T}"><code>PowerDynBase.GridDynamics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridDynamics(
    nodes::AbstractArray{&lt;:AbstractNodeDynamics},
    LY::AbstractMatrix;
    skip_LY_check=false,
    kwargs...)</code></pre><p>Bring all sutypes of <a href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> on one level and then create for each subtype of <a href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> the corresponding subtype of <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a> by using <a href="#PowerDynBase._GridDynamics-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:OrdinaryNodeDynamics,AbstractArray{T,2} where T}"><code>PowerDynBase._GridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.GridDynamicsError" href="#PowerDynBase.GridDynamicsError"><code>PowerDynBase.GridDynamicsError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Error to be thrown if something goes wrong during the grid dynamics construction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.NetworkRHS" href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct NetworkRHS{T, M} &lt;: AbstractNetworkFunction{T, M}
    nodes::AbstractVector{T}
    LY::M
    numnodes
    systemsize
    intrange # unitrange telling me where I find the internal dynamic variables
    nodalintranges # unit ranges to find the internal variables for each node in the full length of internal variables
end</code></pre><p>Representing the full dynamics of the power grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.NetworkRHS-Tuple{Any}" href="#PowerDynBase.NetworkRHS-Tuple{Any}"><code>PowerDynBase.NetworkRHS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">NetworkRHS(x)</code></pre><p>Return the struct of type <a href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a> for <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.NetworkRHS-Tuple{PowerDynBase.AbstractDEVariable,Any}" href="#PowerDynBase.NetworkRHS-Tuple{PowerDynBase.AbstractDEVariable,Any}"><code>PowerDynBase.NetworkRHS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(rhs::NetworkRHS)(x::AbstractDEVariable, t)</code></pre><p>Evalate the network right-hand-side function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.NetworkRHS-Union{Tuple{M}, Tuple{T}, Tuple{AbstractArray{T,1},M}} where M&lt;:(AbstractArray{T,2} where T) where T&lt;:PowerDynBase.AbstractNodeDynamics" href="#PowerDynBase.NetworkRHS-Union{Tuple{M}, Tuple{T}, Tuple{AbstractArray{T,1},M}} where M&lt;:(AbstractArray{T,2} where T) where T&lt;:PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.NetworkRHS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">NetworkRHS(nodes::AbstractVector{T}, LY::M) where {T&lt;:AbstractNodeDynamics, M&lt;:AbstractMatrix}</code></pre><p>Create an <a href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a> object from a node list and the nodal admittance matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.NodeDynamicsError" href="#PowerDynBase.NodeDynamicsError"><code>PowerDynBase.NodeDynamicsError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Error to be thrown if something goes wrong during the node dynamics construction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryNodeDynamics" href="#PowerDynBase.OrdinaryNodeDynamics"><code>PowerDynBase.OrdinaryNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">OrdinaryNodeDynamics(;rhs, n_int)</code></pre><p>The type representing the dynamics of a node that is described via ODEs.</p><p>Each node <span>$a$</span> has the complex voltage <span>$u$</span> and <span>$n$</span> real internal variables <span>$y_1, \dots, y_n$</span>, so it generally describes a system of ordinary differential equation as</p><div>\[\frac{du_a}{dt} = f_u(u_a, {i_c}_a, y_1, \dots, y_n) \\
\frac{dy_{ak}}{dt} = f_k(u_a, {i_c}_a, y_1, \dots, y_n)\quad \forall k = 1, \dots, n.\]</div><p><span>$f$</span> is represented by <code>rhs</code> field of <code>OrdinaryNodeDynamics</code>.</p><ul><li>the general signature of <code>rhs</code> is</li></ul><pre><code class="language-Julia">rhs(dint_dt::AbstractVector,
    u::Complex,
    i::Complex,
    int::AbstractVector,
    t,
    )::Complex</code></pre><ul><li>Input<ul><li><code>u</code> is the complex voltage <span>$u$</span></li><li><code>i</code> is the complex current <span>$i$</span></li><li><code>int</code> is the array of internal variables <span>$y_1, \dots, y_n$</span></li><li><code>t</code> is the time <span>$t$</span></li></ul></li><li>Output<ul><li>the (complex) return value describes <span>$\frac{du}{dt}$</span></li><li><code>rhs</code> writes values in <code>dint_dt</code> describing the left-hand side <span>$\frac{dy_1}{dt}, \dots, \frac{dy_n}{dt}$</span></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryNodeDynamicsWithMass" href="#PowerDynBase.OrdinaryNodeDynamicsWithMass"><code>PowerDynBase.OrdinaryNodeDynamicsWithMass</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">OrdinaryNodeDynamicsWithMass(;rhs, n_int, m_u, m_int)</code></pre><p>The type representing the dynamics of a node that is described via ODEs.</p><p>Each node <span>$a$</span> has the complex voltage <span>$u$</span> and <span>$n$</span> (<code>= n_int</code>) real internal variables <span>$y_1, \dots, y_n$</span>, so it generally describes a system of ordinary differential equation with a voltage mass <span>$m_u$</span> and internal masses <span>$m^{int}_1, \dots, m^{int}_n$</span> as</p><div>\[m_u\frac{du_a}{dt} = f_u(u_a, {i_c}_a, y_1, \dots, y_n) \\
m^{int}_k\frac{dy_{ak}}{dt} = f_k(u_a, {i_c}_a, y_1, \dots, y_n)\quad \forall k = 1, \dots, n.\]</div><p>As we assume that all masses are binary (either 1, or 0), that means, one can implement <a href="https://en.wikipedia.org/wiki/Differential-algebraic_system_of_equations">semi-explicit differential algebraic equations</a> with this node dynamics type. <span>$f$</span> is represented by <code>rhs</code> field of <code>OrdinaryNodeDynamics</code>.</p><ul><li>the general signature of <code>rhs</code> is</li></ul><pre><code class="language-Julia">rhs(dint_dt::AbstractVector,
    u::Complex,
    i::Complex,
    int::AbstractVector,
    t,
    )::Complex</code></pre><ul><li>Input<ul><li><code>u</code> is the complex voltage <span>$u$</span></li><li><code>i</code> is the complex current <span>$i$</span></li><li><code>int</code> is the array of internal variables <span>$y_1, \dots, y_n$</span></li><li><code>t</code> is the time <span>$t$</span></li></ul></li><li>Output<ul><li>the (complex) return value describes <span>$\frac{du}{dt}$</span></li><li><code>rhs</code> writes values in <code>dint_dt</code> describing the left-hand side <span>$\frac{dy_1}{dt}, \dots, \frac{dy_n}{dt}$</span></li></ul></li></ul><p>The binary masses are:</p><ul><li><code>m_u</code> is the boolean value for <span>$m_u$</span></li><li><code>m_int</code> is the array of boolean values for <span>$m^{int}_1, \dots, m^{int}_n$</span></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.PQAlgebraic" href="#PowerDynBase.PQAlgebraic"><code>PowerDynBase.PQAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PQAlgebraic(;S)</code></pre><p>A node type that locally fixes the active (<span>$P$</span>) and reactive power (<span>$Q$</span>) output of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>S = P + Q*im</code>: the complex power output</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PQAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = S_a - u_a \cdot i_a^*.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.PVAlgebraic" href="#PowerDynBase.PVAlgebraic"><code>PowerDynBase.PVAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PVAlgebraic(;P,V)</code></pre><p>A node type that locally fixes the active power (<span>$P$</span>) and the voltage magnitude (<span>$V$</span>) of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: the active (real) power output</li><li><code>V</code>: voltage magnitude</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PVAlgebraic</code> for node <span>$a$</span> applies the equations</p><div>\[0 = P_a - \Re\left(u_a \cdot i_a^*\right), \\
0 = V_a - \left\|u_a\right\|.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SlackAlgebraic" href="#PowerDynBase.SlackAlgebraic"><code>PowerDynBase.SlackAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SlackAlgebraic(;U)</code></pre><p>A node type that locally fixes the complex voltage (<span>$U$</span>) of the node.</p><p>As the complex voltage can be represented as <span>$U=Ve^{i\phi}$</span>, this is equivlant to fixing the voltage magnitude <span>$V$</span> and the angle <span>$\phi$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>U</code>: the complex voltage</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SlackAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = U_a - u_a.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.State" href="#PowerDynBase.State"><code>PowerDynBase.State</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">
    State(base; t=nothing)
    State(grid, vec; t=nothing)
</code></pre><p>Encode the information on the value of a state vector at a particular time point.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>base</code> is an instance of a <code>BaseState</code>, essentially it contains the state   vector and the complete rhs of the system. Instead of <code>base</code>, you can also   directly use a <a href="#PowerDynBase.GridDynamics"><code>GridDynamics</code></a> instance <code>grid</code> and a properly sized   state vector <code>vec</code> to instantiate a <code>State</code>.</li><li><code>t</code> is a time point associated to the <code>base</code>. It defaults to <code>nothing</code>.</li></ul><p><strong>Indexing</strong></p><p>Concerning the indexing, a <code>State</code> object <span>$s$</span> basically behaves like a an array. There are plenty of convenient ways to access its contents at a node <span>$j$</span> by using a particular symbol:</p><ul><li><code>s[j, :u]</code>: complex voltage</li><li><code>s[j, :v]</code>: voltage magnitude</li><li><code>s[j, :φ]</code>: voltage angle</li><li><code>s[j, :i]</code>: complex nodal current</li><li><code>s[j, :iabs]</code>: nodal current magnitude</li><li><code>s[j, :δ]</code>: nodal current angle</li><li><code>s[j, :s]</code>: apparent power</li><li><code>s[j, :p]</code>: real power</li><li><code>s[j, :q]</code>: reactive power</li></ul><p>Currently, setting the state value is only implemented for <span>$u$</span> and <span>$v$</span>, the other quantities are derived automatically.</p><p>When a node <span>$j$</span> has internal variables, you can access (and set) the <span>$k$</span>-th internal variable by calling</p><p><code>s[j, :int, k]</code>.</p><p>The internal variables can be also directly accessed with symbols, i.e.</p><p><code>s[j, :ω]</code></p><p>returns the frequency <span>$ω$</span> at node <span>$j$</span>. To find out the proper symbol, the easiest way is to look into the docs of the corresponding <a href="#PowerDynBase.AbstractNodeParameters"><code>AbstractNodeParameters</code></a> subtype, check the output of <a href="#PowerDynBase.internalsymbolsof-Tuple{PowerDynBase.ODENodeSymbols}"><code>internalsymbolsof</code></a> or simply look at the output of <code>println</code>:</p><pre><code class="language-none">julia&gt; internalsymbolsof(SwingEq(H=2, P=3, D=4, Ω=5))
1-element Array{Symbol,1}:
 :ω

julia&gt; println(SwingEq(H=2, P=3, D=4, Ω=5))
SwingEq[:ω](H=2, P=3, D=4, Ω=5)</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.StateError" href="#PowerDynBase.StateError"><code>PowerDynBase.StateError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Error to be thrown if something goes wrong when creating or modifying states.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SwingEq" href="#PowerDynBase.SwingEq"><code>PowerDynBase.SwingEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEq(;H, P, D, Ω)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a  \omega_a, \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega, \\
v = v(t=0) = \text{const.} \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SwingEqLVS" href="#PowerDynBase.SwingEqLVS"><code>PowerDynBase.SwingEqLVS</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEqLVS(;H, P, D, Ω, Γ, V)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>Γ</code>: voltage stability coefficient</li><li><code>V</code>: set voltage, usually <code>1</code></li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a \omega - \frac{u}{\|u\|} Γ_a  (v_a - V_a), \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega_a, \\
\frac{dv_a}{dt} = - Γ_a  (v_a - V_a) \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.VSIMinimal" href="#PowerDynBase.VSIMinimal"><code>PowerDynBase.VSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIMinimal</code> for node <span>$a$</span> applies the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
\tau_Q\dot{v}_a=-v_a+V_{ref}-K_{Q,a} (\Im\left(u_a \cdot i_a^*\right)-Q_{ref,a})\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\]</div><p>```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.VSIVoltagePT1" href="#PowerDynBase.VSIVoltagePT1"><code>PowerDynBase.VSIVoltagePT1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_v</code>: time constant voltage control delay</li><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIVoltagePT1</code> for node <span>$a$</span> applies the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
 \tau_v\dot{v}_{a}=-v_a+V_{ref}-K_{Q,a}(q_{m,a}-Q_{ref,a})\\
 \tau_Q \dot{q}_{m,a}=-q_{m,a}+\Im\left(u_a \cdot i_a^*\right)\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\\\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{OrdinaryNodeDynamicsWithMass},OrdinaryNodeDynamics}" href="#Base.convert-Tuple{Type{OrdinaryNodeDynamicsWithMass},OrdinaryNodeDynamics}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(::Type{OrdinaryNodeDynamicsWithMass}, ::OrdinaryNodeDynamics)</code></pre><p>Conversion of <code>OrdinaryNodeDynamics</code> to <code>OrdinaryNodeDynamicsWithMass</code> by assuming all masses are 1 (<code>true</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{PowerDynBase.AlgebraicNodeDynamics},OrdinaryNodeDynamicsWithMass}" href="#Base.convert-Tuple{Type{PowerDynBase.AlgebraicNodeDynamics},OrdinaryNodeDynamicsWithMass}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(::Type{AlgebraicNodeDynamics}, ::OrdinaryNodeDynamicsWithMass)</code></pre><p>Conversion of <code>OrdinaryNodeDynamicsWithMass</code> to <code>AlgebraicNodeDynamics</code> by transforming a RHS function into a root function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{PowerDynBase.AlgebraicNodeDynamics},OrdinaryNodeDynamics}" href="#Base.convert-Tuple{Type{PowerDynBase.AlgebraicNodeDynamics},OrdinaryNodeDynamics}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(::Type{AlgebraicNodeDynamics}, ::OrdinaryNodeDynamics)</code></pre><p>Conversion of <code>OrdinaryNodeDynamics</code> to <code>AlgebraicNodeDynamics</code> by going via <code>OrdinaryNodeDynamicsWithMass</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_rule-Tuple{Type{#s20489} where #s20489&lt;:OrdinaryNodeDynamics,Type{#s20488} where #s20488&lt;:OrdinaryNodeDynamicsWithMass}" href="#Base.promote_rule-Tuple{Type{#s20489} where #s20489&lt;:OrdinaryNodeDynamics,Type{#s20488} where #s20488&lt;:OrdinaryNodeDynamicsWithMass}"><code>Base.promote_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">promote_rule(::Type{OrdinaryNodeDynamics}, ::Type{OrdinaryNodeDynamicsWithMass}) = OrdinaryNodeDynamicsWithMass</code></pre><p><code>OrdinaryNodeDynamics</code> can be promoted to <code>OrdinaryNodeDynamicsWithMass</code>, see <a href="#Base.convert-Tuple{Type{OrdinaryNodeDynamicsWithMass},OrdinaryNodeDynamics}"><code>PowerDynBase.convert</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_rule-Tuple{Type{OrdinaryNodeDynamicsWithMass},Type{PowerDynBase.AlgebraicNodeDynamics}}" href="#Base.promote_rule-Tuple{Type{OrdinaryNodeDynamicsWithMass},Type{PowerDynBase.AlgebraicNodeDynamics}}"><code>Base.promote_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">promote_rule(::Type{OrdinaryNodeDynamicsWithMass}, ::Type{AlgebraicNodeDynamics}) = AlgebraicNodeDynamics</code></pre><p><code>OrdinaryNodeDynamicsWithMass</code> can be promoted to <code>AlgebraicNodeDynamics</code>, see <a href="#Base.convert-Tuple{Type{OrdinaryNodeDynamicsWithMass},OrdinaryNodeDynamics}"><code>PowerDynBase.convert</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_rule-Tuple{Type{OrdinaryNodeDynamics},Type{PowerDynBase.AlgebraicNodeDynamics}}" href="#Base.promote_rule-Tuple{Type{OrdinaryNodeDynamics},Type{PowerDynBase.AlgebraicNodeDynamics}}"><code>Base.promote_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">promote_rule(::Type{OrdinaryNodeDynamics}, ::Type{AlgebraicNodeDynamics}) = AlgebraicNodeDynamics</code></pre><p><code>OrdinaryNodeDynamics</code> can be promoted to <code>AlgebraicNodeDynamics</code>, see <a href="#Base.convert-Tuple{Type{OrdinaryNodeDynamicsWithMass},OrdinaryNodeDynamics}"><code>PowerDynBase.convert</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AdmittanceLaplacian-Tuple{Any}" href="#PowerDynBase.AdmittanceLaplacian-Tuple{Any}"><code>PowerDynBase.AdmittanceLaplacian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AdmittanceLaplacian(x)</code></pre><p>Return the nodal admittance matrix of the system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.Nodes-Tuple{Any}" href="#PowerDynBase.Nodes-Tuple{Any}"><code>PowerDynBase.Nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Nodes(x)</code></pre><p>Return the array of nodes for <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SystemSize-Tuple{Any}" href="#PowerDynBase.SystemSize-Tuple{Any}"><code>PowerDynBase.SystemSize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SystemSize(x)</code></pre><p>Return the full system size, i.e. number of independent, dynamic, real-valued variables, for <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.differentials-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractAlgebraicNodeDynamics}" href="#PowerDynBase.differentials-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractAlgebraicNodeDynamics}"><code>PowerDynBase.differentials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Collect the differnetials (or masses) for the whole grid dynamics from each node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.internaldsymbolsof-Tuple{PowerDynBase.ODENodeSymbols}" href="#PowerDynBase.internaldsymbolsof-Tuple{PowerDynBase.ODENodeSymbols}"><code>PowerDynBase.internaldsymbolsof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the symbols representing the derivative of the internal variables of the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.internaloutsymbolsof-Tuple{PowerDynBase.DAENodeSymbols}" href="#PowerDynBase.internaloutsymbolsof-Tuple{PowerDynBase.DAENodeSymbols}"><code>PowerDynBase.internaloutsymbolsof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the symbols representing the output of the internal variables of the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.internalsymbolsof-Tuple{PowerDynBase.ODENodeSymbols}" href="#PowerDynBase.internalsymbolsof-Tuple{PowerDynBase.ODENodeSymbols}"><code>PowerDynBase.internalsymbolsof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the symbols representing the internal variables of the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.parametersof-Tuple{OrdinaryNodeDynamics}" href="#PowerDynBase.parametersof-Tuple{OrdinaryNodeDynamics}"><code>PowerDynBase.parametersof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the parameters struct for the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.showdefinition-Tuple{Any}" href="#PowerDynBase.showdefinition-Tuple{Any}"><code>PowerDynBase.showdefinition</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Show the definition generated by a macro of PowerDynamics.jl, e.g. the macro <a href="#PowerDynBase.@DynamicNode-NTuple{4,Any}"><code>PowerDynBase.@DynamicNode</code></a> creating a subtype of <a href="#PowerDynBase.AbstractNodeParameters"><code>PowerDynBase.AbstractNodeParameters</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.@DynamicNode-NTuple{4,Any}" href="#PowerDynBase.@DynamicNode-NTuple{4,Any}"><code>PowerDynBase.@DynamicNode</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Macro for creating a new type of dynmic nodes.</p><p>Syntax Description:</p><pre><code class="language-Julia">@DynamicNode MyNewNodeName(Par1, Par2, ...) &lt;: NodeDynamicsType(N1, N2, ...) begin
    [all prepratory things that need to be run just once]
end [[x1, dx1], [x2, dx2]] begin
    [the actual dynamics equation]
    [important to set the output variables]
end</code></pre><p>where <code>MyNewNodeName</code> is the name of the new type of dynamic node, <code>Par1, Par2, ...</code> are the names of the parameters, <code>NodeDynamicsType</code> the the node dynamics type (e.g. <code>OrdinaryNodeDynamics</code> or <code>OrdinaryNodeDynamicsWithMass</code>), <code>N1, N1, ...</code> the parameters of the dynamics type, <code>x1, x2, ...</code> the internal variables of the node and <code>dx1, dx2, ...</code> the corresponding differentials.</p><p>In the first block, the preparation code that needs to be run only once is inserted. Finally, the second block contains the dynamics description, where it&#39;s important that the output variables need to be set. In case of <code>OrdinaryNodeDynamics</code> and <code>OrdinaryNodeDynamicsWithMass</code>, these are <code>du</code> and the differentials of the internal variables (here <code>dx1, dx2</code>).</p><p>Below are two examples:</p><pre><code class="language-Julia">@DynamicNode SwingEqParameters(H, P, D, Ω) &lt;: OrdinaryNodeDynamics() begin
    @assert D &gt; 0 &quot;damping (D) should be &gt;0&quot;
    @assert H &gt; 0 &quot;inertia (H) should be &gt;0&quot;
    Ω_H = Ω * 2pi / H
end [[ω, dω]] begin
    p = real(u * conj(i_c))
    dϕ = ω # dϕ is only a temp variable that Julia should optimize out
    du = u * im * dϕ
    dω = (P - D*ω - p)*Ω_H
end</code></pre><pre><code class="language-Julia">@DynamicNode SlackAlgebraicParameters(U) &lt;: OrdinaryNodeDynamicsWithMass(m_u=false, m_int=no_internal_masses) begin
end [] begin
        du = u - U
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractAlgebraicGridDynamics" href="#PowerDynBase.AbstractAlgebraicGridDynamics"><code>PowerDynBase.AbstractAlgebraicGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all grid dynamics represented by DAEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractAlgebraicNodeDynamics" href="#PowerDynBase.AbstractAlgebraicNodeDynamics"><code>PowerDynBase.AbstractAlgebraicNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node dynamics represented by DAEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractDAEVariable" href="#PowerDynBase.AbstractDAEVariable"><code>PowerDynBase.AbstractDAEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all Variables for DAE-type node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractDEVariable" href="#PowerDynBase.AbstractDEVariable"><code>PowerDynBase.AbstractDEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AbstractDEVariable end</code></pre><p>Abstract super type for all variables that <a href="#PowerDynBase.AbstractNetworkFunction"><code>PowerDynBase.AbstractNetworkFunction</code></a> sub-types can be called with.</p><p>DEVariable stands for Differential Equation Variable.</p><p>The basic idea of a DEVariable is to combine (the arrays of) all necessary variables for a sub-type of <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a>. E.g. for a <a href="#PowerDynBase.OrdinaryGridDynamics"><code>PowerDynBase.OrdinaryGridDynamics</code></a> one needs only the state variable (here called <code>val</code> for value) and the derivative (here called <code>ddt</code>). Hence, the definition for the corresponding <a href="#PowerDynBase.ODEVariable"><code>PowerDynBase.ODEVariable</code></a> is:</p><pre><code class="language-none">@DEVariable struct ODEVariable{Tval, Tddt} &lt;: AbstractODEVariable
    val::AbstractVector{Tval}
    ddt::AbstractVector{Tddt}
end ddt</code></pre><p>The final <code>ddt</code> statement is part of the <a href="#PowerDynBase.@DEVariable-Tuple{Any,Any}"><code>PowerDynBase.@DEVariable</code></a> macro stating that the output variable of this kind of DEVariable is <code>ddt</code>. Further, the <a href="#PowerDynBase.@DEVariable-Tuple{Any,Any}"><code>PowerDynBase.@DEVariable</code></a> macro generates all the necessary constructors. Check its docs for more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNetworkFunction" href="#PowerDynBase.AbstractNetworkFunction"><code>PowerDynBase.AbstractNetworkFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AbstractNetworkFunction{T&lt;:AbstractNodeDynamics, M&lt;:AbstractMatrix} end</code></pre><p>Abstract super type of all functions that define how a differential equation for the whole network / power grid behaves, e.g. the full right-hand-side function of the ODE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNodeDynamics" href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all abstract node dynamics types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractODEVariable" href="#PowerDynBase.AbstractODEVariable"><code>PowerDynBase.AbstractODEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all Variables for ODE-type node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractOrdinaryGridDynamics" href="#PowerDynBase.AbstractOrdinaryGridDynamics"><code>PowerDynBase.AbstractOrdinaryGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all grid dynamics represented by ODEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractOrdinaryNodeDynamics" href="#PowerDynBase.AbstractOrdinaryNodeDynamics"><code>PowerDynBase.AbstractOrdinaryNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node dynamics represented by ODEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AlgebraicGridDynamics" href="#PowerDynBase.AlgebraicGridDynamics"><code>PowerDynBase.AlgebraicGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct AlgebraicGridDynamics &lt;: AbstractAlgebraicGridDynamics
    rhs::NetworkRHS
    differentials::AbstractVector{Bool} # boolean values whether there a variable is a differential
end</code></pre><p>The data structure that contains all the information necessary for a power grid model that can be described as an differential algebraic equation. <code>rhs</code> is the <a href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a>. <code>differentials</code> is a 1-dimensional array of boolean values. A <code>true</code> entry means the corresponding variable is dynamic and has a derivative variable. A <code>false</code> entry means the corresponding variable is defined by an algebraic constraint only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AlgebraicNodeDynamics" href="#PowerDynBase.AlgebraicNodeDynamics"><code>PowerDynBase.AlgebraicNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DOCS TBD!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.BaseState" href="#PowerDynBase.BaseState"><code>PowerDynBase.BaseState</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">
    BaseState(grid, vec)
</code></pre><p>Encode a state vector and the corresponding rhs information.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>grid</code> is a <a href="#PowerDynBase.GridDynamics"><code>GridDynamics</code></a> instance that contains the overall system rhs.</li><li><code>vec</code> is a state vector of the system who&#39;s length is given by the total       number of internal and voltage variables.</li></ul><p><strong>Indexing</strong></p><p>In an instance <code>b</code> of of a <code>BaseState</code> behaves like an array, i.e. you can access the <span>$j$</span>-th element of the state vector (and set it to a value <span>$ξ$</span>) by calling <code>b[j] ( = ξ )</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.DAEVariable" href="#PowerDynBase.DAEVariable"><code>PowerDynBase.DAEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Variables for DAE-type node dynamics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.ODEVariable" href="#PowerDynBase.ODEVariable"><code>PowerDynBase.ODEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Variables for ODE-type node dynamics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryGridDynamics" href="#PowerDynBase.OrdinaryGridDynamics"><code>PowerDynBase.OrdinaryGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct OrdinaryGridDynamics &lt;: AbstractOrdinaryGridDynamics
    rhs::NetworkRHS
end</code></pre><p>The data structure that contains all the information necessary for a power grid model that can be described as an ordinary differential equation. In this case, only the <a href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a> is necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryGridDynamicsWithMass" href="#PowerDynBase.OrdinaryGridDynamicsWithMass"><code>PowerDynBase.OrdinaryGridDynamicsWithMass</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct OrdinaryGridDynamicsWithMass &lt;: AbstractAlgebraicGridDynamics
    rhs::NetworkRHS
    masses::AbstractVector{Bool} # diagonal part of the mass matrix, off-diagonal is assumed to be 0 anyway
end</code></pre><p>The data structure that contains all the information necessary for a power grid model that can be described as an ordinary differential equation with masses, i.e. a semi-explicit differential algebraic equation. <code>rhs</code> is the <a href="#PowerDynBase.NetworkRHS"><code>PowerDynBase.NetworkRHS</code></a>. <code>masses</code> is a 1-dimensional array representing the diagonal entries of the mass matrix. The off-diagonal entries are assumed to be 0. <code>masses</code> can only contain boolean values representing: <code>true</code> the equation is treated as a ordinary differential eqation and <code>false</code> the equation is treated as an algebraic constraint on the state variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.PowerDynamicsError" href="#PowerDynBase.PowerDynamicsError"><code>PowerDynBase.PowerDynamicsError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type of all PowerDynamics.jl Errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.view-Tuple{PowerDynBase.AbstractDEVariable,Any}" href="#Base.view-Tuple{PowerDynBase.AbstractDEVariable,Any}"><code>Base.view</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extend view from arrays to subtypes of <a href="#PowerDynBase.AbstractDEVariable"><code>AbstractDEVariable</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.DynamicNode-NTuple{4,Any}" href="#PowerDynBase.DynamicNode-NTuple{4,Any}"><code>PowerDynBase.DynamicNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>See <a href="#PowerDynBase.@DynamicNode-NTuple{4,Any}"><code>PowerDynBase.@DynamicNode</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase._GridDynamics-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:OrdinaryNodeDynamics,AbstractArray{T,2} where T}" href="#PowerDynBase._GridDynamics-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:OrdinaryNodeDynamics,AbstractArray{T,2} where T}"><code>PowerDynBase._GridDynamics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create for each subtype of <a href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> the corresponding subtype of <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.checkLY-Tuple{AbstractArray{T,2} where T}" href="#PowerDynBase.checkLY-Tuple{AbstractArray{T,2} where T}"><code>PowerDynBase.checkLY</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Check whether the admittance laplacian has no purely nodal admittances, i.e. that the sum of columns and rows equals to zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.complexview-Tuple{PowerDynBase.AbstractDEVariable,Any,Any}" href="#PowerDynBase.complexview-Tuple{PowerDynBase.AbstractDEVariable,Any,Any}"><code>PowerDynBase.complexview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extend <a href="#PowerDynBase.complexview-Tuple{PowerDynBase.AbstractDEVariable,Any,Any}"><code>PowerDynBase.complexview</code></a> from arrays to subtypes of <a href="#PowerDynBase.AbstractDEVariable"><code>AbstractDEVariable</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.complexview-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any,Any}} where T" href="#PowerDynBase.complexview-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any,Any}} where T"><code>PowerDynBase.complexview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">complexview(vec::AbstractArray, i0, n)</code></pre><p>Interpret (part of) an array of real values as an array with complex values. <code>i0</code> is the index where to start. <code>n</code> is the number of complex values that should be extracted.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.create_DEVariable-Tuple{Any,Symbol}" href="#PowerDynBase.create_DEVariable-Tuple{Any,Symbol}"><code>PowerDynBase.create_DEVariable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Basically, this macro generates all the constructors (internal and external) for a subtype of AbstracDEVariable.</p><p>If you want to understand what this macro does, call <a href="#PowerDynBase.showdefinition-Tuple{Any}"><code>PowerDynBase.showdefinition</code></a> with a type that was generated by this macro, e.g. <code>showdefinition(ODEVariable)</code>. It will output the full defintion that the macro actually creates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.excomparison-Tuple{Any}" href="#PowerDynBase.excomparison-Tuple{Any}"><code>PowerDynBase.excomparison</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create an expresseion where <code>==</code> is applied between all the expressions given as argument here.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.getDEVariableType-Tuple{Type{Val{OrdinaryNodeDynamics}}}" href="#PowerDynBase.getDEVariableType-Tuple{Type{Val{OrdinaryNodeDynamics}}}"><code>PowerDynBase.getDEVariableType</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Identify each subtype of <a href="#PowerDynBase.AbstractNodeDynamics"><code>AbstractNodeDynamics</code></a> with its corresponding subtype of <a href="#PowerDynBase.AbstractDEVariable"><code>AbstractDEVariable</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.int_differentials-Tuple{PowerDynBase.AbstractAlgebraicNodeDynamics,Vararg{PowerDynBase.AbstractAlgebraicNodeDynamics,N} where N}" href="#PowerDynBase.int_differentials-Tuple{PowerDynBase.AbstractAlgebraicNodeDynamics,Vararg{PowerDynBase.AbstractAlgebraicNodeDynamics,N} where N}"><code>PowerDynBase.int_differentials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the 1-dimensional differentials array (see <a href="#PowerDynBase.AlgebraicGridDynamics"><code>PowerDynBase.AlgebraicGridDynamics</code></a>) for the internal variables for each node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.internal_unitranges-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.internal_unitranges-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.internal_unitranges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the unit ranges that indicate where in the array the internal variables for each of the nodes is saved.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.mapfields-Tuple{Any,Any,Vararg{Any,N} where N}" href="#PowerDynBase.mapfields-Tuple{Any,Any,Vararg{Any,N} where N}"><code>PowerDynBase.mapfields</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function mapfields(f, s, args...)</code></pre><p>Applies <code>f</code> to all fields of (the struct) <code>s</code> giving <code>args...</code> as additional arguments.</p><p>It&#39;s written as a <code>@generated</code> function in order to ensure that the compiler can infer the types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.nint-Tuple{OrdinaryNodeDynamics}" href="#PowerDynBase.nint-Tuple{OrdinaryNodeDynamics}"><code>PowerDynBase.nint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get number of internal arguments of the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.nodeiterator-Tuple{NetworkRHS,PowerDynBase.AbstractDEVariable,Any}" href="#PowerDynBase.nodeiterator-Tuple{NetworkRHS,PowerDynBase.AbstractDEVariable,Any}"><code>PowerDynBase.nodeiterator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nodeiterator(rhs::NetworkRHS, x::AbstractDEVariable, t)</code></pre><p>Distribute the values in <code>x</code> over all the nodes that are summarized in <code>rhs</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.rhs2root-Tuple{Function}" href="#PowerDynBase.rhs2root-Tuple{Function}"><code>PowerDynBase.rhs2root</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A function converting a rhs-type function to a root-type function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.symbolsof-Tuple{OrdinaryNodeDynamics}" href="#PowerDynBase.symbolsof-Tuple{OrdinaryNodeDynamics}"><code>PowerDynBase.symbolsof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the symbols data structure for the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.total_nint-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.total_nint-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.total_nint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the total number of internal variables for an array of node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.total_nvars-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.total_nvars-Tuple{AbstractArray{#s20490,1} where #s20490&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.total_nvars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the total number of dynamic variables for an array of node dynamics.</p><p>This is basically the (real) dimension of the system, hence the sum of internal dynamic variables + 2*(number of nodes = number of complex voltages). The 2 is due to the fact that the complex voltages are treated as two real variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.u_differentials-Tuple{PowerDynBase.AbstractAlgebraicNodeDynamics,Vararg{PowerDynBase.AbstractAlgebraicNodeDynamics,N} where N}" href="#PowerDynBase.u_differentials-Tuple{PowerDynBase.AbstractAlgebraicNodeDynamics,Vararg{PowerDynBase.AbstractAlgebraicNodeDynamics,N} where N}"><code>PowerDynBase.u_differentials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the 1-dimensional differentials array (see <a href="#PowerDynBase.AlgebraicGridDynamics"><code>PowerDynBase.AlgebraicGridDynamics</code></a>) for the voltagee variables for each node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.@DEVariable-Tuple{Any,Any}" href="#PowerDynBase.@DEVariable-Tuple{Any,Any}"><code>PowerDynBase.@DEVariable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@DEVariable struct DEVariableName{Type1, Type2, ...} &lt;: AbstractODEVariable
    ...
end outputVariableName</code></pre><p>Basically, this macro generates all the constructors (internal and external) for a subtype of AbstracDEVariable. In particular, it creates an external constructor that automatically chooses the type for the <code>outputVariableName</code> and instantiates this variable.</p><p>If you want to understand what this macro does, call <a href="#PowerDynBase.showdefinition-Tuple{Any}"><code>PowerDynBase.showdefinition</code></a> with a type that was generated by this macro, e.g. <code>showdefinition(ODEVariable)</code>. It will output the full defintion that the macro actually creates.</p><p>Furthermore, the macro is just the interface for the <a href="#PowerDynBase.create_DEVariable-Tuple{Any,Symbol}"><code>PowerDynBase.create_DEVariable</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridProblem" href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct GridProblem{P&lt;:DEProblem, S&lt;:AbstractState, T&lt;:AbstractFloat} # T is for the timespan
    prob::P
    start::S
    timespan::Tuple{T, T}
end</code></pre><p>Define an analogous problem to DifferentialEquations.jl&#39;s <code>DEProblem</code> subtypes. In the future, this is planned to be replaced by a real <code>DEProblem</code> subtype.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridProblem-Tuple{GridDynamics,AbstractArray{T,1} where T,Any}" href="#PowerDynSolve.GridProblem-Tuple{GridDynamics,AbstractArray{T,1} where T,Any}"><code>PowerDynSolve.GridProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridProblem(g::GridDynamics, start::AbstractVector, timespan; kwargs...)</code></pre><p>Construct a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a> from a an initial condition <code>start</code> for the grid dynamics <code>g</code> which is a subtype of <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{AbstractState{OrdinaryGridDynamics,V,T},Any}} where T where V" href="#PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{AbstractState{OrdinaryGridDynamics,V,T},Any}} where T where V"><code>PowerDynSolve.GridProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridProblem(start::AbstractState{OrdinaryGridDynamics, V, T}, timespan; kwargs...) where {V,T}</code></pre><p>Construct a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a> from a an initial condition (i.e. a <a href="#PowerDynBase.State"><code>PowerDynBase.State</code></a>) for an <a href="#PowerDynBase.OrdinaryGridDynamics"><code>PowerDynBase.OrdinaryGridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{AbstractState{OrdinaryGridDynamicsWithMass,V,T},Any}} where T where V" href="#PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{AbstractState{OrdinaryGridDynamicsWithMass,V,T},Any}} where T where V"><code>PowerDynSolve.GridProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridProblem(start::AbstractState{OrdinaryGridDynamicsWithMass, V, T}, timespan; kwargs...) where {V,T}</code></pre><p>Construct a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a> from a an initial condition (i.e. a <a href="#PowerDynBase.State"><code>PowerDynBase.State</code></a>) for an <a href="#PowerDynBase.OrdinaryGridDynamicsWithMass"><code>PowerDynBase.OrdinaryGridDynamicsWithMass</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{G}, Tuple{G,AbstractState{G,V,T},Any}} where T where V where G" href="#PowerDynSolve.GridProblem-Union{Tuple{T}, Tuple{V}, Tuple{G}, Tuple{G,AbstractState{G,V,T},Any}} where T where V where G"><code>PowerDynSolve.GridProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function GridProblem(g::G, start::AbstractState{G, V, T}, timespan; kwargs...) where {G, V, T}</code></pre><p>Construct a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a> from a an initial condition <code>start</code> (i.e. a <a href="#PowerDynBase.State"><code>PowerDynBase.State</code></a>) with the corresponding subtype of <a href="#PowerDynBase.GridDynamics"><code>PowerDynBase.GridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.solve-Tuple{GridDynamics,Any,Any}" href="#DiffEqBase.solve-Tuple{GridDynamics,Any,Any}"><code>DiffEqBase.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function solve(g::GridDynamics, x0, timespan)</code></pre><p>Solve a power grid <code>g</code> (of type <a href="#PowerDynBase.GridDynamics"><code>PowerDynSolve.GridDynamics</code></a>) starting at <code>x0</code> for a <code>timespan</code>, using DifferentialEquations.jl in the back. The correct solvers are automatically chosen.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.solve-Union{Tuple{GridProblem{P,#s20487,Q} where #s20487&lt;:AbstractState{OrdinaryGridDynamics,V,T}}, Tuple{Q}, Tuple{T}, Tuple{V}, Tuple{P}} where Q where T where V where P" href="#DiffEqBase.solve-Union{Tuple{GridProblem{P,#s20487,Q} where #s20487&lt;:AbstractState{OrdinaryGridDynamics,V,T}}, Tuple{Q}, Tuple{T}, Tuple{V}, Tuple{P}} where Q where T where V where P"><code>DiffEqBase.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function solve(p::GridProblem; kwargs...)</code></pre><p>Solve a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a>, using DifferentialEquations.jl in the back. The correct solvers are automatically chosen.</p><p><code>kwargs</code> are the keyword arguments that are simply passed to DifferentialEquations.jl.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.AbstractGridSolution" href="#PowerDynSolve.AbstractGridSolution"><code>PowerDynSolve.AbstractGridSolution</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all data structures representing solutions of power grid models.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridSolution" href="#PowerDynSolve.GridSolution"><code>PowerDynSolve.GridSolution</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct GridSolution &lt;: AbstractGridSolution
    dqsol::AbstractTimeseriesSolution
    griddynamics::GridDynamics
end</code></pre><p>The data structure interfacing to the solution of the differntial equations of a power grid. Normally, it is not created by hand but return from <code>PowerDynSolve.solve</code>.</p><p><strong>Accessing the solution in a similar interface as <a href="#PowerDynBase.State"><code>PowerDynBase.State</code></a>.</strong></p><p>For some grid solution <code>sol</code>, one can access the variables as</p><pre><code class="language-julia">sol(t, n, s)</code></pre><p>where <code>t</code> is the time (either float or array), <code>n</code> the node number(s) (either integer, array, range (e.g. 2:3) or colon (:, for all nodes)), and <code>s</code> is the symbol represnting the chosen value. <code>s</code> can be either: <code>:v</code>, <code>:φ</code>, <code>:i</code>, <code>:iabs</code>, <code>:δ</code>, <code>:s</code>, <code>:p</code>, <code>:q</code>, or the symbol of the internal variable of the nodes. The meaning of the symbols derives from the conventions of PowerDynamics.jl.</p><p>Finally, one can access the <code>a</code>-th internal variable of a node by using <code>sol(t, n, :int, a)</code>.</p><p><strong>Interfacing the Plots.jl library via plotting recipes, that follow similar instructions as the direct access to the solution.</strong></p><p>For some grid solution <code>sol</code>, one plot variables of the solution asin</p><pre><code class="language-julia">using Plots
plot(sol, n, s, plots_kwargs...)</code></pre><p>where <code>n</code> and <code>s</code> are as in the accessing of plots, and <code>plots_kwargs</code> are the keyword arguments for Plots.jl.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.GridSolutionError" href="#PowerDynSolve.GridSolutionError"><code>PowerDynSolve.GridSolutionError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Error to be thrown if something goes wrong during when solving a power grid model.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.tslabel-Tuple{Any,Any}" href="#PowerDynSolve.tslabel-Tuple{Any,Any}"><code>PowerDynSolve.tslabel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create the standard variable labels for power grid plots.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynSolve.tstransform-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T" href="#PowerDynSolve.tstransform-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T"><code>PowerDynSolve.tstransform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Transform the array output from DifferentialEquations.jl correctly to be used in Plots.jl&#39;s recipes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.solve" href="#DiffEqBase.solve"><code>DiffEqBase.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function solve(p::GridProblem; kwargs...)</code></pre><p>Solve a <a href="#PowerDynSolve.GridProblem"><code>PowerDynSolve.GridProblem</code></a>, using DifferentialEquations.jl in the back. The correct solvers are automatically chosen.</p><p><code>kwargs</code> are the keyword arguments that are simply passed to DifferentialEquations.jl.</p></div></div><div><div><pre><code class="language-none">function solve(g::GridDynamics, x0, timespan)</code></pre><p>Solve a power grid <code>g</code> (of type <a href="#PowerDynBase.GridDynamics"><code>PowerDynSolve.GridDynamics</code></a>) starting at <code>x0</code> for a <code>timespan</code>, using DifferentialEquations.jl in the back. The correct solvers are automatically chosen.</p></div></div></section><footer><hr/></footer></article></body></html>
