<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CausalityToolsBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CausalityToolsBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.ApproximateIntersection" href="#CausalityToolsBase.ApproximateIntersection"><code>CausalityToolsBase.ApproximateIntersection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ApproximateIntersection</code></pre><p>A type indicating that simplex intersections should be computed exactly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.BinningScheme" href="#CausalityToolsBase.BinningScheme"><code>CausalityToolsBase.BinningScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BinningScheme</code></pre><p>The supertype of all binning schemes in the CausalityTools ecosystem. </p></div></div></section><pre><code class="language-none">CausalityToolsBase.CausalityToolsBase</code></pre><pre><code class="language-none">CausalityToolsBase.CustomReconstruction</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.ExactIntersection" href="#CausalityToolsBase.ExactIntersection"><code>CausalityToolsBase.ExactIntersection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ExactIntersection</code></pre><p>A type indicating that simplex intersections should be computed exactly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.Lags" href="#CausalityToolsBase.Lags"><code>CausalityToolsBase.Lags</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Lags</code></pre><p>Wrapper type for lags used when performing custom state space reconstructions. Used in combination with <code>Positions</code> to specify how a <code>CustomReconstruction</code> should be constructed.</p><p><strong>Examples</strong></p><ul><li><code>Lags(2, 0, -3, 1)</code> indicates a 4-dimensional state space reconstruction where    the first variable has a positive lag of 2,    the second variable is not lagged,    the third variable has a lag of -3,    and the fourth variable has a positive lag of 1. </li><li><code>Lags(0, 0)</code> indicates a 2-dimensional state space reconstruction where both    variables are not lagged.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.Positions" href="#CausalityToolsBase.Positions"><code>CausalityToolsBase.Positions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Positions</code></pre><p>Wrapper type for the positions the different dynamical variables appear in when  constructing a custom state space reconstruction. Used in combination with <code>Lags</code> to specify how a <code>CustomReconstruction</code> should be constructed. Each  of the positions must refer to a dynamical variable (column) actually present in the  dataset.</p><p><strong>Examples</strong></p><ul><li><p><code>Positions(1, 2, 1, 5)</code> indicates a 4-dimensional state space reconstruction where </p><ol><li>the 1st coordinate axis of the reconstruction should be formed from the </li></ol><p>first variable/column of the input data.</p><ol><li>the 2nd coordinate axis of the reconstruction should be formed from the </li></ol><p>2nd variable/column of the input data.</p><ol><li>the 3rd coordinate axis of the reconstruction should be formed from the </li></ol><p>1st variable/column of the input data.</p><ol><li>the 4th coordinate axis of the reconstruction should be formed from the </li></ol><p>5th variable/column of the input data.</p></li><li><p><code>Positions(-1, 2)</code> indicates a 2-dimensional reconstruction, but will not work, because    each position must refer to the index of a dynamical variable (column) of a dataset    (indexed from 1 and up).</p></li></ul></div></div></section><pre><code class="language-none">CausalityToolsBase.ReconstructionParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.RectangularBinning" href="#CausalityToolsBase.RectangularBinning"><code>CausalityToolsBase.RectangularBinning</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RectangularBinningScheme</code></pre><p>Instructions for creating a rectangular box partition.</p><p><strong>Fields</strong></p><ul><li><p><strong><code>ϵ::Union{Int, Float64, Vector{Int}, Vector{Float64}}</code></strong>: The instructions for deciding    the edge lengths of the rectangular boxes. The following <code>ϵ</code> are valid:</p><pre><code class="language-none">  1. `ϵ::Int` divides each axis into `ϵ` intervals of the same size.

  2. `ϵ::Float` divides each axis into intervals of size `ϵ`.

  3. `ϵ::Vector{Int}` divides the i-th axis into `ϵᵢ` intervals of the same size.
  
  4. `ϵ::Vector{Float64}` divides the i-th axis into intervals of size `ϵᵢ`.</code></pre></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.RectangularBinningScheme" href="#CausalityToolsBase.RectangularBinningScheme"><code>CausalityToolsBase.RectangularBinningScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RectangularBinningScheme</code></pre><p>The supertype of all rectangular binning schemes in the CausalityTools ecosystem.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.RefinedTriangulationBinningMaxRadius" href="#CausalityToolsBase.RefinedTriangulationBinningMaxRadius"><code>CausalityToolsBase.RefinedTriangulationBinningMaxRadius</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RefinedTriangulationBinningMaxRadius</code></pre><p>A binning scheme for a triangulated simplex partition where some simplices have been  refined (subdivided by a shape-preserving simplex subdivision algorithm).</p><p>The maximum radius bound is applied by first doing an initial triangulation, the  splitting simplices whose radius is large until all simplices have radii less than  the resulting radius bound.</p><p><strong>Fields</strong></p><ul><li><strong><code>max_radius_frac::Float64</code></strong>: The maximum radius expressed as a fraction of the </li></ul><p>radius of the largest simplex of the initial triangulation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.RefinedTriangulationBinningSplitFactor" href="#CausalityToolsBase.RefinedTriangulationBinningSplitFactor"><code>CausalityToolsBase.RefinedTriangulationBinningSplitFactor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RefinedTriangulationBinningSplitFactor</code></pre><p>A binning scheme for a triangulated simplex partition where some simplices have been  refined (subdivided by a shape-preserving simplex subdivision algorithm).</p><p>The split factor bound controls how many times each simplex of the initial triangulation  is to be split.</p><p><strong>Fields</strong></p><ul><li><strong><code>simplex_split_factor::Int</code></strong>: The number of times each simplex is split.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.RefinedTriangulationBinningSplitQuantile" href="#CausalityToolsBase.RefinedTriangulationBinningSplitQuantile"><code>CausalityToolsBase.RefinedTriangulationBinningSplitQuantile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RefinedTriangulationBinningSplitQuantile</code></pre><p>A binning scheme for a triangulated simplex partition where some simplices have been  refined (subdivided by a shape-preserving simplex subdivision algorithm).</p><p>The split fraction bound controls how many times each simplex of the initial triangulation  is to be split.</p><p><strong>Fields</strong></p><ul><li><strong><code>split_quantile::Float64</code></strong>: All simplices with radius larger than the    <code>split_quantile</code>-th quantile of the radii of the simplices in initial triangulation    are split with a splitting factor of <code>simplex_split_factor</code>.</li><li><strong><code>simplex_split_factor::Int</code></strong>: The number of times each simplex is split.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.SimplexIntersectionType" href="#CausalityToolsBase.SimplexIntersectionType"><code>CausalityToolsBase.SimplexIntersectionType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimplexIntersectionType</code></pre><p>An abstract type for different types of simplex intersections.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.TriangulationBinning" href="#CausalityToolsBase.TriangulationBinning"><code>CausalityToolsBase.TriangulationBinning</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TriangulationBinningScheme</code></pre><p>A binning scheme for a triangulated simplex partition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.TriangulationBinningScheme" href="#CausalityToolsBase.TriangulationBinningScheme"><code>CausalityToolsBase.TriangulationBinningScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TriangulationBinningScheme</code></pre><p>The supertype of all triangulation binning schemes in the CausalityTools ecosystem.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.customembed" href="#CausalityToolsBase.customembed"><code>CausalityToolsBase.customembed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">customembed(pts, positions::Positions, lags::Lags)</code></pre><p>Do custom state space reconstructions with <code>customembed(pts, positions::Positions, lags::Lags)</code>.  This function acts almost as <code>DynamicalSystems.reconstruct</code>, but allows for more flexibility in  the ordering of dynamical variables and allows for negative lags. The <code>positions</code> variable  indicates which dynamical variables are mapped to which variables in the final  reconstruction, while <code>lags</code> indicates the lags for each of the embedding variables. </p><p>Example: <code>customembed([rand(3) for i = 1:50], Positions(1, 2, 1, 3), Lags(0, 0, 1, -2)</code>  gives a 4-dimensional embedding with state vectors <code>(x1(t), x2(t), x1(t + 1), x3(t - 2))</code>. </p><p>Note: <code>customembed</code> expects an array of <em>state vectors</em>, i.e. <code>pts[k]</code> must refer to the  <code>k</code>th point of the dataset, not the <code>k</code>th dynamical variable/column.*. To embed a vector of  time series, load <code>DynamicalSystems</code> and wrap the time series in a <code>Dataset</code> first, e.g. if  <code>x = rand(100); y = rand(100)</code> are two time series, then  <code>customembed(Dataset(x, y), Positions(1, 2, 2), Lags(0, 0, 1)</code> will create the embedding with  state vectors <code>(x(t), y(t), y(t + 1))</code>.</p><p>Pre-embedded points may be wrapped in a <code>CustomReconstruction</code> instance by simply calling  <code>customembed(preembedded_pts)</code> without any position/lag instructions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.encode" href="#CausalityToolsBase.encode"><code>CausalityToolsBase.encode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">encode(point, reference_point, edgelengths)</code></pre><p>Encode a point into its integer bin labels relative to some <code>reference_point</code> (always counting from lowest to highest magnitudes), given a set of box  <code>edgelengths</code> (one for each axis). The first bin on the positive side of  the reference point is indexed with 0, and the first bin on the negative  side of the reference point is indexed with -1.</p></div></div></section><pre><code class="language-none">CausalityToolsBase.eval</code></pre><pre><code class="language-none">CausalityToolsBase.fill_embedding_pts!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.get_edgelengths" href="#CausalityToolsBase.get_edgelengths"><code>CausalityToolsBase.get_edgelengths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_edgelengths(pts, ϵ) -&gt; Vector{Float}</code></pre><p>Return the box edge length along each axis resulting from  discretizing <code>pts</code> on a rectangular grid specified by the  binning scheme <code>ϵ</code>.</p></div></div></section><pre><code class="language-none">CausalityToolsBase.get_maxima</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.get_minima" href="#CausalityToolsBase.get_minima"><code>CausalityToolsBase.get_minima</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_maxima(pts) -&gt; Vector{Float}</code></pre><p>Return the maxima along each axis of the dataset <code>pts</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.get_minima_and_edgelengths" href="#CausalityToolsBase.get_minima_and_edgelengths"><code>CausalityToolsBase.get_minima_and_edgelengths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_minima_and_edgelengths(points, ϵ) -&gt; (Vector{Float}, Vector{Float})</code></pre><p>Find the minima along each axis of the embedding, and computes appropriate <code>stepsizes</code> given <code>ϵ</code>, which provide instructions on how to grid the space. Assumes each point is a column vector.</p><p>Specifically, the binning procedure is controlled by the type of <code>ϵ</code>:</p><ol><li><code>ϵ::Int</code> divides each axis into <code>ϵ</code> intervals of the same size.</li><li><code>ϵ::Float</code> divides each axis into intervals of size <code>ϵ</code>.</li><li><code>ϵ::Vector{Int}</code> divides the i-th axis into <code>ϵᵢ</code> intervals of the same size.</li><li><code>ϵ::Vector{Float64}</code> divides the i-th axis into intervals of size <code>ϵᵢ</code>.</li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.get_minmaxes" href="#CausalityToolsBase.get_minmaxes"><code>CausalityToolsBase.get_minmaxes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_minmaxes(pts) -&gt; Tuple{Vector{Float}, Vector{Float}}</code></pre><p>Return a vector of tuples containing axis-wise (minimum, maximum) values.</p></div></div></section><pre><code class="language-none">CausalityToolsBase.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.joint_visits" href="#CausalityToolsBase.joint_visits"><code>CausalityToolsBase.joint_visits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">joint_visits(points, ϵ)</code></pre><p>Determine which bins are visited by <code>points</code> given the rectangular binning scheme <code>ϵ</code>. Bins are referenced relative to the axis minimum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.marginal_visits" href="#CausalityToolsBase.marginal_visits"><code>CausalityToolsBase.marginal_visits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">marginal_visits(points, ϵ, dims)</code></pre><p>Determine which bins are visited by <code>points</code> given the rectangular binning scheme <code>ϵ</code>, only along the desired dimensions <code>dims</code>. Bins are referenced  relative to the axis minimum.</p></div></div><div><div><pre><code class="language-none">marginal_visits(joint_visits, dims)</code></pre><p>Given a set of precomputed joint visited bins, return the marginal along  dimensions <code>dims</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.non0hist" href="#ChaosTools.non0hist"><code>ChaosTools.non0hist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">non0hist(bin_visits)</code></pre><p>Return the unordered histogram (vistitation frequency) over the array of <code>bin_visits</code>, which is a vector containing bin encodings.</p><p>This method extends <code>ChaosTools.non0hist</code>.</p></div></div><div><div><pre><code class="language-none">non0hist(points, ϵ, dims)</code></pre><p>Determine which bins are visited by <code>points</code> given the rectangular binning scheme <code>ϵ</code>, considering only the marginal along dimensions <code>dims</code>. Bins are referenced  relative to the axis minimum.</p><p>Returns the unordered histogram (vistitation frequency) over the array of bin visits.</p><p>This method extends <code>ChaosTools.non0hist</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.optimal_delay" href="#CausalityToolsBase.optimal_delay"><code>CausalityToolsBase.optimal_delay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimal_delay(v; method = &quot;mi_min&quot;)</code></pre><p>Estimate the optimal embedding delay for <code>v</code> using the provided <code>method</code>.  See the documentation for <code>DelayEmbeddings.estimate_delay</code> for a list of  available methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CausalityToolsBase.optimal_dimension" href="#CausalityToolsBase.optimal_dimension"><code>CausalityToolsBase.optimal_dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimal_dimension(v, τ; dims = 1:8; method = &quot;fnn&quot;; kwargs...)</code></pre><p>Estimate the optimal embedding dimension for <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><strong><code>v</code></strong>: The data series for which to estimate the embedding dimension.</li><li><strong><code>τ</code></strong>: The embedding lag.</li><li><strong><code>dims</code></strong>: Dimensions to probe for the optimal dimension.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><strong><code>method</code></strong>: Either &quot;fnn&quot; (Kennel&#39;s false nearest neighbors method),   &quot;afnn&quot; (Cao&#39;s average false nearest neighbors method) or &quot;f1nn&quot; (Krakovská&#39;s   false first nearest neighbors method). See the source code for   <code>DelayEmbeddings.estimate_dimension</code> for more details.</li><li><strong><code>rtol</code></strong>: Tolerance <code>rtol</code> in Kennel&#39;s algorithms. See <a href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/master/src/estimate_dimension.jl"><code>DelayEmbeddings.fnn</code></a>    source code for more details.</li><li><strong><code>atol</code></strong>: Tolerance <code>rtol</code> in Kennel&#39;s algorithms. See <a href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/master/src/estimate_dimension.jl"><code>DelayEmbeddings.fnn</code></a>   source code for more details.</li></ul></div></div><div><div><pre><code class="language-none">optimal_dimension(v; dims = 1:8,
    method_dimension = &quot;fnn&quot;, method_delay = &quot;first_min&quot;)</code></pre><p>Estimate the optimal embedding dimension for <code>v</code> by first estimating the optimal lag, then using that lag to estimate the dimension.</p><p><strong>Arguments</strong></p><ul><li><strong><code>v</code></strong>: The data series for which to estimate the embedding dimension.</li><li><strong><code>dims</code></strong>: The dimensions to try</li></ul></div></div></section><pre><code class="language-none">CausalityToolsBase.verify_valid_positions!</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
