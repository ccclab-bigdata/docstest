<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Hyperspecialize.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Hyperspecialize.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Problem-1">Problem</a></li><li><a class="toctext" href="#Load-Order-Dependent-Solution-1">Load-Order Dependent Solution</a></li><li><a class="toctext" href="#Explicit-Solution-1">Explicit Solution</a></li><li><a class="toctext" href="#Opt-In,-But-Everyone-Can-Join-1">Opt-In, But Everyone Can Join</a></li><li class="toplevel"><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Concretization-1">Concretization</a></li><li><a class="toctext" href="#Replicable-1">Replicable</a></li><li class="toplevel"><a class="toctext" href="#The-Fine-Print-1">The Fine Print</a></li><li><a class="toctext" href="#Data-And-Precompilation-1">Data And Precompilation</a></li><li><a class="toctext" href="#When-Is-Hyperspecialize-Right-For-Me?-1">When Is Hyperspecialize Right For Me?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Hyperspecialize-1" href="#Hyperspecialize-1">Hyperspecialize</a></h1><p><a href="https://travis-ci.org/peterahrens/Hyperspecialize.jl"><img src="https://travis-ci.org/peterahrens/Hyperspecialize.jl.svg?branch=master" alt="Travis"/></a> <a href="https://ci.appveyor.com/project/peterahrens/hyperspecialize-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/32r7s2skrgm9ubva/branch/master?svg=true" alt="AppVeyor"/></a> <a href="https://coveralls.io/github/peterahrens/Hyperspecialize.jl?branch=master"><img src="https://coveralls.io/repos/peterahrens/Hyperspecialize.jl/badge.svg?branch=master&amp;service=github" alt="Coveralls"/></a> <a href="http://codecov.io/github/peterahrens/Hyperspecialize.jl?branch=master"><img src="http://codecov.io/github/peterahrens/Hyperspecialize.jl/coverage.svg?branch=master" alt="Codecov"/></a></p><p>Hyperspecialize is a proud hack of a Julia package designed to resolve method ambiguity errors by automating the task of redefining functions on more specific types!</p><h2><a class="nav-anchor" id="Problem-1" href="#Problem-1">Problem</a></h2><p>It is best to explain the problem (and solution) by example &lt;sup&gt;<a href="#promote_type">1</a>&lt;/sup&gt;. Suppose Peter and his friend Jarrett have both developed eponymous modules <code>Peter</code> and <code>Jarrett</code> as follows:</p><pre><code class="language-julia">module Peter
  import Base.+

  struct PeterNumber &lt;: Number
    x::Number
  end

  Base.:+(p::PeterNumber, y::Number) = PeterNumber(p.x + y)

  export PeterNumber
end

module Jarrett
  import Base.+

  struct JarrettNumber &lt;: Number
    y::Number
  end

  Base.:+(x::Number, j::JarrettNumber) = JarrettNumber(x + j.y)

  export JarrettNumber
end</code></pre><p>Peter and Jarrett have both defined fun numeric types! However, look what happens when the user tries to use Peter&#39;s and Jarrett&#39;s numbers together...</p><pre><code class="language-julia-repl">julia&gt; using .Peter

julia&gt; using .Jarrett

julia&gt; p = PeterNumber(1.0) + 3
PeterNumber(4.0)

julia&gt; j = 2.0 + JarrettNumber(2.0)
JarrettNumber(4.0)

julia&gt; friends = p + j
ERROR: MethodError: +(::PeterNumber, ::JarrettNumber) is ambiguous. Candidates:
  +(x::Number, j::JarrettNumber) in Main.Jarrett at REPL[2]:8
  +(p::PeterNumber, y::Number) in Main.Peter at REPL[1]:8
Possible fix, define
  +(::PeterNumber, ::JarrettNumber)</code></pre><p>Oh no! Since a <code>PeterNumber</code> is a <code>Number</code> and a <code>JarrettNumber</code> is a <code>Number</code>, both <code>+</code> methods are applicable, and neither method is more specific. Julia has no way to decide which method to use, and asks the user to decide by defining a more specific method.</p><p>There is a question of what role developers should play in the resolution of this ambiguity.</p><ul><li>All developers can coordinate their efforts to agree on how their types</li></ul><p>should interact, and then define methods for each interaction. This solution is unrealistic since it poses an undue burden of communication on the developers and since multiple behaviors may be desired for an interaction between types. In the above example, the two definitions of <code>+</code> have different behavior and either may be desired by the user.</p><ul><li>The developer can write their library to run in a modifed execution</li></ul><p>environment like <a href="https://github.com/jrevels/Cassette.jl">Cassette</a>. This solution creates different contexts for multiple dispatch.</p><ul><li>A single developer can define their ambiguous methods only on concrete</li></ul><p>subtypes in <code>Base</code>, and provide utilities to extend these definitions. For example, Peter could define <code>+</code> on all concrete subtypes of <code>Number</code> in Base. In cases of ambiguity, <code>+</code> would then default to Jarrett&#39;s definition unless the user asks for Peter&#39;s definition.</p><p>Hyperspecialize is designed to standardize and provide utilities for the latter approach.</p><h2><a class="nav-anchor" id="Load-Order-Dependent-Solution-1" href="#Load-Order-Dependent-Solution-1">Load-Order Dependent Solution</a></h2><p>Peter decided to use Hyperspecialize, and now his definition looks like this:</p><pre><code class="language-julia">  @replicable Base.:+(p::PeterNumber, y::@hyperspecialize(Number)) = PeterNumber(p.x + y)</code></pre><p>This solution will replicate this definition once for all concrete subtypes of <code>Number</code>. This list of subtypes depends on the module load order. If Peter&#39;s module is loaded first, we get the following behavior:</p><pre><code class="language-julia-repl">julia&gt; friends = p + j
JarrettNumber(PeterNumber(8.0))</code></pre><p>If Jarrett&#39;s module is loaded first, we get the following behavior:</p><pre><code class="language-julia-repl">julia&gt; friends = p + j
PeterNumber(JarrettNumber(8.0))</code></pre><h2><a class="nav-anchor" id="Explicit-Solution-1" href="#Explicit-Solution-1">Explicit Solution</a></h2><p>Peter doesn&#39;t like this unpredictable behavior, so he decides to explicitly define the load order for his types. He asks for his code to only be defined on the concrete subtypes of <code>Number</code> in <code>Base</code>. He uses the <code>@concretize</code> macro to define which subtypes of <code>Number</code> to use.  Now his definition looks like this:</p><pre><code class="language-julia">  @concretize myNumber [BigFloat, Float16, Float32, Float64, Bool, BigInt, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8]

  @replicable Base.:+(p::PeterNumber, y::@hyperspecialize(myNumber)) = PeterNumber(p.x + y)</code></pre><p>Since Peter has only defined <code>+</code> for the concrete subtypes of Number, the user will need to ask for a specific definition of <code>+</code> for a type they would like to use. Consider what happens when Peter&#39;s package and Jarrett&#39;s package are loaded together.</p><pre><code class="language-julia-repl">julia&gt; friends = p + j
JarrettNumber(PeterNumber(8.0))

julia&gt; using Hyperspecialize

julia&gt; @widen Peter.myNumber JarrettNumber
Set(Type[BigInt, Bool, UInt32, Float64, Float32, Int64, Int128, Float16, JarrettNumber, UInt128, UInt8, UInt16, BigFloat, Int8, UInt64, Int16, Int32])

julia&gt; friends = p + j
PeterNumber(JarrettNumber(8.0))</code></pre><p>Before the <code>myNumber</code> type tag in the <code>Peter</code> module is widened, there is no definition of <code>+</code> for <code>PeterNumber</code> and <code>JarrettNumber</code> in the <code>Peter</code> package, but since the <code>Jarrett</code> module defines a more generic method, that one is chosen. After the user widens Peter&#39;s definition to include a JarrettNumber (triggering a specific definition of <code>+</code> to be evaluated in Peter&#39;s module), the more specific method in Peter&#39;s package is chosen.</p><h2><a class="nav-anchor" id="Opt-In,-But-Everyone-Can-Join-1" href="#Opt-In,-But-Everyone-Can-Join-1">Opt-In, But Everyone Can Join</a></h2><p>Suppose Jarrett has also been thinking about method ambiguities with Peter&#39;s package and decides he will also use <code>Hyperspecialize</code>.</p><p>Now Jarret has added</p><pre><code class="language-julia">  @concretize myNumber [BigFloat, Float16, Float32, Float64, Bool, BigInt, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8]

  @replicable Base.:+(x::@hyperspecialize(myNumber), j::JarrettNumber) = JarrettNumber(x + j.y)</code></pre><p>to his module, and the behavior is as follows:</p><pre><code class="language-julia-repl">julia&gt; p + j
ERROR: no promotion exists for PeterNumber and JarrettNumber
Stacktrace:
 [1] error(::String, ::Type, ::String, ::Type) at ./error.jl:42
 [2] promote_to_supertype at ./promotion.jl:284 [inlined]
 [3] promote_result at ./promotion.jl:275 [inlined]
 [4] promote_type at ./promotion.jl:210 [inlined]
 [5] _promote at ./promotion.jl:249 [inlined]
 [6] promote at ./promotion.jl:292 [inlined]
 [7] +(::PeterNumber, ::JarrettNumber) at ./promotion.jl:321
 [8] top-level scope</code></pre><p>There is now no method for adding a PeterNumber and a JarrettNumber! The user must ask for one explicitly using <code>@widen</code> on either Peter or Jarrett&#39;s <code>myNumber</code> type tag. If the user chooses to widen Jarrett&#39;s definitions, we get</p><pre><code class="language-julia-repl">julia&gt; @widen Jarrett.myNumber PeterNumber
Set(Type[BigInt, Bool, UInt32, Float64, Float32, Int64, Int128, Float16, PeterNumber, UInt128, UInt8, UInt16, BigFloat, Int8, UInt64, Int16, Int32])

julia&gt; p + j
JarrettNumber(PeterNumber(8.0))</code></pre><p>If the user instead chooses to widen Peter&#39;s definitions, we get</p><pre><code class="language-julia-repl">julia&gt; @widen Peter.myNumber JarrettNumber
Set(Type[BigInt, Bool, UInt32, Float64, Float32, Int64, Int128, Float16, UInt128, UInt8, UInt16, BigFloat, Int8, UInt64, JarrettNumber, Int16, Int32])

julia&gt; p + j
PeterNumber(JarrettNumber(8.0))</code></pre><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><p>This library provides several functions for managing the defintions to replicate and the types they are replicated over.</p><h2><a class="nav-anchor" id="Concretization-1" href="#Concretization-1">Concretization</a></h2><p>The user must enumerate the types that a definition is to replicated over. We use <em>type tags</em> to describe a particular set of types. The type tag arguments to macros are interpreted literally as symbols. The set of types is referred to as the <em>concretization</em>.</p><p>You may specify the concretization of a type tag using the <code>@concretize</code> macro like this:</p><pre><code class="language-julia">@concretize Key Int</code></pre><p>You may specify more than one type:</p><pre><code class="language-julia">@concretize Key (Int, Float64, Float32)</code></pre><p>If you would like to expand the concretization of a type tag, use the <code>@widen</code> macro.</p><pre><code class="language-julia">@widen Key (BigFloat, Bool)</code></pre><p>You may query the concretization of a type tag with the <code>@concretization</code> macro.</p><pre><code class="language-julia">@concretization Key</code></pre><p>Type tags always have module-local scope and if no module is specified, they are interpreted as belonging to the module in which they are expanded. You may use the type tag form <code>mod.Key</code> to specify a module anywhere a type tag is an argument to a macro.</p><pre><code class="language-julia">@concretization(mod.Key)</code></pre><p>If no concretization is given for a type tag <code>Key</code> in module <code>mod</code>, the tag is given the default concretization corresponding to all the concrete subtypes of whatever the symbol <code>Key</code> means when evaluated in <code>mod</code> (so if you are making up a tag name, please define a concretization for it).</p><h2><a class="nav-anchor" id="Replicable-1" href="#Replicable-1">Replicable</a></h2><p>The heart of the Hyperspecialize package is the <code>@replicable</code> macro, which promises to replicate a definition for all combinations of types in the concretization of type tags that appear in the definition. <code>@replicable</code> takes only one argument, the code to be replicated at global scope in the current module. To specify type tags, use the @hyperspecialize macro where the types in the concretization of a tag should be substituted.</p><p>Thus, the following example</p><pre><code class="language-julia">module Foo
  @concretize MyKey (Int, Float32)
  @replicable bar(x::@hyperspecialize(MyKey), y::(@hyperspecialize MyKey)) = x + y
end</code></pre><p>will execute the following code at global scope in <code>Foo</code>.</p><pre><code class="language-julia">bar(x::Int, y::Int) = x + y
bar(x::Float32, y::Int) = x + y
bar(x::Int, y::Float32) = x + y
bar(x::Float32, y::Float32) = x + y</code></pre><p>If someone has loaded the <code>Foo</code> module and calls</p><pre><code class="language-julia">  @widen Foo.MyKey Float64</code></pre><p>then the following code will execute at global scope in <code>Foo</code>.</p><pre><code class="language-julia">bar(x::Float64, y::Float64) = x + y
bar(x::Int, y::Float64) = x + y
bar(x::Float32, y::Float64) = x + y
bar(x::Float64, y::Int) = x + y
bar(x::Float64, y::Float32) = x + y</code></pre><p>Notice that the earlier definitions are not repeated.</p><h1><a class="nav-anchor" id="The-Fine-Print-1" href="#The-Fine-Print-1">The Fine Print</a></h1><p>This is an example of a module where the idea is simple and the details are not.</p><h2><a class="nav-anchor" id="Data-And-Precompilation-1" href="#Data-And-Precompilation-1">Data And Precompilation</a></h2><p>Data is stored in <code>const global</code> dictionaries named <code>__hyperspecialize__</code> in every module that calls <code>@concretize</code> (Note that this can happen implicitly if other methods are called that expect a concretization to exist already).</p><p>For this reason (and to keep things simple), you cannot concretize a type tag in a module that is not your own.</p><p>Since this package works by calling &quot;eval&quot; on different modules to widen types, if you want to call <code>@widen</code> on a type key in another module, you must do so from the <code>__init__()</code> function in your module. See the documentation on <code>__init__()</code>.</p><h2><a class="nav-anchor" id="When-Is-Hyperspecialize-Right-For-Me?-1" href="#When-Is-Hyperspecialize-Right-For-Me?-1">When Is Hyperspecialize Right For Me?</a></h2><p>There are three main drawbacks to the Hyperspecialize package.</p><ul><li>These macros may generate a very large number of definitions if the</li></ul><p>function definition includes many hyperspecialized type tags. For mathematical operators this can be alleviated using Julia&#39;s promotion rules, but the problem of how to define an unambiguous <code>promote_type</code> still stands. To further reduce the number of methods that are defined, in some situations it may be sufficient to only concretize the type tag to be a union of concrete types in Base. This strategy works best if it is unlikely that the method will be redefined using those types.</p><ul><li>The second drawback is that the user must manually choose desired behavior,</li></ul><p>so if the ambiguity is related to an internal type, the user may not know how to resolve it.</p><ul><li>The third drawback is that both methods that create an ambiguity may be</li></ul><p>desired by a user, and they are forced to choose one global behavior. This can be problematic if a different library has widened the same type tag and made that choice for them already.</p><p>In short, Hyperspecialize works best when the user knows which types are being concretized, and when the resolution to method ambiguities is clear. A major benefit to using Hyperspecialize is that you may keep your type-based API, you are not forced to adopt a function-based API. If this is not something that is important to you and you cannot work around difficulties involved in using Hyperspecialize, you will likely be better off using a contextual dispatch solution such as <a href="https://github.com/jrevels/Cassette.jl">Cassette</a>.</p><p>&lt;a name=&quot;promote<em>type&quot;&gt;1&lt;/a&gt;: I have chosen <code>+</code> as an example function, but it would be possible to define promotion rules to avoid some ambiguities. However, it is possible that type ambiguities may occur in the definition of the `promote</em>type` function.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
