<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · POMDPs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>POMDPs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@POMDP_require" href="#POMDPs.@POMDP_require"><code>POMDPs.@POMDP_require</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@POMDP_require solve(s::CoolSolver, p::POMDP) begin
    PType = typeof(p)
    @req states(::PType)
    @req actions(::PType)
    @req transition(::PType, ::S, ::A)
    s = first(states(p))
    a = first(actions(p))
    t_dist = transition(p, s, a)
    @req rand(::AbstractRNG, ::typeof(t_dist))
end</code></pre><p>Create a get_requirements implementation for the function signature and the requirements block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@POMDP_requirements" href="#POMDPs.@POMDP_requirements"><code>POMDPs.@POMDP_requirements</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">reqs = @POMDP_requirements CoolSolver begin
    PType = typeof(p)
    @req states(::PType)
    @req actions(::PType)
    @req transition(::PType, ::S, ::A)
    s = first(states(p))
    a = first(actions(p))
    t_dist = transition(p, s, a)
    @req rand(::AbstractRNG, ::typeof(t_dist))
end</code></pre><p>Create a RequirementSet object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@get_requirements" href="#POMDPs.@get_requirements"><code>POMDPs.@get_requirements</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@get_requirements f(arg1, arg2)</code></pre><p>Call get_requirements(f, (arg1,arg2)).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@impl_dep" href="#POMDPs.@impl_dep"><code>POMDPs.@impl_dep</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@impl_dep reward(::P,::S,::A,::S) where {P&lt;:POMDP,S,A} reward(::P,::S,::A)</code></pre><p>Declare an implementation dependency and automatically implement <code>implemented</code>.</p><p>In the example above, <code>@implemented reward(::P,::S,::A,::S)</code> will return true if the user has implemented <code>reward(::P,::S,::A,::S)</code> OR <code>reward(::P,::S,::A)</code></p><p>THIS IS ONLY INTENDED FOR USE INSIDE POMDPs AND MAY NOT FUNCTION CORRECTLY ELSEWHERE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@implemented" href="#POMDPs.@implemented"><code>POMDPs.@implemented</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@implemented function(::Arg1Type, ::Arg2Type)</code></pre><p>Check whether there is an implementation available that will return a suitable value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@req" href="#POMDPs.@req"><code>POMDPs.@req</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@req f( ::T1, ::T2)</code></pre><p>Convert a <code>f( ::T1, ::T2)</code> expression to a <code>(f, Tuple{T1,T2})::Req</code> for pushing to a <code>RequirementSet</code>.</p><p>If in a <code>@POMDP_requirements</code> or <code>@POMDP_require</code> block, marks the requirement for including in the set of requirements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@requirements_info" href="#POMDPs.@requirements_info"><code>POMDPs.@requirements_info</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@requirements_info ASolver() [YourPOMDP()]</code></pre><p>Print information about the requirements for a solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@show_requirements" href="#POMDPs.@show_requirements"><code>POMDPs.@show_requirements</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@show_requirements solve(solver, problem)</code></pre><p>Print a a list of requirements for a function call.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@subreq" href="#POMDPs.@subreq"><code>POMDPs.@subreq</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@subreq f(arg1, arg2)</code></pre><p>In a <code>@POMDP_requirements</code> or <code>@POMDP_require</code> block, include the requirements for <code>f(arg1, arg2)</code> as a child argument set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.@warn_requirements" href="#POMDPs.@warn_requirements"><code>POMDPs.@warn_requirements</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@warn_requirements solve(solver, problem)</code></pre><p>Print a warning if there are unmet requirements.</p></div></div></section><pre><code class="language-none">POMDPs.AbstractRequirementSet</code></pre><pre><code class="language-none">POMDPs.CheckedList</code></pre><pre><code class="language-none">POMDPs.EXPORTED_TYPES</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.MDP" href="#POMDPs.MDP"><code>POMDPs.MDP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base type for a fully observable Markov decision process.</p><pre><code class="language-none">S: state type
A: action type</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.NATIVE_PACKAGES" href="#POMDPs.NATIVE_PACKAGES"><code>POMDPs.NATIVE_PACKAGES</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Set containing string names of officially supported solvers and utility packages (e.g. <code>MCTS</code>, <code>SARSOP</code>, <code>POMDPToolbox</code>, etc).  If you have a validated solver that supports the POMDPs.jl API, contact the developers to add your solver to this list. </p></div></div></section><pre><code class="language-none">POMDPs.NON_NATIVE_PACKAGES</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.POMDP" href="#POMDPs.POMDP"><code>POMDPs.POMDP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base type for a partially observable Markov decision process.</p><pre><code class="language-none">S: state type
A: action type
O: observation type</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.POMDP_REGISTRY" href="#POMDPs.POMDP_REGISTRY"><code>POMDPs.POMDP_REGISTRY</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>url to JuliaPOMDP registry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.POMDPs" href="#POMDPs.POMDPs"><code>POMDPs.POMDPs</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Provides a basic interface for defining and solving MDPs/POMDPs</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.Policy" href="#POMDPs.Policy"><code>POMDPs.Policy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base type for a policy (a map from every possible belief, or more abstract policy state, to an optimal or suboptimal action)</p></div></div></section><pre><code class="language-none">POMDPs.REGISTERED_PACKAGES</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.REMOTE_URL" href="#POMDPs.REMOTE_URL"><code>POMDPs.REMOTE_URL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>url to remote JuliaPOMDP organization repo</p></div></div></section><pre><code class="language-none">POMDPs.REQUIRED_REGISTRY_ENTRIES</code></pre><pre><code class="language-none">POMDPs.Req</code></pre><pre><code class="language-none">POMDPs.RequirementSet</code></pre><pre><code class="language-none">POMDPs.SUPPORTED_PACKAGES</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.Simulator" href="#POMDPs.Simulator"><code>POMDPs.Simulator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base type for an object defining how simulations should be carried out.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.Solver" href="#POMDPs.Solver"><code>POMDPs.Solver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base type for an MDP/POMDP solver</p></div></div></section><pre><code class="language-none">POMDPs.TupleType</code></pre><pre><code class="language-none">POMDPs.Unspecified</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.Updater" href="#POMDPs.Updater"><code>POMDPs.Updater</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for an object that defines how the belief should be updated</p><p>A belief is a general construct that represents the knowledge an agent has about the state of the system. This can be a probability distribution, an action observation history or a more general representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.action" href="#POMDPs.action"><code>POMDPs.action</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">action{B}(policy::Policy, x::B)</code></pre><p>Fills and returns action based on the current state or belief, given the policy. <code>B</code> is a generalized information state - can be a state in an MDP, a distribution in POMDP, or any other representation needed to make a decision using the given policy.</p></div></div></section><pre><code class="language-none">POMDPs.action_index</code></pre><pre><code class="language-none">POMDPs.action_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.actionindex" href="#POMDPs.actionindex"><code>POMDPs.actionindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">actionindex{S,A,O}(problem::POMDP{S,A,O}, a::A)
actionindex{S,A}(problem::MDP{S,A}, a::A)</code></pre><p>Return the integer index of action <code>a</code>. Used for discrete models only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.actions" href="#POMDPs.actions"><code>POMDPs.actions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">actions(problem::POMDP)
actions(problem::MDP)</code></pre><p>Returns the entire action space of a POMDP.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.actiontype" href="#POMDPs.actiontype"><code>POMDPs.actiontype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">actiontype(t::Type)
actiontype(p::Union{POMDP,MDP})</code></pre><p>Return the state type for a problem type (the <code>S</code> in <code>POMDP{S,A,O}</code>).</p><pre><code class="language-none">type A &lt;: POMDP{Bool, Int, Bool} end

actiontype(A) # returns Int</code></pre></div></div></section><pre><code class="language-none">POMDPs.add</code></pre><pre><code class="language-none">POMDPs.add_all</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.add_registry" href="#POMDPs.add_registry"><code>POMDPs.add_registry</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_registry()</code></pre><p>Adds the JuliaPOMDP registry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.available" href="#POMDPs.available"><code>POMDPs.available</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">available()</code></pre><p>Prints all the available packages in the JuliaPOMDP registry</p></div></div></section><pre><code class="language-none">POMDPs.build</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.check_requirements" href="#POMDPs.check_requirements"><code>POMDPs.check_requirements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_requirements(r::AbstractRequirementSet)</code></pre><p>Check whether the methods in <code>r</code> have implementations with <code>implemented()</code>. Return true if all methods have implementations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.convert_a" href="#POMDPs.convert_a"><code>POMDPs.convert_a</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert_a(::Type{V}, a, problem::Union{MDP,POMDP}) where V&lt;:AbstractArray
convert_a(::Type{A}, vec::V, problem::Union{MDP,POMDP}) where {A,V&lt;:AbstractArray}</code></pre><p>Convert an action to vectorized form or vice versa.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.convert_call" href="#POMDPs.convert_call"><code>POMDPs.convert_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return a <code>(f, (arg1,arg2))</code> expression given a <code>f(arg1, arg2)</code> expression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.convert_o" href="#POMDPs.convert_o"><code>POMDPs.convert_o</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert_o(::Type{V}, o, problem::Union{MDP,POMDP}) where V&lt;:AbstractArray
convert_o(::Type{O}, vec::V, problem::Union{MDP,POMDP}) where {O,V&lt;:AbstractArray}</code></pre><p>Convert an observation to vectorized form or vice versa.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.convert_req" href="#POMDPs.convert_req"><code>POMDPs.convert_req</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return a <code>(f, Tuple{T1,T2})::Req</code> expression given a <code>f( ::T1, ::T2)</code> expression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.convert_s" href="#POMDPs.convert_s"><code>POMDPs.convert_s</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert_s(::Type{V}, s, problem::Union{MDP,POMDP}) where V&lt;:AbstractArray
convert_s(::Type{S}, vec::V, problem::Union{MDP,POMDP}) where {S,V&lt;:AbstractArray}</code></pre><p>Convert a state to vectorized form or vice versa.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.dimensions" href="#POMDPs.dimensions"><code>POMDPs.dimensions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dimensions(s::Any)</code></pre><p>Returns the number of dimensions in space <code>s</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.discount" href="#POMDPs.discount"><code>POMDPs.discount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">discount(problem::POMDP)
discount(problem::MDP)</code></pre><p>Return the discount factor for the problem.</p></div></div></section><pre><code class="language-none">POMDPs.eval</code></pre><pre><code class="language-none">POMDPs.failed_synth_warning</code></pre><pre><code class="language-none">POMDPs.format_method</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_o" href="#POMDPs.generate_o"><code>POMDPs.generate_o</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_o{S,A,O}(p::POMDP{S,A,O}, s::S, a::A, sp::S, rng::AbstractRNG)</code></pre><p>Return the next observation given current state <code>s</code>, action taken <code>a</code> and next state <code>sp</code>.</p><p>Usually the observation would only depend on the next state <code>sp</code>.</p><pre><code class="language-none">generate_o{S,A,O}(p::POMDP{S,A,O}, s::S, rng::AbstractRNG)</code></pre><p>Return the observation from the current state. This should be used to generate initial observations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_or" href="#POMDPs.generate_or"><code>POMDPs.generate_or</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_or{S,A,O}(p::POMDP{S,A,O}, s::S, a::A, sp::S, rng::AbstractRNG)</code></pre><p>Return the observation <code>o</code> and reward for taking action <code>a</code> in current state <code>s</code> reaching state <code>sp</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_s" href="#POMDPs.generate_s"><code>POMDPs.generate_s</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_s{S,A}(p::Union{POMDP{S,A},MDP{S,A}}, s::S, a::A, rng::AbstractRNG)</code></pre><p>Return the next state given current state <code>s</code> and action taken <code>a</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_so" href="#POMDPs.generate_so"><code>POMDPs.generate_so</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_so{S,A,O}(p::POMDP{S,A,O}, s::S, a::A, rng::AbstractRNG)</code></pre><p>Return the next state <code>sp</code> and observation <code>o</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_sor" href="#POMDPs.generate_sor"><code>POMDPs.generate_sor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_sor{S,A,O}(p::POMDP{S,A,O}, s::S, a::A, rng::AbstractRNG)</code></pre><p>Return the next state <code>sp</code>, observation <code>o</code> and reward for taking action <code>a</code> in current state <code>s</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.generate_sr" href="#POMDPs.generate_sr"><code>POMDPs.generate_sr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_sr{S}(p::Union{POMDP{S},MDP{S}}, s, a, rng::AbstractRNG)</code></pre><p>Return the next state <code>sp</code> and reward for taking action <code>a</code> in current state <code>s</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.get_requirements" href="#POMDPs.get_requirements"><code>POMDPs.get_requirements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_requirements(f::Function, args::Tuple)</code></pre><p>Return a RequirementSet for the function f and arguments args.</p></div></div></section><pre><code class="language-none">POMDPs.getindex</code></pre><pre><code class="language-none">POMDPs.handle_method</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.handle_reqs!" href="#POMDPs.handle_reqs!"><code>POMDPs.handle_reqs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">handle_reqs!(block, reqs_name::Symbol)</code></pre><p>Replace any @req calls with <code>push!($reqs_name, &lt;requirement&gt;)</code></p><p>Returns true if there was a requirement in there and so should not be escaped.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.implemented" href="#POMDPs.implemented"><code>POMDPs.implemented</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">implemented(function, Tuple{Arg1Type, Arg2Type})</code></pre><p>Check whether there is an implementation available that will return a suitable value.</p></div></div></section><pre><code class="language-none">POMDPs.include</code></pre><pre><code class="language-none">POMDPs.initial_state</code></pre><pre><code class="language-none">POMDPs.initial_state_distribution</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.initialize_belief" href="#POMDPs.initialize_belief"><code>POMDPs.initialize_belief</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize_belief(updater::Updater,
                     state_distribution::Any)
initialize_belief(updater::Updater, belief::Any)</code></pre><p>Returns a belief that can be updated using <code>updater</code> that has similar distribution to <code>state_distribution</code> or <code>belief</code>.</p><p>The conversion may be lossy. This function is also idempotent, i.e. there is a default implementation that passes the belief through when it is already the correct type: <code>initialize_belief(updater::Updater, belief) = belief</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.initialstate" href="#POMDPs.initialstate"><code>POMDPs.initialstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialstate{S}(p::Union{POMDP{S},MDP{S}}, rng::AbstractRNG)</code></pre><p>Return the initial state for the problem <code>p</code>.</p><p>Usually the initial state is sampled from an initial state distribution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.initialstate_distribution" href="#POMDPs.initialstate_distribution"><code>POMDPs.initialstate_distribution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialstate_distribution(pomdp::POMDP)
initialstate_distribution(mdp::MDP)</code></pre><p>Return a distribution of the initial state of the pomdp or mdp.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.isterminal" href="#POMDPs.isterminal"><code>POMDPs.isterminal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isterminal{S,A,O}(problem::POMDP{S,A,O}, state::S)
isterminal{S,A}(problem::MDP{S,A}, state::S)</code></pre><p>Check if state s is terminal</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.isterminal_obs" href="#POMDPs.isterminal_obs"><code>POMDPs.isterminal_obs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isterminal_obs{S,A,O}(problem::POMDP{S,A,O}, observation::O)</code></pre><p>Check if an observation is terminal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.iterator" href="#POMDPs.iterator"><code>POMDPs.iterator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iterator(d::Any)</code></pre><p>DEPRECATED. Return an iterable object (array or custom iterator) that iterates over possible values of distribution <code>d</code>. Values with zero probability may be skipped.</p></div></div></section><pre><code class="language-none">POMDPs.length</code></pre><pre><code class="language-none">POMDPs.lowerbound</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mean(d::Any)</code></pre><p>Return the mean of a distribution d.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.mode" href="#StatsBase.mode"><code>StatsBase.mode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mode(d::Any)</code></pre><p>Return the most likely value in a distribution d.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.n_actions" href="#POMDPs.n_actions"><code>POMDPs.n_actions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">n_actions(problem::POMDP)
n_actions(problem::MDP)</code></pre><p>Return the number of actions in <code>problem</code>. Used for discrete models only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.n_observations" href="#POMDPs.n_observations"><code>POMDPs.n_observations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">n_observations(problem::POMDP)</code></pre><p>Return the number of observations in <code>problem</code>. Used for discrete models only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.n_states" href="#POMDPs.n_states"><code>POMDPs.n_states</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">n_states(problem::POMDP)
n_states(problem::MDP)</code></pre><p>Return the number of states in <code>problem</code>. Used for discrete models only.</p></div></div></section><pre><code class="language-none">POMDPs.obs_index</code></pre><pre><code class="language-none">POMDPs.obs_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.observation" href="#POMDPs.observation"><code>POMDPs.observation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">observation{S,A,O}(problem::POMDP{S,A,O}, statep::S)
observation{S,A,O}(problem::POMDP{S,A,O}, action::A, statep::S)
observation{S,A,O}(problem::POMDP{S,A,O}, state::S, action::A, statep::S)</code></pre><p>Return the observation distribution. You need only define the method with the fewest arguments needed to determine the observation distribution.</p><p><strong>Example</strong></p><pre><code class="language-julia">using POMDPToolbox # for SparseCat

struct MyPOMDP &lt;: POMDP{Int, Int, Int} end

observation(p::MyPOMDP, sp::Int) = SparseCat([sp-1, sp, sp+1], [0.1, 0.8, 0.1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.observations" href="#POMDPs.observations"><code>POMDPs.observations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">observations(problem::POMDP)</code></pre><p>Return the entire observation space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.obsindex" href="#POMDPs.obsindex"><code>POMDPs.obsindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">obsindex{S,A,O}(problem::POMDP{S,A,O}, o::O)</code></pre><p>Return the integer index of observation <code>o</code>. Used for discrete models only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.obstype" href="#POMDPs.obstype"><code>POMDPs.obstype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">obstype(t::Type)</code></pre><p>Return the state type for a problem type (the <code>S</code> in <code>POMDP{S,A,O}</code>).</p><pre><code class="language-none">type A &lt;: POMDP{Bool, Bool, Int} end

obstype(A) # returns Int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.pdf" href="#Distributions.pdf"><code>Distributions.pdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pdf(d::Any, x::Any)</code></pre><p>Evaluate the probability density of distribution <code>d</code> at sample <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.pomdp_requirements" href="#POMDPs.pomdp_requirements"><code>POMDPs.pomdp_requirements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return an expression that creates a RequirementSet using the code in the block. The resulting code will <em>always</em> return a RequirementSet, but it may be incomplete if the exception field is not null.</p></div></div></section><pre><code class="language-none">POMDPs.push_dep!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand{T}(rng::AbstractRNG, d::Any)</code></pre><p>Return a random element from distribution or space <code>d</code>.</p><p>If <code>d</code> is a state or transition distribution, the sample will be a state; if <code>d</code> is an action distribution, the sample will be an action or if <code>d</code> is an observation distribution, the sample will be an observation.</p></div></div></section><pre><code class="language-none">POMDPs.read_registry</code></pre><pre><code class="language-none">POMDPs.recursively_check</code></pre><pre><code class="language-none">POMDPs.recursively_show</code></pre><pre><code class="language-none">POMDPs.remove_all</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.requirements_info" href="#POMDPs.requirements_info"><code>POMDPs.requirements_info</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">requirements_info(s::Solver, p::Union{POMDP,MDP}, ...)</code></pre><p>Print information about the requirement for solver s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.reward" href="#POMDPs.reward"><code>POMDPs.reward</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reward{S,A,O}(problem::POMDP{S,A,O}, state::S, action::A)
reward{S,A}(problem::MDP{S,A}, state::S, action::A)</code></pre><p>Return the immediate reward for the s-a pair</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.sampletype" href="#POMDPs.sampletype"><code>POMDPs.sampletype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sampletype(T::Type)
sampletype(d::Any) = sampletype(typeof(d))</code></pre><p>Return the type of objects that are sampled from a distribution or space <code>d</code> when <code>rand(rng, d)</code> is called.</p><p>The distribution writer should implement the <code>sampletype(::Type)</code> method for the distribution type, then the function can be called for that type or for objects of that type (i.e. the <code>sampletype(d::Any) = sampletype(typeof(d))</code> default is provided).</p></div></div></section><pre><code class="language-none">POMDPs.short_method</code></pre><pre><code class="language-none">POMDPs.show_checked_list</code></pre><pre><code class="language-none">POMDPs.show_heading</code></pre><pre><code class="language-none">POMDPs.show_incomplete</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.show_requirements" href="#POMDPs.show_requirements"><code>POMDPs.show_requirements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_requirements(r::AbstractRequirementSet)</code></pre><p>Check whether the methods in <code>r</code> have implementations with <code>implemented()</code> and print out a formatted list showing which are missing. Return true if all methods have implementations.</p></div></div></section><pre><code class="language-none">POMDPs.show_requirer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.simulate" href="#POMDPs.simulate"><code>POMDPs.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simulate{S,A,O,B}(simulator::Simulator, problem::POMDP{S,A,O}, policy::Policy{B}, updater::Updater{B}, initial_belief::B)
simulate{S,A}(simulator::Simulator, problem::MDP{S,A}, policy::Policy, initial_state::S)</code></pre><p>Run a simulation using the specified policy.</p><p>The return type is flexible and depends on the simulator. For example implementations, see the POMDPToolbox package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.solve" href="#POMDPs.solve"><code>POMDPs.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve(solver::Solver, problem::POMDP)</code></pre><p>Solves the POMDP using method associated with solver, and returns a policy.</p></div></div></section><pre><code class="language-none">POMDPs.state_index</code></pre><pre><code class="language-none">POMDPs.state_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.stateindex" href="#POMDPs.stateindex"><code>POMDPs.stateindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stateindex{S,A,O}(problem::POMDP{S,A,O}, s::S)
stateindex{S,A}(problem::MDP{S,A}, s::S)</code></pre><p>Return the integer index of state <code>s</code>. Used for discrete models only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.states" href="#POMDPs.states"><code>POMDPs.states</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">states(problem::POMDP)
states(problem::MDP)</code></pre><p>Returns the complete state space of a POMDP. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.statetype" href="#POMDPs.statetype"><code>POMDPs.statetype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">statetype(t::Type)
statetype(p::Union{POMDP,MDP})</code></pre><p>Return the state type for a problem type (the <code>S</code> in <code>POMDP{S,A,O}</code>).</p><pre><code class="language-none">type A &lt;: POMDP{Int, Bool, Bool} end

statetype(A) # returns Int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.support" href="#Distributions.support"><code>Distributions.support</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">support(d::Any)</code></pre><p>Return the possible values that can be sampled from distribution d. Values with zero probability may be skipped.</p></div></div></section><pre><code class="language-none">POMDPs.test_all</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.transition" href="#POMDPs.transition"><code>POMDPs.transition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transition{S,A,O}(problem::POMDP{S,A,O}, state::S, action::A)
transition{S,A}(problem::MDP{S,A}, state::S, action::A)</code></pre><p>Return the transition distribution from the current state-action pair</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.unpack_typedcall" href="#POMDPs.unpack_typedcall"><code>POMDPs.unpack_typedcall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return a tuple (not an Expr) of the function name, arguments, and argument types.</p><p>E.g. <code>f(arg1::T1, arg2::T2)</code> would be unpacked to (:f, [:arg1, :arg2], [:T1, :T2])</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.update" href="#POMDPs.update"><code>POMDPs.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">update(updater::Updater, belief_old, action, observation)</code></pre><p>Return a new instance of an updated belief given <code>belief_old</code> and the latest action and observation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.updater" href="#POMDPs.updater"><code>POMDPs.updater</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updater(policy::Policy)</code></pre><p>Returns a default Updater appropriate for a belief type that policy <code>p</code> can use</p></div></div></section><pre><code class="language-none">POMDPs.upperbound</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POMDPs.value" href="#POMDPs.value"><code>POMDPs.value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value(p::Policy, s)
value(p::Policy, s, a)</code></pre><p>Returns the utility value from policy <code>p</code> given the state (or belief), or state-action (or belief-action) pair.</p><p>The state-action version is commonly referred to as the Q-value.</p></div></div></section><pre><code class="language-none">POMDPs.verify_registry</code></pre><pre><code class="language-none">POMDPs.weight</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
