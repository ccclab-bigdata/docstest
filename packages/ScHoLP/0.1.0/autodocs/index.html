<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ScHoLP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ScHoLP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.HONData" href="#ScHoLP.HONData"><code>ScHoLP.HONData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>HONData</strong></p><p>Data structure for a temporal higher-order network.</p><p>Each dataset consists of three integer vectors: simplices, nverts, and times. </p><ul><li>The simplices is a contiguous vector of nodes comprising the simplices. </li><li>The nverts vector contains the number of vertices within each simplex. </li><li>The times vector contains the timestamps of the simplices (same length as nverts).</li></ul><p>For example, consider a dataset consisting of three simplices:</p><pre><code class="language-none">1. {1, 2, 3} at time 10
2. {2, 4} at time 15.
3. {1, 3, 4, 5} at time 21.</code></pre><p>Then the data structure would be  </p><ul><li>simplices = [1, 2, 3, 2, 4, 1, 3, 4, 5]</li><li>nverts = [3, 2, 4]</li><li>times = [10, 15, 21]</li></ul><p>There is an additional name variable attached to the dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.NbrSetMap" href="#ScHoLP.NbrSetMap"><code>ScHoLP.NbrSetMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>NbrSetMap</strong></p><p>const NbrSetMap = Dict{NTuple{2, Int64}, Set{Int64}}</p></div></div></section><pre><code class="language-none">ScHoLP.OPEN</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.PKatz3" href="#ScHoLP.PKatz3"><code>ScHoLP.PKatz3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>PKatz3</strong></p><p>Compute 3-way personalized Katz scores for triangles.</p><p>PKatz3(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat,        unweighted::Bool, dense_solve::Bool=false)</p><p>Example usage:</p><pre><code class="language-none">(scores, S) = PPR3(T, B, false, false)</code></pre><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li><li>unweighted::Bool: Whether or not to use the unweighted version of the matrix.</li><li>dense_solve::Bool=false: whether or not to use a dense solver. If B is small, then it is worth setting this option to true.</li></ul><p>returns a tuple (scores, S):</p><ul><li>scores::Vector{Float64}: a vector of 3-way PPR scores for the triangles</li><li>S::SpFltMat: a sparse matrix with the same sparsity pattern as B, where S[i, j] is the personalized Katz score of node i with respect to the seed node j.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.PPR3" href="#ScHoLP.PPR3"><code>ScHoLP.PPR3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>PPR3</strong></p><p>Compute 3-way personalized PageRank scores for triangles.</p><p>PPR3(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat,       unweighted::Bool, dense_solve::Bool=false, α::Float64=0.85)</p><p>Example usage:</p><pre><code class="language-none">(scores, S) = PPR3(T, B, false, false, 0.85)</code></pre><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li><li>unweighted::Bool: Whether or not to use the unweighted version of the matrix.</li><li>dense_solve::Bool=false: whether or not to use a dense solver. If B is small, then it is worth setting this option to true.</li><li>α::Float64=0.85: teleportation parameter for PageRank</li></ul><p>returns a tuple (scores, S):</p><ul><li>scores::Vector{Float64}: a vector of 3-way PPR scores for the triangles</li><li>S::SpFltMat: a sparse matrix with the same sparsity pattern as B, where S[i, j] is the personalized PageRank score of node i with respect to the seed node j.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.STRONG</code></pre><pre><code class="language-none">ScHoLP.ScHoLP</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.SimplicialPROperator" href="#ScHoLP.SimplicialPROperator"><code>ScHoLP.SimplicialPROperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>SimplicialPROperator</strong></p><p>Construct the Simplicial PageRank Operator</p><p>SimplicialPROperator(grad::SpIntMat, curl::SpIntMat,                      edge_map::Dict{NTuple{2,Int64},Int64}, α::Float64)</p><p>Input parameters:</p><ul><li>grad::SpIntMat: gradient operator (as a matrix)</li><li>curl::SpIntMat: curl operator (as a matrix)</li><li>edge_map::Dict{NTuple{2,Int64}, Int64}: maps an a sorted edge tuple to an index for the matrices</li><li>α::Float64: teleportation parameter</li></ul><p>returns simplicial PageRank operator</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.Simplicial_PPR3_combined" href="#ScHoLP.Simplicial_PPR3_combined"><code>ScHoLP.Simplicial_PPR3_combined</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Simplicial<em>PPR3</em>combined</strong></p><p>Compute the &quot;combined&quot; 3-way simplicial personalized PageRank scores for triangles. This is less computationally expensive that the related function Simplicial<em>PPR3</em>decomposed(), which decomposes the scores into the curl, gradient, and harmonic components.</p><p>function Simplicial<em>PPR3</em>combined(triangles::Vector{NTuple{3,Int64}}, A::SpIntMat,                                   At::SpIntMat, B::SpIntMat, α::Float64=0.85)</p><p>Example usage:</p><pre><code class="language-none">(scores_comb, S_comb, vec_edge_map) = Simplicial_PPR3_combined(T, A)</code></pre><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>A::SpIntMat: (# nodes) x (# simplices) adjacency matrix</li><li>α::Float64=0.85: teleportation parameter for PageRank</li></ul><p>returns a tuple (scores<em>comb, S</em>comb, vec<em>edge</em>map)</p><ul><li>scores_comb::Vector{Float64}: scores for &quot;combined&quot; simplicial personalized PageRank</li><li>S_comb::SpFltMat: a sparse matrix, where S[x, y] is the combined simplicial PPR score for edge x with respect to edge y</li><li>vec<em>edge</em>map::Array{Int64,2}: 2 x (# edges) map of indices for S<em>comb such that the vec</em>edge_map[:, i] is the edge for ith index in the matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.Simplicial_PPR3_decomposed" href="#ScHoLP.Simplicial_PPR3_decomposed"><code>ScHoLP.Simplicial_PPR3_decomposed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Simplicial<em>PPR3</em>decomposed</strong></p><p>Compute 3-way simplicial personalized PageRank scores for triangles, decomposed into the harmonic, gradient, and curl components.</p><p>Simplicial<em>PPR3</em>decomposed(triangles::Vector{NTuple{3,Int64}}, A::SpIntMat, dense_solve::Bool=false, α::Float64=0.85)</p><p>Example usage:</p><pre><code class="language-none">(scores_comb, scores_curl, scores_grad, scores_harm, S_comb, S_curl, S_grad, S_harm, vec_edge_map) =
    Simplicial_PPR3_decomposed(T, A)</code></pre><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>A::SpIntMat: (# nodes) x (# simplices) adjacency matrix</li><li>dense_solve::Bool=false: whether or not to use a dense solver. If the network is tiny, then it might be worth setting this option to true.</li><li>α::Float64=0.85: teleportation parameter for PageRank</li></ul><p>returns a tuple (scores<em>comb, scores</em>curl, scores<em>grad, scores</em>harm, S<em>comb, S</em>curl, S<em>grad, S</em>harm, vec<em>edge</em>map)</p><ul><li>scores_comb::Vector{Float64}: scores for &quot;combined&quot; simplicial personalized PageRank</li><li>scores_curl::Vector{Float64}: scores for curl component</li><li>scores_grad::Vector{Float64}: scores for gradient component</li><li>scores_harm::Vector{Float64}: scores for harmonic component</li><li>S_comb::SpFltMat: a sparse matrix, where S[x, y] is the combined simplicial PPR score for edge x with respect to edge y</li><li>S<em>curl::SpFltMat: same as S</em>comb but for the curl component</li><li>S<em>grad::SpFltMat: same as S</em>comb but for the gradient component</li><li>S<em>harm::SpFltMat: same as S</em>comb but for the harmonic component</li><li>vec<em>edge</em>map::Array{Int64,2}: 2 x (# edges) map of indices for S<em>comb, S</em>curl, S<em>grad, S</em>harm, such that the vec<em>edge</em>map[:, i] is the edge for ith index in the matrix</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.SpFltMat" href="#ScHoLP.SpFltMat"><code>ScHoLP.SpFltMat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>SpFltMat</strong></p><p>const SpFltMat = SparseMatrixCSC{Float64,Int64}</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.SpIntMat" href="#ScHoLP.SpIntMat"><code>ScHoLP.SpIntMat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>SpIntMat</strong></p><p>const SpIntMat = SparseMatrixCSC{Float64,Int64}</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.SpMat" href="#ScHoLP.SpMat"><code>ScHoLP.SpMat</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><strong>SpMat</strong></p><p>const SpMat = Union{SpIntMat,SpFltMat}</p></div></div></section><pre><code class="language-none">ScHoLP.WEAK</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.adamic_adar3" href="#ScHoLP.adamic_adar3"><code>ScHoLP.adamic_adar3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>adamic_adar3</strong></p><p>Returns the 3-way Adamic-Adar score for a list of triangles.</p><p>adamic<em>adar3(triangles::Vector{NTuple{3,Int64}}, common</em>nbrs::NbrSetMap, degrees::Vector{Int64})</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>common<em>nbrs::NbrSetMap: the common neighbors map attained from common</em>neighbors_map()</li><li>degrees::Vector{Int64}: degree of each node in the projected graph</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.arithmetic_mean" href="#ScHoLP.arithmetic_mean"><code>ScHoLP.arithmetic_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>arithmetic_mean</strong></p><p>Returns the arithmetic mean of the weights of the edges of a list of triangles.</p><p>arithmetic_mean(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat)</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.backbone</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.basic_matrices" href="#ScHoLP.basic_matrices"><code>ScHoLP.basic_matrices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>basic_matrices</strong></p><p>Computes some simple matrices associated with a dataset.</p><p>basic_matrices(simplices::Vector{Int64}, nverts::Vector{Int64})</p><p>Input parameters:</p><ul><li>simplices::Vector{Int64}: the contiguous vector of simplices</li><li>nverts::Vector{Int64}: the vector of sizes of simplices</li></ul><p>Outputs tuple (A, At, B):</p><ul><li>A::SpIntMat: (# nodes) x (# simplices) adjacency matrix</li><li>At::SpIntMat: the transpose of A</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul></div></div><div><div><p><strong>basic_matrices</strong></p><p>Computes some simple matrices associated with a dataset.</p><p>basic_matrices(dataset::HONData)</p><p>Input parameter:</p><ul><li>dataset::HONData: the dataset</li></ul><p>Outputs tuple (A, At, B):</p><ul><li>A::SpIntMat: (# nodes) x (# simplices) adjacency matrix</li><li>At::SpIntMat: the transpose of A</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.basic_summary_statistics" href="#ScHoLP.basic_summary_statistics"><code>ScHoLP.basic_summary_statistics</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>basic<em>summary</em>statistics</strong></p><p>Prints some basic summary statistics of the dataset.</p><p>basic<em>summary</em>statistics(dataset::String)</p><p>Input parameter:</p><ul><li>dataset::HONData: The dataset.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.bipartite_graph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.closure_type_counts3" href="#ScHoLP.closure_type_counts3"><code>ScHoLP.closure_type_counts3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>closure<em>type</em>counts3</strong></p><p>Computes the closure probabilities of all 3-node configurations. The closure probability is the fraction of instances of open configurations appearing in the first 80% of the timestamped simplices that appear in a simplex in the final 20%.</p><p>closure<em>type</em>counts3(dataset::HONData, initial_cutoff::Int64=100)</p><p>Input parameters:</p><ul><li>dataset::String: The dataset name.</li><li>initial<em>cutoff::Int64=100: Initial cutoff of the simplices. If this is set to less than 100, then the data is first preprocessed to only consider the first initial</em>cutoff percentage of the data.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.closure_type_counts4" href="#ScHoLP.closure_type_counts4"><code>ScHoLP.closure_type_counts4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>closure<em>type</em>counts4</strong></p><p>Computes the closure probabilities of all 4-node configurations that contain at least one triangle. The closure probability is the fraction of instances of open configurations appearing in the first 80% of the timestamped simplices that appear in a simplex in the final 20%.</p><p>closure<em>type</em>counts4(dataset::HONData, initial_cutoff::Int64=100)</p><p>Input parameters:</p><ul><li>dataset::HONData: The dataset.</li><li>initial<em>cutoff::Int64=100: Initial cutoff of the simplices. If this is set to less than 100, then the data is first preprocessed to only consider the first initial</em>cutoff percentage of the data. </li></ul></div></div></section><pre><code class="language-none">ScHoLP.collect_lifecycles</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.common3" href="#ScHoLP.common3"><code>ScHoLP.common3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>common3</strong></p><p>Returns the number of common 4th neighbors of a list of triangles.</p><p>common3(triangles::Vector{NTuple{3,Int64}}, common_nbrs::NbrSetMap)</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>common<em>nbrs::NbrSetMap: the common neighbors map attained from common</em>neighbors_map()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.common_nbr_set" href="#ScHoLP.common_nbr_set"><code>ScHoLP.common_nbr_set</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return common neighbors of two nodes u and v. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.common_neighbors_map" href="#ScHoLP.common_neighbors_map"><code>ScHoLP.common_neighbors_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>common<em>neighbors</em>map</strong></p><p>Construct a map where a key is an edge in the graph B participating in at least one triangle of interest and a value is the vector of common neighbors of the end points of the edge. The graph B is assumed to be undirected, and the keys are ordered by the pair with smallest ID first.</p><p>common<em>neighbors</em>map(B::SpIntMat, triangles::Vector{NTuple{3,Int64}})</p><p>Input parameters:</p><ul><li>B::SpIntMat: the graph</li><li>triangles::Vector{NTuple{3,Int64}}: the triangles of interest</li></ul></div></div></section><pre><code class="language-none">ScHoLP.configuration_sizes_preserved</code></pre><pre><code class="language-none">ScHoLP.data_size_cutoff</code></pre><pre><code class="language-none">ScHoLP.earliest_activity</code></pre><pre><code class="language-none">ScHoLP.enum_open_triangles</code></pre><pre><code class="language-none">ScHoLP.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.example_dataset" href="#ScHoLP.example_dataset"><code>ScHoLP.example_dataset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>example_dataset</strong></p><p>Returns one of the example datasets.</p><p>example_dataset(dataset::String)</p><p>Input parameter:</p><ul><li>dataset::String: one of &quot;email-Enron&quot;, &quot;contact-primary-school&quot;, &quot;contact-high-school&quot;, &quot;example1&quot;, or &quot;example2&quot;</li></ul></div></div></section><pre><code class="language-none">ScHoLP.full_solve</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.generalized_means" href="#ScHoLP.generalized_means"><code>ScHoLP.generalized_means</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>generalized_means</strong></p><p>Computes the generalized p-means of the weights of the edges of a list of triangles. The generalized mean of 3 values is</p><div>\[M_p(x, y, z) = ((x^p + y^p + z^p) / 3)^{1/p}\]</div><p>generalized_means(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat, ps::Float64=[-Inf; collect(-4:0.25:4); Inf])</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li><li>ps::Vector{Float64}=[-Inf; collect(-4:0.25:4); Inf]: the values of p for which to compute the means</li></ul><p>Returns a matrix of size length(triangles) x length(ps) of the scores for the various generalized means.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.geometric_mean" href="#ScHoLP.geometric_mean"><code>ScHoLP.geometric_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>geometric_mean</strong></p><p>Returns the geometric mean of the weights of the edges of a list of triangles.</p><p>geometric_mean(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat)</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.grad_and_curl" href="#ScHoLP.grad_and_curl"><code>ScHoLP.grad_and_curl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>grad<em>and</em>curl</strong></p><p>Construct the gradient and curl operators.</p><p>grad<em>and</em>curl(A::SpIntMat, At::SpIntMat, B::SpIntMat)</p><p>Input parameters:</p><ul><li>A::SpIntMat: (# nodes) x (# simplices) adjacency matrix</li><li>At::SpIntMat: the transpose of A</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul><p>returns tuple (grad, curl, edge_map):</p><ul><li>grad::SpIntMat: gradient operator (as a matrix)</li><li>curl::SpIntMat: curl operator (as a matrix)</li><li>edge_map::Dict{NTuple{2,Int64}, Int64}: maps an a sorted edge tuple to an index for the matrices</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.harmonic_mean" href="#ScHoLP.harmonic_mean"><code>ScHoLP.harmonic_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>harmonic_mean</strong></p><p>Returns the harmonic mean of the weights of the edges of a list of triangles.</p><p>harmonic_mean(triangles::Vector{NTuple{3,Int64}}, B::SpIntMat)</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>B::SpIntMat: Projected graph as a Sparse integer matrix, where B[i, j] is the number of times that i and j co-appear in a simplex.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.hodge_normalization</code></pre><pre><code class="language-none">ScHoLP.include</code></pre><pre><code class="language-none">ScHoLP.initialize_type_counter3</code></pre><pre><code class="language-none">ScHoLP.initialize_type_counter4</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.interval_overlaps" href="#ScHoLP.interval_overlaps"><code>ScHoLP.interval_overlaps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>interval_overlaps</strong></p><p>interval_overlaps(dataset::HONData)</p><p>Compute the number of active interval overlaps in open triangles.</p><p>dataset::HONData     The dataset.</p></div></div></section><pre><code class="language-none">ScHoLP.intervals</code></pre><pre><code class="language-none">ScHoLP.iterative_solve</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.jaccard3" href="#ScHoLP.jaccard3"><code>ScHoLP.jaccard3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>jaccard3</strong></p><p>Returns the 3-way Jaccard index of the neighbor lists of nodes in triangle.</p><p>jaccard3(triangles::Vector{NTuple{3,Int64}}, common_nbrs::NbrSetMap, degrees::Vector{Int64})</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>common<em>nbrs::NbrSetMap: the common neighbors map attained from common</em>neighbors_map()</li><li>degrees::Vector{Int64}: degree of each node in the projected graph</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.make_sparse_ones" href="#ScHoLP.make_sparse_ones"><code>ScHoLP.make_sparse_ones</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>make<em>sparse</em>ones</strong></p><p>Returns a new sparse matrix with the same non-zero pattern as the input but where all non-zeros are set to 1.</p><p>make<em>sparse</em>ones(A::SpIntMat)</p><p>Input parameter:</p><ul><li>A::SpIntMat: a sparse matrix</li></ul></div></div></section><pre><code class="language-none">ScHoLP.neighbor_pairs</code></pre><pre><code class="language-none">ScHoLP.neighbors</code></pre><pre><code class="language-none">ScHoLP.new_closures</code></pre><pre><code class="language-none">ScHoLP.newly_closed_types3</code></pre><pre><code class="language-none">ScHoLP.newly_closed_types4</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.num_open_closed_triangles" href="#ScHoLP.num_open_closed_triangles"><code>ScHoLP.num_open_closed_triangles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>num<em>open</em>closed_triangles</strong></p><p>Computes the number of open and closed triangles in a dataset.</p><p>num<em>open</em>closed_triangles(data::HONData)</p><p>Input parameter:</p><ul><li>data::HONData: the dataset</li></ul><p>Outputs tuple (no, nc):</p><ul><li>no: number of open triangles</li><li>nc: number of closed triangles</li></ul></div></div></section><pre><code class="language-none">ScHoLP.nz_row_inds</code></pre><pre><code class="language-none">ScHoLP.nz_row_vals</code></pre><pre><code class="language-none">ScHoLP.open_types3</code></pre><pre><code class="language-none">ScHoLP.open_types4</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.pref_attach3" href="#ScHoLP.pref_attach3"><code>ScHoLP.pref_attach3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>pref_attach3</strong></p><p>Returns the preferential attachment score for a degree vector</p><p>pref_attach3(triangles::Vector{NTuple{3,Int64}}, degrees::Vector{Int64})</p><p>The score of triangle (i, j, k) is degrees[i] * degrees[j] * degrees[k]</p><p>Input parameters:</p><ul><li>triangles::Vector{NTuple{3,Int64}}: The vector of triangles upon which to compute scores.</li><li>degrees::Vector{Int64}: the degree vector</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.process_lifecycles" href="#ScHoLP.process_lifecycles"><code>ScHoLP.process_lifecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>process_lifecycles</strong></p><p>Process all lifecycles in a given dataset.</p><p>process_lifecycles(data::HONData)</p><p>Input parameters:</p><ul><li>data::HONData: The dataset</li></ul><p>Returns a tuple (closed<em>transitions, open</em>transitions)</p><ul><li>closed_transitions::Array{Int64,2}: matrix whose (i, j) entry is the number of transitions from configuration j to configuration i, out of all triples of nodes that eventually simplicially close</li><li>open_transitions::Array{Int64,2}: matrix whose (i, j) entry is the number of transitions from configuration j to configuration i, out of all triples of nodes that do not simplicially close</li></ul></div></div></section><pre><code class="language-none">ScHoLP.process_trail</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.proj_graph_degree_order" href="#ScHoLP.proj_graph_degree_order"><code>ScHoLP.proj_graph_degree_order</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Ordering of nodes by their degree </p></div></div></section><pre><code class="language-none">ScHoLP.remove_diagonal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.simplex_degree_order" href="#ScHoLP.simplex_degree_order"><code>ScHoLP.simplex_degree_order</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Ordering of nodes by the number of simplices in which they appear </p></div></div></section><pre><code class="language-none">ScHoLP.simplex_key3</code></pre><pre><code class="language-none">ScHoLP.simplex_key4</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.sorted_tuple" href="#ScHoLP.sorted_tuple"><code>ScHoLP.sorted_tuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Turns 3 integers into a sorted tuple. </p></div></div><div><div><p>Turns 4 integers into a sorted tuple. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.split_data" href="#ScHoLP.split_data"><code>ScHoLP.split_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>split_data</strong></p><p>Split data by timestamps into quantiles specified by quantile1 and quantile2. Returns a 4-tuple (old<em>simps, old</em>nverts, new<em>simps, new</em>nverts), where (old<em>simps, old</em>nverts) are the data in the quantile [0, quantile1] and (new<em>simps, new</em>nverts) are the data in the quantile (quantile1, quantile2].</p><p>split_data(simplices::Vector{Int64}, nverts::Vector{Int64},            times::Vector{Int64}, quantile1::Int64,            quantile2::Int64)</p><p>Input parameters:</p><ul><li>simplices::Vector{Int64}: contiguous vector of simplices from dataset</li><li>nverts::Vector{Int64}: vector of simplex sizes from dataset</li><li>times::Vector{Int64}: vector of timestamps of simplices</li><li>quantile1::Int64: first quantile</li><li>quantile2::Int64: second quantile</li></ul><p>Returns a tuple (old<em>simps, old</em>nverts, new<em>simps, new</em>nverts):</p><ul><li>old_simplices::Vector{Int64}: simplices in quantile1</li><li>old<em>nverts::Vector{Int64}: sizes of simplices in old</em>simplices</li><li>new_simplices::Vector{Int64}: simplices between quantile1 and quantile 2</li><li>new<em>nverts::Vector{Int64}: sizes of simplices in new</em>simplices</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.summary_statistics" href="#ScHoLP.summary_statistics"><code>ScHoLP.summary_statistics</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>summary_statistics</strong></p><p>Computes several statistics about the dataset.</p><p>summary_statistics(dataset::HONData)</p><p>Input parameter:</p><ul><li>dataset::HONData: The dataset.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.tetrahedron_closed</code></pre><pre><code class="language-none">ScHoLP.triangle_closed</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScHoLP.triangle_counts" href="#ScHoLP.triangle_counts"><code>ScHoLP.triangle_counts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>triangle_counts</strong></p><p>Counts the number of times each simplicial triangle appears in the data. This function is expensive and requires storage on the order of the number of triangles. Returns a counter that takes a sorted triple of indices as a key and returns the count of that triangle.</p><p>triangle_counts(data::HONData)</p><p>Input parameters:</p><ul><li>data::HONData: The data.</li></ul></div></div></section><pre><code class="language-none">ScHoLP.window_data</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
