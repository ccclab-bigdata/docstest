<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BasisFunctionExpansions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BasisFunctionExpansions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BasisFunctionExpansions.AB_covariance</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.BasisFunctionApproximation" href="#BasisFunctionExpansions.BasisFunctionApproximation"><code>BasisFunctionExpansions.BasisFunctionApproximation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BasisFunctionApproximation(y::Vector, v, bfe::BasisFunctionExpansion, λ = 0)</code></pre><p>Perform parameter identification to identify the Function <code>y = ϕ(v)</code>, where <code>ϕ</code> is a Basis Function Expansion of type <code>bfe</code>. <code>λ</code> is an optional regularization parameter (L² regularization).</p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.BasisFunctionExpansion</code></pre><pre><code class="language-none">BasisFunctionExpansions.BasisFunctionExpansions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.LPVSS" href="#BasisFunctionExpansions.LPVSS"><code>BasisFunctionExpansions.LPVSS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Convenience tyoe for estimation of LPV state-space models</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.MultiDiagonalRBFE" href="#BasisFunctionExpansions.MultiDiagonalRBFE"><code>BasisFunctionExpansions.MultiDiagonalRBFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>MultiDiagonalRBFE</code> has different diagonal covariance matrices for all basis functions See also <code>MultiUniformRBFE</code>, which has the same covariance matrix for all basis functions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.MultiRBFE" href="#BasisFunctionExpansions.MultiRBFE"><code>BasisFunctionExpansions.MultiRBFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>MultiRBFE</code> has different diagonal covariance matrices for all basis functions See also <code>MultiUniformRBFE</code>, which has the same covariance matrix for all basis functions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.MultiUniformRBFE" href="#BasisFunctionExpansions.MultiUniformRBFE"><code>BasisFunctionExpansions.MultiUniformRBFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>MultiUniformRBFE</code> has the same diagonal covariance matrix for all basis functions See also <code>MultiDiagonalRBFE</code>, which has different covariance matrices for all basis functions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.UniformRBFE" href="#BasisFunctionExpansions.UniformRBFE"><code>BasisFunctionExpansions.UniformRBFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Uniform RBFE has the same variance for all basis functions</p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.basis_activation_func</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.basis_activation_func_automatic" href="#BasisFunctionExpansions.basis_activation_func_automatic"><code>BasisFunctionExpansions.basis_activation_func_automatic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis_activation_func_automatic(v,Nv,normalize,coulomb)</code></pre><p>Returns a func v-&gt;ϕ(v) ∈ ℜ(Nv) that calculates the activation of <code>Nv</code> basis functions spread out to cover v nicely. If coulomb is true, then we get twice the number of basis functions, <code>2Nv</code>, with a hard split at <code>v=0</code> (useful to model Coulomb friction). coulomb is not yet fully supported for all expansion types.</p><p>The keyword <code>normalize</code> determines weather or not basis function activations are normalized to sum to one for each datapoint, normalized networks tend to extrapolate better <a href="http://ieeexplore.ieee.org/document/728118/">&quot;The normalized radial basis function neural network&quot; DOI: 10.1109/ICSMC.1998.728118</a></p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.eval</code></pre><pre><code class="language-none">BasisFunctionExpansions.fit_ss</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.getARXregressor" href="#BasisFunctionExpansions.getARXregressor"><code>BasisFunctionExpansions.getARXregressor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb)</code></pre><p>Returns a shortened output signal <code>y</code> and a regressor matrix <code>A</code> such that the least-squares ARX model estimate of order <code>na,nb</code> is <code>y\A</code></p><p>Return a regressor matrix used to fit an ARX model on, e.g., the form <code>A(z)y = B(z)f(u)</code> with output <code>y</code> and input <code>u</code> where the order of autoregression is <code>na</code> and the order of input moving average is <code>nb</code></p><p><strong>Example</strong></p><p>Here we test the model with the Function <code>f(u) = √(|u|)</code></p><pre><code class="language-julia">A     = [1,2*0.7*1,1] # A(z) coeffs
B     = [10,5] # B(z) coeffs
u     = randn(100) # Simulate 100 time steps with Gaussian input
y     = filt(B,A,sqrt.(abs.(u)))
yr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2
bfe   = MultiUniformRBFE(A,[2,2,4,4,4], normalize=true)
bfa   = BasisFunctionApproximation(yr,A,bfe, 1e-3)
e_bfe = √(mean((yr - bfa(A)).^2)) # (0.005174261451622258)
plot([yr bfa(A)], lab=[&quot;Signal&quot; &quot;Prediction&quot;])</code></pre><p>See README (<code>?BasisFunctionExpansions</code>) for more details</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.getARregressor" href="#BasisFunctionExpansions.getARregressor"><code>BasisFunctionExpansions.getARregressor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">y,A = getARregressor(y::AbstractVector,na::Integer)</code></pre><p>Returns a shortened output signal <code>y</code> and a regressor matrix <code>A</code> such that the least-squares AR model estimate of order <code>na</code> is <code>y\A</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.get_centers" href="#BasisFunctionExpansions.get_centers"><code>BasisFunctionExpansions.get_centers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vc,γ = get_centers(bounds, Nv, coulomb=false, coulombdims=0)</code></pre></div></div></section><pre><code class="language-none">BasisFunctionExpansions.get_centers_Kmeans</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.get_centers_automatic" href="#BasisFunctionExpansions.get_centers_automatic"><code>BasisFunctionExpansions.get_centers_automatic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vc,γ = get_centers_automatic(v::AbstractVector,Nv::Int,coulomb = false)</code></pre></div></div><div><div><pre><code class="language-none">vc,γ = get_centers_automatic(v::AbstractMatrix, Nv::AbstractVector{Int}, coulomb=false, coulombdims=0)</code></pre></div></div></section><pre><code class="language-none">BasisFunctionExpansions.get_centers_multi</code></pre><pre><code class="language-none">BasisFunctionExpansions.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.matricesn" href="#BasisFunctionExpansions.matricesn"><code>BasisFunctionExpansions.matricesn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>size(y) = (T-1, n)</p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.mega_regressor</code></pre><pre><code class="language-none">BasisFunctionExpansions.meshgrid</code></pre><pre><code class="language-none">BasisFunctionExpansions.normalized_squared_exponential</code></pre><pre><code class="language-none">BasisFunctionExpansions.normalized_squared_exponential_coulomb</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.output_variance" href="#BasisFunctionExpansions.output_variance"><code>BasisFunctionExpansions.output_variance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">output_variance(model::LPVSS, x::AbstractVector, u::AbstractVector, v=[x u])</code></pre><p>Return a vector of prediction variances. Note, no covariance between dimensions in output is provided</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.predict" href="#BasisFunctionExpansions.predict"><code>BasisFunctionExpansions.predict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">predict(model::LPVSS, x::AbstractMatrix, u, v=[x u])</code></pre><p>If no <code>v</code> provided, return a prediction of the output <code>x&#39;</code> given the state <code>x</code> and input <code>u</code> This function is called when a <code>model::LPVSS</code> object is called like <code>model(x,u)</code></p><p>Provided <code>v</code>, return a prediction of the output <code>x&#39;</code> given the state <code>x</code>, input <code>u</code> and scheduling parameter <code>v</code></p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.quadform</code></pre><pre><code class="language-none">BasisFunctionExpansions.shorten_v</code></pre><pre><code class="language-none">BasisFunctionExpansions.squared_exponential</code></pre><pre><code class="language-none">BasisFunctionExpansions.squared_exponential_coulomb</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.testdata" href="#BasisFunctionExpansions.testdata"><code>BasisFunctionExpansions.testdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x,xm,u,n,m = testdata(T,r=1)</code></pre><p>Generate <code>T</code> time steps of state-space data where the A-matrix changes from <code>A = [0.95 0.1; 0 0.95]</code> to <code>A = [0.5 0.05; 0 0.5]</code> at time <code>t=T÷2</code> <code>x,xm,u,n,m</code> = (state,noisy state, input, statesize, inputsize) <code>r</code> is the seed to the random number generator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BasisFunctionExpansions.toeplitz" href="#BasisFunctionExpansions.toeplitz"><code>BasisFunctionExpansions.toeplitz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">toeplitz{T}(c::AbstractArray{T},r::AbstractArray{T})</code></pre><p>Returns a Toeplitz matrix where <code>c</code> is the first column and <code>r</code> is the first row.</p></div></div></section><pre><code class="language-none">BasisFunctionExpansions.γ2σ</code></pre><pre><code class="language-none">BasisFunctionExpansions.σ2γ</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
