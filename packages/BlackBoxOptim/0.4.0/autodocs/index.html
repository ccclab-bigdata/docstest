<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BlackBoxOptim.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BlackBoxOptim.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BlackBoxOptim.ADE_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AbstractIndividual" href="#BlackBoxOptim.AbstractIndividual"><code>BlackBoxOptim.AbstractIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The point of the <code>SearchSpace</code>.</p><p>The abstract type. It allows different actual implementations to be used, e.g <code>Vector</code> or <code>SubArray</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.AbstractPopulationMatrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AdaptiveDiffEvoParameters" href="#BlackBoxOptim.AdaptiveDiffEvoParameters"><code>BlackBoxOptim.AdaptiveDiffEvoParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Specific data and functions for adaptation An Adaptive DE typically changes parameters of the search dynamically. This is typically done in the <code>tell!()</code> function when we know if the trial vector was better than the target vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AdaptiveDiffEvoRandBin" href="#BlackBoxOptim.AdaptiveDiffEvoRandBin"><code>BlackBoxOptim.AdaptiveDiffEvoRandBin</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An Adaptive DE crossover operator changes <code>cr</code> and <code>f</code> parameters of the search dynamically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AdaptiveDiffEvoRandBin1" href="#BlackBoxOptim.AdaptiveDiffEvoRandBin1"><code>BlackBoxOptim.AdaptiveDiffEvoRandBin1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An Adaptive DE crossover operator changes <code>cr</code> and <code>f</code> parameters of the search dynamically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AdaptiveDiffEvoRandBin2" href="#BlackBoxOptim.AdaptiveDiffEvoRandBin2"><code>BlackBoxOptim.AdaptiveDiffEvoRandBin2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An Adaptive DE crossover operator changes <code>cr</code> and <code>f</code> parameters of the search dynamically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Archive" href="#BlackBoxOptim.Archive"><code>BlackBoxOptim.Archive</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Archive</code> saves information about promising solutions during an optimization run.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ArchiveOutput" href="#BlackBoxOptim.ArchiveOutput"><code>BlackBoxOptim.ArchiveOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for archive-specific component of the <code>OptimizationResults</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ArchivedIndividual" href="#BlackBoxOptim.ArchivedIndividual"><code>BlackBoxOptim.ArchivedIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for individuals stored in <code>Archive</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.AskTellOptimizer" href="#BlackBoxOptim.AskTellOptimizer"><code>BlackBoxOptim.AskTellOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base abstract class for optimizers that perform <code>ask()</code> → ..eval fitness.. → <code>tell!()</code> sequence at each step.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.BimodalCauchy" href="#BlackBoxOptim.BimodalCauchy"><code>BlackBoxOptim.BimodalCauchy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A mixture of 2 Cauchy distributions. Random values are further constrained to <code>[0.0, 1.0]</code> range either by truncating the initial unconstrained value or by generating new random value until it fits the range.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.BlackBoxOptim</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.BorgMOEA" href="#BlackBoxOptim.BorgMOEA"><code>BlackBoxOptim.BorgMOEA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Borg MOEA algorithm.</p><p>Based on Hadka &amp; Reed, &quot;Borg: An Auto-Adaptive Many-Objective Evolutionary Computing Framework&quot;, Evol. Comp. 2013</p></div></div></section><pre><code class="language-none">BlackBoxOptim.BorgMOEA_DefaultParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.CEC09_UP8" href="#BlackBoxOptim.CEC09_UP8"><code>BlackBoxOptim.CEC09_UP8</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>CEC09 Unconstrained Problem 8 objective function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.CEC09_UP8_PF" href="#BlackBoxOptim.CEC09_UP8_PF"><code>BlackBoxOptim.CEC09_UP8_PF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>CEC09 Unconstrained Problem 8 Pareto Frontier. Parameterized by t[1]=f[1] and t[2]=f[2].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.CEC09_Unconstrained_Set" href="#BlackBoxOptim.CEC09_Unconstrained_Set"><code>BlackBoxOptim.CEC09_Unconstrained_Set</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>The collection of CEC09 unconstrained multi-objective problems.</p><p>See http://dces.essex.ac.uk/staff/zhang/MOEAcompetition/cec09testproblem0904.pdf.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Candidate" href="#BlackBoxOptim.Candidate"><code>BlackBoxOptim.Candidate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Candidate solution to the problem.</p><p>Candidate can be either a member of the population (<code>index</code> &gt; 0) or a standalone solution (<code>index</code> == -1). Can carry additional information, like the <code>tag</code> or the genetic operator applied (<code>extra</code>).</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ChannelRef</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ComplexFitnessScheme" href="#BlackBoxOptim.ComplexFitnessScheme"><code>BlackBoxOptim.ComplexFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Complex-valued fitness.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ConstantDirectionGen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ContinuousSearchSpace" href="#BlackBoxOptim.ContinuousSearchSpace"><code>BlackBoxOptim.ContinuousSearchSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fixed-dimensional space, each dimension has a continuous range of valid values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.CrossoverOperator" href="#BlackBoxOptim.CrossoverOperator"><code>BlackBoxOptim.CrossoverOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Modifies <code>NC</code> &quot;children&quot; by transferring some information from <code>NP</code> &quot;parents&quot;.</p><p>The concrete implementations must provide <code>apply!()</code> method.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.DEX_DefaultOptions</code></pre><pre><code class="language-none">BlackBoxOptim.DE_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.DXNESOpt" href="#BlackBoxOptim.DXNESOpt"><code>BlackBoxOptim.DXNESOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DX-NES: distance-weighted extensions of xNES by Fukushima et al.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.DXNES_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.DefaultParameters" href="#BlackBoxOptim.DefaultParameters"><code>BlackBoxOptim.DefaultParameters</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Default parameters for all convenience methods that are exported to the end user.</p><p>See <code>OptRunController</code> for the description.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.DictChain" href="#BlackBoxOptim.DictChain"><code>BlackBoxOptim.DictChain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An ordered set of dicts that are examined one after another to find the parameter value. Returns nothing if no param setting is found in any of the dicts.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.DiffEvoCrossoverOperator</code></pre><pre><code class="language-none">BlackBoxOptim.DiffEvoOpt</code></pre><pre><code class="language-none">BlackBoxOptim.DiffEvoRandBin</code></pre><pre><code class="language-none">BlackBoxOptim.DiffEvoRandBin1</code></pre><pre><code class="language-none">BlackBoxOptim.DiffEvoRandBin2</code></pre><pre><code class="language-none">BlackBoxOptim.DirectSearchProbabilisticDescentDefaultParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.DirectSearcher" href="#BlackBoxOptim.DirectSearcher"><code>BlackBoxOptim.DirectSearcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A supertype for all generating set searcher-like algorithms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.DirectionGenerator" href="#BlackBoxOptim.DirectionGenerator"><code>BlackBoxOptim.DirectionGenerator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DirectionGenerator</code> generates the search directions to use at each step of a GSS search.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.DummyMethodOutput</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EMPTY_PARAMS" href="#BlackBoxOptim.EMPTY_PARAMS"><code>BlackBoxOptim.EMPTY_PARAMS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>The default placeholder value for parameters argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EmbeddingOperator" href="#BlackBoxOptim.EmbeddingOperator"><code>BlackBoxOptim.EmbeddingOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Embeds(projects) the individual into the search space.</p><p>The concrete implementations must provide <code>apply!()</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsBoxArchive" href="#BlackBoxOptim.EpsBoxArchive"><code>BlackBoxOptim.EpsBoxArchive</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ϵ-box archive saves only the solutions that are not ϵ-box dominated by any other solutions in the archive.</p><p>It also counts the number of candidate solutions that have been added and how many ϵ-box progresses have been made.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsBoxArchiveFrontierIterator" href="#BlackBoxOptim.EpsBoxArchiveFrontierIterator"><code>BlackBoxOptim.EpsBoxArchiveFrontierIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterates occupied elements of the <code>archive.frontier</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsBoxArchiveOutput" href="#BlackBoxOptim.EpsBoxArchiveOutput"><code>BlackBoxOptim.EpsBoxArchiveOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>EpsBoxArchive</code>-specific components of the optimization results.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.EpsBoxArchive_DefaultParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsBoxDominanceFitnessScheme" href="#BlackBoxOptim.EpsBoxDominanceFitnessScheme"><code>BlackBoxOptim.EpsBoxDominanceFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>EpsBoxDominanceFitnessScheme</code> defines ϵ-box dominance for <code>N</code>-tuple (<code>N</code>≧1) fitnesses. It operates with fitnesses of type <code>IndexedTupleFitness</code>.</p><p><code>aggregator::AGG</code> is a function mapping tuple fitness to a single numerical value. Might be used for comparisons (or not, depending on the setup). Always used when printing fitness vectors though.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsBoxFrontierIndividual" href="#BlackBoxOptim.EpsBoxFrontierIndividual"><code>BlackBoxOptim.EpsBoxFrontierIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Individual stored in <code>EpsBoxArchive</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.EpsDominanceFitnessScheme" href="#BlackBoxOptim.EpsDominanceFitnessScheme"><code>BlackBoxOptim.EpsDominanceFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ϵ-dominance for <code>N</code>-tuple (<code>N</code>≧1) fitnesses.</p><p><code>aggregator::AGG</code> is a function mapping tuple fitness to a single numerical value. Might be used for comparisons (or not, depending on the setup). Always used when printing fitness vectors though.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Evaluator" href="#BlackBoxOptim.Evaluator"><code>BlackBoxOptim.Evaluator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The abstract base for types that manage the objective function evaluation. <code>P</code> is the optimization problem it is used for.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ExponentialNaturalEvolutionStrategyOpt" href="#BlackBoxOptim.ExponentialNaturalEvolutionStrategyOpt"><code>BlackBoxOptim.ExponentialNaturalEvolutionStrategyOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for a family of NES methods that represent population as</p><pre><code class="language-none">x = μ + σ B⋅Z,</code></pre><p>where <code>B</code> is an exponential of some symmetric matrix <code>lnB</code>, <code>tr(lnB)==0.0</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FAGeneticOperatorsMixture" href="#BlackBoxOptim.FAGeneticOperatorsMixture"><code>BlackBoxOptim.FAGeneticOperatorsMixture</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Frequency-adapting genetic operators mixture.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FitIndividual" href="#BlackBoxOptim.FitIndividual"><code>BlackBoxOptim.FitIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A point in the problem&#39;s search space with the corresponding fitness value.</p><p><code>F</code> is the original problem&#39;s fitness type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FitPopulation" href="#BlackBoxOptim.FitPopulation"><code>BlackBoxOptim.FitPopulation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The default implementation of <code>PopulationWithFitness{F}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FitnessScheme" href="#BlackBoxOptim.FitnessScheme"><code>BlackBoxOptim.FitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>FitnessScheme</code> defines how fitness vectors/values are compared, presented and aggregated. <code>Fitness</code> represents the score of one and the same individual on one or a set of evaluations. A scheme is a specific way to consider the scores in a coherent way. Type parameter <code>F</code> specifies the type of fitness values.</p><p><code>FitnessScheme</code> could also be used as a function that defines the fitness ordering, i.e. <code>fs(x, y) == true</code> iff fitness <code>x</code> is better than <code>y</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FixedDimensionSearchSpace" href="#BlackBoxOptim.FixedDimensionSearchSpace"><code>BlackBoxOptim.FixedDimensionSearchSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SearchSpace</code> with a fixed finite number of dimensions. Applicable to the vast majority of problems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FixedGeneticOperatorsMixture" href="#BlackBoxOptim.FixedGeneticOperatorsMixture"><code>BlackBoxOptim.FixedGeneticOperatorsMixture</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Randomly selects the genetic operator from the vector according to its weight and applies it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FrequencyAdapter" href="#BlackBoxOptim.FrequencyAdapter"><code>BlackBoxOptim.FrequencyAdapter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>FrequencyAdapter</code> adapts the frequencies with which a set of values/strategies/methods should be applied/tried in an optimization problem. It is based on the <code>Adaptive Coordinate Frequencies</code> scheme described in:</p><p>T. Glasmachers and U. Dogan, &quot;Accelerated Coordinate Descent with Adaptive Coordinate Frequencies&quot;, 2013.</p><p>but generalized so that it can support more than the adaptation of only the coordinates in a Coordinate Descent scheme. The things that are being adapted are identified by integers in 1:n, with n being the main parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FrontierIndividual" href="#BlackBoxOptim.FrontierIndividual"><code>BlackBoxOptim.FrontierIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Individual representing the solution from the Pareto set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FrontierIndividualWrapper" href="#BlackBoxOptim.FrontierIndividualWrapper"><code>BlackBoxOptim.FrontierIndividualWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Wrapper for <code>FrontierIndividual</code> that allows easy access to the problem fitness.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FunctionBasedProblem" href="#BlackBoxOptim.FunctionBasedProblem"><code>BlackBoxOptim.FunctionBasedProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>OptimizationProblem</code> with the objective function defined by some Julia <code>Function</code> and search space.</p><p>Optionally, a known optimal value could be provided to terminate the optimization once it is reached.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.FunctionBasedProblemFamily" href="#BlackBoxOptim.FunctionBasedProblemFamily"><code>BlackBoxOptim.FunctionBasedProblemFamily</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Family of <code>FunctionBasedProblem</code> optimization problems parameterized by the number of search space dimensions.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.GSSDefaultParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.GeneratingSetSearcher" href="#BlackBoxOptim.GeneratingSetSearcher"><code>BlackBoxOptim.GeneratingSetSearcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Generating Set Search as described in Kolda2003:   Kolda, Tamara G., Robert Michael Lewis, and Virginia Torczon. &quot;Optimization   by direct search: New perspectives on some classical and modern methods.&quot;   SIAM review 45.3 (2003): 385-482.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.GeneticOperator" href="#BlackBoxOptim.GeneticOperator"><code>BlackBoxOptim.GeneticOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract genetic operator that transforms individuals in the population.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.GeneticOperatorsMixture" href="#BlackBoxOptim.GeneticOperatorsMixture"><code>BlackBoxOptim.GeneticOperatorsMixture</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A mixture of genetic operators, use <code>next()</code> to choose the next operator from the mixture.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.GibbsMutationOperator" href="#BlackBoxOptim.GibbsMutationOperator"><code>BlackBoxOptim.GibbsMutationOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Provides <code>apply()</code> operator that mutates one specified dimension of a parameter vector.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.Hartman3</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman3_A</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman3_P</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman3_alpha</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman6</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman6_A</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman6_P</code></pre><pre><code class="language-none">BlackBoxOptim.Hartman6_alpha</code></pre><pre><code class="language-none">BlackBoxOptim.HatCompare</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Hypersurface" href="#BlackBoxOptim.Hypersurface"><code>BlackBoxOptim.Hypersurface</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><span>$(N-1)$</span>-dimensional manifold in <span>$N$</span>-dimensional space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.IGD" href="#BlackBoxOptim.IGD"><code>BlackBoxOptim.IGD</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">IGD(A::Vector{NTuple{N,F}}, B::Vector{NTuple{N,F}}, [two_sided=true])</code></pre><p>The average Euclidean distance from the points of <code>A</code> to the points of <code>B</code>.</p></div></div><div><div><pre><code class="language-none">IGD(ref::Hypersurface, sol::Vector{FitIndividual}, [two_sided=true])</code></pre><p>Average Euclidean distance from the exact Pareto frontier of the problem (<code>ref</code>) to the solution (<code>sol</code>) produced by the optimization method. If <code>two_sided</code> is on, returns the maximum of <code>IGD(sol, ref)</code> and <code>IGD(nondominated(ref), sol)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.IndexedTupleFitness" href="#BlackBoxOptim.IndexedTupleFitness"><code>BlackBoxOptim.IndexedTupleFitness</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ϵ-box indexed representation of the N-tuple fitness.</p><p>Used together with <code>EpsBoxDominanceFitnessScheme</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Individual" href="#BlackBoxOptim.Individual"><code>BlackBoxOptim.Individual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The point of the <code>SearchSpace</code>.</p><p>The concrete type that could be used for storage.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.IndividualsSelector" href="#BlackBoxOptim.IndividualsSelector"><code>BlackBoxOptim.IndividualsSelector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Selects the individuals from the population.</p><p>The concrete implementations must provide <code>select()</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.JadeFunctionSet" href="#BlackBoxOptim.JadeFunctionSet"><code>BlackBoxOptim.JadeFunctionSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>JADE collection of optimization problems.</p><p>We skip (for now) <code>f12</code> and <code>f13</code> in the JADE paper since they are penalized functions which are quite nonstandard. We also skip <code>f8</code> since we are unsure about its proper implementation.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.MaximizingFitnessScheme</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MethodNames" href="#BlackBoxOptim.MethodNames"><code>BlackBoxOptim.MethodNames</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Names of optimization methods accepted by <code>bboptimize()</code>, <code>:Method</code> keyword argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MethodOutput" href="#BlackBoxOptim.MethodOutput"><code>BlackBoxOptim.MethodOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for method-specific component of the <code>OptimizationResults</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.MinimizationProblemFamily</code></pre><pre><code class="language-none">BlackBoxOptim.MinimizingFitnessScheme</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MirroredRandomDirectionGen" href="#BlackBoxOptim.MirroredRandomDirectionGen"><code>BlackBoxOptim.MirroredRandomDirectionGen</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Generate half of the directions randomly and then mirrors by negating them.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.MultiObjectiveMethodNames</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MultiObjectiveMethods" href="#BlackBoxOptim.MultiObjectiveMethods"><code>BlackBoxOptim.MultiObjectiveMethods</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Multi-objective optimization methods accepted by <code>bboptimize()</code>.</p><p>The values are the method initialization routines or types derived from <code>Optimizer</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MutationClock" href="#BlackBoxOptim.MutationClock"><code>BlackBoxOptim.MutationClock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Mutation clock operator is a more efficient way to mutate vectors than to generate a random value per variable in the vectors. It instead generates the number of variables to skip until the next mutation. Then it uses a sub-mutation operator to do the actual mutation. This is based on the paper:     Deb and Deb (2012), &quot;Analyzing Mutation Schemes for Real-Parameter Genetic Algorithms&quot; but we use a Poisson distribution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MutationOperator" href="#BlackBoxOptim.MutationOperator"><code>BlackBoxOptim.MutationOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Modifies (mutates) one individual.</p><p>The concrete implementations must provide <code>apply!()</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.MutationWrapper" href="#BlackBoxOptim.MutationWrapper"><code>BlackBoxOptim.MutationWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Wraps the mutation operator, so that it could be used as crossover operator.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.NES_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.NO_GEN_OP" href="#BlackBoxOptim.NO_GEN_OP"><code>BlackBoxOptim.NO_GEN_OP</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Placeholder for no-effect genetic operations.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.NaturalEvolutionStrategyOpt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.NoMutation" href="#BlackBoxOptim.NoMutation"><code>BlackBoxOptim.NoMutation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>MutationOperator</code> that does nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.OptController" href="#BlackBoxOptim.OptController"><code>BlackBoxOptim.OptController</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Optimization Controller.</p><p>Applies specific optimization method to a given problem. Supports restarts and modifying parameter of the method between runs. <code>runcontrollers</code> field maintains the list of <code>OptRunController</code> instances applied so far.</p><p>See <code>OptRunController</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.OptRunController" href="#BlackBoxOptim.OptRunController"><code>BlackBoxOptim.OptRunController</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Optimization Run Controller. Manages problem optimization using the specified method.</p><p>See <code>OptController</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.OptimizationProblem" href="#BlackBoxOptim.OptimizationProblem"><code>BlackBoxOptim.OptimizationProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The base abstract type for all optimization problems. <code>FS</code> is a type of a problem&#39;s <code>FitnessScheme</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.OptimizationResults" href="#BlackBoxOptim.OptimizationResults"><code>BlackBoxOptim.OptimizationResults</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The results of running optimization method.</p><p>Returned by <code>run!(oc::OptRunController)</code>. Should be compatible (on the API level) with the <code>Optim</code> package. See <code>make_opt_results()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Optimizer" href="#BlackBoxOptim.Optimizer"><code>BlackBoxOptim.Optimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base abstract class for black-box optimization algorithms.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.PCX_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PM_DefaultOptions" href="#BlackBoxOptim.PM_DefaultOptions"><code>BlackBoxOptim.PM_DefaultOptions</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Default parameters for <code>PolynomialMutation</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParallelEvaluationState" href="#BlackBoxOptim.ParallelEvaluationState"><code>BlackBoxOptim.ParallelEvaluationState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Current state of fitness function evaluation for the vector of candidates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParallelEvaluator" href="#BlackBoxOptim.ParallelEvaluator"><code>BlackBoxOptim.ParallelEvaluator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fitness evaluator that distributes candidates fitness calculation among several worker processes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParallelEvaluatorWorker" href="#BlackBoxOptim.ParallelEvaluatorWorker"><code>BlackBoxOptim.ParallelEvaluatorWorker</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Internal data for the worker process of the parallel evaluator.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ParallelEvaluatorWorkerRef</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParamBounds" href="#BlackBoxOptim.ParamBounds"><code>BlackBoxOptim.ParamBounds</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The valid range of values for a specific dimension in a <code>SearchSpace</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Parameters" href="#BlackBoxOptim.Parameters"><code>BlackBoxOptim.Parameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The parameters storage type for <code>BlackBoxOptim</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParamsDict" href="#BlackBoxOptim.ParamsDict"><code>BlackBoxOptim.ParamsDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The default parameters storage in <code>BlackBoxOptim</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParamsDictChain" href="#BlackBoxOptim.ParamsDictChain"><code>BlackBoxOptim.ParamsDictChain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An ordered set of dicts that are examined one after another to find the parameter value. Returns nothing if no param setting is found in any of the dicts.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParentCentricCrossover" href="#BlackBoxOptim.ParentCentricCrossover"><code>BlackBoxOptim.ParentCentricCrossover</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parent Centric Crossover (PCX).</p><p>See     Deb, K., Anand, A., and Joshi, D., &quot;A Computationally Efficient Evolutionary Algorithm for Real-Parameter Optimization,&quot; Evolutionary Computation, vol. 10, no. 4, pp. 371-395, 2002.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ParetoFitnessScheme" href="#BlackBoxOptim.ParetoFitnessScheme"><code>BlackBoxOptim.ParetoFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Pareto dominance for <code>N</code>-tuple (<code>N</code>≧1) fitnesses.</p><p><code>aggregator::AGG</code> is a function mapping tuple fitness to a single numerical value. Might be used for comparisons (or not, depending on the setup). Always used when printing fitness vectors though.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PolynomialMutation" href="#BlackBoxOptim.PolynomialMutation"><code>BlackBoxOptim.PolynomialMutation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Polynomial mutation as presented in the paper:     Deb and Deb (2012), &quot;Analyzing Mutation Schemes for Real-Parameter Genetic Algorithms&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.Population" href="#BlackBoxOptim.Population"><code>BlackBoxOptim.Population</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The base abstract type for the collection of candidate solutions in the population-based optimization methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PopulationMatrix" href="#BlackBoxOptim.PopulationMatrix"><code>BlackBoxOptim.PopulationMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The simplest <code>Population</code> implementation – a matrix of floats, each column is an individual.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PopulationOptimizer" href="#BlackBoxOptim.PopulationOptimizer"><code>BlackBoxOptim.PopulationOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for population-based optimization methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PopulationOptimizerOutput" href="#BlackBoxOptim.PopulationOptimizerOutput"><code>BlackBoxOptim.PopulationOptimizerOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PopulationOptimizer</code>-specific components of the <code>OptimizationResults</code>. Stores the final population.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.PopulationWithFitness" href="#BlackBoxOptim.PopulationWithFitness"><code>BlackBoxOptim.PopulationWithFitness</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The base abstract types for population that also stores the candidates fitness.</p><p><code>F</code> is the fitness type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ProblemEvaluator" href="#BlackBoxOptim.ProblemEvaluator"><code>BlackBoxOptim.ProblemEvaluator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Default implementation of the <code>Evaluator</code>.</p><p><code>FP</code> is the original problem&#39;s fitness type <code>FA</code> is the fitness type actually stored by the archive.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ProblemFamily" href="#BlackBoxOptim.ProblemFamily"><code>BlackBoxOptim.ProblemFamily</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for problem families.</p><p>It is an abstraction for problem parameterization (e.g by the number of the search space dimensions) that allows to instantiate <code>OptimizationProblem</code> for the concrete parameters.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.Problems</code></pre><pre><code class="language-none">BlackBoxOptim.RISDefaultParameters</code></pre><pre><code class="language-none">BlackBoxOptim.RSDefaultParameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.RadiusLimitedSelector" href="#BlackBoxOptim.RadiusLimitedSelector"><code>BlackBoxOptim.RadiusLimitedSelector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>IndividualsSelector</code> that implements a &quot;trivial geography&quot; similar to Spector and Kline (2006) by first sampling an individual randomly and then selecting additional individuals for the same tournament within a certain deme of limited size (<code>radius</code>) for the sub-sequent individuals in the population.</p><p>The version we implement here is from:     I. Harvey, &quot;The Microbial Genetic Algorithm&quot;, in Advances in Artificial Life     Darwin Meets von Neumann, Springer, 2011. The original paper is:     Spector, L., and J. Klein. 2005. Trivial Geography in Genetic Programming.     In Genetic Programming Theory and Practice III, edited by T. Yu, R.L. Riolo,     and B. Worzel, pp. 109-124. Boston, MA: Kluwer Academic Publishers.     http://faculty.hampshire.edu/lspector/pubs/trivial-geography-toappear.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.RandomBound" href="#BlackBoxOptim.RandomBound"><code>BlackBoxOptim.RandomBound</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Embedding operator that randomly samples between parent&#39;s value and the nearest parameter boundary to get the new valid value if target&#39;s parameter is out-of-bounds.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.RandomDirectionGen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.RandomSearcher" href="#BlackBoxOptim.RandomSearcher"><code>BlackBoxOptim.RandomSearcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Optimize by randomly generating the candidates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.RangePerDimSearchSpace" href="#BlackBoxOptim.RangePerDimSearchSpace"><code>BlackBoxOptim.RangePerDimSearchSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SearchSpace</code> defined by a range of valid values for each dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.RatioFitnessScheme" href="#BlackBoxOptim.RatioFitnessScheme"><code>BlackBoxOptim.RatioFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>In <code>RatioFitnessScheme</code> the fitness values can be ranked on a ratio scale so pairwise comparisons are not required. The default scale used is the aggregate of the fitness components.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ResamplingInheritanceMemeticSearcher</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ResamplingMemeticSearcher" href="#BlackBoxOptim.ResamplingMemeticSearcher"><code>BlackBoxOptim.ResamplingMemeticSearcher</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The variants of the memetic search algorithms RS and RIS. However, we have modified them since they did not give very good performance when implemented as described in the papers below. Possibly, the papers are not unambigous and I have misinterpreted something from them...</p><p>The &quot;Resampling Search&quot; (RS) memetic algorithm is described in:</p><pre><code class="language-none">F. Caraffini, F. Neri, M. Gongora and B. N. Passow, &quot;Re-sampling Search: A
Seriously Simple Memetic Approach with a High Performance&quot;, 2013.</code></pre><p>and its close sibling &quot;Resampling Inheritance Search&quot; (RIS) is described in:</p><pre><code class="language-none">F. Caraffini, F. Neri, B. N. Passow and G. Iacca, &quot;Re-sampled Inheritance
Search: High Performance Despite the Simplicity&quot;, 2013.</code></pre></div></div></section><pre><code class="language-none">BlackBoxOptim.SBX_DefaultOptions</code></pre><pre><code class="language-none">BlackBoxOptim.SPSADefaultParameters</code></pre><pre><code class="language-none">BlackBoxOptim.SPX_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ScalarFitnessScheme" href="#BlackBoxOptim.ScalarFitnessScheme"><code>BlackBoxOptim.ScalarFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Float64</code>-valued scalar fitness scheme. The boolean type parameter <code>MIN</code> specifies if smaller fitness values are better (<code>true</code>) or worse (<code>false</code>).</p></div></div></section><pre><code class="language-none">BlackBoxOptim.Schaffer1Family</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SearchSpace" href="#BlackBoxOptim.SearchSpace"><code>BlackBoxOptim.SearchSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>SearchSpace</code> defines the valid candidate points that could be considered in a search/optimization. The base abstract class has very few restrictions and can allow varying number of dimensions etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SeparableNESOpt" href="#BlackBoxOptim.SeparableNESOpt"><code>BlackBoxOptim.SeparableNESOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Separable Natural Evolution Strategy (sNES) optimizer.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.Shekel10</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel10_A</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel10_C</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel5</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel5_A</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel5_C</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel7</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel7_A</code></pre><pre><code class="language-none">BlackBoxOptim.Shekel7_C</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ShiftedAndBiasedProblem" href="#BlackBoxOptim.ShiftedAndBiasedProblem"><code>BlackBoxOptim.ShiftedAndBiasedProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>TransformedProblem</code> subclass that shifts the objective argument and offsets the value: <span>$f(x - xshift) + fitshift$</span> → min/max, <span>$x$</span> ∈ <span>$X$</span> (<span>$X$</span> stays intact).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SimpleSelector" href="#BlackBoxOptim.SimpleSelector"><code>BlackBoxOptim.SimpleSelector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simple random <code>IndividualsSelector</code>.</p><p>The probabilties of all candidates are equal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SimplexCrossover" href="#BlackBoxOptim.SimplexCrossover"><code>BlackBoxOptim.SimplexCrossover</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simplex Crossover (SPX).</p><p><code>ϵ&gt;0</code> controls how the original simplex is inflated, <code>ϵ=1</code> means no inflation.</p><p>See Tsutsui, Yamamura &amp; Higuchi &quot;Multi-parent recombination with simplex crossover in real coded genetic algorithms&quot;, 1999, Proc. of the Genetic and Evolutionary Computation Conference</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SimulatedBinaryCrossover" href="#BlackBoxOptim.SimulatedBinaryCrossover"><code>BlackBoxOptim.SimulatedBinaryCrossover</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simulated Binary Crossover (SBX).</p><p>See Deb&amp;Agrawal &quot;Simulated binary crossover for continuous search space&quot;, 1994, Complex Systems</p></div></div></section><pre><code class="language-none">BlackBoxOptim.SimultaneousPerturbationSA2</code></pre><pre><code class="language-none">BlackBoxOptim.SingleObjectiveMethodNames</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SingleObjectiveMethods" href="#BlackBoxOptim.SingleObjectiveMethods"><code>BlackBoxOptim.SingleObjectiveMethods</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Single objective optimization methods accepted by <code>bboptimize()</code>.</p><p>The values are the method initialization routines or types derived from <code>Optimizer</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.SteppingOptimizer" href="#BlackBoxOptim.SteppingOptimizer"><code>BlackBoxOptim.SteppingOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Optimizers derived from <code>SteppingOptimizer</code> implement classical iterative optimization scheme <code>step!()</code> → <code>step!()</code> → …</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.StochasticApproximationOptimizer" href="#BlackBoxOptim.StochasticApproximationOptimizer"><code>BlackBoxOptim.StochasticApproximationOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AskTellOptimizer</code> that utilizes randomization to generate the candidates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TopListArchive" href="#BlackBoxOptim.TopListArchive"><code>BlackBoxOptim.TopListArchive</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Archive that maintains a top list of the best performing (best fitness) candidates seen so far.</p><p>The two last best fitness values could be used to estimate a confidence interval for how much improvement potential there is.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TopListArchiveOutput" href="#BlackBoxOptim.TopListArchiveOutput"><code>BlackBoxOptim.TopListArchiveOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>TopListArchive</code>-specific components of the optimization results.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TopListFitness" href="#BlackBoxOptim.TopListFitness"><code>BlackBoxOptim.TopListFitness</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fitness as stored in <code>TopListArchive</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TopListIndividual" href="#BlackBoxOptim.TopListIndividual"><code>BlackBoxOptim.TopListIndividual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Individual stored in <code>TopListArchive</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TournamentSelector" href="#BlackBoxOptim.TournamentSelector"><code>BlackBoxOptim.TournamentSelector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tournament selector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TransformedProblem" href="#BlackBoxOptim.TransformedProblem"><code>BlackBoxOptim.TransformedProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>TransformedProblem{FS, P}</code> is an abstract class for optimization problems derived from some original problem of type <code>P</code> by introducing a few changes.</p><p>The concrete derived types must implement:</p><ul><li><code>objfunc()</code> method</li><li><code>fitness_scheme()</code> and <code>search_space()</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.TupleFitnessScheme" href="#BlackBoxOptim.TupleFitnessScheme"><code>BlackBoxOptim.TupleFitnessScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for tuple-based fitness schemes.</p><p>Type parameters:</p><ul><li><code>N</code> is the number of the objectives</li><li><code>F</code> is the type of each objective</li><li><code>FA</code> is the actual type of the multi-objective fitness</li><li><code>MIN</code> if objectives should be minimized or maximized</li><li><code>AGG</code> the type of aggregator</li></ul></div></div></section><pre><code class="language-none">BlackBoxOptim.UNDX_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.UniformMutation" href="#BlackBoxOptim.UniformMutation"><code>BlackBoxOptim.UniformMutation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Uniform mutation of a parameter vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.UnimodalNormalDistributionCrossover" href="#BlackBoxOptim.UnimodalNormalDistributionCrossover"><code>BlackBoxOptim.UnimodalNormalDistributionCrossover</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Unimodal Normal Distribution Crossover (UNDX).</p><p>See     Kita, H., Ono, I., and Kobayashi, S., &quot;Multi-parental Extension of the Unimodal Normal Distribution Crossover for Real-coded Genetic Algorithms,&quot; Proceedings of the 1999 Congress on Evolutionary Computation, pp. 1581-1588, 1999.     Deb, K., Anand, A., and Joshi, D., &quot;A Computationally Efficient Evolutionary Algorithm for Real-Parameter Optimization,&quot; Evolutionary Computation, vol. 10, no. 4, pp. 371-395, 2002.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.Utils</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.XNESOpt" href="#BlackBoxOptim.XNESOpt"><code>BlackBoxOptim.XNESOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>xNES</code> method.</p><p>Nice but scales badly with increasing dimensions.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.XNES_DefaultOptions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ZERO_SEARCH_SPACE" href="#BlackBoxOptim.ZERO_SEARCH_SPACE"><code>BlackBoxOptim.ZERO_SEARCH_SPACE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>0-dimensional search space. Could be used as a placeholder for optional <code>SearchSpace</code> parameters.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.abort!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.accept_candi!" href="#BlackBoxOptim.accept_candi!"><code>BlackBoxOptim.accept_candi!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Put the candidate back into the pool and copy the values into the corresponding individual of the population (<code>candi.index</code> should be set).</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ackley</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.acquire_candi" href="#BlackBoxOptim.acquire_candi"><code>BlackBoxOptim.acquire_candi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">acquire_candi(pop::FitPopulation[, {ix::Int, candi::Candidate}])</code></pre><p>Get individual from a pool, or create one if the pool is empty. By default the individual is not initialized, but if <code>ix</code> or <code>candi</code> is specified, the corresponding fields of the new candidate are set to the given values.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.acquire_candis</code></pre><pre><code class="language-none">BlackBoxOptim.acquire_mutant</code></pre><pre><code class="language-none">BlackBoxOptim.adaptive_de_rand_1_bin</code></pre><pre><code class="language-none">BlackBoxOptim.adaptive_de_rand_1_bin_radiuslimited</code></pre><pre><code class="language-none">BlackBoxOptim.adaptive_diffevo</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.add_candidate!" href="#BlackBoxOptim.add_candidate!"><code>BlackBoxOptim.add_candidate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_candidate!(a::TopListArchive, fitness::F, candidate[, tag=0][, num_fevals=-1])</code></pre><p>Add a candidate with a fitness to the archive (if it is good enough).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.adjust!" href="#BlackBoxOptim.adjust!"><code>BlackBoxOptim.adjust!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Adjust the internal parameters of the genetic operator <code>op</code> taking into account the fitness change.</p><p>The default implementation does nothing.</p></div></div><div><div><p>Adjust the parameters of the method after the candidate evaluation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.aggregate" href="#BlackBoxOptim.aggregate"><code>BlackBoxOptim.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Aggregation is just the identity function for scalar fitness.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.apply</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.apply!" href="#BlackBoxOptim.apply!"><code>BlackBoxOptim.apply!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Default implementation of <code>apply!()</code> for operators mixture.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.archive</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.archived_fitness" href="#BlackBoxOptim.archived_fitness"><code>BlackBoxOptim.archived_fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">archived_fitness(fit, a::Archive)</code></pre><p>Converts given fitness <code>fit</code> to the format used by the archive <code>a</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ask" href="#BlackBoxOptim.ask"><code>BlackBoxOptim.ask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ask(ato::AskTellOptimizer)</code></pre><p>Ask for a new candidate solution to be generated, and a list of individuals it should be ranked with.</p><p>The individuals are supplied as an array of tuples with the individual and its index.</p><p>See also <code>tell!()</code></p></div></div></section><pre><code class="language-none">BlackBoxOptim.assign_distance_weights!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.assign_weights!" href="#BlackBoxOptim.assign_weights!"><code>BlackBoxOptim.assign_weights!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assign_weights!(weights, rankedCandidates, sortedWeights)</code></pre><p>Assigns the candidate <code>weights</code> according to the candidate index. <code>rankedCandidates</code> are ranked by their fitness, <code>sortedWeights</code> are the corresponding weights.</p><p>Returns candidate weights sorted by the individual&#39;s index in the population.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.bboptimize" href="#BlackBoxOptim.bboptimize"><code>BlackBoxOptim.bboptimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bboptimize(problem[; parameters::Associative, kwargs...])</code></pre><p>Solve given optimization <code>problem</code>.</p><p>See <code>setup_problem()</code> for the types of <code>problem</code> supported. In addition, the <code>problem</code> could be <code>OptController</code> containing the results of the previous optimization runs.</p><p>The optimization method parameters could be specified via <code>kwargs</code> or <code>parameters</code> arguments.</p><p>Returns <code>OptimizationResults</code> instance.</p><p>See also <code>bbsetup()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.bbsetup" href="#BlackBoxOptim.bbsetup"><code>BlackBoxOptim.bbsetup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bbsetup(problem[; parameters::Associative, kwargs...])</code></pre><p>Set up optimization method for a given problem.</p><p>See <code>setup_problem()</code> for the types of <code>problem</code> supported. The optimization method parameters could be specified via <code>kwargs</code> or <code>parameters</code> arguments.</p><p>Returns the initialized <code>OptController</code> instance. To actually run the method call <code>bboptimize()</code> or <code>run!()</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.best_candidate</code></pre><pre><code class="language-none">BlackBoxOptim.best_fitness</code></pre><pre><code class="language-none">BlackBoxOptim.best_of</code></pre><pre><code class="language-none">BlackBoxOptim.borg_moea</code></pre><pre><code class="language-none">BlackBoxOptim.calc_initial_step_size</code></pre><pre><code class="language-none">BlackBoxOptim.calc_sigma_learnrate_for_nes</code></pre><pre><code class="language-none">BlackBoxOptim.calc_sigma_learnrate_for_snes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.calculate_evol_path_params" href="#BlackBoxOptim.calculate_evol_path_params"><code>BlackBoxOptim.calculate_evol_path_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate the parameters for evolutionary path.</p><p>Returns the tuple:</p><ul><li>moving threshold</li><li>path discount</li><li>current Z scale</li></ul></div></div></section><pre><code class="language-none">BlackBoxOptim.candi_pool_size</code></pre><pre><code class="language-none">BlackBoxOptim.candidate_type</code></pre><pre><code class="language-none">BlackBoxOptim.capacity</code></pre><pre><code class="language-none">BlackBoxOptim.chain</code></pre><pre><code class="language-none">BlackBoxOptim.check_and_create_search_space</code></pre><pre><code class="language-none">BlackBoxOptim.check_epsbox_ϵ</code></pre><pre><code class="language-none">BlackBoxOptim.check_stop_condition</code></pre><pre><code class="language-none">BlackBoxOptim.check_valid!</code></pre><pre><code class="language-none">BlackBoxOptim.cigar</code></pre><pre><code class="language-none">BlackBoxOptim.cigtab</code></pre><pre><code class="language-none">BlackBoxOptim.compare_optimizers</code></pre><pre><code class="language-none">BlackBoxOptim.compass_search_directions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.count_dict_report" href="#BlackBoxOptim.count_dict_report"><code>BlackBoxOptim.count_dict_report</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Report the number of times each key was encountered in a count <code>dict</code>.</p><p>Returns a percentage dict calculated while iterating over the counted items.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.crossover_parameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.de_rand_1_bin" href="#BlackBoxOptim.de_rand_1_bin"><code>BlackBoxOptim.de_rand_1_bin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The most used <code>DE/rand/1/bin</code> variant of differential evolution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.de_rand_1_bin_radiuslimited" href="#BlackBoxOptim.de_rand_1_bin_radiuslimited"><code>BlackBoxOptim.de_rand_1_bin_radiuslimited</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The most used <code>DE/rand/1/bin</code> variant with &quot;local geography&quot; via radius-limited sampling.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.de_rand_2_bin</code></pre><pre><code class="language-none">BlackBoxOptim.de_rand_2_bin_radiuslimited</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.deceptive_cuccu2011" href="#BlackBoxOptim.deceptive_cuccu2011"><code>BlackBoxOptim.deceptive_cuccu2011</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generator for the family of deceptive functions from the Cuccu2011 paper on novelty-based restarts. We have vectorized it to allow more than 1D versions. The Cuccu2011 paper uses the following values for</p><pre><code class="language-none">(l, w) = [(5, 0),  (15, 0),  (30, 0),
          (5, 2),  (15, 2),  (30, 2),
          (5, 10), (15, 10), (30, 10)]</code></pre><p>and notes that <code>(15, 2)</code> and <code>(30, 2)</code> are the most difficult instances.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.deceptive_cuccu2011_15_2</code></pre><pre><code class="language-none">BlackBoxOptim.deceptive_cuccu2011_30_2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.delta_fitness" href="#BlackBoxOptim.delta_fitness"><code>BlackBoxOptim.delta_fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delta_fitness(a::TopListArchive)</code></pre><p>The difference between the current best fitness and the former best fitness.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.deltas</code></pre><pre><code class="language-none">BlackBoxOptim.describe</code></pre><pre><code class="language-none">BlackBoxOptim.diameters</code></pre><pre><code class="language-none">BlackBoxOptim.diffevo</code></pre><pre><code class="language-none">BlackBoxOptim.direct_search_probabilistic_descent</code></pre><pre><code class="language-none">BlackBoxOptim.directions_for_k</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.distance" href="#BlackBoxOptim.distance"><code>BlackBoxOptim.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">distance(a::NTuple{N,F}, b::NTuple{N,F})</code></pre><p>Euclidean distance from <code>a</code> to <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.distance_to_optimum" href="#BlackBoxOptim.distance_to_optimum"><code>BlackBoxOptim.distance_to_optimum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the distance from a fitness value to the optimum/best known fitness value.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.dxnes</code></pre><pre><code class="language-none">BlackBoxOptim.elapsed_time</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ellipsoid" href="#BlackBoxOptim.ellipsoid"><code>BlackBoxOptim.ellipsoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Schwefel&#39;s ellipsoid.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.elliptic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.energy_tsallis1996" href="#BlackBoxOptim.energy_tsallis1996"><code>BlackBoxOptim.energy_tsallis1996</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>From section 3, page 7, of Tsallis1996 paper:     Tsallis and Stariolo, &quot;Generalized simulated annealing&quot;, Physica A, 1996. available from http://www.if.ufrgs.br/~stariolo/publications/TsSt96<em>PhysA233</em>395_1996.pdf the original paper used this as a 4-dimensional problem but here it is generalized.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.eval</code></pre><pre><code class="language-none">BlackBoxOptim.evaluator</code></pre><pre><code class="language-none">BlackBoxOptim.evolve</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.evolved_pair" href="#BlackBoxOptim.evolved_pair"><code>BlackBoxOptim.evolved_pair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Post-process the evolved pair.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.example_problems</code></pre><pre><code class="language-none">BlackBoxOptim.f_calls</code></pre><pre><code class="language-none">BlackBoxOptim.f_minimum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.feasible" href="#BlackBoxOptim.feasible"><code>BlackBoxOptim.feasible</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Projects a given point onto the search space coordinate-wise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fill_block!" href="#BlackBoxOptim.fill_block!"><code>BlackBoxOptim.fill_block!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Fill the block of methods to apply.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness" href="#BlackBoxOptim.fitness"><code>BlackBoxOptim.fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fitness(x, p::OptimizationProblem)</code></pre><p>Evaluates the fitness of a candidate.</p></div></div><div><div><pre><code class="language-none">fitness(indi::FitIndividual)</code></pre><p>Gets the fitness of the individual.</p></div></div><div><div><pre><code class="language-none">fitness(params::Individual, e::ProblemEvaluator, tag::Int=0)</code></pre><p>Evaluate the fitness and implicitly update the archive with the provided parameters and calculated fitness.</p><p>Returns the fitness in the archived format.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.fitness_eltype</code></pre><pre><code class="language-none">BlackBoxOptim.fitness_history_csv_header</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness_improvement_potential" href="#BlackBoxOptim.fitness_improvement_potential"><code>BlackBoxOptim.fitness_improvement_potential</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fitness_improvement_potential(a::Archive[, p = 0.01])</code></pre><p>Calculate the solution improvement potential.</p><p>The percentage improvement that can be expected from the current fitness value at a given <code>p</code>-value. In theory, an optimization run should be terminated when this value is very small, i.e. there is little improvement potential left in the run.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.fitness_improvement_ratio</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness_is_within_ftol" href="#BlackBoxOptim.fitness_is_within_ftol"><code>BlackBoxOptim.fitness_is_within_ftol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Checks if the current best fitness is within the given range of a known best fitness. By default the best fitness is unknown.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.fitness_scheme</code></pre><pre><code class="language-none">BlackBoxOptim.fitness_scheme_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness_shaping_utilities_linear" href="#BlackBoxOptim.fitness_shaping_utilities_linear"><code>BlackBoxOptim.fitness_shaping_utilities_linear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fitness_shaping_utilities_linear(n)</code></pre><p>Calculate the <code>n</code>-dimensional fitness shaping utilities vector using the &quot;steps&quot; method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness_shaping_utilities_log" href="#BlackBoxOptim.fitness_shaping_utilities_log"><code>BlackBoxOptim.fitness_shaping_utilities_log</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fitness_shaping_utilities_log(n)</code></pre><p>Calculate the <code>n</code>-dimensional fitness shaping utilities vector using the &quot;log&quot; method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.fitness_type" href="#BlackBoxOptim.fitness_type"><code>BlackBoxOptim.fitness_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fitness_type(fs::FitnessScheme)
fitness_type(fs_type::Type{FitnessScheme})</code></pre><p>Get the type of fitness values for fitness scheme <code>fs</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.fixed_dim_problem</code></pre><pre><code class="language-none">BlackBoxOptim.flatten</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.format_fitness" href="#BlackBoxOptim.format_fitness"><code>BlackBoxOptim.format_fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">format_fitness(fit, [problem::OptimizationProblem])</code></pre><p>Format fitness into a string. Calls <code>show_fitness()</code> under the hood.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.frequencies</code></pre><pre><code class="language-none">BlackBoxOptim.general_stop_reason</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.generate" href="#BlackBoxOptim.generate"><code>BlackBoxOptim.generate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate(surf::Hypersurface, fs::EpsBoxDominanceFitnessScheme, param_step = 0.1*fs.ϵ)</code></pre><p>Generate the points of the hypersurface using the discretization defined by ϵ-box fitness schema.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.griewank</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.hartman" href="#BlackBoxOptim.hartman"><code>BlackBoxOptim.hartman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generic function for <code>Hartman N</code> problem family.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.hartman3" href="#BlackBoxOptim.hartman3"><code>BlackBoxOptim.hartman3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Hartman 3D</code> is a multi-minima, non-separable test problem. Our implementation is based on: http://www.sfu.ca/~ssurjano/hart3.html However, we get a different global minima than the one stated on that page. The minima should be -3.86278 but we get a different one so use that in the problem spec:</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.hartman6" href="#BlackBoxOptim.hartman6"><code>BlackBoxOptim.hartman6</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Hartman 6D</code> is a multi-minima, non-separable test problem. Our implementation is based on: http://www.sfu.ca/~ssurjano/hart6.html</p></div></div></section><pre><code class="language-none">BlackBoxOptim.has_converged</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.hat_compare" href="#BlackBoxOptim.hat_compare"><code>BlackBoxOptim.hat_compare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check whether <code>f1</code> or <code>f2</code> fitness is better.</p><p>Returns</p><ul><li><code>-1</code> if <code>f1</code> is better than <code>f2</code></li><li><code>1</code> if <code>f2</code> is better than <code>f1</code></li><li><code>0</code> if <code>f1</code> and <code>f2</code> are equal.</li></ul></div></div></section><pre><code class="language-none">BlackBoxOptim.hat_compare_pareto</code></pre><pre><code class="language-none">BlackBoxOptim.hat_compare_ϵ</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.hat_compare_ϵ_box" href="#BlackBoxOptim.hat_compare_ϵ_box"><code>BlackBoxOptim.hat_compare_ϵ_box</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a tuple of <code>u</code> and <code>v</code> comparison:</p><ul><li><code>-1</code>: u≺v</li><li><code>0</code>: u and v non-dominating</li><li><code>1</code>: u≻v</li></ul><p>and whether <code>u</code> index fully matches <code>v</code> index.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.include</code></pre><pre><code class="language-none">BlackBoxOptim.index</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.ini_xnes_B" href="#BlackBoxOptim.ini_xnes_B"><code>BlackBoxOptim.ini_xnes_B</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Identity for generic search space </p></div></div><div><div><p>Calculates the initial <span>$log B$</span> matrix for <code>xNES</code> based on the deltas of each dimension.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.init_rng!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.instantiate" href="#BlackBoxOptim.instantiate"><code>BlackBoxOptim.instantiate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">instantiate(family::FunctionBasedProblemFamily, ndim::Int)</code></pre><p>Construct <code>FunctionBasedProblem</code> with the given number of dimensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.instantiate_search_space" href="#BlackBoxOptim.instantiate_search_space"><code>BlackBoxOptim.instantiate_search_space</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">instantiate(family::FunctionBasedProblemFamily, ndim::Int)</code></pre><p>Construct search space for <code>FunctionBasedProblem</code> with the given number of dimensions.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.is_better</code></pre><pre><code class="language-none">BlackBoxOptim.is_minimizing</code></pre><pre><code class="language-none">BlackBoxOptim.is_stopped</code></pre><pre><code class="language-none">BlackBoxOptim.is_worse</code></pre><pre><code class="language-none">BlackBoxOptim.isinterrupted</code></pre><pre><code class="language-none">BlackBoxOptim.isnafitness</code></pre><pre><code class="language-none">BlackBoxOptim.isrunning</code></pre><pre><code class="language-none">BlackBoxOptim.isstarted</code></pre><pre><code class="language-none">BlackBoxOptim.isstopped</code></pre><pre><code class="language-none">BlackBoxOptim.iteration_converged</code></pre><pre><code class="language-none">BlackBoxOptim.iterations</code></pre><pre><code class="language-none">BlackBoxOptim.kwargs2dict</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.last_fitness" href="#BlackBoxOptim.last_fitness"><code>BlackBoxOptim.last_fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">last_fitness(e::Evaluator)</code></pre><p>Get the fitness of the last evaluated candidate.</p><p>Leads to nicer code if we can first test if it is better or worse than existing candidates and only want the fitness itself if the criteria fulfilled.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.last_top_fitness</code></pre><pre><code class="language-none">BlackBoxOptim.lastrun</code></pre><pre><code class="language-none">BlackBoxOptim.local_search</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.magnitude_class" href="#BlackBoxOptim.magnitude_class"><code>BlackBoxOptim.magnitude_class</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get a tuple of the sign and the magnitude of the value rounded to the first digit. Used for archiving candidates separately for each magnitude class.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.make_evaluator" href="#BlackBoxOptim.make_evaluator"><code>BlackBoxOptim.make_evaluator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Create <code>Evaluator</code> instance for a given <code>problem</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.maxs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.merge_fitness_histories" href="#BlackBoxOptim.merge_fitness_histories"><code>BlackBoxOptim.merge_fitness_histories</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">merge_fitness_histories(histories)</code></pre><p>Merge the collection of multiple fitness histories and calculate the <code>min</code>, <code>max</code>, <code>avg</code> and <code>median</code> values for fitness and FIR (fitness improvement ratio) at each point where the fitness is changing.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.minimization_problem</code></pre><pre><code class="language-none">BlackBoxOptim.minimum</code></pre><pre><code class="language-none">BlackBoxOptim.mins</code></pre><pre><code class="language-none">BlackBoxOptim.nafitness</code></pre><pre><code class="language-none">BlackBoxOptim.name</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.next" href="#BlackBoxOptim.next"><code>BlackBoxOptim.next</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next(fa::FrequencyAdapter)</code></pre><p>Give the index of the method that should be used at the next iteration.</p><p><code>FrequencyAdapter</code> maintains a block of randomly shuffled methods. The function takes the next available method in the block. If the block is empty, it is repopulated.</p><p>The methods are randomly shuffled each time the block is regenerated, since we need to know their effectiveness at every period of the optimization process.</p></div></div><div><div><pre><code class="language-none">next(fa::FixedGeneticOperatorsMixture)</code></pre><p>Gets the random genetic operator from the mixture.</p><p>The probability to select an operator is proportional to its weight.</p><p>Returns a tuple of the genetic operator and its index in the mix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.next_candidate!" href="#BlackBoxOptim.next_candidate!"><code>BlackBoxOptim.next_candidate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the index of the next candidate for evaluation based on the Base.pmap() code.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.noisy_quartic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.nondominated" href="#BlackBoxOptim.nondominated"><code>BlackBoxOptim.nondominated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nondominated(fitnesses, fit_scheme)</code></pre><p>Filter <code>fitnesses</code> removing all dominated values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.noprogress_streak" href="#BlackBoxOptim.noprogress_streak"><code>BlackBoxOptim.noprogress_streak</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">noprogress_streak(a::EpsBoxArchive, [since_restart])</code></pre><p>Get the number of <code>add_candidate!()</code> calls since the last ϵ-progress. If <code>since_restart</code> is specified, the number is relative to the last restart.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.notify!</code></pre><pre><code class="language-none">BlackBoxOptim.num_evals</code></pre><pre><code class="language-none">BlackBoxOptim.num_func_evals</code></pre><pre><code class="language-none">BlackBoxOptim.num_steps</code></pre><pre><code class="language-none">BlackBoxOptim.num_vars_to_next_mutation_point</code></pre><pre><code class="language-none">BlackBoxOptim.numchildren</code></pre><pre><code class="language-none">BlackBoxOptim.numdims</code></pre><pre><code class="language-none">BlackBoxOptim.numobjectives</code></pre><pre><code class="language-none">BlackBoxOptim.numparents</code></pre><pre><code class="language-none">BlackBoxOptim.numruns</code></pre><pre><code class="language-none">BlackBoxOptim.objfunc</code></pre><pre><code class="language-none">BlackBoxOptim.occupied_frontier_indices</code></pre><pre><code class="language-none">BlackBoxOptim.opt_value</code></pre><pre><code class="language-none">BlackBoxOptim.optimizer</code></pre><pre><code class="language-none">BlackBoxOptim.orig_problem</code></pre><pre><code class="language-none">BlackBoxOptim.orig_problem_type</code></pre><pre><code class="language-none">BlackBoxOptim.parameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.params" href="#BlackBoxOptim.params"><code>BlackBoxOptim.params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the problem parameters (a point in the search space) of the individual.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.params_mean</code></pre><pre><code class="language-none">BlackBoxOptim.params_std</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.pareto_frontier" href="#BlackBoxOptim.pareto_frontier"><code>BlackBoxOptim.pareto_frontier</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the iterator to the individuals on the Pareto frontier.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.persistent_individuals</code></pre><pre><code class="language-none">BlackBoxOptim.persistent_range</code></pre><pre><code class="language-none">BlackBoxOptim.popsize</code></pre><pre><code class="language-none">BlackBoxOptim.populate_by_mutants</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.population" href="#BlackBoxOptim.population"><code>BlackBoxOptim.population</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate a population for a given problem.</p><p>The default method to generate a population, uses Latin Hypercube Sampling.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.problem</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.problem_set" href="#BlackBoxOptim.problem_set"><code>BlackBoxOptim.problem_set</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">problem_set(ps::Dict{Any, FunctionBasedProblemFamily}, dims::Union{Int,Vector{Int}})</code></pre><p>Construct a fixed-dimensional version of each problem from <code>ps</code> for each dimension given in <code>dims</code>.</p><p>Returns a dictionary of problems.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.problem_summary</code></pre><pre><code class="language-none">BlackBoxOptim.process_candidate!</code></pre><pre><code class="language-none">BlackBoxOptim.quartic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.rand_frontier_index" href="#BlackBoxOptim.rand_frontier_index"><code>BlackBoxOptim.rand_frontier_index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get random occupied Pareto frontier index. Returns 0 if frontier is empty.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.rand_indexes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.rand_individual" href="#BlackBoxOptim.rand_individual"><code>BlackBoxOptim.rand_individual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate one random candidate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.rand_individuals" href="#BlackBoxOptim.rand_individuals"><code>BlackBoxOptim.rand_individuals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate <code>numIndividuals</code> individuals by random sampling in the search space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.rand_individuals_lhs" href="#BlackBoxOptim.rand_individuals_lhs"><code>BlackBoxOptim.rand_individuals_lhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate <code>numIndividuals</code> individuals by latin hypercube sampling (LHS). This should be the default way to create the initial population.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.randbeta</code></pre><pre><code class="language-none">BlackBoxOptim.random_resample</code></pre><pre><code class="language-none">BlackBoxOptim.random_resample_with_inheritance</code></pre><pre><code class="language-none">BlackBoxOptim.random_search</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.range_for_dim" href="#BlackBoxOptim.range_for_dim"><code>BlackBoxOptim.range_for_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the range of valid values for a specific dimension.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.ranges</code></pre><pre><code class="language-none">BlackBoxOptim.rank_by_fitness!</code></pre><pre><code class="language-none">BlackBoxOptim.rank_result_dicts_by</code></pre><pre><code class="language-none">BlackBoxOptim.rastrigin</code></pre><pre><code class="language-none">BlackBoxOptim.recombinate!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.release_candi" href="#BlackBoxOptim.release_candi"><code>BlackBoxOptim.release_candi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Put the candidate back to the pool.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.repeated_bboptimize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.report_from_result_dict" href="#BlackBoxOptim.report_from_result_dict"><code>BlackBoxOptim.report_from_result_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Print a report based on a result dict from one set of repeated runs of an optimization method. Returns the success rate, i.e. number of times the termination reason was &quot;Within fitness tolerance...&quot;.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.report_on_methods_results_on_one_problem</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.report_on_values" href="#BlackBoxOptim.report_on_values"><code>BlackBoxOptim.report_on_values</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Summarize a vector of float values by stating its mean, std dev and median.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.resampling_inheritance_memetic_searcher</code></pre><pre><code class="language-none">BlackBoxOptim.resampling_memetic_searcher</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.reset!" href="#BlackBoxOptim.reset!"><code>BlackBoxOptim.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reset the current <code>ParallelEvaluationState</code> and the vector of candidates that need fitness evaluation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.reset_fitness!" href="#BlackBoxOptim.reset_fitness!"><code>BlackBoxOptim.reset_fitness!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reset the candidate fitness.</p><p>Need it when the candidate parameters have changed, but the stored fitness is still for the old parameter set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.restart!" href="#BlackBoxOptim.restart!"><code>BlackBoxOptim.restart!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Restart Borg MOEA.</p><p>Resize and refills the population from the archive.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.rosenbrock</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.run!" href="#BlackBoxOptim.run!"><code>BlackBoxOptim.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">run!(ctrl::OptRunController)</code></pre><p>Run optimization until one of the stopping conditions are satisfied.</p></div></div><div><div><pre><code class="language-none">run!(oc::OptController)</code></pre><p>Start a new optimization run, possibly with new parameters and report on results.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.s1_ackley</code></pre><pre><code class="language-none">BlackBoxOptim.s1_elliptic</code></pre><pre><code class="language-none">BlackBoxOptim.s1_rastrigin</code></pre><pre><code class="language-none">BlackBoxOptim.s1_rosenbrock</code></pre><pre><code class="language-none">BlackBoxOptim.s1_schwefel</code></pre><pre><code class="language-none">BlackBoxOptim.s1_sphere</code></pre><pre><code class="language-none">BlackBoxOptim.s2_step</code></pre><pre><code class="language-none">BlackBoxOptim.same_fitness</code></pre><pre><code class="language-none">BlackBoxOptim.sample_bernoulli_vector</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.sample_unit_hypersphere" href="#BlackBoxOptim.sample_unit_hypersphere"><code>BlackBoxOptim.sample_unit_hypersphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate <code>num</code> random vectors on the <code>n</code>-dimensional, unit (hyper)sphere. This is the Muller-Marsaglia method as described <a href="http://mathworld.wolfram.com/HyperspherePointPicking.html">here</a>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.save_fitness_history_to_csv_file</code></pre><pre><code class="language-none">BlackBoxOptim.schaffer1</code></pre><pre><code class="language-none">BlackBoxOptim.schaffer1_PF</code></pre><pre><code class="language-none">BlackBoxOptim.schwefel1_2</code></pre><pre><code class="language-none">BlackBoxOptim.schwefel2_21</code></pre><pre><code class="language-none">BlackBoxOptim.schwefel2_22</code></pre><pre><code class="language-none">BlackBoxOptim.schwefel2_26</code></pre><pre><code class="language-none">BlackBoxOptim.search_space</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.select" href="#BlackBoxOptim.select"><code>BlackBoxOptim.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">select(selector&lt;:IndividualsSelector, population, numSamples::Int)</code></pre><p>Select <code>numSamples</code> random candidates from the <code>population</code>.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.separable_nes</code></pre><pre><code class="language-none">BlackBoxOptim.set_as_elite_if_better</code></pre><pre><code class="language-none">BlackBoxOptim.setup!</code></pre><pre><code class="language-none">BlackBoxOptim.setup_optimizer!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.setup_problem" href="#BlackBoxOptim.setup_problem"><code>BlackBoxOptim.setup_problem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setup_problem(problem, parameters::Parameters)</code></pre><p>Set up a fixed-dimensional optimization problem.</p><p>There are several <code>setup_problem()</code> method that accept different type of <code>problem</code> argument:     * <code>OptimizationProblem</code>     * function (<code>:NumDimensions</code> has to be specified in <code>parameters</code>)     * <code>FunctionBasedProblemFamily</code> (<code>:NumDimensions</code> has to be specified in <code>parameters</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.shekel" href="#BlackBoxOptim.shekel"><code>BlackBoxOptim.shekel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generic function to define <code>ShekelN</code> problems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.shekel10" href="#BlackBoxOptim.shekel10"><code>BlackBoxOptim.shekel10</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Shekel10</code> is a 4D, multi-minima, non-separable test problem. Our implementation is based on the C code in: http://www.math.ntu.edu.tw/~wwang/cola<em>lab/test</em>problems/multiple<em>opt/multiopt</em>prob/Shekel10/Shekel10.c</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.shekel5" href="#BlackBoxOptim.shekel5"><code>BlackBoxOptim.shekel5</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Shekel5</code> is a 4D, multi-minima, non-separable test problem. Our implementation is based on the C code in: http://www.math.ntu.edu.tw/~wwang/cola<em>lab/test</em>problems/multiple<em>opt/multiopt</em>prob/Shekel5/Shekel5.c</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.shekel7" href="#BlackBoxOptim.shekel7"><code>BlackBoxOptim.shekel7</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Shekel7</code> is a 4D, multi-minima, non-separable test problem. Our implementation is based on the C code in: http://www.math.ntu.edu.tw/~wwang/cola<em>lab/test</em>problems/multiple<em>opt/multiopt</em>prob/Shekel7/Shekel7.c</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.show_fitness" href="#BlackBoxOptim.show_fitness"><code>BlackBoxOptim.show_fitness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_fitness(io, fit, [problem::OptimizationProblem])</code></pre><p>Output fitness to the given IO stream. <code>show_fitness()</code> method could be overridden for a specific problem, e.g. to print the names of each objective.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.show_report</code></pre><pre><code class="language-none">BlackBoxOptim.shutdown!</code></pre><pre><code class="language-none">BlackBoxOptim.shutdown_optimizer!</code></pre><pre><code class="language-none">BlackBoxOptim.sphere</code></pre><pre><code class="language-none">BlackBoxOptim.start_time</code></pre><pre><code class="language-none">BlackBoxOptim.step</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.step!" href="#BlackBoxOptim.step!"><code>BlackBoxOptim.step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">step!(opt::SteppingOptimizer)</code></pre><p>Do one iteration of the method.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.stop_due_to_low_precision</code></pre><pre><code class="language-none">BlackBoxOptim.stop_reason</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.symmetric_search_space" href="#BlackBoxOptim.symmetric_search_space"><code>BlackBoxOptim.symmetric_search_space</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Create <code>RangePerDimSearchSpace</code> with given number of dimensions and given range of valid values for each dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.t_asy" href="#BlackBoxOptim.t_asy"><code>BlackBoxOptim.t_asy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transform symmetric <code>f</code> into asymmetric objective function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.t_diag" href="#BlackBoxOptim.t_diag"><code>BlackBoxOptim.t_diag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transform <code>f</code> into objective function with ill-conditioning effect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.t_irreg" href="#BlackBoxOptim.t_irreg"><code>BlackBoxOptim.t_irreg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Transform <code>f</code> into objective function with smooth local irregularities.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.tag</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.tagcounts" href="#BlackBoxOptim.tagcounts"><code>BlackBoxOptim.tagcounts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tagcounts(a::EpsBoxArchive)</code></pre><p>Count the tags of individuals on the ϵ-box frontier. Each restart the individual remains in the frontier discounts it by <code>θ</code>.</p><p>Returns the <code>tag</code>→<code>count</code> dictionary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.tell!" href="#BlackBoxOptim.tell!"><code>BlackBoxOptim.tell!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tell!(ato::AskTellOptimizer, rankedCandidates)</code></pre><p>Tell the optimizer about the ranking of candidates. Returns the number of <code>rankedCandidates</code> that were inserted into the population, because of the improved fitness.</p><p>See also <code>ask()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.tournament" href="#BlackBoxOptim.tournament"><code>BlackBoxOptim.tournament</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Simulate tournament among specified <code>candidates</code>.</p><p>Returns the index of the winner.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.trace</code></pre><pre><code class="language-none">BlackBoxOptim.trace_progress</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.trace_state" href="#BlackBoxOptim.trace_state"><code>BlackBoxOptim.trace_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trace_state(io, op::GeneticOperator, mode::Symbol)</code></pre><p>Trace the state of the operator. Called by <code>trace_progress()</code> during <code>OptRunController</code> run by some of the genetic optimizers.</p><p>Override the method to trace the state of your genetic operator.</p></div></div><div><div><pre><code class="language-none">trace_state(io::IO, optimizer::Optimizer, mode::Symbol)</code></pre><p>Trace the current optimization state to a given IO stream. Called by <code>OptRunController</code> <code>trace_progress()</code>.</p><p>Override it for your optimizer to generate method-specific diagnostic traces.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.transient_range</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.update!" href="#BlackBoxOptim.update!"><code>BlackBoxOptim.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Update the internal model of progress and success rate of each method based on the latest progress value of one method. Progress values should be larger the larger the progress/improvement was.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.update_candidates!</code></pre><pre><code class="language-none">BlackBoxOptim.update_fitness!</code></pre><pre><code class="language-none">BlackBoxOptim.update_learning_rates!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.update_parameters!" href="#BlackBoxOptim.update_parameters!"><code>BlackBoxOptim.update_parameters!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">update_parameters!(oc::OptController, parameters::Associative)</code></pre><p>Update the <code>OptController</code> parameters.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.update_population_fitness!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.update_recombination_weights!" href="#BlackBoxOptim.update_recombination_weights!"><code>BlackBoxOptim.update_recombination_weights!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Update recombination operator probabilities based on the archive tag counts.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.viewer" href="#BlackBoxOptim.viewer"><code>BlackBoxOptim.viewer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viewer(population, individual_index)</code></pre><p>Get vector-slice of the population matrix for the specified individual. Does not allocate any additional space, while still providing the same lookup performance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.width_of_confidence_interval" href="#BlackBoxOptim.width_of_confidence_interval"><code>BlackBoxOptim.width_of_confidence_interval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate the width of the confidence interval at a certain <code>p</code>-value. This is based on the paper:     Carvalho (2011), &quot;Confidence intervals for the minimum of a     function using extreme value statistics&quot;</p><p>This means that the current estimate of the confidence interval for the minimum of the optimized function lies within the interval</p><pre><code class="language-none">] l1 - w, l1 [</code></pre><p>with probability <span>$(1-p)$</span> as the number of sampled function points goes to infinity, where</p><pre><code class="language-none">w = width_of_confidence_interval(a, p)
l1 = best_fitness(a)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlackBoxOptim.worker_finished!" href="#BlackBoxOptim.worker_finished!"><code>BlackBoxOptim.worker_finished!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Notify that the worker process is finished and reset its busy flag.</p></div></div></section><pre><code class="language-none">BlackBoxOptim.worst_fitness</code></pre><pre><code class="language-none">BlackBoxOptim.write_result</code></pre><pre><code class="language-none">BlackBoxOptim.xnes</code></pre><pre><code class="language-none">BlackBoxOptim.xrotatedandshifted</code></pre><pre><code class="language-none">BlackBoxOptim.xshifted</code></pre><pre><code class="language-none">BlackBoxOptim.ϵ_index</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
