<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · HyperbolicPlane.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HyperbolicPlane.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HCircle" href="#HyperbolicPlane.HCircle"><code>HyperbolicPlane.HCircle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HCircle(P::HPoint,r::Real)</code> creates a new hyperbolic circle centered at <code>P</code> with radius <code>r</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HContainer" href="#HyperbolicPlane.HContainer"><code>HyperbolicPlane.HContainer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HContainer</code> is a device for holding a collection of hyperbolic objects. It is like a set, but we have to do a lot of work before adding a new element because equal hyperbolic objects might differ a tiny amount and that would mess up hashing.</p><ul><li><code>C = HContainer()</code> creates a new container.</li><li><code>C = HContainer(items...)</code> creates a new container with the items.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HLine" href="#HyperbolicPlane.HLine"><code>HyperbolicPlane.HLine</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HLine(P,Q)</code> creates a new line from the given two points.</p></div></div><div><div><p><code>HLine(S::HSegment)</code> extends the segment <code>S</code> to give a (new) line.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.HLinear</code></pre><pre><code class="language-none">HyperbolicPlane.HObject</code></pre><pre><code class="language-none">HyperbolicPlane.HPlane</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HPoint" href="#HyperbolicPlane.HPoint"><code>HyperbolicPlane.HPoint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HPoint(z::Complex)</code> creates a new point in the hyperbolic plane. The argument <code>z</code> must have absolute value less than 1.</p><p><code>HPoint(r,theta)</code> creates a new point with polar coordinates <code>(r,theta)</code>. See also: <code>polar</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HPolygon" href="#HyperbolicPlane.HPolygon"><code>HyperbolicPlane.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HPolygon()</code> creates a new polygon (with no points).</p><p><code>HPolygon(list)</code> creates a polygon whose points are specified in <code>list</code>.</p><p>See: <code>add_point!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HRay" href="#HyperbolicPlane.HRay"><code>HyperbolicPlane.HRay</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HRay(P::HPoint, t::Real)</code> returns a ray with vertex <code>P</code> pointing to <code>exp(im*t)</code>.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.HRound</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HSegment" href="#HyperbolicPlane.HSegment"><code>HyperbolicPlane.HSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HSegment(A,B)</code> creates a new line segment with endpoints <code>A</code> and <code>B</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.HTriangle" href="#HyperbolicPlane.HTriangle"><code>HyperbolicPlane.HTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>HTriangle(A,B,C)</code> creates a new hyperbolic triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.Horocycle" href="#HyperbolicPlane.Horocycle"><code>HyperbolicPlane.Horocycle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Horocycle(P::HPoint, theta::Real)</code> create the horocycle containing the point <code>P</code> and the ideal point at <code>exp(im*theta)</code>.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.HyperbolicPlane</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHCircle" href="#HyperbolicPlane.RandomHCircle"><code>HyperbolicPlane.RandomHCircle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHCircle()</code> creates a random circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHLine" href="#HyperbolicPlane.RandomHLine"><code>HyperbolicPlane.RandomHLine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHLine()</code> returns a random line in the hyperbolic plane.</p><p>Algorithm: choose two values <code>s,t</code> in <code>[0,2pi)</code> uniformly at random and then make the line from <code>exp(s*im)</code> to <code>exp(t*im)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHPoint" href="#HyperbolicPlane.RandomHPoint"><code>HyperbolicPlane.RandomHPoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHPoint()</code> generates a point at random in the hyperbolic plane.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHPolygon" href="#HyperbolicPlane.RandomHPolygon"><code>HyperbolicPlane.RandomHPolygon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHPolygon(n::Int,simple::Bool=false)</code> create a new <code>HPolygon</code> with <code>n</code> points chosen at random. With <code>simple</code> set to <code>true</code>, return a polygon that does not self-intersect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHRay" href="#HyperbolicPlane.RandomHRay"><code>HyperbolicPlane.RandomHRay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHRay()</code> creates a random ray. <code>RandomRay(P::HPoint)</code> creates a random ray with vertex <code>P</code>.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.RandomHSegment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHTriangle" href="#HyperbolicPlane.RandomHTriangle"><code>HyperbolicPlane.RandomHTriangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHTriangle()</code> creates a random triangle via three calls to <code>RandomHPoint()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.RandomHorocycle" href="#HyperbolicPlane.RandomHorocycle"><code>HyperbolicPlane.RandomHorocycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomHorocycle()</code> creates a random horocycle by choosing a point at random by <code>RandomHPoint</code> and a random ideal point (uniformly between 0 and 2π).</p></div></div></section><pre><code class="language-none">HyperbolicPlane.THRESHOLD</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._cycle" href="#HyperbolicPlane._cycle"><code>HyperbolicPlane._cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_cycle(A,k)</code> returns a <code>k</code>-step shift of <code>A</code>. We require <code>k</code> to be in the interval <code>[0,n-1]</code> where <code>n=length(A)</code>. No checking is done.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._cyclic_equal" href="#HyperbolicPlane._cyclic_equal"><code>HyperbolicPlane._cyclic_equal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_cyclic_equal(A,B)</code> checks if some cyclic shift of one list equals the other.</p></div></div></section><pre><code class="language-none">HyperbolicPlane._dist</code></pre><pre><code class="language-none">HyperbolicPlane._mag</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane._solver" href="#HyperbolicPlane._solver"><code>HyperbolicPlane._solver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_solver(f,goal,lo,hi)</code> assumes <code>f</code> is increasing on the interval <code>[lo,hi]</code></p></div></div><div><div><p><code>_solver(f,goal)</code> assumes that <code>f</code> is increasing and there is a nonnegative <code>x</code> so that <code>f(x)==goal</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.add_object!" href="#HyperbolicPlane.add_object!"><code>HyperbolicPlane.add_object!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_object!(C::HContainer, X::HObject)</code> adds <code>X</code> to the container <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.add_point!" href="#HyperbolicPlane.add_point!"><code>HyperbolicPlane.add_point!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_point!(X::HPolygon, P::HPoint)</code> adds the point <code>P</code> as the last point of the polygon <code>X</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.alt_mod" href="#HyperbolicPlane.alt_mod"><code>HyperbolicPlane.alt_mod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>alt_mod(k,n)</code> is <code>mod(k,n)</code> unless the result is zero, in which case we return <code>n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.angle" href="#Base.angle"><code>Base.angle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>angle(A,B,C)</code> finds the angle betwen <code>BA</code> and <code>BC</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.angles" href="#HyperbolicPlane.angles"><code>HyperbolicPlane.angles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>angles(T::HTriangle)</code> returns a <em>sorted</em> triple containing the angles at the three corners of the triangle.</p></div></div><div><div><p><code>angles(P::HPolygon)</code> returns a list of the angles at the vertices of <code>P</code>.</p><ul><li>The results are always in the interval <code>[0,pi]</code>.</li><li>The order of the angles is the order of the vertices in <code>P.plist</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.area" href="#HyperbolicPlane.area"><code>HyperbolicPlane.area</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>area(T::HTriangle)</code> returns the area of the triangle.</p></div></div><div><div><p><code>area(C::HCircle)</code> returns the area of the circle.</p></div></div><div><div><p><code>area(X::HPolygon)</code> returns the area of the polygon, but is only reliable if <code>X</code> does not self-intersect. See <code>is_simple</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.between" href="#HyperbolicPlane.between"><code>HyperbolicPlane.between</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>between(a,b,c)</code> determines if the hyperbolic point <code>b</code> lies on the segment from <code>a</code> to <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.bisector" href="#HyperbolicPlane.bisector"><code>HyperbolicPlane.bisector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bisector(S::HSegment)</code> yields an <code>HLine</code> that&#39;s the perpendicular bisector of the segment <code>S</code>. May also be invoked <code>bisector(A,B)</code> where <code>A</code> and <code>B</code> are points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.check_diagonal" href="#HyperbolicPlane.check_diagonal"><code>HyperbolicPlane.check_diagonal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>check_diagonal(X::HPolygon, k::Int)</code> checks to see if the diagonal between vertices <code>k-1</code> and <code>k+1</code> (a) does not intersect the boundary of <code>X</code> and (b) goes through the interior of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.circumference" href="#HyperbolicPlane.circumference"><code>HyperbolicPlane.circumference</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>circumference(C::HCircle)</code> returns the circumference of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.collinear" href="#HyperbolicPlane.collinear"><code>HyperbolicPlane.collinear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>collinear</code> checks if the arguments are collinear. Arguments are:</p><ul><li><code>a,b,c</code>: three points</li><li><code>a,L</code>: point and segment (in either order)</li><li><code>L,LL</code>: two segments</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.copy_attr" href="#HyperbolicPlane.copy_attr"><code>HyperbolicPlane.copy_attr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>copy_attr(A,B)</code> copies the attributes assigned to <code>B</code> into <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.dist" href="#AbstractLattices.dist"><code>AbstractLattices.dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dist(P,Q)</code> gives the distance betwen two points in the hyperbolic plane. If <code>Q</code> is omitted, give the distance from <code>P</code> to <code>HPoint(0)</code>.</p></div></div><div><div><p><code>dist(P::HPoint,L::HLine)</code> is the distance from <code>P</code> to the nearest point on <code>L</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDrawing.draw" href="#SimpleDrawing.draw"><code>SimpleDrawing.draw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>draw(X)</code> draws the hyperbolic object <code>X</code> in a graphics window.</p><p><code>draw</code> may be applied to a list of hyperbolic objects.</p><p>The typical sequence of drawing starts by clearing the screen with the <code>plot()</code> function (from the <code>Plots</code> module), then various to calls to <code>draw</code> and then concludes with a call to <code>finish()</code> (see the help message for that function).</p></div></div></section><pre><code class="language-none">HyperbolicPlane.draw_diagonal</code></pre><pre><code class="language-none">HyperbolicPlane.e_center</code></pre><pre><code class="language-none">HyperbolicPlane.e_radius</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.endpoints" href="#HyperbolicPlane.endpoints"><code>HyperbolicPlane.endpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>endpoints(T::HTriangle)</code> returns the corner points of the triangle.</p></div></div><div><div><p><code>endpoints(X::HPolygon)</code> returns the list of vertices (in order) of the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equality_threshold" href="#HyperbolicPlane.equality_threshold"><code>HyperbolicPlane.equality_threshold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>equality_threshold(val)</code> sets the &quot;sloppiness&quot; for equality checking. The default value is 100. In general, two objects are equal if their stored values are within <code>val * eps(1.0)</code>.</p><p>Calling <code>equality_threshold()</code> with no arguments returns the current value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equiangular" href="#HyperbolicPlane.equiangular"><code>HyperbolicPlane.equiangular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>equiangular(n,theta)</code> creates a regular <code>n</code>-gon where the vertex angles equal <code>theta</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.equilateral" href="#HyperbolicPlane.equilateral"><code>HyperbolicPlane.equilateral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>equilateral(n,s)</code> creates a regular <code>n</code>-gon with side lengths <code>s</code> centered at the origin. First point is on the positive x-axis.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.euclidean_center</code></pre><pre><code class="language-none">HyperbolicPlane.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.expander" href="#HyperbolicPlane.expander"><code>HyperbolicPlane.expander</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>expander(P::HPolygon)</code> returns a list of polygons formed by reflecting <code>P</code> across each of its sides.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.find_ear_diagonal" href="#HyperbolicPlane.find_ear_diagonal"><code>HyperbolicPlane.find_ear_diagonal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>find_ear_diagonal(X::HPolygon)</code> returns an index <code>k</code> such that the diagonal from <code>k-1</code> to <code>k+1</code> passes <code>check_diagonal</code>. Returns <code>0</code> if no ear diagonal is found.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.finish</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_center" href="#HyperbolicPlane.get_center"><code>HyperbolicPlane.get_center</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_center(C::HCircle)</code> returns the center of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_radius" href="#HyperbolicPlane.get_radius"><code>HyperbolicPlane.get_radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_radius(C::HCircle)</code> returns the radius of the circle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.get_vertex" href="#HyperbolicPlane.get_vertex"><code>HyperbolicPlane.get_vertex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_vertex(R::HRay)</code> returns the vertex (end point) of the ray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.getz" href="#HyperbolicPlane.getz"><code>HyperbolicPlane.getz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>getz(P::HPoint)</code> returns the point (complex number) in the interior of the unit disc that represents <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.in_up" href="#HyperbolicPlane.in_up"><code>HyperbolicPlane.in_up</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>in_up</code> is a <code>LFT</code> that maps the Poincaré disk to the upper half plane.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.interior_point" href="#HyperbolicPlane.interior_point"><code>HyperbolicPlane.interior_point</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>interior_point(T::HTriangle)</code> returns a point in the interior of the triangle. The interior point is the intersection of the triangle&#39;s medians (the centroid).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.is_simple" href="#HyperbolicPlane.is_simple"><code>HyperbolicPlane.is_simple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>is_simple(X::HPolygon)</code> determines if the polygon edges do not self-intersect. Be sure the polygon is legit using <code>polygon_check</code> first.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.meet" href="#HyperbolicPlane.meet"><code>HyperbolicPlane.meet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>meet(L,LL)</code> finds a point on lines <code>L</code> and <code>LL</code> or throws an error if they don&#39;t intersect.  Also for a line and a segment, or two segments.</p><p>See <code>meet_check</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.meet_check" href="#HyperbolicPlane.meet_check"><code>HyperbolicPlane.meet_check</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>meet_check(L::HLine,LL::HLine)</code> determines if two lines intersect. Also for any combination of lines, segments, or rays.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.midpoint" href="#HyperbolicPlane.midpoint"><code>HyperbolicPlane.midpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>midpoint(p,q)</code> finds the mid point of the line segment from <code>p</code> to <code>q</code>. Also <code>midpoint(L::HSegment)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2xplus" href="#HyperbolicPlane.move2xplus"><code>HyperbolicPlane.move2xplus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>move2xplus(P::HPoint)</code> returns an isometry of H^2 that maps <code>P</code> onto the positive real axis.</p></div></div><div><div><p><code>move2xplus(A,B)</code> or <code>move2xplus(L::HSegment)</code> gives an isometry <code>f</code> so that <code>f(A)</code> is 0 and <code>f(B)</code> is on the positive real axis.</p></div></div><div><div><p><code>move2xplus(L::HLine)</code> returns a linear fractional transformation that maps points on <code>L</code> to the positive x-axis but is <em>not</em> an isometry of the hyperbolic plane.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.move2zero" href="#HyperbolicPlane.move2zero"><code>HyperbolicPlane.move2zero</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>move2zero(P::Hpoint)</code> returns a <code>LFT</code> that&#39;s an isometry of H^2 that maps <code>P</code> to the origin.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.newdraw</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.npoints" href="#HyperbolicPlane.npoints"><code>HyperbolicPlane.npoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>npoints(X::HPolygon)</code> returns the number of points on the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.perimeter" href="#HyperbolicPlane.perimeter"><code>HyperbolicPlane.perimeter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>perimeter(T::HTriangle)</code> or <code>perimeter(P::HPolygon)</code> returns the perimeter of the figure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.perpendicular" href="#HyperbolicPlane.perpendicular"><code>HyperbolicPlane.perpendicular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>perpendicular(L::HLine, P::HPoint)</code> returns a line that is perpendicular to <code>L</code> and contains <code>P</code>.</p></div></div><div><div><p><code>perpendicular(L)</code> returns an arbitrary line that is perpendicular to <code>L</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.point_on_line" href="#HyperbolicPlane.point_on_line"><code>HyperbolicPlane.point_on_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>point_on_line(L)</code> returns a point on the hyperbolic line <code>L</code>.</p><p>See also: <code>points_on_line</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.point_on_ray" href="#HyperbolicPlane.point_on_ray"><code>HyperbolicPlane.point_on_ray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>point_on_ray(R::HRay)</code> returns a point in the interior of the ray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.points_on_circle" href="#HyperbolicPlane.points_on_circle"><code>HyperbolicPlane.points_on_circle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>points_on_circle(C::HCircle)</code> returns a 3-tuple of points that lie on the circle <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.points_on_line" href="#HyperbolicPlane.points_on_line"><code>HyperbolicPlane.points_on_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>points_on_line(L,n)</code> returns a list of <code>n</code> distinct points on the line <code>L</code>.</p><p>See also: <code>point_on_line</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.polar" href="#HyperbolicPlane.polar"><code>HyperbolicPlane.polar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>polar(P::HPoint)</code> gives the polar coordinates of <code>P</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.polygon_check" href="#HyperbolicPlane.polygon_check"><code>HyperbolicPlane.polygon_check</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>polygon_check(X::HPolygon,quiet=true)</code> checks that the polygon is nondegenerate. Possible degeneracies are:</p><ul><li>Repeated vertices</li><li>Fewer than three distinct vertices</li><li>Angles that are either 0 degrees or 180 degrees</li></ul><p>If <code>quiet</code> is <code>false</code>, then a reason for the failed check is printed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.reflect_across" href="#HyperbolicPlane.reflect_across"><code>HyperbolicPlane.reflect_across</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>reflect_across(X::HObject,L::HSegment/HLine)</code> returns the object formed by refecting <code>X across the line segment/line</code>L`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.rotation" href="#HyperbolicPlane.rotation"><code>HyperbolicPlane.rotation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rotation(theta)</code> is an isometry of H^2 corresponding to a rotation about the origin of the amount <code>theta</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.same_side" href="#HyperbolicPlane.same_side"><code>HyperbolicPlane.same_side</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>same_side(P,Q,L)</code> determines if the points <code>P</code> and <code>Q</code> lie in the same (closed) halfplane as determined by <code>L</code>. If either point is on <code>L</code> then the result is <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_color" href="#HyperbolicPlane.set_color"><code>HyperbolicPlane.set_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_color(X,col)</code> sets the color of the hyperbolic object <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_fill_alpha" href="#HyperbolicPlane.set_fill_alpha"><code>HyperbolicPlane.set_fill_alpha</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_fill_alpha(X,alpha)</code> sets the alpha value for the object&#39;s fill. Only works for <code>HPlane</code> and <code>HCircle</code>. Default value is 1 (not transparent)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_fill_color" href="#HyperbolicPlane.set_fill_color"><code>HyperbolicPlane.set_fill_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_fill_color(X,col)</code> sets the color used to fill <code>X</code>. Works for <code>HPlane</code> and <code>HCircle</code>. Default is <code>:yellow</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_line_style" href="#HyperbolicPlane.set_line_style"><code>HyperbolicPlane.set_line_style</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_line_style(X,style)</code> sets the line style for drawing <code>X</code>. Default is <code>:solid</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_no_fill" href="#HyperbolicPlane.set_no_fill"><code>HyperbolicPlane.set_no_fill</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_no_fill(X)</code> removes fill from the <code>HObject</code>. It now draws as unfilled.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_radius" href="#HyperbolicPlane.set_radius"><code>HyperbolicPlane.set_radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_radius(P,rad)</code> sets the radius for an <code>HPoint</code>. The default is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.set_thickness" href="#HyperbolicPlane.set_thickness"><code>HyperbolicPlane.set_thickness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_thickness(X,thk)</code> sets the thickness of the line used to draw the hyperbolic object <code>X</code>. Default is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.sides" href="#HyperbolicPlane.sides"><code>HyperbolicPlane.sides</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sides(P:::HPolygon/HTriangle)</code> returns a list of the line segments that are the sides of the polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.solve_dist" href="#HyperbolicPlane.solve_dist"><code>HyperbolicPlane.solve_dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>solve_dist(d)</code> is the inverse of <code>_dist()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.stab_count" href="#HyperbolicPlane.stab_count"><code>HyperbolicPlane.stab_count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>stab_count(R,targets)</code> is used to count how many items in <code>targets</code> are intersected by <code>R</code> where <code>targets</code> is a list of <code>HLinear</code> objects and <code>R</code> is an <code>HLinear</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.tesselation" href="#HyperbolicPlane.tesselation"><code>HyperbolicPlane.tesselation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tesselation(n,k,deep)</code>: Tesselate the hyperbolic plane by regular <code>n</code>-gons in which each vertex is a corner of <code>k</code> polygons. <code>deep</code> controls how many layers. The center of the first <code>k</code>-gon is placed at the origin.</p><p>May also be called <code>tesselation(n,k,deep,true)</code> in which case a vertex of the first <code>k</code>-gon is placed at the origin and the tesselation is seeded by copies of this first polygon around the origin.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.triangulate" href="#HyperbolicPlane.triangulate"><code>HyperbolicPlane.triangulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>triangulate(X::HPolygon)</code> returns a list of triangles that triangulate <code>X</code>. The polygon should have at least three sides, and have no bad angles, and not self-intersect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HyperbolicPlane.up_in" href="#HyperbolicPlane.up_in"><code>HyperbolicPlane.up_in</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>up_in</code> is a <code>LFT</code> that maps the upper half plane to the Poincaré disk.</p></div></div></section><pre><code class="language-none">HyperbolicPlane.visualize</code></pre><pre><code class="language-none">HyperbolicPlane.∧</code></pre><pre><code class="language-none">HyperbolicPlane.∨</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
