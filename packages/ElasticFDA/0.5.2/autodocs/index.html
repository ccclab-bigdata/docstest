<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ElasticFDA.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ElasticFDA.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.DP_mean" href="#ElasticFDA.DP_mean"><code>ElasticFDA.DP_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate mean function using Bayesian Dynamic Programming     DP_mean(f, times=5)     :param f: array (M,N) of N functions     :param times: MCMC parameter number of times to split</p><pre><code class="language-none">Returns Dict containing
:return distmfamily: distance matrix
:return match_matrix: match_matrix
:return position: position
:return mu_5: mean function
:return rtmatrix: rtmatrix
:return sumdist: sum distance
:return qt_fitted: qt fitted matrix
:return esimator: estimator
:return estimator2: estimator2
:return regcurve: registered curves</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.ElasticFDA</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.Enorm" href="#ElasticFDA.Enorm"><code>ElasticFDA.Enorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate normal Energy on an Array</p><pre><code class="language-none">Enorm(x::Array{Float64,1})</code></pre></div></div><div><div><pre><code class="language-none">Enorm(x::Array{Complex{Float64},1})</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.__init__</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.align_fPCA" href="#ElasticFDA.align_fPCA"><code>ElasticFDA.align_fPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Aligns a collection of functions while extracting principal components. The functions are aligned to the principal components</p><pre><code class="language-none">align_fPCA(f, timet; num_comp=3, smooth=false, sparam=10, MaxItr=50)
:param f: array of shape (M,N) of N functions with M samples
:param timet: vector of size M describing the sample points
:param num_comp: Number of components (default = 3)
:param smooth: Smooth the data using a box filter (default = false)
:param sparam: Number of times to run smoothing filter (default 10)
:param MaxItr: Maximum number of iterations

Returns Dict containing
:return fn: aligned functions - array of shape (M,N) of N functions with M
            samples
:return qn: aligned srvfs - similar structure to fn
:return q0: original srvf - similar structure to fn
:return mqn: srvf mean or median - vector of length M
:return gam: warping functions - similar structure to fn
:return q_pca: srsf principal directions
:return f_pca: functional principal directions
:return latent: latent values
:return coef: coefficients
:return U: eigenvectors
:return orig_var: Original Variance of Functions
:return amp_var: Amplitude Variance
:return phase_var: Phase Variance</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.approx" href="#ElasticFDA.approx"><code>ElasticFDA.approx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Linear interpolation</p><pre><code class="language-none">approx(xd, yd, xi)
:param xd: x samples
:param yd: response samples
:param xi: new x samples</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.arclength" href="#ElasticFDA.arclength"><code>ElasticFDA.arclength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate arc-length parametrization of function</p><pre><code class="language-none">arclength(f::Vector)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.basis</code></pre><pre><code class="language-none">ElasticFDA.basis_fourier</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.bs" href="#ElasticFDA.bs"><code>ElasticFDA.bs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute B-Spline basis     bs(x, df, norder, nderiv=0)     :param x: time samples     :param df: degree of freedom     :param norder: order of splines     :param nderiv: derivative number</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.calc_j" href="#ElasticFDA.calc_j"><code>ElasticFDA.calc_j</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate Jacobian of basis</p><pre><code class="language-none">calc_j(basis)
:param basis: array of (2) from find_basis_normal</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.calc_shape_dist" href="#ElasticFDA.calc_shape_dist"><code>ElasticFDA.calc_shape_dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate elastic shape distance between two curves beta1 and beta2</p><pre><code class="language-none">calc_shape_dist(beta1, beta2)
:param beta1: array (n,T)
:param beta2: array (n,T)
:param method: optimization method to find warping, default is
               Dynamic Programming (&quot;DP&quot;). Other options are
               Coordinate Descent (&quot;DP2&quot;), Riemannian BFGS
               (&quot;RBFGS&quot;)
:param wscale: with scale (false)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.calculate_variance" href="#ElasticFDA.calculate_variance"><code>ElasticFDA.calculate_variance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate variance along curve</p><pre><code class="language-none">calculate_variance(beta)
:param beta: array (n, T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.calculatecentroid" href="#ElasticFDA.calculatecentroid"><code>ElasticFDA.calculatecentroid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate centroid of curve</p><pre><code class="language-none">calculatecentroid(beta)
:param beta: array describing curve (n,T)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.cost_fn</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.cumtrapz" href="#ElasticFDA.cumtrapz"><code>ElasticFDA.cumtrapz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Cumulative Trapezoidal Integration</p><pre><code class="language-none">cumtrapz(x, y, dim=1)
:param x: vector describing time samples
:param y: array describing response
:param dim: dimension to integrate over</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.cumtrapzmid" href="#ElasticFDA.cumtrapzmid"><code>ElasticFDA.cumtrapzmid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Cumulative Trapezoidal Integration using midpoint</p><pre><code class="language-none">cumtrapzmid(x, y, c)
:param x: time samples
:param y: resposne samples
:param c: midpoint
:param mid: midpoint location</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_geodesic" href="#ElasticFDA.curve_geodesic"><code>ElasticFDA.curve_geodesic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Form geodesic between two curves</p><pre><code class="language-none">curve_geodesic(beta1::Array{Float64,2}, beta2::Array{Float64,2}, k::Integer=5)
:param beta1: array (n,T)
:param beta2: array (n,T)
:param k: number of curves along geodesic
:param wscale: with scale (false)

Returns
:return geod: curves along geodesic (n,T,k)
:return geod_q: srvf&#39;s along geodesic</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_karcher_cov" href="#ElasticFDA.curve_karcher_cov"><code>ElasticFDA.curve_karcher_cov</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate Karcher Covariance of a set of curves</p><pre><code class="language-none">curve_karcher_cov(betamean, beta; mode=&#39;O&#39;)
:param betamean: array (n,T) of mean curve
:param beta: array (n,T,N) for N number of curves
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves

:return K: covariance matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_karcher_mean" href="#ElasticFDA.curve_karcher_mean"><code>ElasticFDA.curve_karcher_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates Karcher mean of a collection of curves using the elastic square-root velocity (srvf) framework.</p><pre><code class="language-none">curve_karcher_mean(beta; mode=&#39;O&#39;, maxit=20)
:param beta: array (n,T,N) for N number of curves
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves
:param maxit: maximum number of iterations
:param wscale: with scale (false)

:return mu: mean srvf
:return betamean: mean curve
:return v: shooting vectors
:return q: array of srvfs</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_pair_align" href="#ElasticFDA.curve_pair_align"><code>ElasticFDA.curve_pair_align</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pairwise align two curves</p><pre><code class="language-none">curve_pair_align(beta1::Array{Float64,2}, beta2::Array{Float64,2})
:param beta1: array (n,T)
:param beta2: array (n,T)

Returns
:return beta2n: aligned curve 2 to 1
:return q2n: aligned srvf 2 to 1
:return gam: warping function
:return q1: srvf of curve 1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_principal_directions" href="#ElasticFDA.curve_principal_directions"><code>ElasticFDA.curve_principal_directions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate principal directions of a set of curves</p><pre><code class="language-none">curve_principal_directions(betamean, mu, K; mode=&#39;O&#39;, no=3, N=5)
:param betamean: array (n,T) of mean curve
:param mu: array (n,T) of mean srvf
:param K: array (T,T) covariance matrix
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curve
:param no: number of components
:param N: number of samples on each side of mean

:return pd: array describing principal directions</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_srvf_align" href="#ElasticFDA.curve_srvf_align"><code>ElasticFDA.curve_srvf_align</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Aligns a collection of curves using the elastic square-root velocity (srvf) framework.</p><pre><code class="language-none">curve_srvf_align(beta; mode=&#39;O&#39;, maxit=20)

:param beta: array (n,T,N) for N number of curves
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves
:param maxit: maximum number of iterations

:return betan: aligned curves
:return qn: aligned srvfs
:return betamean: mean curve
:return q_mu: mean srvf</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_to_q" href="#ElasticFDA.curve_to_q"><code>ElasticFDA.curve_to_q</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert curve to square-root velocity function (srvf)</p><pre><code class="language-none">curve_to_q(beta)
:param beta: array describing curve (n,T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.curve_zero_crossing" href="#ElasticFDA.curve_zero_crossing"><code>ElasticFDA.curve_zero_crossing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate zero crossing for optimal regression between curves</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.dp_bayes" href="#ElasticFDA.dp_bayes"><code>ElasticFDA.dp_bayes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate Dynamic Programming using Bayesian approach     dp_bayes(q1, q1L, q2L, times, cut)     :param q1: vector (N)     :param q1L: vector (q1L)     :param q2L: vector (q2L)     :param times: MCMC parameter number of simulations     :param cut: MCMC parameter number of cuts</p><pre><code class="language-none">:return MatchIn2: warping function
:return NDist: minimal distance
:return q2LL: re-parameterized q2L</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.elastic_distance" href="#ElasticFDA.elastic_distance"><code>ElasticFDA.elastic_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate elastic distance between two functions</p><pre><code class="language-none">elastic_distance(f1::Vector, f2::Vector, timet::Vector,
                 method::AbstractString=&quot;SIMUL&quot;)
:param f1: vector of function 1 samples
:param f2: vector of function 2 samples
:param timet: vector of time samples
:param method: optimization method to find warping, default is
               Dynamic Programming (&quot;DP&quot;). Other options are
               Coordinate Descent (&quot;DP2&quot;), Riemannian BFGS
               (&quot;RBFGS&quot;), Simultaneous Alignment (&quot;SIMUL&quot;)

:return da: amplitude distance
:return dp: phase distance</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.elastic_logistic" href="#ElasticFDA.elastic_logistic"><code>ElasticFDA.elastic_logistic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate elastic logistic regression from function data f, for response y</p><pre><code class="language-none">elastic_logistic(f, y, timet; B=None, df=20, max_itr=20, smooth=false)
:param f: array (M,N) of N functions
:param y: vector (N) of responses
:param timet: vector (N) describing time samples
:param B: matrix describing basis functions (M,N) (default=None generates a
          B-spline basis
:param df: degree of freedom of basis
:param max_itr: maximum number of iterations
:param smooth: smooth data

Returns Dict describing regression
:return alpha: intercept
:return beta: regression function
:return fn: aligned functions
:return qn: aligned srsfs
:return gamma: warping functions
:return q: original srsfs
:retrun B: basis functions
:return type: type of regressions
:return b: coefficients
:return LL: logistic loss</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.elastic_mlogistic" href="#ElasticFDA.elastic_mlogistic"><code>ElasticFDA.elastic_mlogistic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate elastic m-logistic regression from function data f, for response y</p><pre><code class="language-none">elastic_mlogistic(f, y, timet; B=None, df=20, max_itr=20, smooth=false)
:param f: array (M,N) of N functions
:param y: vector (N) of responses
:param timet: vector (N) describing time samples
:param B: matrix describing basis functions (M,N) (default=None generates a
          B-spline basis
:param df: degree of freedom of basis
:param max_itr: maximum number of iterations
:param smooth: smooth data

Returns Dict describing regression
:return alpha: intercept
:return beta: regression function
:return fn: aligned functions
:return qn: aligned srsfs
:return gamma: warping functions
:return q: original srsfs
:retrun B: basis functions
:return type: type of regressions
:return b: coefficients
:return n_classes: number of classes
:return LL: logistic loss</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.elastic_prediction" href="#ElasticFDA.elastic_prediction"><code>ElasticFDA.elastic_prediction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Prediction from elastic regression model</p><pre><code class="language-none">elastic_prediction(f, timet, model; y=None, smooth=false)
:param f: functions to predict
:param timet: vector describing time samples
:param model: calculated model (regression, musicologist, mlogistic)
:param y: true response (default = None)
:param smooth: smooth data (default = false)

Returns
:return y_pred: predicted value
:return y_labels: labels of predicted value
:return Perf: Performance metric if truth is supplied</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.elastic_regression" href="#ElasticFDA.elastic_regression"><code>ElasticFDA.elastic_regression</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate elastic regression from function data f, for response y</p><pre><code class="language-none">elastic_regression(f, y, timet; B=None, lambda=0, df=20, max_itr=20,
                   smooth=false)
:param f: array (M,N) of N functions
:param y: vector (N) of responses
:param timet: vector (N) describing time samples
:param B: matrix describing basis functions (M,N) (default=None generates a
          B-spline basis
:param lambda: regularization parameter
:param df: degree of freedom of basis
:param max_itr: maximum number of iterations
:param smooth: smooth data

Returns Dict describing regression
:return alpha: intercept
:return beta: regression function
:return fn: aligned functions
:return qn: aligned srsfs
:return gamma: warping functions
:return q: original srsfs
:retrun B: basis functions
:return type: type of regressions
:return b: coefficients
:return SSE: sum of squared error</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.eval</code></pre><pre><code class="language-none">ElasticFDA.exp_map</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.extrema_1s" href="#ElasticFDA.extrema_1s"><code>ElasticFDA.extrema_1s</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find location of change of sign of srsf that is arclength parameterized</p><pre><code class="language-none">extrema_1s(t::Vector, q::Vector)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.f_L2norm</code></pre><pre><code class="language-none">ElasticFDA.f_SSEg_pw</code></pre><pre><code class="language-none">ElasticFDA.f_basistofunction</code></pre><pre><code class="language-none">ElasticFDA.f_exp1</code></pre><pre><code class="language-none">ElasticFDA.f_logl_pw</code></pre><pre><code class="language-none">ElasticFDA.f_phiinv</code></pre><pre><code class="language-none">ElasticFDA.f_predictfunction</code></pre><pre><code class="language-none">ElasticFDA.f_psimean</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.f_to_srsf" href="#ElasticFDA.f_to_srsf"><code>ElasticFDA.f_to_srsf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert function to square-root slope function (srsf)</p><pre><code class="language-none">f_to_srsf(f::Array, timet=0, smooth=false)
:param f: array of shape (M,N) describing N functions of M samples
:param timet: vector describing time samples (default = 0) will generate
              linearly spaced time vector of length M
:param smooth: smooth data (default = false)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.f_updateg_pw</code></pre><pre><code class="language-none">ElasticFDA.fdawarp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.find_basis_normal" href="#ElasticFDA.find_basis_normal"><code>ElasticFDA.find_basis_normal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find basis normal to srvf</p><pre><code class="language-none">find_basis_normal(q)
:param q: array (n, T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.find_best_rotation" href="#ElasticFDA.find_best_rotation"><code>ElasticFDA.find_best_rotation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find best rotation between two srvfs</p><pre><code class="language-none">find_best_roation(q1,q2)
:param q1: array (n, T)
:param q2: array (n, T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.find_rotation_and_seed_q" href="#ElasticFDA.find_rotation_and_seed_q"><code>ElasticFDA.find_rotation_and_seed_q</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find best rotation and seed value between two srvfs, q1 and q2</p><pre><code class="language-none">find_rotation_and_seed_q(q1,q2)
:param q1: array (n,T)
:param q2: array (n,T)

:return q2new: rotated srvf
:return O_hat: rotation matrix
:return tau: seed value</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.find_rotation_seed_coord" href="#ElasticFDA.find_rotation_seed_coord"><code>ElasticFDA.find_rotation_seed_coord</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Finds best rotation and seed value between two curves beta1, beta2</p><pre><code class="language-none">find_rotation_seed_coord(beta1,beta2)
:param beta1: array (n,T)
:param beta2: array (n,T)

:return beta2new: rotated curve
:return O_hat1: rotation matrix
:return tau: seed value</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.findkarcherinv" href="#ElasticFDA.findkarcherinv"><code>ElasticFDA.findkarcherinv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find Karcher inverse of warping functions</p><pre><code class="language-none">findkarcherinv(warps, times, roundi=false)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.func</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.gauss_model" href="#ElasticFDA.gauss_model"><code>ElasticFDA.gauss_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes random samples of functions from aligned data using Gaussian model</p><pre><code class="language-none">gauss_model(warp_data; n=1, sort_samples=false)
:param warp_data: fdawarp type from srsf_align of aligned data
:param n: number of samples
:param sort_samples: sort samples

Returns warp_data containing
:return fs: random aligned functions
:return gams: random warping functions
:return ft: random functions</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.gradient" href="#ElasticFDA.gradient"><code>ElasticFDA.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>1-D Gradient</p><pre><code class="language-none">gradient(a::Array, dx::Float64=1)
:param f: Vector
:param dx: stepsize

:return g: gradient</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.gradient2" href="#ElasticFDA.gradient2"><code>ElasticFDA.gradient2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>2-D Gradient</p><pre><code class="language-none">gradient2(a::Array, dx::Float64=1, dy::Float=1)
:param a: matrix
:param dx: stepsize
:param dy: stepsize

:return dxdu: derivatives along x
:return dydv: derivatives along y</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.gradient_spline" href="#ElasticFDA.gradient_spline"><code>ElasticFDA.gradient_spline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate gradient of function using B-splines</p><pre><code class="language-none">gradient_spline(timet::Vector, f, smooth=false)
:param: timet: Vector describing time samples
:param: f: Vector or Array (M,N) describing functions of M samples
:param: smooth: smooth data (default = false)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.gram_schmidt" href="#ElasticFDA.gram_schmidt"><code>ElasticFDA.gram_schmidt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Gram-Schmidt Orthogonalization of basis</p><pre><code class="language-none">gram_schmidt(basis)
:param basis: basis out of find_basis_normal</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.group_action_by_gamma" href="#ElasticFDA.group_action_by_gamma"><code>ElasticFDA.group_action_by_gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Warp srvf by gamma</p><pre><code class="language-none">group_action_by_gamma(q, gamma)
:param q: array (n,T)
:param gamma: vector (T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.group_action_by_gamma_coord" href="#ElasticFDA.group_action_by_gamma_coord"><code>ElasticFDA.group_action_by_gamma_coord</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Warp curve f by gamma</p><pre><code class="language-none">group_action_by_gamma_coord(f, gamma)
:param f: array (n,T)
:param gamma: vector (T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.group_warping_bayes" href="#ElasticFDA.group_warping_bayes"><code>ElasticFDA.group_warping_bayes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Group alignment of functions using Bayesian method</p><pre><code class="language-none">group_warping_bayes(f; iter=20000, times=5, powera=1)
:param f: array (M,N) of N functions
:param iter: number of MCMC iterations
:param times: time slicing
:param powera: MCMC parameter

Returns Dict containing
:return f_q: registered srvfs
:return gam_q: warping function
:return f_a: registered functions
:return gam: warping functions</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.hfpca</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.horiz_fPCA" href="#ElasticFDA.horiz_fPCA"><code>ElasticFDA.horiz_fPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates horizontal functional principal component analysis on aligned data</p><pre><code class="language-none">horiz_fPCA(warp_data; no=1)
:param warp_data: fdawarp type from srsf_align of aligned data
:param no: number of components to extract (default = 1)

Returns hfpca containing
:return gam_pca: warping principal directions
:return psi_pca: srsf functional principal directions
:return latent: latent values
:return U: eigenvectors
:return coef: scores
:return vec: shooting vectors
:return gam_mu: mean warping function</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.include</code></pre><pre><code class="language-none">ElasticFDA.inner_product</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.innerprod_q2" href="#ElasticFDA.innerprod_q2"><code>ElasticFDA.innerprod_q2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find inner product between two srvfs, q1 and q2</p><pre><code class="language-none">innerprod_q2(q1, q2)
:param q1: array (n,T)
:param q2: array (n,T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.interp1_flat" href="#ElasticFDA.interp1_flat"><code>ElasticFDA.interp1_flat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Linear interpolation when response contains flat regions</p><pre><code class="language-none">interp1_flat(x, y, xx)
:param x: time samples
:param y: response samples
:param xx: new time samples</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.inv_exp_map</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.inverse_exp" href="#ElasticFDA.inverse_exp"><code>ElasticFDA.inverse_exp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate shooting vector between two srvfs q1 and q2</p><pre><code class="language-none">inverse_exp(q1, q2, beta2)
:param q1: array (n,T)
:param q2: array (n,T)
:param beta2: array (n,T)

:return v: shooting vector</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.inverse_exp_coord" href="#ElasticFDA.inverse_exp_coord"><code>ElasticFDA.inverse_exp_coord</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate shooting vector and distance between two curves beta1 and beta2</p><pre><code class="language-none">inverse_exp_coord(beta1, beta2)
:param beta1: array (n,T)
:param beta2: array (n,T)
:param method: optimization method to find warping, default is
               Dynamic Programming (&quot;DP&quot;). Other options are
               Coordinate Descent (&quot;DP2&quot;), Riemannian BFGS
               (&quot;RBFGS&quot;)
:param wscale: keep scale (false)

:return v: shooting vector
:return dist: shape distance</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.invert_gamma" href="#ElasticFDA.invert_gamma"><code>ElasticFDA.invert_gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Invert warping function</p><pre><code class="language-none">invert_gamma(gam)
:param gam: vector describing warping function</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.itermatch" href="#ElasticFDA.itermatch"><code>ElasticFDA.itermatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>MCMC iteration for group alignment</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.karcher_calc" href="#ElasticFDA.karcher_calc"><code>ElasticFDA.karcher_calc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>karcher mean calculation function     karcher_calc(beta, q, betamean, mu; mode=&#39;O&#39;)     :param beta: array (n,T)     :param q: array (n,T)     :param betamean: array (n,T)     :param mu: array (n,T)     :param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves     :param wscale: with scale (&#39;false&#39;)</p><pre><code class="language-none">:return v: shooting vector
:return d: elastic distance</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.l2_norm</code></pre><pre><code class="language-none">ElasticFDA.libfdasrsf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.logistic_warp" href="#ElasticFDA.logistic_warp"><code>ElasticFDA.logistic_warp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate warping for logistic regression</p><pre><code class="language-none">logistic_warp(beta, timet, q, y)
:param beta: regression function
:param timet: time samples
:param q: srsf
:param y: response

Returns
:return gamma: new gamma</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.logit_gradient!" href="#ElasticFDA.logit_gradient!"><code>ElasticFDA.logit_gradient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate gradient of logistic optimization in place</p><pre><code class="language-none">logit_gradient!(b, grad, X, y)
:param b: coefficients
:param grad: gradient
:param X: matrix
:param y: response</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.logit_hessian" href="#ElasticFDA.logit_hessian"><code>ElasticFDA.logit_hessian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate Hessian of logistic optimization</p><pre><code class="language-none">logit_hessian(s, b, X, y)
:param s:
:param b: coefficients
:param X: matrix
:param y: response</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.logit_loss" href="#ElasticFDA.logit_loss"><code>ElasticFDA.logit_loss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate logistic loss function</p><pre><code class="language-none">logit_loss(b, X, y)
:param b: coefficients
:param X: matrix
:param y: response

Returns
:return out: loss function</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.logit_optm" href="#ElasticFDA.logit_optm"><code>ElasticFDA.logit_optm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate logistic optimization function</p><pre><code class="language-none">logit_optm(x::Vector, grad::Vector, Phi, y)
:param x: samples
:param grad: gradient
:param Phi: coefficient matrix
:param y: response</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.match_ext" href="#ElasticFDA.match_ext"><code>ElasticFDA.match_ext</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find matching between two extremas</p><pre><code class="language-none">match_ext(t1, ext1, d1, t2, ext2, d2)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.mcmc_results</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.meshgrid" href="#ElasticFDA.meshgrid"><code>ElasticFDA.meshgrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates Rectangular Grid in 2-D space</p><pre><code class="language-none">meshgrid(a::LinRange,b::LinRange)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.mlogit_gradient!" href="#ElasticFDA.mlogit_gradient!"><code>ElasticFDA.mlogit_gradient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate m-logistic elastic regression loss function gradient in place</p><pre><code class="language-none">mlogit_gradient!(b, grad, X, Y)
:param b: coefficients
:param grad: gradient
:param X: matrix
:param Y: response matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.mlogit_loss" href="#ElasticFDA.mlogit_loss"><code>ElasticFDA.mlogit_loss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate loss for m-logistic regression</p><pre><code class="language-none">mlogit_loss(b, X, Y)
:param b: coefficients
:param X: matrix
:param Y: response matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.mlogit_optm" href="#ElasticFDA.mlogit_optm"><code>ElasticFDA.mlogit_optm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate warping for m-logistic elastic regression</p><pre><code class="language-none">mlogit_optim(x, grad, Phi, Y)
:param x: sample
:param grad: gradient
:param Phi: matrix
:param Y: response matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.mlogit_warp_grad" href="#ElasticFDA.mlogit_warp_grad"><code>ElasticFDA.mlogit_warp_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate m-logistic warping using gradient method</p><pre><code class="language-none">mlogit_warp_grad(alpha, beta, timet, q, y; max_itr=8000, tol=1e-10,
                 delt=0.008, display=0)
:param alpha: intercept
:param beta: regression function
:param timet: vector describing time samples
:param q: srsf
:param y: response
:param max_itr: maximum number of iterations
:param tol: stopping tolerance
:param delt: gradient step size
:param display: display optimization iterations</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.mvnrand" href="#ElasticFDA.mvnrand"><code>ElasticFDA.mvnrand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Multivariate Normal random number generation</p><pre><code class="language-none">mvnrand(mu, C, n)
:param mu: mean vector
:param C: covariance matrix
:param n: number of samples</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.norm_gam</code></pre><pre><code class="language-none">ElasticFDA.old_dp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.optimum_reparam" href="#ElasticFDA.optimum_reparam"><code>ElasticFDA.optimum_reparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate optimum parameterization (warping of q2 to q1)</p><pre><code class="language-none">optimum_reparam(q1, timet, q2, lam=0.0, method=&quot;SIMUL&quot;, w=0.01, f1o=0.0,
                f2o=0.0)
:param q1: array (M,N) or vector (M) describing srsf set 1
:param timet: vector describing time samples of length M
:param q2: array (M,N) or vector (M) describing srsf of set 2
:param lam: control amount of warping (default=0.0)
:param method: optimization method to find warping, default is
               Dynamic Programming (&quot;DP&quot;). Other options are
               Coordinate Descent (&quot;DP2&quot;), Riemannian BFGS
               (&quot;RBFGS&quot;), Simultaneous Alignment (&quot;SIMUL&quot;)
:param w: Controls RBFGS (default = 0.01)
:param f1o: initial value of f1, vector or scalar depending on q1, defaults
            to zero
:param f2o: initial value of f2, vector or scalar depending on q1, defaults
            to zero

optimum_reparam(q1, time1, q2, time2, lam=0.0, method=&quot;DP&quot;, w=0.01, f1o=0.0,
                f2o=0.0)
same as above, but different timing for q1 and q2

optimum_reparam(beta1, beta2, lam, method=&quot;DP&quot;, w=0.01, rotated=true,
                isclosed=false)
:param beta1: array (n,T) describing curve 1
:param beta2: array (n,T) describing curve 2
:param lam: control amount of warping (default=0.0)
:param method: optimization method to find warping, default is
               Dynamic Programming (&quot;DP&quot;). Other options are
               Coordinate Descent (&quot;DP2&quot;), Riemanain BFGS
               (&quot;RBFGS&quot;)
:param w: Controls RBFGS (default = 0.01)
:param rotated: calculate rotation (default = true)
:param isclosed: closed curve (default = false)

:return gam: warping function
:return R: rotation matrix
:return tau: seed value</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.pair_warping_bayes" href="#ElasticFDA.pair_warping_bayes"><code>ElasticFDA.pair_warping_bayes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute pair warping between two functions using Bayesian method</p><pre><code class="language-none">pair_warping_bayes(f1, f2; iter=15000, times=5, powera=1)
:param f1, f2: vectors describing functions
:param iter: number of iterations
:param times: MCMC parameter
:param powera: MCMC parameter

Returns Dict containing
:return f1:
:return f2_q: srsf registration
:return gam_q: warping function
:return f2a: registered f2
:return gam: warping function
:return dist_collect: distance
:return best_match: best match</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.pair_warping_expomap" href="#ElasticFDA.pair_warping_expomap"><code>ElasticFDA.pair_warping_expomap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute pair warping between two functions using Bayesian method</p><pre><code class="language-none">pair_warping_expomap(f1, f2, timet; iter=20000, burnin=min(5000,iter/2),
                     alpha0=0.1, beta0=0.1, pbetas=[0.5,0.05,0.005,0.0001],
                     probs=[0.1,0.1,0.7,0.1],propvar=1.0,
                     init_coef=zeros(20),npoints=200,extrainfo=false)

:param f1, f2: vectors describing functions
:param timet: vector describing timing
:param iter: number of MCMC iterations
:param burnin: number of MCMC burnin iterations
:param alpha0, beta0: IG parameters for prior of sigma1
:param pbetas: mixture ratios for pCN
:param probs: mixcture probabilities for zpCN
:param propvar: variance of proposal distribution
:param init_coef: initial g coefficients
:param npoits: number of sample points to use during alignment
:param extrainfo: T/F whether additional information is returned (accept, logl, gamma_mat, gamma_stats, xdist, ydist)

Returns mcmc struct containing
:return f2_warped: warped f2
:return gamma: warping function
:return g_coef: g_coeficients
:return sigma1: variance samples
:return accept: accept samples
:return logl: log-likelihood
:return gamma_mat: posterior warping function samples
:return gamma_stats: posterior warping function samples 95% credible intervals
:return xdist: phase distance of posterior warping functions
:return ydist: amplitude distance of posterior warping functions</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.parallel_translate" href="#ElasticFDA.parallel_translate"><code>ElasticFDA.parallel_translate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Parallel translate srvf  along tangent space</p><pre><code class="language-none">parallel_translate(w, q1, q2, basis, mode=&#39;O&#39;)
:param w: shooting vector
:param q1: array (n,T)
:param q2: array (n,T)
:param basis: basis out of find_basis_normal
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.path</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.phi" href="#ElasticFDA.phi"><code>ElasticFDA.phi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Logistic function</p><pre><code class="language-none">phi(t)

Returns
:return out: phi(t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.pre_proc_curve" href="#ElasticFDA.pre_proc_curve"><code>ElasticFDA.pre_proc_curve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pre-processes curve by centering and projecting to tangent space</p><pre><code class="language-none">pre_proc_curve(beta, T=100)
:param beta: array (n,T)
:param T: number of re-sample points

:return betanew: re-sampled and centered curve
:return qnew: projected srvf
:return A: rotation matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.project_curve" href="#ElasticFDA.project_curve"><code>ElasticFDA.project_curve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Project curve onto normal tangent space</p><pre><code class="language-none">project_curve(q)
:param q: array (n,T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.project_tangent" href="#ElasticFDA.project_tangent"><code>ElasticFDA.project_tangent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Project srvf onto tangent space</p><pre><code class="language-none">project_tangent(w, q, basis)
:param w: shooting vector
:param q: array (n,T)
:param basis: basis out of find_basis_normal</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.psi" href="#ElasticFDA.psi"><code>ElasticFDA.psi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate psi</p><pre><code class="language-none">psi(x,a,q)
:param x: array (n, T) of curve
:param a: vector (n) of centroid
:param q: array (n, T) of srvf</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.q_to_curve" href="#ElasticFDA.q_to_curve"><code>ElasticFDA.q_to_curve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert srvf to curve</p><pre><code class="language-none">q_to_curve(q)
:param q: array describing srvf (n,T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.qtocurve" href="#ElasticFDA.qtocurve"><code>ElasticFDA.qtocurve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Bayesian qtocurve function</p><pre><code class="language-none">qtocurve(q, timet=0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.random_gamma" href="#ElasticFDA.random_gamma"><code>ElasticFDA.random_gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generates random warping functions based on gam</p><pre><code class="language-none">random_gamma(gam, num)
:param gam: array (M,N) describing warping functions
:param num: number of functions to generate</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.regression_warp" href="#ElasticFDA.regression_warp"><code>ElasticFDA.regression_warp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Optimization function to calculate warping for elastic regression</p><pre><code class="language-none">regression_warp(beta, timet, q, y, alpha)
:param beta: regression function
:param timet: vector describing time samples
:param q: vector describing srsf
:param y: response value
:param alpha: intercept

Returns
:return gamma_new: new gamma</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.resamplecurve" href="#ElasticFDA.resamplecurve"><code>ElasticFDA.resamplecurve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Resample curve</p><pre><code class="language-none">resamplecurve(x, N=100)
:param x: array describing curve (n,T)
:param N: Number of samples to re-sample curve, N usually is &gt; T</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.rgam" href="#ElasticFDA.rgam"><code>ElasticFDA.rgam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate random warping functions</p><pre><code class="language-none">rgam(N, sigma, num)
:param N: number of time points
:param sigma: standard deviation across samples
:param num: number of random warpings</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.rot_mat" href="#ElasticFDA.rot_mat"><code>ElasticFDA.rot_mat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find rotation matrix for angle theta</p><pre><code class="language-none">rot_mat(theta)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.sample_shapes" href="#ElasticFDA.sample_shapes"><code>ElasticFDA.sample_shapes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Sample shapes from model</p><pre><code class="language-none">sample_shapes(mu, K; mode=&#39;O&#39;, no=3, numSamp=10)
:param mu: array (n,T) mean srvf
:param K: array (T,T) covariance matrix
:param mode: Open (&#39;O&#39;) or Closed (&#39;C&#39;) curves
:param no: number of principal components
:param numSamp: number of samples

:return samples: array (n,T,numSamp) of sample curves</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.scale_curve" href="#ElasticFDA.scale_curve"><code>ElasticFDA.scale_curve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Scale curve to unit length</p><pre><code class="language-none">scale_curve(beta)
:param beta: array (n,T)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.shift_f" href="#ElasticFDA.shift_f"><code>ElasticFDA.shift_f</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Shift curve f by tau</p><pre><code class="language-none">shift_f(f, tau)
:param f: array (n,T)
:param tau: scalar</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.simuiter" href="#ElasticFDA.simuiter"><code>ElasticFDA.simuiter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>MCMC iteration for pairwise alignment</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.simul_align" href="#ElasticFDA.simul_align"><code>ElasticFDA.simul_align</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Simultaneous alignment between two functions</p><pre><code class="language-none">simul_align(f1::Vector, f2::Vector)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.simul_gam" href="#ElasticFDA.simul_gam"><code>ElasticFDA.simul_gam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate warping from q2 to q2 from simultaneous warping</p><pre><code class="language-none">simul_gam(u, g1,g2,t,s1,s2,tt)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.simul_reparam" href="#ElasticFDA.simul_reparam"><code>ElasticFDA.simul_reparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find simultaneous re-parametrization</p><pre><code class="language-none">simul_reparam(te1, te2, mpath)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.simul_reparam_segment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.smooth_data" href="#ElasticFDA.smooth_data"><code>ElasticFDA.smooth_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Smooth functional data using box filter</p><pre><code class="language-none">smooth_data(f::Array{Float64,1}, sparam=10)
:param sparam: Number of times to run filter (default = 10)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.smooth_data!" href="#ElasticFDA.smooth_data!"><code>ElasticFDA.smooth_data!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Smooth functional data using box filter in place</p><pre><code class="language-none">smooth_data!(f::Array{Float64,2}, sparam=10)</code></pre></div></div><div><div><pre><code class="language-none">smooth_data!(f::Array{Float64,1}, sparam=10)
:param sparam: Number of times to run filter (default = 10)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.sqrt_mean" href="#ElasticFDA.sqrt_mean"><code>ElasticFDA.sqrt_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate sqrt mean of warping functions</p><pre><code class="language-none">sqrt_mean(gam)
:param gam: array (M,N) describing warping functions</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.sqrt_mean_inverse" href="#ElasticFDA.sqrt_mean_inverse"><code>ElasticFDA.sqrt_mean_inverse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate sqrt mean inverse of warping function</p><pre><code class="language-none">sqrt_mean_inverse(gam)
:param gam: array (M,N) describing warping functions</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.srsf_align" href="#ElasticFDA.srsf_align"><code>ElasticFDA.srsf_align</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Aligns a collection of functions using the elastic square-root slope (srsf) framework.</p><pre><code class="language-none">srsf_align(f, timet; method=&quot;mean&quot;, smooth=false, sparam=10, lam=0.0,
           optim=&quot;DP&quot;, MaxItr=20)
:param f: array of shape (M,N) of N functions with M samples
:param timet: vector of size M describing the sample points
:param method: (string) calculate Karcher Mean or Median
(options = &quot;mean&quot; or &quot;median&quot;) (default=&quot;mean&quot;)
:param smooth: Smooth the data using a box filter (default = false)
:param sparam: Number of times to run smoothing filter (default 10)
:param lam: controls the elasticity (default = 0)
:param optim: optimization method to find warping, default is
              Simultaneous Alignment (&quot;SIMUL&quot;). Other options are
              Dynamic Programming (&quot;DP2&quot;), Riemannian BFGS
              (&quot;RBFGS&quot;)
:param MaxItr: Maximum number of iterations

Returns fdawarp type containing
:return fn: aligned functions - array of shape (M,N) of N
            functions with M samples
:return qn: aligned srsfs - similar structure to fn
:return q0: original srsfs - similar structure to fn
:return fmean: function mean or median - vector of length N
:return mqn: srvf mean or median - vector of length N
:return gam: warping functions - similar structure to fn
:return orig_var: Original Variance of Functions
:return amp_var: Amplitude Variance
:return phase_var: Phase Variance</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.srsf_to_f" href="#ElasticFDA.srsf_to_f"><code>ElasticFDA.srsf_to_f</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert square-root slope function (srsf) to f</p><pre><code class="language-none">srsf_to_f(q::Array, time, f0=0.0)
:param q: array of shape (M,N) describing N srsf of M samples
:param time: vector describing time samples of length M
:param f0: initial value of f</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.statsFun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.trapz" href="#ElasticFDA.trapz"><code>ElasticFDA.trapz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Trapezoidal Integration</p><pre><code class="language-none">trapz(x, y, dim=1)
:param x: vector of time samples
:param y: array of response samples
:param dim: dimension along which to integrate</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.vert_fPCA" href="#ElasticFDA.vert_fPCA"><code>ElasticFDA.vert_fPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates vertical functional principal component analysis on aligned data</p><pre><code class="language-none">vert_fPCA(warp_data, qn; no=1)
:param warp_data: fdawarp type from srsf_align of aligned data
:param no: number of components to extract (default = 1)

Returns vfpca type containing
:return q_pca: srsf principal directions
:return f_pca: functional principal directions
:return latent: latent values
:return coef: scores
:return U: eigenvectors
:return id: point used for f(0)</code></pre></div></div></section><pre><code class="language-none">ElasticFDA.vfpca</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.warp_f_gamma" href="#ElasticFDA.warp_f_gamma"><code>ElasticFDA.warp_f_gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Warp function by gamma</p><pre><code class="language-none">warp_f_gamma(time::Vector, f::Vector, gam::Vector)
:param time: describes time samples
:param f: describes function
:param gam: describes warping function</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.warp_q_gamma" href="#ElasticFDA.warp_q_gamma"><code>ElasticFDA.warp_q_gamma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Warp srsf by gamma</p><pre><code class="language-none">warp_q_gamma(time::Vector, q::Vector, gam::Vector)
:param time: describes time samples
:param q: describes srsf
:param gam: describes warping function</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ElasticFDA.zero_crossing" href="#ElasticFDA.zero_crossing"><code>ElasticFDA.zero_crossing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculate zero crossing of optimal warping function</p><pre><code class="language-none">zero_crossing(Y,q,bt,timet,y_max,y_min,gmax,gmin)</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
