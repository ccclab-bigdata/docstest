<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· JSON.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JSON.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Basic-Usage-1">Basic Usage</a></li><li><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="JSON.jl-1" href="#JSON.jl-1">JSON.jl</a></h1><h3><a class="nav-anchor" id="Parsing-and-printing-JSON-in-pure-Julia.-1" href="#Parsing-and-printing-JSON-in-pure-Julia.-1">Parsing and printing JSON in pure Julia.</a></h3><p><a href="https://travis-ci.org/JuliaIO/JSON.jl"><img src="https://travis-ci.org/JuliaIO/JSON.jl.svg" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/staticfloat/json-jl"><img src="https://ci.appveyor.com/api/projects/status/2sfomjwl29k6y6oy" alt="Build status"/></a> <a href="http://codecov.io/github/JuliaIO/JSON.jl?branch=master"><img src="http://codecov.io/github/JuliaIO/JSON.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p><a href="http://pkg.julialang.org/?pkg=JSON&amp;ver=0.3"><img src="http://pkg.julialang.org/badges/JSON_0.3.svg" alt="JSON"/></a> <a href="http://pkg.julialang.org/?pkg=JSON&amp;ver=0.4"><img src="http://pkg.julialang.org/badges/JSON_0.4.svg" alt="JSON"/></a> <a href="http://pkg.julialang.org/?pkg=JSON&amp;ver=0.5"><img src="http://pkg.julialang.org/badges/JSON_0.5.svg" alt="JSON"/></a> <a href="http://pkg.julialang.org/?pkg=JSON&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/JSON_0.6.svg" alt="JSON"/></a></p><p><strong>Installation</strong>: <code>julia&gt; Pkg.add(&quot;JSON&quot;)</code></p><h2><a class="nav-anchor" id="Basic-Usage-1" href="#Basic-Usage-1">Basic Usage</a></h2><pre><code class="language-julia">import JSON

# JSON.parse - string or stream to Julia data structures
s = &quot;{\&quot;a_number\&quot; : 5.0, \&quot;an_array\&quot; : [\&quot;string\&quot;, 9]}&quot;
j = JSON.parse(s)
#  Dict{AbstractString,Any} with 2 entries:
#    &quot;an_array&quot; =&gt; {&quot;string&quot;,9}
#    &quot;a_number&quot; =&gt; 5.0

# JSON.json - Julia data structures to a string
JSON.json([2,3])
#  &quot;[2,3]&quot;
JSON.json(j)
#  &quot;{\&quot;an_array\&quot;:[\&quot;string\&quot;,9],\&quot;a_number\&quot;:5.0}&quot;</code></pre><h2><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h2><pre><code class="language-julia">JSON.print(io::IO, s::AbstractString)
JSON.print(io::IO, s::Union{Integer, AbstractFloat})
JSON.print(io::IO, n::Nothing)
JSON.print(io::IO, b::Bool)
JSON.print(io::IO, a::AbstractDict)
JSON.print(io::IO, v::AbstractVector)
JSON.print{T, N}(io::IO, v::Array{T, N})</code></pre><p>Writes a compact (no extra whitespace or indentation) JSON representation to the supplied IO.</p><pre><code class="language-julia">JSON.print(a::AbstractDict, indent)
JSON.print(io::IO, a::AbstractDict, indent)</code></pre><p>Writes a JSON representation with newlines, and indentation if specified. Non-zero <code>indent</code> will be applied recursively to nested elements.</p><pre><code class="language-julia">json(a::Any)</code></pre><p>Returns a compact JSON representation as an <code>AbstractString</code>.</p><pre><code class="language-julia">JSON.parse(s::AbstractString; dicttype=Dict, inttype=Int64)
JSON.parse(io::IO; dicttype=Dict, inttype=Int64)
JSON.parsefile(filename::AbstractString; dicttype=Dict, inttype=Int64, use_mmap=true)</code></pre><p>Parses a JSON <code>AbstractString</code> or IO stream into a nested <code>Array</code> or <code>Dict</code>.</p><p>The <code>dicttype</code> indicates the dictionary type (<code>&lt;: Associative</code>), or a function that returns an instance of a dictionary type, that JSON objects are parsed to.  It defaults to <code>Dict</code> (the built-in Julia dictionary), but a different type can be passed for additional functionality. For example, if you <code>import DataStructures</code> (assuming the <a href="https://github.com/JuliaLang/DataStructures.jl">DataStructures package</a> is installed)</p><ul><li>you can pass <code>dicttype=DataStructures.OrderedDict</code> to maintain the insertion order of the items in the object;</li><li>or you can pass <code>()-&gt;DefaultDict{String,Any}(Missing)</code> to having any non-found keys return <code>missing</code> when you index the result.</li></ul><p>The <code>inttype</code> argument controls how integers are parsed.  If a number in a JSON file is recognized to be an integer, it is parsed as one; otherwise it is parsed as a <code>Float64</code>.  The <code>inttype</code> defaults to <code>Int64</code>, but, for example, if you know that your integer numbers are all small and want to save space, you can pass <code>inttype=Int32</code>.  Alternatively, if your JSON input has integers which are too large for Int64, you can pass <code>inttype=Int128</code> or <code>inttype=BigInt</code>.  <code>inttype</code> can be any subtype of <code>Real</code>.</p><pre><code class="language-julia">JSONText(s::AbstractString)</code></pre><p>A wrapper around a Julia string representing JSON-formatted text, which is inserted <em>as-is</em> in the JSON output of <code>JSON.print</code> and <code>JSON.json</code>.</p><pre><code class="language-julia">JSON.lower(p::Point2D) = [p.x, p.y]</code></pre><p>Define a custom serialization rule for a particular data type. Must return a value that can be directly serialized; see help for more details.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
