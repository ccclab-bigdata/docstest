<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · WeightedArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>WeightedArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">WeightedArrays.@pack_WeightOpt</code></pre><pre><code class="language-none">WeightedArrays.@pack_WeightOpt!</code></pre><pre><code class="language-none">WeightedArrays.@unpack_WeightOpt</code></pre><pre><code class="language-none">WeightedArrays.ALPHA</code></pre><pre><code class="language-none">WeightedArrays.AbsArray</code></pre><pre><code class="language-none">WeightedArrays.AbsMat</code></pre><pre><code class="language-none">WeightedArrays.AbsVec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CatViews.CatView" href="#CatViews.CatView"><code>CatViews.CatView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CatView(x::Weighted)</code></pre><p>Gives a vector-like view of both <code>x.array</code> and <code>x.weights</code>, the last <code>d</code> components are weights.</p></div></div></section><pre><code class="language-none">WeightedArrays.ClampedWeighted</code></pre><pre><code class="language-none">WeightedArrays.DIGITS</code></pre><pre><code class="language-none">WeightedArrays.GroupSlices</code></pre><pre><code class="language-none">WeightedArrays.MINPROB</code></pre><pre><code class="language-none">WeightedArrays.MINWEIGHT</code></pre><pre><code class="language-none">WeightedArrays.MaybeWeightedArray</code></pre><pre><code class="language-none">WeightedArrays.MaybeWeightedMatrix</code></pre><pre><code class="language-none">WeightedArrays.MaybeWeightedVector</code></pre><pre><code class="language-none">WeightedArrays.PLOTSIZE</code></pre><pre><code class="language-none">WeightedArrays.SAVED_PCA</code></pre><pre><code class="language-none">WeightedArrays.UnClampedWeighted</code></pre><pre><code class="language-none">WeightedArrays.WeightOpt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.Weighted" href="#WeightedArrays.Weighted"><code>WeightedArrays.Weighted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">x = Weighted(array, weights)</code></pre><p>Created a Weighted Array, with given weights associated to the last dimension of array, e.g. to columns of a matrix. Keyword <code>norm=true</code> specifies that <code>weights(x)</code> sum to 1 always; this is enforced on construction. Calling <code>normalise!(x)</code> will re-enforce this, after scaling <code>2x</code> or <code>hcat()</code>-ing <code>x + y</code> or mutating.</p><pre><code class="language-none">x = Weighted(array, weights, lo, hi)</code></pre><p>Here every <code>θ ∈ array</code> is constrained <code>lo ≦ θ ≦ hi</code>, the same for all dimensions. (Weights are similarly <code>0 ≦ λ &lt; ∞</code>.) Calling <code>clamp!(x)</code> will re-enforce these box constraints, for instance after mutating <code>x[1,2] *= 3</code> or on <code>y = x .+ 0.4</code>.</p></div></div></section><pre><code class="language-none">WeightedArrays.WeightedArray</code></pre><pre><code class="language-none">WeightedArrays.WeightedArrays</code></pre><pre><code class="language-none">WeightedArrays.WeightedMatrix</code></pre><pre><code class="language-none">WeightedArrays.WeightedVector</code></pre><pre><code class="language-none">WeightedArrays.__init__</code></pre><pre><code class="language-none">WeightedArrays.addlname</code></pre><pre><code class="language-none">WeightedArrays.addname</code></pre><pre><code class="language-none">WeightedArrays.aname</code></pre><pre><code class="language-none">WeightedArrays.array</code></pre><pre><code class="language-none">WeightedArrays.clampdoc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.clip" href="#WeightedArrays.clip"><code>WeightedArrays.clip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clip(x, ϵ=1.0e-100)
clip!(x)</code></pre><p>Sets to zero all entries <code>abs(x[i]) &lt; ϵ</code>. When <code>x::Weighted</code> this acts on <code>x.array</code> only; see also <code>trim()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.clip!" href="#WeightedArrays.clip!"><code>WeightedArrays.clip!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">clip(x, ϵ=1.0e-100)
clip!(x)</code></pre><p>Sets to zero all entries <code>abs(x[i]) &lt; ϵ</code>. When <code>x::Weighted</code> this acts on <code>x.array</code> only; see also <code>trim()</code>.</p></div></div></div></section><pre><code class="language-none">WeightedArrays.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.flatcopy" href="#WeightedArrays.flatcopy"><code>WeightedArrays.flatcopy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">flatten(x::Weighted)</code></pre><p>Makes a vector <code>[ reshaped(x.array,:) ; x.weights ]</code>.</p><pre><code class="language-none">flatcopy!(x, v::Vector)</code></pre><p>Copies numbers from <code>v = flatten(x)</code> back into <code>x</code>.</p><pre><code class="language-none">flatcopy(x, v)</code></pre><p>Uses only <code>size(x)</code> to know what shape <code>::Weighted</code> to make out of <code>v</code> (and <code>x.opt</code> for details).</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.flatcopy!" href="#WeightedArrays.flatcopy!"><code>WeightedArrays.flatcopy!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">flatten(x::Weighted)</code></pre><p>Makes a vector <code>[ reshaped(x.array,:) ; x.weights ]</code>.</p><pre><code class="language-none">flatcopy!(x, v::Vector)</code></pre><p>Copies numbers from <code>v = flatten(x)</code> back into <code>x</code>.</p><pre><code class="language-none">flatcopy(x, v)</code></pre><p>Uses only <code>size(x)</code> to know what shape <code>::Weighted</code> to make out of <code>v</code> (and <code>x.opt</code> for details).</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.flatten" href="#WeightedArrays.flatten"><code>WeightedArrays.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flatten(x::Weighted)</code></pre><p>Makes a vector <code>[ reshaped(x.array,:) ; x.weights ]</code>.</p><pre><code class="language-none">flatcopy!(x, v::Vector)</code></pre><p>Copies numbers from <code>v = flatten(x)</code> back into <code>x</code>.</p><pre><code class="language-none">flatcopy(x, v)</code></pre><p>Uses only <code>size(x)</code> to know what shape <code>::Weighted</code> to make out of <code>v</code> (and <code>x.opt</code> for details).</p></div></div></section><pre><code class="language-none">WeightedArrays.flipzero</code></pre><pre><code class="language-none">WeightedArrays.grsafe</code></pre><pre><code class="language-none">WeightedArrays.include</code></pre><pre><code class="language-none">WeightedArrays.lastlength</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.load" href="#WeightedArrays.load"><code>WeightedArrays.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">save(Π, &quot;file.csv&quot;) = writecsv(&quot;file.csv&quot;, Π)
save(Π, &quot;file.json&quot;)
save(Π, &quot;file.jld&quot;) = JLD.save(file, &quot;Π&quot;, Π)</code></pre><p>Save <code>Π::Weighted</code> to disk, in one of several formats:</p><ul><li><p>CSV: weights are rightmost column, as in <code>[Π.array&#39; Π.weights]</code>. Options aren&#39;t saved, and <code>load()</code> will try to guess them from the numbers. Mathematica: <code>arr = Import[&quot;file.csv&quot;][[;; , 1 ;; -2]]; wei = Import[&quot;file.csv&quot;][[;; , -1]]</code></p></li><li><p>JSON: saves a dictionary, but <code>dict[&quot;array&quot;]</code> is a nested Vector{Vector{Any}} for now, which <code>load()</code> converts to Float64. Includes <code>dict[&quot;opt&quot;] == String(Π.opt)</code>. Mathematica: <code>arr = Import[&quot;file.json&quot;][[1, 2]]; wei = Import[&quot;file.json&quot;][[3, 2]]</code> ... and then maybe <code>Style @@@ Thread[{arr, PointSize /@ (0.3*Sqrt[wei]), Opacity[0.5]}] // ListPlot</code> ?</p></li><li><p>JLD: built-in HDF5 format binary saving, fast &amp; neat but perhaps fragile. Removed for now!</p></li></ul><pre><code class="language-none">Π = load(&quot;file.csv&quot;) = readcsv(&quot;file.csv&quot;, Π)
Π = load(&quot;file.json&quot;)
Π = load(&quot;file.jld&quot;) = JLD.load(file, &quot;Π&quot;)</code></pre><p>Reverse the above.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.maxcol" href="#WeightedArrays.maxcol"><code>WeightedArrays.maxcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxcol(x)
maxcol(x, weights)</code></pre><p>Returns the column of <code>x</code> with the largest weight, as the same type. If <code>x::Weighted{Matrix}</code> then weights need not be given.</p></div></div></section><pre><code class="language-none">WeightedArrays.maxweight</code></pre><pre><code class="language-none">WeightedArrays.myround</code></pre><pre><code class="language-none">WeightedArrays.near</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.normalise" href="#WeightedArrays.normalise"><code>WeightedArrays.normalise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalise(x) ## with an s, NB!
normalise!(x)</code></pre><p>Ensures weights are positive and sum to 1. On <code>x::Weighted</code>... the mutating form checks whether <code>norm=true</code> in <code>x.opt</code>; the copying (!) form sets this flag first.</p><pre><code class="language-none">unnormalise(x)
unnormalise!(x)</code></pre><p>Just alters the flag <code>x.opt.norm</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.normalise!" href="#WeightedArrays.normalise!"><code>WeightedArrays.normalise!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">normalise(x) ## with an s, NB!
normalise!(x)</code></pre><p>Ensures weights are positive and sum to 1. On <code>x::Weighted</code>... the mutating form checks whether <code>norm=true</code> in <code>x.opt</code>; the copying (!) form sets this flag first.</p><pre><code class="language-none">unnormalise(x)
unnormalise!(x)</code></pre><p>Just alters the flag <code>x.opt.norm</code>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.pairwise2" href="#WeightedArrays.pairwise2"><code>WeightedArrays.pairwise2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pairwise2(x, y=x) = Distances.pairwise(SqEuclidean(), x, y)</code></pre><p>Resulting <code>mat[i,j]</code> is distance sqared from <code>x[:,i]</code> to <code>y[:,j]</code>. Implementation varies.</p></div></div></section><pre><code class="language-none">WeightedArrays.pcaylim</code></pre><pre><code class="language-none">WeightedArrays.pointsize</code></pre><pre><code class="language-none">WeightedArrays.positive</code></pre><pre><code class="language-none">WeightedArrays.pplot</code></pre><pre><code class="language-none">WeightedArrays.pplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.rPCA" href="#WeightedArrays.rPCA"><code>WeightedArrays.rPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></div></section><pre><code class="language-none">WeightedArrays.readcsv</code></pre><pre><code class="language-none">WeightedArrays.readjson</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.rpca" href="#WeightedArrays.rpca"><code>WeightedArrays.rpca</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.sPCA" href="#WeightedArrays.sPCA"><code>WeightedArrays.sPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.save" href="#WeightedArrays.save"><code>WeightedArrays.save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">save(Π, &quot;file.csv&quot;) = writecsv(&quot;file.csv&quot;, Π)
save(Π, &quot;file.json&quot;)
save(Π, &quot;file.jld&quot;) = JLD.save(file, &quot;Π&quot;, Π)</code></pre><p>Save <code>Π::Weighted</code> to disk, in one of several formats:</p><ul><li><p>CSV: weights are rightmost column, as in <code>[Π.array&#39; Π.weights]</code>. Options aren&#39;t saved, and <code>load()</code> will try to guess them from the numbers. Mathematica: <code>arr = Import[&quot;file.csv&quot;][[;; , 1 ;; -2]]; wei = Import[&quot;file.csv&quot;][[;; , -1]]</code></p></li><li><p>JSON: saves a dictionary, but <code>dict[&quot;array&quot;]</code> is a nested Vector{Vector{Any}} for now, which <code>load()</code> converts to Float64. Includes <code>dict[&quot;opt&quot;] == String(Π.opt)</code>. Mathematica: <code>arr = Import[&quot;file.json&quot;][[1, 2]]; wei = Import[&quot;file.json&quot;][[3, 2]]</code> ... and then maybe <code>Style @@@ Thread[{arr, PointSize /@ (0.3*Sqrt[wei]), Opacity[0.5]}] // ListPlot</code> ?</p></li><li><p>JLD: built-in HDF5 format binary saving, fast &amp; neat but perhaps fragile. Removed for now!</p></li></ul><pre><code class="language-none">Π = load(&quot;file.csv&quot;) = readcsv(&quot;file.csv&quot;, Π)
Π = load(&quot;file.json&quot;)
Π = load(&quot;file.jld&quot;) = JLD.load(file, &quot;Π&quot;)</code></pre><p>Reverse the above.</p></div></div></section><pre><code class="language-none">WeightedArrays.shadowxy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.sigmoid" href="#WeightedArrays.sigmoid"><code>WeightedArrays.sigmoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmoid(Π)</code></pre><p>Compactifies all entries to [0,1], approximately <code>== sigmoid.(Π)</code> but with nice labels etc. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.sobol" href="#WeightedArrays.sobol"><code>WeightedArrays.sobol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sobol(d, k)</code></pre><p>First <code>k</code> entries from the <code>d</code>-dimensional Sobol sequence, as columns of a <code>Weighted{Matrix}</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.soboln" href="#WeightedArrays.soboln"><code>WeightedArrays.soboln</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">soboln(d, k)</code></pre><p>Normally distributed <code>d</code>-vectors, of mean zero and std. dev. π, generated from Sobol sequence, as columns of a <code>Weighted{Matrix}</code>. </p></div></div></section><pre><code class="language-none">WeightedArrays.sobolnp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.sortcols" href="#WeightedArrays.sortcols"><code>WeightedArrays.sortcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sortcols(x::WeightedMatrix)</code></pre><p>Sorts according to <code>θ₁</code>, i.e. the first row of <code>array(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.spca" href="#WeightedArrays.spca"><code>WeightedArrays.spca</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></div></section><pre><code class="language-none">WeightedArrays.sureweights</code></pre><pre><code class="language-none">WeightedArrays.svecs</code></pre><pre><code class="language-none">WeightedArrays.totweight</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.trim" href="#WeightedArrays.trim"><code>WeightedArrays.trim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trim(x::Weighted)
trim!(x::Weighted)</code></pre><p>Removes points with weight less than cutoff <code>cut=1.0e-10</code>, either copying or mutating.</p><pre><code class="language-none">trim!(Π::Weighted, L::Weighted)</code></pre><p>Removes the same columns from both, using the first one&#39;s weights. Mutates both arguments! Returns tuple <code>(Π,L)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.trim!" href="#WeightedArrays.trim!"><code>WeightedArrays.trim!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">trim(x::Weighted)
trim!(x::Weighted)</code></pre><p>Removes points with weight less than cutoff <code>cut=1.0e-10</code>, either copying or mutating.</p><pre><code class="language-none">trim!(Π::Weighted, L::Weighted)</code></pre><p>Removes the same columns from both, using the first one&#39;s weights. Mutates both arguments! Returns tuple <code>(Π,L)</code>.</p></div></div></div></section><pre><code class="language-none">WeightedArrays.trim_</code></pre><pre><code class="language-none">WeightedArrays.unclamp</code></pre><pre><code class="language-none">WeightedArrays.unique_</code></pre><pre><code class="language-none">WeightedArrays.uniquedoc</code></pre><pre><code class="language-none">WeightedArrays.unnormalise</code></pre><pre><code class="language-none">WeightedArrays.unnormalise!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.wPCA" href="#WeightedArrays.wPCA"><code>WeightedArrays.wPCA</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></section><pre><code class="language-none">WeightedArrays.wcopy</code></pre><pre><code class="language-none">WeightedArrays.wcopy!</code></pre><pre><code class="language-none">WeightedArrays.weights</code></pre><pre><code class="language-none">WeightedArrays.wglue</code></pre><pre><code class="language-none">WeightedArrays.wgrid</code></pre><pre><code class="language-none">WeightedArrays.wname</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.wpca" href="#WeightedArrays.wpca"><code>WeightedArrays.wpca</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f = wPCA(x::Weighted, d=2)
f(x)::Weighted</code></pre><p>Works out the <code>MultivariateStats.PCA</code> to project <code>x</code> into <code>d</code> dimensions. To ignore weights, use <code>wPCA(array(x), d)</code> instead. Returned object can be used as a function <code>f(y) ≈ transform(f,array(y))</code>, preserving <code>weights(y)</code>.</p><pre><code class="language-none">sPCA(x, d=2)
rPCA(y)</code></pre><p>Version with <code>s</code> saves the function above to a global variable, and also applies it, returning <code>f(x)</code>. Then you can recall it, and apply it to some other data, with <code>rPCA(y)</code>. For example:</p><pre><code class="language-none">julia&gt; xx = wrandn(7,50); yy = xx[:, 1:10] |&gt; normalise
julia&gt; plot(xx, sPCA); plot!(yy, rPCA)</code></pre><p>Now equivalent to using PCA-plot function: <code>pplot(xx); pplot!(yy)</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.wrand" href="#WeightedArrays.wrand"><code>WeightedArrays.wrand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wrand(d, k) = Weighted(rand(d, k))</code></pre><p>Uniformly distributed vectors in <code>[0,1]^d</code>, as columns of a <code>Weighted{Matrix}</code> which knows to <code>clamp</code> them to this box. Keyword <code>weights=true</code> gives weights ∝ <code>1 .+ rand(k)</code> rather than constant. Default is now <code>k=1</code>, making a one-column matrix.</p><pre><code class="language-none">wrandn(d, k) = π .* Weighted(randn(d, k))</code></pre><p>Normally distributed <code>d</code>-vectors, of mean zero and std. dev. <code>scale=π</code> by default. Keyword <code>max=10</code> clamps absolute values to be less than this. </p><pre><code class="language-none">wrandnp(d, k)</code></pre><p>Absolute value of normally distributed...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.wrandn" href="#WeightedArrays.wrandn"><code>WeightedArrays.wrandn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">wrand(d, k) = Weighted(rand(d, k))</code></pre><p>Uniformly distributed vectors in <code>[0,1]^d</code>, as columns of a <code>Weighted{Matrix}</code> which knows to <code>clamp</code> them to this box. Keyword <code>weights=true</code> gives weights ∝ <code>1 .+ rand(k)</code> rather than constant. Default is now <code>k=1</code>, making a one-column matrix.</p><pre><code class="language-none">wrandn(d, k) = π .* Weighted(randn(d, k))</code></pre><p>Normally distributed <code>d</code>-vectors, of mean zero and std. dev. <code>scale=π</code> by default. Keyword <code>max=10</code> clamps absolute values to be less than this. </p><pre><code class="language-none">wrandnp(d, k)</code></pre><p>Absolute value of normally distributed...</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.wrandnp" href="#WeightedArrays.wrandnp"><code>WeightedArrays.wrandnp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none">wrand(d, k) = Weighted(rand(d, k))</code></pre><p>Uniformly distributed vectors in <code>[0,1]^d</code>, as columns of a <code>Weighted{Matrix}</code> which knows to <code>clamp</code> them to this box. Keyword <code>weights=true</code> gives weights ∝ <code>1 .+ rand(k)</code> rather than constant. Default is now <code>k=1</code>, making a one-column matrix.</p><pre><code class="language-none">wrandn(d, k) = π .* Weighted(randn(d, k))</code></pre><p>Normally distributed <code>d</code>-vectors, of mean zero and std. dev. <code>scale=π</code> by default. Keyword <code>max=10</code> clamps absolute values to be less than this. </p><pre><code class="language-none">wrandnp(d, k)</code></pre><p>Absolute value of normally distributed...</p></div></div></div></section><pre><code class="language-none">WeightedArrays.writecsv</code></pre><pre><code class="language-none">WeightedArrays.writejson</code></pre><pre><code class="language-none">WeightedArrays.wsobol</code></pre><pre><code class="language-none">WeightedArrays.xaxis_grbug</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="WeightedArrays.xgrid" href="#WeightedArrays.xgrid"><code>WeightedArrays.xgrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xgrid(d, 0:0.1:5)</code></pre><p>Gives the matrix whose colums are <code>d</code>-vectors, forming a grid of the given range in all dimensions. </p></div></div></section><pre><code class="language-none">WeightedArrays.yaxis_grbug</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
