<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · SimpleTraits.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleTraits.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Manual-1">Manual</a></li><li><a class="toctext" href="#[Traitor.jl](https://github.com/andyferris/Traitor.jl)-like-syntax-1">Traitor.jl-like syntax</a></li><li><a class="toctext" href="#Vararg,-default-argument-and-keyword-argument-trait-functions-1">Vararg, default argument and keyword argument trait functions</a></li><li><a class="toctext" href="#Method-overwritten-warnings-1">Method overwritten warnings</a></li><li class="toplevel"><a class="toctext" href="#Details-of-method-dispatch-1">Details of method dispatch</a></li><li><a class="toctext" href="#Advanced-features-1">Advanced features</a></li><li class="toplevel"><a class="toctext" href="#Innards-1">Innards</a></li><li class="toplevel"><a class="toctext" href="#Base-Traits-1">Base Traits</a></li><li class="toplevel"><a class="toctext" href="#Background-1">Background</a></li><li class="toplevel"><a class="toctext" href="#The-Future-1">The Future</a></li><li class="toplevel"><a class="toctext" href="#References-1">References</a></li><li class="toplevel"><a class="toctext" href="#To-ponder-1">To ponder</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SimpleTraits-1" href="#SimpleTraits-1">SimpleTraits</a></h1><p><a href="https://travis-ci.org/mauro3/SimpleTraits.jl"><img src="https://travis-ci.org/mauro3/SimpleTraits.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/mauro3/simpletraits-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/mauro3/SimpleTraits.jl?branch=master&amp;svg=true" alt="Build Status"/></a> <a href="NEWS.md">NEWS</a></p><p><a href="http://pkg.julialang.org/?pkg=SimpleTraits"><img src="http://pkg.julialang.org/badges/SimpleTraits_0.6.svg" alt="SimpleTraits"/></a> <a href="http://pkg.julialang.org/detail/SimpleTraits"><img src="http://pkg.julialang.org/badges/SimpleTraits_0.7.svg" alt="SimpleTraits"/></a></p><p>This package provides a macro-based implementation of traits, using <a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633">Tim Holy&#39;s trait trick</a>. The main idea behind traits is to group types outside the type-hierarchy and to make dispatch work with that grouping.  The difference to Union-types is that types can be added to a trait after the creation of the trait, whereas Union types are fixed after creation.  The cool thing about Tim&#39;s trick is that there is no performance impact compared to using ordinary dispatch.  For a bit of background and a quick introduction to traits watch my 10min <a href="https://youtu.be/j9w8oHfG1Ic">JuliaCon 2015</a> talk.</p><p>One good example of the use of traits is the <a href="https://docs.julialang.org/en/stable/manual/interfaces/#man-interface-array-1">abstract array interface</a> in Julia-Base.  An abstract array either belongs to the <code>Base.IndexLinear</code> or <code>Base.IndexCartesian</code> trait, depending on how its internal indexing works.  The advantage to use a trait there is that one is free to create a type hierarchy independent of this particular &quot;trait&quot; of the array(s).</p><p>Tim Holy <a href="https://github.com/mauro3/SimpleTraits.jl/pull/6#issuecomment-236886253">endorses</a> SimpleTraits, a bit: &quot;I&#39;d say that compared to manually writing out the trait-dispatch, the &quot;win&quot; is not enormous, but it is a little nicer.&quot;  I suspect that — if you don&#39;t write Holy-traits before breakfast — your &quot;win&quot; should be greater ;-)</p><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><p><strong>Note for Julia-0.6:</strong>  Below examples for <code>@traitfn</code> (using <code>where</code>-function   syntax) only work on Julia-0.7, for Julia-0.6 this syntax cannot be   not supported.   For Julia-0.6, see the README of the   SimpleTraits version   <a href="https://github.com/mauro3/SimpleTraits.jl/tree/v0.6.0">v0.6.0</a> instead.</p><p>Traits are defined with <code>@traitdef</code>:</p><pre><code class="language-julia">using SimpleTraits
@traitdef IsNice{X}
@traitdef BelongTogether{X,Y} # traits can have several parameters</code></pre><p>All traits have one or more (type-)parameters to specify the type to which the trait is applied.  For instance <code>IsNice{Int}</code> signifies that <code>Int</code> is a member of <code>IsNice</code> (although whether that is true needs to be checked with the <code>istrait</code> function).  Most traits will be one-parameter traits, however, several parameters are useful when there is a &quot;contract&quot; between several types.</p><p>As a <em>style convention</em>, I suggest to use trait names which start with a verb, as above two traits.  This makes distinguishing between traits and types easier as type names are usually nouns.</p><p>Add types to a trait-group with <code>@traitimpl</code>:</p><pre><code class="language-julia">@traitimpl IsNice{Int}
@traitimpl BelongTogether{Int,String}</code></pre><p>If there is a function which tests whether a trait is fulfilled then it can be used like so:</p><pre><code class="language-julia">@traitimpl IsNice{X} &lt;- isnice(X)
isnice(X) = false # set default</code></pre><p>i.e. any type <code>X</code> for which <code>isnice(X)==true</code> belongs to <code>IsNice</code>. Notes:</p><ul><li>overhead-less  (static) dispatch is only possible if <code>isnice</code> is <em>pure</em>: &quot;[A pure method] promises that the result will always be the same constant regardless of when the method is called [for the same input arguments].&quot; (<a href="https://github.com/mauro3/SimpleTraits.jl/pull/39#issuecomment-293629338">ref</a>).</li><li>Last note that in above example the <code>@traitimpl IsNice{Int}</code> &quot;wins&quot; over the <code>@traitimpl IsNice{X} &lt;- isnice(X)</code>, thus this can be used to define exceptions to a rule.</li></ul><p>It can be checked whether a type belongs to a trait with <code>istrait</code>:</p><pre><code class="language-julia">using Test
@test istrait(IsNice{Int})
@test !istrait(BelongTogether{Int,Int}) # only BelongTogether{Int,String} was added above</code></pre><p>Functions which dispatch on traits are constructed like:</p><pre><code class="language-julia">@traitfn f(x::X) where {X; IsNice{X}} = &quot;Very nice!&quot;
@traitfn f(x::X) where {X; !IsNice{X}} = &quot;Not so nice!&quot;</code></pre><p>This means that a type <code>X</code> which is part of the trait <code>IsNice</code> will dispatch to the method returning <code>&quot;Very nice!&quot;</code>, otherwise to the one returning <code>&quot;Not so nice!&quot;</code>:</p><pre><code class="language-julia">@test f(5)==&quot;Very nice!&quot;
@test f(5.)==&quot;Not so nice!&quot;</code></pre><p>Note that calling a trait-function is just like calling any other function.  Thus there is no extra mental gymnastics required for a &quot;user&quot; of a trait-based package.</p><p>Similarly for <code>BelongTogether</code> which has two parameters:</p><pre><code class="language-julia">@traitfn f(x::X,y::Y) where {X,Y; BelongTogether{X,Y}} = &quot;$x and $y forever!&quot;
@test f(5, &quot;b&quot;)==&quot;5 and b forever!&quot;
@test_throws MethodError f(5, 5)

@traitfn f(x::X,y::Y) where {X,Y; !BelongTogether{X,Y}} = &quot;$x and $y cannot stand each other!&quot;
@test f(5, 5)==&quot;5 and 5 cannot stand each other!&quot;</code></pre><h2><a class="nav-anchor" id="[Traitor.jl](https://github.com/andyferris/Traitor.jl)-like-syntax-1" href="#[Traitor.jl](https://github.com/andyferris/Traitor.jl)-like-syntax-1"><a href="https://github.com/andyferris/Traitor.jl">Traitor.jl</a>-like syntax</a></h2><p>At JuliaCon 2016 folks suggested an alternate, more compact syntax for trait-functions.  However, it only works for single parameter traits. SimpleTraits now supports this.  Above function <code>f</code> can be written as:</p><pre><code class="language-julia">@traitfn ft(x::::IsNice) = &quot;Very nice!&quot;
@traitfn ft(x::::(!IsNice)) = &quot;Not so nice!&quot;</code></pre><p>Note that the parenthesis are needed with negated traits, otherwise a parser error is thrown.</p><h2><a class="nav-anchor" id="Vararg,-default-argument-and-keyword-argument-trait-functions-1" href="#Vararg,-default-argument-and-keyword-argument-trait-functions-1">Vararg, default argument and keyword argument trait functions</a></h2><p>Vararg, default argument and keyword argument trait functions work. However, with keyword arguments the trait function and negated trait function need both have the same keywords (however different values are allowed). Example:</p><pre><code class="language-julia">@traitfn kwfn(x::::Tr1, y...; kw=1) = x+y[1]+kw
@traitfn kwfn(x::::(!Tr1), y...; kw=2) = x+y[1]+kw</code></pre><p>For default arguments the rule is slightly different: with default arguments the trait function and negated trait function need both have the same default-argument with the <em>same values</em>.</p><pre><code class="language-julia">@traitfn deff(x::::Tr1, y=1) = x+y
@traitfn deff(x::::(!Tr1), y=1) = x+y</code></pre><h2><a class="nav-anchor" id="Method-overwritten-warnings-1" href="#Method-overwritten-warnings-1">Method overwritten warnings</a></h2><p>Warnings are issued when methods are overwritten.  Due to Tim&#39;s trick the <code>@traitfn</code> needs to create two functions the first time it is used for a particular method (see next section for an explanation).  But when defining the opposite trait, then better only one method is created or else the warning appears.  Some heuristics to avoid the warnings are in-place to check whether a method is defined yet or not but they fail at times (see issue <a href="https://github.com/mauro3/SimpleTraits.jl/issues/7">#7</a>).  Long story short: define the two methods of a trait and its negation using the same argument names and no warning should be issued.  Although note that the warnings are harmless.</p><h1><a class="nav-anchor" id="Details-of-method-dispatch-1" href="#Details-of-method-dispatch-1">Details of method dispatch</a></h1><p>Defining a trait function adds: one new method (or overwrites one) to the generic function, which contains the logic; and one helper method to do the dispatch (Tim&#39;s trick), if it has not been defined before.</p><p>When calling a generic function which has some <em>trait-methods</em>, dispatch will first work on the types as normal.  If the selected method is a trait-method then trait dispatch will kick in too. Example:</p><pre><code class="language-julia">@traitdef Tr{X}

fn(x::Integer) = 1 # a normal method
@traitfn fn(x::X) where {X&lt;:AbstractFloat;  Tr{X}} = 2
@traitfn fn(x::X) where {X&lt;:AbstractFloat; !Tr{X}} = 3

@traitimpl Tr{Float32}
@traitimpl Tr{Int} # this does not impact dispatch of `fn`

fn(5) # -&gt; 1; dispatch only happens on the type
fn(Float32(5)) # -&gt; 2; dispatch through traits
fn(Float64(5)) # -&gt; 3; dispatch through traits</code></pre><p>Further note that for a particular trait-method dispatch only works on one trait.  Continuing above example, this <em>does not work</em> as one may expect:</p><pre><code class="language-julia">@traitdef Tr2{X}
@traitfn fn(x::X) where {X&lt;:AbstractFloat; Tr2{X}} = 4

@traitimpl Tr2{Float16}
fn(Float16(5)) # -&gt; 4; dispatch through traits
fn(Float32(5)) # -&gt; MethodError; method defined in previous example
               #    was overwritten above</code></pre><p>This last definition of <code>fn</code> just overwrites the definition <code>@traitfn f(x::X) where {X; Tr{X}} = 2</code> from above.</p><p>If you need to dispatch on several traits in a single trait-method, then you&#39;re out of luck.  But please voice your grievance over in pull request <a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">#2</a>.</p><h3><a class="nav-anchor" id="Performance-1" href="#Performance-1">Performance</a></h3><p>There is no performance impact compared to normal functions thanks to Julia&#39;s clever design. Continuing the example from above and looking at the native code</p><pre><code class="language-julia">julia&gt; @code_native fn(5)
        .text
Filename: REPL[3]
        pushq   %rbp
        movq    %rsp, %rbp
Source line: 1
        movl    $1, %eax
        popq    %rbp
        retq
        nopl    (%rax,%rax)

julia&gt; @code_native fn(Float16(5))
        .text
Filename: SimpleTraits.jl
        pushq   %rbp
        movq    %rsp, %rbp
Source line: 185
        movl    $4, %eax
        popq    %rbp
        retq
        nopl    (%rax,%rax)</code></pre><p>shows that the normal method and the trait-method compile down to the same machine instructions.</p><p>However, if the trait-grouping function is not constant or a generated function then dispatch may be dynamic.  This can be checked with <code>@check_fast_traitdispatch</code>, which checks whether the number of lines of LLVM code is the same for a trait function than a normal one:</p><pre><code class="language-julia"># julia 0.6
checkfn(x) = rand()&gt;0.5 ? true : false # a bit crazy!
@traitdef TestTr{X}
@traitimpl TestTr{X} &lt;- checkfn(X)
# this tests a trait-function with TestTr{Int}:
@check_fast_traitdispatch TestTr
# this tests a trait-function with TestTr{String} and will
# also prints number of LLCM-IR lines of trait vs normal function:
@check_fast_traitdispatch TestTr String true

# Now this is fast:
@traitimpl TestTr{String}
@check_fast_traitdispatch TestTr String true</code></pre><h2><a class="nav-anchor" id="Advanced-features-1" href="#Advanced-features-1">Advanced features</a></h2><p>The macros of the previous section are the official API of the package and should be reasonably stable.  What follows in this section is &quot;under the hood&quot; and may well be updated (but still signalled with minor version changes).</p><p>Instead of using <code>@traitimpl</code> to add types to traits, it can be programmed.  Running <code>@traitimpl IsNice{Int}</code> essentially expands to</p><pre><code class="language-julia">SimpleTraits.trait{X1 &lt;: Int}(::Type{IsNice{X1}}) = IsNice{X1}</code></pre><p>I.e. <code>trait</code> is the identity function for a fulfilled trait and returns <code>Not{TraitInQuestion{...}}</code> otherwise (this is the fall-back for <code>&lt;:Any</code>).  So instead of using <code>@traitimpl</code> this can be coded directly.  Note that anything but a constant function will probably not be inlined away by the JIT and will lead to slower dynamic dispatch (see <code>@check_fast_traitdispatch</code> for a helper to check).</p><p>Example leading to static dispatch (since Julia 0.6):</p><pre><code class="language-julia">@traitdef IsBits{X}
SimpleTraits.trait{X1}(::Type{IsBits{X1}}) = isbits(X1) ? IsBits{X1} : Not{IsBits{X1}}
istrait(IsBits{Int}) # true
istrait(IsBits{Array{Int,1}}) # false
struct A
    a::Int
end
istrait(IsBits{A}) # true</code></pre><p>Dynamic dispatch can be avoided using a generated function or <em>pure</em> functions (sometimes they need to be annotated with <code>Base.@pure</code>):</p><pre><code class="language-julia">@traitdef IsBits{X}
@generated function SimpleTraits.trait{X1}(::Type{IsBits{X1}})
    isbits(X1) ? :(IsBits{X1}) : :(Not{IsBits{X1}})
end</code></pre><p>What is allowed in generated functions is heavily restricted, see <a href="https://docs.julialang.org/en/latest/manual/metaprogramming.html#Generated-functions-1">Julia manual</a>. In particular (in Julia 0.6), no methods which are defined after the generated function are allowed to be called inside the generated function, otherwise <a href="https://github.com/JuliaLang/julia/issues/21356">this</a> issue is encountered.  Generally, try pure functions first and only in a pinch generated functions.</p><p>Note that these programmed-traits can be combined with <code>@traitimpl IsBits{XYZ}</code>, i.e. program the general case and add exceptions with <code>@traitimpl IsBits{XYZ}</code>.</p><p>Trait-inheritance can also be hand-coded with above trick.  For instance, the trait given by (in pseudo syntax) <code>BeautyAndBeast{X,Y} &lt;: IsNice{X}, !IsNice{Y}, BelongTogether{X,Y}</code>:</p><pre><code class="language-julia">@traitdef BeautyAndBeast{X,Y}
function SimpleTraits.trait{X,Y}(::Type{BeautyAndBeast{X,Y}})
    if istrait(IsNice{X}) &amp;&amp; !istrait(IsNice{Y}) &amp;&amp; BelongTogether{X,Y}
        BeautyAndBeast{X,Y}
    else
        Not{BeautyAndBeast{X,Y}}
    end
end</code></pre><p>Note that this will lead to slower, dynamic dispatch, as the function is not pure (it depends on the global state of which types belong to the traits <code>IsNice</code> and <code>BelongTogether</code>).  (In Julia 0.5 one could use a generated function but not anymore in Julia 0.6.)</p><p>Note also that trait functions can be generated functions:</p><pre><code class="language-julia">@traitfn @generated fg(x::X) where {X; IsNice{X}} = (println(x); :x)</code></pre><h1><a class="nav-anchor" id="Innards-1" href="#Innards-1">Innards</a></h1><p>The function <code>macroexpand</code> shows the syntax transformations a macro does. Here the edited output of running it for the macros of this package:</p><pre><code class="language-julia">julia&gt; macroexpand(:(@traitdef Tr{X}))

struct Tr{X} &lt;: SimpleTraits.Trait
end

julia&gt; macroexpand(:(@traitimpl Tr{Int}))

# this function does the grouping of types into traits:
SimpleTraits.trait{X1 &lt;: Int}(::Type{Tr{X1}}) = Tr{X1}
SimpleTraits.istrait{X1 &lt;: Int}(::Type{Tr{X1}}) = true # for convenience, really

julia&gt; macroexpand(:(@traitfn g(x::X) where {X; Tr{X}}= x+1))

@inline g(x::X) where {X} = g(trait(Tr{X}), x) # this is Tim&#39;s trick, using above grouping-function
g(::Type{Tr{X}},x::X) where {X} = x + 1 # this is the logic

julia&gt; macroexpand(:(@traitfn g(x::X) where {X; !Tr{X}}= x+1000))

# the trait dispatch helper function needn&#39;t be defined twice,
# only the logic:
g(::Type{ Not{Tr{X}} }, x::X) where {X} = x + 1000</code></pre><p>For a detailed explanation of how Tim&#39;s trick works, see <a href="https://github.com/mauro3/Traits.jl#dispatch-on-traits">Traits.jl: Dispatch on traits</a>. The difference here is I make the methods containing the logic part of the same generic function (there it&#39;s in <code>_f</code>).</p><h1><a class="nav-anchor" id="Base-Traits-1" href="#Base-Traits-1">Base Traits</a></h1><p>I started putting some Julia-Base traits together which can be loaded with <code>using SimpleTraits.BaseTraits</code>, see the source for all definitions.</p><p>Example, dispatch on whether an argument is immutable or not:</p><pre><code class="language-julia">@traitfn f(x::X) where {X; IsImmutable{X}} = X(x.fld+1) # make a new instance
@traitfn f(x::X) where {X; !IsImmutable{X}} = (x.fld += 1; x) # update in-place

# use
mutable struct A; fld end
struct B; fld end
a=A(1)
f(a) # in-place
@assert a.fld == A(2).fld

b=B(1) # out of place
b2 = f(b)
@assert b==B(1)
@assert b2==B(2)</code></pre><h1><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h1><p>This package grew out of an attempt to reduce the complexity of <a href="https://github.com/mauro3/Traits.jl">Traits.jl</a>, but at the same time staying compatible (but which it isn&#39;t).  Compared to Traits.jl, it drops support for:</p><ul><li>Trait definition in terms of methods and constraints.  Instead the user needs to assign types to traits manually.  This removes the most complex part of Traits.jl: the checking whether a type satisfies a trait definition.</li><li>trait functions which dispatch on more than one trait.  This allows to remove the need for generated functions, as well as removing the rules for trait-dispatch.</li></ul><p>The reason for splitting this away from Traits.jl are:</p><ul><li>creating a more reliable and easier to maintain package than Traits.jl</li><li>exploring inclusion in Base (see <a href="https://github.com/JuliaLang/julia/pull/13222">#13222</a>).</li></ul><p>My <a href="https://youtu.be/j9w8oHfG1Ic"><em>JuliaCon 2015</em></a> talk gives a 10 minute introduction to Traits.jl and SimpleTraits.jl.</p><h1><a class="nav-anchor" id="The-Future-1" href="#The-Future-1">The Future</a></h1><p>The future of traits in Julia-Base: According to Stefan Karpinski&#39;s JuliaCon 2016 talk, <a href="https://youtu.be/5gXMpbY1kJY">Julia 1.0</a>, traits are scheduled to land after Julia 1.0.  Although, if someone gets cracking, they may well happen pre-1.0.  My crystal ball tells me that all or most of the functionality of this package will be supported in the future trait system (multiparameter-traits may not be). Thus I expect the transition will be mostly a matter of a syntax update and less of a semantic update.  Also, an advantage to using this package versus hand-coding Holy-traits will be that all occurrences of trait usage are clearly marked and thus easier to update.</p><p>The future of this package: I see it as light-weight package focusing on letting functions use dispatch based on traits.  This dispatch is currently fairly limited, see section &quot;Gotcha&quot; above, but may be expanded in the future: either through something like in PR <a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">m3/multitraits</a> or through a more general generated-function approach (definitely not valid anymore in Julia 0.6).</p><p>In the unlikely event that I find myself with too much time on my hands, I may try to develop a companion package to allow the specification of a trait in terms of interfaces.  The combination of the two packages would then have similar functionality to my experimental package <a href="https://github.com/mauro3/Traits.jl">Traits.jl</a>. If anyone fancies a go at writing this companion package, I would be very happy to help and contribute.  After the <a href="https://github.com/JuliaLang/julia/pull/18457">type-system overhaul</a> lands, this should be much less hackish than what&#39;s in Traits.jl.</p><h1><a class="nav-anchor" id="References-1" href="#References-1">References</a></h1><ul><li><a href="https://github.com/mauro3/Traits.jl">Traits.jl</a> and its references. In particular <a href="https://github.com/mauro3/Traits.jl#dispatch-on-traits">here</a> is an in-depth discussion on limitations of Holy-Traits, which this package implements.</li></ul><h1><a class="nav-anchor" id="To-ponder-1" href="#To-ponder-1">To ponder</a></h1><ul><li>There is a big update sitting in the branch <a href="https://github.com/mauro3/SimpleTraits.jl/pull/2">m3/multitraits</a>; but I never quite finished it.  It would also address the next point:</li><li>Could type inheritance be used for sub-traits (<a href="https://github.com/JuliaLang/julia/issues/10889#issuecomment-94317470">Jutho&#39;s idea</a>)? In particular could it be used in such a way that it is compatible with the multiple inheritance used in Traits.jl?</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
