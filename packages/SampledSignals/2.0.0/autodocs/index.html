<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SampledSignals.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SampledSignals.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">SampledSignals...</code></pre><pre><code class="language-none">SampledSignals.AbstractSampleBuf</code></pre><pre><code class="language-none">SampledSignals.ArrayIsh</code></pre><pre><code class="language-none">SampledSignals.BuiltinIdx</code></pre><pre><code class="language-none">SampledSignals.BuiltinMultiIdx</code></pre><pre><code class="language-none">SampledSignals.ClosedInterval</code></pre><pre><code class="language-none">SampledSignals.ConvertIdx</code></pre><pre><code class="language-none">SampledSignals.DEFAULT_BLOCKSIZE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.DownMixSink" href="#SampledSignals.DownMixSink"><code>SampledSignals.DownMixSink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DownMixSink provides a multi-channel sink that wraps a single-channel sink. Writing to this sink mixes all the channels down to the single channel</p></div></div></section><pre><code class="language-none">SampledSignals.FrameQuant</code></pre><pre><code class="language-none">SampledSignals.GHz</code></pre><pre><code class="language-none">SampledSignals.Hz</code></pre><pre><code class="language-none">SampledSignals.MHz</code></pre><pre><code class="language-none">SampledSignals.PCM16Sample</code></pre><pre><code class="language-none">SampledSignals.PCM20Sample</code></pre><pre><code class="language-none">SampledSignals.PCM24Sample</code></pre><pre><code class="language-none">SampledSignals.PCM32Sample</code></pre><pre><code class="language-none">SampledSignals.PCM64Sample</code></pre><pre><code class="language-none">SampledSignals.PCM8Sample</code></pre><pre><code class="language-none">SampledSignals.ReformatSink</code></pre><pre><code class="language-none">SampledSignals.ResampleSink</code></pre><pre><code class="language-none">SampledSignals.SAMPLE_TYPE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SampleBuf" href="#SampledSignals.SampleBuf"><code>SampledSignals.SampleBuf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Represents a multi-channel regularly-sampled buffer that stores its own sample rate (in samples/second). The wrapped data is an N-dimensional array. A 1-channel sample can be represented with a 1D array or an Mx1 matrix, and a C-channel buffer will be an MxC matrix. So a 1-second stereo audio buffer sampled at 44100Hz with 32-bit floating-point samples in the time domain would have the type SampleBuf{Float32, 2}.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SampleBufSink" href="#SampledSignals.SampleBufSink"><code>SampledSignals.SampleBufSink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>SampleBufSink is a SampleSink backed by a buffer. It&#39;s mostly useful to hook into the stream conversion infrastructure, because you can wrap a buffer in a SampleBufSink and then read a source into it with a different channel count, sample rate, or channel count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SampleBufSource" href="#SampledSignals.SampleBufSource"><code>SampledSignals.SampleBufSource</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>SampleBufSource is a SampleSource backed by a buffer. It&#39;s mostly useful to hook into the stream conversion infrastructure, because you can wrap a buffer in a SampleBufSource and then write it into a sink with a different channel count, sample rate, or channel count.</p></div></div></section><pre><code class="language-none">SampledSignals.SampleRate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SampleSink" href="#SampledSignals.SampleSink"><code>SampledSignals.SampleSink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Represents a sink that samples can be written to, such as an audio file or headphone output.</p><p>Subtypes should implement the <code>samplerate</code>, <code>nchannels</code>, <code>eltype</code>, and <code>unsafe_write</code> methods. <code>unsafe_write</code> can assume that the samplerate, channel count, and element type are all matching.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SampleSource" href="#SampledSignals.SampleSource"><code>SampledSignals.SampleSource</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Represents a source of samples, such as an audio file, microphone input, or SDR Receiver.</p><p>Subtypes should implement the <code>samplerate</code>, <code>nchannels</code>, <code>eltype</code>, and <code>unsafe_read!</code> methods. <code>unsafe_read!</code> can assume that the samplerate, channel count, and element type are all matching.</p></div></div></section><pre><code class="language-none">SampledSignals.SampledSignals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SinSource" href="#SampledSignals.SinSource"><code>SampledSignals.SinSource</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SinSource(eltype, samplerate, freqs)</code></pre><p>SinSource is a multi-channel sine-tone signal generator. <code>freqs</code> can be an array of frequencies for a multi-channel source, or a single frequency for a mono source.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.SpectrumBuf" href="#SampledSignals.SpectrumBuf"><code>SampledSignals.SpectrumBuf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Represents a multi-channel regularly-sampled buffer representing the frequency- domain spectrum of a <code>SampleBuf</code>. The wrapped data is an N-dimensional array. A 1-channel sample can be represented with a 1D array or an Mx1 matrix, and a C-channel buffer will be an MxC matrix. So a 1-second stereo audio buffer sampled at 44100Hz with 32-bit floating-point samples in the time domain would have the type SampleBuf{Float32, 2}.</p></div></div></section><pre><code class="language-none">SampledSignals.THz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.UpMixSink" href="#SampledSignals.UpMixSink"><code>SampledSignals.UpMixSink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>UpMixSink provides a single-channel sink that wraps a multi-channel sink. Writing to this sink copies the single channel to all the channels in the wrapped sink</p></div></div></section><pre><code class="language-none">SampledSignals.WAVE_FORMAT_PCM</code></pre><pre><code class="language-none">SampledSignals.WAVFormat</code></pre><pre><code class="language-none">SampledSignals.__init__</code></pre><pre><code class="language-none">SampledSignals.blocksize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.channelptr" href="#SampledSignals.channelptr"><code>SampledSignals.channelptr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get a pointer to the underlying data for the buffer. Will return a Ptr{T}, where T is the element type of the buffer. This is particularly useful for passing to C libraries to fill the buffer</p></div></div></section><pre><code class="language-none">SampledSignals.dB</code></pre><pre><code class="language-none">SampledSignals.domain</code></pre><pre><code class="language-none">SampledSignals.embed_javascript</code></pre><pre><code class="language-none">SampledSignals.eval</code></pre><pre><code class="language-none">SampledSignals.find_buf</code></pre><pre><code class="language-none">SampledSignals.frames</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.inHz" href="#SampledSignals.inHz"><code>SampledSignals.inHz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inHz(quantity[, rate])</code></pre><p>Translate a particular quantity (usually a frequency) to a (unitless) value in Hz.</p><p>If the given quantity is Unitful, we use the given units. If it is not we assume it is already a value in Hz.</p><p>For some units (e.g. frames) you will need to specify a sample rate:</p><p><strong>Example</strong></p><p>julia&gt; inHz(1.0kHz) 1000.0</p></div></div></section><pre><code class="language-none">SampledSignals.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.inframes" href="#SampledSignals.inframes"><code>SampledSignals.inframes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inframes([Type,]quantity[, rate])</code></pre><p>Translate the given quantity to a (unitless) number of time or frequency frames, given a particular samplerate. Note that this isn&#39;t quantized to integer numbers of frames. If given a <code>Type</code>, the result will first be coerced to the given type.</p><p>If the given quantity is Unitful, we use the given units. If it is not we assume it is already a value in frames.</p><p><strong>Example</strong></p><p>julia&gt; inframes(0.5s, 44100Hz) 22050.0</p><p>julia&gt; inframes(1000Hz, 2048/44100Hz) 46.439909297052154</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.inseconds" href="#SampledSignals.inseconds"><code>SampledSignals.inseconds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>inseconds(quantity[, rate])</p><p>Translate a particular quantity (usually a time) to a (unitless) value in seconds.</p><p>If the given quantity is Unitful, we use the given units. If it is not we assume it is already a value in seconds.</p><p>For some units (e.g. frames) you will need to specify a sample rate:</p><p><strong>Examples</strong></p><p>julia&gt; inseconds(50.0ms) 0.05</p><p>julia&gt; inseconds(441frames, 44100Hz) 0.01</p></div></div></section><pre><code class="language-none">SampledSignals.kHz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.metadata" href="#SampledSignals.metadata"><code>SampledSignals.metadata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">metadata(x, key::Symbol)
metadata(x, key::Symbol, idx)</code></pre><p>Provide implementation-specific metadata for the given buffer or stream. For instance, data from a WAV file might have metadata that comes from extra chunks read from the file. If no <code>idx</code> is given then the first piece of metadata matching the key is returned. If there are multiple matches, the user can provide an index, or <code>:</code> to return a list of all matching metadata.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.mix" href="#SampledSignals.mix"><code>SampledSignals.mix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Mix the channels of the source array into the channels of the dest array, using coefficients from the <code>mix</code> matrix. To mix an M-channel buffer to a N-channel buffer, <code>mix</code> should be MxN. <code>src</code> and <code>dest</code> should not share memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.mix!" href="#SampledSignals.mix!"><code>SampledSignals.mix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Mix the channels of the source array into the channels of the dest array, using coefficients from the <code>mix</code> matrix. To mix an M-channel buffer to a N-channel buffer, <code>mix</code> should be MxN. <code>src</code> and <code>dest</code> should not share memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.mono" href="#SampledSignals.mono"><code>SampledSignals.mono</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Mix the channels of the <code>src</code> array into a mono array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.mono!" href="#SampledSignals.mono!"><code>SampledSignals.mono!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Mix the channels of the <code>src</code> array into the mono <code>dest</code> array.</p></div></div></section><pre><code class="language-none">SampledSignals.ms</code></pre><pre><code class="language-none">SampledSignals.nchannels</code></pre><pre><code class="language-none">SampledSignals.nframes</code></pre><pre><code class="language-none">SampledSignals.ns</code></pre><pre><code class="language-none">SampledSignals.s</code></pre><pre><code class="language-none">SampledSignals.samplerate</code></pre><pre><code class="language-none">SampledSignals.samplerate!</code></pre><pre><code class="language-none">SampledSignals.showchannels</code></pre><pre><code class="language-none">SampledSignals.srname</code></pre><pre><code class="language-none">SampledSignals.ticks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.toindex" href="#SampledSignals.toindex"><code>SampledSignals.toindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">toindex(buf::SampleBuf, I)</code></pre><p>Convert the given index value to one that Base knows how to use natively for indexing</p></div></div></section><pre><code class="language-none">SampledSignals.typename</code></pre><pre><code class="language-none">SampledSignals.unitname</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.unsafe_read!" href="#SampledSignals.unsafe_read!"><code>SampledSignals.unsafe_read!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>unsafe_read!(source::SampleSource, buf::Array, frameoffset, framecount)</p><p>Reads samples from the given source to the given array, assuming that the channel count, sampling rate, and element types are matching. This isn&#39;t called from user code, but is called by the <code>read!</code> (and likewise <code>read</code>) implementions in SampledSignals after it verifies that the buffer and sink are compatible, or possibly adds a conversion wrapper. SampledSignals will call this method with a 1D or 2D (nframes x nchannels) <code>Array</code>, with each channel in its own column. <code>framecount</code> frames of data should be copied into the array starting at <code>frameoffset+1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.unsafe_write" href="#SampledSignals.unsafe_write"><code>SampledSignals.unsafe_write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>unsafe_write(sink::SampleSink, buf::Array, frameoffset, framecount)</p><p>Writes the given buffer to the given sink, assuming that the channel count, sampling rate, and element types are matching. This isn&#39;t called from user code, but is called by the <code>write</code> implemention in SampledSignals after it verifies that the buffer and sink are compatible, or possibly adds a conversion wrapper. sampledsignals will call this method with a 1D or 2D (nframes x nchannels) <code>Array</code>, with each channel in its own column. <code>framecount</code> frames of data should be copied from the array starting at <code>frameoffset+1</code>.</p></div></div></section><pre><code class="language-none">SampledSignals.wavwrite</code></pre><pre><code class="language-none">SampledSignals.wrap_sink</code></pre><pre><code class="language-none">SampledSignals.write_format</code></pre><pre><code class="language-none">SampledSignals.write_header</code></pre><pre><code class="language-none">SampledSignals.write_le</code></pre><pre><code class="language-none">SampledSignals.μs</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
