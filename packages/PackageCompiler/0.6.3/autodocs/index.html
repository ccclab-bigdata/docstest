<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · PackageCompiler.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PackageCompiler.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">PackageCompiler.ExitHooksEnd</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.ExitHooksStart" href="#PackageCompiler.ExitHooksStart"><code>PackageCompiler.ExitHooksStart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Exit hooks can get serialized and therefore end up in weird behaviour When incrementally compiling</p></div></div></section><pre><code class="language-none">PackageCompiler.Include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.InitBase" href="#PackageCompiler.InitBase"><code>PackageCompiler.InitBase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Init basic C libraries</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.InitREPL" href="#PackageCompiler.InitREPL"><code>PackageCompiler.InitREPL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Initialize REPL module for Docs</strong></p></div></div></section><pre><code class="language-none">PackageCompiler.PackageCompiler</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.PrecompileCommand" href="#PackageCompiler.PrecompileCommand"><code>PackageCompiler.PrecompileCommand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The command to pass to julia –output-o, that runs the julia code in <code>path</code> during compilation.</p></div></div></section><pre><code class="language-none">PackageCompiler.allflags</code></pre><pre><code class="language-none">PackageCompiler.build_exec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_executable" href="#PackageCompiler.build_executable"><code>PackageCompiler.build_executable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_executable(
    julia_program, output_name = nothing, c_program = nothing;
    snoopfile = nothing, builddir = nothing, verbose = false, quiet = false,
    copy_julialibs = true, copy_files = nothing, release = false, Release = false,
    sysimage = nothing, home = nothing, startup_file = nothing, handle_signals = nothing,
    sysimage_native_code = nothing, compiled_modules = nothing,
    depwarn = nothing, warn_overwrite = nothing,
    compile = nothing, cpu_target = nothing, optimize = nothing, debug = nothing,
    inline = nothing, check_bounds = nothing, math_mode = nothing,
    cc = nothing, cc_flags = nothing
)
`julia_program` needs to be a Julia script containing a `julia_main` function, e.g. like `examples/hello.jl`
`snoopfile` is optional and can be a Julia script which calls functions that you want to make sure to have precompiled
`builddir` is where the compiled artifacts will end up</code></pre></div></div></section><pre><code class="language-none">PackageCompiler.build_julia_cmd</code></pre><pre><code class="language-none">PackageCompiler.build_object</code></pre><pre><code class="language-none">PackageCompiler.build_shared</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_shared_lib" href="#PackageCompiler.build_shared_lib"><code>PackageCompiler.build_shared_lib</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_shared_lib(
    julia_program, output_name = nothing;
    snoopfile = nothing, builddir = nothing, verbose = false, quiet = false,
    init_shared = false, copy_julialibs = true, copy_files = nothing, release = false, Release = false,
    sysimage = nothing, home = nothing, startup_file = nothing, handle_signals = nothing,
    sysimage_native_code = nothing, compiled_modules = nothing,
    depwarn = nothing, warn_overwrite = nothing,
    compile = nothing, cpu_target = nothing, optimize = nothing, debug = nothing,
    inline = nothing, check_bounds = nothing, math_mode = nothing,
    cc = nothing, cc_flags = nothing
)
`julia_program` needs to be a Julia script containing a `julia_main` function, e.g. like `examples/hello.jl`
`snoopfile` is optional and can be a Julia script which calls functions that you want to make sure to have precompiled
`builddir` is where the compiled artifacts will end up</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_sysimg" href="#PackageCompiler.build_sysimg"><code>PackageCompiler.build_sysimg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_sysimg(sysimg_path=default_sysimg_path(), cpu_target=&quot;native&quot;, userimg_path=nothing; force=false)</code></pre><p>Rebuild the system image. Store it in <code>sysimg_path</code>, which defaults to a file named <code>sys.ji</code> that sits in the same folder as <code>libjulia.{so,dylib}</code>, except on Windows where it defaults to <code>Sys.BINDIR/../lib/julia/sys.ji</code>. Use the cpu instruction set given by <code>cpu_target</code>. Valid CPU targets are the same as for the <code>-C</code> option to <code>julia</code>, or the <code>-march</code> option to <code>gcc</code>. Defaults to <code>native</code>, which means to use all CPU instructions available on the current processor. Include the user image file given by <code>userimg_path</code>, which should contain directives such as <code>using MyPackage</code> to include that package in the new system image. New system image will not replace an older image unless <code>force</code> is set to true.</p></div></div></section><pre><code class="language-none">PackageCompiler.cflags</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.compile_incremental" href="#PackageCompiler.compile_incremental"><code>PackageCompiler.compile_incremental</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compile_incremental(
    toml_path::String, snoopfile::String;
    force = false, precompile_file = nothing, verbose = true,
    debug = false, cc_flags = nothing
)

Extract all calls from `snoopfile` and ahead of time compiles them
incrementally into the current system image.
`force = true` will replace the old system image with the new one.
The argument `toml_path` should contain a project file of the packages that `snoopfile` explicitly uses.
Implicitly used packages &amp; modules don&#39;t need to be contained!

To compile just a single package, see the simpler version  `compile_incremental(package::Symbol)`:</code></pre></div></div><div><div><pre><code class="language-none">compile_incremental(
    packages::Symbol...;
    force = false, reuse = false, verbose = true,
    debug = false, cc_flags = nothing
)

Incrementally compile `package` into the current system image.
`force = true` will replace the old system image with the new one.
`compile_incremental` will run the `Package/test/runtests.jl` file to
record the functions getting compiled. The coverage of the Package&#39;s tests will
thus determine what is getting ahead of time compiled.
For a more explicit version of compile_incremental, see:
`compile_incremental(toml_path::String, snoopfile::String)`</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.compile_package" href="#PackageCompiler.compile_package"><code>PackageCompiler.compile_package</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compile_package(packages...; kw_args...)</code></pre><p>with packages being either a string naming a package, or a tuple <code>(package_name, precompile_file)</code>. If no precompile file is given, it will use the packages <code>runtests.jl</code>, which is a good canditate for figuring out what functions to compile!</p></div></div><div><div><pre><code class="language-none">compile_package(
    packages::Tuple{String, String}...;
    force = false, reuse = false, debug = false, cpu_target = nothing,
    additional_packages = Symbol[]
)</code></pre><p>Compile a list of packages. Each package comes as a tuple of <code>(package_name, precompile_file)</code> where the precompile file should contain all function calls, that should get compiled into the system image. Usually the <code>runtests.jl</code> file is a good candidate, since it should run all important functions of a package. You can pass <code>additional_packages</code> a vector of symbols with package names, to help AOT compiling uninstalled, recursive dependencies of <code>packages</code>. Look at <code>compile_incremental</code> to use a toml instead.</p></div></div></section><pre><code class="language-none">PackageCompiler.compile_system_image</code></pre><pre><code class="language-none">PackageCompiler.copy_files_array</code></pre><pre><code class="language-none">PackageCompiler.copy_julia_libs</code></pre><pre><code class="language-none">PackageCompiler.copy_system_image</code></pre><pre><code class="language-none">PackageCompiler.create_project_from_require</code></pre><pre><code class="language-none">PackageCompiler.current_systemimage</code></pre><pre><code class="language-none">PackageCompiler.default_sysimg_path</code></pre><pre><code class="language-none">PackageCompiler.depsfile</code></pre><pre><code class="language-none">PackageCompiler.eval</code></pre><pre><code class="language-none">PackageCompiler.executable_ext</code></pre><pre><code class="language-none">PackageCompiler.flag_to_jloptions</code></pre><pre><code class="language-none">PackageCompiler.flags_with_cmdval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.force_native_image!" href="#PackageCompiler.force_native_image!"><code>PackageCompiler.force_native_image!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">force_native_image!()</code></pre><p>Builds a clean system image, similar to a fresh Julia install. Can also be used to build a native system image for a downloaded cross compiled julia binary.</p></div></div></section><pre><code class="language-none">PackageCompiler.gcc</code></pre><pre><code class="language-none">PackageCompiler.gccworks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.get_backup!" href="#PackageCompiler.get_backup!"><code>PackageCompiler.get_backup!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the system image file stored in the backup folder. If there is no backup, this function will automatically generate a system image in the backup folder.</p></div></div></section><pre><code class="language-none">PackageCompiler.get_root_dir</code></pre><pre><code class="language-none">PackageCompiler.include</code></pre><pre><code class="language-none">PackageCompiler.includeDir</code></pre><pre><code class="language-none">PackageCompiler.is_short_flag</code></pre><pre><code class="language-none">PackageCompiler.jl_command</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.jl_flag_value" href="#PackageCompiler.jl_flag_value"><code>PackageCompiler.jl_flag_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extract_flag(flag, jl_cmd = Base.julia_cmd())</code></pre><p>Extracts the value for <code>flag</code> from <code>jl_cmd</code>.</p></div></div></section><pre><code class="language-none">PackageCompiler.jl_option_key</code></pre><pre><code class="language-none">PackageCompiler.jl_option_value</code></pre><pre><code class="language-none">PackageCompiler.jl_options_to_flag</code></pre><pre><code class="language-none">PackageCompiler.julia_code_cmd</code></pre><pre><code class="language-none">PackageCompiler.julia_cpu_target</code></pre><pre><code class="language-none">PackageCompiler.julia_flags</code></pre><pre><code class="language-none">PackageCompiler.ldflags</code></pre><pre><code class="language-none">PackageCompiler.ldlibs</code></pre><pre><code class="language-none">PackageCompiler.libDir</code></pre><pre><code class="language-none">PackageCompiler.package_folder</code></pre><pre><code class="language-none">PackageCompiler.package_toml</code></pre><pre><code class="language-none">PackageCompiler.packages_from_require</code></pre><pre><code class="language-none">PackageCompiler.private_libDir</code></pre><pre><code class="language-none">PackageCompiler.push_command!</code></pre><pre><code class="language-none">PackageCompiler.remove_temp_files</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.revert" href="#PackageCompiler.revert"><code>PackageCompiler.revert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reverts a forced compilation of the system image. This will restore any previously backed up system image files, or build a new, clean system image.</p></div></div></section><pre><code class="language-none">PackageCompiler.run_PATH</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.run_julia" href="#PackageCompiler.run_julia"><code>PackageCompiler.run_julia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">run_julia(
    code::String;
    g = nothing, O = nothing, output_o = nothing, J = nothing,
    startup_file = &quot;no&quot;
)</code></pre><p>Run <code>code</code> in a julia command. You can overwrite any julia command line flag by setting it to a value. If the flag has the value <code>nothing</code>, the value of the flag of the current julia process is used.</p></div></div></section><pre><code class="language-none">PackageCompiler.shell_escape</code></pre><pre><code class="language-none">PackageCompiler.short_flag_to_jloptions</code></pre><pre><code class="language-none">PackageCompiler.snoop</code></pre><pre><code class="language-none">PackageCompiler.snoop_packages</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.static_julia" href="#PackageCompiler.static_julia"><code>PackageCompiler.static_julia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">static_julia(juliaprog::String; kw_args...)</code></pre><p>compiles the Julia file at path <code>juliaprog</code> with keyword arguments:</p><pre><code class="language-none">cprog                            C program to compile (required only when building an executable, if not provided a minimal driver program is used)
verbose                          increase verbosity
quiet                            suppress non-error messages
builddir                         build directory
outname                          output files basename
snoopfile                        specify script calling functions to precompile
clean                            remove build directory
autodeps                         automatically build required dependencies
object                           build object file
shared                           build shared library
init_shared                      add `init_jl_runtime` and `exit_jl_runtime` to shared library for runtime initialization
executable                       build executable file
rmtemp                           remove temporary build files
copy_julialibs                   copy Julia libraries to build directory
copy_files                       copy user-specified files to build directory (either `nothing` or a string array)
release                          build in release mode, implies `-O3 -g0` unless otherwise specified
Release                          perform a fully automated release build, equivalent to `-atjr`
sysimage &lt;file&gt;                  start up with the given system image file
home &lt;dir&gt;                       set location of `julia` executable
startup_file {yes|no}            load `~/.julia/config/startup.jl`
handle_signals {yes|no}          enable or disable Julia&#39;s default signal handlers
sysimage_native_code {yes|no}    use native code from system image if available
compiled_modules {yes|no}        enable or disable incremental precompilation of modules
depwarn {yes|no|error}           enable or disable syntax and method deprecation warnings
warn_overwrite {yes|no}          enable or disable method overwrite warnings
compile {yes|no|all|min}         enable or disable JIT compiler, or request exhaustive compilation
cpu_target &lt;target&gt;              limit usage of CPU features up to &lt;target&gt; (implies default `--sysimage_native_code=no`)
optimize {0,1,2,3}               set the optimization level
debug &lt;level&gt;                    enable / set the level of debug info generation
inline {yes|no}                  control whether inlining is permitted
check_bounds {yes|no}            emit bounds checks always or never
math_mode {ieee,fast}            disallow or enable unsafe floating point optimizations
cc                               system C compiler
cc_flags &lt;flags&gt;                 pass custom flags to the system C compiler when building a shared library or executable (either `nothing` or a string array)</code></pre></div></div></section><pre><code class="language-none">PackageCompiler.sysimage_binaries</code></pre><pre><code class="language-none">PackageCompiler.sysimg_folder</code></pre><pre><code class="language-none">PackageCompiler.sysimgbackup_folder</code></pre><pre><code class="language-none">PackageCompiler.system_compiler</code></pre><pre><code class="language-none">PackageCompiler.threadingOn</code></pre><pre><code class="language-none">PackageCompiler.to_cmd_val</code></pre><pre><code class="language-none">PackageCompiler.write_toml</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
