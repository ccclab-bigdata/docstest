<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· UnalignedVectors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>UnalignedVectors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Usage-example:-memory-mapping-1">Usage example: memory mapping</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="UnalignedVectors-1" href="#UnalignedVectors-1">UnalignedVectors</a></h1><p><a href="https://travis-ci.org/JuliaArrays/UnalignedVectors.jl"><img src="https://travis-ci.org/JuliaArrays/UnalignedVectors.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/timholy/unalignedvectors-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/e5s72r50g0xix7o6/branch/master?svg=true" alt="Build status"/></a> <a href="http://codecov.io/github/JuliaArrays/UnalignedVectors.jl?branch=master"><img src="http://codecov.io/github/JuliaArrays/UnalignedVectors.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>Julia allows you to create arrays from a pointer to a memory buffer, but an <code>Array{T}</code> requires a pointer that is a multiple of <code>sizeof(T)</code>. This package allows you to create an <code>AbstractArray</code> with element type <code>T</code> even when the pointer lacks proper alignment.</p><h2><a class="nav-anchor" id="Usage-example:-memory-mapping-1" href="#Usage-example:-memory-mapping-1">Usage example: memory mapping</a></h2><p>A common usage might be memory mapping, using Julia&#39;s <code>Mmap.mmap</code> functionality. Let&#39;s create a fake file format with the following structure:</p><ul><li>magic bytes &quot;BIGARRAY&quot; followed a newline</li><li>the number of dimensions in the array</li><li>the size of the array</li><li>the data of the array (always <code>Float64</code>)</li></ul><p>The rub is that the data will always start with an odd offset, because the magic bytes (plus the newline) total 9 bytes, and the dimension information always adds an even number of types. As a consequence, the memory buffer is not properly aligned for <code>Float64</code> (which requires the pointer address to be a multiple of 8) and consequently ordinary <code>mmap</code> operations will fail.</p><p>To try this out, first let&#39;s write such a file:</p><pre><code class="language-julia">open(&quot;/tmp/testfile.bga&quot;, &quot;w&quot;) do io
    write(io, &quot;BIGARRAY\n&quot;)
    A = [1.0 2.0;
         3.0 4.0]
    write(io, ndims(A))
    for s in size(A)
        write(io, s)
    end
    write(io, A)
end</code></pre><p>Now let&#39;s create a format reader (note that the best way to define a new format is using <a href="https://github.com/JuliaIO/FileIO.jl">FileIO</a>, but for simplicity we&#39;ll keep things very low level):</p><pre><code class="language-julia">function reader(io)
    String(read(io, 9)) == &quot;BIGARRAY\n&quot; || error(&quot;file is not a BIGARRAY file&quot;)
    n = read(io, Int)             # read the number of dimensions
    sz = (read(io, Int, n)...)    # read the size
    # Mmap the buffer:
    a = Mmap.mmap(io, Vector{UInt8}, sizeof(Float64)*prod(sz), position(io))
    # Create an array of the desired eltype and size:
    v = UnalignedVector{Float64}(a)
    reshape(v, sz)
end</code></pre><p>The key thing to note about this implementation is that we <code>mmap</code>ed the buffer as a <code>Vector{UInt8}</code>; had we tried a <code>Vector{Float64}</code>, more recent versions of Julia would have given us an error that would look something like this:</p><pre><code class="language-julia">ERROR: ArgumentError: unsafe_wrap: pointer 0x7f89817ae021 is not properly aligned to 8 bytes
Stacktrace:
 [1] #mmap#1(::Bool, ::Bool, ::Function, ::IOStream, ::Type{Array{Float64,2}}, ::Tuple{Int64,Int64}, ::Int64) at ./mmap.jl:139
 [2] mmap(::IOStream, ::Type{Array{Float64,2}}, ::Tuple{Int64,Int64}, ::Int64) at ./mmap.jl:102
 [3] reader(::IOStream) at ./REPL[4]:5
 [4] open(::##5#6, ::String) at ./iostream.jl:152</code></pre><p>In contrast, since <code>UInt8</code> has an alignment of 1, it&#39;s always safe for <code>mmap</code>ping.</p><p>To create the array with desired element type, the <code>UnalignedVector{Float64}(a)</code> call creates an <code>AbstractVector{Float64}</code> out of the memory buffer, which we then reshape to the desired size. If you want to try this, just read the file with</p><pre><code class="language-julia">B = open(&quot;/tmp/testfile.bga&quot;) do io
    reader(io)
end</code></pre><p>and you should see that <code>B == A</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
