<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · AcceleratedArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AcceleratedArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Getting-started-1">Getting started</a></li><li><a class="toctext" href="#Accelerated-functions-1">Accelerated functions</a></li><li><a class="toctext" href="#Acceleration-Indexes-1">Acceleration Indexes</a></li><li><a class="toctext" href="#Order-based-predicates-and-Intervals-1">Order-based predicates and Intervals</a></li><li><a class="toctext" href="#Work-remaining-1">Work remaining</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="AcceleratedArrays.jl-1" href="#AcceleratedArrays.jl-1">AcceleratedArrays.jl</a></h1><p><em>Arrays with acceleration indices.</em></p><p><a href="https://travis-ci.org/andyferris/AcceleratedArrays.jl"><img src="https://travis-ci.org/andyferris/AcceleratedArrays.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/andyferris/acceleratedarrays-jl"><img src="https://ci.appveyor.com/api/projects/status/9qwb219wpdm3dg3c?svg=true" alt="Build status"/></a> <a href="https://codecov.io/gh/andyferris/AcceleratedArrays.jl"><img src="https://codecov.io/gh/andyferris/AcceleratedArrays.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><p><strong>AcceleratedArrays</strong> provides (seconday) acceleration indexes for Julia <code>AbstractArray</code>s. Such acceleration indexes can be used to speed up certain operations, particularly those involving searching through the values - for example, an <code>AcceleratedArray</code> may have more efficient implementations of functions such as <code>findall</code>, <code>filter</code>, and <code>unique</code>.</p><p>As a general rule, this package has been implemented for the purposes of accelerating analytics workloads and is designed to support functional, non-mutating workflows. It is currently not supported to add an index to data you expect to mutate afterwards.</p><h2><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h2><p>To download this package, from Julia v1.0 press <code>]</code> to enter package mode and type:</p><pre><code class="language-julia">pkg&gt; dev https://github.com/andyferris/AcceleratedArrays.jl</code></pre><p>An <code>AcceleratedArray</code> is generally created by using the <code>accelerate</code> and <code>accelerate!</code> functions. </p><pre><code class="language-julia"># Construct a hash mapping to unique names
a = accelerate([&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], UniqueHashIndex)

# Rearrange an array of random numbers into ascending order
b = accelerate!(rand(1:100, 100), SortIndex)</code></pre><p>The resulting arrays can be used just like regular Julia arrays, except some operations become faster. For example, the hash map will let us find a certain element without exhaustively searching the array, or we can easily find all the elements within a given interval with a sorted array.</p><pre><code class="language-julia"># Find the index of &quot;Bob&quot; in `a`
findall(isequal(&quot;Bob&quot;), a)

# Return all the numbers in `b` between 40 and 60
filter(in(40..60), b)</code></pre><h2><a class="nav-anchor" id="Accelerated-functions-1" href="#Accelerated-functions-1">Accelerated functions</a></h2><p>Accelerations are fully implemented for the following functions, where <code>a</code> is an <code>AcceleratedArray</code>:</p><ul><li><code>x ∈ a</code></li><li><code>count(pred, a)</code></li><li><code>findall(pred, a)</code></li><li><code>filter(pred, a)</code></li></ul><p>There is some work-in-progress on a variety of other functions, including some from <a href="https://github.com/JuliaData/SplitApplyCombine.jl">SplitApplyCombine</a>:</p><ul><li><code>findfirst(pred, a)</code> and <code>findlast(pred, a)</code></li><li><code>unique(a)</code></li><li><code>group</code>, <code>groupinds</code>, <code>groupview</code> and <code>groupreduce</code></li><li><code>innerjoin</code></li></ul><p>Accelerations are only available for some predicates <code>pred</code>, which naturally depend on the acceleration index used (see below for a full set).</p><h2><a class="nav-anchor" id="Acceleration-Indexes-1" href="#Acceleration-Indexes-1">Acceleration Indexes</a></h2><p>The package intruduces the <code>AbstractIndex</code> supertype and the following concrete implemetations. Generally, an index is created when the user calls <code>accelerate</code> or <code>accelerate!</code>.</p><h4><a class="nav-anchor" id="HashIndex-1" href="#HashIndex-1"><code>HashIndex</code></a></h4><p>This index constructs a hashmap between values in the array, and the corresponding array indices. For example, invoking <code>findall</code> to search for the locations of certain values will be reduced to a simple dictionary lookup. Primarily accelerates commands using the <code>isequal</code> predicate.</p><h4><a class="nav-anchor" id="UniqueHashIndex-1" href="#UniqueHashIndex-1"><code>UniqueHashIndex</code></a></h4><p>Like <code>HashIndex</code>, except each value in the array can only appear once. Apart from guaranteeing uniqueness, certain operations may be faster with a <code>UniqueHashIndex</code> than  with a <code>HashIndex</code>.</p><h4><a class="nav-anchor" id="SortIndex-1" href="#SortIndex-1"><code>SortIndex</code></a></h4><p>This index determines the order of the elements (with respect to <code>isless</code>). This index can accelerate not only the <code>isequal</code> predicate, but a variety of other order-based predicates as well (see below).</p><p>The <code>accelerate!</code> function will rearrange the input array, like <code>sort!</code>. This can speed up operations due to simplified algorithms and cache locality.</p><h4><a class="nav-anchor" id="UniqueSortIndex-1" href="#UniqueSortIndex-1"><code>UniqueSortIndex</code></a></h4><p>Like <code>SortIndex</code>, except each value in the array can only appear once. Apart from guaranteeing uniqueness, certain operations may be faster with a <code>UniqueSortIndex</code> than  with a <code>SortIndex</code>.</p><h3><a class="nav-anchor" id="Custom-acceleration-indices-1" href="#Custom-acceleration-indices-1">Custom acceleration indices</a></h3><p>It is simple for a user or another package to implement an <code>AbstractIndex</code> - for instance a third-party package may provide a spatial acceleration index, or an index for fast textual search. Simply overload <code>accelerate</code> (and optionally <code>accelerate!</code>) as well as the operations you would like to accelerate, such as <code>filter</code>, <code>findall</code>, etc. Indices for unique sets of values may inherit from <code>AbstractUniqueIndex &lt;: AbstractIndex</code>.</p><h2><a class="nav-anchor" id="Order-based-predicates-and-Intervals-1" href="#Order-based-predicates-and-Intervals-1">Order-based predicates and Intervals</a></h2><p>In Julia, sorting is (typically) achieved using the <code>isless</code> and <code>isequal</code> predicates, which are designed to provide a canonical total order for values. Currently, the acceleration indices rely on these rather than the comparison operators <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> and <code>!=</code>.</p><p>To make life easier, this package introduces a number of new convenience functions:</p><ul><li><code>islessequal(a, b) = isless(a, b) || isequal(a, b)</code></li><li><code>isgreater(a, b) = isless(b, a)</code></li><li><code>isgreaterequal(a, b) = isless(b, a) || isequal(a, b)</code></li></ul><p>Any of these support &quot;currying&quot;, which is a simple syntax for creating a closure such as <code>isequal(a) = (b -&gt; isequal(a, b))</code>. Such curried predicates are picked up by multiple dispatch to accelerate operations like <code>findall(isequal(3.0), accelerated_array)</code>.</p><h3><a class="nav-anchor" id="Intervals-1" href="#Intervals-1">Intervals</a></h3><p>It is common to want to search for all values in a range. This package introduces an <code>Interval</code> type to represent the set of of values between two endpoints (with respect to <code>isless</code> and <code>isequal</code>).</p><p>An interval is easily created with the <code>..</code> operator via the syntax <code>a .. b</code>. To find if a value is in this range, use the <code>in</code> function/operator (alternatively spelled <code>∈</code>, which can be inserted at the REPL via <code>\in &lt;TAB&gt;</code>). For example, <code>3 ∈ 0 .. 10</code> is <code>true</code> but <code>13 ∈ 0 .. 10</code> is <code>false</code>.</p><p>By default, an interval is inclusive of its endpoints, such that <code>10 ∈ 0 .. 10</code>. An endpoint can be excluded via the <code>lessthan</code> or <code>greaterthan</code> function, which returns a value almost equal to but slightly less/greater than its input. An interval exclusive of both its endpoints can be expressed as <code>greaterthan(a) .. lessthan(b)</code>. For example <code>10 ∉ 0 .. lessthan(10)</code>.</p><h2><a class="nav-anchor" id="Work-remaining-1" href="#Work-remaining-1">Work remaining</a></h2><p>This package is still young, and could support some more features, such as:</p><ul><li>Accelerate more functions, including those in <code>SplitApplyCombine</code>.</li><li>Figure out how to support <code>missing</code>, <code>==</code>, <code>&lt;</code> with either a hash- or sort-based index.</li><li>Move <code>Interval</code>s into their own package, potentially reconcile with <em>IntervalSets.jl</em> (which currently uses <code>&lt;=</code> and <code>&gt;=</code> for comparisons).</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
