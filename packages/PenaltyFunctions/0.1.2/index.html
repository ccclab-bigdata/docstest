<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · PenaltyFunctions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PenaltyFunctions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Available-Penalties-1">Available Penalties</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#License-1">License</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PenaltyFunctions-1" href="#PenaltyFunctions-1">PenaltyFunctions</a></h1><p><em>PenaltyFunctions.jl is a Julia package that provides generic implementations for a diverse set of penalty functions that are commonly used for regularization purposes in Machine Learning.</em></p><table><tr><th><strong>Package Status</strong></th><th><strong>Package Evaluator</strong></th><th><strong>Build Status</strong></th></tr><tr><td><a href="LICENSE.md"><img src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" alt="License"/></a></td><td><a href="http://pkg.julialang.org/?pkg=PenaltyFunctions"><img src="http://pkg.julialang.org/badges/PenaltyFunctions_0.6.svg" alt="Pkg Eval 0.6"/></a></td><td><a href="https://travis-ci.org/JuliaML/PenaltyFunctions.jl"><img src="https://travis-ci.org/JuliaML/PenaltyFunctions.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/Evizero/penaltyfunctions-jl"><img src="https://ci.appveyor.com/api/projects/status/7fcsct29x3m6f4n1?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/github/JuliaML/PenaltyFunctions.jl?branch=josh"><img src="https://coveralls.io/repos/github/JuliaML/PenaltyFunctions.jl/badge.svg?branch=josh" alt="Coverage Status"/></a></td></tr></table><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Many popular models in Machine Learning are parameterized by a set of real-valued coefficients <code>θ</code> (theta), which is usually stored in the form of an array. If our data set has <code>k</code> features, then <code>θ</code> would typically be a vector of <code>k</code> or <code>k+1</code> numeric elements. Each individual feature <code>x_i</code> of our data set is assigned a corresponding coefficient <code>θ_i</code>, which is used to quantify the feature&#39;s influence on the prediction. The concrete values for the coefficient vector are learned by an optimization algorithm, which tries to select the &quot;best&quot; set of coefficients for the given data and model. Without any restriction on their values the optimization algorithm is free to choose the coefficients freely, which may result in overly complex prediction functions. This freedom is known to cause the optimization algorithm to overfit to the noise in the training data. This is where penalties come in!</p><p>A penalty is a function of the coefficients and only the coefficients. It associates the given set of coefficients with a cost without any regard for their influence on the predictive power of the prediction function. This cost is then is added to the overall cost of the prediction function. This way the optimization algorithm is encouraged to choose &quot;simpler&quot; coefficients. What exactly &quot;simpler&quot; means depends on the chosen penalty. In general terms: penalties help to reduce the possibility of overfitting.</p><h2><a class="nav-anchor" id="Available-Penalties-1" href="#Available-Penalties-1">Available Penalties</a></h2><p>This package implements a number of carefully crafted penalty functions, as well as an API to query their properties (e.g. convexity). Furthermore, we expose methods to compute their values and derivatives for a single value, coefficient vectors, and even arrays of arbitrary dimensionality. The provided penalty functions fall into one of two main families, namely <strong>Element Penalties</strong> and <strong>Array Penalties</strong>.</p><h3><a class="nav-anchor" id="Element-Penalties-1" href="#Element-Penalties-1">Element Penalties</a></h3><p>The first family of penalty functions contains all those that apply to to the individual elements of <code>θ</code> element-wise. The resulting cost of a coefficient array is then the sum of the element-wise results.</p><table><tr><th><strong>Univariate Parameter</strong></th><th><strong>Bivariate Parameter</strong></th></tr><tr><td><img src="https://rawgithub.com/JuliaML/FileStorage/master/PenaltyFunctions/univariate.svg" alt="univariate_elem"/></td><td><img src="https://rawgithub.com/JuliaML/FileStorage/master/PenaltyFunctions/bivariate.svg" alt="bivariate_elem"/></td></tr><tr><td>The cost-values of various penalties as a function of a single coefficient</td><td>Cross sections of the cost-surfaces. This time for two coefficients</td></tr></table><p>Every penalty that is of this family is subtype of <code>ElementPenalty</code>. From an implementation perspective these penalties are defined using the element-wise functions. The following table lists the implemented types and their definitions.</p><table><tr><th>Penalty</th><th>value on element</th></tr><tr><td><code>NoPenalty()</code></td><td><code>g(θ) = 0</code></td></tr><tr><td><code>L1Penalty()</code></td><td><code>g(θ) = abs(θ)</code></td></tr><tr><td><code>L2Penalty()</code></td><td><code>g(θ) = 0.5 * θ ^ 2</code></td></tr><tr><td><code>ElasticNetPenalty(α = 0.5)</code></td><td><code>g(θ) = (1 - α) * abs(θ) + α * .5 * θ ^ 2</code></td></tr><tr><td><code>SCADPenalty(a = 3.7, γ = 1.0)</code></td><td><code>L1Penalty that blends to constant</code></td></tr><tr><td><code>MCPPenalty(γ = 2.0)</code></td><td><code>g(θ) = abs(θ) &lt; γ ? abs(θ) - θ ^ 2 / 2γ : γ / 2</code></td></tr><tr><td><code>LogPenalty(η = 1.0)</code></td><td><code>g(θ) = log(1 + η * abs(θ))</code></td></tr></table><p>The total cost for an array of coefficients is then defined as <code>sum(g, θ)</code>.</p><pre><code class="language-julia">using PenaltyFunctions
p = L1Penalty()
x = randn(5)
s = randn(5)
buffer = zeros(5)

# value
value(p, x[1])        # evaluate on element
value(p, x)           # evaluate on array
value.(p, x)          # broadcast is supported as well
value(p, x[1], s[1])  # evaluate on element, scaled by scalar
value(p, x, s[1])     # evaluate on array, scaled by scalar
value(p, x, s)        # evaluate on array, element-wise scaling

# value via calling the Penalty object
p = L1Penalty()
p([1,2,3])

# derivatives and gradients
deriv(p, x[1])        # derivative
deriv(p, x[1], s[1])  # scaled derivative
grad(p, x)            # gradient
grad(p, x, s[1])      # scaled gradient
grad(p, x, s)         # element-wise scaled gradient
grad!(buffer, p, x)       # overwrite buffer with gradient
grad!(buffer, p, x, s[1]) # overwrite buffer with scaled gradient
grad!(buffer, p, x, s)    # overwrite buffer with element-wise scaled gradient

# prox operator
prox(p, x[1], s[1]) # prox on element
prox(p, x, s[1])    # prox on array, scaled by scalar
prox(p, x, s)       # prox on array, element-wise scaling
prox!(p, x, s[1])   # overwrite x, scaled by scalar
prox!(p, x, s)      # overwrite x, element-wise scaling</code></pre><h3><a class="nav-anchor" id="Array-Penalties-1" href="#Array-Penalties-1">Array Penalties</a></h3><p>The second family of penalty functions contains all those that that need to be evaluated on the entire coefficient array <code>θ</code> at once. Every penalty that belongs to this family is subtype of <code>ArrayPenalty</code>. The following table outlines the implemented types and their definitions.</p><table><tr><th>Penalty</th><th>value on array</th></tr><tr><td><code>NuclearNormPenalty()</code></td><td><code>sum of singular values of x</code></td></tr><tr><td><code>MahalanobisPenalty(C)</code></td><td><code>g(x) = x&#39; * C&#39; * C * x</code></td></tr><tr><td><code>GroupLassoPenalty()</code></td><td><code>g(x) = vecnorm(x)</code></td></tr></table><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package is registered in <code>METADATA.jl</code>.</p><pre><code class="language-julia">Pkg.add(&quot;PenaltyFunctions&quot;)</code></pre><h2><a class="nav-anchor" id="License-1" href="#License-1">License</a></h2><p>This code is free to use under the terms of the MIT &quot;Expat&quot; license.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
