<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · Destruct.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Destruct.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Performance-1">Performance</a></li><li><a class="toctext" href="#How-does-it-work?-1">How does it work?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Destruct.jl-1" href="#Destruct.jl-1">Destruct.jl</a></h1><p><a href="https://travis-ci.org/spalato/Destruct.jl"><img src="https://travis-ci.org/spalato/Destruct.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://pkg.julialang.org/?pkg=Destruct&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/Destruct_0.6.svg" alt="PkgEval.jl Status on Julia 0.6"/></a> <a href="http://pkg.julialang.org/?pkg=Destruct&amp;ver=0.7"><img src="http://pkg.julialang.org/badges/Destruct_0.7.svg" alt="PkgEval.jl Status on Julia 0.7"/></a></p><p>Destructuring arrays of tuples in Julia. Should work in Julia 0.6 - 1.0.</p><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>Using julia&#39;s &#39;dot-call&#39; syntax on functions with multiple return arguments results in an array of tuples. Sometimes, you want the tuple of arrays instead, preserving array shape. This can be achieved using <code>destruct</code>, which converts an array of tuple to a tuple of arrays.</p><p>Works with any tuples (ie: with elements of different types).</p><p>This single function doesn&#39;t really require it&#39;s package, maybe you can find it a better home.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><pre><code class="language-julia">julia&gt; using Destruct; using BenchmarkTools
julia&gt; f(a, b) = a+1im*b, a*b, convert(Int, round(a-b)); # some transform returing multiple values
julia&gt; v = f.(rand(3,1), rand(1,4));
julia&gt; typeof(v)
Array{Tuple{Complex{Float64},Float64,Int64},2}
julia&gt; x, y, z = destruct(v);
julia&gt; z
3×4 Array{Int64,2}:
 0  0  0  0
 1  0  1  1
 1  0  1  1
julia&gt; v = f.(rand(500,1,1), rand(1,500,500));
julia&gt; @btime destruct($v); # using BenchmarkTools
  1.396 s (7 allocations: 3.73 GiB)</code></pre><p>Getting this out of the way:</p><pre><code class="language-julia">julia&gt; x, y, z = f.(rand(100,1,1), rand(1,100,100)) |&gt; destruct;</code></pre><h2><a class="nav-anchor" id="Performance-1" href="#Performance-1">Performance</a></h2><p>A common way to unpack Arrays of tuples uses the broadcast dot-call:</p><pre><code class="language-julia">unpack_broadcast(w::Array{&lt;:Tuple}) = Tuple((v-&gt;v[i]).(w) for i=1:length(w[1]))</code></pre><p>However, this approach suffers from two problems: it doesn&#39;t access the elements in the order they are stored in memory and has huge memory consumption for Tuples with varying types (<code>Tuples</code> instead of <code>NTuples</code>).</p><p>This &quot;broadcast unpack&quot; takes between 1.5x and 2x longer than <code>destruct</code> supplied here for arrays of <code>NTuples</code>. The performance gain is much larger  for tuples of heterogenous types: in the 10x to 75x range, using 1/10th of the memory.</p><p>See timing scripts: <code>timing.jl</code> and <code>comparative_timing.jl</code>.</p><h2><a class="nav-anchor" id="How-does-it-work?-1" href="#How-does-it-work?-1">How does it work?</a></h2><p>The <code>destruct</code> function uses macros from <code>Base.Cartesian</code> to allocate destination arrays and iterate over all the things. The alternative implementations using broadcast dot-call is available as <code>Destruct.unpack_broadcast</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
