<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · SchattenNorms.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SchattenNorms.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Norms-implemented-1">Norms implemented</a></li><li><a class="toctext" href="#Utility-functions-1">Utility functions</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Dependencies-1">Dependencies</a></li><li><a class="toctext" href="#TODO-1">TODO</a></li><li><a class="toctext" href="#License-1">License</a></li><li><a class="toctext" href="#Copyright-1">Copyright</a></li><li><a class="toctext" href="#Authors-1">Authors</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SchattenNorms.jl-1" href="#SchattenNorms.jl-1">SchattenNorms.jl</a></h1><p><a href="https://travis-ci.org/BBN-Q/SchattenNorms.jl"><img src="https://travis-ci.org/BBN-Q/SchattenNorms.jl.svg?branch=master" alt="Build Status"/></a></p><p>Simple implementation of Schatten norms. This package includes the complete bounded versions of the induced norms for linear transformations of matrices (i.e., <em>superoperators</em>), implemented as described in</p><p><em>Semidefinite programs for completely bounded norms</em>, John Watrous, <a href="http://theoryofcomputing.org/articles/v005a011/">Theory of Computing, Volume 5 (2009), pp. 217–238</a>. (<a href="http://arxiv.org/abs/0901.4709">preprint</a>)</p><p><em>Simpler semidefinite programs for completely bounded norms</em>, John Watrous, <a href="http://cjtcs.cs.uchicago.edu/articles/2013/8/contents.html">Chicago Journal of Theoretical Computer Science Volume 8 (2013), p. 1-19</a>. (<a href="http://arxiv.org/abs/1207.5726">preprint</a>)</p><p>This package only supports the completely bounded norms for p=1 and p=∞ (which are dual). It is not clear if there is an efficient way to compute the completely bounded norms for other p.</p><h2><a class="nav-anchor" id="Norms-implemented-1" href="#Norms-implemented-1">Norms implemented</a></h2><p>Taking σᵢ(M) to be the <em>i</em>th singular value of a matrix <em>M</em>, we have</p><table><tr><th>Function name</th><th>Mathematical meaning</th></tr><tr><td><code>snorm(M, r)</code></td><td>‖X‖ᵣ = ∑ᵢ (σᵢ(M))ʳ</td></tr><tr><td><code>cbnorm(M, r)</code></td><td>supᵢ {‖M⊗1ᵢ(X)‖ᵣ  :  ‖X‖ᵣ=1}</td></tr></table><p>Some useful aliases and relatd calls are</p><table><tr><th>Alias function</th><th>Equivalent call</th><th>Common name</th></tr><tr><td><code>trnorm(M)</code></td><td><code>snorm(M,1)</code></td><td>trace norm</td></tr><tr><td><code>nucnorm(M)</code></td><td><code>snorm(M,1)</code></td><td>nuclear norm</td></tr><tr><td><code>fnorm(M)</code></td><td><code>snorm(M,2), snorm(M)</code></td><td>Frobenius norm (default for <code>snorm</code>)</td></tr><tr><td><code>specnorm(M)</code></td><td><code>snorm(M,Inf)</code></td><td>spectral norm.</td></tr><tr><td><code>cbnorm(M)</code></td><td><code>cbnorm(M,Inf)</code></td><td>completely bounded norm usually refers to p=∞, so this is the default</td></tr><tr><td><code>dnorm(M)</code></td><td><code>cbnorm(M,1)</code></td><td>diamond norm</td></tr></table><p>For the special case where <code>M</code> is the difference between CPTP maps, or the difference between superoperators corresponding to unitary maps, use <code>ddist</code> described below.</p><h2><a class="nav-anchor" id="Utility-functions-1" href="#Utility-functions-1">Utility functions</a></h2><table><tr><th>Function name</th><th>Common name</th><th>Mathematical meaning</th></tr><tr><td><code>worstfidelity(u, v)</code></td><td>Worst case output state (Jozsa) fidelity</td><td>min {❘⟨ψ ❘ v⁺ u ❘ψ⟩❘² : ❘⟨ψ❘ψ⟩❘² = 1}</td></tr><tr><td><code>ddistu(U,V)</code></td><td>Diamond norm distance between unitary maps</td><td><code>dnorm(liou(U)-liou(V))</code></td></tr><tr><td><code>ddist(E,F)</code></td><td>Diamond norm distance between CPTP maps</td><td><code>dnorm(E-F)</code></td></tr></table><p>Despite the mathematical equivalences between <code>ddist</code>/<code>ddistu</code> and <code>dnorm</code>, <code>ddist</code>/<code>ddistu</code> are much faster and more accurate.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><pre><code class="language-julia">julia&gt; snorm([1 0; 0 -1])
1.4142135623730951

julia&gt; snorm([1 0; 0 -1],1.0)
2.0

julia&gt; snorm([1 0; 0 -1],Inf)
1.0

julia&gt; U,_,_ = svd(randn(2,2)); V,_,_ = svd(randn(2,2)); # unitary invariance

julia&gt; isapprox(snorm([1 0; 0 -1]),snorm(U*[1 0; 0 -1]*V))
true

julia&gt; isapprox(snorm([1 0; 0 -1],1.0),snorm(U*[1 0; 0 -1]*V,1.0))
true

julia&gt; isapprox(snorm([1 0; 0 -1],Inf),snorm(U*[1 0; 0 -1]*V,Inf))
true

julia&gt; R = randn(3,3); snorm(R,1) &gt;= snorm(R,2) &gt;= snorm(R,Inf)
true

julia&gt; p = sort(abs(randn(3))+1.0); snorm(R,p[1]) &gt;= snorm(R,p[2]) &gt;= snorm(R,p[3])
true

julia&gt; snorm(R,1.0) == snorm(R,1) == trnorm(R) == nucnorm(R)
true</code></pre><h2><a class="nav-anchor" id="Dependencies-1" href="#Dependencies-1">Dependencies</a></h2><p>SCS.jl and Convex.jl, for the completely bounded norms.</p><h2><a class="nav-anchor" id="TODO-1" href="#TODO-1">TODO</a></h2><ul><li><p>[ ] The implementation of the completely bounded 1 and ∞ norms is somewhat tailored to transformations between isomorphic spaces. It should be easy to make it more general.</p></li><li><p>[X] The distance between two quantum channels (i.e., trace preserving, completely positive linear maps of operators) is &quot;easier&quot; to compute than the completely bounded 1 norm (the diamond norm). Adding a function just for that would be nice.</p></li><li><p>[X] The diamond norm distance between two unitary maps is also much easier to compute – see, e.g., <a href="https://cs.uwaterloo.ca/~watrous/CS766/LectureNotes/20.pdf">Lecture 20 for John Watrous&#39;s 2011 Quantum Information course</a> – so a customized function would be nice.</p></li></ul><h2><a class="nav-anchor" id="License-1" href="#License-1">License</a></h2><p>Apache Lincense 2.0 (<a href="https://tldrlegal.com/license/apache-license-2.0-(apache-2.0)">summary</a>)</p><h2><a class="nav-anchor" id="Copyright-1" href="#Copyright-1">Copyright</a></h2><p>Raytheon BBN Technologies 2015</p><h2><a class="nav-anchor" id="Authors-1" href="#Authors-1">Authors</a></h2><p>Marcus P da Silva (@marcusps)</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
