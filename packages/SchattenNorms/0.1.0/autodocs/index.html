<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SchattenNorms.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SchattenNorms.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.E_" href="#SchattenNorms.E_"><code>SchattenNorms.E_</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>E<em>(id</em>dim, ρ_rim)</p><p>Generates linear map E such that E(ρ) → 1 ⊗ ρ</p><p>Note that the dual of this map is F such that F*vec(σ ⊗ ρ) → trace(σ) vec(ρ), in other words, E is the dual of the partial trace.</p></div></div></section><pre><code class="language-none">SchattenNorms.SchattenNorms</code></pre><pre><code class="language-none">SchattenNorms.bra</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ddist" href="#SchattenNorms.ddist"><code>SchattenNorms.ddist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ddist(U,V)</p><p>Diamond norm distance between two linear CPTP superoperators.   Equivalent to dnrom(E-F), but under the assumption that <code>E</code> and <code>F</code>   are CPTP supeoperators, but the <code>ddist</code> call is   much more accurate and faster due to properties of CPTP   superoperators.</p><p>See <code>ddistu</code> for a similar implementation of <code>dnorm</code> customized to the difference between unitary operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ddistu" href="#SchattenNorms.ddistu"><code>SchattenNorms.ddistu</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ddist(U,V)</p><p>Diamond norm distance between two unitary operations.   Equivalent to <code>dnorm(liou(U)-liou(V))</code>, under the assumption <code>U</code> and   <code>V</code> are unitary matrices. However the <code>ddist</code> call is much more   accurate and much faster due to properties of unitary matrices and   the corresponding superoperators.</p><p><strong>Note:</strong> for this particular case, the matrices in question are not     the superoperators corresponding to the unitary operation, but     rather the unitary operations themselves.</p><p>See <code>ddist</code> for a similar implementation of <code>dnorm</code> customized to the difference between CPTP maps.</p></div></div></section><pre><code class="language-none">SchattenNorms.dist_to_neighbour</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.dnorm" href="#SchattenNorms.dnorm"><code>SchattenNorms.dnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dnorm(L; solver=Convex.get<em>default</em>solver())</p><p>Computes the diamond norm of a linear superoperator <code>L</code> (i.e., a linear transformation of operators). The superoperator must be represented in column major form. In other words, it must be given by a matrix that, when multiplying a vectorized (column major) operator, it should result in the vectorized (column major) representation of the result of the transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.dnorm2" href="#SchattenNorms.dnorm2"><code>SchattenNorms.dnorm2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dnorm2(L1,L2)</p><p>Computes the diamond norm of a linear superoperator <code>L</code> (i.e., a linear transformation of operators). The superoperator must be represented in column major form. In other words, it must be given by a matrix that, when multiplying a vectorized (column major) operator, it should result in the vectorized (column major) representation of the result of the transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.dnormcptp" href="#SchattenNorms.dnormcptp"><code>SchattenNorms.dnormcptp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dnormcptp(L1,L2)</p><p>Computes the diamond norm distance between two linear completely positive and trace preserving superoperators <code>L1</code> and <code>L2</code> . The superoperators must be represented in column major form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.dnormcptp2" href="#SchattenNorms.dnormcptp2"><code>SchattenNorms.dnormcptp2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dnormcptp(L1,L2)</p><p>Computes the diamond norm of a linear superoperator <code>L</code> (i.e., a linear transformation of operators). The superoperator must be represented in column major form. In other words, it must be given by a matrix that, when multiplying a vectorized (column major) operator, it should result in the vectorized (column major) representation of the result of the transformation.</p></div></div></section><pre><code class="language-none">SchattenNorms.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.fnorm" href="#SchattenNorms.fnorm"><code>SchattenNorms.fnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>fnorm(m)</p><p>Computes the Frobenius norm of a matrix <code>m</code>.</p></div></div></section><pre><code class="language-none">SchattenNorms.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.involution" href="#SchattenNorms.involution"><code>SchattenNorms.involution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>involution(m)</p><p>Permutes the elements of a matrix so that it transforms the column major representation of a linear map L into a matrix C that is positive iff L is completely positive, Hermitian iff L maps (vectorized) Hermitian matrices to Hermitian matrices. In other words, it corresponds to the Choi-Jamiolkoski isomorphism.</p></div></div></section><pre><code class="language-none">SchattenNorms.ket</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.nucnorm" href="#SchattenNorms.nucnorm"><code>SchattenNorms.nucnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>nucnorm(m)</p><p>Computes the nuclear norm of a matrix <code>m</code>.</p></div></div></section><pre><code class="language-none">SchattenNorms.orig_to_line</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.retrϕ" href="#SchattenNorms.retrϕ"><code>SchattenNorms.retrϕ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute the trace of the real representation of a complex matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.snorm" href="#SchattenNorms.snorm"><code>SchattenNorms.snorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>snorm(m,p=2)</p><p>Computes the <code>p</code>-Schatten norm of a matrix <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.specnorm" href="#SchattenNorms.specnorm"><code>SchattenNorms.specnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>specnorm(m)</p><p>Computes the spectral norm of a matrix <code>m</code> (i.e., the maximum singular value).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.trnorm" href="#SchattenNorms.trnorm"><code>SchattenNorms.trnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>trnorm(m)</p><p>Computes the trace norm of a matrix <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.worstfidelity" href="#SchattenNorms.worstfidelity"><code>SchattenNorms.worstfidelity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>worstfidelity(U,V)</p><p>For two unitaries <code>U</code> and <code>V</code>, <code>worstfidelity(U,V)</code> is the worst case Jozsa fidelity between <code>U*a</code> and <code>V*a</code>, where <code>a</code> is a complex vector with norm 1. That is, <code>worstfidelity(U,V)</code> is equal to the minimum of <code>|a&#39;*U&#39;*V*a|^2</code> over all complex vectors <code>a</code> with unit norm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ϕ" href="#SchattenNorms.ϕ"><code>SchattenNorms.ϕ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ϕ represents the isomorphism between complex and real matrices.  e.g., see <a href="http://arxiv.org/abs/1007.2905">Invariant semidefinite programs</a>  by Bachoc et al.  If two arguments are given, they are taken to be the real and  imaginary parts of a complex matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ϕi" href="#SchattenNorms.ϕi"><code>SchattenNorms.ϕi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Extract the imag part of a complex matrix represented as a real matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ϕinv" href="#SchattenNorms.ϕinv"><code>SchattenNorms.ϕinv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Extract the real and imag parts of a complex matrix represented as a real matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SchattenNorms.ϕr" href="#SchattenNorms.ϕr"><code>SchattenNorms.ϕr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Extract the real part of a complex matrix represented as a real matrix</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
