<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuliaFEM Linear Static Example · JuliaFEM</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83590644-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">User&#39;s guide</span></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../2d_hertz_contact/">2D Hertz contact problem</a></li><li><a class="toctext" href="../3d_frame/">Natural frequency analysis of 3d frame structure</a></li><li><a class="toctext" href="../generate_stiffness_matrices/">Generating local matrices for problems</a></li><li class="current"><a class="toctext" href>JuliaFEM Linear Static Example</a><ul class="internal"><li><a class="toctext" href="#Preprocessing-1">Preprocessing</a></li><li><a class="toctext" href="#Postprocessing-1">Postprocessing</a></li><li><a class="toctext" href="#Testing-1">Testing</a></li></ul></li></ul></li><li><span class="toctext">Developer&#39;s guide</span><ul><li><a class="toctext" href="../../packages/FEMBase/mesh/">Mesh</a></li><li><a class="toctext" href="../../packages/FEMBase/fields/">Fields</a></li><li><a class="toctext" href="../../packages/FEMBase/basis/">Basis functions</a></li><li><a class="toctext" href="../../packages/FEMBase/integration/">Integration</a></li><li><a class="toctext" href="../../packages/FEMBase/elements/">Elements</a></li><li><a class="toctext" href="../../packages/FEMBase/problems/">Problems</a></li><li><a class="toctext" href="../../packages/FEMBase/solvers/">Analyses and solvers</a></li><li><a class="toctext" href="../../packages/FEMBase/postprocessing/">Postprocessing</a></li><li><a class="toctext" href="../../packages/FEMBase/results/">Results</a></li><li><a class="toctext" href="../../packages/FEMBase/materials/">Materials</a></li></ul></li><li><span class="toctext">Description of packages</span><ul><li><a class="toctext" href="../../packages/FEMBase/">FEMBase.jl</a></li><li><a class="toctext" href="../../packages/AsterReader/">AsterReader.jl</a></li><li><a class="toctext" href="../../packages/AbaqusReader/">AbaqusReader.jl documentation</a></li><li><a class="toctext" href="../../packages/HeatTransfer/">HeatTransfer.jl</a></li><li><a class="toctext" href="../../packages/FEMBeam/">Introduction</a></li><li><a class="toctext" href="../../packages/MortarContact2D/">MortarContact2D.jl</a></li><li><a class="toctext" href="../../packages/MortarContact2DAD/">MortarContact2DAD.jl</a></li></ul></li><li><span class="toctext">API documentation</span><ul><li><a class="toctext" href="../../api/">API documentation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>JuliaFEM Linear Static Example</a></li></ul><a class="edit-page" href="https://github.com/TRAVIS_REPO_SLUG/blob/master/"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>JuliaFEM Linear Static Example</span><a class="fa fa-bars" href="#"></a></div></header><p>This file is a part of JuliaFEM. License is MIT: see https://github.com/JuliaFEM/JuliaFEM.jl/blob/master/LICENSE.md</p><h1><a class="nav-anchor" id="JuliaFEM-Linear-Static-Example-1" href="#JuliaFEM-Linear-Static-Example-1">JuliaFEM Linear Static Example</a></h1><p><img src="freecad.png" alt/></p><h2><a class="nav-anchor" id="Preprocessing-1" href="#Preprocessing-1">Preprocessing</a></h2><div><pre><code class="language-julia">using JuliaFEM</code></pre></div><p>First we will read in the mesh. Geometry and mesh are greated with FreeCAD, where med format is selected for exporting. Mesh file consist also edge and surface mesh, which we will need to neglect later.</p><pre><code class="language-">datadir = Pkg.dir(&quot;JuliaFEM&quot;, &quot;examples&quot;, &quot;linear_static&quot;)
meshfile = joinpath(datadir, &quot;JuliaFEMSMP18.med&quot;)
mesh = aster_read_mesh(meshfile)</code></pre><p>Next we will create the model and define Elasticity. Also elements are added to the model.</p><pre><code class="language-">model = Problem(Elasticity, &quot;OTHER&quot;, 3)
model_elements = create_elements(mesh, &quot;OTHER&quot;)</code></pre><p>Elements need material properties and they are defined next</p><pre><code class="language-">update!(model_elements, &quot;youngs modulus&quot;, 208.0E3)
update!(model_elements, &quot;poissons ratio&quot;, 0.30)
update!(model_elements, &quot;density&quot;, 7.80E-9)
add_elements!(model, model_elements)</code></pre><p>We can ignore Seg3 and Tri6 elements using <code>filter</code> with a special function returning true if element is something else than Seg3 or Tri6:</p><div><pre><code class="language-julia">function is_not_Seg3_or_Tri6(element)
    return !isa(element, Union{Element{Seg3}, Element{Tri6}})
end

filter!(is_not_Seg3_or_Tri6, model.elements)</code></pre><pre><code class="language-none">0-element Array{Element,1}</code></pre></div><p>The whole idea of the JuliaFEM input is to be a normal Julia script, where the user can freely define any functions needed to perform the task. Here we define a function, which finds nodes on the given plane yz, xz or xy from the given height.</p><div><pre><code class="language-julia">function add_nodes_at_certain_plane_to_node_set!(mesh, name, vector_id, distance,
                                                 radius=6.0)
    for (node, coords) in mesh.nodes
        if isapprox(coords[vector_id], distance, atol=radius)
            add_node_to_node_set!(mesh, name, node)
        end
    end
    return nothing
end</code></pre><pre><code class="language-none">add_nodes_at_certain_plane_to_node_set! (generic function with 2 methods)</code></pre></div><p>We will find nodes from the xz-plane going through point (0,50,0) or actually we previously defined the radius to be 6.0, which means (0,[44,56],0). In other words we will select each node, which second coordinate value is between 44 and 56. This function will edit mesh object and add node set called <code>:mid_fixed</code> to it.</p><pre><code class="language-">add_nodes_at_certain_plane_to_node_set!(mesh, :mid_fixed, 2, 50.0)</code></pre><p>We need to somehow handle the i&#39;s dot. I looked the rough coordinates of the dot in FreeCAD and now we can search three closest nodes to these coordinates. Those will be added to the same set <code>:mid_fixed</code>.</p><pre><code class="language-">ipoint = find_nearest_nodes(mesh, [165.0, 88.0, 10],3)
for poi in ipoint
    add_node_to_node_set!(mesh, :mid_fixed, poi)
end</code></pre><p>The fixed boundary conditions are defined next.</p><pre><code class="language-">fixed = Problem(Dirichlet, &quot;fixed&quot;, 3, &quot;displacement&quot;)
fixed_elements = create_nodal_elements(mesh, &quot;mid_fixed&quot;)
add_elements!(fixed, fixed_elements)
update!(fixed_elements, &quot;displacement 1&quot;, 0.0)
update!(fixed_elements, &quot;displacement 2&quot;, 0.0)
update!(fixed_elements, &quot;displacement 3&quot;, 0.0)</code></pre><p>Let&#39;s use simple acceleration load.</p><pre><code class="language-">update!(model_elements, &quot;displacement load 1&quot;, 1.0)</code></pre><p>Finally the ´Analysis` couples everything togeter.</p><div><pre><code class="language-julia">analysis = Analysis(Linear, model, fixed)</code></pre><pre><code class="language-none">[ Info: Creating a new analysis of type Linear with name `LinearSolver`.
Analysis{Linear}(&quot;LinearSolver&quot;, Problem[Problem{Elasticity}(&quot;OTHER&quot;, 3, &quot;none&quot;, Element[], Dict{Element,Array{Int64,1}}(), Assembly(SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), Float64[], Float64[], Inf, Float64[], Float64[], Inf, Int64[]), Dict{String,AbstractField}(), String[], Elasticity(:continuum, false, false, Symbol[])), Problem{Dirichlet}(&quot;fixed&quot;, 3, &quot;displacement&quot;, Element[], Dict{Element,Array{Int64,1}}(), Assembly(SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), SparseMatrixCOO{Float64}(Int64[], Int64[], Float64[]), Float64[], Float64[], Inf, Float64[], Float64[], Inf, Int64[]), Dict{String,AbstractField}(), String[], Dirichlet(:incremental, false, false, 1))], Dict{String,AbstractField}(), AbstractResultsWriter[], Linear(0.0))</code></pre></div><p>Let&#39;s write resuls to Xdmf file</p><div><pre><code class="language-julia">xdmf = Xdmf(&quot;model_results&quot;; overwrite=true)
add_results_writer!(analysis, xdmf)</code></pre></div><p>This is how the stresses are requested</p><div><pre><code class="language-julia">push!(model.postprocess_fields, &quot;stress&quot;)</code></pre><pre><code class="language-none">1-element Array{String,1}:
 &quot;stress&quot;</code></pre></div><p>Now we have all we need to run the analysis.</p><pre><code class="language-">run!(analysis)</code></pre><h2><a class="nav-anchor" id="Postprocessing-1" href="#Postprocessing-1">Postprocessing</a></h2><p>In order to look the results, we will need to close the xdmf that it is actually written to the file from buffer.</p><div><pre><code class="language-julia">close(xdmf)</code></pre></div><p>Finally when we open the model in ParaView and set some settings we have this end result.</p><p><img src="paraview.png" alt/></p><h2><a class="nav-anchor" id="Testing-1" href="#Testing-1">Testing</a></h2><p>First let&#39;s test that we have the output files writen to the disk</p><pre><code class="language-">if VERSION &lt; v&quot;1.0.0&quot;
    using Base.Test
else
    using Test
end

@test isfile(&quot;model_results.xmf&quot;)
@test isfile(&quot;model_results.h5&quot;)</code></pre><p>Secondly let&#39;s test that we have the same maximum displacement each time. This is also an usefull example how to access the displacements values.</p><pre><code class="language-">time = 0.0
u = analysis(&quot;displacement&quot;, time)
u_norms = Dict(i =&gt; norm(j) for (i, j) in u)
@test isapprox(maximum(values(u_norms)),2.4052929896922337)#-</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../generate_stiffness_matrices/"><span class="direction">Previous</span><span class="title">Generating local matrices for problems</span></a><a class="next" href="../../packages/FEMBase/mesh/"><span class="direction">Next</span><span class="title">Mesh</span></a></footer></article></body></html>
