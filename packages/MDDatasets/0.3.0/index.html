<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · MDDatasets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MDDatasets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#[:heavy*exclamation*mark:-Core-of-C-Data-Analysis/Visualization-Suite](https://github.com/ma-laforge/CData.jl)-1">:heavy<em>exclamation</em>mark: Core of C-Data Analysis/Visualization Suite</a></li><li><a class="toctext" href="#Description-1">Description</a></li><li><a class="toctext" href="#Principal-Types-1">Principal Types</a></li><li><a class="toctext" href="#Sample-Usage-1">Sample Usage</a></li><li><a class="toctext" href="#Usage:-Constructing-A-Hyper-Rectangular-Dataset-1">Usage: Constructing A Hyper-Rectangular Dataset</a></li><li><a class="toctext" href="#Usage:-Constructing-A-Recursive-Sweep-Dataset-1">Usage: Constructing A Recursive-Sweep Dataset</a></li><li><a class="toctext" href="#Known-Limitations-1">Known Limitations</a></li><li><a class="toctext" href="#Disclaimer-1">Disclaimer</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="MDDatasets.jl:-Multi-Dimensional-Datasets-1" href="#MDDatasets.jl:-Multi-Dimensional-Datasets-1">MDDatasets.jl: Multi-Dimensional Datasets</a></h1><h2><a class="nav-anchor" id="[:heavy*exclamation*mark:-Core-of-C-Data-Analysis/Visualization-Suite](https://github.com/ma-laforge/CData.jl)-1" href="#[:heavy*exclamation*mark:-Core-of-C-Data-Analysis/Visualization-Suite](https://github.com/ma-laforge/CData.jl)-1"><a href="https://github.com/ma-laforge/CData.jl">:heavy<em>exclamation</em>mark: Core of C-Data Analysis/Visualization Suite</a></a></h2><p><a href="https://travis-ci.org/ma-laforge/MDDatasets.jl"><img src="https://travis-ci.org/ma-laforge/MDDatasets.jl.svg?branch=master" alt="Build Status"/></a></p><h2><a class="nav-anchor" id="Description-1" href="#Description-1">Description</a></h2><p>The MDDatasets.jl module provides tools to simplify manipulation of multi-dimensional datasets.  MDDatasets.jl implements the core algorithms of the <a href="https://github.com/ma-laforge/CData.jl">C-Data Analysis/Visualization Suite</a></p><p>| &lt;img src=&quot;https://github.com/ma-laforge/FileRepo/blob/master/SignalProcessing/sampleplots/demo15.png&quot; width=&quot;850&quot;&gt; | | :–-: |</p><h3><a class="nav-anchor" id="Functions-Of-1-Argument-(DataF1)-and-Interpolation-1" href="#Functions-Of-1-Argument-(DataF1)-and-Interpolation-1">Functions Of 1 Argument (<code>DataF1</code>) &amp; Interpolation</a></h3><p>Type <code>DataF1</code> is used to represent <em>continuous</em> functions of 1 argument (y = f(x)).  <code>DataF1</code> stores samples of said functions in its <code>x</code> &amp; <code>y</code> vectors.</p><p>Operations performed on two <code>DataF1</code> objects will result in the interpolation of the corresponding <code>{x, y}</code> coordinates.  Furthermore, operations beyond the x-range of a <code>DataF1</code> object &quot;extrapolate&quot; to 0.</p><p>By grouping <code>x</code> &amp; <code>y</code> vectors together, <code>DataF1</code> objects can also lead to simpler/less error-prone interfaces:</p><pre><code class="language-none">PlottingModule.plot(x, y, ...)</code></pre><p>gets simplified to:</p><pre><code class="language-none">PlottingModule.plot(data, ...)</code></pre><p>NOTE: When dealing with complex algorithms, this simplification is rearkably quite significant.</p><h3><a class="nav-anchor" id="Multi-Dimensional-Datasets-(DataHR,-DataRS)-and-Broadcasting-1" href="#Multi-Dimensional-Datasets-(DataHR,-DataRS)-and-Broadcasting-1">Multi-Dimensional Datasets (<code>DataHR</code>, <code>DataRS</code>) &amp; Broadcasting</a></h3><p>In order to identify trends, or simply to verify the repeatability of a process, one often needs to perform the same operation on multiple &quot;experiments&quot;.  This module provides two types that store/organize/access experiment data in a convenient fashion:</p><ul><li><p><strong><code>DataHR</code> (Hyper-Rectangle)</strong>: Collects simpler data elements (like <code>DataF1</code>) into a n-dimensional array.  Each element in <code>DataHR</code> is used to store the result of an &quot;experiment&quot;, and each array dimension represents an <em>independent</em> control variable that was varied (swept).</p></li><li><p><strong><code>DataRS</code> (Recursive Sweep)</strong>: Collects simpler data elements (like <code>DataF1</code>) into a recursive data structure.  Each <code>DataRS</code> element is used to store the results on an &quot;experiment&quot; (or collection of experiments) where a control variable was varied (swept).  Due to the recursive nature of <code>DataRS</code>, each &quot;sweep&quot; can potentially represent a control variable that is <em>dependent</em> on a previous &quot;sweep&quot;.</p></li></ul><h4><a class="nav-anchor" id="Broadcast-Features-1" href="#Broadcast-Features-1">Broadcast Features</a></h4><p>Operations performed on multi-dimensional data sets (<code>DataHR</code> and <code>DataRS</code>) will automatically be broadcast to each element of the dataset (<a href="#KnownLimitations">see Known Limitations</a>).</p><p>Explicit looping over <code>DataHR</code> &amp; <code>DataRS</code> structures is therefore typically not required.  Many algorithms can be used unmodified, even after changing the set of experimental points.</p><p>By default, reducing functions (like <code>maximum</code>, <code>minimum</code>, or <code>mean(::Vector) =&gt; Scalar</code>) will operate on <code>DataHR/DataRS</code> structures by collapsing the inner-most dimension:</p><pre><code class="language-none">#Assuming sig -&gt; DataHR{sweeps={supply, temp, ctrlVoltage}} of DataF1{x=time}
freqVctrl = mean(measfreq(sig)) #DataHR{sweeps={supply, temp, ctrlVoltage}}
maxfVtemp = maximum(freqVctrl) #DataHR{sweeps={supply, temp}}
maxfVsupply = maximum(maxfVtemp) #DataHR{sweeps={supply}}</code></pre><p>As can be inferred from above, the sweep from the inner-most dimension can be thought as the x-coordinate of the data.  That is because subsequent operations will be applied along that dimension.</p><p>TODO: Provide a means to re-order dimensions.</p><h2><a class="nav-anchor" id="Principal-Types-1" href="#Principal-Types-1">Principal Types</a></h2><ul><li><strong><code>DataInt, DataFloat, DataComplex</code></strong>: Useful aliases for largest practical data types on a platform (not yet platform dependent).</li><li><strong><code>DataMD</code></strong>: Abastract data type for multi-dimensional data.</li><li><strong><code>DataF1</code></strong>: Represents a function of 1 variable, y(x) using a x/y vector pair.</li><li><strong><code>DataHR{DataF1/DataInt/DataFloat/DataComplex}</code></strong>: A hyper-rectangular organizaton of data.  Principally designed to collect massive datasets with <em>independent</em> control variables (<a href="#SampleUsage_DataHR">see examples</a>).</li><li><strong><code>DataRS{DataF1/DataInt/DataFloat/DataComplex}</code></strong>: A recursive-sweep organization of data.  Principally designed to collect massive datasets with <em>dependent</em> control variables(<a href="#SampleUsage_DataRS">see examples</a>).</li><li><strong><code>PSweep</code></strong>: A parameter sweep (i.e. an independent control variable that generates experimental points in a <code>DataHR</code> dataset).</li></ul><h3><a class="nav-anchor" id="Function-Listing-1" href="#Function-Listing-1">Function Listing</a></h3><h4><a class="nav-anchor" id="Imported-From-Base-1" href="#Imported-From-Base-1">Imported From <code>Base</code></a></h4><ul><li><p>Single-argument functions:</p><ul><li><code>zeros, ones, abs, abs2, angle,</code></li></ul></li></ul><p>&lt;br&gt;<code>imag, real, exponent,</code> &lt;br&gt;<code>exp, exp2, exp10, expm1,</code> &lt;br&gt;<code>log, log10, log1p, log2,</code> &lt;br&gt;<code>ceil, floor,</code> &lt;br&gt;<code>asin, asind, asinh, acos, acosd, acosh,</code> &lt;br&gt;<code>atan, atand, atanh, acot, acotd, acoth,</code> &lt;br&gt;<code>asec, asecd, asech, acsc, acscd, acsch,</code> &lt;br&gt;<code>sin, sind, sinh, cos, cosd, cosh,</code> &lt;br&gt;<code>tan, tand, tanh, cot, cotd, coth,</code> &lt;br&gt;<code>sec, secd, sech, csc, cscd, csch,</code> &lt;br&gt;<code>sinpi, cospi,</code> &lt;br&gt;<code>sinc, cosc,</code> &lt;br&gt;<code>deg2rad, rad2deg,</code></p><ul><li><p>Two-argument functions:</p><ul><li><code>+, -, *, /,</code></li></ul></li></ul><p>&lt;br&gt;<code>max, min,</code> &lt;br&gt;<code>atan, hypot,</code> &lt;br&gt;<code>maximum, minimum,</code> &lt;br&gt;<code>prod, sum,</code> &lt;br&gt;<code>mean, median, middle,</code></p><h4><a class="nav-anchor" id="Differential/Integral-Math-1" href="#Differential/Integral-Math-1">Differential/Integral Math</a></h4><ul><li><strong><code>deriv</code></strong><code>(d::DataF1, shiftx=[Bool])</code>: Returns dataset with derivative of <code>d</code></li><li><strong><code>integ</code></strong><code>(d::DataF1, shiftx=[Bool])</code>: Returns definite integral of <code>d</code></li><li><strong><code>iinteg</code></strong><code>(d::DataF1, shiftx=[Bool])</code>: Returns dataset with indefinite integral of <code>d</code></li></ul><h4><a class="nav-anchor" id="Basic-Dataset-Operations-1" href="#Basic-Dataset-Operations-1">Basic Dataset Operations</a></h4><ul><li><strong><code>xval</code></strong><code>(::DataF1)</code>: Returns a dataset with where y(x) = x.</li><li><strong><code>value</code></strong><code>(y::DataF1, x=[Real])</code>: Returns <code>y(x)</code></li><li><strong><code>clip</code></strong><code>()</code>: Returns a dataset clipped within an x-range<ul><li><code>clip(::DataF1, xrng::Range)</code></li><li><code>clip(::DataF1, xmin=[Real], xmax=[Real])</code></li></ul></li><li><strong><code>sample</code></strong><code>(::DataF1, xrng::Range)</code>: Returns dataset sampled @ each point in <code>xrng</code></li><li><strong><code>xshift</code></strong><code>(::DataF1, offset::Number)</code>: Returns dataset with all x-values shifted by <code>offset</code> (negative values &quot;shift left&quot;)</li><li><strong><code>xscale</code></strong><code>(::DataF1, fact::Number)</code>: Returns dataset with all x-values scaled by <code>fact</code></li><li><strong><code>yvsx</code></strong><code>(yv::DataF1, xv::DataF1)</code>: Returns dataset with <code>{xv(x), yv(x)}</code> (interpolating, when necessary)</li></ul><h4><a class="nav-anchor" id="Cross-Based-Operations-1" href="#Cross-Based-Operations-1">Cross-Based Operations</a></h4><p>Note: The <code>Event</code> object makes functions return x-vectors that represent the current event number.</p><ul><li><strong><code>xcross</code></strong><code>()</code>: Returns x-values of <code>d1</code> (up-to <code>nmax</code>) when <code>d1</code> crosses 0 (<code>nmax</code>=0: get all crossings):<ul><li><code>xcross([Event,] d1::DataF1, [nmax::Int,] xstart=[Real], allow=[CrossType])</code></li></ul></li><li><strong><code>ycross</code></strong><code>()</code>: Returns y-values of <code>d2</code> (up-to <code>nmax</code>) when <code>d1</code> crosses <code>d2</code> (<code>nmax</code>=0: get all crossings):<ul><li><code>ycross([Event,] d1::DataF1, d2::DataF1, [nmax::Int,] xstart=[Real], allow=[CrossType])</code></li></ul></li><li><strong><code>xcross1</code></strong><code>()</code>: Returns scalar x-value of <code>d1</code> on <code>n</code>-th zero-crossing:<ul><li><code>xcross1([Event,] d1::DataF1, n=[Int], xstart=[Real], allow=[CrossType])</code></li></ul></li><li><strong><code>ycross1</code></strong><code>()</code>: Returns scalar y-value of <code>d1</code> on <code>n</code>-th crossing of <code>d1</code> &amp; <code>d2</code>:<ul><li><code>ycross1([Event,] d1::DataF1, n=[Int], xstart=[Real], allow=[CrossType])</code></li></ul></li></ul><h5><a class="nav-anchor" id="Operations-On-Clock-Signals-1" href="#Operations-On-Clock-Signals-1">Operations On Clock Signals</a></h5><ul><li><strong><code>measperiod</code></strong><code>(d::DataF1, nmax=[Int], tstart=[Real], xing=[CrossType], shiftx=[Bool])</code></li><li><strong><code>measfreq</code></strong><code>(d::DataF1, nmax=[Int], tstart=[Real], xing=[CrossType], shiftx=[Bool])</code></li></ul><h5><a class="nav-anchor" id="Operations-On-Binary-Signals-1" href="#Operations-On-Binary-Signals-1">Operations On Binary Signals</a></h5><ul><li><strong><code>measdelay</code></strong><code>(dref::DataF1, dmain::DataF1, nmax=[Int], tstart_ref=[Real], tstart_main=[Real], xing_ref=[CrossType], xing_main=[CrossType])</code></li><li><strong><code>measck2q</code></strong><code>(ck::DataF1, q::DataF1, delaymin=[Real], tstart_ck=[Real], tstart_q=[Real], xing_ck=[CrossType], xing_q=[CrossType])</code></li></ul><h5><a class="nav-anchor" id="The-CrossType-Object-1" href="#The-CrossType-Object-1">The <code>CrossType</code> Object</a></h5><p>The <code>CrossType</code> object is used to filter out undersired events.</p><ul><li><code>sing</code>: Include singularities (points that cross at a single point).</li><li><code>flat</code>: Include middle of crossings that are detected at multiple consecutive points.</li><li><code>thru</code>: Include crossings make it all the way through the crossing point.</li><li><code>rev</code>: Include crossings that hit the crossing point, then reverse back.</li><li><code>firstlast</code>: Include first/last crossing points (when data starts or ends @ crossing point itself).</li></ul><p>Constructors:</p><ul><li><strong><code>CrossType</code></strong>: Indicates which crossings are allowed in the result.<ul><li><code>CrossType(rise=[Bool], fall=[Bool], sing=[Bool], flat=[Bool], thru=[Bool], rev=[Bool], firstlast=[Bool])</code></li><li><code>CrossType(:rise)</code>: Preset to selecting rising edges</li><li><code>CrossType(:fall)</code>: Preset to selecting falling edges</li><li><code>CrossType(:risefall)</code>: Preset to selecting both rising &amp; falling edges</li></ul></li></ul><p>&lt;a name=&quot;SampleUsage&quot;&gt;&lt;/a&gt;</p><h2><a class="nav-anchor" id="Sample-Usage-1" href="#Sample-Usage-1">Sample Usage</a></h2><p>Examples of the MDDatasets.jl capabilities can be found under the <a href="test/">test directory</a>.</p><p>More advanced usage examples can be found in the <a href="https://github.com/ma-laforge/SignalProcessing.jl/tree/master/sample">sample directory</a> of the <a href="https://github.com/ma-laforge/SignalProcessing.jl">SignalProcessing.jl module</a>.</p><p>&lt;a name=&quot;SampleUsage_DataHR&quot;&gt;&lt;/a&gt;</p><h2><a class="nav-anchor" id="Usage:-Constructing-A-Hyper-Rectangular-Dataset-1" href="#Usage:-Constructing-A-Hyper-Rectangular-Dataset-1">Usage: Constructing A Hyper-Rectangular Dataset</a></h2><p>Assuming input data can be generated using the following:</p><pre><code class="language-none">t = DataF1((0:.01:10)*1e-9) #Time vector stored as a function of 1 argument

#NOTE: get_ydata returns type &quot;DataF1&quot; (stores data as a function of 1 argument):
get_ydata(t::DataF1, tbit, vdd, trise) = sin(2pi*t/tbit)*(trise/tbit)+vdd</code></pre><p>One can create a relatively complex Hyper-Rectangular (DataHR) dataset using the following pattern:</p><pre><code class="language-none">#Parametric sweep representing independent variables of an experiment:
sweeplist = PSweep[
	PSweep(&quot;tbit&quot;, [1, 3, 9] * 1e-9)
	PSweep(&quot;VDD&quot;, 0.9 * [0.9, 1, 1.1])
	PSweep(&quot;trise_frac&quot;, [0.1, 0.15, 0.2]) #Rise time as fraction of bit rate
]

#Generate Hyper-Recangular dataset (DataHR, using dimensions from sweeplist)
datahr = fill(DataHR{DataF1}, sweeplist) do tbit, vdd, trise_frac
	trise = trise_frac*tbit
	return get_ydata(t, tbit, vdd, trise)
end</code></pre><p>&lt;a name=&quot;SampleUsage_DataRS&quot;&gt;&lt;/a&gt;</p><h2><a class="nav-anchor" id="Usage:-Constructing-A-Recursive-Sweep-Dataset-1" href="#Usage:-Constructing-A-Recursive-Sweep-Dataset-1">Usage: Constructing A Recursive-Sweep Dataset</a></h2><p>Assuming input data can be generated using the following:</p><pre><code class="language-none">t = DataF1((0:.01:10)*1e-9) #Time vector stored as a function of 1 argument

#NOTE: get_ydata returns type &quot;DataF1&quot; (stores data as a function of 1 argument):
get_ydata(t::DataF1, tbit, vdd, trise) = sin(2pi*t/tbit)*(trise/tbit)+vdd</code></pre><p>One can create a relatively complex Recursive-Sweep (DataRS) dataset using the following pattern:</p><pre><code class="language-none">datars = fill(DataRS, PSweep(&quot;tbit&quot;, [1, 3, 9] * 1e-9)) do tbit
	fill(DataRS, PSweep(&quot;VDD&quot;, 0.9 * [0.9, 1, 1.1])) do vdd

		#Inner-most sweep: need to specify element type (DataF1):
		fill(DataRS{DataF1}, PSweep(&quot;trise&quot;, [0.1, 0.15, 0.2] * tbit)) do trise
			return get_ydata(t, tbit, vdd, trise)
		end
	end
end</code></pre><p>&lt;a name=&quot;KnownLimitations&quot;&gt;&lt;/a&gt;</p><h2><a class="nav-anchor" id="Known-Limitations-1" href="#Known-Limitations-1">Known Limitations</a></h2><h3><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h3><ol><li>Support for broadcasting functions over <code>DataHR</code> &amp; <code>DataRS</code> types is fairly extensive.<ul><li>Nonetheless, the system is incomplete/imperfect, and unexpected failures will occur.</li></ul></li></ol><h3><a class="nav-anchor" id="Compatibility-1" href="#Compatibility-1">Compatibility</a></h3><p>Extensive compatibility testing of MDDatasets.jl has not been performed.  The module has been tested using the following environment(s):</p><ul><li>Linux / Julia-0.7.0 (64-bit)</li></ul><h2><a class="nav-anchor" id="Disclaimer-1" href="#Disclaimer-1">Disclaimer</a></h2><p>The MDDatasets.jl module is not yet mature.  Expect significant changes.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
