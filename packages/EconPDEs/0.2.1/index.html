<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · EconPDEs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>EconPDEs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#A-Simple-Example-1">A Simple Example</a></li><li class="toplevel"><a class="toctext" href="#Boundary-Conditions-1">Boundary Conditions</a></li><li class="toplevel"><a class="toctext" href="#Time-Iteration-1">Time Iteration</a></li><li class="toplevel"><a class="toctext" href="#Installation-1">Installation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/matthieugomez/EconPDEs.jl"><img src="https://travis-ci.org/matthieugomez/EconPDEs.jl.svg?branch=master" alt="Build Status"/></a></p><p>This package provides the function <code>pdesolve</code>that solves (system of) nonlinear ODEs/PDEs arising in economic models.</p><ul><li>It is fast: the underlying algorithm has a quadratic rate of convergence around the solution.</li><li>It is robust: the underlying algorithm is based on a combination of upwinding and non-linear time stepping (more details <a href="https://github.com/matthieugomez/EconPDEs.jl/blob/master/src/details.pdf">here</a>)</li><li>It is simple-to-use: one can solve a PDE in less than 10 lines of codes. No need to explicitly set up the finite-difference scheme.</li></ul><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>The <a href="https://github.com/matthieugomez/EconPDEs.jl/tree/master/examples">examples folder</a>  solves a variety of macro-finance models:</p><ul><li><em>Habit Model</em> (Campbell Cochrane (1999) and Wachter (2005))</li><li><em>Long Run Risk Model</em> (Bansal Yaron (2004))</li><li><em>Disaster Model</em> (Wachter (2013))</li><li><em>Heterogeneous Agent Models</em> (Garleanu Panageas (2015), Di Tella (2017), Haddad (2015))</li><li><em>Consumption with Borrowing Constraint</em> (Wang Wang Yang (2016), Achdou Han Lasry Lions Moll (2018))</li><li><em>Investment with Borrowing Constraint</em> (Bolton Chen Wang (2009))</li></ul><h1><a class="nav-anchor" id="A-Simple-Example-1" href="#A-Simple-Example-1">A Simple Example</a></h1><p>For instance, to solve the PDE giving the price-dividend ratio in the Long Run Risk model: &lt;img src=&quot;img/by.png&quot;&gt;</p><pre><code class="language-julia">using EconPDEs
# define state grid
state = OrderedDict(:μ =&gt; range(-0.05, stop = 0.1, length = 1000))

# define initial guess
y0 = OrderedDict(:V =&gt; ones(1000))

# define pde function that specifies PDE to solve. The function takes two arguments:
# 1. state variable `state`, a named tuple. 
# The state can be accessed with `state.x` where `x` denotes the name of the state variable.
# 2. current solution `sol`, a named tuple. 
# The current solution at the current state can be accessed with `sol.y` where `y` denotes the name of initial guess. 
# Its derivative can be accessed with `sol.yx` where `x` denotes the name of state variable.
# Its second derivative can be accessed with `sol.yxx`,
# It returns two outputs
# 1. a tuple with the value of PDE at current solution and current state 
# 2. a tuple with drift of state variable, used for upwinding 
function f(state, sol)
	μbar = 0.018 ; ϑ = 0.00073 ; θμ = 0.252 ; νμ = 0.528 ; ρ = 0.025 ; ψ = 1.5 ; γ = 7.5
	Vt = 1 / sol.V - ρ + (1 - 1 / ψ) * (state.μ - 0.5 * γ * ϑ) + θμ * (μbar - state.μ) * sol.Vμ / sol.V +
	0.5 * νμ^2 * ϑ * sol.Vμμ / sol.V + 0.5 * (1 / ψ - γ) / (1- 1 / ψ) * νμ^2 *  ϑ * sol.Vμ^2/sol.V^2
	(Vt,), (θμ * (μbar - state.μ),)
end

# the function `pdesolve` takes three arguments: (i) a function encoding the ode / pde (ii) a state grid corresponding to a discretized version of the state space (iii) an initial guess for the array(s) to solve for. 
pdesolve(f, state, y0)</code></pre><p>More complicated ODEs / PDES (including PDE with two state variables or systems of multiple PDEs) can be found in the <code>examples</code> folder. </p><h1><a class="nav-anchor" id="Boundary-Conditions-1" href="#Boundary-Conditions-1">Boundary Conditions</a></h1><p>When solving a PDE using a finite scheme approach, one needs to specify the value of the solution <em>outside</em> the grid (&quot;ghost node&quot;) to construct the second derivative and, in some cases, the first derivative <em>at</em> the boundary. By default, this package assumes that the value outside the grid is the same as the value <em>at</em> the boundary. I go through several cases for lower boundaries (upper boundaries are similar):</p><ol><li>First Case: <em>at the lower boundary of the grid, the state variable has a positive drift and positive volatility.</em></li></ol><pre><code class="language-none">This happens in models where the state space is unbounded (see Habit, Long Run Risk, and Disaster models). Because the PDE needs to be solved on a grid, one needs to impose reflecting boundaries, i.e. that the first derivative of the value function is null at the border. In term of finite difference scheme, this means that the value of the function outside the grid is equal to the value *at* the boundary. This is the default boundary condition used by `pdesolve`</code></pre><ol><li>Second Case: <em>at the lower boundary of the grid, the state variable has a positive drift and zero volatility.</em></li></ol><pre><code class="language-none">This happens in heterogeneous agent models such as GarleanuPanageas and DiTella models. In this case, the second derivative does not appear in the PDE at the boundary. Because of upwinding, the first derivative does not use the value of the function outside the grid either. Therefore, there is no need to specify the value of the function outside the grid.</code></pre><ol><li>Third case: <em>at the lower boundary of the grid, the state variable has a negative drift and zero volatility.</em></li></ol><pre><code class="language-none">This happens in consumption / saving models with borrowing constraint. Typically, the agent would like to consume but there is an exogeneous constraint on how low his wealth can be. In this case, specify the value of the first derivative to be such that the agent chooses to stay in the state space when the drift of the state variable initially makes it go outside the boundary. See WangWangYang model or AchdouHanLasryLionsMoll in the example folder.</code></pre><ol><li>Sometime, the boundary condition does not fall into one of these cases. When this happens, specify particular values for the derivative at the boundaries using the <code>bc</code> option (see BoltonChenWang model in the example folder).</li></ol><h1><a class="nav-anchor" id="Time-Iteration-1" href="#Time-Iteration-1">Time Iteration</a></h1><p>In some cases, one may want to save the iteration over time rather than the stationary solution. In this case, use <code>pdesolve(f, state, y0, ts)</code>  where <code>ts</code> is a vector of time and <code>y_0</code> is the solution at time <code>ts[1]</code>. See <a href="https://github.com/matthieugomez/EconPDEs.jl/tree/master/examples/Asset Pricing/ArbitrageHoldingCosts">ArbitrageHoldingCosts</a> for an example.</p><h1><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h1><p>To install the package</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;EconPDEs&quot;)</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
