<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· ParserCombinator.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParserCombinator.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Install-1">Install</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li><li><a class="toctext" href="#Parsers-1">Parsers</a></li><li><a class="toctext" href="#Design-1">Design</a></li><li><a class="toctext" href="#Releases-1">Releases</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/andrewcooke/ParserCombinator.jl"><img src="https://travis-ci.org/andrewcooke/ParserCombinator.jl.png" alt="Build Status"/></a> <a href="https://coveralls.io/r/andrewcooke/ParserCombinator.jl"><img src="https://coveralls.io/repos/andrewcooke/ParserCombinator.jl/badge.svg" alt="Coverage Status"/></a></p><p><a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.3"><img src="http://pkg.julialang.org/badges/ParserCombinator_0.3.svg" alt="ParserCombinator"/></a> <a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.4"><img src="http://pkg.julialang.org/badges/ParserCombinator_0.4.svg" alt="ParserCombinator"/></a> <a href="http://pkg.julialang.org/?pkg=ParserCombinator&amp;ver=0.5"><img src="http://pkg.julialang.org/badges/ParserCombinator_0.5.svg" alt="ParserCombinator"/></a></p><h1><a class="nav-anchor" id="ParserCombinator-1" href="#ParserCombinator-1">ParserCombinator</a></h1><ul><li><a href="#example">Example</a></li><li><a href="#install">Install</a></li><li><a href="#manual">Manual</a></li><li><a href="#parsers">Parsers</a></li><li><a href="#design">Design</a></li><li><a href="#releases">Releases</a></li></ul><p>A parser combinator library for Julia, similar to those in other languages, like Haskell&#39;s Parsec or Python&#39;s pyparsing.  It can parse any iterable type (not just strings) (except for regexp matchers, of course).</p><p>ParserCombinator&#39;s main advantage is its flexible <a href="#design">design</a>, which separates the matchers from the evaluation strategy.  This makes it <a href="#evaluation">easy</a> to &quot;plug in&quot; memoization, or debug traces, or to restrict backtracking in a similar way to Parsec - all while using the same grammar.</p><p>It also contains pre-built parsers for <a href="#graph-modelling-language">Graph Modelling Language</a> and <a href="#dot">DOT</a>.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><pre><code class="language-julia">using ParserCombinator


# the AST nodes we will construct, with evaluation via calc()

abstract Node
==(n1::Node, n2::Node) = n1.val == n2.val
calc(n::Float64) = n
type Inv&lt;:Node val end
calc(i::Inv) = 1.0/calc(i.val)
type Prd&lt;:Node val end
calc(p::Prd) = Base.prod(map(calc, p.val))
type Neg&lt;:Node val end
calc(n::Neg) = -calc(n.val)
type Sum&lt;:Node val end
calc(s::Sum) = Base.sum(map(calc, s.val))


# the grammar (the combinators!)

sum = Delayed()
val = E&quot;(&quot; + sum + E&quot;)&quot; | PFloat64()

neg = Delayed()       # allow multiple (or no) negations (eg ---3)
neg.matcher = val | (E&quot;-&quot; + neg &gt; Neg)

mul = E&quot;*&quot; + neg
div = E&quot;/&quot; + neg &gt; Inv
prd = neg + (mul | div)[0:end] |&gt; Prd

add = E&quot;+&quot; + prd
sub = E&quot;-&quot; + prd &gt; Neg
sum.matcher = prd + (add | sub)[0:end] |&gt; Sum

all = sum + Eos()


# and test 

# this prints 2.5
calc(parse_one(&quot;1+2*3/4&quot;, all)[1])

# this prints [Sum([Prd([1.0]),Prd([2.0])])]
parse_one(&quot;1+2&quot;, all)</code></pre><p>Some explanation of the above:</p><ul><li><p>I used rather a lot of &quot;syntactic sugar&quot;.  You can use a more verbose, &quot;parser combinator&quot; style if you prefer.  For example, <code>Seq(...)</code> instead of <code>+</code>, or <code>App(...)</code> instead of <code>&gt;</code>.</p></li><li><p>The matcher <code>E&quot;xyz&quot;</code> matches and then discards the string <code>&quot;xyz&quot;</code>.</p></li><li><p>Every matcher returns a list of matched values.  This can be an empty list if the match succeeded but matched nothing.</p></li><li><p>The operator <code>+</code> matches the expressions to either side and appends the resulting lists.  Similarly, <code>|</code> matches one of two alternatives.</p></li><li><p>The operator <code>|&gt;</code> calls the function to the right, passing in the results from the matchers on the left.</p></li><li><p><code>&gt;</code> is similar to <code>|&gt;</code> but interpolates the arguments (ie uses <code>...</code>).  So instead of passing a list of values, it calls the function with multiple arguments.</p></li><li><p><code>Delayed()</code> lets you define a loop in the grammar.</p></li><li><p>The syntax <code>[0:end]</code> is a greedy repeat of the matcher to the left.  An alternative would be <code>Star(...)</code>, while <code>[3:4]</code> would match only 3 or 4 values.</p></li></ul><p>And it supports packrat parsing too (more exactly, it can memoize results to avoid repeating matches).</p><p>Still, for large parsing tasks (eg parsing source code for a compiler) it would probably be better to use a wrapper around an external parser generator, like Anltr.</p><p><strong>Note:</strong> There&#39;s an <a href="https://github.com/JuliaLang/Compat.jl/issues/94">issue</a>   with the Compat library which means the code above (the assignment to   <code>Delayed.matcher</code>) doesn&#39;t work with 0.3.  See <a href="test/calc.jl">calc.jl</a> for   the uglier, hopefully temporary, 0.3 version.</p><h2><a class="nav-anchor" id="Install-1" href="#Install-1">Install</a></h2><pre><code class="language-julia">julia&gt; Pkg.add(&quot;ParserCombinator&quot;)</code></pre><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><ul><li><a href="#evaluation">Evaluation</a></li><li><a href="#basic-matchers">Basic Matchers</a><ul><li><a href="#equality">Equality</a></li><li><a href="#sequences">Sequences</a></li><li><a href="#empty-values">Empty Values</a></li><li><a href="#alternates">Alternates</a></li><li><a href="#regular-expressions">Regular Expressions</a></li><li><a href="#repetition">Repetition</a></li><li><a href="#full-match">Full Match</a></li><li><a href="#transforms">Transforms</a></li><li><a href="#lookahead-and-negation">Lookahead And Negation</a></li></ul></li><li><a href="#other">Other</a><ul><li><a href="#backtracking">Backtracking</a></li><li><a href="#controlling-memory-use">Controlling Memory Use</a></li><li><a href="#spaces---pre-and-post-fixes">Spaces - Pre And Post-Fixes</a></li><li><a href="#locating-errors">Locating Errors</a></li><li><a href="#coding-style">Coding Style</a></li><li><a href="#adding-matchers">Adding Matchers</a></li><li><a href="#debugging">Debugging</a></li><li><a href="#more-information">More Information</a></li></ul></li></ul><h3><a class="nav-anchor" id="Evaluation-1" href="#Evaluation-1">Evaluation</a></h3><p>Once you have a grammar (see <a href="#basic-matchers">below</a>) you can evaluate it against some input in various ways:</p><ul><li><p><code>parse_one()</code> - a simple, recursive decent parser with backtracking, but no memoization.  Returns a single result or throws a <code>ParserException</code>.</p></li><li><p><code>parse_all()</code> - a packrat parser, with memoization, that returns an iterator (evaluated lazily) over all possible parses of the input.</p></li><li><p><code>parse_lines()</code> - a parser in which the source is parsed line by line.  Pre-4.0.0 Julia copies strings that are passed to regex, so this reduces memory use when using regular expressions.</p></li><li><p><code>parse_try()</code> - similar to Haskell&#39;s Parsec, with backtracking only inside the <code>Try()</code> matcher.  More info <a href="#controlling-memory-use">here</a>.</p></li><li><p><code>parse_dbg()</code> - as <code>parse_one()</code>, but also prints a trace of evaluation for all of the matchers that are children of a <code>Trace()</code> matchers.  Can also be used with other matchers via the keword <code>delegate</code>; for example <code>parse_dbg(...; delegate=Cache)</code> will provide tracing of the packrat parser (<code>parse_all()</code> above).  More info <a href="#debugging">here</a>.</p></li></ul><p>These are all implemented by providing different <code>Config</code> subtypes. For more information see <a href="#design">Design</a>, <a href="src/core/types.jl">types.jl</a> and <a href="src/core/parsers.jl">parsers.jl</a>.</p><h3><a class="nav-anchor" id="Basic-Matchers-1" href="#Basic-Matchers-1">Basic Matchers</a></h3><p>In what follows, remember that the power of parser combinators comes from how you combine these.  They can all be nested, refer to each other, etc etc.</p><h4><a class="nav-anchor" id="Equality-1" href="#Equality-1">Equality</a></h4><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Equal(&quot;ab&quot;))
1-element Array{Any,1}:
 &quot;ab&quot;

julia&gt; parse_one(&quot;abc&quot;, Equal(&quot;abx&quot;))
ERROR: ParserCombinator.ParserException(&quot;cannot parse&quot;)</code></pre><p>This is so common that there&#39;s a corresponding <a href="http://julia.readthedocs.org/en/latest/manual/strings/#non-standard-string-literals">string literal</a> (it&#39;s &quot;e&quot; for `Equal(), the corresponding matcher).</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, e&quot;ab&quot;)
1-element Array{Any,1}:
 &quot;ab&quot;</code></pre><h4><a class="nav-anchor" id="Sequences-1" href="#Sequences-1">Sequences</a></h4><p>Matchers return lists of values.  Multiple matchers can return lists of lists, or the results can be &quot;flattened&quot; a level (usually more useful):</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Series(Equal(&quot;a&quot;), Equal(&quot;b&quot;)))
2-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, Series(Equal(&quot;a&quot;), Equal(&quot;b&quot;); flatten=false))
2-element Array{Any,1}:
 Any[&quot;a&quot;]
 Any[&quot;b&quot;]

julia&gt; parse_one(&quot;abc&quot;, Seq(Equal(&quot;a&quot;), Equal(&quot;b&quot;)))
2-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, And(Equal(&quot;a&quot;), Equal(&quot;b&quot;)))
2-element Array{Any,1}:
 Any[&quot;a&quot;]
 Any[&quot;b&quot;]

julia&gt; parse_one(&quot;abc&quot;, e&quot;a&quot; + e&quot;b&quot;)
2-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, e&quot;a&quot; &amp; e&quot;b&quot;)
2-element Array{Any,1}:
 Any[&quot;a&quot;]
 Any[&quot;b&quot;]</code></pre><p>Where <code>Series()</code> is implemented as <code>Seq()</code> or <code>And()</code>, depending on the value of <code>flatten</code> (default <code>true</code>).</p><p><strong>Warning</strong> - The sugared syntax has to follow standard operator precedence,   where <code>|</code> binds <em>more tightly</em> that <code>+</code>.  This means that</p><pre><code class="language-julia">   matcher1 + matcher2 | matcher3</code></pre><p>is <em>almost always an error</em> because it means:</p><pre><code class="language-julia">   matcher1 + (matcher2 | matcher3)</code></pre><p>while what was intended was:</p><pre><code class="language-julia">   (matcher1 + matcher2) | matcher3</code></pre><h4><a class="nav-anchor" id="Empty-Values-1" href="#Empty-Values-1">Empty Values</a></h4><p>Often, you want to match something but then discard it.  An empty (or discarded) value is an empty list.  This may help explain why I said flattening lists was useful above.</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, And(Drop(Equal(&quot;a&quot;)), Equal(&quot;b&quot;)))
2-element Array{Any,1}:
 Any[]   
 Any[&quot;b&quot;]

julia&gt; parse_one(&quot;abc&quot;, Seq(Drop(Equal(&quot;a&quot;)), Equal(&quot;b&quot;)))
1-element Array{Any,1}:
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, ~e&quot;a&quot; + e&quot;b&quot;)
1-element Array{Any,1}:
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, E&quot;a&quot; + e&quot;b&quot;)
1-element Array{Any,1}:
 &quot;b&quot;</code></pre><p>Note the <code>~</code> (tilde / home directory) and capital <code>E</code> in the last two examples, respectively.</p><h4><a class="nav-anchor" id="Alternates-1" href="#Alternates-1">Alternates</a></h4><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Alt(e&quot;x&quot;, e&quot;a&quot;))
1-element Array{Any,1}:
 &quot;a&quot;

julia&gt; parse_one(&quot;abc&quot;, e&quot;x&quot; | e&quot;a&quot;)
1-element Array{Any,1}:
 &quot;a&quot;</code></pre><p><strong>Warning</strong> - The sugared syntax has to follow standard operator precedence,   where <code>|</code> binds <em>more tightly</em> that <code>+</code>.  This means that</p><pre><code class="language-julia">   matcher1 + matcher2 | matcher3</code></pre><p>is <em>almost always an error</em> because it means:</p><pre><code class="language-julia">   matcher1 + (matcher2 | matcher3)</code></pre><p>while what was intended was:</p><pre><code class="language-julia">   (matcher1 + matcher2) | matcher3</code></pre><h4><a class="nav-anchor" id="Regular-Expressions-1" href="#Regular-Expressions-1">Regular Expressions</a></h4><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Pattern(r&quot;.b.&quot;))
1-element Array{Any,1}:
 &quot;abc&quot;

julia&gt; parse_one(&quot;abc&quot;, p&quot;.b.&quot;)
1-element Array{Any,1}:
 &quot;abc&quot;

julia&gt; parse_one(&quot;abc&quot;, P&quot;.&quot; + p&quot;b.&quot;)
1-element Array{Any,1}:
 &quot;bc&quot;</code></pre><p>As with equality, a capital prefix to the string literal (&quot;p&quot; for &quot;pattern&quot; by the way) implies that the value is dropped.</p><p>Note that regular expresions do not backtrack.  A typical, greedy, regular expression will match as much of the input as possible, every time that it is used.  Backtracking only exists within the library matchers (which can duplicate regular expression functionality, when needed).</p><h4><a class="nav-anchor" id="Repetition-1" href="#Repetition-1">Repetition</a></h4><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Repeat(p&quot;.&quot;))
3-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;

julia&gt; parse_one(&quot;abc&quot;, Repeat(p&quot;.&quot;, 2))
2-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;

julia&gt; collect(parse_all(&quot;abc&quot;, Repeat(p&quot;.&quot;, 2, 3)))
2-element Array{Any,1}:
 Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
 Any[&quot;a&quot;,&quot;b&quot;]    

julia&gt; parse_one(&quot;abc&quot;, Repeat(p&quot;.&quot;, 2; flatten=false))
2-element Array{Any,1}:
 Any[&quot;a&quot;]
 Any[&quot;b&quot;]

julia&gt; collect(parse_all(&quot;abc&quot;, Repeat(p&quot;.&quot;, 0, 3)))
4-element Array{Any,1}:
 Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
 Any[&quot;a&quot;,&quot;b&quot;]    
 Any[&quot;a&quot;]        
 Any[]           

julia&gt; collect(parse_all(&quot;abc&quot;, Repeat(p&quot;.&quot;, 0, 3; greedy=false)))
4-element Array{Any,1}:
 Any[]           
 Any[&quot;a&quot;]        
 Any[&quot;a&quot;,&quot;b&quot;]    
 Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p>You can also use <code>Depth()</code> and <code>Breadth()</code> for greedy and non-greedy repeats directly (but <code>Repeat()</code> is more readable, I think).</p><p>The sugared version looks like this:</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, p&quot;.&quot;[1:2])
2-element Array{Any,1}:
 &quot;a&quot;
 &quot;b&quot;

julia&gt; parse_one(&quot;abc&quot;, p&quot;.&quot;[1:2,:?])
1-element Array{Any,1}:
 &quot;a&quot;

julia&gt; parse_one(&quot;abc&quot;, p&quot;.&quot;[1:2,:&amp;])
2-element Array{Any,1}:
 Any[&quot;a&quot;]
 Any[&quot;b&quot;]

julia&gt; parse_one(&quot;abc&quot;, p&quot;.&quot;[1:2,:&amp;,:?])
1-element Array{Any,1}:
 Any[&quot;a&quot;]</code></pre><p>Where the <code>:?</code> symbol is equivalent to <code>greedy=false</code> and <code>:&amp;</code> to <code>flatten=false</code> (compare with <code>+</code> and <code>&amp;</code> above).</p><p>There are also some well-known special cases:</p><pre><code class="language-julia">julia&gt; collect(parse_all(&quot;abc&quot;, Plus(p&quot;.&quot;)))
3-element Array{Any,1}:
 Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
 Any[&quot;a&quot;,&quot;b&quot;]    
 Any[&quot;a&quot;]        

julia&gt; collect(parse_all(&quot;abc&quot;, Star(p&quot;.&quot;)))
4-element Array{Any,1}:
 Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
 Any[&quot;a&quot;,&quot;b&quot;]    
 Any[&quot;a&quot;]        
 Any[]           </code></pre><h4><a class="nav-anchor" id="Full-Match-1" href="#Full-Match-1">Full Match</a></h4><p>To ensure that all the input is matched, add <code>Eos()</code> to the end of the grammar.</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, Equal(&quot;abc&quot;) + Eos())
1-element Array{Any,1}:
 &quot;abc&quot;

julia&gt; parse_one(&quot;abc&quot;, Equal(&quot;ab&quot;) + Eos())
ERROR: ParserCombinator.ParserException(&quot;cannot parse&quot;)</code></pre><h4><a class="nav-anchor" id="Transforms-1" href="#Transforms-1">Transforms</a></h4><p>Use <code>App()</code> or <code>&gt;</code> to pass the current results to a function (or datatype constructor) as individual values.</p><pre><code class="language-julia">julia&gt; parse_one(&quot;abc&quot;, App(Star(p&quot;.&quot;), tuple))
1-element Array{Any,1}:
 (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)

julia&gt; parse_one(&quot;abc&quot;, Star(p&quot;.&quot;) &gt; string)
1-element Array{Any,1}:
 &quot;abc&quot;</code></pre><p>The action of <code>Appl()</code> and <code>|&gt;</code> is similar, but everything is passed as a single argument (a list).</p><pre><code class="language-julia">julia&gt; type Node children end

julia&gt; parse_one(&quot;abc&quot;, Appl(Star(p&quot;.&quot;), Node))
1-element Array{Any,1}:
 Node(Any[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])

julia&gt; parse_one(&quot;abc&quot;, Star(p&quot;.&quot;) |&gt; x -&gt; map(uppercase, x))
3-element Array{Any,1}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;</code></pre><h4><a class="nav-anchor" id="Lookahead-And-Negation-1" href="#Lookahead-And-Negation-1">Lookahead And Negation</a></h4><p>Sometimes you can&#39;t write a clean grammar that just consumes data: you need to check ahead to avoid something.  Or you need to check ahead to make sure something works a certain way.</p><pre><code class="language-julia">julia&gt; parse_one(&quot;12c&quot;, Lookahead(p&quot;\d&quot;) + PInt() + Dot())
2-element Array{Any,1}:
 12   
   &#39;c&#39;

julia&gt; parse_one(&quot;12c&quot;, Not(Lookahead(p&quot;[a-z]&quot;)) + PInt() + Dot())
2-element Array{Any,1}:
 12   
   &#39;c&#39;</code></pre><p>More generally, <code>Not()</code> replaces any match with failure, and failure with an empty match (ie the empty list).</p><h3><a class="nav-anchor" id="Other-1" href="#Other-1">Other</a></h3><h4><a class="nav-anchor" id="Backtracking-1" href="#Backtracking-1">Backtracking</a></h4><p>By default, matchers will backtrack as necessary.</p><p>In some (unusual) cases, it is useful to disable backtracking.  For example, see PCRE&#39;s &quot;possessive&quot; matching.  This can be done here on a case-by-case basis by adding <code>backtrack=false</code> to <code>Repeat()</code>, <code>Alternatives()</code> and <code>Series()</code>, or by appending <code>!</code> to the matchers that those functions generate: <code>Depth!</code>, <code>Breadth!</code>, <code>Alt!</code>, <code>Seq!</code> and <code>And!</code>.</p><p>For example,</p><pre><code class="language-julia">collect(parse_all(&quot;123abc&quot;, Seq!(p&quot;\d&quot;[0:end], p&quot;[a-z]&quot;[0:end])))</code></pre><p>will give just a single match, because <code>Seq!</code> (with trailing <code>!</code>) does not backtrack the <code>Repeat()</code> child matchers.</p><p>However, since regular expressions do not backtrack, it would have been simpler, and faster, to write the above as</p><pre><code class="language-julia">collect(parse_all(&quot;123abc&quot;, p&quot;\d+[a-z]+&quot;))</code></pre><p>Using <code>backtrack=false</code> only disables backtracking of the direct children of those matchers.  To disable <em>all</em> backtracking, then the change must be made to <em>all</em> matchers in the grammar.  For example, in theory, the following two grammars have different backtracking behaviour:</p><pre><code class="language-julia">Series(Repeat(e&quot;a&quot;, 0, 3), e&quot;b&quot;; backtrack=false)
Series(Repeat(e&quot;a&quot;, 0, 3; backtrack=false), e&quot;b&quot;; backtrack=false)</code></pre><p>(although, in practice, they are identical, in this contrived example, because <code>e&quot;a&quot;</code> doesn&#39;t backtrack anyway).</p><p>This makes a grammar more efficient, but also more specific.  It can reduce the memory consumed by the parser, but does not guarantee that resources will be released - see the next section for a better approach to reducing memory use.</p><h4><a class="nav-anchor" id="Controlling-Memory-Use-1" href="#Controlling-Memory-Use-1">Controlling Memory Use</a></h4><p>Haskell&#39;s Parsec, if I understand correctly, does not backtrack by default.  More exactly, it does not allow input that has been consumed (matched) to be read again.  This reduces memory consumption (at least when parsing files, since read data can be discarded), but only accepts LL(1) grammars.</p><p>To allow parsing of a wider range of grammars, Parsec then introduces the <code>Try</code> combinator, which enables backtracking in some (generally small) portion of the grammar.</p><p>The same approach can be used with this library, using <code>parse_try</code>.</p><pre><code class="language-none">file1.txt:
abcdefghijklmnopqrstuvwxyz
0123456789</code></pre><pre><code class="language-julia">open(&quot;test1.txt&quot;, &quot;r&quot;) do io
    # this throws an execption because it requires backtracking
    parse_try(io, p&quot;[a-z]&quot;[0:end] + e&quot;m&quot; &gt; string)
end

open(&quot;test1.txt&quot;, &quot;r&quot;) do io
    # this (with Try(...)) works fine
    parse_try(io, Try(p&quot;[a-z]&quot;[0:end] + e&quot;m&quot; &gt; string))
end</code></pre><p>Without backtracking, error messages using the <code>Error()</code> matcher are much more useful (this is why Parsec can provide good error messages):</p><pre><code class="language-julia">julia&gt; try
         parse_try(&quot;?&quot;, Alt!(p&quot;[a-z]&quot;, p&quot;\d&quot;, Error(&quot;not letter or number&quot;)))
       catch x
         println(x.msg)
       end
not letter or number at (1,1)
?
^</code></pre><p>where the <code>(1,1)</code> is line number and column - so this failed on the first character of the first line.</p><p>Finally, note that this is implemented at the source level, by restricting what text is visible to the matchers.  Matchers that <em>could</em> backtrack will still make the attempt.  So you should also <a href="#backtracking">disable backtracking in the  matchers</a>, where you do not need it, for an efficient grammar.</p><h4><a class="nav-anchor" id="Spaces-Pre-And-Post-Fixes-1" href="#Spaces-Pre-And-Post-Fixes-1">Spaces - Pre And Post-Fixes</a></h4><p>The lack of a lexer can complicate the handling of whitespace when using parser combinators.  This library includes the ability to add arbitrary matchers before or after named matchers in the grammar - something that can be useful for matching and discarding whitespace.</p><p>For example,</p><pre><code class="language-julia">spc = Drop(Star(Space()))

@with_pre spc begin

    sum = Delayed()
    val = E&quot;(&quot; + spc + sum + spc + E&quot;)&quot; | PFloat64()

    neg = Delayed()             # allow multiple negations (eg ---3)
    neg.matcher = Nullable{Matcher}(val | (E&quot;-&quot; + neg &gt; Neg))

    mul = E&quot;*&quot; + neg
    div = E&quot;/&quot; + neg &gt; Inv
    prd = neg + (mul | div)[0:end] |&gt; Prd

    add = E&quot;+&quot; + prd
    sub = E&quot;-&quot; + prd &gt; Neg
    sum.matcher = Nullable{Matcher}(prd + (add | sub)[0:end] |&gt; Sum)

    all = sum + spc + Eos()

end</code></pre><p>extends the parser given earlier to discard whitespace between numbers and symbols.  The automatc addition of <code>spc</code> as a prefix to named matchers (those assigned to a variable: <code>sum</code>, <code>val</code>, <code>neg</code>, etc) means that it only needs to be added explicitly in a few places.</p><h4><a class="nav-anchor" id="Locating-Errors-1" href="#Locating-Errors-1">Locating Errors</a></h4><p>Sometimes it is useful to report to the user where the input text is &quot;wrong&quot;.  For a recursive descent parser one useful indicator is the maximum depth reached in the source.</p><p>This can be retrieved using the <code>Debug</code> config.  Here is a simple example that delegates to <code>NoCache</code> (the default confg for <code>parse_one()</code>):</p><pre><code class="language-julia">grammar = p&quot;\d+&quot; + Eos()
source = &quot;123abc&quot;
             # make the parser task
debug, task = make(Debug, source, grammar; delegate=NoCache)
once(task)   # this does the parsing and throws an exception
             # the debug config now contains max_iter
println(source[debug.max_iter:end])   # show the error location &quot;abc&quot;</code></pre><p>This is a little complex because I don&#39;t pre-define a function for this case (cf <code>parse_one()</code>).  Please email me if you think I should (currently it&#39;s unclear what features to support directly, and what to leave for &quot;advanced&quot; users).</p><p>For more information see <a href="src/core/parsers.jl">parsers.jl</a> and <a href="src/core/debug.jl">debug.jl</a>.</p><p>An alternative approach to error messages is to use <code>parse_try()</code> with the <code>Error()</code> matcher - see <a href="#controlling-memory-use">here</a>.</p><h4><a class="nav-anchor" id="Coding-Style-1" href="#Coding-Style-1">Coding Style</a></h4><p>Don&#39;t go reinventing regexps.  The built-in regexp engine is way, way more efficient than this library could ever be.  So call out to regexps liberally. The <code>p&quot;...&quot;</code> syntax makes it easy.</p><p>But don&#39;t use regular expressions if you need to backtrack what is being matched.</p><p>Drop stuff you don&#39;t need.</p><p>Transform things into containers so that your result has nice types.  Look at how the <a href="#example">example</a> works.</p><p>Understand the format you are parsing.  What motivated the person who designed the format?  Compare the <a href="src/gml/GML.jl">GML</a> and <a href="src/dot/DOT.jl">DOT</a> parsers - they return different results because the format authors cared about different things.  GML is an elegant, general data format, while DOT is a sequential description - a program, almost - that encodes graph layouts.</p><h4><a class="nav-anchor" id="Adding-Matchers-1" href="#Adding-Matchers-1">Adding Matchers</a></h4><p>First, are you sure you need to add a matcher?  You can do a <em>lot</em> with <a href="#transforms">transforms</a>.</p><p>If you do, here are some places to get started:</p><ul><li><p><code>Equal()</code> in <a href="src/core/matchers.jl">matchers.jl</a> is a great example for something that does a simple, single thing, and returns success or failure.</p></li><li><p>Most matchers that call to a sub-matcher can be implemented as transforms. But if you insist, there&#39;s an example in <a href="test/case.jl">case.jl</a>.</p></li><li><p>If you want to write complex, stateful matchers then I&#39;m afraid you&#39;re going to have to learn from the code for <code>Repeat()</code> and <code>Series()</code>.  Enjoy!</p></li></ul><h4><a class="nav-anchor" id="Debugging-1" href="#Debugging-1">Debugging</a></h4><p>Debugging a grammar can be a frustrating experience - there are times when it really helps to have a simple view &quot;inside&quot; what is happening.  This is supported by <code>parse_dbg</code> which will print a record of all messages (execute and response - see <a href="#design">design</a>) for matchers inside a <code>Trace()</code> matcher.</p><p>In addition, if the grammar is defined inside a <code>@with_names</code> macro, the symbols used to identify various parts of the grammar (the variable names) are displayed when appropriate.</p><p>Here&#39;s a full example (you can view less by applying <code>Trace()</code> to only the matchers you care about):</p><pre><code class="language-julia">@with_names begin

    sum = Delayed()
    val = E&quot;(&quot; + sum + E&quot;)&quot; | PFloat64()

    neg = Delayed()             # allow multiple negations (eg ---3)
    neg.matcher = val | (E&quot;-&quot; + neg &gt; Neg)
    
    mul = E&quot;*&quot; + neg
    div = E&quot;/&quot; + neg &gt; Inv
    prd = neg + (mul | div)[0:end] |&gt; Prd
    
    add = E&quot;+&quot; + prd
    sub = E&quot;-&quot; + prd &gt; Neg
    sum.matcher = prd + (add | sub)[0:end] |&gt; Sum
    
    all = sum + Eos()
end

parse_dbg(&quot;1+2*3/4&quot;, Trace(all))</code></pre><p>which gives:</p><pre><code class="language-none">  1:1+2*3/4    00 Trace-&gt;all
  1:1+2*3/4    01  all-&gt;sum
  1:1+2*3/4    02   Transform-&gt;Seq
  1:1+2*3/4    03    Seq-&gt;prd
  1:1+2*3/4    04     prd-&gt;Seq
  1:1+2*3/4    05      Seq-&gt;neg
  1:1+2*3/4    06       Alt-&gt;Seq
  1:1+2*3/4    07        Seq-&gt;Drop
  1:1+2*3/4    08         Drop-&gt;Equal
   :           08         Drop&lt;-!!!
   :           07        Seq&lt;-!!!
   :           06       Alt&lt;-!!!
  1:1+2*3/4    06       Alt-&gt;Transform
  1:1+2*3/4    07        Transform-&gt;Pattern
  2:+2*3/4     07        Transform&lt;-{&quot;1&quot;}
  2:+2*3/4     06       Alt&lt;-{1.0}
  2:+2*3/4     05      Seq&lt;-{1.0}
  2:+2*3/4     05      Seq-&gt;Depth
  2:+2*3/4     06       Depth-&gt;Alt
  2:+2*3/4     07        Alt-&gt;mul
  2:+2*3/4     08         mul-&gt;Drop
  2:+2*3/4     09          Drop-&gt;Equal
   :           09          Drop&lt;-!!!
   :           08         mul&lt;-!!!
   :           07        Alt&lt;-!!!
  2:+2*3/4     07        Alt-&gt;div
  2:+2*3/4     08         div-&gt;Seq
  2:+2*3/4     09          Seq-&gt;Drop
  2:+2*3/4     10 Drop-&gt;Equal
   :           10 Drop&lt;-!!!
   :           09          Seq&lt;-!!!
   :           08         div&lt;-!!!
   :           07        Alt&lt;-!!!
   :           06       Depth&lt;-!!!
  2:+2*3/4     05      Seq&lt;-{}
  2:+2*3/4     04     prd&lt;-{1.0}
  2:+2*3/4     03    Seq&lt;-{Prd({1.0})}
  2:+2*3/4     03    Seq-&gt;Depth
  2:+2*3/4     04     Depth-&gt;Alt
  2:+2*3/4     05      Alt-&gt;add
  2:+2*3/4     06       add-&gt;Drop
  2:+2*3/4     07        Drop-&gt;Equal
  3:2*3/4      07        Drop&lt;-{&quot;+&quot;}
  3:2*3/4      06       add&lt;-{}
  3:2*3/4      06       add-&gt;prd
  3:2*3/4      07        prd-&gt;Seq
  3:2*3/4      08         Seq-&gt;neg
  3:2*3/4      09          Alt-&gt;Seq
  3:2*3/4      10 Seq-&gt;Drop
  3:2*3/4      11  Drop-&gt;Equal
   :           11  Drop&lt;-!!!
   :           10 Seq&lt;-!!!
   :           09          Alt&lt;-!!!
  3:2*3/4      09          Alt-&gt;Transform
  3:2*3/4      10 Transform-&gt;Pattern
  4:*3/4       10 Transform&lt;-{&quot;2&quot;}
  4:*3/4       09          Alt&lt;-{2.0}
  4:*3/4       08         Seq&lt;-{2.0}
  4:*3/4       08         Seq-&gt;Depth
  4:*3/4       09          Depth-&gt;Alt
  4:*3/4       10 Alt-&gt;mul
  4:*3/4       11  mul-&gt;Drop
  4:*3/4       12   Drop-&gt;Equal
  5:3/4        12   Drop&lt;-{&quot;*&quot;}
  5:3/4        11  mul&lt;-{}
  5:3/4        11  mul-&gt;neg
  5:3/4        12   Alt-&gt;Seq
  5:3/4        13    Seq-&gt;Drop
  5:3/4        14     Drop-&gt;Equal
   :           14     Drop&lt;-!!!
   :           13    Seq&lt;-!!!
   :           12   Alt&lt;-!!!
  5:3/4        12   Alt-&gt;Transform
  5:3/4        13    Transform-&gt;Pattern
  6:/4         13    Transform&lt;-{&quot;3&quot;}
  6:/4         12   Alt&lt;-{3.0}
  6:/4         11  mul&lt;-{3.0}
  6:/4         10 Alt&lt;-{3.0}
  6:/4         09          Depth&lt;-{3.0}
  6:/4         09          Depth-&gt;Alt
  6:/4         10 Alt-&gt;mul
  6:/4         11  mul-&gt;Drop
  6:/4         12   Drop-&gt;Equal
   :           12   Drop&lt;-!!!
   :           11  mul&lt;-!!!
   :           10 Alt&lt;-!!!
  6:/4         10 Alt-&gt;div
  6:/4         11  div-&gt;Seq
  6:/4         12   Seq-&gt;Drop
  6:/4         13    Drop-&gt;Equal
  7:4          13    Drop&lt;-{&quot;/&quot;}
  7:4          12   Seq&lt;-{}
  7:4          12   Seq-&gt;neg
  7:4          13    Alt-&gt;Seq
  7:4          14     Seq-&gt;Drop
  7:4          15      Drop-&gt;Equal
   :           15      Drop&lt;-!!!
   :           14     Seq&lt;-!!!
   :           13    Alt&lt;-!!!
  7:4          13    Alt-&gt;Transform
  7:4          14     Transform-&gt;Pattern
  8:           14     Transform&lt;-{&quot;4&quot;}
  8:           13    Alt&lt;-{4.0}
  8:           12   Seq&lt;-{4.0}
  8:           11  div&lt;-{4.0}
  8:           10 Alt&lt;-{Inv(4.0)}
  8:           09          Depth&lt;-{Inv(4.0)}
  8:           09          Depth-&gt;Alt
  8:           10 Alt-&gt;mul
  8:           11  mul-&gt;Drop
  8:           12   Drop-&gt;Equal
   :           12   Drop&lt;-!!!
   :           11  mul&lt;-!!!
   :           10 Alt&lt;-!!!
  8:           10 Alt-&gt;div
  8:           11  div-&gt;Seq
  8:           12   Seq-&gt;Drop
  8:           13    Drop-&gt;Equal
   :           13    Drop&lt;-!!!
   :           12   Seq&lt;-!!!
   :           11  div&lt;-!!!
   :           10 Alt&lt;-!!!
   :           09          Depth&lt;-!!!
  8:           08         Seq&lt;-{3.0,Inv(4.0)}
  8:           07        prd&lt;-{2.0,3.0,Inv(4.0)}
  8:           06       add&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           05      Alt&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           04     Depth&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           04     Depth-&gt;Alt
  8:           05      Alt-&gt;add
  8:           06       add-&gt;Drop
  8:           07        Drop-&gt;Equal
   :           07        Drop&lt;-!!!
   :           06       add&lt;-!!!
   :           05      Alt&lt;-!!!
  8:           05      Alt-&gt;sub
  8:           06       sub-&gt;Seq
  8:           07        Seq-&gt;Drop
  8:           08         Drop-&gt;Equal
   :           08         Drop&lt;-!!!
   :           07        Seq&lt;-!!!
   :           06       sub&lt;-!!!
   :           05      Alt&lt;-!!!
   :           04     Depth&lt;-!!!
  8:           03    Seq&lt;-{Prd({2.0,3.0,Inv(4.0)})}
  8:           02   Transform&lt;-{Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})}
  8:           01  all&lt;-{Sum({Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})})}
  8:           01  all-&gt;Eos
  8:           01  all&lt;-{}
  8:           00 Trace&lt;-{Sum({Prd({1.0}),Prd({2.0,3.0,Inv(4.0)})})}</code></pre><p>Some things to note here:</p><ul><li><p>The number on the left is the current iterator, followed by the source at the current offset.</p></li><li><p>The second column of numbers is the depth (relative to <code>Trace()</code>).  The indentation of the messages to the right reflects this, but &quot;wraps&quot; every 10 levels.</p></li><li><p>The message flow shows execute as <code>-&gt;</code> and response as <code>&lt;-</code>.  Matcher names are replaced by variable names (eg <code>sum</code>) where appropriate.</p></li><li><p>This functionality is implemented as a separate parser <code>Config</code> instance, so has no performance penalty when not used.  See <a href="src/core/debug.jl">debug.jl</a> for more details.</p></li></ul><p>Finally, printing a matcher gives a useful tree view of the grammar. Loops are elided with <code>...</code>:</p><pre><code class="language-julia">println(all)</code></pre><p>gives</p><pre><code class="language-none">all
+-[1]:sum
| `-TransSuccess
|   +-Seq
|   | +-[1]:prd
|   | | +-Seq
|   | | | +-[1]:neg
|   | | | | `-Alt
|   | | | |   +-[1]:Seq
|   | | | |   | +-[1]:Drop
|   | | | |   | | `-Equal
|   | | | |   | |   `-&quot;(&quot;
|   | | | |   | +-[2]:sum...
|   | | | |   | `-[3]:Drop
|   | | | |   |   `-Equal
|   | | | |   |     `-&quot;)&quot;
|   | | | |   +-[2]:TransSuccess
|   | | | |   | +-Pattern
|   | | | |   | | `-r&quot;-?(\d*\.?\d+|\d+\.\d*)([eE]\d+)?&quot;
|   | | | |   | `-f
|   | | | |   `-[3]:TransSuccess
|   | | | |     +-Seq
|   | | | |     | +-[1]:Drop
|   | | | |     | | `-Equal
|   | | | |     | |   `-&quot;-&quot;
|   | | | |     | `-[2]:neg...
|   | | | |     `-f
|   | | | `-[2]:Depth
|   | | |   +-Alt
|   | | |   | +-[1]:mul
|   | | |   | | +-[1]:Drop
|   | | |   | | | `-Equal
|   | | |   | | |   `-&quot;*&quot;
|   | | |   | | `-[2]:neg...
|   | | |   | `-[2]:div
|   | | |   |   +-Seq
|   | | |   |   | +-[1]:Drop
|   | | |   |   | | `-Equal
|   | | |   |   | |   `-&quot;/&quot;
|   | | |   |   | `-[2]:neg...
|   | | |   |   `-f
|   | | |   +-lo=0
|   | | |   +-hi=9223372036854775807
|   | | |   `-flatten=true
|   | | `-f
|   | `-[2]:Depth
|   |   +-Alt
|   |   | +-[1]:add
|   |   | | +-[1]:Drop
|   |   | | | `-Equal
|   |   | | |   `-&quot;+&quot;
|   |   | | `-[2]:prd...
|   |   | `-[2]:sub
|   |   |   +-Seq
|   |   |   | +-[1]:Drop
|   |   |   | | `-Equal
|   |   |   | |   `-&quot;-&quot;
|   |   |   | `-[2]:prd...
|   |   |   `-f
|   |   +-lo=0
|   |   +-hi=9223372036854775807
|   |   `-flatten=true
|   `-f
`-[2]:Eos</code></pre><p>Also, <code>parse_XXX(...., debug=true)</code> will show a strack trace from within the main parse loop (which gives more information on the source of any error).</p><h4><a class="nav-anchor" id="More-Information-1" href="#More-Information-1">More Information</a></h4><p>For more details, I&#39;m afraid your best bet is the source code:</p><ul><li><p><a href="src/core/types/jl">types.jl</a> introduces the types use throughout the code</p></li><li><p><a href="src/core/matchers.jl">matchers.jl</a> defines things like <code>Seq</code> and <code>Repeat</code></p></li><li><p><a href="src/core/sugar.jl">sugar.jl</a> adds <code>+</code>, <code>[...]</code> etc</p></li><li><p><a href="src/core/extras.jl">extras.jl</a> has parsers for Int, Float, etc</p></li><li><p><a href="src/core/parsers.jl">parsers.jl</a> has more info on creating the <code>parse_one</code> and <code>parse_all</code> functions</p></li><li><p><a href="src/core/transforms.jl">transforms.jl</a> defines how results can be manipulated</p></li><li><p><a href="test/tests.jl">tests.jl</a> has a pile of one-liner tests that might be useful</p></li><li><p><a href="test/debug.jl">debug.jl</a> shows how to enable debug mode</p></li><li><p><a href="test/case.jl">case.jl</a> has an example of a user-defined combinator</p></li></ul><h2><a class="nav-anchor" id="Parsers-1" href="#Parsers-1">Parsers</a></h2><h3><a class="nav-anchor" id="Graph-Modelling-Language-1" href="#Graph-Modelling-Language-1">Graph Modelling Language</a></h3><p>GML describes a graph using a general dict / list format (something like JSON).</p><ul><li><p><code>parse_raw</code> returns lists and tuples that directly match the GML structure.</p></li><li><p><code>parse_dict</code> places the same data in nested dicts and vectors.  The keys are symbols, so you access a file using the syntax <code>dict[:field]</code>.</p><p><code>parse_dict()</code> has two important keyword arguments: <code>lists</code> is a list of keys that should be stored as lists (default is <code>:graph, :node, :edge</code>); <code>unsafe</code> should be set to <code>true</code> if mutiple values for other keys should be discarded (default <code>false</code>).  The underlying issue is that it is not clear from the file format which keys are lists, so the user must specify them; by default an error is thrown if this information is incomplete, but <code>unsafe</code> can be set if a user doesn&#39;t care about those attributes.</p></li></ul><p>Note that the parser does not conform fully to the <a href="https://en.wikipedia.org/wiki/Graph_Modelling_Language">specifications</a>: ISO 8859-1 entities are not decoded (the parser should accept UTF 8); integers and floats are 64bit; strings can be any length; no check is made for required fields.</p><p>For example, to print node IDs and edge connections in a graph</p><pre><code class="language-julia">using ParserCombinator.Parsers.GML

my_graph = &quot;graph [
  node [id 1]
  node [id 2]
  node [id 3]
  edge [source 1 target 2]
  edge [source 2 target 3]
  edge [source 3 target 1]
]&quot;

root = parse_dict(my_graph)

for graph in root[:graph]  # there could be multiple graphs
    for node in graph[:node]
        println(&quot;node $(node[:id])&quot;)
    end
    for edge in graph[:edge]
        println(&quot;edge $(edge[:source]) - $(edge[:target])&quot;)
    end
end</code></pre><p>giving</p><pre><code class="language-none">node 1
node 2
node 3
edge 1 - 2
edge 2 - 3
edge 3 - 1</code></pre><p>For further details, please read <a href="src/gml/GML.jl">GML.jl</a>.</p><h3><a class="nav-anchor" id="DOT-1" href="#DOT-1">DOT</a></h3><p>DOT describes a graph using a complex format that resembles a program (with mutable state) more than a specification (see comments in <a href="src/dot/DOT.jl">source</a>).</p><ul><li><p><code>parse_dot</code> returns a list of structured AST (see the types in <a href="src/dot/DOT.jl">DOT.jl</a>), one per graph in the file.  It has one keyword argument, <code>debug</code>, which takes a <code>Bool</code> and enables the usual debugging output.</p></li><li><p><code>nodes(g::Graph)</code> extracts a set of node names from the structured AST.</p></li><li><p><code>edges(g::Graph)</code> extracts a set of edge names (node name pairs) from the structured AST.</p></li></ul><p>For example, to print node IDs and edge connections in a graph</p><pre><code class="language-julia">using ParserCombinator.Parsers.DOT

my_graph = &quot;graph {
  1 -- 2
  2 -- 3
  3 -- 1
}&quot;

root = parse_dot(my_graph)

for node in nodes(root)
    println(&quot;node $(node)&quot;)
end
for (node1, node2) in edges(root)
    println(&quot;edge $(node1) - $(node2)&quot;)
end</code></pre><p>giving</p><pre><code class="language-none">node 2
node 3
edge 2 - 3
edge 1 - 3
edge 1 - 2</code></pre><p>Nodes and edges are unordered (returned as a <code>Set</code>).  The graph specification is undirected (cf <code>digraph {...}</code>) and so the order of nodes in an edge is in canonical (sorted) form.</p><h2><a class="nav-anchor" id="Design-1" href="#Design-1">Design</a></h2><p>For a longer discussion of the design of ParserCombinator.jl, please see <a href="http://www.acooke.org/cute/DetailedDi0.html">this blog post</a>, also available <a href="design.txt">here</a>.</p><h3><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h3><p>Parser combinators were first written (afaik) in functional languages where tail calls do not consume stack.  Also, packrat parsers are easiest to implement in lazy languages, since shared, cached results are &quot;free&quot;.</p><p>Julia has neither tail recursion optimisation nor lazy evaluation.</p><p>On the other hand, tail call optimisation is not much use when you want to support backtracking or combine results from child parsers. And it is possible to implement combinators for repeated matches using iteration rather than recursion.</p><p>In short, life is complicated.  Different parser features have different costs and any particular implementation choice needs to be defended with detailed analysis.  Ideally we want an approach that supports features with low overhead by default, but which can be extended to accomodate more expensive features when necessary.</p><p>This library defines the grammar in a static graph, which is then &quot;interpreted&quot; using an explicit trampoline (described in more detail below).  The main advantages are:</p><ul><li><p>Describing the grammar in a static graph of types, rather than mutually recursive functions, gives better integration with Julia&#39;s method dispatch.  So, for example, we can overload operators like <code>+</code> to sequence matchers, or use macros to modify the grammar at compile time.  And the &quot;execution&quot; of the grammar is simple, using dispatch on the graph nodes.</p></li><li><p>The semantics of the parser can be modified by changing the trampoline implementation (which can also be done by method dispatch on a &quot;configuration&quot; type).  This allows, for example, the choice of whether to use memoization to be separated from the grammar itself.</p></li><li><p>State is explicitly identified and encapsulated, simplifying both backtracking (resumption from the current state) and memoization.</p></li></ul><p>The main disadvantages are:</p><ul><li><p>Defining new combinators is more complex.  The behaviour of a matcher is defined as a group of methods that correspond to transitions in a state machine.  On the other hand, with dispatch on the grammar and state nodes, the implementation remains idiomatic and compact.</p></li><li><p>Although the &quot;feel&quot; and &quot;end result&quot; of the library are similar to other parser combinator libraries (the grammar types handled are as expected, for example), one could argue that the matchers are not &quot;real&quot; combinators (what is written by the user is a graph of types, not a set of recursive functions, even if the final execution logic is equivalent).</p></li></ul><h3><a class="nav-anchor" id="Trampoline-Protocol-1" href="#Trampoline-Protocol-1">Trampoline Protocol</a></h3><p>A matcher is invoked by a call to</p><pre><code class="language-julia">execute(k::Config, m::Matcher, s::State, i) :: Message</code></pre><p>where <code>k</code> must include, at a minimum, the field <code>k.source</code> that follows the <a href="http://julia.readthedocs.org/en/latest/stdlib/collections/?highlight=iterator">iterator protocol</a> when used with <code>i</code>.  So, for example, <code>next(k.source, i)</code> returns the next value from the source, plus a new iter.</p><p>The initial call (ie the first time a given value of <code>i</code> is used, before any backtracking) will have <code>s</code> equal to <code>CLEAN</code>.</p><p>A matcher returns a <code>Message</code> which indicates to the trampoline how processing should continue:</p><ul><li><p><code>Failure</code> indicates that the match has failed and probably (depending on parent matcher and configuration) triggers backtracking.  There is a single instance of the type, <code>FAILURE</code>.</p></li><li><p><code>Success</code> indicates that the match succeeded, and so contains a result (of type <code>Value</code>, which is a type alias for <code>Any[]</code>) together with the updated iter <code>i</code> and any state that the matcher will need to look for further matchers (this can be be <code>DIRTY</code> which is globally used to indicate that all further matches will fail).</p></li><li><p><code>Execute</code> which results in a &quot;nested&quot; call to a child matcher&#39;s <code>execute</code> method (as above).</p></li></ul><p>The <code>FAILURE</code> and <code>Success</code> messages are processed by the trampoline and (typically, although a trampoline implementation may also use cached values) result in calls to</p><pre><code class="language-julia">failure(k::Config, m::Matcher, s::State) :: Message

success(k::Config, m::Matcher, s::State, t::State, i, r::Value) :: Message</code></pre><p>where the parent matcher (<code>m</code>) can do any clean-up work, resulting in a new <code>Message</code>.</p><p>Note that the child&#39;s state, <code>t</code>, is returned to the parent.  It is the responsibility of the parent to save this (in its own state) if it wants to re-call the child.</p><h3><a class="nav-anchor" id="Source-(Input-Text)-Protocol-1" href="#Source-(Input-Text)-Protocol-1">Source (Input Text) Protocol</a></h3><p>The source text is read using the <a href="http://julia.readthedocs.org/en/latest/stdlib/collections/?highlight=iterator">standard Julia iterator protocol</a>, extended with several methods defined in <a href="src/core/sources.jl">sources.jl</a>.</p><p>The use of iterators means that <code>Dot()</code> returns characters, not strings.  But in practice that matcher is rarely used (particularly since, with strings, you can use regular expressions - <code>p&quot;pattern&quot;</code> for example), and you can construct a string from multiple characters using <code>&gt; string</code>.</p><h2><a class="nav-anchor" id="Releases-1" href="#Releases-1">Releases</a></h2><p>1.7.0 - 2015-10-13 - Added DOT parser.</p><p>1.6.0 - 2015-07-26 - Changed from <code>s&quot;</code> to <code>e&quot;</code>; added support for fast regex patch.</p><p>1.5.0 - 2015-07-25 - Clarified source handling; improved <a href="issues/5">GML speed</a>.</p><p>1.4.0 - 2015-07-18 - Added GML parser; related parse_try fixes.</p><p>1.3.0 - 2015-06-27 - Added parse_try.</p><p>1.2.0 - 2015-06-28 - Trampoline side rewritten; more execution modes.</p><p>1.1.0 - 2015-06-07 - Fixed calc example; debug mode; much rewriting.</p><p>1.0.0 - ~2015-06-03 - More or less feature complete.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
