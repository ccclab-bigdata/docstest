<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · LPVSpectral.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LPVSpectral.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ADMM" href="#LPVSpectral.ADMM"><code>LPVSpectral.ADMM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ADMM(x,proxf,proxg;
iters      = 10000,   # ADMM maximum number of iterations
tol        = 1e-5,    # ADMM tolerance
printerval = 100,     # Print this often
cb(x,z)    = nothing, # Callback function
μ          = 0.05`)   # ADMM tuning parameter. If results oscillate, lower this value.</code></pre></div></div></section><pre><code class="language-none">LPVSpectral.ComplexNormal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.LPVSpectral" href="#LPVSpectral.LPVSpectral"><code>LPVSpectral.LPVSpectral</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Least-squares spectral estimation toolbox.</p><p>For help, see README.md at https://github.com/baggepinnen/LPVSpectral.jl and</p><p><a href="http://lup.lub.lu.se/record/ac32368e-e199-44ff-b76a-36668ac7d595">Fredrik Bagge Carlson, Anders Robertsson, Rolf Johansson: &quot;Linear Parameter-Varying Spectral Decomposition&quot;. In: 2017 American Control Conference 2017.</a> Available at: http://lup.lub.lu.se/record/ac32368e-e199-44ff-b76a-36668ac7d595</p><p>This module provide the functions</p><pre><code class="language-none">ls_spectral
tls_spectral
ls_windowpsd
ls_windowcsd
ls_cohere
ls_spectral_lpv
ls_sparse_spectral_lpv
ls_windowpsd_lpv
basis_activation_func</code></pre><p>and re-exports the following from DSP.jl</p><pre><code class="language-none">export periodogram, welch_pgram, Windows</code></pre><p>Periodogram types and SpectralExt type can be plotted using <code>plot(x::SpectralExt)</code></p></div></div></section><pre><code class="language-none">LPVSpectral.Periodogram</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.SpectralExt" href="#LPVSpectral.SpectralExt"><code>LPVSpectral.SpectralExt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LPV Spectral estimation result type.</p><p>See <code>ls_spectral_lpv</code> for additional help.</p><p>An object of this type can be plotted if <code>Plots.jl</code> is installed. Use regular Plots-syntax, with the additional attributes</p><pre><code class="language-none">normalization= :none / :sum / :max
normdim = :freq / :v # Only applies if normalization= :sum or :max
dims = 2 or 3 (default = 2)</code></pre><p>Fields:</p><pre><code class="language-none">Y::AbstractVector
X::AbstractVector
V::AbstractVector
w
Nv
λ
coulomb::Bool
normalize::Bool
x                   # The estimated parameters
Σ                   # Covariance of the estimated parameters</code></pre></div></div></section><pre><code class="language-none">LPVSpectral.Windows</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.Windows2" href="#LPVSpectral.Windows2"><code>LPVSpectral.Windows2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Windows2(y,t,nw,noverlap,window_func) noverlap = -1 sets the noverlap to dpw/2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.Windows3" href="#LPVSpectral.Windows3"><code>LPVSpectral.Windows3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Windows3(y,t,v,nw::Integer,noverlap::Integer,window_func::Function) noverlap = -1 sets the noverlap to dpw/2</p></div></div></section><pre><code class="language-none">LPVSpectral._K</code></pre><pre><code class="language-none">LPVSpectral._K_norm</code></pre><pre><code class="language-none">LPVSpectral._Kcoulomb</code></pre><pre><code class="language-none">LPVSpectral._Kcoulomb_norm</code></pre><pre><code class="language-none">LPVSpectral.affine_transform</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.basis_activation_func" href="#LPVSpectral.basis_activation_func"><code>LPVSpectral.basis_activation_func</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>basis<em>activation</em>func(V,Nv,normalize,coulomb)</p><p>Returns a func v-&gt;ϕ(v) ∈ ℜ(Nv) that calculates the activation of <code>Nv</code> basis functions spread out to cover V nicely. If coulomb is true, then we get twice the number of basis functions, 2Nv</p></div></div></section><pre><code class="language-none">LPVSpectral.cn_V</code></pre><pre><code class="language-none">LPVSpectral.cn_V2ΓC</code></pre><pre><code class="language-none">LPVSpectral.cn_Vs</code></pre><pre><code class="language-none">LPVSpectral.cn_Vxx</code></pre><pre><code class="language-none">LPVSpectral.cn_Vxy</code></pre><pre><code class="language-none">LPVSpectral.cn_Vyx</code></pre><pre><code class="language-none">LPVSpectral.cn_Vyy</code></pre><pre><code class="language-none">LPVSpectral.cn_fV</code></pre><pre><code class="language-none">LPVSpectral.cn_fVxx</code></pre><pre><code class="language-none">LPVSpectral.cn_fVxy</code></pre><pre><code class="language-none">LPVSpectral.cn_fVyx</code></pre><pre><code class="language-none">LPVSpectral.cn_fVyy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.detrend" href="#LPVSpectral.detrend"><code>LPVSpectral.detrend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>detrend(x, order=0, t = 1:length(x)) Removes the trend of order <code>order</code>, i.e, mean and, if order=1, the slope of the signal <code>x</code> If <code>order</code> = 1, then the sampling points of <code>x</code> can be supplied as <code>t</code> (default: <code>t = 1:length(x)</code>)</p></div></div></section><pre><code class="language-none">LPVSpectral.detrend!</code></pre><pre><code class="language-none">LPVSpectral.eval</code></pre><pre><code class="language-none">LPVSpectral.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_cohere" href="#LPVSpectral.ls_cohere"><code>LPVSpectral.ls_cohere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_cohere(y,u,t,freqs; nw = 10, noverlap = -1, estimator=ls_spectral, kwargs...)</code></p><p>Perform spectral coherence estimation using the least-squares method.</p><p><code>estimator</code> is the spectral estimatio function to use, default is <code>ls_spectral</code>. For sparse estimation, try <code>estimator = ls_sparse_spectral</code> See <code>ls_sparse_spectral</code> for more help. See also <code>ls_windowcsd</code> and <code>ls_spectral</code> for additional help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_sparse_spectral" href="#LPVSpectral.ls_sparse_spectral"><code>LPVSpectral.ls_sparse_spectral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_sparse_spectral(y,t,f=(0:((length(y)-1)/2))/length(y), [window]; λ=1, proxg      = ProximalOperators.NormL1(λ), kwargs...)</code></p><p>perform spectral estimation using the least-squares method with (default) a L1-norm penalty on the Fourier coefficients, change kwarg <code>proxg</code> to e.g. <code>NormL0(λ)</code> for a different behavior or <code>proxg = IndBallL0(4)</code> if the number of frequencies is known in advance. Promotes a sparse spectrum. See <code>?ADMM</code> for keyword arguments to control the solver.</p><p><code>y</code> is the signal to be analyzed <code>t</code> is the sampling points <code>f</code> is a vector of frequencies</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_sparse_spectral_lpv" href="#LPVSpectral.ls_sparse_spectral_lpv"><code>LPVSpectral.ls_sparse_spectral_lpv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>`ls<em>sparse</em>spectral_lpv(Y,X,V,w,Nv::Int; λ = 1, coulomb = false, normalize=true, coulomb    = false, normalize  = true)</p><p>Perform LPV spectral estimation using the method presented in Bagge Carlson et al. &quot;Linear Parameter-Varying Spectral Decomposition.&quot; modified to include a sparsity-promoting L1 group-lasso penalty on the coefficients. The groups are based on frequency, meaning a solution in which either all parameters For a particular frequency are zero, or all are non-zero. This is useful in the identification of frequency components among a large set of possible frequencies. See the paper or README For additional details.</p><p><code>Y</code> output</p><p><code>X</code> sample locations</p><p><code>V</code> scheduling signal</p><p><code>w</code> frequency vector</p><p><code>Nv</code> number of basis functions</p><p><code>λ</code> Regularization parameter</p><p><code>coulomb</code> Assume discontinuity at <code>v=0</code> (useful For signals where, e.g., Coulomb friction might cause issues.)</p><p><code>normalize</code> Use normalized basis functions (See paper For details).</p><p>See <code>?ADMM</code> for keyword arguments to control the solver.</p><p>See also <code>psd</code>, <code>ls_spectral_lpv</code> and <code>ls_windowpsd_lpv</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_spectral" href="#LPVSpectral.ls_spectral"><code>LPVSpectral.ls_spectral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_spectral(y,t,f=(0:((length(y)-1)/2))/length(y); λ=0)</code></p><p>perform spectral estimation using the least-squares method <code>y</code> is the signal to be analyzed <code>t</code> is the sampling points <code>f</code> is a vector of frequencies</p><p>See also <code>ls_sparse_spectral</code> <code>tls_spectral</code></p></div></div><div><div><p><code>ls_spectral(y,t,f,W::AbstractVector)</code> <code>W</code> is a vector of weights, for weighted least-squares</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_spectral_lpv" href="#LPVSpectral.ls_spectral_lpv"><code>LPVSpectral.ls_spectral_lpv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_spectral_lpv(Y,X,V,w,Nv::Int; λ = 1e-8, coulomb = false, normalize=true)</code></p><p>Perform LPV spectral estimation using the method presented in Bagge Carlson et al. &quot;Linear Parameter-Varying Spectral Decomposition.&quot; See the paper For additional details.</p><p><code>Y</code> output</p><p><code>X</code> sample locations</p><p><code>V</code> scheduling signal</p><p><code>w</code> frequency vector</p><p><code>Nv</code> number of basis functions</p><p><code>λ</code> Regularization parameter</p><p><code>coulomb</code> Assume discontinuity at <code>v=0</code> (useful for signals where, e.g., Coulomb friction might cause issues.)</p><p><code>normalize</code> Use normalized basis functions (See paper for details).</p><p>The method will issue a warning if less than 90% of the variance in <code>Y</code> is described by the estimated model. If this is the case, try increasing either the number of frequencies or the number of basis functions per frequency. Alternatively, try lowering the regularization parameter <code>λ</code>.</p><p>See also <code>psd</code>, <code>ls_sparse_spectral_lpv</code> and <code>ls_windowpsd_lpv</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_windowcsd" href="#LPVSpectral.ls_windowcsd"><code>LPVSpectral.ls_windowcsd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_windowcsd(y,u,t,freqs; nw = 10, noverlap = -1, window_func=rect, estimator=ls_spectral, kwargs...)</code></p><p>Perform windowed cross spectral density estimation using the least-squares method.</p><p><code>y</code> and <code>u</code> are the two signals to be analyzed and <code>t::AbstractVector</code> are their sampling points <code>window_func</code> defaults to <code>Windows.rect</code></p><p><code>estimator</code> is the spectral estimatio function to use, default is <code>ls_spectral</code>. For sparse estimation, try <code>estimator = ls_sparse_spectral</code> See <code>ls_sparse_spectral</code> for more help.</p><p>See <code>ls_spectral</code> for additional help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_windowpsd" href="#LPVSpectral.ls_windowpsd"><code>LPVSpectral.ls_windowpsd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ls_windowpsd(y,t,freqs; nw = 10, noverlap = -1, window_func=rect, estimator=ls_spectral, kwargs...)</code></p><p>perform widowed spectral estimation using the least-squares method. <code>window_func</code> defaults to <code>Windows.rect</code></p><p><code>estimator</code> is the spectral estimatio function to use, default is <code>ls_spectral</code>. For sparse estimation, try <code>estimator = ls_sparse_spectral</code> See <code>ls_sparse_spectral</code> for more help. <code>kwargs</code> are passed to <code>estimator</code>.</p><p>See <code>ls_spectral</code> for additional help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ls_windowpsd_lpv" href="#LPVSpectral.ls_windowpsd_lpv"><code>LPVSpectral.ls_windowpsd_lpv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ls<em>windowpsd</em>lpv(Y::AbstractVector,X::AbstractVector,V::AbstractVector,w,Nv::Integer, nw::Int=10, noverlap=0;  kwargs...)</p><p>Perform windowed psd estimation using the LPV method. A rectangular window is always used.</p><p>See <code>?ls_spectral_lpv</code> for additional help.</p></div></div></section><pre><code class="language-none">LPVSpectral.meshgrid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.pdf" href="#LPVSpectral.pdf"><code>LPVSpectral.pdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>f(cn::ComplexNormal, z)</code></p><p>Probability density Function <code>f(z)</code> for a complex normal distribution. This can probably be more efficiently implemented</p></div></div></section><pre><code class="language-none">LPVSpectral.periodogram</code></pre><pre><code class="language-none">LPVSpectral.periodogram!</code></pre><pre><code class="language-none">LPVSpectral.plot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.psd" href="#LPVSpectral.psd"><code>LPVSpectral.psd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>psd(se::SpectralExt) Compute the power spectral density For a SpectralExt object</p><p>See also <code>ls_windowpsd_lpv</code></p></div></div></section><pre><code class="language-none">LPVSpectral.rand</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.real_complex_bs" href="#LPVSpectral.real_complex_bs"><code>LPVSpectral.real_complex_bs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>real_complex_bs(A,b, λ=0)</code> Replaces the backslash operator For complex arguments. Expands the A-matrix into <code>[real(A) imag(A)]</code> and performs the computation using real arithmetics. Optionally accepts <code>λ</code> to solve the ridge regression problem using the formulation <code>[A;λI]\[b;0]. λ should be given with the same dimension as the columns of A, i.e. if λ represents a standard deviation, then λ = σ, not λ = σ²</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.reshape_params" href="#LPVSpectral.reshape_params"><code>LPVSpectral.reshape_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns params as a [nω × N] matrix</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.ridgereg" href="#LPVSpectral.ridgereg"><code>LPVSpectral.ridgereg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ridgereg(A,b,λ)</code> Accepts <code>λ</code> to solve the ridge regression problem using the formulation <code>[A;λI]\[b;0]. λ should be given with the same dimension as the columns of A, i.e. if λ represents an inverse standard deviation, then 1/λ = σ, not 1/λ = σ²</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPVSpectral.tls_spectral" href="#LPVSpectral.tls_spectral"><code>LPVSpectral.tls_spectral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tls_spectral(y,t,f=(0:((length(y)-1)/2))/length(y))</code> Perform total least-squares spectral estimation using the SVD-method. See <code>ls_spectral</code> for additional help</p></div></div></section><pre><code class="language-none">LPVSpectral.welch_pgram</code></pre><pre><code class="language-none">LPVSpectral.Σ</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
