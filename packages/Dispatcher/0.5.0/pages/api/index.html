<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Dispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dispatcher.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../manual/">Manual</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Nodes-1">Nodes</a></li><li><a class="toctext" href="#Graph-1">Graph</a></li><li><a class="toctext" href="#Executors-1">Executors</a></li><li><a class="toctext" href="#Errors-1">Errors</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Nodes-1" href="#Nodes-1">Nodes</a></h2><h3><a class="nav-anchor" id="DispatchNode-1" href="#DispatchNode-1">DispatchNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchNode" href="#Dispatcher.DispatchNode"><code>Dispatcher.DispatchNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>DispatchNode</code> represents a unit of computation that can be run. A <code>DispatchNode</code> may depend on other <code>DispatchNode</code>s, which are returned from the <a href="#Dispatcher.dependencies-Tuple{DispatchNode}"><code>dependencies</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Union{Tuple{T}, Tuple{T}} where T&lt;:DispatchNode" href="#Dispatcher.get_label-Union{Tuple{T}, Tuple{T}} where T&lt;:DispatchNode"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_label(node::DispatchNode) -&gt; String</code></pre><p>Returns a node&#39;s label. By default, <code>DispatchNode</code>s do not support labels, so this method will error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:DispatchNode" href="#Dispatcher.set_label!-Union{Tuple{T}, Tuple{T,Any}} where T&lt;:DispatchNode"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_label!(node::DispatchNode, label)</code></pre><p>Sets a node&#39;s label. By default, <code>DispatchNode</code>s do not support labels, so this method will error. Actual method implementations should return their second argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{DispatchNode}" href="#Dispatcher.has_label-Tuple{DispatchNode}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_label(node::DispatchNode) -&gt; Bool</code></pre><p>Returns true or false as to whether the node has a label (ie: a <a href="#Dispatcher.get_label-Union{Tuple{T}, Tuple{T}} where T&lt;:DispatchNode"><code>get_label(::DispatchNode)</code></a> method)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{DispatchNode}" href="#Dispatcher.dependencies-Tuple{DispatchNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dependencies(node::DispatchNode) -&gt; Tuple{Vararg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this node. Unless given a <code>dependencies</code> method, a <code>DispatchNode</code> will be assumed to have no dependencies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{DispatchNode}" href="#Dispatcher.prepare!-Tuple{DispatchNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(node::DispatchNode)</code></pre><p>Execute some action on a node before dispatching nodes via an <a href="#Dispatcher.Executor"><code>Executor</code></a>. The default method performs no action.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{DispatchNode}" href="#Dispatcher.run!-Tuple{DispatchNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(node::DispatchNode)</code></pre><p>Execute a node&#39;s action as part of dispatch. The default method performs no action.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{DispatchNode}" href="#Base.isready-Tuple{DispatchNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isready(node::DispatchNode) -&gt; Bool</code></pre><p>Determine whether a node has an available result. The default method assumes no synchronization is involved in retrieving that result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{DispatchNode}" href="#Base.wait-Tuple{DispatchNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wait(node::DispatchNode)</code></pre><p>Block the current task until a node has a result available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Union{Tuple{T}, Tuple{T}} where T&lt;:DispatchNode" href="#Base.fetch-Union{Tuple{T}, Tuple{T}} where T&lt;:DispatchNode"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch(node::DispatchNode) -&gt; Any</code></pre><p>Fetch a node&#39;s result if available, blocking until it is available. All subtypes of <code>DispatchNode</code> should implement this, so the default method throws an error.</p></div></div></section><h3><a class="nav-anchor" id="Op-1" href="#Op-1">Op</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Op" href="#Dispatcher.Op"><code>Dispatcher.Op</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>Op</code> is a <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a> which wraps a function which is executed when the <code>Op</code> is run. The result of that function call is stored in the <code>result</code> <code>DeferredFuture</code>. Any <code>DispatchNode</code>s which appear in the args or kwargs values will be noted as dependencies. This is the most common <code>DispatchNode</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Op-Tuple{Function}" href="#Dispatcher.Op-Tuple{Function}"><code>Dispatcher.Op</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Op(func::Function, args...; kwargs...) -&gt; Op</code></pre><p>Construct an <code>Op</code> which represents the delayed computation of <code>func(args...; kwargs)</code>. Any <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s which appear in the args or kwargs values will be noted as dependencies. The default label of an <code>Op</code> is the name of <code>func</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.@op" href="#Dispatcher.@op"><code>Dispatcher.@op</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@op func(...)</code></pre><p>The <code>@op</code> macro makes it more convenient to construct <a href="#Dispatcher.Op"><code>Op</code></a> nodes. It translates a function call into an <code>Op</code> call, effectively deferring the computation.</p><pre><code class="language-julia">a = @op sort(1:10; rev=true)</code></pre><p>is equivalent to</p><pre><code class="language-julia">a = Op(sort, 1:10; rev=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Tuple{Op}" href="#Dispatcher.get_label-Tuple{Op}"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_label(op::Op) -&gt; String</code></pre><p>Returns the <code>op.label</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Tuple{Op,AbstractString}" href="#Dispatcher.set_label!-Tuple{Op,AbstractString}"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_label!(op::Op, label::AbstractString)</code></pre><p>Set the op&#39;s label. Returns its second argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{Op}" href="#Dispatcher.has_label-Tuple{Op}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_label(::Op) -&gt; Bool</code></pre><p>Always return <code>true</code> as an <code>Op</code> will always have a label.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{Op}" href="#Dispatcher.dependencies-Tuple{Op}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dependencies(op::Op) -&gt; Tuple{Verarg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this <code>Op</code>. This will be all <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s in the <code>Op</code>&#39;s function <code>args</code> and <code>kwargs</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Op}" href="#Dispatcher.prepare!-Tuple{Op}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(op::Op)</code></pre><p>Replace an <code>Op</code>&#39;s result field with a fresh, empty one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Op}" href="#Dispatcher.run!-Tuple{Op}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(op::Op)</code></pre><p>Fetch an <code>Op</code>&#39;s dependencies and execute its function. Store the result in its <code>result::DeferredFuture</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Op}" href="#Base.isready-Tuple{Op}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isready(op::Op) -&gt; Bool</code></pre><p>Determine whether an <code>Op</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Op}" href="#Base.wait-Tuple{Op}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wait(op::Op)</code></pre><p>Wait until an <code>Op</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Op}" href="#Base.fetch-Tuple{Op}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch(op::Op) -&gt; Any</code></pre><p>Return the result of the <code>Op</code>. Block until it is available. Throw <a href="#Dispatcher.DependencyError"><code>DependencyError</code></a> in the event that the result is a <code>DependencyError</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{Op}" href="#Base.summary-Tuple{Op}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">summary(op::Op)</code></pre><p>Returns a string representation of the <code>Op</code> with its label and the args/kwargs types.</p><p><strong>NOTE</strong>: if an arg/kwarg is a <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a> with a label it will be printed with that arg.</p></div></div></section><h3><a class="nav-anchor" id="DataNode-1" href="#DataNode-1">DataNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DataNode" href="#Dispatcher.DataNode"><code>Dispatcher.DataNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>DataNode</code> is a <code>DispatchNode</code> which wraps a piece of static data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{DataNode}" href="#Base.fetch-Tuple{DataNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch{T}(node::DataNode{T}) -&gt; T</code></pre><p>Immediately return the data contained in a <code>DataNode</code>.</p></div></div></section><h3><a class="nav-anchor" id="IndexNode-1" href="#IndexNode-1">IndexNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.IndexNode" href="#Dispatcher.IndexNode"><code>Dispatcher.IndexNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>IndexNode</code> refers to an element of the return value of a <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>. It is meant to handle multiple return values from a <code>DispatchNode</code>.</p><p>Example:</p><pre><code class="language-julia">n1, n2 = Op(() -&gt; divrem(5, 2))
run!(exec, [n1, n2])

@assert fetch(n1) == 2
@assert fetch(n2) == 1</code></pre><p>In this example, <code>n1</code> and <code>n2</code> are created as <code>IndexNode</code>s pointing to the <a href="#Dispatcher.Op"><code>Op</code></a> at index <code>1</code> and index <code>2</code> respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.IndexNode-Tuple{DispatchNode,Int64}" href="#Dispatcher.IndexNode-Tuple{DispatchNode,Int64}"><code>Dispatcher.IndexNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">IndexNode(node::DispatchNode, index) -&gt; IndexNode</code></pre><p>Create a new <code>IndexNode</code> referring to the result of <code>node</code> at <code>index</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{IndexNode}" href="#Dispatcher.dependencies-Tuple{IndexNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dependencies(node::IndexNode) -&gt; Tuple{DispatchNode}</code></pre><p>Return the dependency that this node will fetch data (at a certain index) from.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{IndexNode}" href="#Dispatcher.prepare!-Tuple{IndexNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(node::IndexNode)</code></pre><p>Replace an <code>IndexNode</code>&#39;s result field with a fresh, empty one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{IndexNode}" href="#Dispatcher.run!-Tuple{IndexNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Union{Tuple{IndexNode{T}}, Tuple{T}} where T&lt;:Union{Op, IndexNode}" href="#Dispatcher.run!-Union{Tuple{IndexNode{T}}, Tuple{T}} where T&lt;:Union{Op, IndexNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{IndexNode}" href="#Base.isready-Tuple{IndexNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isready(node::IndexNode) -&gt; Bool</code></pre><p>Determine whether an <code>IndexNode</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{IndexNode}" href="#Base.wait-Tuple{IndexNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wait(node::IndexNode)</code></pre><p>Wait until an <code>IndexNode</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{IndexNode}" href="#Base.fetch-Tuple{IndexNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch(node::IndexNode) -&gt; Any</code></pre><p>Return the stored result of indexing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{IndexNode}" href="#Base.summary-Tuple{IndexNode}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">summary(node::IndexNode)</code></pre><p>Returns a string representation of the <code>IndexNode</code> with a summary of the wrapped node and the node index.</p></div></div></section><h3><a class="nav-anchor" id="CollectNode-1" href="#CollectNode-1">CollectNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.CollectNode" href="#Dispatcher.CollectNode"><code>Dispatcher.CollectNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CollectNode{T&lt;:DispatchNode}(nodes::Vector{T}) -&gt; CollectNode{T}</code></pre><p>Create a node which gathers an array of nodes and stores an array of their results in its result field.</p></div></div><div><div><pre><code class="language-none">CollectNode(nodes) -&gt; CollectNode{DispatchNode}</code></pre><p>Create a <code>CollectNode</code> from any iterable of nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.CollectNode-Tuple{Array{DispatchNode,1}}" href="#Dispatcher.CollectNode-Tuple{Array{DispatchNode,1}}"><code>Dispatcher.CollectNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CollectNode{T&lt;:DispatchNode}(nodes::Vector{T}) -&gt; CollectNode{T}</code></pre><p>Create a node which gathers an array of nodes and stores an array of their results in its result field.</p></div></div><div><div><pre><code class="language-none">CollectNode(nodes) -&gt; CollectNode{DispatchNode}</code></pre><p>Create a <code>CollectNode</code> from any iterable of nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Tuple{CollectNode}" href="#Dispatcher.get_label-Tuple{CollectNode}"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_label(node::CollectNode) -&gt; String</code></pre><p>Returns the node.label.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Tuple{CollectNode,AbstractString}" href="#Dispatcher.set_label!-Tuple{CollectNode,AbstractString}"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_label!(node::CollectNode, label::AbstractString) -&gt; AbstractString</code></pre><p>Set the node&#39;s label. Returns its second argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{CollectNode}" href="#Dispatcher.has_label-Tuple{CollectNode}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_label(::CollectNode) -&gt; Bool</code></pre><p>Always return <code>true</code> as a <code>CollectNode</code> will always have a label.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{CollectNode}" href="#Dispatcher.dependencies-Tuple{CollectNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dependencies{T&lt;:DispatchNode}(node::CollectNode{T}) -&gt; Vector{T}</code></pre><p>Return the nodes this depends on which this node will collect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{CollectNode}" href="#Dispatcher.prepare!-Tuple{CollectNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(node::CollectNode)</code></pre><p>Initialize a <code>CollectNode</code> with a fresh result <code>DeferredFuture</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{CollectNode}" href="#Dispatcher.run!-Tuple{CollectNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(node::CollectNode)</code></pre><p>Collect all of a <code>CollectNode</code>&#39;s dependencies&#39; results into a Vector and store that in this node&#39;s result field. Returns <code>nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{CollectNode}" href="#Base.isready-Tuple{CollectNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isready(node::CollectNode) -&gt; Bool</code></pre><p>Determine whether a <code>CollectNode</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{CollectNode}" href="#Base.wait-Tuple{CollectNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wait(node::CollectNode)</code></pre><p>Block until a <code>CollectNode</code> has an available result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{CollectNode}" href="#Base.fetch-Tuple{CollectNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fetch(node::CollectNode) -&gt; Vector</code></pre><p>Return the result of the collection. Block until it is available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{CollectNode}" href="#Base.summary-Tuple{CollectNode}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">summary(node::CollectNode)</code></pre><p>Returns a string representation of the <code>CollectNode</code> with its label.</p></div></div></section><h2><a class="nav-anchor" id="Graph-1" href="#Graph-1">Graph</a></h2><h3><a class="nav-anchor" id="DispatchGraph-1" href="#DispatchGraph-1">DispatchGraph</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchGraph" href="#Dispatcher.DispatchGraph"><code>Dispatcher.DispatchGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DispatchGraph</code> wraps a directed graph from <code>LightGraphs</code> and a bidirectional dictionary mapping between <code>DispatchNode</code> instances and vertex numbers in the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.nodes-Tuple{DispatchGraph}" href="#Dispatcher.nodes-Tuple{DispatchGraph}"><code>Dispatcher.nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nodes(graph::DispatchGraph) -&gt;</code></pre><p>Return an iterable of all nodes stored in the <code>DispatchGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{DispatchGraph}" href="#Base.length-Tuple{DispatchGraph}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(graph::DispatchGraph) -&gt; Integer</code></pre><p>Return the number of nodes in the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DispatchGraph,DispatchNode}" href="#Base.push!-Tuple{DispatchGraph,DispatchNode}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(graph::DispatchGraph, node::DispatchNode) -&gt; DispatchGraph</code></pre><p>Add a node to the graph and return the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.add_edge!-Tuple{DispatchGraph,DispatchNode,DispatchNode}" href="#LightGraphs.SimpleGraphs.add_edge!-Tuple{DispatchGraph,DispatchNode,DispatchNode}"><code>LightGraphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add_edge!(graph::DispatchGraph, parent::DispatchNode, child::DispatchNode) -&gt; Bool</code></pre><p>Add an edge to the graph from <code>parent</code> to <code>child</code>. Return whether the operation was successful.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{DispatchGraph,DispatchGraph}" href="#Base.:==-Tuple{DispatchGraph,DispatchGraph}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph1::DispatchGraph == graph2::DispatchGraph</code></pre><p>Determine whether two graphs have the same nodes and edges. This is an expensive operation.</p></div></div></section><h2><a class="nav-anchor" id="Executors-1" href="#Executors-1">Executors</a></h2><h3><a class="nav-anchor" id="Executor-1" href="#Executor-1">Executor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Executor" href="#Dispatcher.Executor"><code>Dispatcher.Executor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>Executor</code> handles execution of <a href="#Dispatcher.DispatchGraph"><code>DispatchGraph</code></a>s.</p><p>A type <code>T &lt;: Executor</code> must implement <code>dispatch!(::T, ::DispatchNode)</code> and may optionally implement <code>dispatch!(::T, ::DispatchGraph; throw_error=true)</code>.</p><p>The function call tree will look like this when an executor is run:</p><pre><code class="language-none">run!(exec, context)
    prepare!(exec, context)
        prepare!(nodes[i])
    dispatch!(exec, context)
        dispatch!(exec, nodes[i])
            run!(nodes[i])</code></pre><p>NOTE: Currently, it is expected that <code>dispatch!(::T, ::DispatchNode)</code> returns something to wait on (ie: <code>Task</code>, <code>Future</code>, <code>Channel</code>, <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>, etc)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Union{Tuple{S}, Tuple{T}, Tuple{Executor,AbstractArray{T,N} where N,AbstractArray{S,N} where N}} where S&lt;:DispatchNode where T&lt;:DispatchNode" href="#Dispatcher.run!-Union{Tuple{S}, Tuple{T}, Tuple{Executor,AbstractArray{T,N} where N,AbstractArray{S,N} where N}} where S&lt;:DispatchNode where T&lt;:DispatchNode"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(exec, output_nodes, input_nodes; input_map, throw_error) -&gt; DispatchResult</code></pre><p>Create a graph, ending in <code>output_nodes</code>, and using <code>input_nodes</code>/<code>input_map</code> to replace nodes with fixed values (and ignoring nodes for which all paths descend to <code>input_nodes</code>), then execute it.</p><p><strong>Arguments</strong></p><ul><li><code>exec::Executor</code>: the executor which will execute the graph</li><li><code>graph::DispatchGraph</code>: the graph which will be executed</li><li><code>output_nodes::AbstractArray{T&lt;:DispatchNode}</code>: the nodes whose results we are interested in</li><li><code>input_nodes::AbstractArray{T&lt;:DispatchNode}</code>: &quot;root&quot; nodes of the graph which will be replaced with their fetched values (dependencies of these nodes are not included in the graph)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>input_map::Associative=Dict{DispatchNode, Any}()</code>: dict keys are &quot;root&quot; nodes of the subgraph which will be replaced with the dict values (dependencies of these nodes are not included in the graph)</li><li><code>throw_error::Bool</code>: whether to throw any <a href="#Dispatcher.DependencyError"><code>DependencyError</code></a>s immediately (see <a href="#Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a> for more information)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DispatchResult}</code>: an array containing a <code>DispatchResult</code> for each node in <code>output_nodes</code>, in that order.</li></ul><p><strong>Throws</strong></p><ul><li><code>ExecutorError</code>: if the constructed graph contains a cycle</li><li><code>CompositeException</code>/<a href="#Dispatcher.DependencyError"><code>DependencyError</code></a>: see documentation for <a href="#Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Executor,DispatchGraph}" href="#Dispatcher.run!-Tuple{Executor,DispatchGraph}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run!(exec::Executor, graph::DispatchGraph; kwargs...)</code></pre><p>The <code>run!</code> function prepares a <a href="#Dispatcher.DispatchGraph"><code>DispatchGraph</code></a> for dispatch and then dispatches <a href="#Dispatcher.run!-Tuple{DispatchNode}"><code>run!(::DispatchNode)</code></a> calls for all nodes in its graph.</p><p>Users will almost never want to add methods to this function for different <a href="#Dispatcher.Executor"><code>Executor</code></a> subtypes; overriding <a href="#Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a> is the preferred pattern.</p><p>Return an array containing a <code>Result{DispatchNode, DependencyError}</code> for each leaf node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Executor,DispatchGraph}" href="#Dispatcher.prepare!-Tuple{Executor,DispatchGraph}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(exec::Executor, graph::DispatchGraph)</code></pre><p>This function prepares a context for execution. Call <a href="#Dispatcher.prepare!-Tuple{DispatchNode}"><code>prepare!(::DispatchNode)</code></a> on each node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}" href="#Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dispatch!(exec::Executor, graph::DispatchGraph; throw_error=true) -&gt; Vector</code></pre><p>The default <code>dispatch!</code> method uses <code>asyncmap</code> over all nodes in the context to call <code>dispatch!(exec, node)</code>. These <code>dispatch!</code> calls for each node are wrapped in various retry and error handling methods.</p><p><strong>Wrapping Details</strong></p><ol><li><p>All nodes are wrapped in a try catch which waits on the value returned from the <code>dispatch!(exec, node)</code> call. Any errors are caught and used to create <a href="#Dispatcher.DependencyError"><code>DependencyError</code></a>s which are thrown. If no errors are produced then the node is returned.</p><p><strong>NOTE</strong>: All errors thrown by trying to run <code>dispatch!(exec, node)</code> are wrapped in a <code>DependencyError</code>.</p></li><li><p>The aformentioned wrapper function is used in a retry wrapper to rerun failed nodes (up to some limit). The wrapped function will only be retried iff the error produced by <code>dispatch!(::Executor, ::DispatchNode</code>) passes one of the retry functions specific to that <a href="#Dispatcher.Executor"><code>Executor</code></a>. By default the <a href="#Dispatcher.AsyncExecutor"><code>AsyncExecutor</code></a> has no <a href="#Dispatcher.retry_on-Tuple{Executor}"><code>retry_on</code></a> functions and the <a href="#Dispatcher.ParallelExecutor"><code>ParallelExecutor</code></a> only has <code>retry_on</code> functions related to the loss of a worker process during execution.</p></li><li><p>A node may enter a failed state if it exits the retry wrapper with an exception. This may occur if an exception is thrown while executing a node and it does not pass any of the <code>retry_on</code> conditions for the <code>Executor</code> or too many attempts to run the node have been made. In the situation where a node has entered a failed state and the node is an <code>Op</code> then the <code>op.result</code> is set to the <code>DependencyError</code>, signifying the node&#39;s failure to any dependent nodes. Finally, if <code>throw_error</code> is true then the <code>DependencyError</code> will be immediately thrown in the current process without allowing other nodes to finish. If <code>throw_error</code> is false then the <code>DependencyError</code> is not thrown and it will be returned in the array of passing and failing nodes.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>exec::Executor</code>: the executor we&#39;re running</li><li><code>graph::DispatchGraph</code>: the context of nodes to run</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>throw_error::Bool=true</code>: whether or not to throw the <code>DependencyError</code> for failed nodes</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Union{DispatchNode, DependencyError}}</code>: a list of <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s or <code>DependencyError</code>s for failed nodes</li></ul><p><strong>Throws</strong></p><ul><li><code>dispatch!</code> has the same behaviour on exceptions as <code>asyncmap</code> and <code>pmap</code>. In 0.5 this will throw a <code>CompositeException</code> containing <code>DependencyError</code>s, while in 0.6 this will simply throw the first <code>DependencyError</code>.</li></ul><p><strong>Usage</strong></p><p><strong>Example 1</strong></p><p>Assuming we have some uncaught application error:</p><pre><code class="language-julia">exec = AsyncExecutor()
n1 = Op(() -&gt; 3)
n2 = Op(() -&gt; 4)
failing_node = Op(() -&gt; throw(ErrorException(&quot;ApplicationError&quot;)))
dep_node = Op(n -&gt; println(n), failing_node)  # This node will fail as well
graph = DispatchGraph([n1, n2, failing_node, dep_node])</code></pre><p>Then <code>dispatch!(exec, graph)</code> will throw a <code>DependencyError</code> and <code>dispatch!(exec, graph; throw_error=false)</code> will return an array of passing nodes and the <code>DependencyError</code>s (ie: <code>[n1, n2, DependencyError(...), DependencyError(...)]</code>).</p><p><strong>Example 2</strong></p><p>Now if we want to retry our node on certain errors we can do:</p><pre><code class="language-julia">exec = AsyncExecutor(5, [e -&gt; isa(e, HttpError) &amp;&amp; e.status == &quot;503&quot;])
n1 = Op(() -&gt; 3)
n2 = Op(() -&gt; 4)
http_node = Op(() -&gt; http_get(...))
graph = DispatchGraph([n1, n2, http_node])</code></pre><p>Assuming that the <code>http_get</code> function does not error 5 times the call to <code>dispatch!(exec, graph)</code> will return [n1, n2, http<em>node]. If the `http</em>get` function either:</p><ol><li>fails with a different status code</li><li>fails with something other than an <code>HttpError</code> or</li><li>throws an <code>HttpError</code> with status &quot;503&quot; more than 5 times</li></ol><p>then we&#39;ll see the same failure behaviour as in the previous example.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run_inner_node!-Tuple{Executor,DispatchNode,Int64}" href="#Dispatcher.run_inner_node!-Tuple{Executor,DispatchNode,Int64}"><code>Dispatcher.run_inner_node!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run_inner_node!(exec::Executor, node::DispatchNode, id::Int)</code></pre><p>Run the <code>DispatchNode</code> in the <code>DispatchGraph</code> at position <code>id</code>. Any error thrown during the node&#39;s execution is caught and wrapped in a <a href="#Dispatcher.DependencyError"><code>DependencyError</code></a>.</p><p>Typical <a href="#Dispatcher.Executor"><code>Executor</code></a> implementations should not need to override this.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{Executor}" href="#Dispatcher.retries-Tuple{Executor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{Executor}" href="#Dispatcher.retry_on-Tuple{Executor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div></div></section><h3><a class="nav-anchor" id="AsyncExecutor-1" href="#AsyncExecutor-1">AsyncExecutor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.AsyncExecutor" href="#Dispatcher.AsyncExecutor"><code>Dispatcher.AsyncExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AsyncExecutor</code> is an <a href="#Dispatcher.Executor"><code>Executor</code></a> which schedules a local Julia <code>Task</code> for each <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a> and waits for them to complete. <code>AsyncExecutor</code>&#39;s <a href="#Dispatcher.dispatch!-Tuple{AsyncExecutor,DispatchNode}"><code>dispatch!(::AsyncExecutor, ::DispatchNode)</code></a> method will complete as long as each <code>DispatchNode</code>&#39;s <a href="#Dispatcher.run!-Tuple{DispatchNode}"><code>run!(::DispatchNode)</code></a> method completes and there are no cycles in the computation graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.AsyncExecutor-Tuple{}" href="#Dispatcher.AsyncExecutor-Tuple{}"><code>Dispatcher.AsyncExecutor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AsyncExecutor(retries=5, retry_on::Vector{Function}=Function[]) -&gt; AsyncExecutor</code></pre><p><code>retries</code> is the number of times the executor is to retry a failed node. <code>retry_on</code> is a vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise).</p><p>Return a new <code>AsyncExecutor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{AsyncExecutor,DispatchNode}" href="#Dispatcher.dispatch!-Tuple{AsyncExecutor,DispatchNode}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dispatch!(exec::AsyncExecutor, node::DispatchNode) -&gt; Task</code></pre><p><code>dispatch!</code> takes the <code>AsyncExecutor</code> and a <code>DispatchNode</code> to run. The <a href="#Dispatcher.run!-Tuple{DispatchNode}"><code>run!(::DispatchNode)</code></a> method on the node is called within a <code>@async</code> block and the resulting <code>Task</code> is returned. This is the defining method of <code>AsyncExecutor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{AsyncExecutor}" href="#Dispatcher.retries-Tuple{AsyncExecutor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div></div><div><div><pre><code class="language-none">retries(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Int</code></pre><p>Return the number of retries per node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{AsyncExecutor}" href="#Dispatcher.retry_on-Tuple{AsyncExecutor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div></div><div><div><pre><code class="language-none">retry_on(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Vector{Function}</code></pre><p>Return the array of retry conditions.</p></div></div></section><h3><a class="nav-anchor" id="ParallelExecutor-1" href="#ParallelExecutor-1">ParallelExecutor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.ParallelExecutor" href="#Dispatcher.ParallelExecutor"><code>Dispatcher.ParallelExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>ParallelExecutor</code> is an <a href="#Dispatcher.Executor"><code>Executor</code></a> which creates a Julia <code>Task</code> for each <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a>, spawns each of those tasks on the processes available to Julia, and waits for them to complete. <code>ParallelExecutor</code>&#39;s <a href="#Dispatcher.dispatch!-Tuple{Executor,DispatchGraph}"><code>dispatch!(::ParallelExecutor, ::DispatchGraph)</code></a> method will complete as long as each <code>DispatchNode</code>&#39;s <a href="#Dispatcher.run!-Tuple{DispatchNode}"><code>run!(::DispatchNode)</code></a> method completes and there are no cycles in the computation graph.</p><pre><code class="language-none">ParallelExecutor(retries=5, retry_on::Vector{Function}=Function[]) -&gt; ParallelExecutor</code></pre><p><code>retries</code> is the number of times the executor is to retry a failed node. <code>retry_on</code> is a vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). Returns a new <code>ParallelExecutor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{ParallelExecutor,DispatchNode}" href="#Dispatcher.dispatch!-Tuple{ParallelExecutor,DispatchNode}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dispatch!(exec::ParallelExecutor, node::DispatchNode) -&gt; Future</code></pre><p><code>dispatch!</code> takes the <code>ParallelExecutor</code> and a <a href="#Dispatcher.DispatchNode"><code>DispatchNode</code></a> to run. The <a href="#Dispatcher.run!-Tuple{DispatchNode}"><code>run!(::DispatchNode)</code></a> method on the node is called within an <code>@spawn</code> block and the resulting <code>Future</code> is returned. This is the defining method of <code>ParallelExecutor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{ParallelExecutor}" href="#Dispatcher.retries-Tuple{ParallelExecutor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div></div><div><div><pre><code class="language-none">retries(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Int</code></pre><p>Return the number of retries per node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{ParallelExecutor}" href="#Dispatcher.retry_on-Tuple{ParallelExecutor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div></div><div><div><pre><code class="language-none">retry_on(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Vector{Function}</code></pre><p>Return the array of retry conditions.</p></div></div></section><h2><a class="nav-anchor" id="Errors-1" href="#Errors-1">Errors</a></h2><h3><a class="nav-anchor" id="DependencyError-1" href="#DependencyError-1">DependencyError</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DependencyError" href="#Dispatcher.DependencyError"><code>Dispatcher.DependencyError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DependencyError</code> wraps any errors (and corresponding traceback) that occur on the dependency of a given nodes.</p><p>This is important for passing failure conditions to dependent nodes after a failed number of retries.</p><p><strong>NOTE</strong>: our <code>trace</code> field is a Union of <code>Vector{Any}</code> and <code>StackTrace</code> because we could be storing the traceback from a <code>CompositeException</code> (inside a <code>RemoteException</code>) which is of type <code>Vector{Any}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{DependencyError}" href="#Base.summary-Tuple{DependencyError}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">summary(de::DependencyError)</code></pre><p>Retuns a string representation of the error with only the internal <code>Exception</code> type and the <code>id</code></p></div></div></section><footer><hr/><a class="previous" href="../manual/"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
