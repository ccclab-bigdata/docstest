<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · AbstractPlotting.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractPlotting.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">AbstractPlotting...</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@extract" href="#AbstractPlotting.@extract"><code>AbstractPlotting.@extract</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>usage @exctract scene (a, b, c, d)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@extractvalue" href="#AbstractPlotting.@extractvalue"><code>AbstractPlotting.@extractvalue</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-example">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@get_attribute" href="#AbstractPlotting.@get_attribute"><code>AbstractPlotting.@get_attribute</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it&#39;s a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-example">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div></div></section><pre><code class="language-none">AbstractPlotting.@key_str</code></pre><pre><code class="language-none">AbstractPlotting.@log_gc</code></pre><pre><code class="language-none">AbstractPlotting.@log_performance</code></pre><pre><code class="language-none">AbstractPlotting.@log_signals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@recipe" href="#AbstractPlotting.@recipe"><code>AbstractPlotting.@recipe</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><strong>type recipe are really simple and just overload the argument conversion pipeline.</strong></p><p>convert<em>arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert</em>arguments(P, rand(10, 10))</p><p><strong>only apply this for a certain plot type:</strong></p><p>convert<em>arguments(P::Type{&lt;:Scatter}, x::MyType) = convert</em>arguments(P, rand(10, 10))</p><p><strong>optionally define the plotting type, when someone just says plot(x::MyType)</strong></p><p><strong>- will fall back to whatever the standard plot type for what you return from argument_convert is!</strong></p><p>plottype(::MyType) = Surface</p><p><strong>full recipes:</strong></p><p><strong>(x, y, z) &amp;&amp; themes are optional</strong></p><p>@recipe(MyPlot, x, y, z) do scene     Theme(         plot_color =&gt; :red     ) end</p><p><strong>this macro defines the following:</strong></p><p>const Myplot{ArgTypes} = Combined{myplot, ArgTypes}</p><p><strong>the type parameter contains the function instead of e.g. a symbol. This way</strong></p><p><strong>the mapping from Myplot to myplot is safer and simpler.</strong></p><p><strong>Downside, we always need a function. Would there be rejection against that?</strong></p><p><strong>all the signatures to make it nice to use:</strong></p><p>myplot(args...; kw<em>args...) = ... myplot!(scene, args...; kw</em>args...) = ... myplot(kw<em>args::Dict, args...) = ... myplot!(scene, kw</em>args::Dict, args...) = ... #etc (not 100% settled what signatures there will be)</p><p><strong>the next one is optional, but it will allow to say plot_object[:x] to fetch the first argument</strong></p><p><strong>from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>.</strong></p><p><strong>If you leave out the (x, y, z)</strong></p><p><strong>in the recipe macro, it will default to plot<em>object<a href="always works">1</a>, and plot</em>object[:arg1]</strong></p><p>argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</p><p><strong>this function will insert the theme into any scene that plots Myplot.</strong></p><p>function default<em>theme(scene, ::Myplot)     Theme(         plot</em>color =&gt; :red     ) end #––––––––––––––-</p><p><strong>Implement the recipe</strong></p><p>function plot!(plot::MyPlot)     # normal plotting code, building up on any previously defined recipes     # or atomic plotting operations, and adds it to the combined <code>plot</code>:     lines!(plot, rand(10), color = plot[:plot_color])     plot!(plot, plot[:x], plot[:y])     plot end</p><p><strong>Add specialization</strong></p><p>const MyVolume = MyPlot{Tuple{ArgTypes &lt;: AbstractArray{&lt;: AbstractFloat, 3}}} argument<em>names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional function plot!(plot::MyVolume)     # plot a volume with a colormap going from fully transparent to plot</em>color     volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])     plot end</p></div></div></section><pre><code class="language-none">AbstractPlotting.Absolute</code></pre><pre><code class="language-none">AbstractPlotting.Absorption</code></pre><pre><code class="language-none">AbstractPlotting.AbsorptionRGBA</code></pre><pre><code class="language-none">AbstractPlotting.AbstractBackend</code></pre><pre><code class="language-none">AbstractPlotting.AbstractCamera</code></pre><pre><code class="language-none">AbstractPlotting.AbstractPlot</code></pre><pre><code class="language-none">AbstractPlotting.AbstractPlotList</code></pre><pre><code class="language-none">AbstractPlotting.AbstractPlotting</code></pre><pre><code class="language-none">AbstractPlotting.AbstractScene</code></pre><pre><code class="language-none">AbstractPlotting.AbstractScreen</code></pre><pre><code class="language-none">AbstractPlotting.Accum</code></pre><pre><code class="language-none">AbstractPlotting.Annotations</code></pre><pre><code class="language-none">AbstractPlotting.Arc</code></pre><pre><code class="language-none">AbstractPlotting.Arrows</code></pre><pre><code class="language-none">AbstractPlotting.Atomic</code></pre><pre><code class="language-none">AbstractPlotting.AttributeOrPlot</code></pre><pre><code class="language-none">AbstractPlotting.Attributes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Automatic" href="#AbstractPlotting.Automatic"><code>AbstractPlotting.Automatic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type to indicate that an attribute will get calculated automatically</p></div></div></section><pre><code class="language-none">AbstractPlotting.Axis</code></pre><pre><code class="language-none">AbstractPlotting.Axis2D</code></pre><pre><code class="language-none">AbstractPlotting.Axis3D</code></pre><pre><code class="language-none">AbstractPlotting.Band</code></pre><pre><code class="language-none">AbstractPlotting.BarPlot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Billboard" href="#AbstractPlotting.Billboard"><code>AbstractPlotting.Billboard</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div></section><pre><code class="language-none">AbstractPlotting.Button</code></pre><pre><code class="language-none">AbstractPlotting.ButtonTypes</code></pre><pre><code class="language-none">AbstractPlotting.Camera</code></pre><pre><code class="language-none">AbstractPlotting.Camera2D</code></pre><pre><code class="language-none">AbstractPlotting.Camera3D</code></pre><pre><code class="language-none">AbstractPlotting.CameraLift</code></pre><pre><code class="language-none">AbstractPlotting.Categorical</code></pre><pre><code class="language-none">AbstractPlotting.Circle</code></pre><pre><code class="language-none">AbstractPlotting.ColorLegend</code></pre><pre><code class="language-none">AbstractPlotting.Combined</code></pre><pre><code class="language-none">AbstractPlotting.Continous</code></pre><pre><code class="language-none">AbstractPlotting.Contour</code></pre><pre><code class="language-none">AbstractPlotting.Contour3d</code></pre><pre><code class="language-none">AbstractPlotting.Contours</code></pre><pre><code class="language-none">AbstractPlotting.ContoursHygiene</code></pre><pre><code class="language-none">AbstractPlotting.ConversionTrait</code></pre><pre><code class="language-none">AbstractPlotting.EmptyCamera</code></pre><pre><code class="language-none">AbstractPlotting.Events</code></pre><pre><code class="language-none">AbstractPlotting.FRect</code></pre><pre><code class="language-none">AbstractPlotting.FRect2D</code></pre><pre><code class="language-none">AbstractPlotting.FRect3D</code></pre><pre><code class="language-none">AbstractPlotting.Formatters</code></pre><pre><code class="language-none">AbstractPlotting.GLNormalUVMesh</code></pre><pre><code class="language-none">AbstractPlotting.Heatmap</code></pre><pre><code class="language-none">AbstractPlotting.IRect</code></pre><pre><code class="language-none">AbstractPlotting.IRect2D</code></pre><pre><code class="language-none">AbstractPlotting.IRect3D</code></pre><pre><code class="language-none">AbstractPlotting.Image</code></pre><pre><code class="language-none">AbstractPlotting.ImageLike</code></pre><pre><code class="language-none">AbstractPlotting.IndexedAbsorptionRGBA</code></pre><pre><code class="language-none">AbstractPlotting.IsoValue</code></pre><pre><code class="language-none">AbstractPlotting.Key</code></pre><pre><code class="language-none">AbstractPlotting.Keyboard</code></pre><pre><code class="language-none">AbstractPlotting.Legend</code></pre><pre><code class="language-none">AbstractPlotting.Limits</code></pre><pre><code class="language-none">AbstractPlotting.LineSegments</code></pre><pre><code class="language-none">AbstractPlotting.Lines</code></pre><pre><code class="language-none">AbstractPlotting.LinesegmentBuffer</code></pre><pre><code class="language-none">AbstractPlotting.MaximumIntensityProjection</code></pre><pre><code class="language-none">AbstractPlotting.Mesh</code></pre><pre><code class="language-none">AbstractPlotting.MeshScatter</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Mouse" href="#AbstractPlotting.Mouse"><code>AbstractPlotting.Mouse</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Backend independant Mouse enums and fields</p></div></div></section><pre><code class="language-none">AbstractPlotting.MultiplePlot</code></pre><pre><code class="language-none">AbstractPlotting.NVec</code></pre><pre><code class="language-none">AbstractPlotting.NativeFont</code></pre><pre><code class="language-none">AbstractPlotting.Node</code></pre><pre><code class="language-none">AbstractPlotting.Orthographic</code></pre><pre><code class="language-none">AbstractPlotting.Palette</code></pre><pre><code class="language-none">AbstractPlotting.Perspective</code></pre><pre><code class="language-none">AbstractPlotting.Pivot</code></pre><pre><code class="language-none">AbstractPlotting.PixelCamera</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Plot" href="#AbstractPlotting.Plot"><code>AbstractPlotting.Plot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the Combined type that represents the signature of <code>args</code>.</p></div></div></section><pre><code class="language-none">AbstractPlotting.PlotDisplay</code></pre><pre><code class="language-none">AbstractPlotting.PlotFunc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotList" href="#AbstractPlotting.PlotList"><code>AbstractPlotting.PlotList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Plotlist(plots...)</code></p><p>Experimental feature. Create an object that can encode multiple series.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotSpec" href="#AbstractPlotting.PlotSpec"><code>AbstractPlotting.PlotSpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div></section><pre><code class="language-none">AbstractPlotting.Point</code></pre><pre><code class="language-none">AbstractPlotting.Point2</code></pre><pre><code class="language-none">AbstractPlotting.Point2d</code></pre><pre><code class="language-none">AbstractPlotting.Point2f0</code></pre><pre><code class="language-none">AbstractPlotting.Point3</code></pre><pre><code class="language-none">AbstractPlotting.Point3f0</code></pre><pre><code class="language-none">AbstractPlotting.Point4</code></pre><pre><code class="language-none">AbstractPlotting.Point4f0</code></pre><pre><code class="language-none">AbstractPlotting.PointBased</code></pre><pre><code class="language-none">AbstractPlotting.Pointf0</code></pre><pre><code class="language-none">AbstractPlotting.Poly</code></pre><pre><code class="language-none">AbstractPlotting.Popup</code></pre><pre><code class="language-none">AbstractPlotting.ProjectionEnum</code></pre><pre><code class="language-none">AbstractPlotting.Quaternion</code></pre><pre><code class="language-none">AbstractPlotting.Quaternionf0</code></pre><pre><code class="language-none">AbstractPlotting.RGBAf0</code></pre><pre><code class="language-none">AbstractPlotting.RGBf0</code></pre><pre><code class="language-none">AbstractPlotting.RangeLike</code></pre><pre><code class="language-none">AbstractPlotting.RaymarchAlgorithm</code></pre><pre><code class="language-none">AbstractPlotting.RealVector</code></pre><pre><code class="language-none">AbstractPlotting.RecordEvents</code></pre><pre><code class="language-none">AbstractPlotting.Rect</code></pre><pre><code class="language-none">AbstractPlotting.Rect2D</code></pre><pre><code class="language-none">AbstractPlotting.Rect3D</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Reverse" href="#AbstractPlotting.Reverse"><code>AbstractPlotting.Reverse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reverses the attribute T uppon conversion</p></div></div></section><pre><code class="language-none">AbstractPlotting.SMat</code></pre><pre><code class="language-none">AbstractPlotting.Scatter</code></pre><pre><code class="language-none">AbstractPlotting.ScatterLines</code></pre><pre><code class="language-none">AbstractPlotting.Scene</code></pre><pre><code class="language-none">AbstractPlotting.SceneLike</code></pre><pre><code class="language-none">AbstractPlotting.ScenePlot</code></pre><pre><code class="language-none">AbstractPlotting.Series</code></pre><pre><code class="language-none">AbstractPlotting.Slider</code></pre><pre><code class="language-none">AbstractPlotting.Sphere</code></pre><pre><code class="language-none">AbstractPlotting.Stepper</code></pre><pre><code class="language-none">AbstractPlotting.StreamLines</code></pre><pre><code class="language-none">AbstractPlotting.Surface</code></pre><pre><code class="language-none">AbstractPlotting.SurfaceLike</code></pre><pre><code class="language-none">AbstractPlotting.Text</code></pre><pre><code class="language-none">AbstractPlotting.TextBuffer</code></pre><pre><code class="language-none">AbstractPlotting.TextureAtlas</code></pre><pre><code class="language-none">AbstractPlotting.Theme</code></pre><pre><code class="language-none">AbstractPlotting.Transformable</code></pre><pre><code class="language-none">AbstractPlotting.Transformation</code></pre><pre><code class="language-none">AbstractPlotting.Vec</code></pre><pre><code class="language-none">AbstractPlotting.Vec2</code></pre><pre><code class="language-none">AbstractPlotting.Vec2d</code></pre><pre><code class="language-none">AbstractPlotting.Vec2f0</code></pre><pre><code class="language-none">AbstractPlotting.Vec3</code></pre><pre><code class="language-none">AbstractPlotting.Vec3f0</code></pre><pre><code class="language-none">AbstractPlotting.Vec4</code></pre><pre><code class="language-none">AbstractPlotting.Vec4f0</code></pre><pre><code class="language-none">AbstractPlotting.VecTypes</code></pre><pre><code class="language-none">AbstractPlotting.Vecf0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.VideoStream" href="#AbstractPlotting.VideoStream"><code>AbstractPlotting.VideoStream</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VideoStream(scene::Scene, dir = mktempdir(), name = &quot;video&quot;)</code></pre><p>returns a stream and a buffer that you can use to not allocate for new frames. Use <code>add_frame!(stream, window, buffer)</code> to add new video frames to the stream. Use <code>save(stream)</code> to save the video to &#39;dir/name.mkv&#39;. You can also call <code>save(stream, &quot;mkv&quot;)</code>, <code>save(stream, &quot;mp4&quot;)</code>, <code>save(stream, &quot;gif&quot;)</code> or <code>save(stream, &quot;webm&quot;)</code> to convert the stream to those formats.</p></div></div></section><pre><code class="language-none">AbstractPlotting.Volume</code></pre><pre><code class="language-none">AbstractPlotting.VolumeLike</code></pre><pre><code class="language-none">AbstractPlotting.VolumeSlices</code></pre><pre><code class="language-none">AbstractPlotting.Wireframe</code></pre><pre><code class="language-none">AbstractPlotting.XYBased</code></pre><pre><code class="language-none">AbstractPlotting.__init__</code></pre><pre><code class="language-none">AbstractPlotting._alternative_fonts</code></pre><pre><code class="language-none">AbstractPlotting._cache_path</code></pre><pre><code class="language-none">AbstractPlotting._current_default_theme</code></pre><pre><code class="language-none">AbstractPlotting._default_font</code></pre><pre><code class="language-none">AbstractPlotting._font_cache</code></pre><pre><code class="language-none">AbstractPlotting._forced_update_scheduled</code></pre><pre><code class="language-none">AbstractPlotting._help</code></pre><pre><code class="language-none">AbstractPlotting._isfinite</code></pre><pre><code class="language-none">AbstractPlotting._marker_map</code></pre><pre><code class="language-none">AbstractPlotting._plot!</code></pre><pre><code class="language-none">AbstractPlotting._primary_resolution</code></pre><pre><code class="language-none">AbstractPlotting._tobe_cached</code></pre><pre><code class="language-none">AbstractPlotting._widths</code></pre><pre><code class="language-none">AbstractPlotting.a_length</code></pre><pre><code class="language-none">AbstractPlotting.absrect</code></pre><pre><code class="language-none">AbstractPlotting.add_axis!</code></pre><pre><code class="language-none">AbstractPlotting.add_labels!</code></pre><pre><code class="language-none">AbstractPlotting.add_pan!</code></pre><pre><code class="language-none">AbstractPlotting.add_restriction!</code></pre><pre><code class="language-none">AbstractPlotting.add_rotation!</code></pre><pre><code class="language-none">AbstractPlotting.add_translation!</code></pre><pre><code class="language-none">AbstractPlotting.add_zoom!</code></pre><pre><code class="language-none">AbstractPlotting.align_offset</code></pre><pre><code class="language-none">AbstractPlotting.alignment2num</code></pre><pre><code class="language-none">AbstractPlotting.all_gradient_names</code></pre><pre><code class="language-none">AbstractPlotting.alternativefonts</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations" href="#AbstractPlotting.annotations"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`annotations(strings::Vector{String}, positions::Vector{Point})`</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!" href="#AbstractPlotting.annotations!"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.annotations!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.annotations!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.apply_convert!" href="#AbstractPlotting.apply_convert!"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>apply for return type     (args...,)</p></div></div><div><div><p>apply for return type PlotSpec</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc" href="#AbstractPlotting.arc"><code>AbstractPlotting.arc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arc(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!" href="#AbstractPlotting.arc!"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arc!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arc!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arc!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.argtypes</code></pre><pre><code class="language-none">AbstractPlotting.argument_conversion</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.argument_names" href="#AbstractPlotting.argument_names"><code>AbstractPlotting.argument_names</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Each argument can be named for a certain plot type <code>P</code>. Falls back to <code>arg1</code>, <code>arg2</code>, etc.</p></div></div></section><pre><code class="language-none">AbstractPlotting.arrow_head</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows" href="#AbstractPlotting.arrows"><code>AbstractPlotting.arrows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!" href="#AbstractPlotting.arrows!"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.assemble</code></pre><pre><code class="language-none">AbstractPlotting.assetpath</code></pre><pre><code class="language-none">AbstractPlotting.atomic_function_symbols</code></pre><pre><code class="language-none">AbstractPlotting.atomic_functions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.atomic_limits" href="#AbstractPlotting.atomic_limits"><code>AbstractPlotting.atomic_limits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Data limits calculate a minimal boundingbox from the data points in a plot. This doesn&#39;t include any transformations, markers etc.</p></div></div></section><pre><code class="language-none">AbstractPlotting.attributes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.automatic" href="#AbstractPlotting.automatic"><code>AbstractPlotting.automatic</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Singleton instance to indicate that an attribute will get calculated automatically</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_backends" href="#AbstractPlotting.available_backends"><code>AbstractPlotting.available_backends</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Currently available displays by backend</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_gradients" href="#AbstractPlotting.available_gradients"><code>AbstractPlotting.available_gradients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_marker_symbols" href="#AbstractPlotting.available_marker_symbols"><code>AbstractPlotting.available_marker_symbols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">available_marker_symbols()</code></pre><p>Displays all available marker symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d" href="#AbstractPlotting.axis2d"><code>AbstractPlotting.axis2d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis2d(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d!" href="#AbstractPlotting.axis2d!"><code>AbstractPlotting.axis2d!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d" href="#AbstractPlotting.axis3d"><code>AbstractPlotting.axis3d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis3d(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d!" href="#AbstractPlotting.axis3d!"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.backend_display</code></pre><pre><code class="language-none">AbstractPlotting.backend_show</code></pre><pre><code class="language-none">AbstractPlotting.backend_showable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band" href="#AbstractPlotting.band"><code>AbstractPlotting.band</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.band(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!" href="#AbstractPlotting.band!"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.band!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.band!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.band!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.band_connect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot" href="#AbstractPlotting.barplot"><code>AbstractPlotting.barplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.barplot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!" href="#AbstractPlotting.barplot!"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.bearing</code></pre><pre><code class="language-none">AbstractPlotting.boundingbox</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.broadcast_foreach" href="#AbstractPlotting.broadcast_foreach"><code>AbstractPlotting.broadcast_foreach</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Like broadcast but for foreach. Doesn&#39;t care about shape and treats Tuples &amp;&amp; StaticVectors as scalars.</p></div></div></section><pre><code class="language-none">AbstractPlotting.bs_getindex</code></pre><pre><code class="language-none">AbstractPlotting.bs_length</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button" href="#AbstractPlotting.button"><code>AbstractPlotting.button</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.button(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!" href="#AbstractPlotting.button!"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.button!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.button!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.button!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.button_key</code></pre><pre><code class="language-none">AbstractPlotting.cached_load</code></pre><pre><code class="language-none">AbstractPlotting.cached_logo</code></pre><pre><code class="language-none">AbstractPlotting.calc_drag</code></pre><pre><code class="language-none">AbstractPlotting.calc_offset</code></pre><pre><code class="language-none">AbstractPlotting.calc_position</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!" href="#AbstractPlotting.calculated_attributes!"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`calculated_attributes!(plot::AbstractPlot)`</code></pre><p>Fill in values that can only be calculated when we have all other attributes filled</p></div></div><div><div><pre><code class="language-none">`calculated_attributes!(trait::Type{&lt;: AbstractPlot}, plot)`</code></pre><p>trait version of calculated_attributes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam2d" href="#AbstractPlotting.cam2d"><code>AbstractPlotting.cam2d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a subscene with a pixel camera</p></div></div></section><pre><code class="language-none">AbstractPlotting.cam2d!</code></pre><pre><code class="language-none">AbstractPlotting.cam3d!</code></pre><pre><code class="language-none">AbstractPlotting.camera</code></pre><pre><code class="language-none">AbstractPlotting.cameracontrols</code></pre><pre><code class="language-none">AbstractPlotting.cameracontrols!</code></pre><pre><code class="language-none">AbstractPlotting.campixel</code></pre><pre><code class="language-none">AbstractPlotting.campixel!</code></pre><pre><code class="language-none">AbstractPlotting.camspace</code></pre><pre><code class="language-none">AbstractPlotting.categoric_labels</code></pre><pre><code class="language-none">AbstractPlotting.categoric_position</code></pre><pre><code class="language-none">AbstractPlotting.categoric_range</code></pre><pre><code class="language-none">AbstractPlotting.categorical_trait</code></pre><pre><code class="language-none">AbstractPlotting.center!</code></pre><pre><code class="language-none">AbstractPlotting.child</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.close2square" href="#AbstractPlotting.close2square"><code>AbstractPlotting.close2square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns (N1, N2) with <code>N1 x N2 == n</code>. N2 might become 1</p></div></div></section><pre><code class="language-none">AbstractPlotting.close_all_nodes</code></pre><pre><code class="language-none">AbstractPlotting.color_and_colormap!</code></pre><pre><code class="language-none">AbstractPlotting.colorbrewer_8color_names</code></pre><pre><code class="language-none">AbstractPlotting.colorbrewer_names</code></pre><pre><code class="language-none">AbstractPlotting.colorbuffer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend" href="#AbstractPlotting.colorlegend"><code>AbstractPlotting.colorlegend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colorlegend(scene, colormap, range)</code></pre><p>creates a legend from a colormap</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!" href="#AbstractPlotting.colorlegend!"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.colorlegend!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.colorlegend!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.colorswatch</code></pre><pre><code class="language-none">AbstractPlotting.combine</code></pre><pre><code class="language-none">AbstractPlotting.combine!</code></pre><pre><code class="language-none">AbstractPlotting.combined_modelmatrix</code></pre><pre><code class="language-none">AbstractPlotting.concrete_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour" href="#AbstractPlotting.contour"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contour(x, y, z)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!" href="#AbstractPlotting.contour!"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d" href="#AbstractPlotting.contour3d"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!" href="#AbstractPlotting.contour3d!"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour3d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour3d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.contourlines</code></pre><pre><code class="language-none">AbstractPlotting.conversion_trait</code></pre><pre><code class="language-none">AbstractPlotting.convert_argument</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments" href="#AbstractPlotting.convert_arguments"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p></div></div><div><div><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y)::(Vector)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and turns it into a vector of 2D points of the values from <code>x</code> and <code>y</code>.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals&#39;s <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(x)::(String)</code></pre><p>Takes an input <code>AbstractString</code> <code>x</code> and converts it to a string.</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>HyperRectangle</code> <code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>Takes 3 <code>AbstractMatrix</code> <code>x</code>, <code>y</code>, and <code>z</code>, converts them to <code>Float32</code> and outputs them in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y&#39;)</code>. <code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code> <code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div><div><pre><code class="language-none">convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p></div></div><div><div><pre><code class="language-none">convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p></div></div><div><div><pre><code class="language-none">convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryTypes.Face{N, &lt;: Integer}.</p></div></div><div><div><pre><code class="language-none">convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref">to_vertices</a> and <a href="@ref">to_triangles</a> for more informations about accepted types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`AbstractVector{&lt;:AbstractFloat}` for denoting sequences of fill/nofill. e.g.</code></pre><p>[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!</p></div></div><div><div><pre><code class="language-none">A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`</code></pre></div></div><div><div><pre><code class="language-none">Text align, e.g.:</code></pre></div></div><div><div><pre><code class="language-none">font conversion</code></pre><p>a string naming a font, e.g. helvetica</p></div></div><div><div><pre><code class="language-none">rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div></div><div><div><pre><code class="language-none">to_colormap(b, x)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="#AbstractPlotting.to_color"><code>to_color</code></a> accepts.</p></div></div><div><div><p>Tuple(A, B) or Pair{A, B} with any object that <a href="#AbstractPlotting.to_color"><code>to_color</code></a> accepts</p></div></div><div><div><p>A Symbol/String naming the gradient. For more on what names are available please see: `available_gradients()</p></div></div><div><div><pre><code class="language-none">to_volume_algorithm(b, x)</code></pre><p>Enum values: <code>IsoValue</code> <code>Absorption</code> <code>MaximumIntensityProjection</code> <code>AbsorptionRGBA</code> <code>IndexedAbsorptionRGBA</code></p></div></div><div><div><p>Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption</p></div></div></section><pre><code class="language-none">AbstractPlotting.correct_ratio!</code></pre><pre><code class="language-none">AbstractPlotting.current_backend</code></pre><pre><code class="language-none">AbstractPlotting.current_default_theme</code></pre><pre><code class="language-none">AbstractPlotting.current_global_scene</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.current_scene" href="#AbstractPlotting.current_scene"><code>AbstractPlotting.current_scene</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the current active scene (the last scene that got created)</p></div></div></section><pre><code class="language-none">AbstractPlotting.data_limits</code></pre><pre><code class="language-none">AbstractPlotting.decompose</code></pre><pre><code class="language-none">AbstractPlotting.default_labels</code></pre><pre><code class="language-none">AbstractPlotting.default_palettes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.default_plot_signatures" href="#AbstractPlotting.default_plot_signatures"><code>AbstractPlotting.default_plot_signatures</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> default_plot_signatures(funcname, PlotType)</code></pre><p>Creates all the different overloads for <code>funcname</code> that need to be supported for the plotting frontend! Since we add all these signatures to different functions, we make it reusable with this function</p></div></div></section><pre><code class="language-none">AbstractPlotting.default_printer</code></pre><pre><code class="language-none">AbstractPlotting.default_theme</code></pre><pre><code class="language-none">AbstractPlotting.default_ticks</code></pre><pre><code class="language-none">AbstractPlotting.defaultfont</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.detach!" href="#AbstractPlotting.detach!"><code>AbstractPlotting.detach!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove <code>combined</code> from the current parent, and add it to a new subscene of the parent scene. Returns the new parent.</p></div></div></section><pre><code class="language-none">AbstractPlotting.dim2</code></pre><pre><code class="language-none">AbstractPlotting.dim3</code></pre><pre><code class="language-none">AbstractPlotting.disconnect!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.dont_touch" href="#AbstractPlotting.dont_touch"><code>AbstractPlotting.dont_touch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Moves <code>child</code> so that it doesn&#39;t touch parent. Leaves a gap to parent defined by <code>pad</code>.</p></div></div></section><pre><code class="language-none">AbstractPlotting.dragslider</code></pre><pre><code class="language-none">AbstractPlotting.draw_axis2d</code></pre><pre><code class="language-none">AbstractPlotting.draw_axis3d</code></pre><pre><code class="language-none">AbstractPlotting.draw_frame</code></pre><pre><code class="language-none">AbstractPlotting.draw_grid</code></pre><pre><code class="language-none">AbstractPlotting.draw_ticks</code></pre><pre><code class="language-none">AbstractPlotting.draw_titles</code></pre><pre><code class="language-none">AbstractPlotting.dropped_files</code></pre><pre><code class="language-none">AbstractPlotting.el32convert</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.elconvert" href="#AbstractPlotting.elconvert"><code>AbstractPlotting.elconvert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Converts the elemen array type to <code>T1</code> without making a copy if the element type matches</p></div></div></section><pre><code class="language-none">AbstractPlotting.enable_ith</code></pre><pre><code class="language-none">AbstractPlotting.entered_window</code></pre><pre><code class="language-none">AbstractPlotting.estimated_space</code></pre><pre><code class="language-none">AbstractPlotting.eval</code></pre><pre><code class="language-none">AbstractPlotting.events</code></pre><pre><code class="language-none">AbstractPlotting.extract_expr</code></pre><pre><code class="language-none">AbstractPlotting.extrema_nan</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fill_between!" href="#AbstractPlotting.fill_between!"><code>AbstractPlotting.fill_between!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div></section><pre><code class="language-none">AbstractPlotting.fill_view</code></pre><pre><code class="language-none">AbstractPlotting.find_closest</code></pre><pre><code class="language-none">AbstractPlotting.find_in_plots</code></pre><pre><code class="language-none">AbstractPlotting.finish!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor" href="#AbstractPlotting.fit_factor"><code>AbstractPlotting.fit_factor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fit_factor(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the scaling one needs to apply to lims to fit <code>rect</code> without changing aspect ratio. Returns float scaling and the full strech as given by <a href="#AbstractPlotting.fit_factor_stretch"><code>fit_factor_stretch</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor_stretch" href="#AbstractPlotting.fit_factor_stretch"><code>AbstractPlotting.fit_factor_stretch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fit_factor_stretch(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the stretch factor to fill <code>rect</code> in all dimension. Returns a stretch <code>N</code> dimensional fit factor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_ratio" href="#AbstractPlotting.fit_ratio"><code>AbstractPlotting.fit_ratio</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fit_ratio(rect, lims)</code></pre><p>Calculates the ratio one needs to stretch <code>lims</code> in order to get the same aspect ratio</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.flatten_combined" href="#AbstractPlotting.flatten_combined"><code>AbstractPlotting.flatten_combined</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flattens all the combined plots and returns a Vector of Atomic plots</p></div></div></section><pre><code class="language-none">AbstractPlotting.float32type</code></pre><pre><code class="language-none">AbstractPlotting.font_render_callback!</code></pre><pre><code class="language-none">AbstractPlotting.font_render_callbacks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.force_update!" href="#AbstractPlotting.force_update!"><code>AbstractPlotting.force_update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Forces to rerender the scnee</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.from_dict" href="#AbstractPlotting.from_dict"><code>AbstractPlotting.from_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">from_dict(::Type{T}, dict)</code></pre><p>Creates the type <code>T</code> from the fields in dict. Automatically converts to the correct node types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.frustum" href="#AbstractPlotting.frustum"><code>AbstractPlotting.frustum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Create view frustum

Parameters
----------
    left : float
     Left coordinate of the field of view.
    right : float
     Left coordinate of the field of view.
    bottom : float
     Bottom coordinate of the field of view.
    top : float
     Top coordinate of the field of view.
    znear : float
     Near coordinate of the field of view.
    zfar : float
     Far coordinate of the field of view.

Returns
-------
    M : array
     View frustum matrix (4x4).</code></pre></div></div></section><pre><code class="language-none">AbstractPlotting.func2string</code></pre><pre><code class="language-none">AbstractPlotting.func2type</code></pre><pre><code class="language-none">AbstractPlotting.get_attribute</code></pre><pre><code class="language-none">AbstractPlotting.get_iter</code></pre><pre><code class="language-none">AbstractPlotting.get_texture_atlas</code></pre><pre><code class="language-none">AbstractPlotting.getindex_value</code></pre><pre><code class="language-none">AbstractPlotting.getoffsets</code></pre><pre><code class="language-none">AbstractPlotting.getposition</code></pre><pre><code class="language-none">AbstractPlotting.global_texture_atlas</code></pre><pre><code class="language-none">AbstractPlotting.glyph_advance!</code></pre><pre><code class="language-none">AbstractPlotting.glyph_bearing!</code></pre><pre><code class="language-none">AbstractPlotting.glyph_extent!</code></pre><pre><code class="language-none">AbstractPlotting.glyph_index!</code></pre><pre><code class="language-none">AbstractPlotting.glyph_scale!</code></pre><pre><code class="language-none">AbstractPlotting.glyph_uv_width!</code></pre><pre><code class="language-none">AbstractPlotting.grid</code></pre><pre><code class="language-none">AbstractPlotting.has_ffmpeg</code></pre><pre><code class="language-none">AbstractPlotting.hasfield</code></pre><pre><code class="language-none">AbstractPlotting.hasfocus</code></pre><pre><code class="language-none">AbstractPlotting.hbox</code></pre><pre><code class="language-none">AbstractPlotting.hbox!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap" href="#AbstractPlotting.heatmap"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`heatmap(x, y, values)` or `heatmap(values)`</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!" href="#AbstractPlotting.heatmap!"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.heatmap!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.heatmap!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help" href="#AbstractPlotting.help"><code>AbstractPlotting.help</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>AbstractPlotting.jl</code>.</p><p>For help on a specific function&#39;s arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function&#39;s attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_arguments" href="#AbstractPlotting.help_arguments"><code>AbstractPlotting.help_arguments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_attributes" href="#AbstractPlotting.help_attributes"><code>AbstractPlotting.help_attributes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-example">&gt;help_attributes(scatter)
	alpha
	color
	colormap
	colorrange
	distancefield
	glowcolor
	glowwidth
	linewidth
	marker
	marker_offset
	markersize
	overdraw
	rotations
	strokecolor
	strokewidth
	transform_marker
	transparency
	uv_offset_width
	visible</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.hovered_scene" href="#AbstractPlotting.hovered_scene"><code>AbstractPlotting.hovered_scene</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hovered_scene()</code></pre><p>Return the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div></section><pre><code class="language-none">AbstractPlotting.icon</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image" href="#AbstractPlotting.image"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`image(x, y, image)` / `image(image)`</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!" href="#AbstractPlotting.image!"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.image!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.image!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.image!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.image!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.image!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.include</code></pre><pre><code class="language-none">AbstractPlotting.inline!</code></pre><pre><code class="language-none">AbstractPlotting.insert_glyph!</code></pre><pre><code class="language-none">AbstractPlotting.insertplots!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.interpolated_getindex" href="#AbstractPlotting.interpolated_getindex"><code>AbstractPlotting.interpolated_getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">interpolated_getindex(cmap::AbstractArray, value::AbstractFloat, norm = (0.0, 1.0))</code></pre><p>Like getindex, but accepts values between 0..1 and interpolates those to the full range. You can use <code>norm</code>, to change the range of 0..1 to whatever you want.</p></div></div></section><pre><code class="language-none">AbstractPlotting.io_lock</code></pre><pre><code class="language-none">AbstractPlotting.is2d</code></pre><pre><code class="language-none">AbstractPlotting.is_mouseinside</code></pre><pre><code class="language-none">AbstractPlotting.is_unitrange</code></pre><pre><code class="language-none">AbstractPlotting.isaxis</code></pre><pre><code class="language-none">AbstractPlotting.isnewline</code></pre><pre><code class="language-none">AbstractPlotting.ispixelcam</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.ispressed" href="#AbstractPlotting.ispressed"><code>AbstractPlotting.ispressed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>returns true if <code>button</code> is pressed in scene[:mousebuttons or :keyboardbuttons] You can use nothing, to indicate it should always return true</p></div></div></section><pre><code class="language-none">AbstractPlotting.isroot</code></pre><pre><code class="language-none">AbstractPlotting.isvisible</code></pre><pre><code class="language-none">AbstractPlotting.iter_or_array</code></pre><pre><code class="language-none">AbstractPlotting.keyboard_buttons</code></pre><pre><code class="language-none">AbstractPlotting.labelposition</code></pre><pre><code class="language-none">AbstractPlotting.layout</code></pre><pre><code class="language-none">AbstractPlotting.layout_sizes</code></pre><pre><code class="language-none">AbstractPlotting.layout_text</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend" href="#AbstractPlotting.legend"><code>AbstractPlotting.legend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.legend(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!" href="#AbstractPlotting.legend!"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.legend!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.legend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.legend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.lerp</code></pre><pre><code class="language-none">AbstractPlotting.lift</code></pre><pre><code class="language-none">AbstractPlotting.limits</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines" href="#AbstractPlotting.lines"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`lines(x, y, z)` / `lines(x, y)` / or `lines(positions)`</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!" href="#AbstractPlotting.lines!"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.lines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.lines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.lines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.lines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.lines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments" href="#AbstractPlotting.linesegments"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`linesegments(x, y, z)` / `linesegments(x, y)` / `linesegments(positions)`</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong>: The same as for <a href="#AbstractPlotting.lines"><code>lines</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!" href="#AbstractPlotting.linesegments!"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.linesegments!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.linesegments!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.log_info</code></pre><pre><code class="language-none">AbstractPlotting.log_level</code></pre><pre><code class="language-none">AbstractPlotting.logging_io</code></pre><pre><code class="language-none">AbstractPlotting.logo</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lookat" href="#AbstractPlotting.lookat"><code>AbstractPlotting.lookat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>view = lookat(eyeposition, lookat, up)</code> creates a view matrix with the eye located at <code>eyeposition</code> and looking at position <code>lookat</code>, with the top of the window corresponding to the direction <code>up</code>. Only the component of <code>up</code> that is perpendicular to the vector pointing from <code>eyeposition</code> to <code>lookat</code> will be used.  All inputs must be supplied as 3-vectors.</p></div></div></section><pre><code class="language-none">AbstractPlotting.make_iter</code></pre><pre><code class="language-none">AbstractPlotting.make_label</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.map_once" href="#AbstractPlotting.map_once"><code>AbstractPlotting.map_once</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map_once(closure, inputs::Node....)::Node</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.</p><p>``` function test(s1::Node)     s3 = map<em>once(x-&gt; (println(&quot;1 &quot;, x); x), s1)     s3 = map</em>once(x-&gt; (println(&quot;2 &quot;, x); x), s1)</p><p>end test(Node(1), Node(2))</p><blockquote></blockquote></div></div></section><pre><code class="language-none">AbstractPlotting.merge_attributes!</code></pre><pre><code class="language-none">AbstractPlotting.merge_attributes_doublebang!</code></pre><pre><code class="language-none">AbstractPlotting.merged_get!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys" href="#AbstractPlotting.mergekeys"><code>AbstractPlotting.mergekeys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mergekeys(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>. Creates a copy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys!" href="#AbstractPlotting.mergekeys!"><code>AbstractPlotting.mergekeys!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mergekeys!(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh" href="#AbstractPlotting.mesh"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`mesh(x, y, z)`, `mesh(mesh_object)`, `mesh(x, y, z, faces)`, or `mesh(xyz, faces)`</code></pre><p>Plots a 3D mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!" href="#AbstractPlotting.mesh!"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.mesh!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.mesh!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter" href="#AbstractPlotting.meshscatter"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`meshscatter(x, y, z)` / `meshscatter(x, y)` / `meshscatter(positions)`</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!" href="#AbstractPlotting.meshscatter!"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.meshscatter!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.meshscatter!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.minimal_default</code></pre><pre><code class="language-none">AbstractPlotting.modelmatrix</code></pre><pre><code class="language-none">AbstractPlotting.mouse_buttons</code></pre><pre><code class="language-none">AbstractPlotting.mouse_in_scene</code></pre><pre><code class="language-none">AbstractPlotting.mouse_position</code></pre><pre><code class="language-none">AbstractPlotting.mouse_selection</code></pre><pre><code class="language-none">AbstractPlotting.mousedrag</code></pre><pre><code class="language-none">AbstractPlotting.mouseover</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouseposition" href="#AbstractPlotting.mouseposition"><code>AbstractPlotting.mouseposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mouseposition(scene = hovered_scene()) -&gt; pos</code></pre><p>Return the current position of the mouse <code>pos</code> in <em>data points</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div></section><pre><code class="language-none">AbstractPlotting.move!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.move_from_touch" href="#AbstractPlotting.move_from_touch"><code>AbstractPlotting.move_from_touch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>calculates how much <code>child</code> rectangle needs to move to not touch the <code>parent</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot" href="#AbstractPlotting.multipleplot"><code>AbstractPlotting.multipleplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot!" href="#AbstractPlotting.multipleplot!"><code>AbstractPlotting.multipleplot!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.must_update" href="#AbstractPlotting.must_update"><code>AbstractPlotting.must_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns wether a scene needs updating</p></div></div></section><pre><code class="language-none">AbstractPlotting.mutual_exclusive_attributes</code></pre><pre><code class="language-none">AbstractPlotting.nan_extrema</code></pre><pre><code class="language-none">AbstractPlotting.ngrid</code></pre><pre><code class="language-none">AbstractPlotting.node</code></pre><pre><code class="language-none">AbstractPlotting.node_pairs</code></pre><pre><code class="language-none">AbstractPlotting.not_implemented_for</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.notify!" href="#AbstractPlotting.notify!"><code>AbstractPlotting.notify!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pushes an updates to all listeners of <code>node</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.on" href="#Observables.on"><code>Observables.on</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">on(f, c::Camera, nodes::Node...)</code></pre><p>When mapping over nodes for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.onpick" href="#AbstractPlotting.onpick"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code></p></div></div></section><pre><code class="language-none">AbstractPlotting.orthogonal</code></pre><pre><code class="language-none">AbstractPlotting.orthographicprojection</code></pre><pre><code class="language-none">AbstractPlotting.otherdim</code></pre><pre><code class="language-none">AbstractPlotting.outerbox</code></pre><pre><code class="language-none">AbstractPlotting.padrect</code></pre><pre><code class="language-none">AbstractPlotting.parent_or_self</code></pre><pre><code class="language-none">AbstractPlotting.parent_scene</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection" href="#AbstractPlotting.perspectiveprojection"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>proj = perspectiveprojection([T], fovy, aspect, znear, zfar)</code> defines a projection matrix with a given angular field-of-view <code>fovy</code> along the y-axis (measured in degrees), the specified <code>aspect</code> ratio, and near and far clipping planes <code>znear</code>, <code>zfar</code>. Optionally specify the element type <code>T</code> of the matrix.</p></div></div><div><div><p><code>proj = perspectiveprojection([T], rect, fov, near, far)</code> defines the projection ratio in terms of the rectangular view size <code>rect</code> rather than the aspect ratio.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.pick" href="#AbstractPlotting.pick"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Picks a mouse position</p></div></div></section><pre><code class="language-none">AbstractPlotting.pixel_boundingbox</code></pre><pre><code class="language-none">AbstractPlotting.pixelarea</code></pre><pre><code class="language-none">AbstractPlotting.playbutton</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot" href="#AbstractPlotting.plot"><code>AbstractPlotting.plot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.plot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!" href="#AbstractPlotting.plot!"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.plot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.plot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.plot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div><div><div><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div></div><div><div><pre><code class="language-none">`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p></div></div></section><pre><code class="language-none">AbstractPlotting.plotfunc</code></pre><pre><code class="language-none">AbstractPlotting.plotkey</code></pre><pre><code class="language-none">AbstractPlotting.plots</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plots_from_camera" href="#AbstractPlotting.plots_from_camera"><code>AbstractPlotting.plots_from_camera</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Fetches all plots sharing the same camera</p></div></div></section><pre><code class="language-none">AbstractPlotting.plotsym</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plottype" href="#AbstractPlotting.plottype"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`plot_type(plot_args...)`</code></pre><p>The default plot type for any argument is <code>lines</code>. Any custom argument combination that has only one meaningful way to be plotted should overload this. e.g.:</p><pre><code class="language-example">    # make plot(rand(5, 5, 5)) plot as a volume
    plottype(x::Array{&lt;: AbstractFlot, 3}) = Volume</code></pre></div></div><div><div><pre><code class="language-none">plottype(P1::Type{&lt;: Combined{T1}}, P2::Type{&lt;: Combined{T2}})</code></pre><p>Chooses the more concrete plot type ```example function convert_arguments(P::PlotFunc, args...)     ptype = plottype(P, Lines)     ... end</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly" href="#AbstractPlotting.poly"><code>AbstractPlotting.poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.poly(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!" href="#AbstractPlotting.poly!"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.poly!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.poly!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.poly!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.popup</code></pre><pre><code class="language-none">AbstractPlotting.positive_widths</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.primary_resolution" href="#AbstractPlotting.primary_resolution"><code>AbstractPlotting.primary_resolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the resolution of the primary monitor. If the primary monitor can&#39;t be accessed, returns (1920, 1080) (full hd)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.print_rec" href="#AbstractPlotting.print_rec"><code>AbstractPlotting.print_rec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">print_rec(io::IO, dict, indent::Int = 1[; extended = false])</code></pre><p>Traverses a dictionary <code>dict</code> and recursively print out its keys and values in a nicely-indented format.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div></section><pre><code class="language-none">AbstractPlotting.print_stats</code></pre><pre><code class="language-none">AbstractPlotting.project</code></pre><pre><code class="language-none">AbstractPlotting.project_widths</code></pre><pre><code class="language-none">AbstractPlotting.projection_switch</code></pre><pre><code class="language-none">AbstractPlotting.qrotation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.quiver" href="#AbstractPlotting.quiver"><code>AbstractPlotting.quiver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.quiver!" href="#AbstractPlotting.quiver!"><code>AbstractPlotting.quiver!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.range_label_bb</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.raw_boundingbox" href="#AbstractPlotting.raw_boundingbox"><code>AbstractPlotting.raw_boundingbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the exact boundingbox of a Scene/Plot, without considering any transformation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.reasonable_resolution" href="#AbstractPlotting.reasonable_resolution"><code>AbstractPlotting.reasonable_resolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a reasonable resolution for the main monitor. (right now just half the resolution of the main monitor)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record" href="#AbstractPlotting.record"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">record(func, scene, path)</code></pre><p>usage:</p><pre><code class="language-example">    record(scene, &quot;test.gif&quot;) do io
        for i = 1:100
            scene.plots[:color] = ...# animate scene
            recordframe!(io) # record a new frame
        end
    end</code></pre></div></div><div><div><pre><code class="language-none">record(func, scene, path, iter)</code></pre><p>usage:</p><pre><code class="language-example">    record(scene, &quot;test.gif&quot;, 1:100) do i
        scene.plots[:color] = ...# animate scene
    end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record_events" href="#AbstractPlotting.record_events"><code>AbstractPlotting.record_events</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Record all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.recordframe!" href="#AbstractPlotting.recordframe!"><code>AbstractPlotting.recordframe!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Adds a video frame to the VideoStream</p></div></div></section><pre><code class="language-none">AbstractPlotting.register_backend!</code></pre><pre><code class="language-none">AbstractPlotting.register_callbacks</code></pre><pre><code class="language-none">AbstractPlotting.remove_font_render_callback!</code></pre><pre><code class="language-none">AbstractPlotting.render</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replace_automatic!" href="#AbstractPlotting.replace_automatic!"><code>AbstractPlotting.replace_automatic!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replay_events" href="#AbstractPlotting.replay_events"><code>AbstractPlotting.replay_events</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resample" href="#AbstractPlotting.resample"><code>AbstractPlotting.resample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resample(A::AbstractVector, len::Integer)</code></pre><p>Resample a vector with linear interpolation to have length <code>len</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resampled_colors" href="#AbstractPlotting.resampled_colors"><code>AbstractPlotting.resampled_colors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resampled_colors(attributes::Attributes, levels::Integer)</code></pre><p>Resample the color attribute from <code>attributes</code>. Resamples <code>:colormap</code> if present, or repeats <code>:color</code>.</p></div></div></section><pre><code class="language-none">AbstractPlotting.reset!</code></pre><pre><code class="language-none">AbstractPlotting.root</code></pre><pre><code class="language-none">AbstractPlotting.rootparent</code></pre><pre><code class="language-none">AbstractPlotting.rotate</code></pre><pre><code class="language-none">AbstractPlotting.rotate!</code></pre><pre><code class="language-none">AbstractPlotting.rotate_cam</code></pre><pre><code class="language-none">AbstractPlotting.rotate_cam!</code></pre><pre><code class="language-none">AbstractPlotting.rotation</code></pre><pre><code class="language-none">AbstractPlotting.rotation_between</code></pre><pre><code class="language-none">AbstractPlotting.rotationmatrix4</code></pre><pre><code class="language-none">AbstractPlotting.rotationmatrix_x</code></pre><pre><code class="language-none">AbstractPlotting.rotationmatrix_y</code></pre><pre><code class="language-none">AbstractPlotting.rotationmatrix_z</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.safe_off" href="#AbstractPlotting.safe_off"><code>AbstractPlotting.safe_off</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Observables.off but without throwing an error</p></div></div></section><pre><code class="language-none">AbstractPlotting.same_length_array</code></pre><pre><code class="language-none">AbstractPlotting.sample_color</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.save" href="#AbstractPlotting.save"><code>AbstractPlotting.save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">save(path::String, io::VideoStream)</code></pre><p>Flushes the video stream and converts the file to the extension found in <code>path</code> which can be <code>mkv</code> is default and doesn&#39;t need convert, <code>gif</code>, <code>mp4</code> and <code>webm</code>. <code>mp4</code> is recommended for the internet, since it&#39;s the most supported format. <code>webm</code> yields the smallest file size, <code>mp4</code> and <code>mk4</code> are marginally bigger and <code>gif</code>s are up to 6 times bigger with same quality!</p></div></div></section><pre><code class="language-none">AbstractPlotting.save_print</code></pre><pre><code class="language-none">AbstractPlotting.scalarmax</code></pre><pre><code class="language-none">AbstractPlotting.scalarmin</code></pre><pre><code class="language-none">AbstractPlotting.scale</code></pre><pre><code class="language-none">AbstractPlotting.scale!</code></pre><pre><code class="language-none">AbstractPlotting.scale_scene!</code></pre><pre><code class="language-none">AbstractPlotting.scaled_width</code></pre><pre><code class="language-none">AbstractPlotting.scalematrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter" href="#AbstractPlotting.scatter"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`scatter(x, y, z)` / `scatter(x, y)` / `scatter(positions)`</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!" href="#AbstractPlotting.scatter!"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatter!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatter!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.scatterfun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines" href="#AbstractPlotting.scatterlines"><code>AbstractPlotting.scatterlines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!" href="#AbstractPlotting.scatterlines!"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.scroll</code></pre><pre><code class="language-none">AbstractPlotting.sdistancefield</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.select_rectangle" href="#AbstractPlotting.select_rectangle"><code>AbstractPlotting.select_rectangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong> <code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div></section><pre><code class="language-none">AbstractPlotting.selection_rect!</code></pre><pre><code class="language-none">AbstractPlotting.seperate_tuple</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series" href="#AbstractPlotting.series"><code>AbstractPlotting.series</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.series(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!" href="#AbstractPlotting.series!"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.series!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.series!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.series!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.set_theme!</code></pre><pre><code class="language-none">AbstractPlotting.setup_camera!</code></pre><pre><code class="language-none">AbstractPlotting.signal_convert</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider" href="#AbstractPlotting.slider"><code>AbstractPlotting.slider</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.slider(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!" href="#AbstractPlotting.slider!"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.slider!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.slider!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.slider!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.sphere_streamline</code></pre><pre><code class="language-none">AbstractPlotting.start!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.step!" href="#AbstractPlotting.step!"><code>AbstractPlotting.step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">step!(s::Stepper)</code></pre><p>steps through a <code>Makie.Stepper</code> and outputs a file with filename <code>filename-step.jpg</code>. This is useful for generating progressive plot examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines" href="#AbstractPlotting.streamlines"><code>AbstractPlotting.streamlines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.streamlines(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!" href="#AbstractPlotting.streamlines!"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface" href="#AbstractPlotting.surface"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`surface(x, y, z)`</code></pre><p>Plots a surface, where <code>(x, y, z)</code> are supposed to lie on a grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!" href="#AbstractPlotting.surface!"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.surface!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.surface!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.surface!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.surface!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.surface!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text" href="#AbstractPlotting.text"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`text(string)`</code></pre><p>Plots a text.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!" href="#AbstractPlotting.text!"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.text!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.text!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.text!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.text!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.text!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.text_bb</code></pre><pre><code class="language-none">AbstractPlotting.text_limits</code></pre><pre><code class="language-none">AbstractPlotting.textslider</code></pre><pre><code class="language-none">AbstractPlotting.theme</code></pre><pre><code class="language-none">AbstractPlotting.ticks_and_labels</code></pre><pre><code class="language-none">AbstractPlotting.to2tuple</code></pre><pre><code class="language-none">AbstractPlotting.to3tuple</code></pre><pre><code class="language-none">AbstractPlotting.to_2d_scale</code></pre><pre><code class="language-none">AbstractPlotting.to_3d_scale</code></pre><pre><code class="language-none">AbstractPlotting.to_align</code></pre><pre><code class="language-none">AbstractPlotting.to_cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_color" href="#AbstractPlotting.to_color"><code>AbstractPlotting.to_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_color(color)</code></pre><p>Converts a <code>color</code> symbol (e.g. <code>:blue</code>) to a color RGBA.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_colormap" href="#AbstractPlotting.to_colormap"><code>AbstractPlotting.to_colormap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_colormap(cm[, N = 20])</code></pre><p>Converts a colormap <code>cm</code> symbol (e.g. <code>:Spectral</code>) to a colormap RGB array, where <code>N</code> specifies the number of color points.</p></div></div></section><pre><code class="language-none">AbstractPlotting.to_font</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_func" href="#AbstractPlotting.to_func"><code>AbstractPlotting.to_func</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_func(Typ)</code></pre><p>Maps the input of a Type name to its cooresponding function.</p></div></div></section><pre><code class="language-none">AbstractPlotting.to_func_name</code></pre><pre><code class="language-none">AbstractPlotting.to_image</code></pre><pre><code class="language-none">AbstractPlotting.to_levels</code></pre><pre><code class="language-none">AbstractPlotting.to_linspace</code></pre><pre><code class="language-none">AbstractPlotting.to_ndim</code></pre><pre><code class="language-none">AbstractPlotting.to_node</code></pre><pre><code class="language-none">AbstractPlotting.to_plotspec</code></pre><pre><code class="language-none">AbstractPlotting.to_rotation</code></pre><pre><code class="language-none">AbstractPlotting.to_screen</code></pre><pre><code class="language-none">AbstractPlotting.to_sizes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker" href="#AbstractPlotting.to_spritemarker"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_spritemarker(b, x::Circle)</code></pre><p><code>GeometryTypes.Circle(Point2(...), radius)</code></p></div></div><div><div><pre><code class="language-none">to_spritemarker(b, ::Type{Circle})</code></pre><p><code>Type{GeometryTypes.Circle}</code></p></div></div><div><div><pre><code class="language-none">to_spritemarker(b, ::Type{Rectangle})</code></pre><p><code>Type{GeometryTypes.Rectangle}</code></p></div></div><div><div><pre><code class="language-none">to_spritemarker(b, marker::Char)</code></pre><p>Any <code>Char</code>, including unicode</p></div></div><div><div><p>Matrix of AbstractFloat will be interpreted as a distancefield (negative numbers outside shape, positive inside)</p></div></div><div><div><p>Any AbstractMatrix{&lt;: Colorant} or other image type</p></div></div><div><div><p>A <code>Symbol</code> - Available options can be printed with <code>available_marker_symbols()</code></p></div></div><div><div><p>Vector of anything that is accepted as a single marker will give each point it&#39;s own marker. Note that it needs to be a uniform vector with the same element type!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_string" href="#AbstractPlotting.to_string"><code>AbstractPlotting.to_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_string(func)</code></pre><p>Turns the input of a function name or plot Type into a string.</p></div></div></section><pre><code class="language-none">AbstractPlotting.to_textsize</code></pre><pre><code class="language-none">AbstractPlotting.to_triangles</code></pre><pre><code class="language-none">AbstractPlotting.to_tuple</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_type" href="#AbstractPlotting.to_type"><code>AbstractPlotting.to_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">to_type(func)</code></pre><p>Maps the input of a function name to its cooresponding Type.</p></div></div></section><pre><code class="language-none">AbstractPlotting.to_value</code></pre><pre><code class="language-none">AbstractPlotting.to_vector</code></pre><pre><code class="language-none">AbstractPlotting.to_vertices</code></pre><pre><code class="language-none">AbstractPlotting.to_world</code></pre><pre><code class="language-none">AbstractPlotting.transform</code></pre><pre><code class="language-none">AbstractPlotting.transform!</code></pre><pre><code class="language-none">AbstractPlotting.transformation</code></pre><pre><code class="language-none">AbstractPlotting.transformationmatrix</code></pre><pre><code class="language-none">AbstractPlotting.translate!</code></pre><pre><code class="language-none">AbstractPlotting.translate_cam!</code></pre><pre><code class="language-none">AbstractPlotting.translated</code></pre><pre><code class="language-none">AbstractPlotting.translation</code></pre><pre><code class="language-none">AbstractPlotting.translationmatrix</code></pre><pre><code class="language-none">AbstractPlotting.translationmatrix_x</code></pre><pre><code class="language-none">AbstractPlotting.translationmatrix_y</code></pre><pre><code class="language-none">AbstractPlotting.translationmatrix_z</code></pre><pre><code class="language-none">AbstractPlotting.un_transform</code></pre><pre><code class="language-none">AbstractPlotting.unicode_input</code></pre><pre><code class="language-none">AbstractPlotting.update!</code></pre><pre><code class="language-none">AbstractPlotting.update_cam!</code></pre><pre><code class="language-none">AbstractPlotting.update_limits!</code></pre><pre><code class="language-none">AbstractPlotting.use_display</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.used_attributes" href="#AbstractPlotting.used_attributes"><code>AbstractPlotting.used_attributes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">used_attributes(args...) = ()</code></pre><p>function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Usage:</p><pre><code class="language-example">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn&#39;t happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_argumetns(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div></section><pre><code class="language-none">AbstractPlotting.value_convert</code></pre><pre><code class="language-none">AbstractPlotting.vbox</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume" href="#AbstractPlotting.volume"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`volume(volume_data)`</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!" href="#AbstractPlotting.volume!"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volume!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volume!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volume!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volume!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volume!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices" href="#AbstractPlotting.volumeslices"><code>AbstractPlotting.volumeslices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!" href="#AbstractPlotting.volumeslices!"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.w_component</code></pre><pre><code class="language-none">AbstractPlotting.widths</code></pre><pre><code class="language-none">AbstractPlotting.window_area</code></pre><pre><code class="language-none">AbstractPlotting.window_open</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe" href="#AbstractPlotting.wireframe"><code>AbstractPlotting.wireframe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.wireframe(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!" href="#AbstractPlotting.wireframe!"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><pre><code class="language-none">AbstractPlotting.wong_colors</code></pre><pre><code class="language-none">AbstractPlotting.wscale</code></pre><pre><code class="language-none">AbstractPlotting.xvector</code></pre><pre><code class="language-none">AbstractPlotting.xyz_boundingbox</code></pre><pre><code class="language-none">AbstractPlotting.yvector</code></pre><pre><code class="language-none">AbstractPlotting.zero_origin</code></pre><pre><code class="language-none">AbstractPlotting.zerorect</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
