<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · TensorToolbox.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TensorToolbox.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">TensorToolbox.==</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.MatrixCell" href="#TensorToolbox.MatrixCell"><code>TensorToolbox.MatrixCell</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MatrixCell(N)</code></pre><p>Cell of matrices of length N.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.TTrank" href="#TensorToolbox.TTrank"><code>TensorToolbox.TTrank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TTrank(X::TTtensor,full=false)
TTrank(X::TensorCell,full=false)</code></pre><p>Representational TT-rank of X. If cores of X are of size R{n-1} x In x Rn, returns (R1,...,R{n-1}) for full=false or (1,R1,....,Rn) for full=true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.TTsvd" href="#TensorToolbox.TTsvd"><code>TensorToolbox.TTsvd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TTsvd(X;tol=1e-8,reqrank=[])
TTsvd(X::TTtensor;tol=1e-8,reqrank=[])</code></pre><p>Decomposes full tensor X into its TT format. If input is already a TTtensor, recompresses it.</p></div></div></section><pre><code class="language-none">TensorToolbox.TTtensor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.TTtv" href="#TensorToolbox.TTtv"><code>TensorToolbox.TTtv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TTtv(X::TTtensor,u::VectorCell,mode::Int)
TTtv(X::TTtensor,U::Matrix,mode::Int)
TTtv(X::TensorCell,u::VectorCell)
TTtv(X::TensorCell,U::Matrix)</code></pre><p>TT-tensor times vector. For N=ndims(X) and n=[mode,mode+1,...,N] contracts nth core of the TT-tensor with vector u[N-n+1]. If input is a matrix, then vectors u are its columns. Called on a subset of cores, it contracts all given cores to vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.TensorCell" href="#TensorToolbox.TensorCell"><code>TensorToolbox.TensorCell</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TensorCell(N)</code></pre><p>Cell of multidimensional arrays of length N.</p></div></div></section><pre><code class="language-none">TensorToolbox.TensorToolbox</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.VectorCell" href="#TensorToolbox.VectorCell"><code>TensorToolbox.VectorCell</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorCell(N)</code></pre><p>Cell of vectors of length N.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.arrange" href="#TensorToolbox.arrange"><code>TensorToolbox.arrange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arrange(X[,n::Integer])
arrange(X[,P::Vector])</code></pre><p>Arrange the rank-1 components of a ktensor: normalize the columns of the factor matrices and then sort the ktensor components by magnitude, greatest to least.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: Absorb the weights into the nth factor matrix instead of lambda.</li><li><code>P</code>: Rearrange the components of X according to the permutation P. P should be a permutation of 1 to ncomponents(X).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.arrange!" href="#TensorToolbox.arrange!"><code>TensorToolbox.arrange!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arrange!(X[,n::Integer])
arrange!(X[,P::Vector])</code></pre><p>Arrange the rank-1 components of a ktensor: normalize the columns of the factor matrices and then sort the ktensor components by magnitude, greatest to least. Rewrite ktensor.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: Absorb the weights into the nth factor matrix instead of lambda.</li><li><code>P</code>: Rearrange the components of X according to the permutation P. P should be a permutation of 1 to ncomponents(X).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.blockdiag" href="#TensorToolbox.blockdiag"><code>TensorToolbox.blockdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>blockdiag(X,Y)</p><p>Create block diagonal tensor where tensors X and Y are block elements. If X and Y are matrices, equal to blkdiag for sparse matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cat(X,Y,n)</code></pre><p>Concatente htensors X and Y by mode n.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.check_vector_input" href="#TensorToolbox.check_vector_input"><code>TensorToolbox.check_vector_input</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_vector_input(input,dim,default_value)</code></pre><p>Check whether input vector is of appropriate size or if input is number create vector out of it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.children" href="#TensorToolbox.children"><code>TensorToolbox.children</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">children(T[,node])</code></pre><p>Matrix of children for each node of a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.colspace" href="#TensorToolbox.colspace"><code>TensorToolbox.colspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colspace(X; &lt;keyword arguments&gt;)</code></pre><p>Column space basis.</p><p><strong>Arguments:</strong></p><ul><li><code>X</code>: Matrix.</li><li><code>method</code> ∈ {&quot;svd&quot;,&quot;lanczos&quot;,&quot;randsvd&quot;} Method for SVD. Default: &quot;svd&quot;.</li><li><code>maxrank::Integer</code>: Maximal rank. Optional.</li><li><code>atol::Number</code>: Drop singular values below atol.  Default: 1e-8.</li><li><code>rtol::Number</code>: Drop singular values below rtol*sigma_1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter used by lanczos and randsvd methods. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.contract" href="#TensorToolbox.contract"><code>TensorToolbox.contract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contract(X,Y)
contract(X,indX,Y,indY[,perm])
contract(X::TensorCell)</code></pre><p>Contracted product of tensors. Contract indX modes of array X to indY modes of array Y and permute the result by vector perm. Default: indX=[ndims(X)], indY=[1].</p></div></div><div><div><hr/><pre><code class="language-none">contract(T::TTtensor,X::Array,start_mode,modes)</code></pre><p>Contract modes 1:ndims(X-1) of full tensor X to TTtensor T cores[start<em>mode:start</em>mode+modes-1]. Output: TTtensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.coresize" href="#TensorToolbox.coresize"><code>TensorToolbox.coresize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coresize(X)</code></pre><p>Size of core tensor of a ttensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.count_leaves" href="#TensorToolbox.count_leaves"><code>TensorToolbox.count_leaves</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count_leaves(T,node)</code></pre><p>Number of leaves under a node of a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.cp_als" href="#TensorToolbox.cp_als"><code>TensorToolbox.cp_als</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cp_als(X,R;init,tol,maxit,dimorder)</code></pre><p>Compute a CP decomposition with R components of a tensor X .</p><p><strong>Arguments:</strong></p><ul><li><code>init</code> ∈ {MatrixCell,&quot;rand&quot;,&quot;nvecs&quot;,&quot;eigs&quot;}. Initial guess for factor matrices. If init=&quot;nvecs&quot; (same as &quot;eigs&quot;) initialize matrices with function nvecs.</li><li><code>tol</code>: Tolerance. Defualt: 1e-4.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li>`dimorder&#39;: Order of dimensions. Default: 1:ndims(A).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.diagt" href="#TensorToolbox.diagt"><code>TensorToolbox.diagt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diagt(v[,dims])</code></pre><p>Create a diagonal tensor for a given vector of diagonal elements. Generalization of diagm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.dims" href="#TensorToolbox.dims"><code>TensorToolbox.dims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dims(T,node)</code></pre><p>Content of a node of a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.dimtree" href="#TensorToolbox.dimtree"><code>TensorToolbox.dimtree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">dimtree(leaves::Vector{Int}[,internal_nodes::Vector{Int}])
dimtree(N[,treetype])</code></pre><p>Dimension tree. Create from:</p><ul><li>a vector of leaves (and a vector of internal nodes),</li><li>an order of a tensor N and a type treetype of a dimtree. Default: treetype=&quot;balanced&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.dirsum" href="#TensorToolbox.dirsum"><code>TensorToolbox.dirsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dirsum(X,Y)</p><p>Direct sum od tensors. Equal to blockdiag.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.display" href="#Base.Multimedia.display"><code>Base.Multimedia.display</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>TensorToolbox:</p><pre><code class="language-none">display(X::ttensor[,name])
display(X::ktensor[,name])
display(X::htensor[,name])</code></pre><p>Displays a tensor X of a given name.</p></div></div><div><div><pre><code class="language-none">display(T)</code></pre><p>Display a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.dropdims" href="#Base.dropdims"><code>Base.dropdims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>TensorToolbox:</p><pre><code class="language-none">dropdims(X)</code></pre><p>Remove singleton dimensions from htensor.</p></div></div></section><pre><code class="language-none">TensorToolbox.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ewprod" href="#TensorToolbox.ewprod"><code>TensorToolbox.ewprod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ewprod(X,Y)</p><p>Element-wise product of two ttensors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.extract" href="#TensorToolbox.extract"><code>TensorToolbox.extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extract(X,factors)</code></pre><p>Create a new ktensor with only the specified factors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.eye" href="#TensorToolbox.eye"><code>TensorToolbox.eye</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eye(n::Integer)</code></pre><p>Identity matrix of size nxn.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.fixsigns" href="#TensorToolbox.fixsigns"><code>TensorToolbox.fixsigns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fixsign(X)</code></pre><p>Fix sign ambiguity of a ktensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.fixsigns!" href="#TensorToolbox.fixsigns!"><code>TensorToolbox.fixsigns!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fixsign(X)</code></pre><p>Fix sign ambiguity of a ktensor. Rewrite ktensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.full" href="#TensorToolbox.full"><code>TensorToolbox.full</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>TensorToolbox:</p><pre><code class="language-none">full(X::ttensor)
full(X::ktensor)
full(X::htensor)</code></pre><p>Make full tensor out of a decomposed tensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hadcten" href="#TensorToolbox.hadcten"><code>TensorToolbox.hadcten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hadcten(X,Y,fmat)</code></pre><p>Core tensor of Hadamard product of two ttensors with given factor matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.height" href="#TensorToolbox.height"><code>TensorToolbox.height</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">height(T)</code></pre><p>Height of a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hosvd" href="#TensorToolbox.hosvd"><code>TensorToolbox.hosvd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hosvd(X; &lt;keyword arguments&gt;)</code></pre><p>Higher-order singular value decomposition.</p><p><strong>Arguments:</strong></p><ul><li><code>X</code>: Tensor (multidimensional array) or ttensor.</li><li><code>method</code> ∈ {&quot;svd&quot;,&quot;lanczos&quot;,&quot;randsvd&quot;} Method for SVD. Default: &quot;svd&quot;.</li><li><code>reqrank::Vector</code>: Requested mutlilinear rank. Optional.</li><li><code>eps_abs::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps_abs. Default: 1e-8.</li><li><code>eps_rel::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps<em>rel*sigma</em>1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hosvd1" href="#TensorToolbox.hosvd1"><code>TensorToolbox.hosvd1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>hosvd1(X,Y; &lt;keyword arguments&gt;)</p><p>Hadamard product of ttensors X and Y as ttensor. Creates the product and calls hosvd. See also: hosvd2, hosvd3, hosvd4.</p><p><strong>Arguments:</strong></p><ul><li><code>method</code> ∈ {&quot;svd&quot;,&quot;lanczos&quot;,&quot;randsvd&quot;}. Method for SVD. Default: &quot;randsvd&quot;.</li><li><code>reqrank::Vector</code>: Requested mutlilinear rank. Optional.</li><li><code>eps_abs::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps_abs. Optional.</li><li><code>eps_rel::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps<em>rel*sigma</em>1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hosvd2" href="#TensorToolbox.hosvd2"><code>TensorToolbox.hosvd2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>hosvd2(X,Y; &lt;keyword arguments&gt;)</p><p>Hadamard product of ttensors X and Y as ttensor. Orthogonalizes factor matrices from structure and calls hosvd on updated core tensor. See also: hosvd1, hosvd3, hosvd4.</p><p><strong>Arguments:</strong></p><ul><li><code>method</code> ∈ {&quot;svd&quot;,&quot;lanczos&quot;,&quot;randsvd&quot;} Method for SVD. Default: &quot;randsvd&quot;.</li><li><code>reqrank::Vector</code>: Requested mutlilinear rank. Optional.</li><li><code>eps_abs::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps_abs. Optional.</li><li><code>eps_rel::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps<em>rel*sigma</em>1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hosvd3" href="#TensorToolbox.hosvd3"><code>TensorToolbox.hosvd3</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>hosvd3(X,Y; &lt;keyword arguments&gt;)</p><p>Hadamard product of ttensors X and Y as ttensor. Structure exploiting, works with (X ∗ Y)ₙ(X ∗ Y)ₙᵀ matrices. See also: hosvd1, hosvd2, hosvd4.</p><p><strong>Arguments:</strong></p><ul><li><code>method</code> ∈ {&quot;lanczos&quot;,&quot;randsvd&quot;} Structure exploiting method for SVD. Default: &quot;lanczos&quot;.</li><li><code>reqrank::Vector</code>: Requested mutlilinear rank. Optional.</li><li><code>variant</code> ∈ {&#39;A&#39;,&#39;B&#39;} Variant of multiplication (X ∗ Y)ₙ(X ∗ Y)ₙᵀ. Default: &#39;B&#39;.</li><li><code>eps_abs::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps_abs. Optional.</li><li><code>eps_rel::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps<em>rel*sigma</em>1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hosvd4" href="#TensorToolbox.hosvd4"><code>TensorToolbox.hosvd4</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>hosvd4(X,Y; &lt;keyword arguments&gt;)</p><p>Hadamard product of ttensors X and Y as ttensor. Uses rank-1 randomized algorithm for finding range of (X ∗ Y)ₙ. If reqrank defined, calls additonal hosvd on updated core tensor. See also: hosvd1, hosvd2, hosvd3.</p><p><strong>Arguments:</strong></p><ul><li><code>method</code> ∈ {&quot;svd&quot;,&quot;lanczos&quot;,&quot;randsvd&quot;} Method for SVD. Default: &quot;svd&quot;.</li><li><code>reqrank::Vector</code>: Requested mutlilinear rank. Optional.</li><li><code>eps_abs::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps_abs. Optional.</li><li><code>eps_rel::Number/Vector</code>: Drop singular values (of mode-n matricization) below eps<em>rel*sigma</em>1. Optional.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.hrank" href="#TensorToolbox.hrank"><code>TensorToolbox.hrank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fmat(X)</code></pre><p>Hierarchical ranks of a htensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.htensor" href="#TensorToolbox.htensor"><code>TensorToolbox.htensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">htensor(tree,trten,fmat)
htensor(tree,trten,U1,U2,...)</code></pre><p>Hierarchical Tucker tensor.</p><p><strong>Arguments:</strong></p><ul><li><code>tree::dimtree</code>: Dimension tree.</li><li><code>trten::TensorCell</code>: Transfer tensors. One for each internal node of the tree.</li><li><code>fmat::MatrixCell</code>: Frame matrices. One for each leaf of the tree.</li></ul><p>For htensor X, X.isorth=true if frame matrices are othonormal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.htrunc" href="#TensorToolbox.htrunc"><code>TensorToolbox.htrunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">htrunc(X[,tree])</code></pre><p>Truncate full tensor X into a htensor for a given tree. If tree not specified use balanced tree.</p></div></div></section><pre><code class="language-none">TensorToolbox.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.innerprod" href="#TensorToolbox.innerprod"><code>TensorToolbox.innerprod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>innerprod(X,Y)    innerprod(X::ttensor,Y::ttensor)    innerprod(X::ktensor,Y::ktensor)</p><p>Inner product of two tensors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.is_leaf" href="#TensorToolbox.is_leaf"><code>TensorToolbox.is_leaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_leaf(T,node)</code></pre><p>True if a node is a leaf in a dimtree T. False otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.is_left" href="#TensorToolbox.is_left"><code>TensorToolbox.is_left</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_left(T,node)</code></pre><p>True if a node is a left node of dimtree T. False otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.is_right" href="#TensorToolbox.is_right"><code>TensorToolbox.is_right</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_right(T,node)</code></pre><p>True if a node is a right node of dimtree T. False otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isequal" href="#Base.isequal"><code>Base.isequal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isequal(X::ttensor,Y::ttensor)
isequal(X::ktensor,Y::ktensor)
isequal(X::ktensor,Y::htensor)</code></pre><p>Two tensors in decomposed format are equal if they have equal components. Same as: X==Y.</p></div></div><div><div><pre><code class="language-none">isequal(T1,T2)</code></pre><p>True if two dimensional trees are equal, false otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.khatrirao" href="#TensorToolbox.khatrirao"><code>TensorToolbox.khatrirao</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">khatrirao(M,t=&#39;n&#39;)
khatrirao(M,n,t=&#39;n&#39;)</code></pre><p>Khatri-Rao product of matrices from M:  M₁⊙ ⋯ ⊙ Mₙ. Optionally skip nth matrix. If t=&#39;t&#39;, compute transpose Khatri-Rao product: M₁⊙ᵀ ⋯ ⊙ᵀ Mₙ.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.krank" href="#TensorToolbox.krank"><code>TensorToolbox.krank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">krank(X::ktensor)</code></pre><p>Represenation k-rank. Equal to number of columns of factor matrices if ktensor X.</p></div></div></section><pre><code class="language-none">TensorToolbox.kron</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.krontkron" href="#TensorToolbox.krontkron"><code>TensorToolbox.krontkron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">krontkron(A,v,t=&#39;n&#39;)</code></pre><p>Kronecker product of matrices multiplied by Kronecker product of vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.krontm" href="#TensorToolbox.krontm"><code>TensorToolbox.krontm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>krontm(X,Y,M[,modes,t=&#39;n&#39;])</p><p>Kronecker product of two tensors times matrix (n-mode product): (X ⊗ Y) x₁ M₁ x₂ M₂ x₃ ⋯ xₙ Mₙ.</p><p><strong>Arguments:</strong></p><ul><li><code>X::Array</code></li><li><code>Y::Array</code></li><li><code>M::Matrix/MatrixCell</code></li><li><code>modes::Integer/Vector</code> : Modes for multiplication. Default: 1:length(M).</li><li><code>t=&#39;t&#39;</code>: Transpose matrices from M.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.krontv" href="#TensorToolbox.krontv"><code>TensorToolbox.krontv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">krontv(A,B,v)</code></pre><p>Kronecker product times vector: (A ⊗ B)v. If v is a matrix, multiply column by column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.krtv" href="#TensorToolbox.krtv"><code>TensorToolbox.krtv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">krtv(A,B,v)</code></pre><p>Khatri-Rao product times vector: (A ⊙ B)v. If v is a matrix, multiply column by column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.kten2TT" href="#TensorToolbox.kten2TT"><code>TensorToolbox.kten2TT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kten2TT(X::ktensor)</code></pre><p>Transform ktensor to TTtensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ktensor" href="#TensorToolbox.ktensor"><code>TensorToolbox.ktensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ktensor(fmat)
ktensor(lambda,fmat)</code></pre><p>Tensor in Kruskal format defined by its vector of weights lambda and factor matrices. Default lambda: vector of ones. For ktensor X, X.isorth=true if factor matrices are othonormal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.lanczos" href="#TensorToolbox.lanczos"><code>TensorToolbox.lanczos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos(A; &lt;keyword arguments&gt;)</code></pre><p>Lanczos based SVD - computes left singular vectors and singular values of a matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>A::Matrix</code></li><li><code>tol</code>: Tolerance - discard singular values below tol. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>reqrank</code>: Number of singular values and singular vectors to compute. Optional.</li><li><code>p</code>: Oversampling parameter. Default: p=10.</li></ul></div></div><div><div><pre><code class="language-none">lanczos(X,Y,n; &lt;keyword arguments&gt;)</code></pre><p>Structure exploiting Lanczos based SVD - computes left singular vectors and singular values of n-mode matricization (X ∗ Y)ₙ. Works with matrix (X ∗ Y)ₙ(X ∗ Y)ₙᵀ.</p><p><strong>Arguments:</strong></p><ul><li><code>reqrank::Integer</code>: Requested rank. Optional.</li><li><code>variant</code> ∈ {&#39;A&#39;,&#39;B&#39;} Variant of multiplication (X ∗ Y)ₙ(X ∗ Y)ₙᵀ. Default: &#39;B&#39;.</li><li><code>tol::Number/Vector</code>: Tolerance. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.lanczos_tridiag" href="#TensorToolbox.lanczos_tridiag"><code>TensorToolbox.lanczos_tridiag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos_tridiag(A; &lt;keyword arguments&gt;)</code></pre><p>Lanczos tridiagonalization algorithm - returns orthonormal Q and symmetric tridiagonal T such that A≈Q<em>T</em>Q&#39;.</p><p><strong>Arguments:</strong></p><ul><li><code>A::Matrix</code></li><li><code>tol</code>: Tolerance. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>reqrank</code>: Number of singular values and singular vectors to compute. Optional.</li><li><code>p</code>: Oversampling parameter. Default: p=10.</li></ul></div></div><div><div><pre><code class="language-none">lanczos_tridiag(X,Y,n; &lt;keyword arguments&gt;)</code></pre><p>Structure exploiting Lanczos tridiagonalization algorithm for n-mode matricization A=(X ∗ Y)ₙ(X ∗ Y)ₙᵀ. Returns orthonormal Q and symmetric tridiagonal T such that A≈Q<em>T</em>Q&#39;.</p><p><strong>Arguments:</strong></p><ul><li><code>reqrank::Integer</code>: Requested rank. Optional.</li><li><code>variant</code> ∈ {&#39;A&#39;,&#39;B&#39;} Variant of multiplication (X ∗ Y)ₙ(X ∗ Y)ₙᵀ. Default: &#39;B&#39;.</li><li><code>tol::Number/Vector</code>: Tolerance. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.left_child_length" href="#TensorToolbox.left_child_length"><code>TensorToolbox.left_child_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">left_child_length(T[,node])</code></pre><p>Length of the left child of a node of a dimtree T. Default: node=1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.lvl" href="#TensorToolbox.lvl"><code>TensorToolbox.lvl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lvl(T[,node])</code></pre><p>Vector of levels for each node of a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.matten" href="#TensorToolbox.matten"><code>TensorToolbox.matten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">matten(A,n,dims)
matten(A,R,C,dims)</code></pre><p>Fold matrix A into a tensor of dimension dims by mode n or by row and column vectors R and C.</p></div></div></section><pre><code class="language-none">TensorToolbox.mhadtm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.mhadtv" href="#TensorToolbox.mhadtv"><code>TensorToolbox.mhadtv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mhadtv(X,Y,v,n,t=&#39;b&#39;;variant=&#39;B&#39;)</code></pre><p>Mode-n matricized Hadamard product of ttensors X and Y times vector v.</p><ul><li><code>t=&#39;b&#39;</code>:  (X ∗ Y)ₙ(X ∗ Y)ₙᵀv. Variant of multiplication (X ∗ Y)ₙ(X ∗ Y)ₙᵀ can be specified to &#39;A&#39; or &#39;B&#39;.</li><li><code>t=&#39;n&#39;</code>:  (X ∗ Y)ₙᵀv.</li><li><code>t=&#39;t&#39;</code>:  (X ∗ Y)ₙᵀv.</li></ul><p>If v is a matrix, multiply column by column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.minus" href="#TensorToolbox.minus"><code>TensorToolbox.minus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">minus(X::ttensor,Y::ttensor)
minus(X::ktensor,Y::ktensor)
minus(X::htensor,Y::htensor)</code></pre><p>Subtraction of two tensors. Same as: X-Y.</p></div></div><div><div><pre><code class="language-none">minus(X::TTtensor,Y::TTtensor)</code></pre><p>Subtraction of two TTtensors. Same as: X-Y.</p></div></div></section><pre><code class="language-none">TensorToolbox.mkrontm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.mkrontv" href="#TensorToolbox.mkrontv"><code>TensorToolbox.mkrontv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mkrontv(X,Y,v,n,t=&#39;n&#39;)</code></pre><p>Matricized Kronecker product of tensors X and Y times vector v (n-mode multiplication): (X ⊗ Y)ₙv. If t=&#39;t&#39;, transpose matricized Kronecker product: (X ⊗ Y)ᵀₙv. If v is a matrix, multiply column by column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.mrank" href="#TensorToolbox.mrank"><code>TensorToolbox.mrank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mrank(X[,tol])
mrank(X::ttensor[,tol])</code></pre><p>Multilinear rank of a tensor with optionally given tolerance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.msvdvals" href="#TensorToolbox.msvdvals"><code>TensorToolbox.msvdvals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>msvdvals(X,n)</p><p>Singular values of mode-n matricization of a ttensor calculated directly. See also: nvecs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.mtimes" href="#TensorToolbox.mtimes"><code>TensorToolbox.mtimes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mtimes(a,X)</code></pre><p>Scalar times ttensor. Same as: a*X.</p></div></div><div><div><pre><code class="language-none">mtimes(a,X)</code></pre><p>Scalar times TTtensor. Same as: a*X.</p></div></div></section><pre><code class="language-none">TensorToolbox.mtimes!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.mttkrp" href="#TensorToolbox.mttkrp"><code>TensorToolbox.mttkrp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mttkrp(X,M,n)
mttkrp(X::ttensor,M,n)
mttkrp(X::ktensor,M,n)</code></pre><p>Mode-n matricized tensor X times Khatri-Rao product of matrices from M (except nth) in reverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ncomponents" href="#TensorToolbox.ncomponents"><code>TensorToolbox.ncomponents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ncomponents(X)</code></pre><p>Number of components of a ktensor.</p></div></div></section><pre><code class="language-none">TensorToolbox.ndims</code></pre><pre><code class="language-none">TensorToolbox.next_single_node</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.neye" href="#TensorToolbox.neye"><code>TensorToolbox.neye</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neye(dims)</code></pre><p>Identity tensor of a given dimension. Generalization of eye.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.node2ind" href="#TensorToolbox.node2ind"><code>TensorToolbox.node2ind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">node2ind(T,nodes)</code></pre><p>Convert node numbers to transfer tensor or frames indices in a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.nodes_on_lvl" href="#TensorToolbox.nodes_on_lvl"><code>TensorToolbox.nodes_on_lvl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nodes_on_lvl(T,l)</code></pre><p>Nodes on a level l in a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.non" href="#TensorToolbox.non"><code>TensorToolbox.non</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">non(T)</code></pre><p>Number of nodes of a dimtree T.</p></div></div></section><pre><code class="language-none">TensorToolbox.norm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize(X[,n;normtype,factor])</code></pre><p>Normalize columns of factor matrices of a ktensor. Also ensures that lambda is positive.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: Absorbe the excess weight into nth factor matrix.  If n=0, equally divide the weights across the factor matrices and set lambda to vector of ones.  If n=&quot;sort&quot;, sort the components by lambda value, from greatest to least.</li><li><code>normtype</code>: Default: 2.</li><li><code>factor</code>: Just normalize specified factor.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize!(X[,n,normtype,factor])</code></pre><p>Normalize columns of factor matrices of a ktensor. Rewrite ktensor. Also ensures that lambda is positive.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code>: Absorbe the excess weight into nth factor matrix.  If n=0, equally divide the weights across the factor matrices and set lambda to vector of ones.  If n=&quot;sort&quot;, sort the components by lambda value, from greatest to least.</li><li><code>normtype</code>: Default: 2.</li><li><code>factor</code>: Just normalize specified factor.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.nrank" href="#TensorToolbox.nrank"><code>TensorToolbox.nrank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nrank(X,n[,tol])
nrank(X::ttensor,n[,tol])</code></pre><p>Rank of the n-mode matricization of a tensor X (n-rank).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.nvecs" href="#TensorToolbox.nvecs"><code>TensorToolbox.nvecs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nvecs(X,n,r=0;flipsign=false,svds=false)
nvecs(X::ttensor,n,r=0;flipsign=false)
nvecs(X::ktensor,n,r=0;flipsign=false)</code></pre><p>Computes the r leading singular vectors of mode-n matricization of a tensor X. Works with XₙXₙᵀ.</p><p><strong>Arguments:</strong></p><ul><li><code>flipsign=true</code>: Make the largest magnitude element be positive.</li><li><code>svds=true</code>: Use svds on Xₙ rather than eigs on XₙXₙᵀ.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parent(T[,node])</code></pre><p>Vectors of parents for each node of a dimtree T.</p></div></div></section><pre><code class="language-none">TensorToolbox.permutedims</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.plus" href="#TensorToolbox.plus"><code>TensorToolbox.plus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">plus(X::ttensor,Y::ttensor)
plus(X::ktensor,Y::ktensor)
plus(X::htensor,Y::htensor)</code></pre><p>Addition of two tensors. Same as: X+Y.</p></div></div><div><div><pre><code class="language-none">plus(X::TTtensor,Y::TTtensor)</code></pre><p>Addition of two TTtensors. Same as: X+Y.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.positions" href="#TensorToolbox.positions"><code>TensorToolbox.positions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">positions(T)</code></pre><p>Positions of nodes of a dimtree T in a full binary tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randTTtensor" href="#TensorToolbox.randTTtensor"><code>TensorToolbox.randTTtensor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randTTtensor(I::Vector,R::Vector)
randTTtensor(I::Integer,R::Integer,N::Integer)</code></pre><p>Create random TTtensor of size I and TT-rank rank R, or of order N and size I × ⋯ × I and TT-rank (R,...,R).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randhtensor" href="#TensorToolbox.randhtensor"><code>TensorToolbox.randhtensor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randhtensor(I::Vector,R::Vector)
randhtensor(I::Vector,R::Vector,T::dimtree)</code></pre><p>Create random htensor of size I, hierarchical rank R and balanced tree T. If T not specified use balanced tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randktensor" href="#TensorToolbox.randktensor"><code>TensorToolbox.randktensor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randktensor(I::Vector,R::Integer)
randktensor(I::Integer,R::Integer,N::Integer)</code></pre><p>Create random Kruskal tensor of size I with R components, or of order N and size I × ⋯ × I.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randrange" href="#TensorToolbox.randrange"><code>TensorToolbox.randrange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randrange(X,Y,n; &lt;keyword arguments&gt;)</code></pre><p>Structure exploiting randomized range approximation of n-mode matricization of Hadamard product (X ∗ Y)ₙ, where X and Y are ttensors.</p><p><strong>Arguments:</strong></p><ul><li><code>reqrank::Integer</code>: Requested rank. Optional.</li><li><code>tol::Number/Vector</code>: Tolerance. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>r</code>: Number of samples for stopping criterion. Default: r=10.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randsvd" href="#TensorToolbox.randsvd"><code>TensorToolbox.randsvd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>randsvd(A; &lt;keyword arguments&gt;)</p><p>Randomized SVD algorithm - returns left singular vectors and singular values of a matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>A::Matrix</code></li><li><code>tol</code>: Tolerance - discard singular values below tol. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>reqrank</code>: Number of singular values and singular vectors to compute. Optional.</li><li><code>r</code>: Number of samples for stopping criterion. Default: r=10.</li><li><code>p</code>: Oversampling parameter. Default: p=10.</li></ul></div></div><div><div><pre><code class="language-none">randsvd(X,Y,n; &lt;keyword arguments&gt;)</code></pre><p>Structure exploiting randomized SVD - computes left singular vectors and singular values of n-mode matricization (X ∗ Y)ₙ. Works with matrix (X ∗ Y)ₙ(X ∗ Y)ₙᵀ.</p><p><strong>Arguments:</strong></p><ul><li><code>reqrank::Integer</code>: Requested rank. Optional.</li><li><code>variant</code> ∈ {&#39;A&#39;,&#39;B&#39;} Variant of multiplication (X ∗ Y)ₙ(X ∗ Y)ₙᵀ. Default: &#39;B&#39;.</li><li><code>tol::Number/Vector</code>: Tolerance. Default: 1e-8.</li><li><code>maxit</code>: Maximal number of iterations. Default: 1000.</li><li><code>r</code>: Number of samples for stopping criterion. Default: r=10.</li><li><code>p::Integer</code>: Oversampling parameter. Defaul p=10.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.randttensor" href="#TensorToolbox.randttensor"><code>TensorToolbox.randttensor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randttensor(I::Vector,R::Vector)
randttensor(I::Integer,R::Integer,N::Integer)</code></pre><p>Create random ttensor of size I and multilinear rank R, or of order N and size I × ⋯ × I and mulilinear rank (R,...,R).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.redistribute" href="#TensorToolbox.redistribute"><code>TensorToolbox.redistribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">redistribute(X,n)</code></pre><p>Distribute lambda values to a mode n.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.redistribute!" href="#TensorToolbox.redistribute!"><code>TensorToolbox.redistribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">redistribute!(X,n)</code></pre><p>Distribute lambda values to a mode n. Rewrite ktensor X.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.reorth" href="#TensorToolbox.reorth"><code>TensorToolbox.reorth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  reorth(X::ttensor)
  reorth(X::htensor)
  reorth(X::TTtensor[,direction,full])</code></pre><p>Orthogonalize factor matrices of a tensor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.reorth!" href="#TensorToolbox.reorth!"><code>TensorToolbox.reorth!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reorth!(X::ttensor)
reorth!(X::htensor)
reorth(X::TTtensor[,direction,full])</code></pre><p>Orthogonalize factor matrices of a tensor. Rewrite ttensor.</p></div></div></section><pre><code class="language-none">TensorToolbox.show</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.sibling" href="#TensorToolbox.sibling"><code>TensorToolbox.sibling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sibling(T,node)</code></pre><p>Sibling of a node in a dimtree T.</p></div></div></section><pre><code class="language-none">TensorToolbox.size</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.sthosvd" href="#TensorToolbox.sthosvd"><code>TensorToolbox.sthosvd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sthosvd(X,reqrank,p)</code></pre><p>Sequentially truncated HOSVD of a tensor X of predifined rank and processing order p.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.structure" href="#TensorToolbox.structure"><code>TensorToolbox.structure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">structure(T)</code></pre><p>For each internal node of a given dimtree, returns its representation t, its left child and right child representations tl and tr.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.subnodes" href="#TensorToolbox.subnodes"><code>TensorToolbox.subnodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subnodes(T,node)</code></pre><p>Nodes in the subtree of a node in a dimtree T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.subtree" href="#TensorToolbox.subtree"><code>TensorToolbox.subtree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subtree(T,node)</code></pre><p>Dimensional tree with the same structure as a subtree of a node in a dimtree T. See also: subnodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.tenmat" href="#TensorToolbox.tenmat"><code>TensorToolbox.tenmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tenmat(X,n)
tenmat(X,row=[],col=[])
tenmat(X::ttensor,n)
tenmat(X::ktensor,n)</code></pre><p>Mode-n matricization of a tensor or matricization by row and column vectors R and C.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.tkron" href="#TensorToolbox.tkron"><code>TensorToolbox.tkron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tkron(X,Y)</code></pre><p>Kronecker product of two tensors X and Y. Direct generalization of Kronecker product of matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.tkrtv" href="#TensorToolbox.tkrtv"><code>TensorToolbox.tkrtv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tkrtv(A,B,v)</p><p>Transpose Khatri-Rao product times vector: (A ⊙ᵀ B)v. If v is a matrix, multiply column by column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.tocell" href="#TensorToolbox.tocell"><code>TensorToolbox.tocell</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tocell(X[,n])</p><p>Converts ktensor X into MatrixCell. If n specified, absorb the weights into the nth factor matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.trten2mat" href="#TensorToolbox.trten2mat"><code>TensorToolbox.trten2mat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trten2mat(B::Array)
trten2mat(B::TensorCell)</code></pre><p>Transfer tensor to matrix. If transfer tensor is given as a tensor of order 3 and size <code>(r1,r2,r3)</code>, reshape it into a matrix of size <code>(r1r2,r3)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.trten2ten" href="#TensorToolbox.trten2ten"><code>TensorToolbox.trten2ten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trten2ten(B::Matrix,r1::Integer,r2::Integer)
trten2ten(B::MatrixCell,r1::Vector,r2::Vector)</code></pre><p>Transfer tensor to tensor. If transfer tensor is given as a matrix, reshape it into a tensor of order 3 and size r1×r2×r3, where <code>r3=size(B,2)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ttensor" href="#TensorToolbox.ttensor"><code>TensorToolbox.ttensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ttensor(cten,fmat)</code></pre><p>Tensor in Tucker format defined by its core tensor and factor matrices. For ttensor X, X.isorth=true if factor matrices are othonormal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ttm" href="#TensorToolbox.ttm"><code>TensorToolbox.ttm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ttm(X,M[,modes,t=&#39;n&#39;])
ttm(X::ttensor,M[,modes,t=&#39;n&#39;])</code></pre><p>Tensor times matrix (n-mode product):  X x₁ M₁ x₂ M₂ x₃ ⋯ xₙ Mₙ Default modes: 1:length(M). If t=&#39;t&#39;, transpose matrices from M.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ttt" href="#TensorToolbox.ttt"><code>TensorToolbox.ttt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ttv(X,Y)</code></pre><p>Outer product of two tensors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.ttv" href="#TensorToolbox.ttv"><code>TensorToolbox.ttv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ttv(X,V[,modes])</code></pre><p>Tensor times vectors (n-mode product):  X x₁ V₁ x₂ V₂ x₃ ⋯ xₙ Vₙ. Default modes: 1:length(M).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorToolbox.uminus" href="#TensorToolbox.uminus"><code>TensorToolbox.uminus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>uminus(X::ttensor)    uminus(X::ktensor)    uminus(X::htensor)</p><p>Unary minus. Same as: (-1)*X.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
