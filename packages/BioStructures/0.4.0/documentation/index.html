<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation Â· BioStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BioStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Documentation</a><ul class="internal"><li><a class="toctext" href="#Basics-1">Basics</a></li><li><a class="toctext" href="#Manipulating-structures-1">Manipulating structures</a></li><li><a class="toctext" href="#Spatial-calculations-1">Spatial calculations</a></li><li><a class="toctext" href="#Downloading-PDB-files-1">Downloading PDB files</a></li><li><a class="toctext" href="#Reading-PDB-files-1">Reading PDB files</a></li><li><a class="toctext" href="#Writing-PDB-files-1">Writing PDB files</a></li><li><a class="toctext" href="#RCSB-PDB-utility-functions-1">RCSB PDB utility functions</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Documentation</a></li></ul></nav><hr/><div id="topbar"><span>Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BioStructures-documentation-1" href="#BioStructures-documentation-1">BioStructures documentation</a></h1><p>The BioStructures.jl package provides functionality to manipulate macromolecular structures, and in particular to read and write <a href="http://www.rcsb.org/pdb/home/home.do">Protein Data Bank</a> (PDB) and mmCIF files. It is designed to be used for standard structural analysis tasks, as well as acting as a platform on which others can build to create more specific tools.</p><p>It compares favourably in terms of performance to other PDB parsers - see some <a href="https://github.com/jgreener64/pdb-benchmarks">benchmarks</a>. The PDB and mmCIF parsers currently read in the whole PDB without explicit errors (with one exception). Help can be found on individual functions using <code>?function_name</code>.</p><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><p>To download a PDB file:</p><pre><code class="language-julia">using BioStructures

# Stored in the current working directory by default
downloadpdb(&quot;1EN2&quot;)</code></pre><p>To parse a PDB file into a Structure-Model-Chain-Residue-Atom framework:</p><pre><code class="language-julia">julia&gt; struc = read(&quot;/path/to/pdb/file.pdb&quot;, PDB)
ProteinStructure 1EN2.pdb with 1 models, 1 chains (A), 85 residues, 754 atoms</code></pre><p>mmCIF files can be read into the same data structure with <code>read(&quot;/path/to/cif/file.cif&quot;, MMCIF)</code>. If you want to read an mmCIF file into a dictionary to query yourself (e.g. to access metadata fields), use <code>MMCIFDict</code>:</p><pre><code class="language-julia">julia&gt; mmcif_dict = MMCIFDict(&quot;/path/to/cif/file.cif&quot;)
mmCIF dictionary with 716 fields

julia&gt; mmcif_dict[&quot;_entity_src_nat.common_name&quot;]
&quot;great nettle&quot;</code></pre><p>A <code>MMCIFDict</code> can be accessed in similar ways to a standard dictionary, and if necessary the underlying dictionary of <code>MMCIFDict</code> <code>d</code> can be accessed with <code>d.dict</code>.</p><p>Refer to <a href="#Downloading-PDB-files-1">Downloading PDB files</a> and <a href="#Reading-PDB-files-1">Reading PDB files</a> sections for more options.</p><p>The elements of <code>struc</code> can be accessed as follows:</p><table><tr><th>Command</th><th>Returns</th><th>Return type</th></tr><tr><td><code>struc[1]</code></td><td>Model 1</td><td><code>Model</code></td></tr><tr><td><code>struc[1][&quot;A&quot;]</code></td><td>Model 1, chain A</td><td><code>Chain</code></td></tr><tr><td><code>struc[1][&#39;A&#39;]</code></td><td>Shortcut to above if the chain ID is a single character</td><td><code>Chain</code></td></tr><tr><td><code>struc[&quot;A&quot;]</code></td><td>The lowest model (model 1), chain A</td><td><code>Chain</code></td></tr><tr><td><code>struc[&quot;A&quot;][&quot;50&quot;]</code></td><td>Model 1, chain A, residue 50</td><td><code>AbstractResidue</code></td></tr><tr><td><code>struc[&quot;A&quot;][50]</code></td><td>Shortcut to above if it is not a hetero residue and the insertion code is blank</td><td><code>AbstractResidue</code></td></tr><tr><td><code>struc[&quot;A&quot;][&quot;H_90&quot;]</code></td><td>Model 1, chain A, hetero residue 90</td><td><code>AbstractResidue</code></td></tr><tr><td><code>struc[&quot;A&quot;][50][&quot;CA&quot;]</code></td><td>Model 1, chain A, residue 50, atom name CA</td><td><code>AbstractAtom</code></td></tr><tr><td><code>struc[&quot;A&quot;][15][&quot;CG&quot;][&#39;A&#39;]</code></td><td>For disordered atoms, access a specific location</td><td><code>Atom</code></td></tr></table><p>Disordered atoms are stored in a <code>DisorderedAtom</code> container but calls fall back to the default atom, so disorder can be ignored if you are not interested in it. Disordered residues (i.e. point mutations with different residue names) are stored in a <code>DisorderedResidue</code> container.</p><p>The idea is that disorder will only bother you if you want it to. See the <a href="http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ#How_is_disorder_handled.3F">Biopython discussion</a> for more.</p><p>Properties can be retrieved as follows:</p><table><tr><th>Function</th><th>Returns</th><th>Return type</th></tr><tr><td><code>serial</code></td><td>Serial number of an atom</td><td><code>Int</code></td></tr><tr><td><code>atomname</code></td><td>Name of an atom</td><td><code>String</code></td></tr><tr><td><code>altlocid</code></td><td>Alternative location ID of an atom</td><td><code>Char</code></td></tr><tr><td><code>x</code></td><td>x coordinate of an atom</td><td><code>Float64</code></td></tr><tr><td><code>y</code></td><td>y coordinate of an atom</td><td><code>Float64</code></td></tr><tr><td><code>z</code></td><td>z coordinate of an atom</td><td><code>Float64</code></td></tr><tr><td><code>coords</code></td><td>coordinates of an atom</td><td><code>Array{Float64,1}</code></td></tr><tr><td><code>occupancy</code></td><td>Occupancy of an atom (default is <code>1.0</code>)</td><td><code>Float64</code></td></tr><tr><td><code>tempfactor</code></td><td>Temperature factor of an atom (default is <code>0.0</code>)</td><td><code>Float64</code></td></tr><tr><td><code>element</code></td><td>Element of an atom (default is <code>&quot;  &quot;</code>)</td><td><code>String</code></td></tr><tr><td><code>charge</code></td><td>Charge of an atom (default is <code>&quot;  &quot;</code>)</td><td><code>String</code></td></tr><tr><td><code>residue</code></td><td>Residue an atom belongs to</td><td><code>Residue</code></td></tr><tr><td><code>ishetero</code></td><td><code>true</code> if the residue or atom is a hetero residue/atom</td><td><code>Bool</code></td></tr><tr><td><code>isdisorderedatom</code></td><td><code>true</code> if the atom is disordered</td><td><code>Bool</code></td></tr><tr><td><code>pdbline</code></td><td>PDB ATOM/HETATM record for an atom</td><td><code>String</code></td></tr><tr><td><code>resname</code></td><td>Residue name of a residue or atom</td><td><code>String</code></td></tr><tr><td><code>resnumber</code></td><td>Residue number of a residue or atom</td><td><code>Int</code></td></tr><tr><td><code>inscode</code></td><td>Insertion code of a residue or atom</td><td><code>Char</code></td></tr><tr><td><code>resid</code></td><td>Residue ID of an atom or residue (<code>full=true</code> includes chain)</td><td><code>String</code></td></tr><tr><td><code>atomnames</code></td><td>Atom names of the atoms in a residue, sorted by serial</td><td><code>Array{String,1}</code></td></tr><tr><td><code>atoms</code></td><td>Dictionary of atoms in a residue</td><td><code>Dict{String, AbstractAtom}</code></td></tr><tr><td><code>isdisorderedres</code></td><td><code>true</code> if the residue has multiple residue names</td><td><code>Bool</code></td></tr><tr><td><code>disorderedres</code></td><td>Access a particular residue name in a <code>DisorderedResidue</code></td><td><code>Residue</code></td></tr><tr><td><code>chain</code></td><td>Chain a residue or atom belongs to</td><td><code>Chain</code></td></tr><tr><td><code>chainid</code></td><td>Chain ID of a chain, residue or atom</td><td><code>String</code></td></tr><tr><td><code>resids</code></td><td>Sorted residue IDs in a chain</td><td><code>Array{String,1}</code></td></tr><tr><td><code>residues</code></td><td>Dictionary of residues in a chain</td><td><code>Dict{String, AbstractResidue}</code></td></tr><tr><td><code>model</code></td><td>Model a chain, residue or atom belongs to</td><td><code>Model</code></td></tr><tr><td><code>modelnumber</code></td><td>Model number of a model, chain, residue or atom</td><td><code>Int</code></td></tr><tr><td><code>chainids</code></td><td>Sorted chain IDs in a model or structure</td><td><code>Array{String,1}</code></td></tr><tr><td><code>chains</code></td><td>Dictionary of chains in a model or structure</td><td><code>Dict{String, Chain}</code></td></tr><tr><td><code>structure</code></td><td>Structure a model, chain, residue or atom belongs to</td><td><code>ProteinStructure</code></td></tr><tr><td><code>structurename</code></td><td>Name of the structure an element belongs to</td><td><code>String</code></td></tr><tr><td><code>modelnumbers</code></td><td>Sorted model numbers in a structure</td><td><code>Array{Int,1}</code></td></tr><tr><td><code>models</code></td><td>Dictionary of models in a structure</td><td><code>Dict{Int, Model}</code></td></tr></table><p>The <code>strip</code> keyword argument determines whether surrounding whitespace is stripped for <code>atomname</code>, <code>element</code>, <code>charge</code>, <code>resname</code> and <code>atomnames</code> (default <code>true</code>).</p><p>The coordinates of an atom can be set using <code>x!</code>, <code>y!</code>, <code>z!</code> and <code>coords!</code>.</p><h2><a class="nav-anchor" id="Manipulating-structures-1" href="#Manipulating-structures-1">Manipulating structures</a></h2><p>Elements can be looped over to reveal the sub-elements in the correct order:</p><pre><code class="language-julia">for mod in struc
    for ch in mod
        for res in ch
            for at in res
                # Do something
            end
        end
    end
end</code></pre><p>Models are ordered numerically; chains are ordered by chain ID character ordering, except the empty chain is last; residues are ordered by residue number and insertion code with hetero residues after standard residues; atoms are ordered by atom serial. If you want the first sub-element you can use <code>first</code>. For example <code>first(struc[1])</code> gets the first chain in model 1.</p><p><code>collect</code> can be used to get arrays of sub-elements. <code>collectatoms</code>, <code>collectresidues</code>, <code>collectchains</code> and <code>collectmodels</code> return arrays of a particular type from a structural element or element array.</p><p>Selectors are functions passed as additional arguments to these functions. Only elements that return <code>true</code> when passed to all the selector are retained. For example:</p><table><tr><th>Command</th><th>Action</th><th>Return type</th></tr><tr><td><code>collect(struc[&#39;A&#39;][50])</code></td><td>Collect the sub-elements of an element, e.g. atoms from a residue</td><td><code>Array{AbstractAtom,1}</code></td></tr><tr><td><code>collectresidues(struc)</code></td><td>Collect the residues of an element</td><td><code>Array{AbstractResidue,1}</code></td></tr><tr><td><code>collectatoms(struc)</code></td><td>Collect the atoms of an element</td><td><code>Array{AbstractAtom,1}</code></td></tr><tr><td><code>collectatoms(struc, calphaselector)</code></td><td>Collect the C-alpha atoms of an element</td><td><code>Array{AbstractAtom,1}</code></td></tr><tr><td><code>collectatoms(struc, calphaselector, disorderselector)</code></td><td>Collect the disordered C-alpha atoms of an element</td><td><code>Array{AbstractAtom,1}</code></td></tr></table><p>The selectors available are:</p><table><tr><th>Function</th><th>Acts on</th><th>Selects for</th></tr><tr><td>standardselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues arising from standard (ATOM) records</td></tr><tr><td>heteroselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues arising from hetero (HETATM) records</td></tr><tr><td>atomnameselector</td><td><code>AbstractAtom</code></td><td>Atoms with atom name in a given list</td></tr><tr><td>calphaselector</td><td><code>AbstractAtom</code></td><td>C-alpha atoms</td></tr><tr><td>cbetaselector</td><td><code>AbstractAtom</code></td><td>C-beta atoms, or C-alpha atoms for glycine residues</td></tr><tr><td>backboneselector</td><td><code>AbstractAtom</code></td><td>Atoms in the protein backbone (CA, N and C)</td></tr><tr><td>heavyatomselector</td><td><code>AbstractAtom</code></td><td>Non-hydrogen atoms</td></tr><tr><td>hydrogenselector</td><td><code>AbstractAtom</code></td><td>Hydrogen atoms</td></tr><tr><td>resnameselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues with residue name in a given list</td></tr><tr><td>waterselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues with residue name HOH</td></tr><tr><td>notwaterselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues with residue name not HOH</td></tr><tr><td>disorderselector</td><td><code>AbstractAtom</code> or <code>AbstractResidue</code></td><td>Atoms/residues with alternative locations</td></tr></table><p>It is easy to define your own atom, residue, chain or model selectors. The below will collect all atoms with x coordinate less than 0:</p><pre><code class="language-julia">xselector(at::AbstractAtom) = x(at) &lt; 0
collectatoms(struc, xselector)</code></pre><p>Alternatively, you can use an anonymous function:</p><pre><code class="language-julia">collectatoms(struc, at -&gt; x(at) &lt; 0)</code></pre><p><code>countatoms</code>, <code>countresidues</code>, <code>countchains</code> and <code>countmodels</code> can be used to count elements wth the same selector API. For example:</p><pre><code class="language-julia">julia&gt; countatoms(struc)
754

julia&gt; countatoms(struc, calphaselector)
85

julia&gt; countresidues(struc, standardselector)
85</code></pre><p>The sequence of a protein can be retrieved by passing a <code>Chain</code> or array of residues to <code>AminoAcidSequence</code>:</p><pre><code class="language-julia">julia&gt; AminoAcidSequence(struc[&#39;A&#39;], standardselector)
85aa Amino Acid Sequence:
RCGSQGGGSTCPGLRCCSIWGWCGDSEPYCGRTCENKCWSGERSDHRCGAAVGNPPCGQDRCCSVHGWCGGGNDYCSGGNCQYRC</code></pre><p>See <a href="https://github.com/BioJulia/BioSequences.jl">BioSequences.jl</a> for more on how to deal with sequences.</p><h2><a class="nav-anchor" id="Spatial-calculations-1" href="#Spatial-calculations-1">Spatial calculations</a></h2><p>Various functions are provided to calculate spatial quantities for proteins:</p><table><tr><th>Command</th><th>Returns</th></tr><tr><td><code>distance</code></td><td>Minimum distance between two elements</td></tr><tr><td><code>sqdistance</code></td><td>Minimum square distance between two elements</td></tr><tr><td><code>bondangle</code></td><td>Angle between three atoms</td></tr><tr><td><code>dihedralangle</code></td><td>Dihedral angle defined by four atoms</td></tr><tr><td><code>omegaangle</code></td><td>Omega dihedral angle between a residue and the previous residue</td></tr><tr><td><code>phiangle</code></td><td>Phi dihedral angle between a residue and the previous residue</td></tr><tr><td><code>psiangle</code></td><td>Psi dihedral angle between a residue and the next residue</td></tr><tr><td><code>omegaangles</code></td><td><code>Vector</code> of omega dihedral angles of an element</td></tr><tr><td><code>phiangles</code></td><td><code>Vector</code> of phi dihedral angles of an element</td></tr><tr><td><code>psiangles</code></td><td><code>Vector</code> of psi dihedral angles of an element</td></tr><tr><td><code>ramachandranangles</code></td><td><code>Vector</code>s of phi and psi angles of an element</td></tr><tr><td><code>ContactMap</code></td><td><code>ContactMap</code> of two elements, or one element with itself</td></tr><tr><td><code>DistanceMap</code></td><td><code>DistanceMap</code> of two elements, or one element with itself</td></tr><tr><td><code>showcontactmap</code></td><td>Print a representation of a <code>ContactMap</code> to <code>stdout</code> or a specified <code>IO</code> instance</td></tr><tr><td><code>rmsd</code></td><td>RMSD between two elements of the same size - assumes they are superimposed</td></tr><tr><td><code>displacements</code></td><td><code>Vector</code> of displacements between two elements of the same size - assumes they are superimposed</td></tr></table><p>The <code>omegaangle</code>, <code>phiangle</code> and <code>psiangle</code> functions can take either a pair of residues or a chain and a position. The <code>omegaangle</code> and <code>phiangle</code> functions measure the angle between the residue at the given index and the one before. The <code>psiangle</code> function measures between the given index and the one after.</p><p>For example:</p><pre><code class="language-julia">julia&gt; distance(struc[&#39;A&#39;][10], struc[&#39;A&#39;][20])
10.782158874733762

julia&gt; rad2deg(bondangle(struc[&#39;A&#39;][50][&quot;N&quot;], struc[&#39;A&#39;][50][&quot;CA&quot;], struc[&#39;A&#39;][50][&quot;C&quot;]))
110.77765846083398

julia&gt; rad2deg(dihedralangle(struc[&#39;A&#39;][50][&quot;N&quot;], struc[&#39;A&#39;][50][&quot;CA&quot;], struc[&#39;A&#39;][50][&quot;C&quot;], struc[&#39;A&#39;][51][&quot;N&quot;]))
-177.38288114072924

julia&gt; rad2deg(psiangle(struc[&#39;A&#39;][50], struc[&#39;A&#39;][51]))
-177.38288114072924

julia&gt; rad2deg(psiangle(struc[&#39;A&#39;], 50))
-177.38288114072924</code></pre><p><code>ContactMap</code> takes in a structural element or a list, such as a <code>Chain</code> or <code>Vector{Atom}</code>, and returns a <code>ContactMap</code> object showing the contacts between the elements for a specified distance. <code>ContactMap</code> can also be given two structural elements as arguments, in which case a non-symmetrical 2D array is returned showing contacts between the elements. The underlying <code>BitArray{2}</code> for <code>ContactMap</code> <code>contacts</code> can be accessed with <code>contacts.data</code> if required.</p><pre><code class="language-julia">julia&gt; contacts = ContactMap(collectatoms(struc[&#39;A&#39;], cbetaselector), 8.0)
Contact map of size (85, 85)</code></pre><p>A <a href="http://docs.juliaplots.org/latest/recipes">plot recipe</a> is defined for this so it can shown with <a href="http://docs.juliaplots.org/latest">Plots.jl</a>:</p><pre><code class="language-julia">using Plots
plot(contacts)</code></pre><p><img src="../contactmap.png" alt="contactmap"/></p><p>For a quick, text-based representation of a <code>ContactMap</code> use <code>showcontactmap</code>.</p><p><code>DistanceMap</code> works in an analogous way to <code>ContactMap</code> and gives a map of the distances. It can also be plotted:</p><pre><code class="language-julia">dists = DistanceMap(collectatoms(struc[&#39;A&#39;], cbetaselector))
using Plots
plot(dists)</code></pre><p><img src="../distancemap.png" alt="distancemap"/></p><h2><a class="nav-anchor" id="Downloading-PDB-files-1" href="#Downloading-PDB-files-1">Downloading PDB files</a></h2><p>To download a PDB file to a specified directory:</p><pre><code class="language-julia">downloadpdb(&quot;1EN2&quot;, pdb_dir=&quot;path/to/pdb/directory&quot;)</code></pre><p>To download multiple PDB files to a specified directory:</p><pre><code class="language-julia">downloadpdb([&quot;1EN2&quot;, &quot;1ALW&quot;, &quot;1AKE&quot;], pdb_dir=&quot;path/to/pdb/directory&quot;)</code></pre><p>To download a PDB file in PDB, XML, MMCIF or MMTF format use the <code>file_format</code> argument:</p><pre><code class="language-julia">downloadpdb(&quot;1ALW&quot;, pdb_dir=&quot;path/to/pdb/directory&quot;, file_format=MMTF)

# To get XML
downloadpdb(&quot;1ALW&quot;, pdb_dir=&quot;path/to/pdb/directory&quot;, file_format=PDBXML)</code></pre><p>To apply a function to a downloaded file and delete the file afterwards:</p><pre><code class="language-julia">downloadpdb(f, &quot;1ALW&quot;)</code></pre><p>Or, using Julia&#39;s <code>do</code> syntax:</p><pre><code class="language-julia">downloadpdb(&quot;1ALW&quot;) do fp
    s = read(fp, PDB)
    # Do something
end</code></pre><p>Various options can be set through optional keyword arguments when downloading PDB files:</p><table><tr><th>Keyword Argument</th><th>Description</th></tr><tr><td><code>pdb_dir::AbstractString=pwd()</code></td><td>The directory to which the PDB file is downloaded; defaults to the current working directory</td></tr><tr><td><code>file_format::Type=PDB</code></td><td>The format of the PDB file; options are PDB, PDBXML, MMCIF and MMTF</td></tr><tr><td><code>obsolete::Bool=false</code></td><td>If set <code>true</code>, the PDB file is downloaded in the auto-generated &quot;obsolete&quot; directory inside the specified <code>pdb_dir</code></td></tr><tr><td><code>overwrite::Bool=false</code></td><td>If set <code>true</code>, overwrites the PDB file if it exists in <code>pdb_dir</code>; by default skips downloading the PDB file if it exists</td></tr><tr><td><code>ba_number::Integer=0</code></td><td>If set &gt; 0 downloads the respective biological assembly; by default downloads the PDB file</td></tr></table><h2><a class="nav-anchor" id="Reading-PDB-files-1" href="#Reading-PDB-files-1">Reading PDB files</a></h2><p>To parse an existing PDB file into a Structure-Model-Chain-Residue-Atom framework:</p><pre><code class="language-julia">julia&gt; struc = read(&quot;/path/to/pdb/file.pdb&quot;, PDB)
ProteinStructure 1EN2.pdb with 1 models, 1 chains (A), 85 residues, 754 atoms</code></pre><p>Read a mmCIF file instead by replacing <code>PDB</code> with <code>MMCIF</code>. Various options can be set through optional keyword arguments when parsing PDB/mmCIF files:</p><table><tr><th>Keyword Argument</th><th>Description</th></tr><tr><td><code>structure_name::AbstractString</code></td><td>The name given to the returned <code>ProteinStructure</code>; defaults to the file name</td></tr><tr><td><code>remove_disorder::Bool=false</code></td><td>Whether to remove atoms with alt loc ID not &#39; &#39; or &#39;A&#39;.</td></tr><tr><td><code>read_std_atoms::Bool=true</code></td><td>Whether to read standard ATOM records.</td></tr><tr><td><code>read_het_atoms::Bool=true</code></td><td>Whether to read HETATOM records.</td></tr></table><p>The function <code>readpdb</code> provides an alternative way to read PDB files in line with <code>downloadpdb</code>. To parse a PDB file by specifying the PDB ID and PDB directory:</p><pre><code class="language-julia">struc = readpdb(&quot;1EN2&quot;, pdb_dir=&quot;/path/to/pdb/directory&quot;)</code></pre><p>The same keyword arguments are taken as <code>read</code> above, plus <code>pdb_dir</code> and <code>ba_number</code>.</p><p>To download and parse a PDB file into a Structure-Model-Chain-Residue-Atom framework in a single line:</p><pre><code class="language-julia">julia&gt; struc = retrievepdb(&quot;1ALW&quot;, pdb_dir=&quot;path/to/pdb/directory&quot;)
INFO: Downloading PDB: 1ALW
ProteinStructure 1ALW.pdb with 1 models, 2 chains (A,B), 346 residues, 2928 atoms</code></pre><p>Various options can be set when using <code>retrievepdb</code>:</p><table><tr><th>Keyword Argument</th><th>Description</th></tr><tr><td><code>pdb_dir::AbstractString=pwd()</code></td><td>The directory to which the PDB file is downloaded; defaults to the current working directory</td></tr><tr><td><code>obsolete::Bool=false</code></td><td>If set <code>true</code>, the PDB file is downloaded in the auto-generated &quot;obsolete&quot; directory inside the specified <code>pdb_dir</code></td></tr><tr><td><code>overwrite::Bool=false</code></td><td>If set <code>true</code>, overwrites the PDB file if it exists in <code>pdb_dir</code>; by default skips downloading the PDB file if it exists</td></tr><tr><td><code>ba_number::Integer=0</code></td><td>If set &gt; 0 downloads the respective biological assembly; by default downloads the PDB file</td></tr><tr><td><code>structure_name::AbstractString=&quot;$pdbid.pdb&quot;</code></td><td>The name given to the returned <code>ProteinStructure</code>; defaults to the PDB ID</td></tr><tr><td><code>remove_disorder::Bool=false</code></td><td>Whether to remove atoms with alt loc ID not &#39; &#39; or &#39;A&#39;.</td></tr><tr><td><code>read_std_atoms::Bool=true</code></td><td>Whether to read standard ATOM records.</td></tr><tr><td><code>read_het_atoms::Bool=true</code></td><td>Whether to read HETATOM records.</td></tr></table><h2><a class="nav-anchor" id="Writing-PDB-files-1" href="#Writing-PDB-files-1">Writing PDB files</a></h2><p>PDB format files can be written:</p><pre><code class="language-julia">writepdb(&quot;1EN2_out.pdb&quot;, struc)</code></pre><p>Any element type can be given as input to <code>writepdb</code>. Atom selectors can also be given as additional arguments:</p><pre><code class="language-julia"># Only backbone atoms are written out
writepdb(&quot;1EN2_out.pdb&quot;, struc, backboneselector)</code></pre><p>The first argument can also be a stream. To write mmCIF format files, use the <code>writemmcif</code> function with similar arguments. A <code>MMCIFDict</code> can also be written using <code>writemmcif</code>:</p><pre><code class="language-julia">writemmcif(&quot;1EN2_out.dic&quot;, mmcif_dict)</code></pre><p>Multi-character chain IDs can be written to mmCIF files but will throw an error when written to a PDB file as the PDB file format only has one character allocated to the chain ID.</p><p>If you want the PDB record line for an <code>Atom</code>, use <code>pdbline</code>. For example:</p><pre><code class="language-julia">julia&gt; pdbline(at)
&quot;HETATM  101  C  A  X B  20      10.500  20.123  -5.123  0.50 50.13           C1+&quot;</code></pre><p>If you want to generate a PDB record line from values directly, do so using an <code>AtomRecord</code>:</p><pre><code class="language-julia">julia&gt; pdbline(AtomRecord(false, 669, &quot;CA&quot;, &#39; &#39;, &quot;ILE&quot;, &quot;A&quot;, 90, &#39; &#39;, [31.743, 33.11, 31.221], 1.00, 25.76, &quot;C&quot;, &quot;&quot;))
&quot;ATOM    669  CA  ILE A  90      31.743  33.110  31.221  1.00 25.76           C  &quot;</code></pre><h2><a class="nav-anchor" id="RCSB-PDB-utility-functions-1" href="#RCSB-PDB-utility-functions-1">RCSB PDB utility functions</a></h2><p>To get the list of all PDB entries:</p><pre><code class="language-julia">l = pdbentrylist()</code></pre><p>To download the entire RCSB PDB database in your preferred file format:</p><pre><code class="language-julia">downloadentirepdb(pdb_dir=&quot;path/to/pdb/directory&quot;, file_format=MMTF)</code></pre><p>This operation takes a lot of disk space and time to complete (depending on internet connection). The keyword arguments are:</p><table><tr><th>Keyword Argument</th><th>Description</th></tr><tr><td><code>pdb_dir::AbstractString=pwd()</code></td><td>The directory to which the PDB files are downloaded; defaults to the current working directory</td></tr><tr><td><code>file_format::Type=PDB</code></td><td>The format of the PDB file; options are PDB, PDBXML, MMCIF and MMTF</td></tr><tr><td><code>overwrite::Bool=false</code></td><td>If set <code>true</code>, overwrites the PDB file if it exists in <code>pdb_dir</code>; by default skips downloading the PDB file if it exists</td></tr></table><p>To update your local PDB directory based on the weekly status list of new, modified and obsolete PDB files from the RCSB server:</p><pre><code class="language-julia">updatelocalpdb(pdb_dir=&quot;path/to/pdb/directory&quot;, file_format=MMTF)</code></pre><p>Obsolete PDB files are stored in the auto-generated <code>obsolete</code> directory inside the specified local PDB directory.</p><p>To maintain a local copy of the entire RCSB PDB database, run the <code>downloadentirepdb</code> function once to download all PDB files and set up a CRON job or similar to run <code>updatelocalpdb</code> function once a week to keep the local PDB directory up to date with the RCSB server.</p><p>There are a few more functions that may be useful:</p><table><tr><th>Function</th><th>Returns</th><th>Return type</th></tr><tr><td><code>pdbentrylist</code></td><td>List of all PDB entries from the RCSB server</td><td><code>Array{String,1}</code></td></tr><tr><td><code>pdbstatuslist</code></td><td>List of PDB entries from a specified RCSB weekly status list URL</td><td><code>Array{String,1}</code></td></tr><tr><td><code>pdbrecentchanges</code></td><td>Added, modified and obsolete PDB lists from the recent RCSB weekly status files</td><td><code>Tuple{Array{String,1},Array{String,1},</code> <code>Array{String,1}}</code></td></tr><tr><td><code>pdbobsoletelist</code></td><td>List of all obsolete PDB entries</td><td><code>Array{String,1}</code></td></tr><tr><td><code>downloadallobsoletepdb</code></td><td>Downloads all obsolete PDB files from the RCSB PDB server</td><td><code>Array{String,1}</code></td></tr></table><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>A few further examples of BioStructures usage are given below.</p><p><strong>A)</strong> To plot the temperature factors of a protein, if you have Plots installed:</p><pre><code class="language-julia">using Plots
calphas = collectatoms(struc, calphaselector)
plot(resnumber.(calphas),
     tempfactor.(calphas),
     xlabel=&quot;Residue number&quot;,
     ylabel=&quot;Temperature factor&quot;,
     label=&quot;&quot;)</code></pre><p><strong>B)</strong> To print the PDB records for all C-alpha atoms within 5 Angstrom of residue 38:</p><pre><code class="language-julia">for at in calphas
    if distance(struc[&#39;A&#39;][38], at) &lt; 5.0 &amp;&amp; resnumber(at) != 38
        println(pdbline(at))
    end
end</code></pre><p><strong>C)</strong> To show the Ramachandran phi/psi angle plot of a structure, if you have Plots installed:</p><pre><code class="language-julia">using Plots
phi_angles, psi_angles = ramachandranangles(struc, standardselector)
scatter(rad2deg.(phi_angles),
     rad2deg.(psi_angles),
     title=&quot;Ramachandran plot&quot;,
     xlabel=&quot;Phi / degrees&quot;,
     ylabel=&quot;Psi / degrees&quot;,
     label=&quot;&quot;,
     xticks=[-180, -90, 0, 90, 180],
     yticks=[-180, -90, 0, 90, 180],
     xlims=(-180, 180),
     ylims=(-180, 180))</code></pre><p><strong>D)</strong> To calculate the RMSD and displacements between the heavy (non-hydrogen) atoms of two models in an NMR structure:</p><pre><code class="language-julia">downloadpdb(&quot;1SSU&quot;)
struc_nmr = read(&quot;1SSU.pdb&quot;, PDB)
rmsd(struc_nmr[5], struc_nmr[10], heavyatomselector)
displacements(struc_nmr[5], struc_nmr[10], heavyatomselector)</code></pre><p><strong>E)</strong> To calculate the cysteine fraction of every structure in the PDB:</p><pre><code class="language-julia">l = pdbentrylist()
for p in l
    downloadpdb(p, file_format=MMCIF) do fp
        s = read(fp, MMCIF)
        nres = countresidues(s, standardselector)
        if nres &gt; 0
            frac = countresidues(s, standardselector, x -&gt; resname(x) == &quot;CYS&quot;) / nres
            println(p, &quot;  &quot;, round(frac, digits=2))
        end
    end
end</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../contributing/"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
