<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ControlSystems.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ControlSystems.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">ControlSystems.AbstractSimulator</code></pre><pre><code class="language-none">ControlSystems.AbstractSystem</code></pre><pre><code class="language-none">ControlSystems.Bodeplot</code></pre><pre><code class="language-none">ControlSystems.ControlSystems</code></pre><pre><code class="language-none">ControlSystems.Impulseplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.LQG" href="#ControlSystems.LQG"><code>ControlSystems.LQG</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">G = LQG(A,B,C,D, Q1, Q2, R1, R2; qQ=0, qR=0, integrator=false)
G = LQG(sys, args...; kwargs...)</code></pre><p>Return an LQG object that describes the closed control loop around the process <code>sys=ss(A,B,C,D)</code> where the controller is of LQG-type. The controller is specified by weight matrices <code>R1,R2</code> that penalizes state deviations and control signal variance respectively, and covariance matrices <code>Q1,Q2</code> which specify state drift and measurement covariance respectively. This constructor calls <a href="#ControlSystems.lqr"><code>lqr</code></a> and <a href="#ControlSystems.kalman"><code>kalman</code></a> and forms the closed-loop system.</p><p>If <code>integrator=true</code>, the resulting controller will have intregral action. This is achieved by adding a model of a constant disturbance on the inputs to the system described by <code>A,B,C,D</code>.</p><p><code>qQ</code> and <code>qR</code> can be set to incorporate loop transfer recovery, i.e.,</p><pre><code class="language-julia">L = lqr(A, B, Q1+qQ*C&#39;C, Q2)
K = kalman(A, C, R1+qR*B*B&#39;, R2)</code></pre><p><strong>Fields</strong></p><p>When the LQG-object is populated by the lqg-function, the following fields have been made available</p><ul><li><code>L</code> is the feedback matrix, such that <code>A-BL</code> is stable. Note that the length of the state vector (and the width of L) is increased by the number of inputs if the option <code>integrator=true</code>.</li><li><code>K</code> is the kalman gain such that <code>A-KC</code> is stable</li><li><code>sysc</code> is a dynamical system describing the controller <code>u=L*inv(A-BL-KC+KDL)Ky</code></li></ul><p><strong>Functions</strong></p><p>Several other properties of the object are accessible with the indexing function <code>getindex()</code> and are called with the syntax <code>G[:function]</code>. The available functions are (some have many alternative names, separated with / )</p><p>-<code>G[:cl] / G[:closedloop]</code> is the closed-loop system, including observer, from reference to output, precompensated to have static gain 1 (<code>u = −Lx + lᵣr</code>). -<code>G[:S] / G[:Sin]</code> Input sensitivity function -<code>G[:T] / G[:Tin]</code> Input complementary sensitivity function -<code>G[:Sout]</code> Output sensitivity function -<code>G[:Tout]</code> Output complementary sensitivity function -<code>G[:CS]</code> The transfer function from measurement noise to control signal -<code>G[:DS]</code> The transfer function from input load disturbance to output -<code>G[:lt] / G[:looptransfer] / G[:loopgain]  =  PC</code> -<code>G[:rd] / G[:returndifference]  =  I + PC</code> -<code>G[:sr] / G[:stabilityrobustness]  =  I + inv(PC)</code> -<code>G[:sysc] / G[:controller]</code> Returns the controller as a StateSpace-system</p><p>It is also possible to access all fileds using the <code>G[:symbol]</code> syntax, the fields are <code>P ,Q1,Q2,R1,R2,qQ,qR,sysc,L,K,integrator</code></p><p><strong>Example</strong></p><pre><code class="language-julia">eye(n) = Matrix{Float64}(I,n,n) # For convinience

qQ = 1
qR = 1
Q1 = 10eye(4)
Q2 = 1eye(2)
R1 = 1eye(6)
R2 = 1eye(2)

G = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR, integrator=true)

Gcl = G[:cl]
T = G[:T]
S = G[:S]
sigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))
stepplot(Gcl)</code></pre></div></div></section><pre><code class="language-none">ControlSystems.LTISystem</code></pre><pre><code class="language-none">ControlSystems.Lsimplot</code></pre><pre><code class="language-none">ControlSystems.Nicholsplot</code></pre><pre><code class="language-none">ControlSystems.Nyquistplot</code></pre><pre><code class="language-none">ControlSystems.Plots</code></pre><pre><code class="language-none">ControlSystems.Pzmap</code></pre><pre><code class="language-none">ControlSystems.Rlocusplot</code></pre><pre><code class="language-none">ControlSystems.Sigmaplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.Simulator" href="#ControlSystems.Simulator"><code>ControlSystems.Simulator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Simulator</code></pre><p><strong>Fields:</strong></p><pre><code class="language-none">P::StateSpace
f = (x,p,t) -&gt; x
y = (x,t)   -&gt; y</code></pre></div></div></section><pre><code class="language-none">ControlSystems.SisoRational</code></pre><pre><code class="language-none">ControlSystems.SisoTf</code></pre><pre><code class="language-none">ControlSystems.SisoZpk</code></pre><pre><code class="language-none">ControlSystems.StateSpace</code></pre><pre><code class="language-none">ControlSystems.Stepplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.TransferFunction" href="#ControlSystems.TransferFunction"><code>ControlSystems.TransferFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>F(s)</code>, <code>F(omega, true)</code>, <code>F(z, false)</code></p><p>Notation for frequency response evaluation.</p><ul><li>F(s) evaluates the continuous-time transfer function F at s.</li><li>F(omega,true) evaluates the discrete-time transfer function F at exp(i<em>Ts</em>omega)</li><li>F(z,false) evaluates the discrete-time transfer function F at z</li></ul></div></div></section><pre><code class="language-none">ControlSystems._LQG</code></pre><pre><code class="language-none">ControlSystems._LQGi</code></pre><pre><code class="language-none">ControlSystems._PlotScale</code></pre><pre><code class="language-none">ControlSystems._PlotScaleFunc</code></pre><pre><code class="language-none">ControlSystems._PlotScaleStr</code></pre><pre><code class="language-none">ControlSystems.__CONTROLSYSTEMS_SOURCE_DIR__</code></pre><pre><code class="language-none">ControlSystems._allGainCrossings</code></pre><pre><code class="language-none">ControlSystems._allPhaseCrossings</code></pre><pre><code class="language-none">ControlSystems._bounds_and_features</code></pre><pre><code class="language-none">ControlSystems._check_consistent_sampling_time</code></pre><pre><code class="language-none">ControlSystems._default_Ts</code></pre><pre><code class="language-none">ControlSystems._default_freq_vector</code></pre><pre><code class="language-none">ControlSystems._default_time_data</code></pre><pre><code class="language-none">ControlSystems._default_time_vector</code></pre><pre><code class="language-none">ControlSystems._findCrossings</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems._fix_conjugate_pairs!" href="#ControlSystems._fix_conjugate_pairs!"><code>ControlSystems._fix_conjugate_pairs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Typically LAPACK returns a vector with, e.g., eigenvalues to a real matrix, they are paired up in exact conjugate pairs. This fact is used in some places for working with zpk representations of LTI systems. eigvals(A) returns a on this form, however, for generalized eigenvalues there is a small numerical discrepancy, which breaks some functions. This function fixes small discrepancies in the conjugate pairs.</p></div></div></section><pre><code class="language-none">ControlSystems._issmooth</code></pre><pre><code class="language-none">ControlSystems._preprocess_for_freqresp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems._printcoefficient" href="#ControlSystems._printcoefficient"><code>ControlSystems._printcoefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Heurisitc function that tries to add parentheses when printing the coeffcient for systems on zpk form. Should at least handle the following types Measurment, Dual, Sym. </p></div></div></section><pre><code class="language-none">ControlSystems._same_io_dims</code></pre><pre><code class="language-none">ControlSystems._string_mat_with_headers</code></pre><pre><code class="language-none">ControlSystems.acker</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.append" href="#ControlSystems.append"><code>ControlSystems.append</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>append(systems::StateSpace...), append(systems::TransferFunction...)</code></p><p>Append systems in block diagonal form</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.balance" href="#ControlSystems.balance"><code>ControlSystems.balance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>T, B = balance(A[, perm=true])</code></p><p>Compute a similarity transform <code>T</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale, and not permute <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.balance_statespace" href="#ControlSystems.balance_statespace"><code>ControlSystems.balance_statespace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>A, B, C, T = balance_statespace{S}(A::Matrix{S}, B::Matrix{S}, C::Matrix{S}, perm::Bool=false)</code></p><p><code>sys, T = balance_statespace(sys::StateSpace, perm::Bool=false)</code></p><p>Computes a balancing transformation <code>T</code> that attempts to scale the system so that the row and column norms of [T<em>A/T T</em>B; C/T 0] are approximately equal. If <code>perm=true</code>, the states in <code>A</code> are allowed to be reordered.</p><p>This is not the same as finding a balanced realization with equal and diagonal observability and reachability gramians, see <code>balreal</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.balance_transform" href="#ControlSystems.balance_transform"><code>ControlSystems.balance_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>T = balance_transform{R}(A::Matrix{R}, B::Matrix{R}, C::Matrix{R}, perm::Bool=false)</code></p><p><code>T = balance_transform(sys::StateSpace, perm::Bool=false) = balance_transform(A,B,C,perm)</code></p><p>Computes a balancing transformation <code>T</code> that attempts to scale the system so that the row and column norms of [T<em>A/T T</em>B; C/T 0] are approximately equal. If <code>perm=true</code>, the states in <code>A</code> are allowed to be reordered.</p><p>No balancing will be done if <code>A, B C</code> are not BLAS compatible</p><p>This is not the same as finding a balanced realization with equal and diagonal observability and reachability gramians, see <code>balreal</code> See also <code>balance_statespace</code>, <code>balance</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.balreal" href="#ControlSystems.balreal"><code>ControlSystems.balreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sysr, G = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code></p><p>See also <code>gram</code>, <code>baltrunc</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.baltrunc" href="#ControlSystems.baltrunc"><code>ControlSystems.baltrunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sysr, G = baltrunc(sys::StateSpace, atol = √ϵ, rtol=1e-3, unitgain=true)</code></p><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>, and truncating it such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed. If <code>unitgain=true</code>, the matrix <code>D</code> is chosen such that unit static gain is achieved.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div></div></section><pre><code class="language-none">ControlSystems.blockdiag</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.bode" href="#ControlSystems.bode"><code>ControlSystems.bode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>mag, phase, w = bode(sys[, w])</code></p><p>Compute the magnitude and phase parts of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>mag</code> and <code>phase</code> has size <code>(length(w), ny, nu)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.bodeplot" href="#ControlSystems.bodeplot"><code>ControlSystems.bodeplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = bodeplot(sys, args...)</code>, <code>bodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, kwargs...)</code></p><p>Create a Bode plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div></div></section><pre><code class="language-none">ControlSystems.bodeplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.c2d" href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>[sysd, x0map] = c2d(sys, Ts, method=:zoh)</code></p><p>Convert the continuous system <code>sys</code> into a discrete system with sample time <code>Ts</code>, using the provided method. Currently only <code>:zoh</code> and <code>:foh</code> are provided.</p><p>Returns the discrete system <code>sysd</code>, and a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.c2d_poly2poly" href="#ControlSystems.c2d_poly2poly"><code>ControlSystems.c2d_poly2poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>c2d_poly2poly(ro,h)</code></p><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.c2d_roots2poly" href="#ControlSystems.c2d_roots2poly"><code>ControlSystems.c2d_roots2poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>c2d_roots2poly(ro,h)</code></p><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.care" href="#ControlSystems.care"><code>ControlSystems.care</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>care(A, B, Q, R)</code></p><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div></div></section><pre><code class="language-none">ControlSystems.charpoly</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.check_real" href="#ControlSystems.check_real"><code>ControlSystems.check_real</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If TR is Complex and T is Real, check that every pole is matched to its conjugate this assumes that the compelx poles are ordered as they are output by the LAPACK routines that return complex-conjugated values, i.e., (x+iy) is followed by (x-iy)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.covar" href="#ControlSystems.covar"><code>ControlSystems.covar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>P = covar(sys, W)</code></p><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of an lti-model <code>sys</code>, driven by gaussian white noise &#39;w&#39; of covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> where δ is the dirac delta.</p><p>The ouput is if Inf if the system is unstable. Passing white noise directly to the output will result in infinite covariance in the corresponding outputs (D<em>W</em>D&#39; .!= 0) for contunuous systems.</p></div></div></section><pre><code class="language-none">ControlSystems.cswap!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.ctrb" href="#ControlSystems.ctrb"><code>ControlSystems.ctrb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ctrb(A, B)</code> or <code>ctrb(sys)</code></p><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dab" href="#ControlSystems.dab"><code>ControlSystems.dab</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>DAB   Solves the Diophantine-Aryabhatta-Bezout identity</p><p><code>X,Y = DAB(A,B,C)</code></p><p>AX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.damp" href="#ControlSystems.damp"><code>ControlSystems.damp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Wn, zeta, ps = damp(sys)</code></p><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dampreport" href="#ControlSystems.dampreport"><code>ControlSystems.dampreport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dampreport(sys)</code></p><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dare" href="#ControlSystems.dare"><code>ControlSystems.dare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dare(A, B, Q, R)</code></p><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where A and R are non-singular.</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dcgain" href="#ControlSystems.dcgain"><code>ControlSystems.dcgain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dcgain(sys)</code></p><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.delaymargin" href="#ControlSystems.delaymargin"><code>ControlSystems.delaymargin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dₘ = delaymargin(G::LTISystem)</code></p><p>Only supports SISO systems</p></div></div></section><pre><code class="language-none">ControlSystems.den</code></pre><pre><code class="language-none">ControlSystems.denpoly</code></pre><pre><code class="language-none">ControlSystems.denvec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.diagonalize" href="#ControlSystems.diagonalize"><code>ControlSystems.diagonalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dsys = diagonalize(s::StateSpace, digits=12)</code> Diagonalizes the system such that the A-matrix is diagonal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dkalman" href="#ControlSystems.dkalman"><code>ControlSystems.dkalman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dkalman(A, C, R1, R2)</code> kalman(sys, R1, R2)`</p><p>Calculate the optimal Kalman gain for discrete time systems</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dlqr" href="#ControlSystems.dlqr"><code>ControlSystems.dlqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dlqr(A, B, Q, R)</code>, <code>dlqr(sys, Q, R)</code></p><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u[k] = K*x[k]</code> that minimizes the cost function:</p><p>J = sum(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the discrte time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>See also <code>lqg</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
h = 0.1
A = [1 h; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0, h)
Q = I
R = I
L = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used

u(t,x) = -L*x # Form control law,
t=0:h:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0)
plot(t,x, lab=[&quot;Position&quot;, &quot;Velocity&quot;]&#39;, xlabel=&quot;Time [s]&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dlyap" href="#ControlSystems.dlyap"><code>ControlSystems.dlyap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dlyap(A, Q)</code></p><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.evalfr" href="#ControlSystems.evalfr"><code>ControlSystems.evalfr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>evalfr(sys, x)</code> Evaluate the transfer function of the LTI system sys at the complex number s=x (continuous-time) or z=x (discrete-time).</p><p>For many values of <code>x</code>, use <code>freqresp</code> instead.</p></div></div></section><pre><code class="language-none">ControlSystems.fastrank</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.feedback" href="#ControlSystems.feedback"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>feedback(L)</code> Returns L/(1+L) <code>feedback(P1,P2)</code> Returns P1/(1+P1*P2)</p></div></div><div><div><p><code>feedback(sys)</code></p><p><code>feedback(sys1,sys2)</code></p><p>Forms the negative feedback interconnection</p><pre><code class="language-julia">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.feedback2dof" href="#ControlSystems.feedback2dof"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>feedback2dof(P,R,S,T)</code> Return <code>BT/(AR+ST)</code> where B and A are the numerator and denomenator polynomials of <code>P</code> respectively <code>feedback2dof(B,A,R,S,T)</code> Return <code>BT/(AR+ST)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.freqresp" href="#ControlSystems.freqresp"><code>ControlSystems.freqresp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>sys_fr = freqresp(sys, w)</p><p>Evaluate the frequency response of a linear system</p><p><code>w -&gt; C*((iw*im -A)^-1)*B + D</code></p><p>of system <code>sys</code> over the frequency vector <code>w</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.gangoffour" href="#ControlSystems.gangoffour"><code>ControlSystems.gangoffour</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>S,D,N,T = gangoffour(P,C)</code>, <code>gangoffour(P::AbstractVector,C::AbstractVector)</code></p><p>Given a transfer function describing the Plant <code>P</code> and a transferfunction describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><p><code>S = 1/(1+PC)</code> Sensitivity function</p><p><code>D = P/(1+PC)</code></p><p><code>N = C/(1+PC)</code></p><p><code>T = PC/(1+PC)</code> Complementary sensitivity function</p><p>Only supports SISO systems</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.gangoffourplot" href="#ControlSystems.gangoffourplot"><code>ControlSystems.gangoffourplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = gangoffourplot(P::LTISystem, C::LTISystem)</code>, <code>gangoffourplot(P::Union{Vector, LTISystem}, C::Vector; plotphase=false)</code></p><p>Gang-of-Four plot.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.gangofseven" href="#ControlSystems.gangofseven"><code>ControlSystems.gangofseven</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>S, D, N, T, RY, RU, RE = gangofseven(P,C,F)</code></p><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><p><code>S = 1/(1+PC)</code> Sensitivity function</p><p><code>D = P/(1+PC)</code></p><p><code>N = C/(1+PC)</code></p><p><code>T = PC/(1+PC)</code> Complementary sensitivity function</p><p><code>RY = PCF/(1+PC)</code></p><p><code>RU = CF/(1+P*C)</code></p><p><code>RE = F/(1+P*C)</code></p><p>Only supports SISO systems</p></div></div></section><pre><code class="language-none">ControlSystems.getColorSys</code></pre><pre><code class="language-none">ControlSystems.getLogTicks</code></pre><pre><code class="language-none">ControlSystems.getStyleSys</code></pre><pre><code class="language-none">ControlSystems.get_A</code></pre><pre><code class="language-none">ControlSystems.get_B</code></pre><pre><code class="language-none">ControlSystems.get_C</code></pre><pre><code class="language-none">ControlSystems.get_D</code></pre><pre><code class="language-none">ControlSystems.get_Ts</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.getlims" href="#ControlSystems.getlims"><code>ControlSystems.getlims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get atributes from xlims or ylims default to extrema(wmag) if xlims/ylims not defined or empty</p></div></div></section><pre><code class="language-none">ControlSystems.getpoles</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.gram" href="#ControlSystems.gram"><code>ControlSystems.gram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>gram(sys, opt)</code></p><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.impulse" href="#ControlSystems.impulse"><code>ControlSystems.impulse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>y, t, x = impulse(sys[, Tf])</code> or <code>y, t, x = impulse(sys[, t])</code></p><p>Calculate the impulse response of system <code>sys</code>. If the final time <code>Tf</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations.</p><p><code>y</code> has size <code>(length(t), ny, nu)</code>, <code>x</code> has size <code>(length(t), nx, nu)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.impulseplot" href="#ControlSystems.impulseplot"><code>ControlSystems.impulseplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">impulseplot(sys[, Tf[,  Ts]])</code></pre><p>Plot step response of <code>sys</code> with optional final time <code>Tf</code> and discretization time <code>Ts</code>. If not defined, suitable values are chosen based on <code>sys</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.impulseplot!</code></pre><pre><code class="language-none">ControlSystems.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.index2range" href="#ControlSystems.index2range"><code>ControlSystems.index2range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>outs = index2range(ind1, ind2) Helper function to convert indexes with scalars to ranges. Used to avoid dropping dimensions</p></div></div></section><pre><code class="language-none">ControlSystems.indirect_str</code></pre><pre><code class="language-none">ControlSystems.interpolate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.iscontinuous" href="#ControlSystems.iscontinuous"><code>ControlSystems.iscontinuous</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>iscontinuous(sys)</code></p><p>Returns <code>true</code> if <code>sys</code> is continuous, else returns <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.isproper" href="#ControlSystems.isproper"><code>ControlSystems.isproper</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>isproper(tf)</code></p><p>Returns <code>true</code> if the <code>TransferFunction</code> is proper. This means that order(den)</p><blockquote><p>= order(num))</p></blockquote></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.issiso" href="#ControlSystems.issiso"><code>ControlSystems.issiso</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>issiso(sys)</code></p><p>Returns <code>true</code> if <code>sys</code> is SISO, else returns <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.isstable" href="#ControlSystems.isstable"><code>ControlSystems.isstable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>isstable(sys)</code></p><p>Returns <code>true</code> if <code>sys</code> is stable, else returns <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.kalman" href="#ControlSystems.kalman"><code>ControlSystems.kalman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>kalman(A, C, R1, R2)</code> kalman(sys, R1, R2)`</p><p>Calculate the optimal Kalman gain</p><p>See also <code>LQG</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.laglink" href="#ControlSystems.laglink"><code>ControlSystems.laglink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>laglink(a, M; h=0)</code></p><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.leadlink" href="#ControlSystems.leadlink"><code>ControlSystems.leadlink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>leadlink(b, N, K; h=0)</code></p><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.leadlinkat" href="#ControlSystems.leadlinkat"><code>ControlSystems.leadlinkat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>leadlinkat(ω, N, K; h=0)</code></p><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.leadlinkcurve" href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link)</p><p>If an input argument <code>s</code> is given, the curve is plotted from <code>s</code> to 10, else from 1 to 10.</p><p>See also <code>Leadlink, leadlinkat</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.loopshapingPI" href="#ControlSystems.loopshapingPI"><code>ControlSystems.loopshapingPI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>kp,ki,C = loopshapingPI(P,ωp; ϕl,rl, phasemargin)</code></p><p>Selects the parameters of a PI-controller such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>If <code>phasemargin</code> is supplied, <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><p>See also <code>pidplots</code>, <code>stabregionPID</code></p></div></div></section><pre><code class="language-none">ControlSystems.lqg</code></pre><pre><code class="language-none">ControlSystems.lqgi</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.lqr" href="#ControlSystems.lqr"><code>ControlSystems.lqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>lqr(A, B, Q, R)</code></p><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the continuous time model <code>dx = Ax + Bu</code>.</p><p><code>lqr(sys, Q, R)</code></p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>See also <code>LQG</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(t,x) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0)
plot(t,x, lab=[&quot;Position&quot;, &quot;Velocity&quot;]&#39;, xlabel=&quot;Time [s]&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.lsim" href="#ControlSystems.lsim"><code>ControlSystems.lsim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>y, t, x = lsim(sys, u, t; x0, method])</code></p><p><code>y, t, x, uout = lsim(sys, u::Function, t; x0, method)</code></p><p>Calculate the time response of system <code>sys</code> to input <code>u</code>. If <code>x0</code> is ommitted, a zero vector is used.</p><p><code>y</code>, <code>x</code>, <code>uout</code> has time in the first dimension. Initial state <code>x0</code> defaults to zero.</p><p>Continuous time systems are simulated using an ODE solver if <code>u</code> is a function. If <code>u</code> is an array, the system is discretized before simulation. For a lower level inteface, see <code>?Simulator</code> and <code>?solve</code></p><p><code>u</code> can be a function or a matrix/vector of precalculated control signals. If <code>u</code> is a function, then <code>u(x,i)</code> (<code>u(x,t)</code>) is called to calculate the control signal every iteration (time instance used by solver). This can be used to provide a control law such as state feedback <code>u(x,t) = -L*x</code> calculated by <code>lqr</code>. To simulate a unit step, use <code>(x,i)-&gt; 1</code>, for a ramp, use <code>(x,i)-&gt; i*h</code>, for a step at <code>t=5</code>, use (x,i)-&gt; (i*h &gt;= 5) etc.</p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0)
plot(t,x, lab=[&quot;Position&quot;, &quot;Velocity&quot;]&#39;, xlabel=&quot;Time [s]&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.lsima" href="#ControlSystems.lsima"><code>ControlSystems.lsima</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>[y, t, x] = lsima(sys, t[, x0, method])</code></p><p>Calculate the time response of adaptive controller. If <code>x0</code> is ommitted, a zero vector is used.</p><p>Continuous time systems are discretized before simulation. By default, the method is chosen based on the smoothness of the input signal. Optionally, the <code>method</code> parameter can be specified as either <code>:zoh</code> or <code>:foh</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.lsimplot" href="#ControlSystems.lsimplot"><code>ControlSystems.lsimplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = lsimplot(sys::LTISystem, u, t; x0=0, method)</code></p><p><code>lsimplot(LTISystem[sys1, sys2...], u, t; x0, method)</code></p><p>Calculate the time response of the <code>LTISystem</code>(s) to input <code>u</code>. If <code>x0</code> is not specified, a zero vector is used.</p><p>Continuous time systems are discretized before simulation. By default, the method is chosen based on the smoothness of the input signal. Optionally, the <code>method</code> parameter can be specified as either <code>:zoh</code> or <code>:foh</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.lsimplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.ltitr" href="#ControlSystems.ltitr"><code>ControlSystems.ltitr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ltitr(A, B, u[,x0])</code></p><p><code>ltitr(A, B, u::Function, iters[,x0])</code></p><p>Simulate the discrete time system <code>x[k + 1] = A x[k] + B u[k]</code>, returning <code>x</code>. If <code>x0</code> is not provided, a zero-vector is used.</p><p>If <code>u</code> is a function, then <code>u(x,i)</code> is called to calculate the control signal every iteration. This can be used to provide a control law such as state feedback <code>u=-Lx</code> calculated by <code>lqr</code>. In this case, an integrer <code>iters</code> must be provided that indicates the number of iterations.</p></div></div></section><pre><code class="language-none">ControlSystems.lyap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.margin" href="#ControlSystems.margin"><code>ControlSystems.margin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ωgₘ, gₘ, ωϕₘ, ϕₘ = margin{S&lt;:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)</code></p><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><p>If <code>!allMargins</code>, return only the smallest margin</p><p>If <code>full</code> return also <code>fullPhase</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.marginplot" href="#ControlSystems.marginplot"><code>ControlSystems.marginplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = marginplot(sys::LTISystem [,w::AbstractVector];  kwargs...)</code>, <code>marginplot(sys::Vector{LTISystem}, w::AbstractVector;  kwargs...)</code></p><p>Plot all the amplitude and phase margins of the system(s) <code>sys</code>. A frequency vector <code>w</code> can be optionally provided.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.markovparam" href="#ControlSystems.markovparam"><code>ControlSystems.markovparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>markovparam(sys, n)</code></p><p>Compute the <code>n</code>th markov parameter of state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.minreal" href="#ControlSystems.minreal"><code>ControlSystems.minreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tf = minreal(tf::TransferFunction, eps=sqrt(eps()))</code></p><p>Create a minimial representation of each transfer function in <code>tf</code> by cancelling poles and zeros will promote system to an appropriate numeric type</p></div></div><div><div><p><code>minsys = minreal(s::StateSpace, tol=sqrt(eps()))</code> is implemented via <code>baltrunc</code> and returns a system on diagonal form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.nicholsplot" href="#ControlSystems.nicholsplot"><code>ControlSystems.nicholsplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>fig = <code>nicholsplot{T&lt;:LTISystem}(systems::Vector{T}, w::AbstractVector; kwargs...)</code></p><p>Create a Nichols plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p>Keyword arguments:</p><pre><code class="language-none">text = true
Gains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]
pInc = 30
sat = 0.4
val = 0.85
fontsize = 10</code></pre><p><code>pInc</code> determines the increment in degrees between phase lines.</p><p><code>sat</code> ∈ [0,1] determines the saturation of the gain lines</p><p><code>val</code> ∈ [0,1] determines the brightness of the gain lines</p><p>Additional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular Plots.jl syntax</p><p>This function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer</p></div></div></section><pre><code class="language-none">ControlSystems.nicholsplot!</code></pre><pre><code class="language-none">ControlSystems.ninputs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>..  norm(sys, p=2; tol=1e-6)</code></p><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the L∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the L∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>norminf</code> instead.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p>sys is first converted to a state space model if needed.</p><p>The L∞ norm computation implements the &#39;two-step algorithm&#39; in: N.A. Bruinsma and M. Steinbuch, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters 14 (1990), pp. 287-293. For the discrete-time version, see, e.g.,: P. Bongers, O. Bosgra, M. Steinbuch, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p></div></div></section><pre><code class="language-none">ControlSystems.normLinf_twoSteps_ct</code></pre><pre><code class="language-none">ControlSystems.normLinf_twoSteps_dt</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.norminf" href="#ControlSystems.norminf"><code>ControlSystems.norminf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>.. (peakgain, peakgainfrequency) = norminf(sys; tol=1e-6)</code></p><p>Compute the L∞ norm of the LTI system <code>sys</code>, together with the frequency <code>peakgainfrequency</code> (in rad/TimeUnit) at which the gain achieves its peak value <code>peakgain</code>. The H∞ norm is the same as the L∞ for stable systems, and Inf for unstable systems.</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p>sys is first converted to a state space model if needed.</p><p>The L∞ norm computation implements the &#39;two-step algorithm&#39; in: N.A. Bruinsma and M. Steinbuch, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters 14 (1990), pp. 287-293. For the discrete-time version, see, e.g.,: P. Bongers, O. Bosgra, M. Steinbuch, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p></div></div></section><pre><code class="language-none">ControlSystems.noutputs</code></pre><pre><code class="language-none">ControlSystems.nstates</code></pre><pre><code class="language-none">ControlSystems.num</code></pre><pre><code class="language-none">ControlSystems.numeric_type</code></pre><pre><code class="language-none">ControlSystems.numpoly</code></pre><pre><code class="language-none">ControlSystems.numvec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.nyquist" href="#ControlSystems.nyquist"><code>ControlSystems.nyquist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>re, im, w = nyquist(sys[, w])</code></p><p>Compute the real and imaginary parts of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>re</code> and <code>im</code> has size <code>(length(w), ny, nu)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.nyquistplot" href="#ControlSystems.nyquistplot"><code>ControlSystems.nyquistplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = nyquistplot(sys; gaincircles=true, kwargs...)</code>, <code>nyquistplot(LTISystem[sys1, sys2...]; gaincircles=true, kwargs...)</code></p><p>Create a Nyquist plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p><code>gaincircles</code> plots the circles corresponding to |S(iω)| = 1 and |T(iω)| = 1, where S and T are the sensitivity and complementary sensitivity functions.</p><p><code>kwargs</code> is sent as argument to plot.</p></div></div></section><pre><code class="language-none">ControlSystems.nyquistplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.obsv" href="#ControlSystems.obsv"><code>ControlSystems.obsv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>obsv(A, C)</code> or <code>obsv(sys)</code></p><p>Compute the observability matrix for the system described by <code>(A, C)</code> or <code>sys</code>.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.parallel" href="#ControlSystems.parallel"><code>ControlSystems.parallel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>series(sys1::LTISystem, sys2::LTISystem)</code></p><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.pid" href="#ControlSystems.pid"><code>ControlSystems.pid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates and returns a PID controller on transfer function form. <code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants <code>series</code> indicates  whether or not the series form or parallel form (default) is desired</p><p><code>C = pid(; kp=0, ki=0; kd=0, time=false, series=false)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.pidplots" href="#ControlSystems.pidplots"><code>ControlSystems.pidplots</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Plots interesting figures related to closing the loop around process <code>P</code> with a PID controller Send in a bunch of PID-parameters in any of the vectors kp, ki, kd. The vectors must be the same length.</p><p><code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants</p><p><code>series</code> indicates  whether or not the series form or parallel form (default) is desired</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps</p><p>One can also supply a frequency vector ω to be used in Bode and Nyquist plots</p><p><code>pidplots(P, args...; kps=0, kis=0, kds=0, time=false, series=false, ω=0)</code></p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.place" href="#ControlSystems.place"><code>ControlSystems.place</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>place(A, B, p)</code>, <code>place(sys::StateSpace, p)</code></p><p>Calculate gain matrix <code>K</code> such that the poles of <code>(A-BK)</code> in are in <code>p</code></p></div></div></section><pre><code class="language-none">ControlSystems.plot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.pole" href="#ControlSystems.pole"><code>ControlSystems.pole</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>pole(sys)</code></p><p>Compute the poles of system <code>sys</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.poly2vec</code></pre><pre><code class="language-none">ControlSystems.poly_factors2string</code></pre><pre><code class="language-none">ControlSystems.primitivetype</code></pre><pre><code class="language-none">ControlSystems.print_compact</code></pre><pre><code class="language-none">ControlSystems.print_siso</code></pre><pre><code class="language-none">ControlSystems.printpoly2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.printpolydesc" href="#ControlSystems.printpolydesc"><code>ControlSystems.printpolydesc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Prints polynomial in descending order, with variable <code>var</code></p></div></div></section><pre><code class="language-none">ControlSystems.printpolyfun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.pzmap" href="#ControlSystems.pzmap"><code>ControlSystems.pzmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig = pzmap(fig, system, args...; kwargs...)</code></p><p>Create a pole-zero map of the <code>LTISystem</code>(s) in figure <code>fig</code>, <code>args</code> and <code>kwargs</code> will be sent to the <code>scatter</code> plot command.</p></div></div></section><pre><code class="language-none">ControlSystems.pzmap!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.reduce_sys" href="#ControlSystems.reduce_sys"><code>ControlSystems.reduce_sys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.rlocus" href="#ControlSystems.rlocus"><code>ControlSystems.rlocus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rlocusplot(P::LTISystem, K)</code></pre><p>Computes and plots the root locus of the SISO LTISystem P with a negative feedback loop and feedback gains <code>K</code>, if <code>K</code> is not provided, range(1e-6,stop=500,length=10000) is used. If <code>OrdinaryDiffEq.jl</code> is installed and loaded by the user (<code>using OrdinaryDiffEq</code>), <code>rlocusplot</code> will use an adaptive step-size algorithm to select values of <code>K</code>. A scalar <code>Kmax</code> can then be given as second argument.</p></div></div></section><pre><code class="language-none">ControlSystems.rlocusplot</code></pre><pre><code class="language-none">ControlSystems.rlocusplot!</code></pre><pre><code class="language-none">ControlSystems.roots2poly_factors</code></pre><pre><code class="language-none">ControlSystems.roots2real_poly_factors</code></pre><pre><code class="language-none">ControlSystems.rst</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.rstc" href="#ControlSystems.rstc"><code>ControlSystems.rstc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See ?rstd for the discerte case</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.rstd" href="#ControlSystems.rstd"><code>ControlSystems.rstd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rstd  Polynomial synthesis in discrete time.</p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)</code></p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)</code></p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></p><p>Polynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)</p><p>Inputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]</p><p>Outputs: R,S,T  : Polynomials in controller</p><p>See function DAB how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.series" href="#ControlSystems.series"><code>ControlSystems.series</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>series(sys1::LTISystem, sys2::LTISystem)</code></p><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.setPlotScale" href="#ControlSystems.setPlotScale"><code>ControlSystems.setPlotScale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>setPlotScale(str)</code></p><p>Set the default scale of magnitude in <code>bodeplot</code> and <code>sigmaplot</code>. <code>str</code> should be either <code>&quot;dB&quot;</code> or <code>&quot;log10&quot;</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.showterm2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.sigma" href="#ControlSystems.sigma"><code>ControlSystems.sigma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sv, w = sigma(sys[, w])</code></p><p>Compute the singular values of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>sv</code> has size <code>(length(w), max(ny, nu))</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.sigmaplot" href="#ControlSystems.sigmaplot"><code>ControlSystems.sigmaplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sigmaplot(sys, args...)</code>, <code>sigmaplot(LTISystem[sys1, sys2...], args...)</code></p><p>Plot the singular values of the frequency response of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div></div></section><pre><code class="language-none">ControlSystems.sigmaplot!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.siso_ss_to_zpk" href="#ControlSystems.siso_ss_to_zpk"><code>ControlSystems.siso_ss_to_zpk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert get zpk representation of sys from input j to output i</p></div></div></section><pre><code class="language-none">ControlSystems.siso_tf_to_ss</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.sisomargin" href="#ControlSystems.sisomargin"><code>ControlSystems.sisomargin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ωgₘ, gₘ, ωϕₘ, ϕₘ = sisomargin{S&lt;:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)</code></p><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.sminreal" href="#ControlSystems.sminreal"><code>ControlSystems.sminreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sminreal(sys)</code></p><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.solve" href="#DiffEqBase.solve"><code>DiffEqBase.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sol = solve(s::AbstractSimulator, x0, tspan,  args...; kwargs...)</code></pre><p>Simulate the system represented by <code>s</code> from initial state <code>x0</code> over time span <code>tspan = (t0,tf)</code>. <code>args</code> and <code>kwargs</code> are sent to the <code>solve</code> function from <code>OrdinaryDiffEq</code>, e.g., <code>solve(s, x0, tspan,  Tsit5(), reltol=1e-5)</code> solves the problem with solver <a href="http://docs.juliadiffeq.org/stable/solvers/ode_solve.html"><code>Tsit5()</code></a> and relative tolerance 1e-5.</p><p>See also <code>Simulator</code> <code>lsim</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.ss" href="#ControlSystems.ss"><code>ControlSystems.ss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sys = ss(A, B, C, D, Ts=0) -&gt; sys</code></p><p>Create a state-space model <code>sys::StateSpace{T, MT&lt;:AbstractMatrix{T}}</code> where <code>MT</code> is the type of matrixes <code>A,B,C,D</code> and <code>T</code> the element type.</p><p>This is a continuous-time model if Ts is omitted or set to 0. Otherwise, this is a discrete-time model with sampling period Ts. Set Ts=-1 for a discrete-time model with unspecified sampling period.</p><p><code>sys = ss(D[, Ts, ...])</code> specifies a static gain matrix D.</p></div></div></section><pre><code class="language-none">ControlSystems.ss2tf</code></pre><pre><code class="language-none">ControlSystems.ssdata</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.stabregionPID" href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fig, kp, ki = stabregionPID(P, [ω]; kd=0, doplot = true)</code></p><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s</p><p>The curve is found by analyzing P(s)*C(s) = -1 ⟹ |PC| = |P| |C| = 1 arg(P) + arg(C) = -π</p><p>If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions</p><p>See also <code>stabregionPID</code>, <code>loopshapingPI</code>, <code>pidplots</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.step" href="#Base.step"><code>Base.step</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>y, t, x = step(sys[, Tf])</code> or <code>y, t, x = step(sys[, t])</code></p><p>Calculate the step response of system <code>sys</code>. If the final time <code>Tf</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations.</p><p><code>y</code> has size <code>(length(t), ny, nu)</code>, <code>x</code> has size <code>(length(t), nx, nu)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.stepplot" href="#ControlSystems.stepplot"><code>ControlSystems.stepplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stepplot(sys[, Tf[,  Ts]])</code></pre><p>Plot step response of <code>sys</code> with optional final time <code>Tf</code> and discretization time <code>Ts</code>. If not defined, suitable values are chosen based on <code>sys</code>.</p></div></div></section><pre><code class="language-none">ControlSystems.stepplot!</code></pre><pre><code class="language-none">ControlSystems.struct_ctrb_obsv</code></pre><pre><code class="language-none">ControlSystems.struct_ctrb_states</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.tf" href="#ControlSystems.tf"><code>ControlSystems.tf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>sys = tf(num, den, Ts=0), sys = tf(gain, Ts=0)</code></p><p>Create as a fraction of polynomials:</p><p><code>sys::TransferFunction{SisoRational{T,TR}} = numerator/denominator</code> where T is the type of the coefficients in the polynomial.</p><p><code>num</code>: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>den</code>: the coefficients of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>Ts</code>: Sample time or <code>0</code> for continuous system.</p><p>Other uses: <code>tf(sys)</code>: Convert <code>sys</code> to <code>tf</code> form. <code>tf(&quot;s&quot;)</code>, <code>tf(&quot;z&quot;)</code>: Create the continous transferfunction <code>s</code>.</p><p>See also: <code>zpk</code>, <code>ss</code></p></div></div></section><pre><code class="language-none">ControlSystems.to_matrix</code></pre><pre><code class="language-none">ControlSystems.toeplitz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.tzero" href="#ControlSystems.tzero"><code>ControlSystems.tzero</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tzero(sys)</code></p><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p></div></div></section><pre><code class="language-none">ControlSystems.unwrap</code></pre><pre><code class="language-none">ControlSystems.unwrap!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.zpconv" href="#ControlSystems.zpconv"><code>ControlSystems.zpconv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>zpc(a,r,b,s)</code> form conv(a,r) + conv(b,s) where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.zpk" href="#ControlSystems.zpk"><code>ControlSystems.zpk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>zpk(gain, Ts=0), zpk(num, den, k, Ts=0), zpk(sys)</code></p><p>Create transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.</p><p><code>sys::TransferFunction{SisoZpk{T,TR}} = k*numerator/denominator</code> where <code>T</code> is the type of <code>k</code> and <code>TR</code> the type of the zeros/poles, usually Float64 and Complex{Float64}.</p><p><code>num</code>: the roots of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>den</code>: the roots of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>k</code>: The gain of the system. Obs, this is not the same as <code>dcgain</code>.</p><p><code>Ts</code>: Sample time or <code>0</code> for continuous system.</p><p>Other uses:</p><p><code>zpk(sys)</code>: Convert <code>sys</code> to <code>zpk</code> form.</p><p><code>zpk(&quot;s&quot;)</code>: Create the transferfunction <code>s</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.zpkdata" href="#ControlSystems.zpkdata"><code>ControlSystems.zpkdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>z, p, k = zpkdata(sys)</code></p><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><p><code>z</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>p</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>k</code> : Matrix{Float64}, (ny x nu)</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
