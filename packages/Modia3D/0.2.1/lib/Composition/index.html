<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Composition · Modia3D</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Modia3D</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/GettingStarted/">Getting Started</a></li><li><a class="toctext" href="../../man/Examples/">Examples</a></li><li><a class="toctext" href="../../man/Plans/">Plans for version 1.0</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Composition</a><ul class="internal"></ul></li><li><a class="toctext" href="../Graphics/">Graphics</a></li><li><a class="toctext" href="../Solids/">Solids</a></li><li><a class="toctext" href="../ForceElements/">ForceElements</a></li><li><a class="toctext" href="../Basics/">Basics</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Composition</a></li></ul></nav><hr/><div id="topbar"><span>Composition</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition" href="#Modia3D.Composition"><code>Modia3D.Composition</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">module Modia3D.Composition</code></pre><p>Structuring of objects moving in 3D. Most important constructors (dof are the <code>degrees-of-freedom</code>):</p><table><tr><th>Function</th><th>dof</th><th>Description</th></tr><tr><td><a href="#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>@assembly</code></a><code>Name(..) begin .. end</code></td><td>-</td><td>Return a <code>Name</code> constructor for Object3Ds</td></tr><tr><td><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a><code>([data];..)</code></td><td>0</td><td>Return a reference Object3D</td></tr><tr><td><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a><code>(parent [, data];..)</code></td><td>0,6</td><td>Return Object3D fixed/moving w.r.t. <code>parent</code></td></tr><tr><td><a href="#Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}"><code>Modia3D.Revolute</code></a><code>(obj1,obj2;..)</code></td><td>1</td><td>Return a revolute joint</td></tr><tr><td><a href="#Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}"><code>Modia3D.Prismatic</code></a><code>(obj1,obj2;..)</code></td><td>1</td><td>Return a prismatic joint</td></tr></table><p>The optional <code>data</code> associated with an <code>Object3D</code> can be one of the following:</p><table><tr><th><code>data</code></th><th>Description</th></tr><tr><td><code>::</code><a href="../Solids/#Modia3D.Solids.Solid"><code>Modia3D.Solid</code></a></td><td>Solids with geometry, mass, visual/contact material</td></tr><tr><td><code>&lt;:Modia3D.AbstractVisualElement</code></td><td>Visual elements (<a href="../Graphics/#Modia3D.Graphics"><code>Modia3D.Graphics</code></a>)</td></tr></table><p><strong>Main developers</strong></p><p>Andrea Neumayr and Martin Otter, <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Object3D" href="#Modia3D.Composition.Object3D"><code>Modia3D.Composition.Object3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">obj1 = Object3D([data]; visualizeFrame=Modia3D.Inherited)
obj2 = Object3D(parent [, data]; fixed=true, r=zeros(3), R=nothing, q=nothing, 
                v_start=zeros(3), w_start=zeros(3), 
                visualizeFrame=Modia3D.Inherited)</code></pre><p>Generate a new Object3D object, that is a coordinate system (= frame) with associated data. If <code>parent</code> is present, the Object3D is defined relatively to the parent Object3D. If <code>parent</code> is not present, the Object3D is either a reference object (such as the world-object), or the object is connected later with a joint to another  Object3D. If <code>fixed=true</code>, the object is rigidly connect to its parent; otherwise it is moving freely relative to its parent (mathematically described by quaternions).</p><p>Note, there are many convenience functions in ModiaMath.Frames to generate a ModiaMath.RotationMatrix <code>R</code> or a ModiaMath.Quaternion <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::Modia3D.AbstractObject3Ddata</code>: Optional data associated with Object3D.</p></li><li><p><code>parent::Object3D</code>: Parent object.</p></li><li><p><code>fixed::Bool</code>:</p><ul><li><code>fixed = true</code>, if the Object3D is fixed relatively to its parent Object3D at position <code>r,R,q</code>. It is best to provide the rotation information via <code>R</code> in this case. </li><li><code>fixed = false</code>, if Object3D can move freely relatively to its parent Object3D and is   initially placed at <code>r,R,q</code>. The movement is internally described with Quaternion vector <code>q</code>.  Therefore, it is best to provide the rotation information via <code>q</code> in this case.</li></ul></li><li><p><code>r::AbstractVector</code>: Initial relative position vector from frame of parent object to   origin of frame object, resolved in parent frame.</p></li><li><p><code>R::Union{ModiaMath.RotationMatrix,NOTHING}</code>: Initial rotation matrix defining the rotation   from frame of parent object to frame of Object3D. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li><li><p><code>q::Union{ModiaMath.Quaternion,NOTHING}</code>: Initial quaternion defining the rotation  from frame of parent object to frame of Object3D. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li><li><p><code>v_start::AbstractVector</code>: If <code>fixed=false</code>, initial velocity of the origin of Object3D with respect to parent, resolved in parent frame.</p></li><li><p><code>w_start::AbstractVector</code>: If <code>fixed=false</code>, initial angular velocity of Object3D with respect to parent, resolved in Object3D.</p></li><li><p><code>visualizeFrame::Union{Bool,Modia3D.Ternary}</code>: Coordinate system of Object3D is always (= true), or never (= false) visualized, or it is visualized if defined in SceneOptions(...) (= Modia3D.Inherited).</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D

# Define assembly
@assembly MyAssembly begin
   world = Object3D()

   # Frame fixed in world
   frame1 = Object3D(world; r=[0.1, 0.2, 0.3])

   # Frame moving relatively to frame1
   r2     = [0.2, 0.2, 0.3]
   frame2 = Object3D(frame1; fixed=false, r=r2)

   # Frame moving relatively to world
   frame3 = Object3D(world; fixed=false, r=-r2)
end
Modia3D.visualizeAssembly!(MyAssembly())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.PointGravityField" href="#Modia3D.Composition.PointGravityField"><code>Modia3D.Composition.PointGravityField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PointGravityField(mass), PointGravityField(;mue=G*EarthMass)</code></pre><p>Return a PointGravityField struct with the gravity field constant mue (mue = G*mass).</p><p><strong>Example</strong></p><pre><code class="language-julia">import Modia3D

grav = Modia3D.PointGravityField()   # Gravity field of earth
   r = Modia3D.EarthRadius
   g = gravityAcceleration(grav,r)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.SimulationModel" href="#Modia3D.Composition.SimulationModel"><code>Modia3D.Composition.SimulationModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">simModel = SimulationModel(assembly::Modia3D.AbstractAssembly;
                           analysis::ModiaMath.AnalysisType=ModiaMath.DynamicAnalysis,
                           startTime = 0.0, stopTime  = 1.0, tolerance = 1e-4,
                           interval  = (stopTime-startTime)/500.0)</code></pre><p>Generate a <code>simulationModel</code> from an <code>assembly</code> generated with macro <a href="#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.@assembly</code></a> and the type of <code>analysis</code> to be carried out on the <code>assembly</code>. Additionally, default <code>startTime</code>, <code>stopTime</code>, <code>tolerance</code>, <code>interval</code> for the simulation engine are defined. These values should be adapted so that assembly-specific, meaningful defaults are provided.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.UniformGravityField" href="#Modia3D.Composition.UniformGravityField"><code>Modia3D.Composition.UniformGravityField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UniformGravityField(;g=9.81, n=[0,1,0])</code></pre><p>Return a UniformGravityField struct.</p><p><strong>Arguments</strong></p><ul><li><code>g::Float64</code>: Gravity constant</li><li><code>n::AbstractVector</code>: Direction of gravity</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">import Modia3D

grav = Modia3D.UniformGravityField()
   r = Modia3D.EarthRadius
   g = gravityAcceleration(grav,r)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.Prismatic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">joint = Modia3D.Prismatic(obj1::Object3D, obj2::Object3D;
                          axis=1, s_start=0, v_start=0, canCollide=false)</code></pre><p>Return a <code>joint</code> object that constrains the movement of <code>obj2::</code><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a> with respect to <code>obj1::</code><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a> along coordinate axis <code>axis</code> (<code>axis = 1,2,3</code>). The initial position/velocity of <code>obj2</code> with respect to <code>obj1</code> along <code>axis</code> is <code>s_start</code> [m] and <code>v_start</code> [m/s], respectively. If <code>canCollide=false</code>, no collision detection will occur between <code>obj1</code> and <code>obj2</code> (and <code>Object3D</code>s that are directly or indirectly rigidly fixed to <code>obj1</code> or <code>obj2</code>).</p><p>If a <code>Prismatic</code> joint <em>closes a kinematic loop</em>, then the already present objects must be consistent to the <code>Prismatic</code> joint that is the frames of <code>obj1</code> and <code>obj2</code> must be <em>parallel</em> to each other and movement of <code>obj1</code> along its axis <code>axis</code> with <code>s_start</code> results in <code>obj2</code>. If <code>s_start=NaN</code>,  its value is computed in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D
import ModiaMath

@assembly FallingBall(;h=1.0) begin
   world  = Object3D()
   sphere = Object3D( Modia3D.Solid(Modia3D.SolidSphere(0.1), &quot;Aluminium&quot;) )

   # Constrain sphere movement (initial placement at position [0,h,0])
   prismatic = Modia3D.Prismatic(world, sphere, axis=2, s_start=h)  
end

simulationModel = Modia3D.SimulationModel( FallingBall(h=1.5), stopTime=1.0 )
result          = ModiaMath.simulate!(simulationModel)
ModiaMath.plot(result, (&quot;prismatic.s&quot;, &quot;prismatic.v&quot;))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.Revolute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">joint = Modia3D.Revolute(obj1, obj2; axis=3, phi_start=0, w_start=0, canCollide=false)</code></pre><p>Return a Revolute <code>joint</code> that rotates <code>obj1::</code><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a> into <code>obj2::</code><a href="#Modia3D.Composition.Object3D"><code>Object3D</code></a> along the z-axis of <code>obj1</code>. The initial start angle is <code>phi_start</code> and the initial angular velocity is <code>w_start</code>. If <code>canCollide=false</code>, no collision detection will occur between <code>obj1</code> and <code>obj2</code> (and <code>Object3D</code>s that are directly or indirectly rigidly fixed to <code>obj1</code> or <code>obj2</code>).</p><p>If a <code>Revolute</code> joint <em>closes a kinematic loop</em>, then the already present objects must be consistent to the <code>Revolute</code> joint that is the frames of <code>obj1</code> and <code>obj2</code> must be <em>parallel</em> to each other and rotation of <code>obj1</code> along its axis <code>axis</code> with <code>phi_start</code> results in <code>obj2</code>. If <code>phi_start=NaN</code>, its value is computed in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D
import ModiaMath

@assembly Pendulum(;L=1.0) begin
   world  = Modia3D.Object3D()
   frame1 = Modia3D.Object3D()
   rev    = Modia3D.Revolute(world, frame1)
   sphere = Modia3D.Object3D(frame1, Modia3D.Solid(Modia3D.SolidSphere(0.1), &quot;Aluminium&quot;),
                             r = [L,0,0] )
end

simulationModel = Modia3D.SimulationModel( Pendulum(L=0.8), stopTime=5.0 )
result          = ModiaMath.simulate!(simulationModel)
ModiaMath.plot(result, (&quot;rev.phi&quot;, &quot;rev.w&quot;))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.distance-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.distance-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">d = distance(frame1, frame2)</code></pre><p>Return the distance between the origin of frame1 and the origin of frame2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#Modia3D.Composition.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>Modia3D.Composition.planarRotationAngle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">angle = planarRotationAngle(e, v1, v2)
      = planarRotationAngle(frame1, frame2)</code></pre><p>Return angle of a planar rotation, given the rotation axis e (a unit vector) and the representations of a vector in frame 1 (v1) and frame 2 (v2).</p><p>Under the assumption that the z-axes of frame1 and frame2 coincide, return the angle between the x-axis of frame1 and the position vector from frame1 to frame2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.visualizeAssembly!-Tuple{Modia3D.AbstractAssembly}" href="#Modia3D.Composition.visualizeAssembly!-Tuple{Modia3D.AbstractAssembly}"><code>Modia3D.Composition.visualizeAssembly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">visualizeAssembly!(assembly::Modia3D.AbstractAssembly)</code></pre><p>Visualize the <code>assembly</code> defined with macro <a href="#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.@assembly</code></a> in its initial configuration (but without simulating it).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.@assembly-Tuple{Any,Any}" href="#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.Composition.@assembly</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@assembly AssemblyName(arguments) begin ... end</code></pre><p>Return the constructor for a new struct <code>AssemblyName</code> consisting of Object3Ds that are connected together. The new struct consists of all left-hand-side (scalar or vector) symbols present between <code>begin ... end</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D

@assembly Bar(;Lx = 0.1, Ly=Lx/5, Lz=Ly) begin
   frame0 = Modia3D.Object3D(Modia3D.Solid(Modia3D.SolidBeam(Lx,Ly,Lz), nothing, vmat1))
   frame1 = Modia3D.Object3D(frame0; r=[-Lx/2, 0.0, 0.0])
   frame2 = Modia3D.Object3D(frame0; r=[ Lx/2, 0.0, 0.0])
   cyl1   = Modia3D.Object3D(frame1, cyl)
   cyl2   = Modia3D.Object3D(frame2, cyl)
end
bar = Bar(;Lx=1.0)
Modia3D.visualizeAssembly!( bar )</code></pre></div></div></section><footer><hr/><a class="previous" href="../../man/Plans/"><span class="direction">Previous</span><span class="title">Plans for version 1.0</span></a><a class="next" href="../Graphics/"><span class="direction">Next</span><span class="title">Graphics</span></a></footer></article></body></html>
