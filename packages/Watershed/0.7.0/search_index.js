var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#Julia-version-of-3D-Watershed-1",
    "page": "Readme",
    "title": "Julia version of 3D Watershed",
    "category": "section",
    "text": "(Image: Build Status)This is a translation of Zlateski\'s C++ Watershed code."
},

{
    "location": "#Hierarchical-watershed-segmentation-1",
    "page": "Readme",
    "title": "Hierarchical watershed segmentation",
    "category": "section",
    "text": "Given an affinity graph as input, return as output a segmentation into watershed basins and a hierarchy generated by single linkage clustering. The segmentation is an indexed image, with nonnegative integer values running from 0 to the number of basins. The hierarchy can be represented by a segmentPairsrogram,  a tree in which leaves represent watershed basins, and internal vertices represent mergings of clusters. The height of each vertex is the affinity at which the merging occurs. The vanilla version of the algorithm typically produces severe oversegmentation, basins that are excessively numerous and/or small. Options are provided to moderate this tendency in two ways:Collapsing all subtrees above a height (high threshold) to single leaves. The resulting segmentPairsrogram defines a hierarchy on segments that are unions of watershed basins.\nCollapsing subtrees to eliminate leaves below a size threshold (but only for vertices above some height).After collapsing subtrees, the regions of the segmentation are all mergings of watershed basins, and the leaves of the segmentPairsrogram represent these regions. This implementation is for an affinity graph associated with a 3D image. Each vertex of the graph is an image voxel, and each edge between nearest neighbor pairs of voxels. A voxel has 6 nearest neighbors in the x,y,z,-x,-y, and -z directions, and the graph is said to have 6-connectivity.  The weight of an edge represents the “affinity” of two voxels for each other.  High affinity voxels tend to end up in the same segment, and low affinity voxels in different segments. Watershed basins are associated with local maxima of the graph, following the sign convention from graph partitioning in which edges between segments are minimized (and therefore edges within segments are maximized). This is potentially confusing, as the sign convention is the opposite from the original watershed definition in image processing.  In that field, watershed basins are associated with local minima, in accord with the metaphor of a \"drop of water flowing downhill.\"The affinity graph is represented by three images, because the number of edges in the affinity graph is three times the number of voxels in the image (neglecting boundary effects).  We use convolutional networks to generate the affinity graph from the image [Turaga et al. 2010], but other algorithms may be used.  The simplest case is an affinity graph in which the weight of each edge is the maximum of its two voxel values. Then the watershed basins are associated with local maxima of the image, and our watershed on graphs reduces to the conventional watershed on images (except for the flipped sign).In image processing, many watershed implementations identify the ridgelines that separate basins, and assign the label \"0\" to voxels on ridgelines.  Our watershed does not do this, because the ridgeline between two basins is regarded as being located on edges rather than voxels. However, our watershed can be made to label some voxels as background as follows.  Edges of the graph with affinity below a low threshold are removed. After this operation, some voxels become singletons, completely disconnected from the rest of the graph. These background voxels are given a label of \"0\" to distinguish them from foreground regions."
},

{
    "location": "#Installation-1",
    "page": "Readme",
    "title": "Installation",
    "category": "section",
    "text": "in Julia RSVP: update the metadata: Pkg.update()\nadd package: Pkg.add(\"Watershed\")\nupdate the code to latest master branch: Pkg.checkout(\"Watershed\")"
},

{
    "location": "#Usage-1",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "See test scripts for example of how to use functions. The main functions are in segment.jl"
},

{
    "location": "#Citation-1",
    "page": "Readme",
    "title": "Citation",
    "category": "section",
    "text": "@article{zlateski2015image,\n  title={Image segmentation by size-dependent single linkage clustering of a watershed basin graph},\n  author={Zlateski, Aleksandar and Seung, H Sebastian},\n  journal={arXiv preprint arXiv:1505.00249},\n  year={2015}\n}"
},

{
    "location": "#Credit-1",
    "page": "Readme",
    "title": "Credit",
    "category": "section",
    "text": "The algorithm is the same with Aleksandar Zlateski\'s C++ Watershed implementation.  This package was first translated to Julia by Sebastian Seung.  It is currently maintained by Jingpeng Wu."
},

{
    "location": "autodocs/#Watershed.divideplateaus!",
    "page": "Docstrings",
    "title": "Watershed.divideplateaus!",
    "category": "function",
    "text": "DIVIDEPLATEAUS! - Divide plateaus in steepest ascent graph\n\n divideplateaus!(sag)\n\nsag: steepest ascent graph (directed and unweighted). sag[x,y,z] contains 6-bit number encoding edges outgoing from (x,y,z)\n\nModify steepest ascent graph so as to\n\nDivide non-maximal plateaus into paths that exit as quickly as possible\nBreak ties between multiple outgoing edges\n\nNote this is an in-place modification of sag\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.findbasins",
    "page": "Docstrings",
    "title": "Watershed.findbasins",
    "category": "function",
    "text": "FINDBASINS - find basins of attraction\n\n seg, counts, counts0 = findbasins(sag)\n\nsag: steepest ascent graph (directed and unweighted). sag[x,y,z] contains 6-bit number encoding edges outgoing from (x,y,z)\nseg: segmentation into basins.  Each element of the 3D array contains a basin ID, a nonnegative integer ranging from 0 to the number of basins.\ncounts: number of voxels in each basin\ncounts0: number of background voxels\n\nA value of 0 in seg indicates a background voxel, which has no edges at all in the steepest ascent graph.  All such singletons are given the same ID of 0, although they are technically basins by themselves.\n\nThe algorithm starts from an unassigned voxel, and identifies all downstream voxels via breadth-first search (BFS). The search terminates in two possible ways:\n\ndownstream voxel that was previously assigned a basin ID =>\n\nassign that ID to queued voxels.\n\nno more downstream voxels => assign new basin ID to queued voxels.\n\nThen the queue is emptied, and BFS begins anew at an unassigned voxel. The algorithm ends when all voxels are assigned.\n\nThe 7th bit (0x40) is used to indicate whether a voxel has been visited during BFS.\n\nThe MSB indicates whether a voxel has been assigned a basin ID.  The MSB definition is given in the functions at the end of the file for UInt32 and UInt64 cases.\n\nfindbasins is applied to the steepest ascent graph after modification by divideplateaus!  By this point all paths are unique, except in maximal plateaus.\n\nwhat happens if findbasins is applied directly to the output of steepestascent?  ties are resolved in an unsystematic way.  seems to differ from Cousty\'s watershed cuts, which alternates btw DFS and BFS.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.mergeregions!",
    "page": "Docstrings",
    "title": "Watershed.mergeregions!",
    "category": "function",
    "text": "MERGEREGIONS - merge small regions by agglomerative clustering\n\nnew_rg = mergeregions(seg, rg, counts, thresholds, dust_size = 0)\n\nseg - segmentation.  IDs of foreground regions are 1:length(counts).  ID=0 for background.  This is modified in place by the clustering.\nrg: region graph as list of edges, array of (weight,id1,id2) tuples. The edges should be presorted so that weights are in descending order. Region IDs should be consistent with those in seg, except no zeros.\nnew_rg: new region graph after clustering, same format as rg.\ncounts: sizes of regions in seg (modified in place)\nthresholds: sequence of (sizeth,weightth) pairs to be used for merging\ndust_size: after merging, tiny regions less than dust_size to be eliminated by changing them to background voxels\n\nAgglomerative clustering proceeds by considering the edges of the region graph in sequence.  If either region has size less than size_th, then merge the regions. When the weight of the edge in the region graph is less than or equal to weight_th, agglomeration proceeds to the next (size_th,weight_th) in thresholds or terminates if there is none.\n\nto-do: update code to include self-edges in new_rg\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.mst",
    "page": "Docstrings",
    "title": "Watershed.mst",
    "category": "function",
    "text": "MST - compute maximal spanning tree from weighted graph\n\n regiontree = mst(rg,max_segid)\n\nrg: region graph as list of edges, array of (weight,id1,id2) tuples.  The edges should be presorted so that weights are in descending order.\nmax_segid: largest ID in region graph\nregiontree: maximal spanning tree (MST) of region graph as list of edges, array of (weight,id1,id2) tuples. The vertices in each edge are ordered so that id2 is unique across edges. In other words, id1 and id2 correspond to parent and child in the tree. The code places the root of the tree at segid=1\n\nThe MST effectively represents the segmentPairsrogram for single-linkage clustering.  Each edge (weight,id1,id2) in the MST represents an internal vertex of the dendrogram located at height = weight, i.e., a merging of two clusters with score weight.  The MST contains a bit more information than the dendrogram, because id1 and id2 are the root IDs of the two clusters, i.e., the maximum weight edge between the two clusters is between their elements id1 and id2.\n\nThe code should work for general graphs.  If edges of rg are presorted by ascending weight, the code will compute the minimal spanning tree rather than the maximal spanning tree.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.regiongraph",
    "page": "Docstrings",
    "title": "Watershed.regiongraph",
    "category": "function",
    "text": "REGIONGRAPH - create region graph by finding maximum affinity between each pair of regions in segmentation\n\n rg = regiongraph(aff,seg,max_segid)\n\nrg: region graph as list of edges, array of (weight,id1,id2) tuples. The edges are sorted so that weights are in descending order.\naff: affinity graph (undirected and weighted). 4D array of affinities, where last dimension is of size 3\nseg: segmentation.  Each element of the 3D array contains a segment ID, a nonnegative integer ranging from 0 to max_segid\nmax_segid: number of segments\n\nThe vertices of the region graph are regions in the segmentation.  An edge of the region graph corresponds to a pair of regions in the segmentation that are connected by an edge in the affinity graph.  The weight of an edge in the region graph is the maximum weight of the edges in the affinity graph connecting the two regions.\n\nThe region graph includes every edge between a region and itself. The weight of a self-edge is the maximum affinity within the region.\n\nBackground voxels (those with ID=0) are ignored.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.rg2segmentPairs",
    "page": "Docstrings",
    "title": "Watershed.rg2segmentPairs",
    "category": "function",
    "text": "transform rg to dendrogram for omnification\n\n\n\n\n\n"
},

{
    "location": "autodocs/#Watershed.steepestascent",
    "page": "Docstrings",
    "title": "Watershed.steepestascent",
    "category": "function",
    "text": "STEEPESTASCENT - Construct steepest ascent graph from affinity graph\n\n sag = steepestascent(aff, low, high)\n\nsag: steepest ascent graph (directed and unweighted). sag[x,y,z] contains 6-bit number encoding edges outgoing from (x,y,z)\naff: affinity graph (undirected and weighted). 4D array of affinities, where last dimension is of size 3\nlow: edges with affinity <= low are removed\nhigh: affinities >= high are considered infinity\n\nDirected paths in the steepest ascent graph are steepest ascent paths in the affinity graph.  Both graphs are for 3D lattice with 6-connectivity.  The steepest ascent graph can contain vertices with multiple outgoing edges if there are ties in the affinity graph, i.e., if steepest ascent paths are nonunique.\n\nWe follow the convention that:\n\naff[x,y,z,1] is affinity of voxels at [x-1,y,z] and [x,y,z]\naff[x,y,z,2] is affinity of voxels at [x,y-1,z] and [x,y,z]\naff[x,y,z,3] is affinity of voxels at [x,y,z-1] and [x,y,z]\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Watershed.AffinityMapWatershed.DEFAULT_DUST_SIZEWatershed.DEFAULT_HIGHWatershed.DEFAULT_IS_THRESHOLD_RELATIVEWatershed.DEFAULT_LOWWatershed.DEFAULT_THRESHOLDSWatershed.RegionGraphWatershed.SegmentationWatershed.WatershedWatershed._basesegWatershed._percent2thdWatershed._wsseg2dWatershed.aff2sgmWatershed.atomicsegWatershed.divideplateaus!Watershed.evalWatershed.findbasinsWatershed.findbasins!Watershed.high_bitWatershed.includeWatershed.low_bitsWatershed.mergeregions!Watershed.mergergWatershed.mergerg!Watershed.mstWatershed.regiongraphWatershed.relative2absoluteWatershed.rg2segmentPairsWatershed.steepestascentWatershed.watershedWatershed.wsseg"
},

]}
