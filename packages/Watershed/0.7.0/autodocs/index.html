<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Watershed.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Watershed.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Watershed.AffinityMap</code></pre><pre><code class="language-none">Watershed.DEFAULT_DUST_SIZE</code></pre><pre><code class="language-none">Watershed.DEFAULT_HIGH</code></pre><pre><code class="language-none">Watershed.DEFAULT_IS_THRESHOLD_RELATIVE</code></pre><pre><code class="language-none">Watershed.DEFAULT_LOW</code></pre><pre><code class="language-none">Watershed.DEFAULT_THRESHOLDS</code></pre><pre><code class="language-none">Watershed.RegionGraph</code></pre><pre><code class="language-none">Watershed.Segmentation</code></pre><pre><code class="language-none">Watershed.Watershed</code></pre><pre><code class="language-none">Watershed._baseseg</code></pre><pre><code class="language-none">Watershed._percent2thd</code></pre><pre><code class="language-none">Watershed._wsseg2d</code></pre><pre><code class="language-none">Watershed.aff2sgm</code></pre><pre><code class="language-none">Watershed.atomicseg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.divideplateaus!" href="#Watershed.divideplateaus!"><code>Watershed.divideplateaus!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>DIVIDEPLATEAUS!</code> - Divide plateaus in steepest ascent graph</p><pre><code class="language-none"> divideplateaus!(sag)</code></pre><ul><li><code>sag</code>: steepest ascent graph (directed and unweighted). <code>sag[x,y,z]</code> contains 6-bit number encoding edges outgoing from (x,y,z)</li></ul><p>Modify steepest ascent graph so as to</p><ol><li>Divide non-maximal plateaus into paths that exit as quickly as possible</li><li>Break ties between multiple outgoing edges</li></ol><p>Note this is an in-place modification of <code>sag</code></p></div></div></section><pre><code class="language-none">Watershed.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.findbasins" href="#Watershed.findbasins"><code>Watershed.findbasins</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>FINDBASINS</code> - find basins of attraction</p><pre><code class="language-none"> seg, counts, counts0 = findbasins(sag)</code></pre><ul><li><code>sag</code>: steepest ascent graph (directed and unweighted). <code>sag[x,y,z]</code> contains 6-bit number encoding edges outgoing from (x,y,z)</li><li><code>seg</code>: segmentation into basins.  Each element of the 3D array contains a <em>basin ID</em>, a nonnegative integer ranging from 0 to the number of basins.</li><li><code>counts</code>: number of voxels in each basin</li><li><code>counts0</code>: number of background voxels</li></ul><p>A value of 0 in <code>seg</code> indicates a background voxel, which has no edges at all in the steepest ascent graph.  All such singletons are given the same ID of 0, although they are technically basins by themselves.</p><p>The algorithm starts from an unassigned voxel, and identifies all downstream voxels via breadth-first search (BFS). The search terminates in two possible ways:</p><ol><li>downstream voxel that was previously assigned a basin ID =&gt;</li></ol><p>assign that ID to queued voxels.</p><ol><li>no more downstream voxels =&gt; assign new basin ID to queued voxels.</li></ol><p>Then the queue is emptied, and BFS begins anew at an unassigned voxel. The algorithm ends when all voxels are assigned.</p><p>The 7th bit (0x40) is used to indicate whether a voxel has been visited during BFS.</p><p>The MSB indicates whether a voxel has been assigned a basin ID.  The MSB definition is given in the functions at the end of the file for UInt32 and UInt64 cases.</p><p><code>findbasins</code> is applied to the steepest ascent graph after modification by <code>divideplateaus!</code>  By this point all paths are unique, except in maximal plateaus.</p><p><strong>what happens if <code>findbasins</code> is applied directly to the output of <code>steepestascent</code>?  ties are resolved in an unsystematic way.  seems to differ from Cousty&#39;s watershed cuts, which alternates btw DFS and BFS.</strong></p></div></div></section><pre><code class="language-none">Watershed.findbasins!</code></pre><pre><code class="language-none">Watershed.high_bit</code></pre><pre><code class="language-none">Watershed.include</code></pre><pre><code class="language-none">Watershed.low_bits</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.mergeregions!" href="#Watershed.mergeregions!"><code>Watershed.mergeregions!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>MERGEREGIONS</code> - merge small regions by agglomerative clustering</p><pre><code class="language-none">new_rg = mergeregions(seg, rg, counts, thresholds, dust_size = 0)</code></pre><ul><li><code>seg</code> - segmentation.  IDs of foreground regions are 1:length(counts).  ID=0 for background.  This is modified in place by the clustering.</li><li><code>rg</code>: region graph as list of edges, array of (weight,id1,id2) tuples. The edges should be presorted so that weights are in descending order. Region IDs should be consistent with those in <code>seg</code>, except no zeros.</li><li><code>new_rg</code>: new region graph after clustering, same format as <code>rg</code>.</li><li><code>counts</code>: sizes of regions in <code>seg</code> (modified in place)</li><li><code>thresholds</code>: sequence of (size<em>th,weight</em>th) pairs to be used for merging</li><li><code>dust_size</code>: after merging, tiny regions less than dust_size to be eliminated by changing them to background voxels</li></ul><p>Agglomerative clustering proceeds by considering the edges of the region graph in sequence.  If either region has size less than <code>size_th</code>, then merge the regions. When the weight of the edge in the region graph is less than or equal to <code>weight_th</code>, agglomeration proceeds to the next <code>(size_th,weight_th)</code> in <code>thresholds</code> or terminates if there is none.</p><p><strong>to-do: update code to include self-edges in <code>new_rg</code></strong></p></div></div></section><pre><code class="language-none">Watershed.mergerg</code></pre><pre><code class="language-none">Watershed.mergerg!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.mst" href="#Watershed.mst"><code>Watershed.mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>MST</code> - compute maximal spanning tree from weighted graph</p><pre><code class="language-none"> regiontree = mst(rg,max_segid)</code></pre><ul><li><code>rg</code>: region graph as list of edges, array of (weight,id1,id2) tuples.  The edges should be presorted so that weights are in descending order.</li><li><code>max_segid</code>: largest ID in region graph</li><li><code>regiontree</code>: <em>maximal</em> spanning tree (MST) of region graph as list of edges, array of <code>(weight,id1,id2)</code> tuples. The vertices in each edge are ordered so that <code>id2</code> is unique across edges. In other words, id1 and id2 correspond to parent and child in the tree. The code places the root of the tree at segid=1</li></ul><p>The MST effectively represents the segmentPairsrogram for single-linkage clustering.  Each edge <code>(weight,id1,id2)</code> in the MST represents an internal vertex of the dendrogram located at height = <code>weight</code>, i.e., a merging of two clusters with score <code>weight</code>.  The MST contains a bit more information than the dendrogram, because <code>id1</code> and <code>id2</code> are the root IDs of the two clusters, i.e., the maximum weight edge between the two clusters is between their elements <code>id1</code> and <code>id2</code>.</p><p>The code should work for general graphs.  If edges of <code>rg</code> are presorted by ascending weight, the code will compute the <em>minimal</em> spanning tree rather than the maximal spanning tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.regiongraph" href="#Watershed.regiongraph"><code>Watershed.regiongraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>REGIONGRAPH</code> - create region graph by finding maximum affinity between each pair of regions in segmentation</p><pre><code class="language-none"> rg = regiongraph(aff,seg,max_segid)</code></pre><ul><li><code>rg</code>: region graph as list of edges, array of (weight,id1,id2) tuples. The edges are sorted so that weights are in descending order.</li><li><code>aff</code>: affinity graph (undirected and weighted). 4D array of affinities, where last dimension is of size 3</li><li><code>seg</code>: segmentation.  Each element of the 3D array contains a <em>segment ID</em>, a nonnegative integer ranging from 0 to <code>max_segid</code></li><li><code>max_segid</code>: number of segments</li></ul><p>The vertices of the region graph are regions in the segmentation.  An edge of the region graph corresponds to a pair of regions in the segmentation that are connected by an edge in the affinity graph.  The weight of an edge in the region graph is the maximum weight of the edges in the affinity graph connecting the two regions.</p><p>The region graph includes every edge between a region and itself. The weight of a self-edge is the maximum affinity within the region.</p><p>Background voxels (those with ID=0) are ignored.</p></div></div></section><pre><code class="language-none">Watershed.relative2absolute</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.rg2segmentPairs" href="#Watershed.rg2segmentPairs"><code>Watershed.rg2segmentPairs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>transform rg to dendrogram for omnification</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Watershed.steepestascent" href="#Watershed.steepestascent"><code>Watershed.steepestascent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>STEEPESTASCENT</code> - Construct steepest ascent graph from affinity graph</p><pre><code class="language-none"> sag = steepestascent(aff, low, high)</code></pre><ul><li><code>sag</code>: steepest ascent graph (directed and unweighted). <code>sag[x,y,z]</code> contains 6-bit number encoding edges outgoing from (x,y,z)</li><li><code>aff</code>: affinity graph (undirected and weighted). 4D array of affinities, where last dimension is of size 3</li><li><code>low</code>: edges with affinity &lt;= <code>low</code> are removed</li><li><code>high</code>: affinities &gt;= <code>high</code> are considered infinity</li></ul><p>Directed paths in the steepest ascent graph are steepest ascent paths in the affinity graph.  Both graphs are for 3D lattice with 6-connectivity.  The steepest ascent graph can contain vertices with multiple outgoing edges if there are ties in the affinity graph, i.e., if steepest ascent paths are nonunique.</p><p>We follow the convention that:</p><ul><li><code>aff[x,y,z,1]</code> is affinity of voxels at [x-1,y,z] and [x,y,z]</li><li><code>aff[x,y,z,2]</code> is affinity of voxels at [x,y-1,z] and [x,y,z]</li><li><code>aff[x,y,z,3]</code> is affinity of voxels at [x,y,z-1] and [x,y,z]</li></ul></div></div></section><pre><code class="language-none">Watershed.watershed</code></pre><pre><code class="language-none">Watershed.wsseg</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
