<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · ExtensibleScheduler.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ExtensibleScheduler.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">ExtensibleScheduler Overview</a></li><li class="current"><a class="toctext" href>Getting Started</a><ul class="internal"><li><a class="toctext" href="#Install-1">Install</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Library-Outline-1">Library Outline</a></li><li><a class="toctext" href="#See-also-1">See also</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Getting Started</a></li></ul></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><h2><a class="nav-anchor" id="Install-1" href="#Install-1">Install</a></h2><p><code>ExtensibleScheduler</code> is a registered package. To add it to your Julia packages, simply do the following in REPL:</p><pre><code class="language-julia">Pkg.add(&quot;ExtensibleScheduler&quot;)</code></pre><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><div><pre><code class="language-julia">using ExtensibleScheduler
using TimeFrames
using Dates: now

function print_time_noparam()
    println(&quot;From print_time_noparam $(now(Dates.UTC))&quot;)
end

function print_time_args(x)
    println(&quot;From print_time_args $(now(Dates.UTC)) $x&quot;)
end

function print_time_kwargs(; a=&quot;default&quot;)
    println(&quot;From print_time_kwargs $(now(Dates.UTC)) $a&quot;)
end

function sample()
    # Use BlockingScheduler with default jobstore, default executor...
    sched = BlockingScheduler()

    # Define what action will be executed
    action = Action(print_time_kwargs; Dict(:a=&gt;&quot;keyword&quot;)...)

    # Define when job should be triggered
    trigger = Trigger(DateTime(2017, 12, 17, 20, 8, 0))  # execute one time at given DateTime
    #trigger = Trigger(DateTime(2017, 12, 17, 20, 8, 5))  # execute one time at given DateTime
    #trigger = Trigger(now(Dates.UTC) - Dates.Second(5))  # execute one time at given DateTime (misfire)
    #trigger = Trigger(now(Dates.UTC) + Dates.Second(5))  # execute one time at given DateTime
    #trigger = Trigger(Dates.Time(15, 58), n=1)  # execute one time at given Time (of current day or of next day)
    #trigger = Trigger(Seconds(5), n=1)  # execute one time (5 seconds after being add)
    #trigger = Trigger(tf&quot;5s&quot;)  # periodic job ; priority=0 by default
    
    # Add job to jobstore
    add(sched, action, trigger)

    # Run scheduler
    run(sched)
end

sample()
</code></pre></div><p><a href="../sample/sample.jl">Download example</a></p><h2><a class="nav-anchor" id="Library-Outline-1" href="#Library-Outline-1">Library Outline</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.ExtensibleScheduler" href="#ExtensibleScheduler.ExtensibleScheduler"><code>ExtensibleScheduler.ExtensibleScheduler</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A generally useful event scheduler module.</p><p>The <code>ExtensibleScheduler</code> package provides advanced and extensible <a href="https://julialang.org/">Julia</a> events schedulers inspired by Python schedulers <a href="https://apscheduler.readthedocs.io/">APScheduler</a>, <a href="https://github.com/dbader/schedule">schedule</a> and <a href="https://docs.python.org/3/library/sched.html">sched</a>.</p><p>It&#39;s also inspired by <a href="https://github.com/scls19fr/Sched.jl">Sched.jl</a>, a Julia event scheduler inspired by Python <a href="https://docs.python.org/3/library/sched.html">sched</a>.</p><p>Schedulers can use real time clock (system time) or simulated time (for simulation purpose).</p></div></div></section><h3><a class="nav-anchor" id="Schedulers-1" href="#Schedulers-1">Schedulers</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.AbstractScheduler" href="#ExtensibleScheduler.AbstractScheduler"><code>ExtensibleScheduler.AbstractScheduler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AbstractScheduler</code> is an abstract type for schedulers.</p><p>Schedulers are structs which are responsible of running  <code>Action</code> at given instants (according a <code>Trigger</code>).</p><p>Several kind of schedulers can implement <code>AbstractScheduler</code>.</p><p>The most simple scheduler is <code>BlockingScheduler</code> which is monothread.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.BlockingScheduler" href="#ExtensibleScheduler.BlockingScheduler"><code>ExtensibleScheduler.BlockingScheduler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BlockingScheduler(; clock=real_time_clock, delayfunc=_sleep, jobconfig=JobConfig())</code></pre><p><code>BlockingScheduler</code> is the simplest scheduler. It implements <code>AbstractScheduler</code>.</p><p>This is a monothread implementation of scheduling job.</p><p><strong>Optional arguments</strong></p><ul><li><code>clock::AbstractClock</code>: clock that will be used by scheduler (it&#39;s by default <code>real_time_clock</code>, which is system UTC time but a <code>SimClock</code> struct can also be passed for simulation purpose).</li><li><code>delayfunc::DelayFunc</code>: functor which is responsible (when called) of waiting until next task should be fired (<code>_sleep</code> is used by default but a <code>NoSleep</code> struct can also be passed for simulation purpose).</li><li><code>jobconfig::JobConfig</code>: job configuration default settings (<code>misfire_grace_period</code>...)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.add-Tuple{ExtensibleScheduler.AbstractScheduler,Action,ExtensibleScheduler.AbstractTrigger}" href="#ExtensibleScheduler.add-Tuple{ExtensibleScheduler.AbstractScheduler,Action,ExtensibleScheduler.AbstractTrigger}"><code>ExtensibleScheduler.add</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add(sched, action, trigger; name=DEFAULT_JOB_NAME, priority=DEFAULT_PRIORITY)</code></pre><p>Schedule when an <code>Action</code> named <code>action</code> should be triggered (according <code>trigger</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run-Tuple{BlockingScheduler}" href="#Base.run-Tuple{BlockingScheduler}"><code>Base.run</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run(sched)</code></pre><p>Run (in a blocking loop) a scheduler named <code>sched</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.run_pending-Tuple{BlockingScheduler}" href="#ExtensibleScheduler.run_pending-Tuple{BlockingScheduler}"><code>ExtensibleScheduler.run_pending</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run_pending(sched)</code></pre><p>Run pending tasks of a scheduler <code>sched</code>.</p><p>This function should be called instead of <code>run</code> when using scheduler in simulation mode.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.shutdown-Tuple{BlockingScheduler}" href="#ExtensibleScheduler.shutdown-Tuple{BlockingScheduler}"><code>ExtensibleScheduler.shutdown</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shutdown(sched)</code></pre><p>Shutdown scheduler <code>sched</code>.</p></div></div></section><h3><a class="nav-anchor" id="Action-1" href="#Action-1">Action</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.Action" href="#ExtensibleScheduler.Action"><code>ExtensibleScheduler.Action</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Action(func, args...; kwargs...)</code></pre><p>An <code>Action</code> is a structure (a functor in fact) which stores function, arguments and keyword arguments.</p><p>An <code>Action</code> can be run (in fact it&#39;s run internally by a scheduler when a <code>Job</code> is triggered.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run-Tuple{Action}" href="#Base.run-Tuple{Action}"><code>Base.run</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">run(action::Action)</code></pre><p>Run <code>action</code>.</p><p>This function shouldn&#39;t be called directly. It&#39;s called by scheduler when a job is triggered.</p></div></div></section><h3><a class="nav-anchor" id="JobStore-1" href="#JobStore-1">JobStore</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.AbstractJobStore" href="#ExtensibleScheduler.AbstractJobStore"><code>ExtensibleScheduler.AbstractJobStore</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AbstractJobStore</code> is an abstract type for jobstores</p><p>A jobstore is a data structure which is responsible of storing jobs that should be executed later.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.MemoryJobStore" href="#ExtensibleScheduler.MemoryJobStore"><code>ExtensibleScheduler.MemoryJobStore</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MemoryJobStore()</code></pre><p><code>MemoryJobStore</code> implements <code>AbstractJobStore</code>.</p><p>This is a data structure which is responsible of storing into memory jobs that should be executed later.</p></div></div></section><h3><a class="nav-anchor" id="Triggers-1" href="#Triggers-1">Triggers</a></h3><h4><a class="nav-anchor" id="Triggers-construction-1" href="#Triggers-construction-1">Triggers construction</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.Trigger" href="#ExtensibleScheduler.Trigger"><code>ExtensibleScheduler.Trigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Trigger(dt::DateTime)</code></pre><p>Return an <code>InstantTrigger</code> which should trigger job at a given <code>DateTime</code> <code>dt</code></p></div></div><div><div><pre><code class="language-none">Trigger(d::Date)</code></pre><p>Return an <code>InstantTrigger</code> which should trigger job at a given <code>Date</code> <code>d</code>(at midnight)</p></div></div><div><div><pre><code class="language-none">Trigger(t::Dates.Time[, n=number_of_times])</code></pre><p>Return an <code>TimeTrigger</code> which should trigger a job daily at a given time (once, a finite number of times or indefinitely).</p></div></div><div><div><pre><code class="language-none">Trigger(td::Dates.Period[, n=number_of_times])</code></pre><p>Return an <code>PeriodTrigger</code> which should trigger a job after a given period (<code>DatePeriod</code> or <code>TimePeriod</code>).</p></div></div><div><div><pre><code class="language-none">Trigger(tf::TimeFrame[, n=number_of_times])</code></pre><p>Return an <code>TimeFrameTrigger</code> which should trigger a job at a given instant according timeframe periodicity. (from <a href="https://github.com/femtotrader/TimeFrames.jl">TimeFrames.jl</a>)</p></div></div><div><div><pre><code class="language-none">Trigger(f::Function[, n=number_of_times])</code></pre><p>Return an <code>CustomTrigger</code> which should trigger a job according a function <code>f</code>.</p></div></div></section><h4><a class="nav-anchor" id="Trigger-iteration-1" href="#Trigger-iteration-1">Trigger iteration</a></h4><p>Iteration can help to know when job should be triggered.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iterate-Tuple{ExtensibleScheduler.AbstractTrigger,Any}" href="#Base.iterate-Tuple{ExtensibleScheduler.AbstractTrigger,Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iterate(trigger, dt[, n=number_of_times])</code></pre><p>Iterate from instant <code>dt</code> using trigger with a given iteration number <code>n</code>  if <code>n &lt; 0</code> (<code>-1</code> by default), it iterates indefinitely.</p><p><strong>Usage</strong></p><pre><code class="language-none">julia&gt; trigger = Trigger(Dates.Time(20, 30))

julia&gt; for dt in iterate(trigger, DateTime(2020, 1, 1), n=3)
         @show dt
       end
dt = 2020-01-01T20:30:00
dt = 2020-01-02T20:30:00
dt = 2020-01-03T20:30:00

julia&gt; collect(iterate(trigger, DateTime(2020, 1, 1), n=3))
3-element Array{Any,1}:
 2020-01-01T20:30:00
 2020-01-02T20:30:00
 2020-01-03T20:30:00</code></pre></div></div></section><h4><a class="nav-anchor" id="Private-1" href="#Private-1">Private</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.InstantTrigger" href="#ExtensibleScheduler.InstantTrigger"><code>ExtensibleScheduler.InstantTrigger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InstantTrigger(dt::DateTime)</code></pre><p>A trigger which should trigger job at a given instant (a given <code>DateTime</code> for example)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.TimeTrigger" href="#ExtensibleScheduler.TimeTrigger"><code>ExtensibleScheduler.TimeTrigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TimeTrigger(t::Dates.Time[, n=number_of_times])</code></pre><p>A trigger which should trigger a job daily at a given time.</p><p><strong>Optional parameter</strong></p><ul><li><code>n=1</code>: trigger once</li><li><code>n=-1</code> (default): trigger every day indefinitely</li><li><code>n=value</code>: trigger just a number of times</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.PeriodTrigger" href="#ExtensibleScheduler.PeriodTrigger"><code>ExtensibleScheduler.PeriodTrigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PeriodTrigger(t::Dates.Time[, n=number_of_times])</code></pre><p>A trigger which should trigger a job after a given period (<code>DatePeriod</code> or <code>TimePeriod</code>)</p><p><strong>Optional parameter</strong></p><ul><li><code>n=1</code>: trigger once</li><li><code>n=-1</code> (default): trigger every day indefinitely</li><li><code>n=value</code>: trigger just a number of times</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.TimeFrameTrigger" href="#ExtensibleScheduler.TimeFrameTrigger"><code>ExtensibleScheduler.TimeFrameTrigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">TimeFrameTrigger(tf::TimeFrame)</code></pre><p>A trigger which should trigger a job at a given instant according timeframe periodicity (from <a href="https://github.com/femtotrader/TimeFrames.jl">TimeFrames.jl</a>)</p><p><strong>Example</strong></p><pre><code class="language-none">TimeFrameTrigger(&quot;H&quot;)</code></pre><p>should run a job every hour</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.CustomTrigger" href="#ExtensibleScheduler.CustomTrigger"><code>ExtensibleScheduler.CustomTrigger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CustomTrigger(f::Function[, n=number_of_times])</code></pre><p>A trigger which should trigger a job according a function <code>f</code>.</p><p>It&#39;s generally a better idea (cleaner implementation) to write your own  trigger from  <code>AbstractTrigger</code>, <code>AbstractFiniteTrigger</code> or <code>AbstractInfiniteTrigger</code>  but passing a function to a <code>CustomTrigger</code> can be quite handy</p><p>Job can be triggered:</p><ul><li>once (<code>n=1</code>)</li><li>a finite number of times (<code>n=number_of_times</code>)</li><li>indefinitely (without setting <code>n</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">f = (dt_previous_fire, dt_now) -&gt; dt_now + Dates.Minute(5)
trigger = CustomTrigger(f)</code></pre><p>should run a job every 5 minutes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.NoTrigger" href="#ExtensibleScheduler.NoTrigger"><code>ExtensibleScheduler.NoTrigger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>NoTrigger define a trigger that never trigger.</p><p>It&#39;s a useful struct for triggers operations such as applying offset or jitter to a trigger.</p></div></div></section><h4><a class="nav-anchor" id="Triggers-operations-1" href="#Triggers-operations-1">Triggers operations</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.TriggerOffset" href="#ExtensibleScheduler.TriggerOffset"><code>ExtensibleScheduler.TriggerOffset</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TriggerOffset(trigger, offset)</code></pre><p>or</p><pre><code class="language-none">TriggerOffset(offset)</code></pre><p>A trigger operation to shift instant when a job should be triggered (adding an offset)</p><p>Addition <code>+</code> and substraction <code>-</code> are implemented so it&#39;s possible to define a new trigger using</p><pre><code class="language-none">Trigger(&quot;H&quot;) + TriggerOffset(Date.Minute(3))</code></pre><p>to be able to run a job every hour at 3 minutes after round after.</p><p>This is same as:</p><pre><code class="language-none">TriggerOffset(Trigger(&quot;H&quot;), Date.Minute(3))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.TriggerJitter" href="#ExtensibleScheduler.TriggerJitter"><code>ExtensibleScheduler.TriggerJitter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TriggerJitter(trigger, offset)</code></pre><p>or</p><pre><code class="language-none">TriggerOffset(offset)</code></pre><p>A trigger operation that apply <a href="https://en.wikipedia.org/wiki/Jitter">jitter</a> to instant when a job should be triggered.</p><p>Addition <code>+</code> and substraction <code>-</code> are implemented so it&#39;s possible to define a new trigger using</p><pre><code class="language-none">Trigger(&quot;H&quot;) + TriggerJitter(Date.Minute(3))</code></pre><p>to be able to run a job every hour with a random jitter of 3 minutes. This is same as:</p><pre><code class="language-none">TriggerJitter(Trigger(&quot;H&quot;), Date.Minute(3))</code></pre><p>Randomize <code>next_dt_fire</code> by adding or subtracting a random value (the jitter). If the resulting DateTime is in the past, returns the initial <code>next_dt_fire</code> without jitter.</p><p>next<em>dt</em>fire - jitter &lt;= result &lt;= next<em>dt</em>fire + jitter</p></div></div></section><h3><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h3><h3><a class="nav-anchor" id="Job-1" href="#Job-1">Job</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.Job" href="#ExtensibleScheduler.Job"><code>ExtensibleScheduler.Job</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Job(id, action, trigger, name, priority, dt_created, dt_updated, dt_next_fire, n_triggered, config)</code></pre><p>A job is an internal structure which store what action  should be executed when triggered.</p><p>It also store several properties such as priority level, number of time a job is triggered, when will next trigger should occur...</p></div></div></section><h3><a class="nav-anchor" id="Priority-1" href="#Priority-1">Priority</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExtensibleScheduler.Priority" href="#ExtensibleScheduler.Priority"><code>ExtensibleScheduler.Priority</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Priority(time_, priority)</code></pre><p>Priority of events.</p><p>Comparison is first done by time, and after (if same time) using priority value.</p><p>As in UNIX, lower priority numbers mean higher priority.</p></div></div></section><h2><a class="nav-anchor" id="See-also-1" href="#See-also-1">See also</a></h2><ul><li><a href="https://scls19fr.github.io/Sched.jl/latest/">Sched.jl</a> A <a href="https://julialang.org/">Julia</a> events scheduler inspired by <a href="https://docs.python.org/3/library/sched.html">Python sched</a>.</li><li><a href="https://discourse.julialang.org/t/julia-cron-like-event-scheduler/6899">https://discourse.julialang.org/t/julia-cron-like-event-scheduler/6899</a></li></ul><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">ExtensibleScheduler Overview</span></a></footer></article></body></html>
