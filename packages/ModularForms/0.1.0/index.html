<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModularForms.jl Documentation · ModularForms.jl: computation with modular forms in Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModularForms.jl: computation with modular forms in Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>ModularForms.jl Documentation</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>ModularForms.jl Documentation</a></li></ul></nav><hr/><div id="topbar"><span>ModularForms.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ModularForms.jl-Documentation-1" href="#ModularForms.jl-Documentation-1">ModularForms.jl Documentation</a></h1><ul><li><a href="#ModularForms.jl-Documentation-1">ModularForms.jl Documentation</a></li><ul><li><a href="#Functions-1">Functions</a></li><li><a href="#Index-1">Index</a></li></ul></ul><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.delta_qexp" href="#ModularForms.delta_qexp"><code>ModularForms.delta_qexp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delta_qexp(prec=10, var=&quot;q&quot;, K=ZZ)</code></pre><p>Return the q-expansion of the normalized cusp form of weight 12 to  precision <code>prec</code> as a power series over <code>K</code> in the variable <code>var</code>. </p><p><strong>Arguments</strong></p><ul><li><code>prec::Integer=10</code>: precision of the output </li><li><code>var::String=&quot;q&quot;</code>: variable name</li><li><code>K=ZZ</code>: base ring of the output</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.delta_k_qexp" href="#ModularForms.delta_k_qexp"><code>ModularForms.delta_k_qexp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delta_k_qexp(k, prec=10, var=&quot;q&quot;)</code></pre><p>Return the q-expansion of the unique normalized eigenform of weight  <code>k</code> and level 1 for k in {12, 16, 18, 20, 22, 26} as a power series  to precision <code>prec</code> in <code>var</code> over ZZ.</p><p>These eigenforms are the normalized generators for the six  one-dimensional spaces of cusp forms of level 1.  </p><p><strong>Arguments</strong></p><ul><li><code>k::Integer</code>: weight of the unique normalized eigenform</li><li><code>prec::Integer=10</code>: precision of the output </li><li><code>var::String=&quot;q&quot;</code>: variable name</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.eisenstein_series_qexp" href="#ModularForms.eisenstein_series_qexp"><code>ModularForms.eisenstein_series_qexp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eisenstein_series_qexp(k, prec=10, K=QQ, var=&quot;q&quot;, normalization=&quot;linear&quot;)</code></pre><p>Return the q-expansion of the normalized weight <code>k</code> Eisenstein series  on the modular group to precision <code>prec</code> as a power series in the ring  <code>K</code> in variable <code>var</code>, using the given <code>normalization</code>. </p><p>Three normalizations are available: &quot;linear&quot; (default), &quot;constant&quot;,  and &quot;integral&quot;. If the normalization is &quot;linear&quot; then the linear  coefficient is 1. If it is &quot;constant&quot; then the series will be  normalized to have constant term 1. If the normalization is &quot;integral&quot; then the series will be normalized to have integer coefficients and no  common factors.  Note: To prevent errors, the output will be in the ring QQ if the  normalization is &quot;linear&quot; or &quot;constant&quot;.</p><p><strong>Arguments</strong></p><ul><li><code>k::Integer</code>: even positive integer, weight of the Eisenstein series</li><li><code>prec::Integer=10</code>: precision of the output </li><li><code>K=ZZ</code>: base ring of the output </li><li><code>var::String=&quot;q&quot;</code>: variable name</li><li><code>normalization::String=&quot;linear&quot;</code>: normalization to use</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.eta_quotient" href="#ModularForms.eta_quotient"><code>ModularForms.eta_quotient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eta_quotient(g, prec=10)</code></pre><p>Return the eta-quotient relative to the given collection of integers <code>g</code> as a power series up to precision <code>prec</code>. </p><p>The input g is an array of pairs [[t<em>1,r</em>1], [t<em>2,r</em>2], ..., [t<em>s,r</em>s]]  where each t<em>j is a positive integer and each r</em>j a nonnegative integer.  An error is thrown if the sum of t<em>j*r</em>j for j in {1, ..., s} does not equal 24, as the function only applies to eta-quotients that are cusp forms. The output is a cusp form of integral weight.  </p><p><strong>Arguments</strong></p><ul><li><code>g::Array{Array}</code>: an array of pairs, collection of integers</li><li><code>prec::Integer=10</code>: precision of the output</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.victor_miller_basis" href="#ModularForms.victor_miller_basis"><code>ModularForms.victor_miller_basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">victor_miller_basis_poly(k, prec=10, cusp_only=false, var=&quot;q&quot;)</code></pre><p>Return the Victor Miller basis for modular forms of weight <code>k</code> and level 1 to precision <code>prec</code> as an array whose entries are power series in ZZ[[<code>var</code>]]. If <code>cusp_only</code> is true, then return only a basis for the cuspidal subspace.</p><p>The algorithm uses the proof of Lemma 2.20 from William A. Stein.</p><p><strong>Arguments</strong></p><ul><li><code>k::Integer</code>: weight</li><li><code>prec::Integer=10</code>: precision of the output</li><li><code>cusp_only::Boolean=false</code></li><li><code>var::String=&quot;q&quot;</code>: variable name</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.hecke_operator_on_qexp" href="#ModularForms.hecke_operator_on_qexp"><code>ModularForms.hecke_operator_on_qexp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hecke_operator_on_qexp(f, n, k, prec=nothing)</code></pre><p>Compute the image of the q-expansion <code>f</code> of a modular form under the Hecke operator T_<code>n</code> of weight <code>k</code>. Return a power series to precision <code>prec</code>. </p><p><strong>Arguments</strong></p><ul><li><code>f::RelSeriesElem</code>: q-expansion</li><li><code>n::Integer</code>: integer &gt;=1 </li><li><code>k::Integer</code>: weight </li><li><code>prec::Integer=nothing</code>: precision of the output</li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.hecke_operator_on_basis" href="#ModularForms.hecke_operator_on_basis"><code>ModularForms.hecke_operator_on_basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hecke_operator_on_basis(B, n, k)</code></pre><p>Compute the matrix of the Hecke operator T_<code>n</code> of weight <code>k</code> relative to the given basis <code>B</code> of q-expansions for a space of  modular forms. </p><p><strong>Arguments</strong></p><ul><li><code>B::Array</code>: array of q-expansions</li><li><code>n::Integer</code>: integer &gt;=1 </li><li><code>k::Integer</code>: weight </li></ul><p><strong>Examples still missing</strong></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.prime_range" href="#ModularForms.prime_range"><code>ModularForms.prime_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prime_range(n)</code></pre><p>Return an array consisting of all primes up to and including <code>n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModularForms.poly_to_power_series" href="#ModularForms.poly_to_power_series"><code>ModularForms.poly_to_power_series</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">poly_to_power_series(f, K, prec=10)</code></pre><p>Convert the polynomial <code>f</code> over <code>K</code> to a relative power series  to precision <code>prec</code> as a polynomial.</p><p>The power series has the same coefficient ring and variable  name as f. The input polynomial f must be correct up to  precision prec. </p><p><strong>Arguments</strong></p><p>&#39; <code>f::PolyElem</code>: polynomial over K, correct up to prec</p><ul><li><code>K</code>: base ring of the output</li><li><code>prec::Integer=10</code>: precision of the output</li></ul><p><strong>Examples still missing</strong></p></div></div></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#ModularForms.delta_k_qexp"><code>ModularForms.delta_k_qexp</code></a></li><li><a href="#ModularForms.delta_qexp"><code>ModularForms.delta_qexp</code></a></li><li><a href="#ModularForms.eisenstein_series_qexp"><code>ModularForms.eisenstein_series_qexp</code></a></li><li><a href="#ModularForms.eta_quotient"><code>ModularForms.eta_quotient</code></a></li><li><a href="#ModularForms.hecke_operator_on_basis"><code>ModularForms.hecke_operator_on_basis</code></a></li><li><a href="#ModularForms.hecke_operator_on_qexp"><code>ModularForms.hecke_operator_on_qexp</code></a></li><li><a href="#ModularForms.poly_to_power_series"><code>ModularForms.poly_to_power_series</code></a></li><li><a href="#ModularForms.prime_range"><code>ModularForms.prime_range</code></a></li><li><a href="#ModularForms.victor_miller_basis"><code>ModularForms.victor_miller_basis</code></a></li></ul><footer><hr/></footer></article></body></html>
