<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SimpleGraphs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleGraphs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.AbstractSimpleGraph" href="#SimpleGraphs.AbstractSimpleGraph"><code>SimpleGraphs.AbstractSimpleGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AbstractSimpleGraph</code> is a parent class for <code>SimpleGraph</code> and <code>SimpleDigraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.BuckyBall" href="#SimpleGraphs.BuckyBall"><code>SimpleGraphs.BuckyBall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>BuckyBall()</code> returns the Bucky ball graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Complete" href="#SimpleGraphs.Complete"><code>SimpleGraphs.Complete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Complete(n)</code> returns a complete graph with <code>n</code> vertices <code>1:n</code>.</p><p><code>Complete(n,m)</code> returns a complete bipartite graph with <code>n</code> vertices in one part and <code>m</code> vertices in the other.</p><p><code>Complete([n1,n2,...,nt])</code> returns a complete multipartite graph with parts of size <code>n1</code>, <code>n2</code>, ..., <code>nt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Cube" href="#SimpleGraphs.Cube"><code>SimpleGraphs.Cube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Cube(n)</code> creates the <code>n</code>-dimensional cube graph. This graph has <code>2^n</code> vertices named by all possible length-<code>n</code> strings of 0s and 1s. Two vertices are adjacent iff they differ in exactly one position.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Cycle" href="#SimpleGraphs.Cycle"><code>SimpleGraphs.Cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Cycle(n)</code> creates a cycle with vertex set <code>1:n</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.DEFAULT_MARKER_SIZE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.DFS" href="#SimpleGraphs.DFS"><code>SimpleGraphs.DFS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>perform a depth first search on graph G starting at vertex v</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.DirectedComplete" href="#SimpleGraphs.DirectedComplete"><code>SimpleGraphs.DirectedComplete</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>DirectedComplete(n)</code> creates a directed complete graph with all possible edges (including a loop at each vertex). Use <code>DirectedComplete(n,false)</code> to supress the creation of loops.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.DirectedCycle" href="#SimpleGraphs.DirectedCycle"><code>SimpleGraphs.DirectedCycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>DirectedCycle(n)</code> creates a directed cycles with vertices <code>1:n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.DirectedPath" href="#SimpleGraphs.DirectedPath"><code>SimpleGraphs.DirectedPath</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>DirectedPath(n)</code> creates a directed cycles with vertices <code>1:n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Dodecahedron" href="#SimpleGraphs.Dodecahedron"><code>SimpleGraphs.Dodecahedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Dodecahedron()</code> creates the dodecahedron <code>SimpleGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Frucht" href="#SimpleGraphs.Frucht"><code>SimpleGraphs.Frucht</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Frucht()</code> returns the Frucht graph: A 12-vertex, 3-regular graph with no non-nontrivial automorphisms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.GraphEmbedding" href="#SimpleGraphs.GraphEmbedding"><code>SimpleGraphs.GraphEmbedding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>GraphEmbedding(G)</code> creates a drawing of the <code>SimpleGraph</code> <code>G</code>. It is given a circular embedding.</p><p><strong>Note</strong>: Direct usage of <code>GraphEmbedding</code> is <strong>deprecated</strong>!</p><p><code>GraphEmbedding(G,d)</code> creates a drawing using the <code>Dict</code> <code>d</code> to specify the vertex locations. <code>d</code> should map vertices of <code>G</code> to <code>Vector</code>s that specify x,y-coordinates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Grid" href="#SimpleGraphs.Grid"><code>SimpleGraphs.Grid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Grid(n,m)</code> creates an <code>n</code>-by-<code>m</code> grid graph. For other grids, we suggest <code>Path(n1)*Path(n2)*Path(n3)</code> optionally wrapped in <code>relabel</code>. See also: <code>Cube</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Hoffman" href="#SimpleGraphs.Hoffman"><code>SimpleGraphs.Hoffman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Hoffman()</code> creates the Hoffman graph which is cospectral with, but not isomorphic to, <code>Cube(4)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.HoffmanSingleton" href="#SimpleGraphs.HoffmanSingleton"><code>SimpleGraphs.HoffmanSingleton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>HoffmanSingleton()</code> creates the Hoffman-Singleton graph. This is a 7-regular graph whose diameter is 2 and whose girth is 5.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Icosahedron" href="#SimpleGraphs.Icosahedron"><code>SimpleGraphs.Icosahedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Icosahedron()</code> creates the icosahedron <code>SimpleGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.IntDigraph" href="#SimpleGraphs.IntDigraph"><code>SimpleGraphs.IntDigraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>IntDigraph()</code> creates a new directed graph with vertices of type <code>Int64</code>.</p><p><code>IntDigraph(n)</code> prepopulates the vertex set with vertices <code>1:n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.IntGraph" href="#SimpleGraphs.IntGraph"><code>SimpleGraphs.IntGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>IntGraph()</code> creates a new <code>SimpleGraph</code> whose vertices are of type <code>Int</code>. Called as <code>IntGraph(n::Int)</code> prepopulates the vertex set with vertices <code>1:n</code>.</p><p><code>IntGraph(A)</code> where <code>A</code> is an adjacency matrix creates a graph for which <code>A</code> is the adjacency matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Johnson" href="#SimpleGraphs.Johnson"><code>SimpleGraphs.Johnson</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Johnson(n,k)</code> creates the Johnson graph whose vertices and the <code>k</code>-element subsets of <code>{1,2,...,n}</code>. Vertices <code>v</code> and <code>w</code> are adjacent if their intersection has size <code>k-1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Kneser" href="#SimpleGraphs.Kneser"><code>SimpleGraphs.Kneser</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Kneser(n,m)</code> creates the Kneser graph whose vertices are all the <code>m</code>-element subsets of <code>1:n</code> in which two vertices are adjacent iff they are disjoint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Knight" href="#SimpleGraphs.Knight"><code>SimpleGraphs.Knight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Knight(r::Int=8,c::Int=8)</code> creates a Knight&#39;s Moves graph on a <code>r</code>-by-<code>c</code> grid. That is, the vertices of this graph are the squares of an <code>r</code>-by-<code>c</code> chess board. Two vertices are adjacent if a Knight can go from one of these squares to the other in a single move.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.LZ" href="#SimpleGraphs.LZ"><code>SimpleGraphs.LZ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes L^Z defined in (5) of the Reference</p><p>Input: Z: current layout (coordinates)        d: Ideal distances (default: all 1)        w: weights (default: d.^-2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.NE" href="#SimpleGraphs.NE"><code>SimpleGraphs.NE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>NE(G)</code> returns the number of edges in <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.NV" href="#SimpleGraphs.NV"><code>SimpleGraphs.NV</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>NV(G)</code> returns the number of vertices in <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Octahedron" href="#SimpleGraphs.Octahedron"><code>SimpleGraphs.Octahedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Octahedron()</code> creates the octaahedron <code>SimpleGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Paley" href="#SimpleGraphs.Paley"><code>SimpleGraphs.Paley</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Paley(p)</code> creates the Paley graph with <code>p</code> vertices named <code>0:(p-1)</code>. Here <code>p</code> must be a prime with <code>p%4==1</code>. Vertices <code>u</code> and <code>v</code> are adjacent iff <code>u-v</code> is a quadratic residue (perfect square) modulo <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Path" href="#SimpleGraphs.Path"><code>SimpleGraphs.Path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Path(n)</code> creates a path graph with <code>n</code> vertices named <code>1:n</code>.</p><p><code>Path(array)</code> creates a path graph with vertices <code>array[1]</code>, <code>array[2]</code>, etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Petersen" href="#SimpleGraphs.Petersen"><code>SimpleGraphs.Petersen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Petersen()</code> returns the Petersen graph. The vertices are labeled as the 2-element subsets of <code>1:5</code>. Wrap in <code>relabel</code> to have vertices named <code>1:10</code>. See also: <code>Kneser</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomDigraph" href="#SimpleGraphs.RandomDigraph"><code>SimpleGraphs.RandomDigraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomDigraph(n,p)</code> creates an Erdos-Renyi style random directed graph with vertices <code>1:n</code> and edge probability <code>p</code> (equal to 0.5 by default). The possible edges <code>(u,v)</code> and <code>(v,u)</code> are independent. No loops are created. To also create loops (each with probability <code>p</code>) use <code>RandomDigraph(n,p,true)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomGraph" href="#SimpleGraphs.RandomGraph"><code>SimpleGraphs.RandomGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomGraph(n,p=0.5)</code> creates an Erdos-Renyi random graph with <code>n</code> vertices and edge probability <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomRegular" href="#SimpleGraphs.RandomRegular"><code>SimpleGraphs.RandomRegular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomRegular(n,d)</code> creates a random <code>d</code>-regular graph on <code>n</code> vertices. This can take a while especially if the arguments are large. Call with an optional third argument to activate verbose progress reports: <code>RandomRegular(n,p,true)</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.RandomRegularBuilder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomSBM" href="#SimpleGraphs.RandomSBM"><code>SimpleGraphs.RandomSBM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomSBM(bmap,pmat)</code> creates a random stochastic block model random graph. The vector <code>bmap</code> is a list of <code>n</code> positive integers giving the block number of vertices <code>1:n</code>. The <code>i,j</code>-entry of the matrix <code>pmat</code> gives the probability of an edge from a vertex in block <code>i</code> to a vertex in block <code>j</code>.</p><p><code>RandomSBM(n,pvec,pmat)</code> creates such a graph with <code>n</code> vertices. The vector <code>pvec</code> gives the probabilities that vertices fall into a given block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomTournament" href="#SimpleGraphs.RandomTournament"><code>SimpleGraphs.RandomTournament</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomTournament(n)</code> creates a random tournament with vertex set <code>1:n</code>.  This is equivalent to randomly assigning a direction to every edge of a simple complete graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.RandomTree" href="#SimpleGraphs.RandomTree"><code>SimpleGraphs.RandomTree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>RandomTree(n)</code> creates a random tree on <code>n</code> vertices each with probability <code>1/n^(n-2)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.ShiftDigraph" href="#SimpleGraphs.ShiftDigraph"><code>SimpleGraphs.ShiftDigraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ShiftDigraph(alphabet,n)</code> creates a <code>SimpleDigraph</code> whose vertices are all length-<code>n</code> tuples of the elements in <code>alphabet</code> (which can be an array such as <code>[0,1]</code> or a string such as <code>&quot;abc&quot;</code>). An edge from <code>u</code> to <code>v</code> corresponds to an element dropped from the first position in <code>u</code> and another element added to the end yielding <code>v</code>. For example, in <code>ShiftDigraph([0,1],5)</code> there are two edges leaving vertex <code>(0,1,0,1,1)</code>; one goes to <code>(1,0,1,1,0)</code> and the other to <code>(1,0,1,1,1)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.SimpleDigraph" href="#SimpleGraphs.SimpleDigraph"><code>SimpleGraphs.SimpleDigraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SimpleDigraph()</code> creates a new directed graph with vertices of <code>Any</code> type. This can be restricted to vertics of type <code>T</code> with <code>SimpleDigraph{T}()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.SimpleGraph" href="#SimpleGraphs.SimpleGraph"><code>SimpleGraphs.SimpleGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>SimpleGraph</code> type represents a simple graph; that is, an undirected graph with no loops and no multiple edges.</p><p>Use <code>SimpleGraph()</code> to create a new graph in which the vertices may be <code>Any</code> type. Use <code>SimpleGraph{T}()</code> to create a new graph in which the vertices are of type <code>T</code>. See <code>IntGraph</code> and <code>StringGraph</code> as special cases.</p></div></div></section><pre><code class="language-none">SimpleGraphs.SimpleGraphs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Spindle" href="#SimpleGraphs.Spindle"><code>SimpleGraphs.Spindle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Spindle()</code> returns the Moser spindle graph. This is a seven-vertex unit distance graph with chromatic number equal to 4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.StringDigraph" href="#SimpleGraphs.StringDigraph"><code>SimpleGraphs.StringDigraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>StringDigraph()</code> creates a new directe graph with vertices of type <code>String</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.StringGraph" href="#SimpleGraphs.StringGraph"><code>SimpleGraphs.StringGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A <code>StringGraph</code> is a <code>SimpleGraph</code> whose vertices are of type <code>String</code>.</p><p>When constructed with <code>StringGraph()</code> creates an empty <code>SimpleGraph{String}</code>.</p><p>When invoked as <code>StringGraph(file::AbstractString)</code> opens the named file for parsing as a graph. Each line of the file should contain one or two tokens separated by white space. If the line contains a single token, we add that token as a vertex. If the line contains two (or more) tokens, then the first two tokens are taken as vertex names and (assuming they are different) the corresponding edge is created. Any extra tokens on the line are ignored. Lines that begin with a # are ignored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Tetrahedron" href="#SimpleGraphs.Tetrahedron"><code>SimpleGraphs.Tetrahedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Tetrahedron()</code> creates the tetrahedron <code>SimpleGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.TorusDigraph" href="#SimpleGraphs.TorusDigraph"><code>SimpleGraphs.TorusDigraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function for creating a Torus Graph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.Wheel" href="#SimpleGraphs.Wheel"><code>SimpleGraphs.Wheel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Wheel(n)</code> creates a wheel graph with <code>n</code> vertices. That is, a cycle with <code>n-1</code> vertices <code>1:(n-1)</code> all adjacent to a common single vertex, <code>n</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs._checksquare</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.add!" href="#SimpleGraphs.add!"><code>SimpleGraphs.add!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add!(G,v)</code> adds a new vertex <code>v</code> to the graph.</p><p><code>add!(G,v,w)</code> adds a new edge <code>(v,w)</code> to the graph. If one (or both) of those vertices is not already in the graph, it is added to the vertex set.</p></div></div></section><pre><code class="language-none">SimpleGraphs.add_dict!</code></pre><pre><code class="language-none">SimpleGraphs.add_edge_matrix!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.add_edges!" href="#SimpleGraphs.add_edges!"><code>SimpleGraphs.add_edges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_edges!(G,edge_table)</code> adds edges to the graph <code>G</code>. The argument <code>edge_table</code> is an <code>m</code>-by-<code>2</code> array of vertices. Each row of the table represents an edge to add to <code>G</code>. Returns the number of edges successfully added to <code>G</code>.</p><p>This works both when <code>G</code> is a <code>SimpleGraph</code> and when <code>G</code> is a <code>SimpleDigraph</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.add_key!</code></pre><pre><code class="language-none">SimpleGraphs.add_key_value!</code></pre><pre><code class="language-none">SimpleGraphs.add_value!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.adjacency" href="#SimpleGraphs.adjacency"><code>SimpleGraphs.adjacency</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>adjacency(G)</code> returns the adjacency matrix of <code>G</code>.</p><p>Note: If the vertices can be sorted by <code>sort</code>, then the first row of the adjacency matrix corresponds to the first vertex (in order) in <code>G</code> and so forth. However, if the vertices are not sortable in this way, the mapping between vertices and rows/columns of the matrix is unpredictable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>G&#39;</code> is equivalent to <code>complement(G)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.all_tuples" href="#SimpleGraphs.all_tuples"><code>SimpleGraphs.all_tuples</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>all_tuples(alphabet, n)</code> creates an iterator that produces all length-<code>n</code> tuples of distinct elements in <code>alphabet</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.allow_loops!" href="#SimpleGraphs.allow_loops!"><code>SimpleGraphs.allow_loops!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>allow_loops!(G)</code> enables <code>G</code> to have loops`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.bipartition" href="#SimpleGraphs.bipartition"><code>SimpleGraphs.bipartition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bipartition(G)</code> creates a bipartition of the graph (or returns an error if the graph is not bipartite. Output is a <code>Partition</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.bisect" href="#SimpleGraphs.bisect"><code>SimpleGraphs.bisect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bisect(G::SimpleGraph)</code> partitions the vertex set of <code>G</code> using the eigenvector associated with the second smallest eigenvalue of the graph&#39;s Laplacian matrix (called <code>x</code> below).</p><p>This can be invoked as follows:</p><ul><li><p><code>bisect(G,&quot;user&quot;,pivot)</code> splits the vertices <code>v</code> depending on <code>x[v] &gt;= pivot</code> vs. <code>x[v] &lt; pivot</code>.</p></li><li><p><code>bisect(G,&quot;zero&quot;)</code> is the same as <code>bisect(G,&quot;user&quot;, 0.0)</code>.</p></li><li><p><code>bisect(G,&quot;median&quot;)</code> is equivalent to <code>bisect(G,&quot;user&quot;,m)</code> where <code>m</code> is the median value of <code>x</code>.</p></li><li><p><code>bisect(G,&quot;equal&quot;)</code> creates a partition in which the two parts have sizes the differ by at most 1.</p></li></ul><p>A plain call to <code>bisect(G)</code> is equivalent to <code>bisect(G,&quot;zero&quot;)</code> (which is the same as <code>bisect(G,&quot;user&quot;, 0.0)</code>).</p></div></div></section><pre><code class="language-none">SimpleGraphs.bounds</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_check" href="#SimpleGraphs.cache_check"><code>SimpleGraphs.cache_check</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_check(G,item)</code> checks if the symbol <code>item</code> is a valid key.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_clear" href="#SimpleGraphs.cache_clear"><code>SimpleGraphs.cache_clear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_clear(G)</code> clears all items in <code>G</code>&#39;s cache.</p><p><code>cache_clear(G,item)</code> clears just that item.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_off" href="#SimpleGraphs.cache_off"><code>SimpleGraphs.cache_off</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_off(G)</code> deactivates cache checking. You may also wish to call <code>cache_clear</code> to recover storage.</p><p>See also: <code>cache_on</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_on" href="#SimpleGraphs.cache_on"><code>SimpleGraphs.cache_on</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_on(G)</code> activates results caching for this graph. See also: <code>cache_off</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_recall" href="#SimpleGraphs.cache_recall"><code>SimpleGraphs.cache_recall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_recall(G,item)</code> retreives the value associated with <code>item</code>.</p><p><strong>WARNING</strong>: No check is done to see if this value is defined. Be sure to use <code>cache_check</code> first!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cache_save" href="#SimpleGraphs.cache_save"><code>SimpleGraphs.cache_save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cache_save(G,item,value)</code> saves <code>value</code> associated with the symbol (key) <code>item</code> in the cache for this graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cartesian" href="#SimpleGraphs.cartesian"><code>SimpleGraphs.cartesian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cartesian(G,H)</code> creates the Cartesian product of the two graphs. This can be abbreviated as <code>G*H</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.char_poly" href="#SimpleGraphs.char_poly"><code>SimpleGraphs.char_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>char_poly(G)</code> returns the characteristic polynomial of <code>adjacency(G)</code>. Use <code>char_poly(G,function)</code> for other possible integer matrix functions such as <code>laplace</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.circular!" href="#SimpleGraphs.circular!"><code>SimpleGraphs.circular!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>circular!(X)</code> arranges the vertices of the graph held in the <code>GraphEmbedding</code> around a circle.</p></div></div></section><pre><code class="language-none">SimpleGraphs.circular_embedding</code></pre><pre><code class="language-none">SimpleGraphs.code_to_tree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.complement" href="#SimpleGraphs.complement"><code>SimpleGraphs.complement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>complement(G)</code> creates (as a new graph) the complement of <code>G</code>. Note that <code>G&#39;</code> is a short cut for <code>complement(G)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.complement!" href="#SimpleGraphs.complement!"><code>SimpleGraphs.complement!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>complement!(G)</code> replaces <code>G</code> with its complement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.components" href="#SimpleGraphs.components"><code>SimpleGraphs.components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>components(G)</code> returns the vertex sets of the connected components of <code>G</code> (as a <code>Partition</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.contract!" href="#SimpleGraphs.contract!"><code>SimpleGraphs.contract!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>contract!(G,u,v)</code> contracts the edge <code>(u,v)</code> in the graph. The merged vertex is named <code>u</code> (hence <code>contract!(G,v,u)</code> results in a different, albeit isomorphic, graph).</p><p>Note: The edge <code>(u,v)</code> need not be present in the graph. If missing, this is equivalent to first adding the edge to the graph and then contracting it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.cross_edges" href="#SimpleGraphs.cross_edges"><code>SimpleGraphs.cross_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cross_edges(G::SimpleGraph,A,B)</code> returns the set of edges of <code>G</code> with one end in <code>A</code> and one end in <code>B</code>. Here <code>A</code> and <code>B</code> are collections of vertices of <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.deg" href="#SimpleGraphs.deg"><code>SimpleGraphs.deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>deg(G,v)</code> gives the degree of <code>v</code> in <code>G</code>.</p><p><code>deg(G)</code> gives the degree sequence (sorted).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.deg_hist" href="#SimpleGraphs.deg_hist"><code>SimpleGraphs.deg_hist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>deg_hist(G)</code> gives a tally of how many vertices of each degree are present in the graph. Because Julia arrays are 1-based, the indexing is a bit off. Specifically, entry <code>k</code> in the returned array is the number of vertices of degree <code>k-1</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.deg_sorted_vlist</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>delete!(G,v)</code> deletes vertex <code>v</code> (and any edges incident with <code>v</code>) from the graph.</p><p><code>delete!(G,v,w)</code> deletes the edge <code>(v,w)</code> from <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.diam" href="#SimpleGraphs.diam"><code>SimpleGraphs.diam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>diam(G)</code> returns the diameter of <code>G</code> or <code>-1</code> if <code>G</code> is not connected.</p></div></div></section><pre><code class="language-none">SimpleGraphs.directed_ham_cycle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.disjoint_union" href="#SimpleGraphs.disjoint_union"><code>SimpleGraphs.disjoint_union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>disjoint_union(G,H)</code> is a new graph formed by taking disjoint copies of <code>G</code> and <code>H</code> (and no additional edges).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.dist" href="#AbstractLattices.dist"><code>AbstractLattices.dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dist(G,u,v)</code> finds the length of a shortest path from <code>u</code> to <code>v</code> in <code>G</code>. Returns <code>-1</code> if no such path exists.</p><p><code>dist(G,u)</code> finds the distance from <code>u</code> to all other vertices in <code>G</code>. Result is returned as a <code>Dict</code>.</p><p><code>dist(G)</code> finds all pairs of distances in <code>G</code>. Result is a <code>Dict</code> whose <code>[u,v]</code> entry is the distance from <code>u</code> to <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.dist_matrix" href="#SimpleGraphs.dist_matrix"><code>SimpleGraphs.dist_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dist_matrix(G)</code> returns a matrix whose <code>i,j</code>-entry is the distance from the <code>i</code>th vertex to the <code>j</code>th vertex. If there is no <code>i,j</code>-path, that entry is <code>-1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.draw_labels" href="#SimpleGraphs.draw_labels"><code>SimpleGraphs.draw_labels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>draw_labels(G)</code> will add the vertices names to the drawing window.</p><p>The results are usually ugly. One can try increasing the size of the vertices (see <code>set_vertex_size</code>). The font size of the labels can be specified using <code>draw_labels(G,FontSize)</code>. The default is 10.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.dual_deg" href="#SimpleGraphs.dual_deg"><code>SimpleGraphs.dual_deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dual_deg(G,v)</code> returns a two-tuple consisting of the out degree and in degree of the vertex <code>v</code>.</p><p><code>dual_deg(G)</code> gives a list of all the dual degrees.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.eccentricity" href="#SimpleGraphs.eccentricity"><code>SimpleGraphs.eccentricity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>eccentricity(G,v)</code> returns the eccentricty of vertex <code>v</code> in the graph <code>G</code>. This is the maximum distance from <code>v</code> to another vertex (or -1 if the graph is not connected).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.edge_length" href="#SimpleGraphs.edge_length"><code>SimpleGraphs.edge_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>edge_length(G)</code> returns an array containing the lengths of the edges in the current embedding of <code>G</code>.</p></div></div><div><div><p><code>edge_length(G,e)</code> gives the distance between the embedded endpoints of the edge <code>e</code> in the drawing <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvals" href="#LinearAlgebra.eigvals"><code>LinearAlgebra.eigvals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>eigvals(G)</code> for a <code>SimpleGraph</code> returns the eigenvalues of <code>G</code>&#39;s adjacency matrix. More generally, <code>eigvals(G,mat)</code> returns the eigenvalues of <code>mat(G)</code> where <code>mat</code> is a matrix-valued function of <code>G</code>. In particular, one can use <code>mat(G,laplace)</code> to find the eigenvalues of <code>G</code>&#39;s Laplacian.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.elist" href="#SimpleGraphs.elist"><code>SimpleGraphs.elist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>elist(G)</code> returns the edges of <code>G</code> as a list (array).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.embed" href="#SimpleGraphs.embed"><code>SimpleGraphs.embed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>embed(G)</code> creates a new embedding for <code>G</code>. The full call is</p><pre><code class="language-none">embed(G,algorithm;args...)</code></pre><p>The <code>symbol</code> algorithm indicates the embedding algorithm. The <code>args</code> are a collection of possible arguments to be sent to the algorithm.</p><p>The <code>algorithm</code> defaults to <code>:circular</code> and may be one of the following:</p><ul><li><code>:circular</code>: arrange the vertices evenly in a circle.</li><li><code>:random</code>: arrange the vertices randomly.</li><li><code>:spring</code>: use the <code>spring</code> layout from <code>GraphLayout</code>. Optional argument:<ul><li><code>iterations</code>.</li></ul></li><li><code>:stress</code>: use the <code>stress</code> layout from <code>GraphLayout</code>.</li><li><code>:spectral</code>: use the <code>spectral</code> embedding. Optional arguments:<ul><li><code>xcol</code> – which eigenvalue to use for the <code>x</code> coordinate.</li><li><code>ycol</code> – which eigenvalue to use for the <code>y</code> coordinate</li></ul></li></ul><p>Note that if the graph already has (say) an embedding, that embedding may be used as the starting point for one of the algorithms.</p></div></div><div><div><p><code>embed(G,d)</code> specifies an embedding of the graph <code>G</code> with a dictionary <code>d</code> that maps vertices to coordinates (as two dimensional vectors <code>[x,y]</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.euler" href="#SimpleGraphs.euler"><code>SimpleGraphs.euler</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>euler(G,u,v)</code> finds an Euler trail in <code>G</code> starting at <code>u</code> and ending at <code>v</code> returned as a list of vertices (in the order they are visited on the trail).</p><p><code>euler(G,u)</code> finds an Euler tour beginning and ending at <code>u</code>. Alternatively, call <code>euler(G)</code> and the initial/final vertex will be selected for you.</p><p>Note: The algorithm will succeed even if there are isolated vertices in the graph (just don&#39;t choose an isolated vertex as the first/last).</p><p>If no Euler trail/tour exists, an empty list is returned.</p></div></div></section><pre><code class="language-none">SimpleGraphs.euler_work!</code></pre><pre><code class="language-none">SimpleGraphs.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.fastN!" href="#SimpleGraphs.fastN!"><code>SimpleGraphs.fastN!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fastN!(G,flg=true)</code> is used to turn on (or off) fast neighborhood lookup in graphs. Switching this off decreases the size of the data structure holding the graph, but slows down look up of edges.</p><p><strong>Note</strong>: Fast neighborhood look up is on by default.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.find_path" href="#SimpleGraphs.find_path"><code>SimpleGraphs.find_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>find_path(G,s,t)</code> finds a shortest path from <code>s</code> to <code>t</code>. If no such path exists, an empty list is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.forbid_loops!" href="#SimpleGraphs.forbid_loops!"><code>SimpleGraphs.forbid_loops!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>forbid_loops!(G)</code> disables the digraph&#39;s ability to have loops. It also removes any loops it may already have.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.geogebra" href="#SimpleGraphs.geogebra"><code>SimpleGraphs.geogebra</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>geogebra(G,file_name)</code> takes a <code>SimpleGraph</code> and writes out a script to produce a drawing of this graph in GeoGebra.</p><p>Here is the secret sauce to make this work.</p><ul><li>Run <code>geogebra(G,file_name)</code> to save the script to <code>file_name</code>. By default, the file name is <code>geogebra.txt</code>.</li><li>Copy the contents of <code>file_name</code> to the clipboard.</li><li>Create a new GeoGebra document.</li><li>In the <strong>Input</strong> zone at the bottom, enter <code>Button[]</code> to create a new button.</li><li>Right click the button and select the <strong>Object Properties...</strong> menu option.</li><li>Go to the <strong>Scripting</strong> tab and paste in the copied commands.</li><li>Save and close the properties window.</li><li>Press the newly created button.</li></ul><p>Some properties of the vertices can be specified in this function with named parameters as follows:</p><ul><li><code>vertex_labels</code>: If set to <code>true</code>, the vertices in the drawing have labels. Default is <code>false</code> (no labels drawn). Note that the color of the labels matches the color of the vertices, so if you set the color to <code>white</code> the labels will be invisible.</li><li><code>vertex_color</code>: Use this to specify the fill color of the vertices. The default is <code>&quot;black&quot;</code>.</li><li><code>vertex_colors</code>: This is a dictionary mapping vertices to color names. Vertices are given the color specified. If, however, a vertex is missing from this dictionary, then <code>vertex_color</code> is used instead.</li><li><code>vertex_size</code>: Use this to specify the radius of the vertices. The default is <code>3</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.get_embedding_direct" href="#SimpleGraphs.get_embedding_direct"><code>SimpleGraphs.get_embedding_direct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_embedding_direct(G)</code> returns a direct reference to a graph&#39;s embedding. This function is not exposed. Users should use <code>cache_recall(G,:GraphEmbedding)</code> instead to retrieve a copy of the drawing. If there is not drawing, a default (circular) drawing is created.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.get_line_color" href="#SimpleGraphs.get_line_color"><code>SimpleGraphs.get_line_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_line_color(G)</code> returns the color used to draw edges and the circles around vertices. See <code>set_line_color</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.get_vertex_color" href="#SimpleGraphs.get_vertex_color"><code>SimpleGraphs.get_vertex_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_vertex_color(G)</code> returns the color used to fill in vertices. See <code>set_vertex_color</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.get_vertex_size" href="#SimpleGraphs.get_vertex_size"><code>SimpleGraphs.get_vertex_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>get_vertex_size(G)</code> returns the size of the circle used when drawing vertices. See also <code>set_vertex_size</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Abbreviation for <code>lex(G,H)</code> for <code>SimpleGraph</code>s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.getxy" href="#SimpleGraphs.getxy"><code>SimpleGraphs.getxy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>getxy(G)</code> returns a copy of the dictionary mapping vertices to their x,y-coordinates. This is a way of saving an embedding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.girth" href="#SimpleGraphs.girth"><code>SimpleGraphs.girth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>girth(G)</code> computes the length of a shortest cycle in <code>G</code> or returns <code>0</code> if <code>G</code> is acyclic.</p><p><strong>Warning</strong>: This implementation is quite inefficient.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.girth_cycle" href="#SimpleGraphs.girth_cycle"><code>SimpleGraphs.girth_cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>girth_cycle(G)</code> returns a shorest cycle of <code>G</code> as an array listing the vertices on that cycle, or an empty array if <code>G</code> is acyclic.</p><p><em>Warning</em>: This implementation is quite inefficient.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.graffle" href="#SimpleGraphs.graffle"><code>SimpleGraphs.graffle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>graffle(G::SimpleGraph, filename=&quot;julia.graffle&quot;,rad=9)</code> creates an OmniGraffle document of this drawing.</p><ul><li><code>G</code> is the graph</li><li><code>filename</code> is the name of the OmniGraffle document (be sure to end with <code>.graffle</code>)</li><li><code>rad</code> is the radius of the circles representing the vertices</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.graph_center" href="#SimpleGraphs.graph_center"><code>SimpleGraphs.graph_center</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>graph_center(G)</code> returns the set of vertices of a <code>SimpleGraph</code> with minimum eccentricities.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.greedy_color" href="#SimpleGraphs.greedy_color"><code>SimpleGraphs.greedy_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>greedy_color(G,seq)</code> creates a greedy proper coloring of the graph. The argument <code>seq</code> should be a 1-dimensional array containing every vertex exactly once (the function does not check this for you). The function follows that order in creating the coloring which is returned to you as a <code>Dict</code> mapping vertices to positive integers (representing the colors).</p><p>If <code>seq</code> is omitted, a random permutation of the vertices is used.</p></div></div></section><pre><code class="language-none">SimpleGraphs.hamCycle</code></pre><pre><code class="language-none">SimpleGraphs.ham_check</code></pre><pre><code class="language-none">SimpleGraphs.ham_extend</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.hamiltonian_cycle" href="#SimpleGraphs.hamiltonian_cycle"><code>SimpleGraphs.hamiltonian_cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>hamiltonian_cycle(G::SimpleGraph)</code> returns a Hamiltonian cycle in the graph (if one exists) or an empty array (otherwise). This works reasonably well for small graphs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.has" href="#SimpleGraphs.has"><code>SimpleGraphs.has</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>has(G,v)</code> returns <code>true</code> iff <code>v</code> is a vertex of <code>G</code>.</p><p><code>has(G,v,w)</code> returns <code>true</code> iff <code>(v,w)</code> is an edge of <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.has_embedding" href="#SimpleGraphs.has_embedding"><code>SimpleGraphs.has_embedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>has_embedding(G)</code> returns <code>true</code> if an embedding has been created for <code>G</code> in its cache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.in_deg" href="#SimpleGraphs.in_deg"><code>SimpleGraphs.in_deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>in_deg(G,v)</code> is the in degree of vertex <code>v</code>.</p><p><code>in_deg(G)</code> is a sorted list of the in degrees of all vertices in the directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.in_neighbors" href="#SimpleGraphs.in_neighbors"><code>SimpleGraphs.in_neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>in_neighbors(G,v)</code> gives a list of all of <code>v</code>&#39;s in neighbors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.incidence" href="#SimpleGraphs.incidence"><code>SimpleGraphs.incidence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>incidence(G)</code> returns the vertex-edge incidence matrix of <code>G</code>.</p><p>Notes:</p><ul><li><p>The result is a sparse matrix. Wrap in <code>full</code> to convert to nonsparse.</p></li><li><p>Each column of the matrix has exactly one <code>+1</code> and one <code>-1</code>. If <code>G</code></p></li></ul><p>is undirected and an unsigned incidence matrix is desired, use <code>incidence(G,false)</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.indep_poly" href="#SimpleGraphs.indep_poly"><code>SimpleGraphs.indep_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>indep_poly(G)</code> returns the independence polynomial of the <code>SimpleGraph</code> <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.induce" href="#SimpleGraphs.induce"><code>SimpleGraphs.induce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>induce(G,A)</code> creates the induced subgraph of <code>G</code> with vertices in the set <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.interlace" href="#SimpleGraphs.interlace"><code>SimpleGraphs.interlace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>interlace(G)</code> returns the interlace polynomial of the graph <code>G</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.isSafe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.is_acyclic" href="#SimpleGraphs.is_acyclic"><code>SimpleGraphs.is_acyclic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>is_acyclic(G)</code> returns <code>true</code> if <code>G</code> has no cycles and <code>false</code> otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.is_connected" href="#SimpleGraphs.is_connected"><code>SimpleGraphs.is_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>is_connected(G)</code> determines if <code>G</code> is connected.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.is_cut_edge" href="#SimpleGraphs.is_cut_edge"><code>SimpleGraphs.is_cut_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>is_cut_edge(G,u,v)</code> [or <code>is_cut_edge(G,e)</code>] determins if <code>(u,v)</code> [or <code>e</code>] is a cut edge of <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.is_looped" href="#SimpleGraphs.is_looped"><code>SimpleGraphs.is_looped</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>is_looped(G)</code> indicates if the directed graph <code>G</code> is capable of having loops. Returning <code>true</code> does not mean that digraph actually has loops.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.is_strongly_connected" href="#SimpleGraphs.is_strongly_connected"><code>SimpleGraphs.is_strongly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>test if a directed graph is strongly connected by using DFS</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>join(G,H)</code> is a new graph formed by taking disjoint copies of <code>G</code> and <code>H</code> together with all possible edges between those copies.</p></div></div></section><pre><code class="language-none">SimpleGraphs.label_append</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.laplace" href="#SimpleGraphs.laplace"><code>SimpleGraphs.laplace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>laplace(G)</code> returns the Laplacian matrix of <code>G</code>. This is the adjacency matrix minus the (diagonal) degree matrix. See <code>adjacency</code> to understand how vertices correspond to rows/columns of the resulting matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.layout_spring_adj" href="#SimpleGraphs.layout_spring_adj"><code>SimpleGraphs.layout_spring_adj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Use the spring/repulsion model of Fruchterman and Reingold (1991):
    Attractive force:  f_a(d) =  d^2 / k
    Repulsive force:  f_r(d) = -k^2 / d
where d is distance between two vertices and the optimal distance
between vertices k is defined as C * sqrt( area / num_vertices )
where C is a parameter we can adjust

Arguments:
adj_matrix Adjacency matrix of some type. Non-zero of the eltype
           of the matrix is used to determine if a link exists,
           but currently no sense of magnitude
C          Constant to fiddle with density of resulting layout
MAXITER    Number of iterations we apply the forces
INITTEMP   Initial &quot;temperature&quot;, controls movement per iteration</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.lex" href="#SimpleGraphs.lex"><code>SimpleGraphs.lex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>lex(G,H)</code> computes the lexicographic product of the graphs <code>G</code> and <code>H</code>. The vertex set of this graph is the set of all ordered pairs <code>(g,h)</code> (with <code>g</code> a vertex of <code>G</code> and <code>h</code> a vertex of <code>H</code> in which we have the edge <code>(g,h)~(g&#39;,h&#39;)</code> if either <code>g~g&#39;</code> in <code>G</code> or else <code>g=g</code> and <code>h~h&#39;</code>.</p><p>We can use the notation <code>G[H]</code> also to create <code>lex(G,H)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.line_graph" href="#SimpleGraphs.line_graph"><code>SimpleGraphs.line_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>line_graph(G)</code> creates the line graph of <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.list2dict" href="#SimpleGraphs.list2dict"><code>SimpleGraphs.list2dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>list2dict(list)</code> takes a list of <code>(Symbol,Any)</code> pairs and converts them to a dictionary mapping the symbols to their associated values.</p></div></div></section><pre><code class="language-none">SimpleGraphs.load!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.local_complement!" href="#SimpleGraphs.local_complement!"><code>SimpleGraphs.local_complement!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>local_complement!(G,v)</code> complements the edges in the neighborhood of <code>v</code>. That is, if <code>u</code> and <code>w</code> are neighbors of <code>v</code> then we toggle the edge/nonedge <code>uw</code>, modifying the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.loops" href="#SimpleGraphs.loops"><code>SimpleGraphs.loops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>loops(G)</code> returns a list of vertices at which a loop is present.</p></div></div></section><pre><code class="language-none">SimpleGraphs.makeColorClass</code></pre><pre><code class="language-none">SimpleGraphs.makeSimplex!</code></pre><pre><code class="language-none">SimpleGraphs.make_scaler</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.matching_poly" href="#SimpleGraphs.matching_poly"><code>SimpleGraphs.matching_poly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>matching_poly(G)</code> returns the matching polynomial of the <code>SimpleGraph</code> <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.my_layout_stressmajorize_adj" href="#SimpleGraphs.my_layout_stressmajorize_adj"><code>SimpleGraphs.my_layout_stressmajorize_adj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute graph layout using stress majorization</p><p>Inputs:</p><pre><code class="language-none">δ: Matrix of pairwise distances
p: Dimension of embedding (default: 2)
w: Matrix of weights. If not specified, defaults to
       w[i,j] = δ[i,j]^-2 if δ[i,j] is nonzero, or 0 otherwise
X0: Initial guess for the layout. Coordinates are given in rows.
    If not specified, default to random matrix of Gaussians</code></pre><p>Additional optional keyword arguments control the convergence of the algorithm and the additional output as requested:</p><pre><code class="language-none">maxiter:   Maximum number of iterations. Default: 400size(X0, 1)^2
abstols:   Absolute tolerance for convergence of stress.
           The iterations terminate if the difference between two
           successive stresses is less than abstol.
           Default: √(eps(eltype(X0))
reltols:   Relative tolerance for convergence of stress.
           The iterations terminate if the difference between two
           successive stresses relative to the current stress is less than
           reltol. Default: √(eps(eltype(X0))
abstolx:   Absolute tolerance for convergence of layout.
           The iterations terminate if the Frobenius norm of two successive
           layouts is less than abstolx. Default: √(eps(eltype(X0))
verbose:   If true, prints convergence information at each iteration.
           Default: false
returnall: If true, returns all iterates and their associated stresses.
           If false (default), returns the last iterate</code></pre><p>Output:</p><pre><code class="language-none">The final layout X, with coordinates given in rows, unless returnall=true.</code></pre><p>Reference:</p><pre><code class="language-none">The main equation to solve is (8) of:

@incollection{
    author = {Emden R Gansner and Yehuda Koren and Stephen North},
    title = {Graph Drawing by Stress Majorization}
    year={2005},
    isbn={978-3-540-24528-5},
    booktitle={Graph Drawing},
    seriesvolume={3383},
    series={Lecture Notes in Computer Science},
    editor={Pach, J&#39;anos},
    doi={10.1007/978-3-540-31843-9_25},
    publisher={Springer Berlin Heidelberg},
    pages={239--250},
}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightXML.name" href="#LightXML.name"><code>LightXML.name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>name(G)</code> returns the graph&#39;s name.</p><p><code>name(G,str)</code> assigns <code>str</code> to be the graph&#39;s name. If <code>str</code> is empty, then the name is set to the default <code>SimpleGraph{T}</code> where <code>T</code> is the vertex type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.neighbors" href="#SimpleGraphs.neighbors"><code>SimpleGraphs.neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>neighbors(G,v)</code> returns a list of the neighbors of <code>v</code>.</p><p>May also be invoked as <code>G[v]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.num_components" href="#SimpleGraphs.num_components"><code>SimpleGraphs.num_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>num_components(G)</code> returns the number of connected components in <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.num_trans_orientations" href="#SimpleGraphs.num_trans_orientations"><code>SimpleGraphs.num_trans_orientations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>num_trans_orientations(G)</code> returns the number of transitive orientations of the graph <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.out_deg" href="#SimpleGraphs.out_deg"><code>SimpleGraphs.out_deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>out_deg(G,v)</code> is the out degree of vertex <code>v</code>.</p><p><code>out_deg(G)</code> is a sorted list of the out degrees of all vertices in the directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.out_neighbors" href="#SimpleGraphs.out_neighbors"><code>SimpleGraphs.out_neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>out_neighbors(G,v)</code> gives a list of all <code>v</code>&#39;s out neighbors.</p></div></div></section><pre><code class="language-none">SimpleGraphs.pivot!</code></pre><pre><code class="language-none">SimpleGraphs.private_adj</code></pre><pre><code class="language-none">SimpleGraphs.private_dist</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.radius" href="#SimpleGraphs.radius"><code>SimpleGraphs.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>radius(G)</code> returns the radius of the graph <code>G</code>. This is the minimum <code>eccentricity</code> of a vertex of <code>G</code> (or -1 if the graph is not connected).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.random!" href="#SimpleGraphs.random!"><code>SimpleGraphs.random!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>random!(X)</code> gives the graph held in <code>X</code> a random embedding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.random_greedy_color" href="#SimpleGraphs.random_greedy_color"><code>SimpleGraphs.random_greedy_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>random_greedy_color(G, reps)</code> repeatedly invokes <code>greedy_color</code> using random permutations of the vertex set. After <code>reps</code> iterations, the best coloring found is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.recenter" href="#SimpleGraphs.recenter"><code>SimpleGraphs.recenter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>recenter(G)</code> translates the graph&#39;s drawing so that the center of mass of the vertices is at the origin.</p></div></div></section><pre><code class="language-none">SimpleGraphs.recenter!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.relabel" href="#SimpleGraphs.relabel"><code>SimpleGraphs.relabel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>relabel(G)</code> returns a copy of <code>G</code> in which the vertices are renamed <code>1:n</code>.</p><p><code>relabel(G,d)</code> (where <code>d</code> is a <code>Dict</code>) returns a copy of <code>G</code> in which vertex <code>v</code> is renamed <code>d[v]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.remove_embedding" href="#SimpleGraphs.remove_embedding"><code>SimpleGraphs.remove_embedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>remove_embedding(G)</code> erases the graph&#39;s embedding saved in its cache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.remove_loops!" href="#SimpleGraphs.remove_loops!"><code>SimpleGraphs.remove_loops!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>remove_loops!(G)</code> removes all loops (if any) in the digraph, but does <em>not</em> alter the <code>G</code>&#39;s ability to have loops.</p></div></div></section><pre><code class="language-none">SimpleGraphs.rescale!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.rotate" href="#SimpleGraphs.rotate"><code>SimpleGraphs.rotate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rotate(G,theta)</code> rotate&#39;s the graph&#39;s drawing by the angle <code>theta</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.rotate!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.scale" href="#SimpleGraphs.scale"><code>SimpleGraphs.scale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>scale(G,m)</code> multiplies all coordinates in the graph&#39;s drawing by <code>m</code>. If <code>m</code> is omitted, the drawing is rescaled so that the average length of an edge equals 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.set_embedding_direct" href="#SimpleGraphs.set_embedding_direct"><code>SimpleGraphs.set_embedding_direct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_embedding_direct(G,X)</code> overwrites (or creates) the drawing <code>X</code> in the graph&#39;s cache. This non-exposed function should not be called by the user.</p></div></div></section><pre><code class="language-none">SimpleGraphs.set_fill_color</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.set_line_color" href="#SimpleGraphs.set_line_color"><code>SimpleGraphs.set_line_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_line_color(G,color)</code> sets the color used to draw edges and the circles around vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.set_vertex_color" href="#SimpleGraphs.set_vertex_color"><code>SimpleGraphs.set_vertex_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_vertex_color(G,color)</code> sets the color that gets drawn in the interior of the vertices. (All vertices get the same color.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.set_vertex_size" href="#SimpleGraphs.set_vertex_size"><code>SimpleGraphs.set_vertex_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>set_vertex_size(G,sz)</code> sets the size of the circle used when drawing vertices. The default is <code>6</code>. See also <code>get_vertex_size</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.show</code></pre><pre><code class="language-none">SimpleGraphs.simplify</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.spanning_forest" href="#SimpleGraphs.spanning_forest"><code>SimpleGraphs.spanning_forest</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>spanning_forest(G)</code> creates a maximal acyclic subgraph of <code>G</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.spectral!" href="#SimpleGraphs.spectral!"><code>SimpleGraphs.spectral!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>spectral!(X::GraphEmbedding)</code> gives the graph held in <code>X</code> an embedding based on the eigenvectors of the Laplacian matrix of the graph. Specifically, the <code>x</code>-coordinates come from the eigenvector associated with the second smallest eigenvalue, and the <code>y</code>-coordinates come from the eigenveector associated with the third smallest.</p><p>This may also be invoked as <code>spectral!(X,xcol,ycol)</code> to choose other eigenvectors to use for the x and y coordinates of the embedding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.spring!" href="#SimpleGraphs.spring!"><code>SimpleGraphs.spring!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>spring!(X)</code> gives the graph held in <code>X</code> with a spring embedding (based on code in the <code>GraphLayout</code> module). If runs a default number of iterations (100) of that algorithm. To change the number of iterations, use <code>spring!(X,nits)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.stress" href="#SimpleGraphs.stress"><code>SimpleGraphs.stress</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stress function to majorize</p><p>Input:     X: A particular layout (coordinates in rows)     d: Matrix of pairwise distances     w: Weights for each pairwise distance</p><p>See (1) of Reference</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.stress!" href="#SimpleGraphs.stress!"><code>SimpleGraphs.stress!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>stress!(X)</code> computes a stress major layout using code taken from the <code>GraphLayout</code> package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.super_toggle!" href="#SimpleGraphs.super_toggle!"><code>SimpleGraphs.super_toggle!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>super_toggle!(G,A,B)</code> toggles all edges/nonedges <code>ab</code> where <code>a</code> is in <code>A</code> and <code>b</code> is in <code>B</code>. <strong>No error checking is done</strong>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.tikz_file" href="#SimpleGraphs.tikz_file"><code>SimpleGraphs.tikz_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tikz_file(G,label,filename)</code> writes the tikz code for drawing the graph <code>G</code> into <code>filename</code>. If <code>label</code> is omitted (or <code>false</code>) vertex labels are not drawn. If <code>filename</code> is omitted, it defaults to <code>graph.tex</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.tikz_print" href="#SimpleGraphs.tikz_print"><code>SimpleGraphs.tikz_print</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tikz_print(G)</code> prints tikz code to draw <code>G</code>. <code>tikz_print(G,true)</code> does likewise, with vertex labels drawn.</p></div></div></section><pre><code class="language-none">SimpleGraphs.tikz_string</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.toggle!" href="#SimpleGraphs.toggle!"><code>SimpleGraphs.toggle!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>toggle!(G,x,y)</code> deletes edge <code>xy</code> if present or adds edge <code>xy</code> if absent. <strong>No error checking is done</strong>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.transform" href="#SimpleGraphs.transform"><code>SimpleGraphs.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>transform(G,A,b)</code> applies an affine transformation to all coordinates in the graph&#39;s drawing. Here <code>A</code> is 2-by-2 matrix and <code>b</code> is a 2-vector. Each point <code>p</code> is mapped to <code>A*p+b</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.transform!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.transitive_orientation" href="#SimpleGraphs.transitive_orientation"><code>SimpleGraphs.transitive_orientation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>transitive_orientation(G)</code> finds a transitive orientation of the simple graph <code>G</code>. The result is a <code>SimpleDigraph</code>. An error is raised if <code>G</code> does not have a transitive orientation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.translate" href="#SimpleGraphs.translate"><code>SimpleGraphs.translate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>translate(G,b)</code> translates the graph&#39;s drawing by the vector <code>b</code>; that is, every point <code>p</code> in the drawing is replaced by <code>p+b</code>.</p></div></div></section><pre><code class="language-none">SimpleGraphs.translate!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.trim" href="#SimpleGraphs.trim"><code>SimpleGraphs.trim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>trim(G)</code> returns a copy of <code>G</code> with all isolated vertices removed.</p><p><code>trim(G,d)</code> returns a copy of <code>G</code> in which we iteratively remove all vertices of degree <code>d</code> or smaller. For example, if <code>G</code> is a tree, <code>trim(G,1)</code> will eventually remove all vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.twins" href="#SimpleGraphs.twins"><code>SimpleGraphs.twins</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>twins(G,u,v)</code> determines if <code>u</code> and <code>v</code> are twin vertices of <code>G</code>. That is, if <code>G[u]-v == G[v]-u</code>. This is an equivalence relation.</p><p><code>twins(G)</code> returns a partition of the graph&#39;s vertex set into twin equivalence classes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.two_color" href="#SimpleGraphs.two_color"><code>SimpleGraphs.two_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>two_color(G)</code> creates a two-coloring of the graph or throws an error if the graph is not bipartite. The output is a <code>Dict</code> mapping the vertex set to the values 1 and 2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>union(G,H)</code> creates the union of the graphs <code>G</code> and <code>H</code>. The graphs may (and typically do) have common vertices or edges.</p></div></div></section><pre><code class="language-none">SimpleGraphs.vertex2idx</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.vertex_split" href="#SimpleGraphs.vertex_split"><code>SimpleGraphs.vertex_split</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>vertex_split(G)</code> converts the directed graph <code>G</code> into an undirected bipartite graph. For each vertex <code>v</code> in <code>G</code>, the output graph has two vertices <code>(v,1)</code> and <code>(v,2)</code>. Each edge <code>(v,w)</code> of <code>G</code> is rendered as an edge between <code>(v,1)</code> and <code>(w,2)</code> in the output graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.vertex_type" href="#SimpleGraphs.vertex_type"><code>SimpleGraphs.vertex_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>vertex_type(G)</code> returns the data type of the vertices this graph may hold. For example, if <code>G=IntGraph()</code> then this returns <code>Int64</code>.`</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.vlist" href="#SimpleGraphs.vlist"><code>SimpleGraphs.vlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>vlist(G)</code> returns the vertices of <code>G</code> as a list (array).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.weightedlaplacian" href="#SimpleGraphs.weightedlaplacian"><code>SimpleGraphs.weightedlaplacian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compute weighted Laplacian given ideal weights w</p><p>Lʷ defined in (4) of the Reference</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleGraphs.wiener_index" href="#SimpleGraphs.wiener_index"><code>SimpleGraphs.wiener_index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>wiener_index(G)</code> is the sum of the distances between vertices in <code>G</code>. Returns -1 if <code>G</code> is not connected.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
