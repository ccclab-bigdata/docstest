<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ChaosTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ChaosTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">ChaosTools.@SMatrix</code></pre><pre><code class="language-none">ChaosTools.@SVector</code></pre><pre><code class="language-none">ChaosTools.AbstractDataset</code></pre><pre><code class="language-none">ChaosTools.AbstractEmbedding</code></pre><pre><code class="language-none">ChaosTools.AbstractNeighborhood</code></pre><pre><code class="language-none">ChaosTools.CDS_KWARGS</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.ChaosTools" href="#ChaosTools.ChaosTools"><code>ChaosTools.ChaosTools</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Tools for the exploration of chaos and nonlinear dynamics</p></div></div></section><pre><code class="language-none">ChaosTools.Chebyshev</code></pre><pre><code class="language-none">ChaosTools.Cityblock</code></pre><pre><code class="language-none">ChaosTools.ContinuousDynamicalSystem</code></pre><pre><code class="language-none">ChaosTools.Dataset</code></pre><pre><code class="language-none">ChaosTools.DelayEmbedding</code></pre><pre><code class="language-none">ChaosTools.DelayEmbeddings</code></pre><pre><code class="language-none">ChaosTools.DiscreteDynamicalSystem</code></pre><pre><code class="language-none">ChaosTools.DynamicalSystem</code></pre><pre><code class="language-none">ChaosTools.DynamicalSystemsBase</code></pre><pre><code class="language-none">ChaosTools.Euclidean</code></pre><pre><code class="language-none">ChaosTools.FixedMassNeighborhood</code></pre><pre><code class="language-none">ChaosTools.FixedSizeNeighborhood</code></pre><pre><code class="language-none">ChaosTools.KDTree</code></pre><pre><code class="language-none">ChaosTools.MTDelayEmbedding</code></pre><pre><code class="language-none">ChaosTools.PSOS_ERROR</code></pre><pre><code class="language-none">ChaosTools.PlaneCrossing</code></pre><pre><code class="language-none">ChaosTools.ROOTS_ALG</code></pre><pre><code class="language-none">ChaosTools.SMatrix</code></pre><pre><code class="language-none">ChaosTools.SVector</code></pre><pre><code class="language-none">ChaosTools.Sk</code></pre><pre><code class="language-none">ChaosTools.Systems</code></pre><pre><code class="language-none">ChaosTools._check_plane</code></pre><pre><code class="language-none">ChaosTools._fill_orbitdiagram!</code></pre><pre><code class="language-none">ChaosTools._get_Q</code></pre><pre><code class="language-none">ChaosTools._initialize_output</code></pre><pre><code class="language-none">ChaosTools._periodicorbits!</code></pre><pre><code class="language-none">ChaosTools.autocor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.boxcounting_dim" href="#ChaosTools.boxcounting_dim"><code>ChaosTools.boxcounting_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>capacity<em>dim(args...) = generalized</em>dim(0, args...)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.broomhead_king" href="#ChaosTools.broomhead_king"><code>ChaosTools.broomhead_king</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">broomhead_king(s::AbstractVector, d::Int) -&gt; U, S, Vtr</code></pre><p>Return the Broomhead-King coordinates of a timeseries <code>s</code> by performing <code>svd</code> on the so-called trajectory matrix with dimension <code>d</code>.</p><p><strong>Description</strong></p><p>Broomhead and King coordinates is an approach proposed in [1] that applies the Karhunen–Loève theorem to delay coordinates embedding with smallest possible delay.</p><p>The function performs singular value decomposition on the <code>d</code>-dimensional trajectory matrix <span>$X$</span> of <span>$s$</span>,</p><div>\[X = \frac{1}{\sqrt{N}}\left(
\begin{array}{cccc}
x_1 &amp; x_2 &amp; \ldots &amp; x_d \\
x_2 &amp; x_3 &amp; \ldots &amp; x_{d+1}\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
x_{N-d+1} &amp; x_{N-d+2} &amp;\ldots &amp; x_N
\end{array}
\right) = U\cdot S \cdot V^{tr}.\]</div><p>where <span>$x := s - \bar{s}$</span>. The columns of <span>$U$</span> can then be used as a new coordinate system, and by considering the values of the singular values <span>$S$</span> you can decide how many columns of <span>$U$</span> are &quot;important&quot;. See the documentation page for example application.</p><p><strong>References</strong></p><p>[1] :  D. S. Broomhead, R. Jones and G. P. King, J. Phys. A <strong>20</strong>, 9, pp L563 (1987)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.capacity_dim" href="#ChaosTools.capacity_dim"><code>ChaosTools.capacity_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>capacity<em>dim(args...) = generalized</em>dim(0, args...)</p></div></div></section><pre><code class="language-none">ChaosTools.columns</code></pre><pre><code class="language-none">ChaosTools.delay_distance</code></pre><pre><code class="language-none">ChaosTools.dimension</code></pre><pre><code class="language-none">ChaosTools.embed</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.estimate_boxsizes" href="#ChaosTools.estimate_boxsizes"><code>ChaosTools.estimate_boxsizes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">estimate_boxsizes(dataset::AbstractDataset; k::Int = 12, z = -1, w = 1)</code></pre><p>Return <code>k</code> exponentially spaced values: <code>10 .^ range(lower+w, upper+z, length = k)</code>.</p><p><code>lower</code> is the magnitude of the minimum pair-wise distance between datapoints while <code>upper</code> is the magnitude of the maximum difference between greatest and smallest number among each timeseries.</p><p>&quot;Magnitude&quot; here stands for order of magnitude, i.e. <code>round(log10(x))</code>.</p></div></div></section><pre><code class="language-none">ChaosTools.estimate_delay</code></pre><pre><code class="language-none">ChaosTools.estimate_dimension</code></pre><pre><code class="language-none">ChaosTools.eval</code></pre><pre><code class="language-none">ChaosTools.exponential_decay_fit</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.gali" href="#ChaosTools.gali"><code>ChaosTools.gali</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gali(ds::DynamicalSystem, tmax, k::Int | Q0; kwargs...) -&gt; GALI_k, t</code></pre><p>Compute <span>$\text{GALI}_k$</span> [1] for a given <code>k</code> up to time <code>tmax</code>. Return <span>$\text{GALI}_k(t)$</span> and time vector <span>$t$</span>.</p><p>The third argument, which sets the order of <code>gali</code>, can be an integer <code>k</code>, or a matrix with its columns being the deviation vectors (then <code>k = size(Q0)[2]</code>). In the first case random orthonormal vectors are chosen.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold = 1e-12</code> : If <code>GALI_k</code> falls below the <code>threshold</code> iteration is terminated.</li><li><code>dt = 1</code> : Time-step between deviation vector normalizations. For continuous systems this is approximate.</li><li><code>u0</code> : Initial state for the system. Defaults to <code>get_state(ds)</code>.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="@ref"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>The Generalized Alignment Index, <span>$\text{GALI}_k$</span>, is an efficient (and very fast) indicator of chaotic or regular behavior type in <span>$D$</span>-dimensional Hamiltonian systems (<span>$D$</span> is number of variables). The <em>asymptotic</em> behavior of <span>$\text{GALI}_k(t)$</span> depends critically on the type of orbit resulting from the initial condition. If it is a chaotic orbit, then</p><div>\[\text{GALI}_k(t) \sim
\exp\left[\sum_{j=1}^k (\lambda_1 - \lambda_j)t \right]\]</div><p>with <span>$\lambda_j$</span> being the <code>j</code>-th Lyapunov exponent (see <a href="#ChaosTools.lyapunov"><code>lyapunov</code></a>, <a href="#ChaosTools.lyapunovs"><code>lyapunovs</code></a>). If on the other hand the orbit is regular, corresponding to movement in <span>$d$</span>-dimensional torus with <span>$1 \le d \le D/2$</span> then it holds</p><div>\[\text{GALI}_k(t) \sim
    \begin{cases}
      \text{const.}, &amp; \text{if} \;\; 2 \le k \le d  \; \; \text{and}
      \; \;d &gt; 1 \\
      t^{-(k - d)}, &amp; \text{if} \;\;  d &lt; k \le D - d \\
      t^{-(2k - D)}, &amp; \text{if} \;\;  D - d &lt; k \le D
    \end{cases}\]</div><p>Traditionally, if <span>$\text{GALI}_k(t)$</span> does not become less than the <code>threshold</code> until <code>tmax</code> the given orbit is said to be chaotic, otherwise it is regular.</p><p>Our implementation is not based on the original paper, but rather in the method described in [2], which uses the product of the singular values of <span>$A$</span>, a matrix that has as <em>columns</em> the deviation vectors.</p><p><strong>Performance Notes</strong></p><p>This function uses a <a href="@ref"><code>tangent_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="language-none">ChaosTools.gali(tinteg, tmax, dt, threshold)</code></pre><p><strong>References</strong></p><p>[1] : Skokos, C. H. <em>et al.</em>, Physica D <strong>231</strong>, pp 30–54 (2007)</p><p>[2] : Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 5 (section 5.3.1 and ref. [85] therein), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.genentropy" href="#ChaosTools.genentropy"><code>ChaosTools.genentropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">genentropy(α, ε, dataset::AbstractDataset; base = e)</code></pre><p>Compute the <code>α</code> order generalized (Rényi) entropy [1] of a dataset, by first partitioning it into boxes of length <code>ε</code> using <a href="#ChaosTools.non0hist"><code>non0hist</code></a>.</p><pre><code class="language-julia">genentropy(α, p::AbstractArray; base = e)</code></pre><p>Compute the entropy of an array <code>p</code> directly, assuming that <code>p</code> is sum-normalized.</p><p>Optionally use <code>base</code> for the logarithms.</p><p><strong>Description</strong></p><p>Let <span>$p$</span> be an array of probabilities (summing to 1). Then the Rényi entropy is</p><div>\[H_\alpha(p) = \frac{1}{1-\alpha} \log \left(\sum_i p[i]^\alpha\right)\]</div><p>and generalizes other known entropies, like e.g. the information entropy (<span>$\alpha = 1$</span>, see [2]), the maximum entropy (<span>$\alpha=0$</span>, also known as Hartley entropy), or the correlation entropy (<span>$\alpha = 2$</span>, also known as collision entropy).</p><p><strong>References</strong></p><p>[1] : A. Rényi, <em>Proceedings of the fourth Berkeley Symposium on Mathematics, Statistics and Probability</em>, pp 547 (1960)</p><p>[2] : C. E. Shannon, Bell Systems Technical Journal <strong>27</strong>, pp 379 (1948)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.generalized_dim" href="#ChaosTools.generalized_dim"><code>ChaosTools.generalized_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generalized_dim(α, dataset [, sizes]) -&gt; D_α</code></pre><p>Return the <code>α</code> order generalized dimension of the <code>dataset</code>, by calculating the <a href="#ChaosTools.genentropy"><code>genentropy</code></a> for each <code>ε ∈ sizes</code>.</p><p><strong>Description</strong></p><p>The returned dimension is approximated by the (inverse) power law exponent of the scaling of the <a href="#ChaosTools.genentropy"><code>genentropy</code></a> versus the box size <code>ε</code>, where <code>ε ∈ sizes</code>.</p><p>Calling this function performs a lot of automated steps:</p><ol><li>A vector of box sizes is decided by calling <code>sizes = estimate_boxsizes(dataset)</code>, if <code>sizes</code> is not given.</li><li>For each element of <code>sizes</code> the appropriate entropy is calculated, through <code>d = genentropy.(α, sizes, dataset)</code>. Let <code>x = -log.(sizes)</code>.</li><li>The curve <code>d(x)</code> is decomposed into linear regions, using <a href="#ChaosTools.linear_regions"><code>linear_regions</code></a><code>(x, d)</code>.</li><li>The biggest linear region is chosen, and a fit for the slope of that region is performed using the function <a href="#ChaosTools.linear_region"><code>linear_region</code></a>. This slope is the return value of <code>generalized_dim</code>.</li></ol><p>By doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result.</p><p>The following aliases are provided:</p><ul><li>α = 0 : <code>boxcounting_dim</code>, <code>capacity_dim</code></li><li>α = 1 : <code>information_dim</code></li></ul></div></div></section><pre><code class="language-none">ChaosTools.get_deviations</code></pre><pre><code class="language-none">ChaosTools.get_state</code></pre><pre><code class="language-none">ChaosTools.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.information_dim" href="#ChaosTools.information_dim"><code>ChaosTools.information_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>information<em>dim(args...) = generalized</em>dim(1, args...)</p></div></div></section><pre><code class="language-none">ChaosTools.inittest_default</code></pre><pre><code class="language-none">ChaosTools.integrator</code></pre><pre><code class="language-none">ChaosTools.jacobian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.kaplanyorke_dim" href="#ChaosTools.kaplanyorke_dim"><code>ChaosTools.kaplanyorke_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kaplanyorke_dim(lyapunovs::AbstractVector)</code></pre><p>Calculate the Kaplan-Yorke dimension, a.k.a. Lyapunov dimension [1].</p><p><strong>Description</strong></p><p>The Kaplan-Yorke dimension is simply the point where <code>cumsum(lyapunovs)</code> becomes zero (interpolated). If the sum of the exponents never becomes negative the function will return the length of the input vector.</p><p>Useful in combination with <a href="#ChaosTools.lyapunovs"><code>lyapunovs</code></a>.</p><p><strong>References</strong></p><p>[1] :  J. Kaplan &amp; J. Yorke, <em>Chaotic behavior of multidimensional difference equations</em>, Lecture Notes in Mathematics vol. <strong>730</strong>, Springer (1979)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.lambdamatrix" href="#ChaosTools.lambdamatrix"><code>ChaosTools.lambdamatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lambdamatrix(λ, inds::Vector{Int}, sings) -&gt; Λk</code></pre><p>Return the matrix <span>$\mathbf{\Lambda}_k$</span> used to create a new dynamical system with some unstable fixed points turned to stable in the function <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p><p><strong>Arguments</strong></p><ol><li><code>λ&lt;:Real</code> : the multiplier of the <span>$C_k$</span> matrix, with <code>0&lt;λ&lt;1</code>.</li><li><code>inds::Vector{Int}</code> : The <code>i</code>th entry of this vector gives the <em>row</em> of the nonzero element of the <code>i</code>th column of <span>$C_k$</span>.</li><li><code>sings::Vector{&lt;:Real}</code> : The element of the <code>i</code>th column of <span>$C_k$</span> is +1 if <code>signs[i] &gt; 0</code> and -1 otherwise (<code>sings</code> can also be <code>Bool</code> vector).</li></ol><p>Calling <code>lambdamatrix(λ, D::Int)</code> creates a random <span>$\mathbf{\Lambda}_k$</span> by randomly generating an <code>inds</code> and a <code>signs</code> from all possible combinations. The <em>collections</em> of all these combinations can be obtained from the function <a href="#ChaosTools.lambdaperms"><code>lambdaperms</code></a>.</p><p><strong>Description</strong></p><p>Each element of <code>inds</code> <em>must be unique</em> such that the resulting matrix is orthogonal and represents the group of special reflections and permutations.</p><p>Deciding the appropriate values for <code>λ, inds, sings</code> is not trivial. However, in ref. [2] there is a lot of information that can help with that decision. Also, by appropriately choosing various values for <code>λ</code>, one can sort periodic orbits from e.g. least unstable to most unstable, see [3] for details.</p><p><strong>References</strong></p><p>[2] : D. Pingel <em>et al.</em>, Phys. Rev. E <strong>62</strong>, pp 2119 (2000)</p><p>[3] : F. K. Diakonos <em>et al.</em>, Phys. Rev. Lett. <strong>81</strong>, pp 4349 (1998)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.lambdaperms" href="#ChaosTools.lambdaperms"><code>ChaosTools.lambdaperms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lambdaperms(D) -&gt; indperms, singperms</code></pre><p>Return two collections that each contain all possible combinations of indices (total of <span>$D!$</span>) and signs (total of <span>$2^D$</span>) for dimension <code>D</code> (see <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.linear_region" href="#ChaosTools.linear_region"><code>ChaosTools.linear_region</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linear_region(x, y; dxi::Int = 1, tol = 0.2) -&gt; ([ind1, ind2], slope)</code></pre><p>Call <a href="#ChaosTools.linear_regions"><code>linear_regions</code></a>, identify the largest linear region and approximate the slope of the entire region using <code>linreg</code>. Return the indices where the region starts and stops (<code>x[ind1:ind2]</code>) as well as the approximated slope.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.linear_regions" href="#ChaosTools.linear_regions"><code>ChaosTools.linear_regions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linear_regions(x, y; dxi::Int = 1, tol = 0.2) -&gt; (lrs, tangents)</code></pre><p>Identify regions where the curve <code>y(x)</code> is linear, by scanning the <code>x</code>-axis every <code>dxi</code> indices (e.g. at <code>x[1] to x[5], x[5] to x[10], x[10] to x[15]</code> and so on if <code>dxi=5</code>).</p><p>If the slope (calculated using <code>LsqFit</code>) of a region of width <code>dxi</code> is approximatelly equal to that of the previous region, within tolerance <code>tol</code>, then these two regions belong to the same linear region.</p><p>Return the indices of <code>x</code> that correspond to linear regions, <code>lrs</code>, and the approximated <code>tangents</code> at each region. <code>lrs</code> is a vector of <code>Int</code>. Notice that <code>tangents</code> is <em>not</em> accurate: it is not recomputed at every step, but only when its error exceeds the tolerance <code>tol</code>! Use <a href="#ChaosTools.linear_region"><code>linear_region</code></a> to obtain a correct estimate for the slope of the largest linear region.</p></div></div></section><pre><code class="language-none">ChaosTools.linreg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.lyapunov" href="#ChaosTools.lyapunov"><code>ChaosTools.lyapunov</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyapunov(ds::DynamicalSystem, Τ; kwargs...) -&gt; λ</code></pre><p>Calculate the maximum Lyapunov exponent <code>λ</code> using a method due to Benettin [1], which simply evolves two neighboring trajectories (one called &quot;given&quot; and one called &quot;test&quot;) while constantly rescaling the test one. <code>T</code>  denotes the total time of evolution (should be <code>Int</code> for discrete systems).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Ttr = 0</code> : Extra &quot;transient&quot; time to evolve the trajectories before starting to measure the expontent. Should be <code>Int</code> for discrete systems.</li><li><code>d0 = 1e-9</code> : Initial &amp; rescaling distance between the two neighboring trajectories.</li><li><code>upper_threshold = 1e-6</code> : Upper distance threshold for rescaling.</li><li><code>lower_threshold = 1e-12</code> : Lower distance threshold for rescaling (in order to  be able to detect negative exponents).</li><li><code>dt = 1</code> : Time of evolution between each check of distance exceeding the thresholds. For continuous systems this is approximate.</li><li><code>inittest = (u1, d0) -&gt; u1 .+ d0/sqrt(D)</code> : A function that given <code>(u1, d0)</code> initializes the test state with distance <code>d0</code> from the given state <code>u1</code> (<code>D</code> is the dimension of the system). This function can be used when you want to avoid the test state appearing in a region of the phase-space where it would have e.g. different energy or escape to infinity.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="@ref"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>Two neighboring trajectories with initial distance <code>d0</code> are evolved in time. At time <span>$t_i$</span> their distance <span>$d(t_i)$</span> either exceeds the <code>upper_threshold</code>, or is lower than <code>lower_threshold</code>, which initializes a rescaling of the test trajectory back to having distance <code>d0</code> from the given one, while the rescaling keeps the difference vector along the maximal expansion/contraction direction: <span>$u_2 \to u_1+(u_2−u_1)/(d(t_i)/d_0)$</span>.</p><p>The maximum Lyapunov exponent is the average of the time-local Lyapunov exponents</p><div>\[\lambda = \frac{1}{t_{n} - t_0}\sum_{i=1}^{n}
\ln\left( a_i \right),\quad a_i = \frac{d(t_{i})}{d_0}.\]</div><p><strong>Performance Notes</strong></p><p>This function uses a <a href="@ref"><code>parallel_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="language-none">lyapunov(pinteg, T, Ttr, dt, d0, ut, lt)</code></pre><p><strong>References</strong></p><p>[1] : G. Benettin <em>et al.</em>, Phys. Rev. A <strong>14</strong>, pp 2338 (1976)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.lyapunovs" href="#ChaosTools.lyapunovs"><code>ChaosTools.lyapunovs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyapunovs(ds::DynamicalSystem, N [, k::Int | Q0]; kwargs...) -&gt; λs</code></pre><p>Calculate the spectrum of Lyapunov exponents [1] of <code>ds</code> by applying a QR-decomposition on the parallelepiped matrix <code>N</code> times. Return the spectrum sorted from maximum to minimum.</p><p>The third argument <code>k</code> is optional, and dictates how many lyapunov exponents to calculate (defaults to <code>dimension(ds)</code>). Instead of passing an integer <code>k</code> you can pass a pre-initialized matrix <code>Q0</code> whose columns are initial deviation vectors (then <code>k = size(Q0)[2]</code>).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0 = get_state(ds)</code> : State to start from.</li><li><code>Ttr = 0</code> : Extra &quot;transient&quot; time to evolve the system before application of the algorithm. Should be <code>Int</code> for discrete systems. Both the system and the deviation vectors are evolved for this time.</li><li><code>dt</code> : Time of individual evolutions between successive orthonormalization steps. Defaults to <code>1</code>. For continuous systems this is approximate.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="@ref"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>The method we employ is &quot;H2&quot; of [2], originally stated in [3]. The deviation vectors defining a <code>D</code>-dimensional parallepiped in tangent space are evolved using the tangent dynamics of the system. A QR-decomposition at each step yields the local growth rate for each dimension of the parallepiped. The growth rates are then averaged over <code>N</code> successive steps, yielding the lyapunov exponent spectrum (at each step the parallepiped is re-normalized).</p><p><strong>Performance Notes</strong></p><p>This function uses a <a href="@ref"><code>tangent_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="language-none">lyapunovs(tinteg, N, dt::Real, Ttr::Real)</code></pre><p>If you want to obtain the convergence timeseries of the Lyapunov spectrum, use the method</p><pre><code class="language-none">ChaosTools.lyapunovs_convergence(tinteg, N, dt, Ttr)</code></pre><p>(not exported).</p><p><strong>References</strong></p><p>[1] : A. M. Lyapunov, <em>The General Problem of the Stability of Motion</em>, Taylor &amp; Francis (1992)</p><p>[2] : K. Geist <em>et al.</em>, Progr. Theor. Phys. <strong>83</strong>, pp 875 (1990)</p><p>[3] : G. Benettin <em>et al.</em>, Meccanica <strong>15</strong>, pp 9-20 &amp; 21-30 (1980)</p></div></div></section><pre><code class="language-none">ChaosTools.lyapunovs_convergence</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.max_linear_region" href="#ChaosTools.max_linear_region"><code>ChaosTools.max_linear_region</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">max_linear_region(lrs::Vector{Int}, tangents::Vector{Float64})</code></pre><p>Find the biggest linear region and return it.</p></div></div></section><pre><code class="language-none">ChaosTools.maxima</code></pre><pre><code class="language-none">ChaosTools.min_pairwise_distance</code></pre><pre><code class="language-none">ChaosTools.minima</code></pre><pre><code class="language-none">ChaosTools.minmaxima</code></pre><pre><code class="language-none">ChaosTools.mutualinformation</code></pre><pre><code class="language-none">ChaosTools.neighborhood</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.non0hist" href="#ChaosTools.non0hist"><code>ChaosTools.non0hist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">non0hist(ε, dataset::AbstractDataset)</code></pre><p>Partition a dataset into tabulated intervals (boxes) of size <code>ε</code> and return the sum-normalized histogram in an unordered 1D form, discarding all zero elements and bin edge information.</p><p><strong>Performances Notes</strong></p><p>This method has a linearithmic time complexity (<code>n log(n)</code> for <code>n = length(data)</code>) and a linear space complexity (<code>l</code> for <code>l = dimension(data)</code>). This allows computation of entropies of high-dimensional datasets and with small box sizes <code>ε</code> without memory overflow.</p><p>Use e.g. <code>fit(Histogram, ...)</code> from <a href="http://juliastats.github.io/StatsBase.jl/stable/"><code>StatsBase</code></a> if you wish to keep information about the edges of the binning as well as the zero elements.</p></div></div></section><pre><code class="language-none">ChaosTools.normalize_deviations!</code></pre><pre><code class="language-none">ChaosTools.normalize_devs</code></pre><pre><code class="language-none">ChaosTools.normalize_impl</code></pre><pre><code class="language-none">ChaosTools.normalize_inplace!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.numericallyapunov" href="#ChaosTools.numericallyapunov"><code>ChaosTools.numericallyapunov</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numericallyapunov(R::Dataset, ks;  refstates, w, distance, ntype)</code></pre><p>Return <code>E = [E(k) for k ∈ ks]</code>, where <code>E(k)</code> is the average logarithmic distance between states of a <a href="@ref"><code>neighborhood</code></a> that are evolved in time for <code>k</code> steps (<code>k</code> must be integer).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>refstates = 1:(length(R) - ks[end])</code> : Vector of indices that notes which states of the reconstruction should be used as &quot;reference states&quot;, which means that the algorithm is applied for all state indices contained in <code>refstates</code>.</li><li><code>w::Int = 1</code> : The Theiler window, which determines whether points are separated enough in time to be considered separate trajectories (see [1] and <a href="@ref"><code>neighborhood</code></a>).</li><li><code>ntype::AbstractNeighborhood = FixedMassNeighborhood(1)</code> : The method to be used when evaluating the neighborhood of each reference state. See <a href="@ref"><code>AbstractNeighborhood</code></a> or <a href="@ref"><code>neighborhood</code></a> for more info.</li><li><code>distance::Metric = Cityblock()</code> : The distance function used in the logarithmic distance of nearby states. The allowed distances are <code>Cityblock()</code> and <code>Euclidean()</code>. See below for more info.</li></ul><p><strong>Description</strong></p><p>If the dataset/reconstruction exhibits exponential divergence of nearby states, then it should clearly hold</p><div>\[E(k) \approx \lambda\Delta t k + E(0)\]</div><p>for a <em>well defined region</em> in the <code>k</code> axis, where <span>$\lambda$</span> is the approximated maximum Lyapunov exponent. <span>$\Delta t$</span> is the time between samples in the original timeseries. You can use <a href="#ChaosTools.linear_region"><code>linear_region</code></a> with arguments <code>(ks .* Δt, E)</code> to identify the slope (= <span>$\lambda$</span>) immediatelly, assuming you have choosen sufficiently good <code>ks</code> such that the linear scaling region is bigger than the saturated region.</p><p>The algorithm used in this function is due to Parlitz [1], which itself expands upon Kantz [2]. In sort, for each reference state a neighborhood is evaluated. Then, for each point in this neighborhood, the logarithmic distance between reference state and neighborhood state is calculated as the &quot;time&quot; index <code>k</code> increases. The average of the above over all neighborhood states over all reference states is the returned result.</p><p>If the <code>Metric</code> is <code>Euclidean()</code> then use the Euclidean distance of the full <code>D</code>-dimensional points (distance <span>$d_E$</span> in ref. [1]). If however the <code>Metric</code> is <code>Cityblock()</code>, calculate the absolute distance of <em>only the first elements</em> of the <code>m+k</code> and <code>n+k</code> points of the reconstruction <code>R</code> (distance <span>$d_F$</span> in ref. [1]).</p><p><strong>References</strong></p><p>[1] : Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 1 (section 1.3.2), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</p><p>[2] : Kantz, H., Phys. Lett. A <strong>185</strong>, pp 77–87 (1994)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.orbitdiagram" href="#ChaosTools.orbitdiagram"><code>ChaosTools.orbitdiagram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orbitdiagram(ds::DiscreteDynamicalSystem, i, p_index, pvalues; kwargs...)</code></pre><p>Compute the orbit diagram (also called bifurcation diagram) of the given system, saving the <code>i</code> variable(s) for parameter values <code>pvalues</code>. The <code>p_index</code> specifies which parameter of the equations of motion is to be changed.</p><p><code>i</code> can be <code>Int</code> or <code>AbstractVector{Int}</code>. If <code>i</code> is <code>Int</code>, returns a vector of vectors. Else it returns vectors of vectors of vectors. Each entry are the points at each parameter value.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Ttr::Int = 1000</code> : Transient steps; each orbit is evolved for <code>Ttr</code> first before saving output.</li><li><code>n::Int = 100</code> : Amount of points to save for each initial condition.</li><li><code>dt = 1</code> : Stepping time. Changing this will give you the orbit diagram of the <code>dt</code> order map.</li><li><code>u0 = get_state(ds)</code> : Initial condition. Besides a vector you can also give a vector of vectors such that <code>length(u0) == length(pvalues)</code>. Then each parameter has a different initial condition.</li></ul><p>See also <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a> and <a href="#ChaosTools.produce_orbitdiagram"><code>produce_orbitdiagram</code></a>.</p></div></div></section><pre><code class="language-none">ChaosTools.orthonormal</code></pre><pre><code class="language-none">ChaosTools.parallel_integrator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.periodicorbits" href="#ChaosTools.periodicorbits"><code>ChaosTools.periodicorbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">periodicorbits(ds::DiscreteDynamicalSystem,
               o, ics [, λs, indss, singss]; kwargs...) -&gt; FP</code></pre><p>Find fixed points <code>FP</code> of order <code>o</code> for the map <code>ds</code> using the algorithm due to Schmelcher &amp; Diakonos [1]. <code>ics</code> is a collection of initial conditions (container of vectors) to be evolved.</p><p><strong>Optional Arguments</strong></p><p>The optional arguments <code>λs, indss, singss</code> <em>must be containers</em> of appropriate values, besides <code>λs</code> which can also be a number. The elements of those containers are passed to: <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix(λ, inds, sings)</code></a>, which creates the appropriate <span>$\mathbf{\Lambda}_k$</span> matrix. If these arguments are not given, a random permutation will be chosen for them, with <code>λ=0.001</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>maxiters::Int = 100000</code> : Maximum amount of iterations an i.c. will be iterated  before claiming it has not converged.</li><li><code>disttol = 1e-10</code> : Distance tolerance. If the 2-norm of a previous state with  the next one is <code>≤ disttol</code> then it has converged to a fixed point.</li><li><code>inftol = 10.0</code> : If a state reaches <code>norm(state) ≥ inftol</code> it is assumed that  it has escaped to infinity (and is thus abandoned).</li><li><code>roundtol::Int = 4</code> : The found fixed points are rounded  to <code>roundtol</code> digits before pushed into the list of returned fixed points <code>FP</code>,  <em>if</em> they are not already contained in <code>FP</code>.  This is done so that <code>FP</code> doesn&#39;t contain duplicate fixed points (notice  that this has nothing to do with <code>disttol</code>). Turn this to <code>typemax(Int)</code>  to get the full precision of the algorithm.</li></ul><p><strong>Description</strong></p><p>The algorithm used can detect periodic orbits by turning fixed points of the original map <code>ds</code> to stable ones, through the transformation</p><div>\[\mathbf{x}_{n+1} = \mathbf{x}_n +
\mathbf{\Lambda}_k\left(f^{(o)}(\mathbf{x}_n) - \mathbf{x}_n\right)\]</div><p>with <span>$f$</span> = <code>eom</code>. The index <span>$k$</span> counts the various possible <span>$\mathbf{\Lambda}_k$</span>.</p><p><strong>Performance Notes</strong></p><p><em>All</em> initial conditions are evolved for <em>all</em> <span>$\mathbf{\Lambda}_k$</span> which can very quickly lead to long computation times.</p><p><strong>References</strong></p><p>[1] : P. Schmelcher &amp; F. K. Diakonos, Phys. Rev. Lett. <strong>78</strong>, pp 4733 (1997)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.permentropy" href="#ChaosTools.permentropy"><code>ChaosTools.permentropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permentropy(x::AbstractVector, order [, interval=1]; base = e)</code></pre><p>Compute the permutation entropy [1] of given <code>order</code> from the <code>x</code> timeseries.</p><p>Optionally, <code>interval</code> can be specified to use <code>x[t0:interval:t1]</code> when calculating permutation of the sliding windows between <code>t0</code> and <code>t1 = t0 + interval * (order - 1)</code>.</p><p>Optionally use <code>base</code> for the logarithms.</p><p><strong>References</strong></p><p>[1] : C. Bandt, &amp; B. Pompe, <a href="http://doi.org/10.1103/PhysRevLett.88.174102">Phys. Rev. Lett. <strong>88</strong> (17), pp 174102 (2002)</a></p></div></div></section><pre><code class="language-none">ChaosTools.poincare_cross!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.poincaresos" href="#ChaosTools.poincaresos"><code>ChaosTools.poincaresos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">poincaresos(ds::ContinuousDynamicalSystem, plane, tfinal = 1000.0; kwargs...)</code></pre><p>Calculate the Poincaré surface of section (also called Poincaré map) [1, 2] of the given system with the given <code>plane</code>. The system is evolved for total time of <code>tfinal</code>.</p><p>If the state of the system is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation intersecting the hyperplane is</p><div>\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</div><p>where <span>$\mathbf{a}, b$</span> are the parameters that define the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Number}</code>, like <code>(j, r)</code> : the planecrossing is defined as when the <code>j</code> variable of the system crosses the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p>Returns a <a href="@ref"><code>Dataset</code></a> of the points that are on the surface of section.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>direction = -1</code> : Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Positive direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>idxs = 1:dimension(ds)</code> : Optionally you can choose which variables to save. Defaults to the entire state.</li><li><code>Ttr = 0.0</code> : Transient time to evolve the system before starting to compute the PSOS.</li><li><code>u0 = get_state(ds)</code> : Specify an initial state.</li><li><code>warning = true</code> : Throw a warning if the Poincaré section was empty.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-6)</code> : A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>diffeq...</code> : All other extra keyword arguments are propagated into <code>init</code> of DifferentialEquations.jl. See <a href="@ref"><code>trajectory</code></a> for examples.</li></ul><p><strong>References</strong></p><p>[1] : H. Poincaré, <em>Les Methods Nouvelles de la Mécanique Celeste</em>, Paris: Gauthier-Villars (1892)</p><p>[2] : M. Tabor, <em>Chaos and Integrability in Nonlinear Dynamics: An Introduction</em>, §4.1, in pp. 118-126, New York: Wiley (1989)</p><p>See also <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>, <a href="#ChaosTools.produce_orbitdiagram"><code>produce_orbitdiagram</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChaosTools.produce_orbitdiagram" href="#ChaosTools.produce_orbitdiagram"><code>ChaosTools.produce_orbitdiagram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">produce_orbitdiagram(ds::ContinuousDynamicalSystem, plane, i::Int,
                     p_index, pvalues; kwargs...)</code></pre><p>Produce an orbit diagram (also called bifurcation diagram) for the <code>i</code> variable(s) of the given continuous system by computing Poincaré surfaces of section using <code>plane</code> for the given parameter values (see <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>).</p><p><code>i</code> can be <code>Int</code> or <code>AbstractVector{Int}</code>. If <code>i</code> is <code>Int</code>, returns a vector of vectors. Else it returns vectors of vectors of vectors. Each entry are the points at each parameter value.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>printparams::Bool = false</code> : Whether to print the parameter used during computation in order to keep track of running time.</li><li><code>direction, warning, Ttr, rootkw, diffeq...</code> : Propagated into <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>.</li><li><code>u0 = get_state(ds)</code> : Initial condition. Besides a vector you can also give a vector of vectors such that <code>length(u0) == length(pvalues)</code>. Then each parameter has a different initial condition.</li></ul><p><strong>Description</strong></p><p>For each parameter, a PSOS reduces the system from a flow to a map. This then allows the formal computation of an &quot;orbit diagram&quot; for the <code>i</code> variable of the system, just like it is done in <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>.</p><p>The parameter change is done as <code>p[p_index] = value</code> taking values from <code>pvalues</code> and thus you must use a parameter container that supports this (either <code>Array</code>, <code>LMArray</code>, dictionary or other).</p><p>See also <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>, <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>.</p></div></div></section><pre><code class="language-none">ChaosTools.reconstruct</code></pre><pre><code class="language-none">ChaosTools.reinit!</code></pre><pre><code class="language-none">ChaosTools.rescale!</code></pre><pre><code class="language-none">ChaosTools.set_deviations!</code></pre><pre><code class="language-none">ChaosTools.set_parameter!</code></pre><pre><code class="language-none">ChaosTools.set_state!</code></pre><pre><code class="language-none">ChaosTools.slope</code></pre><pre><code class="language-none">ChaosTools.step!</code></pre><pre><code class="language-none">ChaosTools.stochastic_indicator</code></pre><pre><code class="language-none">ChaosTools.tangent_integrator</code></pre><pre><code class="language-none">ChaosTools.trajectory</code></pre><pre><code class="language-none">ChaosTools.trajectory_matrix</code></pre><pre><code class="language-none">ChaosTools.λdist</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
