<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom widgets · Interact</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interact</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../observables/">Observables</a></li><li><a class="toctext" href="../widgets/">Widgets</a></li><li class="current"><a class="toctext" href>Custom widgets</a><ul class="internal"><li><a class="toctext" href="#The-Widget-type-1">The Widget type</a></li><li><a class="toctext" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></li><li><a class="toctext" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></li></ul></li><li><a class="toctext" href="../modifiers/">Modifiers</a></li><li><a class="toctext" href="../layout/">Layout</a></li><li><a class="toctext" href="../deploying/">Deploying the web app</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Custom widgets</a></li></ul></nav><hr/><div id="topbar"><span>Custom widgets</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Custom-widgets-1" href="#Custom-widgets-1">Custom widgets</a></h1><p>Besides the standard widgets, Interact provides a framework to define custom GUIs. This is currently possible with two approaches, the full featured <code>Widget</code> type and the simple to use but more basic <a href="#Widgets.@manipulate"><code>@manipulate</code></a> macro.</p><h2><a class="nav-anchor" id="The-Widget-type-1" href="#The-Widget-type-1">The Widget type</a></h2><p>The <code>Widget</code> type can be used to create custom widgets. The types is parametric, with the parameter being the name of the widget and it takes as argument a <code>OrderedDict</code> of children.</p><p>For example:</p><pre><code class="language-julia">d = OrderedDict(:label =&gt; &quot;My label&quot;, :button =&gt; button(&quot;My button&quot;))
w = Widget{:mywidget}(d)</code></pre><p>Children can be accessed and modified using <code>getindex</code> and <code>setindex!</code> on the <code>Widget</code> object:</p><pre><code class="language-julia">println(w[:label])
w[:label] = &quot;A new label&quot;</code></pre><p>Optionally, the <code>Widget</code> can have some output, which should be an <code>Observable</code>:</p><pre><code class="language-julia">d = OrderedDict(:label =&gt; &quot;My label&quot;, :button =&gt; button(&quot;My button&quot;))
output = map(t -&gt; t &gt; 5 ? &quot;You pressed me many times&quot; : &quot;You didn&#39;t press me enough&quot;, d[:button])
w = Interact.Widget{:mywidget}(d, output = output)</code></pre><p>Finally the <a href="#Widgets.@layout!"><code>@layout!</code></a> macro allows us to set the layout of the widget:</p><pre><code class="language-julia">@layout! w hbox(vbox(:label, :button), observe(_)) # observe(_) refers to the output of the widget</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout!" href="#Widgets.@layout!"><code>Widgets.@layout!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@layout!(d, x)</code></p><p>Set <code>d.layout</code> to match the result of <code>Widgets.@layout(x)</code>. See <a href="#Widgets.@layout"><code>Widgets.@layout</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Interact

julia&gt; t = Widget{:test}(OrderedDict(:b =&gt; slider(1:100), :c =&gt; button()));

julia&gt; @layout! t hbox(:b, CSSUtil.hskip(1em), :c);</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout" href="#Widgets.@layout"><code>Widgets.@layout</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@layout(d, x)</code></p><p>Apply the expression <code>x</code> to the widget <code>d</code>, replacing e.g. symbol <code>:s</code> with the corresponding subwidget <code>d[:s]</code> In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>. <code>@layout</code> can be combined with <code>@map</code> to have the layout update interactively as function of some widget.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Interact

julia&gt; cpt = OrderedDict(:vertical =&gt; Observable(true), :b =&gt; slider(1:100), :c =&gt; button());

julia&gt; t = Widget{:test}(cpt, output = observe(cpt[:b]));

julia&gt; Widgets.@layout t vbox(:b, CSSUtil.vskip(1em), :c);

julia&gt; Widgets.@layout t Widgets.@map &amp;(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);</code></pre><p>Use <a href="#Widgets.@layout!"><code>@layout!</code></a> to set the widget layout in place:</p><pre><code class="language-julia-repl">julia&gt; @layout! t Widgets.@map &amp;(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);</code></pre><p><code>@layout(x)</code></p><p>Curried version of <code>@layout(d, x)</code>: anonymous function mapping <code>d</code> to <code>@layout(d, x)</code>.</p></div></div></section><h2><a class="nav-anchor" id="Defining-custom-widgets-without-depending-on-Interact-1" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></h2><p>This is only relevant for package authors: it is not necessary to depend on Interact to define custom widgets. One can instead use the low-dependency package <a href="https://github.com/piever/Widgets.jl">Widgets</a> that defines (but does not export) all the widgets. For example:</p><pre><code class="language-julia"># in the package MyPackage defining the recipe:
using Widgets
function myrecipe(i)
    label = &quot;My recipe&quot;
    wdg = Widgets.dropdown(i)
    Widget([&quot;label&quot; =&gt; label, &quot;dropdown&quot; =&gt; wdg])
end

# The user would then do:
using MyPackage, Interact

myrecipe([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</code></pre><h2><a class="nav-anchor" id="A-simpler-approach:-the-manipulate-macro-1" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@manipulate" href="#Widgets.@manipulate"><code>Widgets.@manipulate</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@manipulate expr</code></p><p>The @manipulate macro lets you play with any expression using widgets. <code>expr</code> needs to be a <code>for</code> loop. The <code>for</code> loop variable are converted to widgets using the <a href="../widgets/#Widgets.widget"><code>widget</code></a> function (ranges become <code>slider</code>, lists of options become <code>togglebuttons</code>, etc...). The <code>for</code> loop body is displayed beneath the widgets and automatically updated as soon as the widgets change value.</p><p>Use <code>throttle = df</code> to only update the output after a small time interval <code>dt</code> (useful if the update is costly as it prevents multiple updates when moving for example a slider).</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Colors

@manipulate for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end

@manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end</code></pre><p><a href="#Widgets.@layout!"><code>@layout!</code></a> can be used to adjust the layout of a manipulate block:</p><pre><code class="language-julia">using Interact

ui = @manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end
@layout! ui dom&quot;div&quot;(observe(_), vskip(2em), :r, :g, :b)
ui</code></pre></div></div></section><footer><hr/><a class="previous" href="../widgets/"><span class="direction">Previous</span><span class="title">Widgets</span></a><a class="next" href="../modifiers/"><span class="direction">Next</span><span class="title">Modifiers</span></a></footer></article></body></html>
