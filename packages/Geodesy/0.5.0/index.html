<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · Geodesy.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Geodesy.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Quick-start-1">Quick start</a></li><li><a class="toctext" href="#Basic-Terminology-1">Basic Terminology</a></li><li><a class="toctext" href="#The-API-1">The API</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Geodesy-1" href="#Geodesy-1">Geodesy</a></h1><table><tr><th><strong>Package Evaluator</strong></th><th><strong>Build Status</strong></th></tr><tr><td><a href="http://pkg.julialang.org/?pkg=Geodesy"><img src="http://pkg.julialang.org/badges/Geodesy_0.5.svg" alt="0.5 package tests"/></a> <a href="http://pkg.julialang.org/?pkg=Geodesy"><img src="http://pkg.julialang.org/badges/Geodesy_0.6.svg" alt="0.6 package tests"/></a></td><td><a href="https://travis-ci.org/JuliaGeo/Geodesy.jl"><img src="https://travis-ci.org/JuliaGeo/Geodesy.jl.svg?branch=master" alt="Linux/macOS"/></a> <a href="https://ci.appveyor.com/project/JuliaGeo/geodesy-jl"><img src="https://ci.appveyor.com/api/projects/status/github/JuliaGeo/Geodesy.jl?svg=true" alt="Windows"/></a> <a href="https://coveralls.io/r/JuliaGeo/Geodesy.jl"><img src="http://img.shields.io/coveralls/JuliaGeo/Geodesy.jl.svg" alt="Coverage"/></a></td></tr></table><p><strong>Geodesy</strong> is a Julia package for working with points in various world and local coordinate systems. The primary feature of <em>Geodesy</em> is to define and perform coordinate transformations in a convenient and safe framework, leveraging the <em>CoordinateTransformations</em> <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">package</a>. Transformations are accurate and efficient and implemented in native Julia code (with many functions being ported from Charles Karney&#39;s <em>GeographicLib</em> <a href="http://geographiclib.sourceforge.net/">C++ library</a>), and some common geodetic datums are provided for convenience.</p><h2><a class="nav-anchor" id="Quick-start-1" href="#Quick-start-1">Quick start</a></h2><p>Lets define a 3D point by its latitude, longitude and altitude (LLA):</p><pre><code class="language-julia">x_lla = LLA(-27.468937, 153.023628, 0.0) # City Hall, Brisbane, Australia</code></pre><p>This can be converted to a Cartesian Earth-Centered-Earth-Fixed (ECEF) coordinate simply by calling the constructor</p><pre><code class="language-julia">x_ecef = ECEF(x_lla, wgs84)</code></pre><p>Here we have used the WGS-84 ellipsoid to calculate the transformation, but other datums such as <code>osgb36</code>, <code>nad27</code> and <code>grs80</code> are provided. All transformations use the <em>CoordinateTransformations</em>&#39; interface, and the above is short for</p><pre><code class="language-julia">x_ecef = ECEFfromLLA(wgs84)(x_lla)</code></pre><p>where <code>ECEFfromLLA</code> is a type inheriting from <em>CoordinateTransformations</em>&#39; <code>Transformation</code>. (Similar names <code>XfromY</code> exist for each of the coordinate types.)</p><p>Often, points are measured or required in a <em>local</em> frame, such as the north-east-up coordinates with respect to a given origin. The <code>ENU</code> type represents points in this coordinate system and we may transform between ENU and globally referenced coordinates using <code>ENUfromLLA</code>, etc.</p><pre><code class="language-julia">origin_lla = LLA(-27.468937, 153.023628, 0.0) # City Hall, Brisbane, Australia
point_lla = LLA(-27.465933, 153.025900, 0.0)  # Central Station, Brisbane, Australia

# Define the transformation and execute it
trans = ENUfromLLA(origin_lla, wgs84)
point_enu = trans(point_lla)

# Equivalently
point_enu = ENU(point_enu, point_origin, wgs84)</code></pre><p>Similarly, we could convert to UTM/UPS coordinates, and two types are provided for this - <code>UTM</code> stores 3D coordinates <code>x</code>, <code>y</code>, and <code>z</code> in an unspecified zone, while <code>UTMZ</code> includes the <code>zone</code> number and <code>hemisphere</code> bool (where <code>true</code> = northern, <code>false</code> = southern). To get the canonical zone for your coordinates, simply use:</p><pre><code class="language-julia">x_utmz = UTMZ(x_lla, wgs84)</code></pre><p>If you are transforming a large number of points to or from a given zone, it may be more effective to define the transformation explicitly and use the lighter <code>UTM</code> storage type.</p><pre><code class="language-julia">points_lla::Vector{LLA{Float64}}
utm_from_lla = UTMfromLLA(56, false, wgs84) # Zone 56-South
points_utm = map(utm_from_lla, points_lla) # A new vector of UTM coordinates</code></pre><p><em>Geodesy</em> becomes particularly powerful when you chain together transformations. For example, you can define a single transformation from your data on disk in UTM coordinates to a local frame in ENU coordinates. Internally, this will perform UTM (+ zone) → LLA → ECEF → ENU via composing transformations with <code>∘</code> into a <code>ComposedTransformation</code>:</p><pre><code class="language-julia">julia&gt; origin = LLA(-27.468937, 153.023628, 0.0) # City Hall, Brisbane, Australia
LLA(lat=-27.468937°, lon=153.023628°, alt=0.0)

julia&gt; trans = ENUfromUTMZ(origin, wgs84)
(ENUfromECEF(ECEF(-5.046925124630393e6, 2.5689157252069353e6, -2.924416653602336e6), lat=-27.468937°, lon=153.023628°) ∘ (ECEFfromLLA(wgs84) ∘ LLAfromUTMZ(wgs84)))</code></pre><p>This transformation can then be composed with rotations and translations in <em>CoordinateTransformations</em> (or your own custom-defined <code>AbstractTransformation</code> to define further reference frames. For example, in this way, a point measured by a scanner on a moving vehicle at a particular time may be globally georeferenced with a single call to the <code>Transformation</code>!</p><p>Finally, the Cartesian distance between world points can be calculated via automatic transformation to a Cartesian frame:</p><pre><code class="language-julia">x_lla = LLA(-27.468937, 153.023628, 0.0) # City Hall, Brisbane, Australia
y_lla = LLA(-27.465933, 153.025900, 0.0) # Central Station, Brisbane, Australia
distance(x_lla, y_lla)                   # 401.54 meters</code></pre><p>(assuming the <code>wgs84</code> datum, which can be configured in <code>distance(x, y, datum)</code>).</p><h2><a class="nav-anchor" id="Basic-Terminology-1" href="#Basic-Terminology-1">Basic Terminology</a></h2><p>This section describes some terminology and concepts that are relevant to <em>Geodesy.jl</em>, attempting to define Geodesy-specific jargon where possible.  For a longer, less technical discussion with more historical context, ICSM&#39;s <a href="http://www.icsm.gov.au/mapping/index.html">Fundamentals of Mapping page</a> is highly recommended.</p><h3><a class="nav-anchor" id="Coordinate-Reference-Systems-and-Spatial-Reference-Identifiers-1" href="#Coordinate-Reference-Systems-and-Spatial-Reference-Identifiers-1">Coordinate Reference Systems and Spatial Reference Identifiers</a></h3><p>A position on the Earth can be given by some numerical coordinate values, but those don&#39;t mean much without more information.  The extra information is called the <strong>Coordinate Reference System</strong> or <strong>CRS</strong> (also known as a <em>Spatial Reference System</em> or SRS).  A CRS tells you two main things:</p><ul><li>The measurement procedure: which real world objects were used to define the frame of reference or <em>datum</em> of the measurement?</li><li>The <em>coordinate system</em>: how do coordinate numerical values relate to the reference frame defined by the datum?</li></ul><p>The full specification of a CRS can be complex, so a short label called a <strong>Spatial Reference IDentifier</strong> or <strong>SRID</strong> is usually used instead.  For example, <a href="http://epsg.io/4326">EPSG:4326</a> is one way to refer to the 2D WGS84 latitude and longitude you&#39;d get from a mobile phone GPS device.  An SRID is of the form <code>AUTHORITY:CODE</code>, where the code is a number and the authority is the name of an organization maintaining a list of codes with associated CRS information.  There are services where you can look up a CRS, for example, <a href="http://epsg.io">http://epsg.io</a> is a convenient interface to the SRIDs maintained by the <em>European Petroleum Survey Group</em> (EPSG) authority.  Likewise, <a href="http://spatialreference.org">http://spatialreference.org</a> is an open registry to which anyone can contribute.</p><p>When maintaining a spatial database, it&#39;s typical to define an internal list of SRIDs (effectively making your organization the authority), and a mapping from these to CRS information.  A link back to a definitive SRID from an external authority should also be included where possible.</p><h3><a class="nav-anchor" id="Datums-1" href="#Datums-1">Datums</a></h3><p>In spatial measurement and positioning, a <strong>datum</strong> is a set of reference objects and assigned coordinates <em>relative to which</em> other objects may be positioned.  For example, in traditional surveying a datum might comprise a pair of pegs in the ground, separated by a carefully measured distance.  When surveying the position of an unknown but nearby point, the angle back to the original datum objects can be measured using a theodolite.  After this, the relative position of the new point can be computed using simple triangulation. Repeating this trick with any of the now three known points, an entire triangulation network of surveyed objects can be extended outward.  Any point surveyed relative to the network is said to be measured <em>in the datum</em> of the original objects.  Datums are often named with an acronym, for example OSGB36 is the Ordnance Survey of Great Britain, 1936.</p><p>In the era of satellite geodesy, coordinates are determined for an object by timing signals from a satellite constellation (eg, the GPS satellites) and computing position relative to those satellites.  Where is the datum here? At first glance the situation seems quite different from the traditional setup described above.  However, the satellite positions as a function of time (<em>ephemerides</em>, in the jargon) must themselves be defined relative to some frame. This is done by continuously observing the satellites from a set of highly stable ground stations equipped with GPS receivers. It is the full set of these ground stations and their assigned coordinates which form the datum.</p><p>Let&#39;s inspect the flow of positional information in both cases:</p><ul><li>For traditional surveying,<pre><code class="language-none">datum object positions -&gt; triangulation network -&gt; newly surveyed point</code></pre></li><li>For satellite geodesy,<pre><code class="language-none">datum object positions -&gt; satellite ephemerides -&gt; newly surveyed point</code></pre></li></ul><p>We see that the basic nature of a datum is precisely the same regardless of whether we&#39;re doing a traditional survey or using a GPS receiver.</p><h3><a class="nav-anchor" id="Terrestrial-reference-systems-and-frames-1" href="#Terrestrial-reference-systems-and-frames-1">Terrestrial reference systems and frames</a></h3><p>Coordinates for new points are measured by transferring coordinates from the datum objects, as described above.  However, how do we decide on coordinates for the datum objects themselves?  This is purely a matter of convention, consistency and measurement.</p><p>For example, the <strong>International Terrestrial Reference System</strong> (<strong>ITRS</strong>) is a reference system that rotates with the Earth so that the average velocity of the crust is zero. That is, in this reference system the only crust movement is geophysical.  Roughly speaking, the <em>defining conventions</em> for the ITRS are:</p><ul><li>Space is modeled as a three-dimensional Euclidean affine space.</li><li>The origin is at the center of mass of the Earth (it is <em>geocentric</em>).</li><li>The z-axis is the axis of rotation of the Earth.</li><li>The scale is set to 1 SI meter.</li><li>The x-axis is orthogonal to the z-axis and aligns with the international reference meridian through Greenwich.</li><li>The y-axis is set to the cross product of the z and x axes, forming a right handed coordinate frame.</li><li>Various rates of change of the above must also be specified, for example, the scale should stay constant in time.</li></ul><p>The precise conventions are defined in chapter 4 of the <a href="https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html">IERS conventions</a> published by the International Earth Rotation and Reference Service (IERS). These conventions define an ideal reference <em>system</em>, but they&#39;re useless without physical measurements that give coordinates for a set of real world datum objects.  The process of measuring and computing coordinates for datum objects is called <em>realizing</em> the reference system and the result is called a <em>reference frame</em>.  For example, the <strong>International Terrestrial Reference Frame of 2014</strong> (<strong>ITRF2014</strong>) realizes the ITRS conventions using raw measurement data gathered in the 25 years prior to 2014.</p><p>To measure and compute coordinates, several space geodesy techniques are used to gather raw measurement data; currently the IERS includes <a href="https://en.wikipedia.org/wiki/Very-long-baseline_interferometry">VLBI (very long baseline interferometry)</a> of distant astronomical radio sources, <a href="https://en.wikipedia.org/wiki/Satellite_laser_ranging">SLR (satellite laser ranging)</a>, <a href="https://en.wikipedia.org/wiki/Global_Positioning_System">GPS (global positioning system)</a> and <a href="https://en.wikipedia.org/wiki/DORIS_(geodesy)">DORIS (gosh these acronyms are tiring)</a>. The raw data is not in the form of positions, but must be condensed down in a large scale fitting problem, ideally by requiring physical and statistical consistency of all measurements, tying measurements at different sites together with physical models.</p><h3><a class="nav-anchor" id="Coordinate-systems-1" href="#Coordinate-systems-1">Coordinate systems</a></h3><p>In geometry, a <strong>coordinate system</strong> <a href="https://en.wikipedia.org/wiki/Coordinate_system">is a system</a> which uses one or more numbers, or <strong>coordinates</strong> to uniquely determine the position of a point in a mathematical space such as Euclidean space.  For example, in geodesy a point is commonly referred to using geodetic latitude, longitude and height relative to a given reference ellipsoid; this is called a <strong>geodetic coordinate system</strong>.</p><p>An <a href="https://en.wikipedia.org/wiki/Ellipsoid"><strong>ellipsoid</strong></a> is chosen because it&#39;s a reasonable model for the shape of the Earth and its gravitational field without being overly complex; it has only a few parameters, and a simple mathematical form.  The term <a href="https://en.wikipedia.org/wiki/Spheroid"><strong>spheroid</strong></a> is also used because the ellipsoids in use today are rotationally symmetric around the pole. Note that there&#39;s several ways to define <a href="https://en.wikipedia.org/wiki/Latitude">latitude</a> on an ellipsoid. The most natural for geodesy is <strong>geodetic latitude</strong>, used by default because it&#39;s physically accessible in any location as a good approximation to the angle between the gravity vector and the equatorial plane.  (This type of latitude is not an angle measured at the centre of the ellipsoid, which may be surprising if you&#39;re used to spherical coordinates!)</p><p>There are usually several useful coordinate systems for the same space.  As well as the geodetic coordinates mentioned above, it&#39;s common to see</p><ul><li>The x,y,z components in an Earth-Centred Cartesian coordinate system rotating with the Earth.  This is conventionally called an <strong>Earth-Centred Earth-Fixed</strong> (<strong>ECEF</strong>) coordinate system. This is a natural coordinate system in which to define coordinates for the datum objects defining a terrestrial reference frame.</li><li>The east,north and up <strong>ENU</strong> components of a Cartesian coordinate frame at a particular point on the ellipsoid.  This coordinate system is useful as a local frame for navigation.</li><li>Easting,northing and vertical components of a <strong>projected coordinate system</strong> or <a href="http://www.icsm.gov.au/mapping/about_projections.html"><strong>map projection</strong></a>. There&#39;s an entire zoo of these, designed to represent the curved surface of an ellipsoid with a flat map.</li></ul><p>Different coordinates systems provide different coordinates for the same point, so it&#39;s obviously important to specify exactly which coordinate system you&#39;re using.  In particular, you should specify which ellipsoid parameters are in use if you deal with latitude and longitude, as in principle you could have more than one ellipsoid.  This is a point of confusion, because a datum in geodesy also comes with a reference ellipsoid as a very strong matter of convention (thus being called a <strong>geodetic datum</strong>).</p><p>With its conventional ellipsoid, a geodetic datum also defines a conventional geodetic coordinate system, thus bringing together concepts which are interconnected but conceptually distinct.  To emphasize:</p><ul><li>A coordinate system is a mathematical abstraction allowing us to manipulate <em>geometric</em> quantities using numeric and algebraic techniques.  By itself, mathematical geometry is pure abstraction without a connection to the physical world.</li><li>A datum is a set of physical objects with associated coordinates, thereby <em>defining</em> a reference frame in a way which is physically accessible.  A datum is the bridge which connects physical reality to the abstract ideal of mathematical geometry, via the algebraic mechanism of a coordinate system.</li></ul><h2><a class="nav-anchor" id="The-API-1" href="#The-API-1">The API</a></h2><h3><a class="nav-anchor" id="Coordinate-types-1" href="#Coordinate-types-1">Coordinate types</a></h3><p>Geodesy provides several in-built coordinate storage types for convenience and safety. The philosophy is to avoid carrying around raw data in generic containers like <code>Vector</code>s with no concept of what coordinate system it is in.</p><h5><a class="nav-anchor" id="LLA{T}-latitude,-longitude-and-altitude-1" href="#LLA{T}-latitude,-longitude-and-altitude-1"><code>LLA{T}</code> - latitude, longitude and altitude</a></h5><p>The global <code>LLA</code> type stores data in a lat-lon-alt order, where latitude and longitude are expected in degrees (not radians). A keyword constructor, <code>LLA(lat=x, lon=y, alt=z)</code>, is also provided to help with having to remember the storage order.</p><h5><a class="nav-anchor" id="LatLon{T}-latitude-and-longitude-1" href="#LatLon{T}-latitude-and-longitude-1"><code>LatLon{T}</code> - latitude and longitude</a></h5><p>The 2D <code>LatLon</code> type stores data in a lat-lon order, where latitude and longitude are expected in degrees (not radians). A keyword constructor, <code>LatLon(lat=x, lon=y)</code>, is also provided. <code>LatLon</code> is currently the only supported 2D coordinate.</p><h5><a class="nav-anchor" id="ECEF{T}-Earth-centered,-Earth-fixed-1" href="#ECEF{T}-Earth-centered,-Earth-fixed-1"><code>ECEF{T}</code> - Earth-centered, Earth-fixed</a></h5><p>The global <code>ECEF</code> type stores Cartesian coordinates <code>x</code>, <code>y</code>, <code>z</code>, according to the <a href="https://en.wikipedia.org/wiki/ECEF">usual convention</a>. Being a Cartesian frame, <code>ECEF</code> is a subtype of <a href="https://github.com/andyferris/StaticArrays.jl">StaticArrays</a>&#39; <code>StaticVector</code> and they can be added and subtracted with themselves and other vectors.</p><h5><a class="nav-anchor" id="UTM{T}-universal-transverse-Mercator-1" href="#UTM{T}-universal-transverse-Mercator-1"><code>UTM{T}</code> - universal transverse-Mercator</a></h5><p>The <code>UTM</code> type encodes the easting <code>x</code>, northing <code>y</code> and height <code>z</code> of a UTM coordinate in an unspecified zone. This data type is also used to encode universal polar-stereographic (UPS) coordinates (where the zone is <code>0</code>).</p><h5><a class="nav-anchor" id="UTMZ{T}-universal-transverse-Mercator-zone-1" href="#UTMZ{T}-universal-transverse-Mercator-zone-1"><code>UTMZ{T}</code> - universal transverse-Mercator + zone</a></h5><p>In addition to the easting <code>x</code>, northing <code>y</code> and height <code>z</code>, the global <code>UTMZ</code> type also encodes the UTM <code>zone</code> and <code>hemisphere</code>, where <code>zone</code> is a <code>UInt8</code> and <code>hemisphere</code> is a <code>Bool</code> for compact storage. The northern hemisphere is denoted as <code>true</code>, and the southern as <code>false</code>. Zone <code>0</code> corresponds to the UPS projection about the corresponding pole, otherwise <code>zone</code> is an integer between <code>1</code> and <code>60</code>.</p><h5><a class="nav-anchor" id="ENU{T}-east-north-up-1" href="#ENU{T}-east-north-up-1"><code>ENU{T}</code> - east-north-up</a></h5><p>The <code>ENU</code> type is a local Cartesian coordinate that encodes a point&#39;s distance towards east <code>e</code>, towards north <code>n</code> and upwards <code>u</code> with respect to an unspecified origin. Like <code>ECEF</code>, <code>ENU</code> is also a subtype of <code>StaticVector</code>.</p><h3><a class="nav-anchor" id="Geodetic-Datums-1" href="#Geodetic-Datums-1">Geodetic Datums</a></h3><p>Geodetic datums are modelled as subtypes of the abstract type <code>Datum</code>.  The associated ellipsoid may be obtained by calling the <code>ellipsoid()</code> function, for example, <code>ellipsoid(NAD83())</code>.</p><p>There are several pre-defined datums.  Worldwide datums include</p><ul><li><code>WGS84</code> - standard GPS datum for moderate precision work (representing both the latest frame realization, or if time is supplied a discontinuous dynamic datum where time looks up the frame implementation date in the broadcast ephemerides.)</li><li><code>WGS84{GpsWeek}</code> - specific realizations of the WGS84 frame.</li><li><code>ITRF{Year}</code> - Realizations of the International Terrestrial Reference System for high precision surveying.</li></ul><p>National datums include</p><ul><li><code>OSGB36</code> - Ordnance Survey of Great Britain of 1936.</li><li><code>NAD27</code>, <code>NAD83</code> - North American Datums of 1927 and 1983, respectively</li><li><code>GDA94</code> - Geocentric Datum of Australia, 1994.</li></ul><p>Datums may also be passed to coordinate transformation constructors such as transverse-Mercator and polar-stereographic projections in which case the associated ellipsoid will be extracted to form the transformation.  For datums without extra parameters (everything except <code>ITRF</code> and <code>WGS84{Week}</code>) there is a standard instance defined to reduce the amount of brackets you have to type. For example, <code>LLAfromECEF(NAD83())</code> and <code>LLAfromECEF(nad83)</code> are equivalent.</p><h3><a class="nav-anchor" id="Transformations-and-conversions-1" href="#Transformations-and-conversions-1">Transformations and conversions</a></h3><p><em>Geodesy</em> provides two interfaces changing coordinate systems.</p><p>&quot;Transformations&quot; are based on <em>CoordinateTransformations</em> interface for defining <code>AbstractTransformation</code>s and allow the user to apply them by calling them, invert them with <code>inv()</code> and compose them with <code>compose()</code> or <code>∘</code>. The transformations cache any possible pre-calculations for efficiency when the same transformation is applied to many points.</p><p>&quot;Conversions&quot; are based on type-constructors, obeying simple syntax like <code>LLA(ecef, datum)</code>. The <code>datum</code> or other information is <em>always</em> necessary, as no assumptions are made by <em>Geodesy</em> for safety and consistency reasons. Similarly, <code>Base.convert</code> is not defined because, without assumptions, it would require additional information. The main drawback of this approach is that some calculations may not be pre-cached (for instance, the origin of an ENU transformation).</p><h4><a class="nav-anchor" id="Between-LLA-and-ECEF-1" href="#Between-LLA-and-ECEF-1">Between <code>LLA</code> and <code>ECEF</code></a></h4><p>The <code>LLAfromECEF</code> and <code>ECEFfromLLA</code> transformations require an ellipsoidal datum to perform the conversion. The exact transformation is performed in both directions, using a port the ECEF → LLA transformation from <em>GeographicLib</em>.</p><h4><a class="nav-anchor" id="Between-LLA-and-UTM/UTMZ-1" href="#Between-LLA-and-UTM/UTMZ-1">Between <code>LLA</code> and <code>UTM</code>/<code>UTMZ</code></a></h4><p>The <code>LLAfromUTM(Z)</code> and <code>UTM(Z)fromLLA</code> transformations also require an ellipsoidal datum to perform the conversion. The transformation retains a cache of the parameters used in the transformation, which in the case of the transverse-Mercator projection leads to a significant saving.</p><p>In all cases zone <code>0</code> corresponds to the UPS coordinate system, and the polar-stereographic projection of <em>GeographicLib</em> has been ported to Julia to perform the transformation.</p><p>An approximate, 6th-order expansion is used by default for the transverse-Mercator projection and its inverse (though orders 4-8 are defined). The algorithm is a native Julia port of that used in <em>GeographicLib</em>, and is accurate to nanometers for up to several UTM zones away from the reference meridian. However, the series expansion diverges at ±90° from the reference meridian. While the <code>UTMZ</code>-methods will automatically choose the canonical zone and hemisphere for the input, extreme care must be taken to choose an appropriate zone for the <code>UTM</code> methods. (In the future, we implement the exact UTM transformation as a fallback — contributions welcome!)</p><p>There is also <code>UTMfromUTMZ</code> and <code>UTMZfromUTM</code> transformations that are helpful for converting between these two formats and putting data into the same <code>UTM</code> zone.</p><h4><a class="nav-anchor" id="To-and-from-local-ENU-frames-1" href="#To-and-from-local-ENU-frames-1">To and from local <code>ENU</code> frames</a></h4><p>The <code>ECEFfromENU</code> and <code>ENUfromECEF</code> transformations define the transformation around a specific origin. Both the origin coordinates as an <code>ECEF</code> as well as its corresponding latitude and longitude are stored in the transformation for maximal efficiency when performing multiple <code>transform</code>s. The transformation can be inverted with <code>inv</code> to perform the reverse transformation with respect to the same origin.</p><h4><a class="nav-anchor" id="Composed-transformations-1" href="#Composed-transformations-1">Composed transformations</a></h4><p>Many other methods are defined as convenience constructors for composed transformations, to go between any two of the coordinate types defined here. These include:</p><ul><li><code>ECEFfromUTMZ(datum) = ECEFfromLLA(datum) ∘ LLAfromUTMZ(datum)</code></li><li><code>UTMZfromECEF(datum) = UTMZfromLLA(datum) ∘ LLAfromECEF(datum)</code></li><li><code>UTMfromECEF(zone, hemisphere, datum) = UTMfromLLA(zone, hemisphere, datum) ∘ LLAfromECEF(datum)</code></li><li><code>ECEFfromUTM(zone, hemisphere, datum) = ECEFfromLLA(datum) ∘ LLAfromUTM(zone, hemisphere, datum)</code></li><li><code>ENUfromLLA(origin, datum) = ENUfromECEF(origin, datum) ∘ ECEFfromLLA(datum)</code></li><li><code>LLAfromENU(origin, datum) = LLAfromECEF(datum) ∘ ECEFfromENU(origin, datum)</code></li><li><code>ECEFfromUTMZ(datum) = ECEFfromLLA(datum) ∘ LLAfromUTMZ(datum)</code></li><li><code>ENUfromUTMZ(origin, datum)  = ENUfromLLA(origin, datum) ∘ LLAfromUTMZ(datum</code></li><li><code>UTMZfromENU(origin, datum)  = UTMZfromLLA(datum) ∘ LLAfromENU(origin, datum)</code></li><li><code>UTMfromENU(origin, zone, hemisphere, datum) = UTMfromLLA(zone, hemisphere, datum) ∘ LLAfromENU(origin, datum)</code></li><li><code>ENUfromUTM(origin, zone, hemisphere, datum) = ENUfromLLA(origin, datum) ∘ LLAfromUTM(zone, hemisphere, datum)</code></li></ul><p>Constructor-based transforms for these are also provided, such as <code>UTMZ(ecef, datum)</code> which converts to <code>LLA</code> as an intermediary, as above. When converting multiple points to or from the <em>same</em> ENU reference frame, it is recommended to use the transformation-based approach for efficiency. However, the other constructor-based conversions should be similar in speed to their transformation counterparts.</p><h3><a class="nav-anchor" id="Distance-1" href="#Distance-1">Distance</a></h3><p>Currently, the only defined distance measure is the Cartesian distance, <code>distance(x, y, [datum = wgs84])</code>, which works for all combinations of types for <code>x</code> and <code>y</code> - except that the UTM zone and hemisphere must also be provided for <code>UTM</code> types, as in <code>distance(utm1, utm2, zone, hemisphere, [datum = wgs84])</code> (the Cartesian distance for <code>UTM</code> types is not approximated, but achieved via conversion to <code>ECEF</code>).</p><p>This is the only function currently in <em>Geodesy</em> which takes a default datum, and <em>should</em> be relatively accurate for close points where Cartesian distances may be most important. Future work may focus on geodesics and related calculations (contributions welcome!).</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
