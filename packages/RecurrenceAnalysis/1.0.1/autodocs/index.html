<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · RecurrenceAnalysis.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RecurrenceAnalysis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">RecurrenceAnalysis.@histogram_params</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.@windowed" href="#RecurrenceAnalysis.@windowed"><code>RecurrenceAnalysis.@windowed</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@windowed(f(x,...), width)
@windowed(f(x,...); width, step=1)</code></pre><p>Calculate windowed RQA parameters with a given window width.</p><p><code>f(x,...)</code> may be any call to RQA functions (e.g. <a href="#RecurrenceAnalysis.recurrencerate"><code>recurrencerate</code></a>, <a href="#RecurrenceAnalysis.determinism"><code>determinism</code></a>, etc.), with <code>x</code> being a named variable that designates the recurrence matrix (do not use in-place calculations of the recurrence matrix). The results are returned in a vector with one value for each position of the window. By default the window moves at one-point intervals, but a longer <code>step</code> length may be specified, together with the window <code>width</code>, by declaring those options as keyword arguments.</p><p>This macro may be also used with recurrence matrix constructors (<code>RecurrenceMatrix</code>, <code>CrossRecurrenceMatrix</code>, <code>JointRecurrenceMatrix</code>), to create &#39;incomplete&#39; matrices that are suitable for such windowed RQA. The values of the resulting matrix in the diagonals within the window width will be equal to those obtained without the <code>@windowed</code> macro, if the distances are not scaled (using the option <code>scale=1</code>, see <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a>). Outside the window width, the values of the recurrence matrix will be undefined (mostly zero).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.ARM</code></pre><pre><code class="language-none">RecurrenceAnalysis.AbstractRecurrenceMatrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.CrossRecurrenceMatrix" href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>RecurrenceAnalysis.CrossRecurrenceMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CrossRecurrenceMatrix(x, y, ε; kwargs...)</code></pre><p>Create a cross recurrence matrix from trajectories <code>x</code> and <code>y</code>.</p><p>The cross recurrence matrix is a bivariate extension of the recurrence matrix. For the time series <code>x</code>, <code>y</code>, of length <code>n</code> and <code>m</code>, respectively, it is a sparse <code>n×m</code> matrix of Boolean values, such that if <code>d(x[i], y[j]) ≤ ε</code>, then the cell <code>(i, j)</code> of the matrix will have a <code>true</code> value.</p><p>See <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> for details, references and keywords. See also: <a href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>JointRecurrenceMatrix</code></a>.</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.DEFAULT_METRIC</code></pre><pre><code class="language-none">RecurrenceAnalysis.Dataset</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.JointRecurrenceMatrix" href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>RecurrenceAnalysis.JointRecurrenceMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JointRecurrenceMatrix(x, y, ε; kwargs...)</code></pre><p>Create a joint recurrence matrix from <code>x</code> and <code>y</code>.</p><p>The joint recurrence matrix considers the recurrences of the trajectories of <code>x</code> and <code>y</code> separately, and looks for points where both recur simultaneously. It is calculated by the element-wise multiplication of the recurrence matrices of <code>x</code> and <code>y</code>. If <code>x</code> and <code>y</code> are of different length, the recurrences are only calculated until the length of the shortest one.</p><p>See <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> for details, references and keywords. See also: <a href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>CrossRecurrenceMatrix</code></a>.</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.MAXDIM</code></pre><pre><code class="language-none">RecurrenceAnalysis.METRICS</code></pre><pre><code class="language-none">RecurrenceAnalysis.RecurrenceAnalysis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.RecurrenceMatrix" href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceAnalysis.RecurrenceMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RecurrenceMatrix(x, ε; kwargs...)</code></pre><p>Create a recurrence matrix from trajectory <code>x</code>. Objects of type <code>&lt;:AbstractRecurrenceMatrix</code> are displayed as a <a href="#RecurrenceAnalysis.recurrenceplot"><code>recurrenceplot</code></a>.</p><p><strong>Description</strong></p><p>The recurrence matrix is a numeric representation of a &quot;recurrence plot&quot; [1, 2], in the form of a sparse square matrix of Boolean values.</p><p><code>x</code> must be a <code>Vector</code> or a <code>Dataset</code> or a <code>Matrix</code> with data points in rows (possibly representing and embedded phase space; see <a href="@ref"><code>embed</code></a>). If <code>d(x[i], x[j]) ≤ ε</code> (with <code>d</code> the distance function), then the cell <code>(i, j)</code> of the matrix will have a <code>true</code> value. The criteria to evaluate distances between data points are defined by the following keyword arguments:</p><ul><li><code>scale=1</code> : a function of the distance matrix (see <a href="#RecurrenceAnalysis.distancematrix"><code>distancematrix</code></a>), or a fixed number, used to scale the value of <code>ε</code>. Typical choices are <code>maximum</code> or <code>mean</code>, such that the threshold <code>ε</code> is defined as a ratio of the maximum or the mean distance between data points, respectively (using <code>mean</code> or <code>maximum</code> calls specialized versions that are faster than the naive approach).  Use <code>1</code> to keep the distances unscaled (default).</li><li><code>fixedrate::Bool=false</code> : a flag that indicates if <code>ε</code> should be taken as a target fixed recurrence rate (see <a href="#RecurrenceAnalysis.recurrencerate"><code>recurrencerate</code></a>). If <code>fixedrate</code> is set to <code>true</code>, <code>ε</code> must be a value between 0 and 1, and <code>scale</code> is ignored.</li><li><code>metric=&quot;euclidean&quot;</code> : metric of the distances, either <code>Metric</code> or a string,  as in <a href="#RecurrenceAnalysis.distancematrix"><code>distancematrix</code></a>.</li></ul><p>See also: <a href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>CrossRecurrenceMatrix</code></a>, <a href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>JointRecurrenceMatrix</code></a> and use <a href="#RecurrenceAnalysis.recurrenceplot"><code>recurrenceplot</code></a> to turn the result of these functions into a plottable format.</p><p><strong>References</strong></p><p>[1] : N. Marwan <em>et al.</em>, &quot;Recurrence plots for the analysis of complex systems&quot;, <em>Phys. Reports 438</em>(5-6), 237-329 (2007).</p><p>[2] : N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis._computescale</code></pre><pre><code class="language-none">RecurrenceAnalysis._determinism</code></pre><pre><code class="language-none">RecurrenceAnalysis._distancematrix</code></pre><pre><code class="language-none">RecurrenceAnalysis._dl_average</code></pre><pre><code class="language-none">RecurrenceAnalysis._dl_entropy</code></pre><pre><code class="language-none">RecurrenceAnalysis._dl_max</code></pre><pre><code class="language-none">RecurrenceAnalysis._laminarity</code></pre><pre><code class="language-none">RecurrenceAnalysis._linehistograms</code></pre><pre><code class="language-none">RecurrenceAnalysis._recurrence_matrix</code></pre><pre><code class="language-none">RecurrenceAnalysis._rrdenominator</code></pre><pre><code class="language-none">RecurrenceAnalysis._rt_average</code></pre><pre><code class="language-none">RecurrenceAnalysis._rt_entropy</code></pre><pre><code class="language-none">RecurrenceAnalysis._rt_max</code></pre><pre><code class="language-none">RecurrenceAnalysis._trend</code></pre><pre><code class="language-none">RecurrenceAnalysis._vl_average</code></pre><pre><code class="language-none">RecurrenceAnalysis._vl_entropy</code></pre><pre><code class="language-none">RecurrenceAnalysis._vl_max</code></pre><pre><code class="language-none">RecurrenceAnalysis.block2grayscale</code></pre><pre><code class="language-none">RecurrenceAnalysis.checkgridsize</code></pre><pre><code class="language-none">RecurrenceAnalysis.colvals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.coordinates" href="#RecurrenceAnalysis.coordinates"><code>RecurrenceAnalysis.coordinates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coordinates(R) -&gt; xs, ys</code></pre><p>Return the coordinates of the recurrence points of <code>R</code> (in indices).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.deftheiler</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.determinism" href="#RecurrenceAnalysis.determinism"><code>RecurrenceAnalysis.determinism</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">determinism(R[; lmin=2, theiler])</code></pre><p>Calculate the determinism of the recurrence matrix <code>R</code>:</p><p><strong>Description</strong></p><p>The determinism is calculated as:</p><div>\[DET = \frac{\sum_{l=lmin}{l P(l)}}{\sum_{l=1}{l P(l)}} =
\frac{\sum_{l=lmin}{l P(l)}}{\sum R}\]</div><p>where <span>$l$</span> stands for the lengths of diagonal lines in the matrix, and <span>$P(l)$</span> is the number of lines of length equal to <span>$l$</span>.</p><p><code>lmin</code> is set to 2 by default, and this calculation rules out all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.diagonalhistogram</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.distancematrix" href="#RecurrenceAnalysis.distancematrix"><code>RecurrenceAnalysis.distancematrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">distancematrix(x [, y = x], metric = &quot;euclidean&quot;)</code></pre><p>Create a matrix with the distances between each pair of points of the time series <code>x</code> and <code>y</code> using <code>metric</code>.</p><p>The time series <code>x</code> and <code>y</code> can be <code>Dataset</code>s or vectors or matrices with data points in rows. The data point dimensions (or number of columns) must be the same for <code>x</code> and <code>y</code>. The returned value is a <code>n×m</code> matrix, with <code>n</code> being the length (or number of rows) of <code>x</code>, and <code>m</code> the length of <code>y</code>.</p><p>The metric can be identified by a string, or any of the <code>Metric</code>s defined in the <a href="https://github.com/JuliaStats/Distances.jl"><code>Distances</code> package</a>. The list of strings available to define the metric are:</p><ul><li><code>&quot;max&quot;</code> or <code>&quot;inf&quot;</code> for the maximum or L∞ norm (<code>Chebyshev()</code> in the <code>Distances</code> package).</li><li><code>&quot;euclidean&quot;</code> for the L2 or Euclidean norm, used by default (<code>Euclidean()</code> in <code>Distances</code>).</li><li><code>&quot;manhattan&quot;</code>, <code>&quot;cityblock&quot;</code>, <code>&quot;taxicab&quot;</code> or <code>&quot;min&quot;</code> for the Manhattan or L1 norm (<code>Cityblock()</code> in <code>Distances</code>).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.divergence" href="#RecurrenceAnalysis.divergence"><code>RecurrenceAnalysis.divergence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">divergence(R[; theiler])</code></pre><p>Calculate the divergence of the recurrence matrix <code>R</code> (actually the inverse of <a href="#RecurrenceAnalysis.dl_max"><code>dl_max</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.dl_average" href="#RecurrenceAnalysis.dl_average"><code>RecurrenceAnalysis.dl_average</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dl_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the diagonal lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.dl_entropy" href="#RecurrenceAnalysis.dl_entropy"><code>RecurrenceAnalysis.dl_entropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dl_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the diagonal lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.dl_max" href="#RecurrenceAnalysis.dl_max"><code>RecurrenceAnalysis.dl_max</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dl_max(R[; lmin=2, theiler])</code></pre><p>Calculate the longest diagonal line contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.embed</code></pre><pre><code class="language-none">RecurrenceAnalysis.eval</code></pre><pre><code class="language-none">RecurrenceAnalysis.extendhistogram!</code></pre><pre><code class="language-none">RecurrenceAnalysis.extentions</code></pre><pre><code class="language-none">RecurrenceAnalysis.getmetric</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.grayscale" href="#RecurrenceAnalysis.grayscale"><code>RecurrenceAnalysis.grayscale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">grayscale(R [, bwcode]; width::Int, height::Int, exactsize=false)</code></pre><p>Transform the recurrence matrix <code>R</code> into a full matrix suitable for plotting as a grayscale image. By default it returns a matrix with the same size as <code>R</code>, but switched axes, containing &quot;black&quot; values in the cells that represent recurrent points, and &quot;white&quot; values in the empty cells and interpolating in-between for cases with both recurrent and empty cells, see below.</p><p>The numeric codes for black and white are given in a 2-element tuple as a second optional argument. Its default value is <code>(0.0, 1.0)</code>, i.e. black is coded as <code>0.0</code> (no brightness) and white as <code>1.0</code> (full brightness). The type of the elements in the tuple defines the type of the returned matrix. This must be taken into account if, for instance, the image is coded as a matrix of integers corresponding to a grayscale; in such case the black and white codes must be given as numbers of the required integer type.</p><p>The keyword arguments <code>width</code> and <code>height</code> can be given to define a custom size of the image. If only one dimension is given, the other is automatically calculated. If both dimensions are given, by default they are adjusted to keep an aspect proportional to the original matrix, such that the returned matrix fits into a matrix of the given dimensions. This automatic adjustment can be disabled by passing the keyword argument <code>exactsize=true</code>.</p><p>If the image has different dimensions than <code>R</code>, the cells of <code>R</code> are distributed in a grid with the size of the image, and a gray level between white and black is calculated for each element of the grid, proportional to the number of recurrent points contained in it. The levels of gray are coded as numbers of the same type as the black and white codes.</p><p>It is advised to use <code>width, height</code> arguments for large matrices otherwise plots using functions like e.g. <code>imshow</code> could be misleading.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.ij_block_rmat" href="#RecurrenceAnalysis.ij_block_rmat"><code>RecurrenceAnalysis.ij_block_rmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ij_block_rmat(x, y, bsize, dindex, vargs...; kwargs...)</code></pre><p>Return the indices of the rows and columns of the nonzero values of a block-diagonal cross-recurrence matrix.</p><p>If <code>m</code> is the cross-recurrence matrix of <code>x</code> and <code>y</code> (created with the positional and keyword arguments <code>vargs</code> and <code>kwargs</code>), the indices returned by this function are limited to the &quot;block-diagonal&quot; indicated by <code>dindex ∈ {-1,0,1}</code>, as in the following graphical representation (<code>#</code> represents the regions that are included, and <code>O</code> the excluded regions):</p><p><code>dindex==-1</code>    <code>dindex==0</code>    <code>dindex==1</code>  OOOOOO          ##OOOO         OO##OO  OOOOOO          ##OOOO         OO##OO  ##OOOO          OO##OO         OOOO##  ##OOOO          OO##OO         OOOO##  OO##OO          OOOO##         OOOOOO  OO##OO          OOOO##         OOOOOO</p><p>The size of the blocks is <code>bsize × bsize</code>. The last block may be smaller if <code>bsize</code> is not a divisor of the size of the whole cross-recurrence matrix.</p><p>The returned value is a tuple of two arrays, the first containing the indices of the rows and columns of the nonzero values within the included regions.</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.laminarity" href="#RecurrenceAnalysis.laminarity"><code>RecurrenceAnalysis.laminarity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">laminarity(R[; lmin=2, theiler])</code></pre><p>Calculate the laminarity of the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The laminarity is calculated as:</p><div>\[LAM = \frac{\sum_{v=lmin}{v P(l)}}{\sum_{v=1}{v P(v)}} =
\frac{\sum_{v=lmin}{v P(l)}}{\sum R}\]</div><p>where <span>$v$</span> stands for the lengths of vertical lines in the matrix, and <span>$P(v)$</span> is the number of lines of length equal to <span>$v$</span>.</p><p><code>lmin</code> is set to 2 by default, and this calculation rules out all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.meanrecurrencetime" href="#RecurrenceAnalysis.meanrecurrencetime"><code>RecurrenceAnalysis.meanrecurrencetime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">meanrecurrencetime(R[; lmin=2, theiler])</code></pre><p>Calculate the mean recurrence time of the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>Equivalent to <a href="#RecurrenceAnalysis.rt_average"><code>rt_average</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.nmprt" href="#RecurrenceAnalysis.nmprt"><code>RecurrenceAnalysis.nmprt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nmprt(R[; lmin=2, theiler])</code></pre><p>Calculate the number of the most probable recurrence time (NMPRT), ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>This number indicates how many times the system has recurred using the recurrence time that appears most frequently, i.e it is the maximum value of the histogram of recurrence times [1].</p><p><strong>References</strong></p><p>[1] : E.J. Ngamga <em>et al.</em> &quot;Recurrence analysis of strange nonchaotic dynamics&quot;, <em>Physical Review E</em>, 75(3), 036222(1-8), 2007, DOI:10.1103/physreve.75.036222</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.oldshow</code></pre><pre><code class="language-none">RecurrenceAnalysis.overlapgrid</code></pre><pre><code class="language-none">RecurrenceAnalysis.radius_mrr</code></pre><pre><code class="language-none">RecurrenceAnalysis.reconstruct</code></pre><pre><code class="language-none">RecurrenceAnalysis.recurrence_matrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.recurrenceplot" href="#RecurrenceAnalysis.recurrenceplot"><code>RecurrenceAnalysis.recurrenceplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recurrenceplot([io,] R; minh = 25, maxh = 0.5, ascii, kwargs...) -&gt; u</code></pre><p>Create a text-based scatterplot representation of a recurrence matrix <code>R</code> to be displayed in <code>io</code> (by default <code>stdout</code>) using <code>UnicodePlots</code>. The matrix spans at minimum <code>minh</code> rows and at maximum <code>maxh*displaysize(io)[1]</code> (i.e. by default half the display). As we always try to plot in equal aspect ratio, if the width of the plot is even less, the minimum height is dictated by the width.</p><p>The keyword <code>ascii::Bool</code> can ensure that all elements of the plot are ASCII characters (<code>true</code>) or Unicode (<code>false</code>).</p><p>The rest of the <code>kwargs</code> are propagated into <code>UnicodePlots.scatterplot</code>.</p><p>Notice that the accuracy of this function drops drastically for matrices whose size is significantly bigger than the width and height of the display (assuming each index of the matrix is one character).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.recurrencerate" href="#RecurrenceAnalysis.recurrencerate"><code>RecurrenceAnalysis.recurrencerate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recurrencerate(R[; theiler])</code></pre><p>Calculate the recurrence rate of the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The recurrence rate is calculated as:</p><div>\[RR = \frac{1}{S} \sum R\]</div><p>where <span>$S$</span> is the size of <code>R</code> or the region of <code>R</code> with potential recurrent points. There is not a unique definition of that denominator, which is defined as the full size of the matrix in many sources (e.g. [1]), whereas in others it is adjusted to remove the points of the LOI when they are excluded from the count [2,3].</p><p>For matrices of type <code>RecurrenceMatrix</code> or <code>JointRecurrenceMatrix</code>, where the points around the central diagonal are usually excluded, the denominator is adjusted to the size of the matrix outside the Theiler window (by default equal to the LOI, and adjustable with the keyword argument <code>theiler</code>; see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for details). For matrices of type <code>CrossRecurrenceMatrix</code>, where normally all points are analyzed, the denominator is always the full size of the matrix, regardless of the Theiler window that might be defined (none by default).</p><p><em>Hint</em>: to reproduce the calculations done following the formulas that use the full size of the matrix in the denominator, use <code>CrossRecurrenceMatrix(s,s,ε)</code> to define the recurrence matrix, instead of <code>RecurrenceMatrix(s,ε)</code>, setting <code>theiler=1</code> (or <code>theiler=n</code> in general) to explicitly exclude the LOI or other diagonals around it.</p><p><strong>References</strong></p><p>[1] : N. Marwan <em>et al.</em>, &quot;Recurrence plots for the analysis of complex systems&quot;, <em>Phys. Reports 438</em>(5-6), 237-329 (2007).</p><p>[2] : C.L. Webber &amp; J.P. Zbilut, &quot;Recurrence Quantification Analysis of Nonlinear Dynamical Systems&quot;, in: Riley MA &amp; Van Orden GC, Tutorials in Contemporary Nonlinear Methods for the Behavioral Sciences, 26-94 (2005). URL: https://www.nsf.gov/pubs/2005/nsf05057/nmbs/nmbs.pdf</p><p>[3] : N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.recurrencestructures" href="#RecurrenceAnalysis.recurrencestructures"><code>RecurrenceAnalysis.recurrencestructures</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recurrencestructures(x::AbstractRecurrenceMatrix;
                         diagonal=true,
                         vertical=true,
                         recurrencetimes=true,
                         kwargs...)</code></pre><p>Return a dictionary with the histograms of the recurrence structures contained in the recurrence matrix <code>x</code>, with the keys <code>&quot;diagonal&quot;</code>, <code>&quot;vertical&quot;</code> or <code>&quot;recurrencetimes&quot;</code>, depending on what keyword arguments are given as <code>true</code>.</p><p><strong>Description</strong></p><p>Each item of the dictionary is a vector of integers, such that the <code>i</code>-th element of the vector is the number of lines of length <code>i</code> contained in <code>x</code>.</p><ul><li><code>&quot;diagonal&quot;</code> counts the diagonal lines, i.e. the recurrent trajectories.</li><li><code>&quot;vertical&quot;</code> counts the vertical lines, i.e. the laminar states.</li><li><code>&quot;recurrencetimes&quot;</code> counts the vertical distances between recurrent states,   i.e. the recurrence times.</li></ul><p>All the points of the matrix are counted by default. The keyword argument <code>theiler</code> can be passed to rule out the lines around the main diagonal. See the arguments of the function <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for further details.</p><p>&quot;Empty&quot; histograms are represented always as <code>[0]</code>.</p><p><em>Notice</em>: There is not a unique operational definition of &quot;recurrence times&quot;. In the analysis of recurrence plots, usually the  &quot;second type&quot; of recurrence times as defined by Gao and Cai [1] are considered, i.e. the distance between consecutive (but separated) recurrent structures in the vertical direction of the matrix. But that distance is not uniquely defined when the vertical recurrent structures are longer than one point. The recurrence times calculated here are the distance between the midpoints of consecutive lines, which is a balanced estimator of the Poincaré recurrence times [2].</p><p><strong>References</strong></p><p>[1] J. Gao &amp; H. Cai. &quot;On the structures and quantification of recurrence plots&quot;. <a href="https://www.sciencedirect.com/science/article/pii/S0375960100003042?via%3Dihub"><em>Physics Letters A</em>, 270(1-2), 75–87 (2000)</a>.</p><p>[2] N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.rqa" href="#RecurrenceAnalysis.rqa"><code>RecurrenceAnalysis.rqa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rqa(R; kwargs...)</code></pre><p>Calculate all RQA parameters of a recurrence matrix <code>R</code>. See the functions referred to below for the definition of the different parameters and the default values of the arguments. Using this function is much more efficient than calling all individual functions one by one.</p><p><strong>Return</strong></p><p>The returned value is a NamedTuple with the following entries:</p><ul><li><code>RR</code>: recurrence rate (see <a href="#RecurrenceAnalysis.recurrencerate"><code>recurrencerate</code></a>)</li><li><code>DET</code>: determinsm (see <a href="#RecurrenceAnalysis.determinism"><code>determinism</code></a>)</li><li><code>L</code>: average length of diagonal structures (see <a href="#RecurrenceAnalysis.dl_average"><code>dl_average</code></a>)</li><li><code>Lmax</code>: maximum length of diagonal structures (see <a href="#RecurrenceAnalysis.dl_max"><code>dl_max</code></a>)</li><li><code>DIV</code>: divergence (see <a href="#RecurrenceAnalysis.divergence"><code>divergence</code></a>)</li><li><code>ENTR</code>: entropy of diagonal structures (see <a href="#RecurrenceAnalysis.dl_entropy"><code>dl_entropy</code></a>)</li><li><code>TREND</code>: trend of recurrences (see <a href="#RecurrenceAnalysis.trend"><code>trend</code></a>)</li><li><code>LAM</code>: laminarity (see <a href="#RecurrenceAnalysis.laminarity"><code>laminarity</code></a>)</li><li><code>TT</code>: trapping time (see <a href="#RecurrenceAnalysis.trappingtime"><code>trappingtime</code></a>)</li><li><code>Vmax</code>: maximum length of vertical structures (see <a href="#RecurrenceAnalysis.vl_max"><code>vl_max</code></a>)</li><li><code>VENTR</code>: entropy of vertical structures (see <a href="#RecurrenceAnalysis.vl_entropy"><code>vl_entropy</code></a>)</li><li><code>MRT</code>: mean recurrence time (see <a href="#RecurrenceAnalysis.meanrecurrencetime"><code>meanrecurrencetime</code></a>)</li><li><code>RTE</code> recurrence time entropy (see <a href="#RecurrenceAnalysis.rt_entropy"><code>rt_entropy</code></a>)</li><li><code>NMPRT</code>: number of the most probable recurrence time (see <a href="#RecurrenceAnalysis.nmprt"><code>nmprt</code></a>)</li></ul><p>In the case of empty histograms (e.g. no existing vertical lines less than the keyword <code>lminvert</code>) the average and maximum values (<code>L</code>, <code>Lmax</code>, <code>TT</code>, <code>Vmax</code>, <code>MRT</code>) are returned as <code>0.0</code> but their respective entropies (<code>ENTR</code>, <code>VENTR</code>, <code>RTE</code>) are returned as <code>NaN</code>.</p><p><strong>Keyword Arguments</strong></p><p>Standard keyword arguments are the ones accepted by the functions listed below, i.e. <code>theiler</code>, <code>lmin</code>, and <code>border</code>:</p><ul><li><p><code>theiler</code> is used to define a &quot;Theiler window&quot; around the central diagonal or &quot;line of identity&quot; (LOI): a region of points that are excluded in the calculation of RQA parameters, in order to rule out self-recurrences and apparent recurrences for smooth or high resolution data. The LOI is excluded by default for matrices of the types <code>RecurrenceMatrix</code> or <code>JointRecurrenceMatrix</code>, but it is included for matrices of the type <code>CrossRecurrenceMatrix</code>. <code>theiler=0</code> means that the whole matrix is scanned for lines. <code>theiler=1</code> means that the LOI is excluded. In general, <code>theiler=n</code> means that the <code>n</code> central diagonals are excluded (at both sides of the LOI, i.e. actually <code>2n-1</code> diagonals are excluded).</p></li><li><p><code>lmin</code> is used to define the minimum line length in the parameters that describe the distributions of diagonal or vertical lines (it is set as 2 by default).</p></li><li><p><code>border</code> is used to avoid border effects in the calculation of <code>TREND</code> (cf. <a href="#RecurrenceAnalysis.trend"><code>trend</code></a>).</p></li></ul><p>In addition <code>theilerdiag</code>, <code>lmindiag</code> may be used to declare specific values that override the values of <code>theiler</code> and <code>lmin</code> in the calculation of parameters related to diagonal structures. Likewise, <code>theilervert</code> and <code>lminvert</code> can be used for the calculation of parameters related to vertical structures.</p><p>The keyword argument <code>onlydiagonal</code> (<code>false</code> by default) can be set to <code>true</code> in order to restrict the analysis to the recurrence rate and the parameters related to diagonal structures (<code>RR</code>, <code>DET</code>, <code>L</code>, <code>Lmax</code>, <code>DIV</code> and <code>ENTR</code>), which makes this function slightly faster.</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.rqa_funs</code></pre><pre><code class="language-none">RecurrenceAnalysis.rqa_types</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.rt_average" href="#RecurrenceAnalysis.rt_average"><code>RecurrenceAnalysis.rt_average</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the recurrence times contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.rt_entropy" href="#RecurrenceAnalysis.rt_entropy"><code>RecurrenceAnalysis.rt_entropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the recurrence times contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.rt_histogram</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.rt_max" href="#RecurrenceAnalysis.rt_max"><code>RecurrenceAnalysis.rt_max</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_max(R[; lmin=2, theiler])</code></pre><p>Calculate the longest recurrence time contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.sorteddistances" href="#RecurrenceAnalysis.sorteddistances"><code>RecurrenceAnalysis.sorteddistances</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sorteddistances(x; kwargs...)</code></pre><p>Return a tuple with the sorted distances between points of the embedded time series <code>x</code>, and the recurrence rates under those values.</p><p>The keyword arguments are the same that should be passed to the functions <code>recurrencematrix</code> and <code>recurrencerate</code> to obtain those results. I.e., if <code>d,r = sorteddistances(x; kwargs...)</code>, and <code>rmat = recurrencematrix(x, d[i]; kwargs...)</code>, then <code>recurrencerate(rmat; kwargs...) == r[i]</code>.</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.tau_recurrence</code></pre><pre><code class="language-none">RecurrenceAnalysis.textrecurrenceplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.trappingtime" href="#RecurrenceAnalysis.trappingtime"><code>RecurrenceAnalysis.trappingtime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trappingtime(R[; lmin=2, theiler])</code></pre><p>Calculate the trapping time of the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>The trapping time is the average of the vertical line structures and thus equal to <a href="#RecurrenceAnalysis.vl_average"><code>vl_average</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.trend" href="#RecurrenceAnalysis.trend"><code>RecurrenceAnalysis.trend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trend(R[; border=10, theiler])</code></pre><p>Calculate the trend of recurrences in the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The trend is the slope of the linear regression that relates the density of recurrent points in the diagonals parallel to the LOI and the distance between those diagonals and the LOI. It quantifies the degree of system stationarity, such that in recurrence plots where points &quot;fade away&quot; from the central diagonal, the trend will have a negative value.</p><p>It is calculated as:</p><div>\[TREND = 10^3\frac{\sum_{d=\tau}^{\tilde{N}}\delta[d]\left(RR[d]-\langle RR[d]\rangle\right)}{\sum_{d=\tau}^{\tilde{N}}\delta[d]^2}\]</div><p>where <span>$RR[d]$</span> is the local recurrence rate of the diagonal <span>$d$</span>, <span>$\delta[d]$</span> is a balanced measure of the distance between that diagonal and the LOI, <span>$\tau$</span> is the Theiler window (number of central diagonals that are excluded), and <span>$\tilde{N}$</span> is the number of the outmost diagonal that is included.</p><p>This parameter is expressed in units of variation recurrence rate every 1000 data points, hence the factor <span>$10^3$</span> in the formula [1]. </p><p>The 10 outermost diagonals (counting from the corners of the matrix) are excluded by default to avoid &quot;border effects&quot;. Use the keyword argument <code>border</code> to define a different number of excluded lines, and <code>theiler</code> to define the size of the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for details).</p><p><em>Note</em>: In rectangular cross-recurrence plots (i.e. when the time series that originate them are not of the same length), the limits of the formula for TREND are not clearly defined. For the sake of consistency, this function limits the calculations to the biggest square matrix that contains the LOI.</p><p><strong>References</strong></p><p>[1] C.L. Webber &amp; J.P. Zbilut, &quot;Recurrence Quantification Analysis of Nonlinear Dynamical Systems&quot;, in: Riley MA &amp; Van Orden GC, <em>Tutorials in Contemporary Nonlinear Methods for the Behavioral Sciences</em>, 2005, 26-94. https://www.nsf.gov/pubs/2005/nsf05057/nmbs/nmbs.pdf</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.verticalhistograms</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.vl_average" href="#RecurrenceAnalysis.vl_average"><code>RecurrenceAnalysis.vl_average</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vl_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the vertical lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.vl_entropy" href="#RecurrenceAnalysis.vl_entropy"><code>RecurrenceAnalysis.vl_entropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vl_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the vertical lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><pre><code class="language-none">RecurrenceAnalysis.vl_histogram</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecurrenceAnalysis.vl_max" href="#RecurrenceAnalysis.vl_max"><code>RecurrenceAnalysis.vl_max</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vl_max(R[; lmin=2, theiler])</code></pre><p>Calculate the longest vertical line contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
