<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· GPUArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GPUArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Why-another-GPU-array-package-in-yet-another-language?-1">Why another GPU array package in yet another language?</a></li><li class="toplevel"><a class="toctext" href="#Scope-1">Scope</a></li><li class="toplevel"><a class="toctext" href="#Currently-supported-subset-of-Julia-Code-1">Currently supported subset of Julia Code</a></li><li class="toplevel"><a class="toctext" href="#JLArray-1">JLArray</a></li><li class="toplevel"><a class="toctext" href="#TODO-/-up-for-grabs-1">TODO / up for grabs</a></li><li class="toplevel"><a class="toctext" href="#Installation-1">Installation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GPUArrays-1" href="#GPUArrays-1">GPUArrays</a></h1><p><a href="https://travis-ci.org/JuliaGPU/GPUArrays.jl"><img src="https://travis-ci.org/JuliaGPU/GPUArrays.jl.svg?branch=master" alt/></a> <a href="https://ci.appveyor.com/project/SimonDanisch/gpuarrays-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/2aa4bvmq7e9rh338/branch/master?svg=true" alt/></a> <a href="https://gitlab.com/JuliaGPU/GPUArrays.jl/pipelines"><img src="https://gitlab.com/JuliaGPU/GPUArrays.jl/badges/master/pipeline.svg" alt/></a> <a href="https://codecov.io/gh/JuliaGPU/GPUArrays.jl"><img src="https://codecov.io/gh/JuliaGPU/GPUArrays.jl/branch/master/graph/badge.svg" alt/></a> <a href="https://JuliaGPU.github.io/GPUArrays.jl/latest"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt/></a></p><p><a href="https://github.com/JuliaGPU/GPUBenchmarks.jl/blob/master/results/results.md">Benchmarks</a></p><p>Abstract GPU Array package for Julia&#39;s various GPU backends. See it as a Julia Base.AbstractArray for GPUs. Currently, you either need to install <a href="https://github.com/JuliaGPU/CLArrays.jl">CLArrays</a> or <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArrays</a> for a concrete implementation.</p><h1><a class="nav-anchor" id="Why-another-GPU-array-package-in-yet-another-language?-1" href="#Why-another-GPU-array-package-in-yet-another-language?-1">Why another GPU array package in yet another language?</a></h1><p>Julia offers great advantages for programming the GPU. This <a href="http://mikeinnes.github.io/2017/08/24/cudanative.html">blog post</a> outlines a few of those.</p><p>E.g., we can use Julia&#39;s JIT to generate optimized kernels for map/broadcast operations.</p><p>This works even for things like complex arithmetic, since we can compile what&#39;s already in Julia Base. This isn&#39;t restricted to Julia Base, GPUArrays works with all kind of user defined types and functions!</p><p>GPUArrays relies heavily on Julia&#39;s dot broadcasting. The great thing about dot broadcasting in Julia is, that it <a href="http://julialang.org/blog/2017/01/moredots">actually fuses operations syntactically</a>, which is vital for performance on the GPU. E.g.:</p><pre><code class="language-Julia">out .= a .+ b ./ c .+ 1
#turns into this one broadcast (map):
broadcast!(out, a, b, c) do a, b, c
    a + b / c + 1
end</code></pre><p>Will result in one GPU kernel call to a function that combines the operations without any extra allocations. This allows GPUArrays to offer a lot of functionality with minimal code.</p><p>Also, when compiling Julia for the GPU, we can use all the cool features from Julia, e.g. higher order functions, multiple dispatch, meta programming and generated functions. Checkout the examples, to see how this can be used to emit specialized code while not losing flexibility:</p><p><a href="https://github.com/JuliaGPU/GPUBenchmarks.jl/blob/master/results/results.md">&lt;img src=&quot;https://raw.githubusercontent.com/JuliaGPU/GPUBenchmarks.jl/master/results/plots/juliaset_result.png&quot; height=&quot;150&quot;&gt;</a> <a href="https://juliagpu.github.io/GPUShowcases.jl/latest/">&lt;img src=&quot;https://user-images.githubusercontent.com/1010467/40832645-12ca1f50-658c-11e8-9fb4-170871db2499.png&quot; height=&quot;150&quot;&gt;</a></p><p>In theory, we could go as far as inspecting user defined callbacks (we can get the complete AST), count operations and estimate register usage and use those numbers to optimize our kernels!</p><h1><a class="nav-anchor" id="Scope-1" href="#Scope-1">Scope</a></h1><p>Interface offered for all backends:</p><pre><code class="language-Julia">map(f, ::GPUArray...)
map!(f, dest::GPUArray, ::GPUArray...)

broadcast(f, ::GPUArray...)
broadcast!(f, dest::GPUArray, ::GPUArray...)

mapreduce(f, op, ::GPUArray...) # so support for sum/mean/minimum etc comes for free

getindex, setindex!, push!, append!, splice!, append!, copy!, reinterpret, convert

From (CL/CU)FFT
fft!/fft/ifft/ifft! and the matching plan_fft functions.
From (CL/CU)BLAS
gemm!, scal!, gemv! and the high level functions that are implemented with these, like A * B, A_mul_B!, etc.</code></pre><h1><a class="nav-anchor" id="Currently-supported-subset-of-Julia-Code-1" href="#Currently-supported-subset-of-Julia-Code-1">Currently supported subset of Julia Code</a></h1><p>working with immutable isbits (not containing pointers) type should be completely supported non allocating code (so no constructs like <code>x = [1, 2, 3]</code>). Note that tuples are isbits, so this works x = (1, 2, 3). Transpiler/OpenCL has problems with putting GPU arrays on the gpu into a struct - so no views and actually no multidimensional indexing. For that <code>size</code> is needed which would need to be part of the array struct. A fix for that is in sight, though.</p><h1><a class="nav-anchor" id="JLArray-1" href="#JLArray-1">JLArray</a></h1><p>The <code>JLArray</code> is a <code>GPUArray</code> which doesn&#39;t run on the GPU and rather uses Julia&#39;s async constructs as its backend. It serves as a fallback for testing compatibility with <code>GPUArray</code>s in cases where a GPU does not exist and as a reference implementation. It is constructed as follows:</p><pre><code class="language-julia">gA = JLArray(A)</code></pre><h1><a class="nav-anchor" id="TODO-/-up-for-grabs-1" href="#TODO-/-up-for-grabs-1">TODO / up for grabs</a></h1><ul><li>stencil operations, convolutions</li><li>more tests and benchmarks</li><li>tests, that only switch the backend but use the same code</li><li>performance improvements!!</li><li>interop between OpenCL, CUDA and OpenGL is there as a protype, but needs proper hooking up via <code>Base.copy!</code> / <code>convert</code></li></ul><h1><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h1><p>See CuArrays or CLArrays for installation instructions.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
