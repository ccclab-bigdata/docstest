<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · GPUArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GPUArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.@LocalMemory" href="#GPUArrays.@LocalMemory"><code>GPUArrays.@LocalMemory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Creates a local static memory shared inside one block. Equivalent to <code>__local</code> of OpenCL or <code>__shared__ (&lt;variable&gt;)</code> of CUDA.</p></div></div></section><pre><code class="language-none">GPUArrays.@allowscalar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.@cartesianidx" href="#GPUArrays.@cartesianidx"><code>GPUArrays.@cartesianidx</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">cartesianidx(A, statesym = :state)</code></pre><p>Like <a href="../#GPUArrays.@linearidx-Tuple{Any,Any}"><code>@linearidx(A, statesym = :state)</code></a>, but returns an N-dimensional <code>NTuple{ndim(A), Int}</code> as index</p></div></div></section><pre><code class="language-none">GPUArrays.@disallowscalar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.@linearidx" href="#GPUArrays.@linearidx"><code>GPUArrays.@linearidx</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">linearidx(A, statesym = :state)</code></pre><p>Macro form of <code>linear_index</code>, which calls return when out of bounds. So it can be used like this:</p><pre><code class="language-none">```julia
function kernel(state, A)
    idx = @linear_index A state
    # from here on it&#39;s save to index into A with idx
    @inbounds begin
        A[idx] = ...
    end
end
```</code></pre></div></div></section><pre><code class="language-none">GPUArrays.AbstractDeviceArray</code></pre><pre><code class="language-none">GPUArrays.CommonReduceResult</code></pre><pre><code class="language-none">GPUArrays.FFTKernel</code></pre><pre><code class="language-none">GPUArrays.FFTPlan</code></pre><pre><code class="language-none">GPUArrays.GPUArray</code></pre><pre><code class="language-none">GPUArrays.GPUArrays</code></pre><pre><code class="language-none">GPUArrays.GPUBackend</code></pre><pre><code class="language-none">GPUArrays.GPUDestArray</code></pre><pre><code class="language-none">GPUArrays.GPUMatrix</code></pre><pre><code class="language-none">GPUArrays.GPUVecOrMat</code></pre><pre><code class="language-none">GPUArrays.GPUVector</code></pre><pre><code class="language-none">GPUArrays.JLArray</code></pre><pre><code class="language-none">GPUArrays.JLBackend</code></pre><pre><code class="language-none">GPUArrays.JLDevice</code></pre><pre><code class="language-none">GPUArrays.JLState</code></pre><pre><code class="language-none">GPUArrays.LCGStep</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.LocalMem" href="#GPUArrays.LocalMem"><code>GPUArrays.LocalMem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Thread group local memory</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.LocalMemory" href="#GPUArrays.LocalMemory"><code>GPUArrays.LocalMemory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Creates a block local array pointer with <code>T</code> being the element type and <code>N</code> the length. Both T and N need to be static! C is a counter for approriately get the correct Local mem id in CUDAnative. This is an internal method which needs to be overloaded by the GPU Array backends</p></div></div></section><pre><code class="language-none">GPUArrays.Sampler</code></pre><pre><code class="language-none">GPUArrays.SmallSigned</code></pre><pre><code class="language-none">GPUArrays.SmallUnsigned</code></pre><pre><code class="language-none">GPUArrays.TausStep</code></pre><pre><code class="language-none">GPUArrays.TestSuite</code></pre><pre><code class="language-none">GPUArrays.WidenReduceResult</code></pre><pre><code class="language-none">GPUArrays._allowscalar</code></pre><pre><code class="language-none">GPUArrays._getindex</code></pre><pre><code class="language-none">GPUArrays._gpu_call</code></pre><pre><code class="language-none">GPUArrays._ind2sub</code></pre><pre><code class="language-none">GPUArrays._setindex!</code></pre><pre><code class="language-none">GPUArrays._sub2ind</code></pre><pre><code class="language-none">GPUArrays.acc_mapreduce</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.all_devices" href="#GPUArrays.all_devices"><code>GPUArrays.all_devices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns all devices from <code>backends = active_backends()</code>. Device can be filtered by passing <code>filter_funcs</code>, e.g. : <code>is_gpu</code>, <code>is_cpu</code>, <code>(dev)-&gt; has_atleast(dev, threads, 512)</code></p></div></div></section><pre><code class="language-none">GPUArrays.allequal</code></pre><pre><code class="language-none">GPUArrays.allowscalar</code></pre><pre><code class="language-none">GPUArrays.assertscalar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.available_devices" href="#GPUArrays.available_devices"><code>GPUArrays.available_devices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns all devices for the current backend. Device can be filtered by passing <code>filter_funcs</code>, e.g. : <code>is_gpu</code>, <code>is_cpu</code>, <code>(dev)-&gt; has_atleast(dev, threads, 512)</code></p></div></div></section><pre><code class="language-none">GPUArrays.backend</code></pre><pre><code class="language-none">GPUArrays.bgetindex</code></pre><pre><code class="language-none">GPUArrays.blas_module</code></pre><pre><code class="language-none">GPUArrays.blasbuffer</code></pre><pre><code class="language-none">GPUArrays.blockdim_x</code></pre><pre><code class="language-none">GPUArrays.blockdim_y</code></pre><pre><code class="language-none">GPUArrays.blockdim_z</code></pre><pre><code class="language-none">GPUArrays.blockidx_x</code></pre><pre><code class="language-none">GPUArrays.blockidx_y</code></pre><pre><code class="language-none">GPUArrays.blockidx_z</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.blocks" href="#GPUArrays.blocks"><code>GPUArrays.blocks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Blocks that group together hardware threads</p></div></div></section><pre><code class="language-none">GPUArrays.cached_state</code></pre><pre><code class="language-none">GPUArrays.clear_cache</code></pre><pre><code class="language-none">GPUArrays.collect_kernel</code></pre><pre><code class="language-none">GPUArrays.convolution!</code></pre><pre><code class="language-none">GPUArrays.convolution_fft!</code></pre><pre><code class="language-none">GPUArrays.convolution_kernel</code></pre><pre><code class="language-none">GPUArrays.copy_kernel!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.destroy!" href="#GPUArrays.destroy!"><code>GPUArrays.destroy!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Destroys context, freeing all it&#39;s resources.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.device" href="#GPUArrays.device"><code>GPUArrays.device</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">device(A::AbstractArray)</code></pre><p>Gets the device associated to the Array <code>A</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.device_summary" href="#GPUArrays.device_summary"><code>GPUArrays.device_summary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Summarizes all features of a device and prints it to <code>io</code></p></div></div></section><pre><code class="language-none">GPUArrays.eltype_or</code></pre><pre><code class="language-none">GPUArrays.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.fast_isapprox" href="#GPUArrays.fast_isapprox"><code>GPUArrays.fast_isapprox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Same as Base.isapprox, but without keyword args and without nans</p></div></div></section><pre><code class="language-none">GPUArrays.fftkernel</code></pre><pre><code class="language-none">GPUArrays.filterfuncs</code></pre><pre><code class="language-none">GPUArrays.floattype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.forall_devices" href="#GPUArrays.forall_devices"><code>GPUArrays.forall_devices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Iterates through all available devices and calls <code>f(context)</code> after initializing the standard context for that device.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.free_global_memory" href="#GPUArrays.free_global_memory"><code>GPUArrays.free_global_memory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Free global memory. Isn&#39;t supported for AMD cards right now, in which case it returns NaN, so don&#39;t rely on the output of this function.</p></div></div></section><pre><code class="language-none">GPUArrays.genperm</code></pre><pre><code class="language-none">GPUArrays.getidx_2d1d</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.global_memory" href="#GPUArrays.global_memory"><code>GPUArrays.global_memory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Global memory, e.g. VRAM or RAM of device</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.global_size" href="#GPUArrays.global_size"><code>GPUArrays.global_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">global_size(state)</code></pre><p>Global size == blockdim * griddim == total number of kernel execution</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.gpu_call" href="#GPUArrays.gpu_call"><code>GPUArrays.gpu_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gpu_call(kernel::Function, A::GPUArray, args::Tuple, configuration = length(A))</code></pre><p>Calls function <code>kernel</code> on the GPU. <code>A</code> must be an GPUArray and will help to dispatch to the correct GPU backend and supplies queues and contexts. Calls the kernel function with <code>kernel(state, args...)</code>, where state is dependant on the backend and can be used for getting an index into <code>A</code> with <code>linear_index(state)</code>. Optionally, a launch configuration can be supplied in the following way:</p><pre><code class="language-none">1) A single integer, indicating how many work items (total number of threads) you want to launch.
    in this case `linear_index(state)` will be a number in the range `1:configuration`
2) Pass a tuple of integer tuples to define blocks and threads per blocks!</code></pre></div></div></section><pre><code class="language-none">GPUArrays.gpu_convert</code></pre><pre><code class="language-none">GPUArrays.gpu_ind2sub</code></pre><pre><code class="language-none">GPUArrays.gpu_promote_type</code></pre><pre><code class="language-none">GPUArrays.gpu_rand</code></pre><pre><code class="language-none">GPUArrays.gpu_sub2ind</code></pre><pre><code class="language-none">GPUArrays.griddim_x</code></pre><pre><code class="language-none">GPUArrays.griddim_y</code></pre><pre><code class="language-none">GPUArrays.griddim_z</code></pre><pre><code class="language-none">GPUArrays.grow_at</code></pre><pre><code class="language-none">GPUArrays.grow_dimensions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.has_atleast" href="#GPUArrays.has_atleast"><code>GPUArrays.has_atleast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Checks a device for a certain attribute and returns true if it has at least <code>value</code>. Can be used with e.g. <code>threads</code>, <code>blocks</code>, <code>global_memory</code>, <code>local_memory</code></p></div></div></section><pre><code class="language-none">GPUArrays.include</code></pre><pre><code class="language-none">GPUArrays.index_kernel</code></pre><pre><code class="language-none">GPUArrays.indexstyle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.is_cpu" href="#GPUArrays.is_cpu"><code>GPUArrays.is_cpu</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns true if <code>device</code> is a cpu</p></div></div></section><pre><code class="language-none">GPUArrays.is_cudanative</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.is_gpu" href="#GPUArrays.is_gpu"><code>GPUArrays.is_gpu</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns true if <code>device</code> is a gpu</p></div></div></section><pre><code class="language-none">GPUArrays.is_julia</code></pre><pre><code class="language-none">GPUArrays.is_opencl</code></pre><pre><code class="language-none">GPUArrays.is_opengl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.linear_index" href="#GPUArrays.linear_index"><code>GPUArrays.linear_index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linear_index(state)</code></pre><p>linear index corresponding to each kernel launch (in OpenCL equal to get<em>global</em>id).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.local_memory" href="#GPUArrays.local_memory"><code>GPUArrays.local_memory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Block local memory</p></div></div></section><pre><code class="language-none">GPUArrays.make_rand_num</code></pre><pre><code class="language-none">GPUArrays.mapreduce_impl</code></pre><pre><code class="language-none">GPUArrays.mapreducedim_kernel</code></pre><pre><code class="language-none">GPUArrays.materialize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.name" href="#GPUArrays.name"><code>GPUArrays.name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Hardware name of a device</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.new_context" href="#GPUArrays.new_context"><code>GPUArrays.new_context</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a new context from <code>device</code> without caching the resulting context.</p></div></div></section><pre><code class="language-none">GPUArrays.next_rand</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.on_device" href="#GPUArrays.on_device"><code>GPUArrays.on_device</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a temporary context for <code>device</code> and executes <code>f(context)</code> while this context is active. Context gets destroyed afterwards. Note, that creating a temporary context is expensive.</p></div></div></section><pre><code class="language-none">GPUArrays.reduce_kernel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.reset!" href="#GPUArrays.reset!"><code>GPUArrays.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Resets a context freeing all resources and creating a new context.</p></div></div></section><pre><code class="language-none">GPUArrays.reshape!</code></pre><pre><code class="language-none">GPUArrays.setindex_kernel!</code></pre><pre><code class="language-none">GPUArrays.shmem_counter</code></pre><pre><code class="language-none">GPUArrays.simple_broadcast_index</code></pre><pre><code class="language-none">GPUArrays.startvalue</code></pre><pre><code class="language-none">GPUArrays.supports_double</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.synchronize" href="#GPUArrays.synchronize"><code>GPUArrays.synchronize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">synchronize(A::AbstractArray)</code></pre><p>Blocks until all operations are finished on <code>A</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.synchronize_threads" href="#GPUArrays.synchronize_threads"><code>GPUArrays.synchronize_threads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> synchronize_threads(state)</code></pre><p>in CUDA terms <code>__synchronize</code> in OpenCL terms: <code>barrier(CLK_LOCAL_MEM_FENCE)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.test" href="#GPUArrays.test"><code>GPUArrays.test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Runs the entire GPUArrays test suite on array type <code>AT</code></p></div></div></section><pre><code class="language-none">GPUArrays.thread_blocks_heuristic</code></pre><pre><code class="language-none">GPUArrays.threadidx_x</code></pre><pre><code class="language-none">GPUArrays.threadidx_y</code></pre><pre><code class="language-none">GPUArrays.threadidx_z</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.threads" href="#GPUArrays.threads"><code>GPUArrays.threads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Hardware threads of device</p></div></div></section><pre><code class="language-none">GPUArrays.to_blocks</code></pre><pre><code class="language-none">GPUArrays.to_cartesian</code></pre><pre><code class="language-none">GPUArrays.to_cpu</code></pre><pre><code class="language-none">GPUArrays.to_device</code></pre><pre><code class="language-none">GPUArrays.to_index</code></pre><pre><code class="language-none">GPUArrays.to_number_range</code></pre><pre><code class="language-none">GPUArrays.transpose_blocks!</code></pre><pre><code class="language-none">GPUArrays.uniformscaling_kernel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.unsafe_reinterpret" href="#GPUArrays.unsafe_reinterpret"><code>GPUArrays.unsafe_reinterpret</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unsafe reinterpret for backends to overload. This makes it easier to do checks just on the high level.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GPUArrays.update!" href="#GPUArrays.update!"><code>GPUArrays.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This updates an array, even if dimensions and sizes don&#39;t match. Will resize accordingly!</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
