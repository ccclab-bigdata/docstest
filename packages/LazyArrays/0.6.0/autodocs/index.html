<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · LazyArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">LazyArrays.@lazyldiv</code></pre><pre><code class="language-none">LazyArrays.@lazylmul</code></pre><pre><code class="language-none">LazyArrays.@lazymul</code></pre><pre><code class="language-none">LazyArrays.AbstractArrayApplyStyle</code></pre><pre><code class="language-none">LazyArrays.AbstractBandedLayout</code></pre><pre><code class="language-none">LazyArrays.AbstractColumnMajor</code></pre><pre><code class="language-none">LazyArrays.AbstractConcatArray</code></pre><pre><code class="language-none">LazyArrays.AbstractDecreasingStrides</code></pre><pre><code class="language-none">LazyArrays.AbstractFillLayout</code></pre><pre><code class="language-none">LazyArrays.AbstractIncreasingStrides</code></pre><pre><code class="language-none">LazyArrays.AbstractRowMajor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.AbstractStridedLayout" href="#LazyArrays.AbstractStridedLayout"><code>LazyArrays.AbstractStridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractStridedLayout</code></pre><p>is an abstract type whose subtypes are returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is BLAS compatible and the element type is a <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>. In this case, one must implement the strided array interface, which requires overrides of <code>strides(A::MyMatrix)</code> and <code>unknown_convert(::Type{Ptr{T}}, A::MyMatrix)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.Add" href="#LazyArrays.Add"><code>LazyArrays.Add</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Add(A1, A2, …, AN)</code></pre><p>A lazy representation of <code>A1 + A2 + … + AN</code>; i.e., a shorthand for <code>applied(+, A1, A2, …, AN)</code>.</p></div></div></section><pre><code class="language-none">LazyArrays.AddArray</code></pre><pre><code class="language-none">LazyArrays.AddMatrix</code></pre><pre><code class="language-none">LazyArrays.AddVector</code></pre><pre><code class="language-none">LazyArrays.Applied</code></pre><pre><code class="language-none">LazyArrays.ApplyArray</code></pre><pre><code class="language-none">LazyArrays.ApplyBroadcastStyle</code></pre><pre><code class="language-none">LazyArrays.ApplyLayout</code></pre><pre><code class="language-none">LazyArrays.ApplyMatrix</code></pre><pre><code class="language-none">LazyArrays.ApplyStyle</code></pre><pre><code class="language-none">LazyArrays.ApplyVector</code></pre><pre><code class="language-none">LazyArrays.ArrayLdivArray</code></pre><pre><code class="language-none">LazyArrays.ArrayLdivArrayStyle</code></pre><pre><code class="language-none">LazyArrays.ArrayMulArray</code></pre><pre><code class="language-none">LazyArrays.ArrayMulArrayAdd</code></pre><pre><code class="language-none">LazyArrays.ArrayMulArrayStyle</code></pre><pre><code class="language-none">LazyArrays.ArrayMuls</code></pre><pre><code class="language-none">LazyArrays.BArrayLdivArray</code></pre><pre><code class="language-none">LazyArrays.BArrayMulArray</code></pre><pre><code class="language-none">LazyArrays.BArrayMulArrayAdd</code></pre><pre><code class="language-none">LazyArrays.BArrayMulArrayPlusArray</code></pre><pre><code class="language-none">LazyArrays.BArrayMulArrayPlusConstArray</code></pre><pre><code class="language-none">LazyArrays.BConstArrayMulArray</code></pre><pre><code class="language-none">LazyArrays.BConstArrayMulArrayPlusArray</code></pre><pre><code class="language-none">LazyArrays.BConstArrayMulArrayPlusConstArray</code></pre><pre><code class="language-none">LazyArrays.BlasMatMulMat</code></pre><pre><code class="language-none">LazyArrays.BlasMatMulVec</code></pre><pre><code class="language-none">LazyArrays.BroadcastArray</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.BroadcastLayout" href="#LazyArrays.BroadcastLayout"><code>LazyArrays.BroadcastLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BroadcastLayout(f, layouts)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> is a <code>BroadcastArray</code>. <code>f</code> is a function that broadcast operation is applied and <code>layouts</code> is a tuple of <code>MemoryLayout</code> of the broadcasted arguments.</p></div></div></section><pre><code class="language-none">LazyArrays.CachedArray</code></pre><pre><code class="language-none">LazyArrays.CachedMatrix</code></pre><pre><code class="language-none">LazyArrays.CachedVector</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ColumnMajor" href="#LazyArrays.ColumnMajor"><code>LazyArrays.ColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a column major array, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p><p>Arrays with <code>ColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div></section><pre><code class="language-none">LazyArrays.ConjLayout</code></pre><pre><code class="language-none">LazyArrays.Cumsum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DecreasingStrides" href="#LazyArrays.DecreasingStrides"><code>LazyArrays.DecreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DecreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with decreasing strides, so that <code>stride(A,ndims(A)) ≥ 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p></div></div></section><pre><code class="language-none">LazyArrays.DefaultApplyStyle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseColumnMajor" href="#LazyArrays.DenseColumnMajor"><code>LazyArrays.DenseColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory equivalent to an <code>Array</code>, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≡ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(1, size(A,1))`.</p><p>Arrays with <code>DenseColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseRowMajor" href="#LazyArrays.DenseRowMajor"><code>LazyArrays.DenseRowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseRowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array with dense entries, so that <code>stride(A,ndims(A)) == 1</code> and <code>stride(A,i) ≡ size(A,i+1) * stride(A,i+1)</code> for <code>1 ≤ i ≤ ndims(A)-1</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(size(A,2), 1)`.</p></div></div></section><pre><code class="language-none">LazyArrays.DiagonalLayout</code></pre><pre><code class="language-none">LazyArrays.Diff</code></pre><pre><code class="language-none">LazyArrays.FillLayout</code></pre><pre><code class="language-none">LazyArrays.Hcat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.HermitianLayout" href="#LazyArrays.HermitianLayout"><code>LazyArrays.HermitianLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HermitianLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a hermitianized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>HermitianLayout(layout, uplo)</code> must overrided <code>hermitiandata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == conj(B[j,k])</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.IncreasingStrides" href="#LazyArrays.IncreasingStrides"><code>LazyArrays.IncreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IncreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with  increasing strides, so that <code>stride(A,1) ≥ 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p></div></div></section><pre><code class="language-none">LazyArrays.Inv</code></pre><pre><code class="language-none">LazyArrays.InvMatrix</code></pre><pre><code class="language-none">LazyArrays.InvOrPInv</code></pre><pre><code class="language-none">LazyArrays.Kron</code></pre><pre><code class="language-none">LazyArrays.LayoutApplyStyle</code></pre><pre><code class="language-none">LazyArrays.LazyArrayApplyStyle</code></pre><pre><code class="language-none">LazyArrays.LazyArrayStyle</code></pre><pre><code class="language-none">LazyArrays.LazyArrays</code></pre><pre><code class="language-none">LazyArrays.Ldiv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.LowerTriangularLayout" href="#LazyArrays.LowerTriangularLayout"><code>LazyArrays.LowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LowerTriangularLayout(layout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>LowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>LowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≤ k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UpperTriangularLayout</code>.</p></div></div></section><pre><code class="language-none">LazyArrays.MatLdivMat</code></pre><pre><code class="language-none">LazyArrays.MatLdivVec</code></pre><pre><code class="language-none">LazyArrays.MatMulMat</code></pre><pre><code class="language-none">LazyArrays.MatMulMatAdd</code></pre><pre><code class="language-none">LazyArrays.MatMulVec</code></pre><pre><code class="language-none">LazyArrays.MatMulVecAdd</code></pre><pre><code class="language-none">LazyArrays.MatrixFunctionStyle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.MemoryLayout" href="#LazyArrays.MemoryLayout"><code>LazyArrays.MemoryLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MemoryLayout(A)</code></pre><p>specifies the layout in memory for an array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to override <code>MemoryLayout</code> to indicate how an array is stored in memory. For example, if your matrix is column major with <code>stride(A,2) == size(A,1)</code>, then override as follows:</p><pre><code class="language-none">MemoryLayout(::MyMatrix) = DenseColumnMajor()</code></pre><p>The default is <code>UnknownLayout()</code> to indicate that the layout in memory is unknown.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is compatible.</p></div></div></section><pre><code class="language-none">LazyArrays.Mul</code></pre><pre><code class="language-none">LazyArrays.Mul2</code></pre><pre><code class="language-none">LazyArrays.MulAdd</code></pre><pre><code class="language-none">LazyArrays.MulArray</code></pre><pre><code class="language-none">LazyArrays.MulLayout</code></pre><pre><code class="language-none">LazyArrays.MulMatrix</code></pre><pre><code class="language-none">LazyArrays.MulVector</code></pre><pre><code class="language-none">LazyArrays.PInv</code></pre><pre><code class="language-none">LazyArrays.PInvMatrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.RowMajor" href="#LazyArrays.RowMajor"><code>LazyArrays.RowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array, so that <code>stride(A,ndims(A)) == 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p><p>If <code>A</code> is a matrix  with <code>RowMajor</code> memory layout, then <code>transpose(A)</code> should return a matrix whose layout is <code>ColumnMajor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ScalarLayout" href="#LazyArrays.ScalarLayout"><code>LazyArrays.ScalarLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if A is a scalar, which does not live in memory</p></div></div></section><pre><code class="language-none">LazyArrays.SetOperations</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.StridedLayout" href="#LazyArrays.StridedLayout"><code>LazyArrays.StridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StridedLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory. <code>Array</code>s with <code>StridedLayout</code> must conform to the <code>DenseArray</code> interface.</p></div></div></section><pre><code class="language-none">LazyArrays.SymTridiagonalLayout</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.SymmetricLayout" href="#LazyArrays.SymmetricLayout"><code>LazyArrays.SymmetricLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymmetricLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a symmetrized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>SymmetricLayout(layout, uplo)</code> must overrided <code>symmetricdata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == B[j,k]</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div></section><pre><code class="language-none">LazyArrays.TriangularLayout</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitLowerTriangularLayout" href="#LazyArrays.UnitLowerTriangularLayout"><code>LazyArrays.UnitLowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnitLowerTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UnitLowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>UnitLowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ B[k,j]</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitUpperTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitUpperTriangularLayout" href="#LazyArrays.UnitUpperTriangularLayout"><code>LazyArrays.UnitUpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnitUpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UnitUpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitLowerTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnknownLayout" href="#LazyArrays.UnknownLayout"><code>LazyArrays.UnknownLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnknownLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if it is unknown how the entries of an array <code>A</code> are stored in memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UpperTriangularLayout" href="#LazyArrays.UpperTriangularLayout"><code>LazyArrays.UpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≥ k</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>LowerTriangularLayout</code>.</p></div></div></section><pre><code class="language-none">LazyArrays.Vcat</code></pre><pre><code class="language-none">LazyArrays.VcatLayout</code></pre><pre><code class="language-none">LazyArrays.ZerosLayout</code></pre><pre><code class="language-none">LazyArrays._BroadcastArray</code></pre><pre><code class="language-none">LazyArrays._Hcat</code></pre><pre><code class="language-none">LazyArrays._Vcat</code></pre><pre><code class="language-none">LazyArrays.__default_materialize</code></pre><pre><code class="language-none">LazyArrays._broadcast2broadcastarray</code></pre><pre><code class="language-none">LazyArrays._broadcast_getindex_range</code></pre><pre><code class="language-none">LazyArrays._column_subarraylayout</code></pre><pre><code class="language-none">LazyArrays._column_subarraylayout1</code></pre><pre><code class="language-none">LazyArrays._copyto!</code></pre><pre><code class="language-none">LazyArrays._cumsum</code></pre><pre><code class="language-none">LazyArrays._default_materialize</code></pre><pre><code class="language-none">LazyArrays._dotplus</code></pre><pre><code class="language-none">LazyArrays._eltypes</code></pre><pre><code class="language-none">LazyArrays._gemm!</code></pre><pre><code class="language-none">LazyArrays._gemv!</code></pre><pre><code class="language-none">LazyArrays._hemv!</code></pre><pre><code class="language-none">LazyArrays._kron2!</code></pre><pre><code class="language-none">LazyArrays._kron_dims</code></pre><pre><code class="language-none">LazyArrays._lmaterialize</code></pre><pre><code class="language-none">LazyArrays._materialize</code></pre><pre><code class="language-none">LazyArrays._mul</code></pre><pre><code class="language-none">LazyArrays._mul_axes</code></pre><pre><code class="language-none">LazyArrays._mul_eltype</code></pre><pre><code class="language-none">LazyArrays._mul_ndims</code></pre><pre><code class="language-none">LazyArrays._row_subarraylayout</code></pre><pre><code class="language-none">LazyArrays._row_subarraylayout1</code></pre><pre><code class="language-none">LazyArrays._strided_subarraylayout</code></pre><pre><code class="language-none">LazyArrays._symv!</code></pre><pre><code class="language-none">LazyArrays._vcat_axes</code></pre><pre><code class="language-none">LazyArrays._vcat_broadcasted</code></pre><pre><code class="language-none">LazyArrays._vcat_cumsum</code></pre><pre><code class="language-none">LazyArrays._vcat_getindex_eval</code></pre><pre><code class="language-none">LazyArrays.adjointlayout</code></pre><pre><code class="language-none">LazyArrays.applied</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.cache" href="#LazyArrays.cache"><code>LazyArrays.cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cache(array::AbstractArray)</code></pre><p>Caches the entries of an array.</p></div></div></section><pre><code class="language-none">LazyArrays.checkdimensions</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.colsupport" href="#LazyArrays.colsupport"><code>LazyArrays.colsupport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>&quot;     colsupport(A, j)</p><p>gives an iterator containing the possible non-zero entries in the j-th column of A.</p></div></div></section><pre><code class="language-none">LazyArrays.conjlayout</code></pre><pre><code class="language-none">LazyArrays.default_blasmul!</code></pre><pre><code class="language-none">LazyArrays.diagonaldata</code></pre><pre><code class="language-none">LazyArrays.eval</code></pre><pre><code class="language-none">LazyArrays.hermitiandata</code></pre><pre><code class="language-none">LazyArrays.hermitianlayout</code></pre><pre><code class="language-none">LazyArrays.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.lmaterialize" href="#LazyArrays.lmaterialize"><code>LazyArrays.lmaterialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>lmaterialize(M::Mul)</p><p>materializes arrays iteratively, left-to-right.</p></div></div></section><pre><code class="language-none">LazyArrays.materializeargs</code></pre><pre><code class="language-none">LazyArrays.offdiagonaldata</code></pre><pre><code class="language-none">LazyArrays.reinterpretedmemorylayout</code></pre><pre><code class="language-none">LazyArrays.reshapedmemorylayout</code></pre><pre><code class="language-none">LazyArrays.resizedata!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.rowsupport" href="#LazyArrays.rowsupport"><code>LazyArrays.rowsupport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>&quot;     rowsupport(A, k)</p><p>gives an iterator containing the possible non-zero entries in the k-th row of A.</p></div></div></section><pre><code class="language-none">LazyArrays.subarraylayout</code></pre><pre><code class="language-none">LazyArrays.symmetricdata</code></pre><pre><code class="language-none">LazyArrays.symmetriclayout</code></pre><pre><code class="language-none">LazyArrays.tile_size</code></pre><pre><code class="language-none">LazyArrays.tiled_blasmul!</code></pre><pre><code class="language-none">LazyArrays.transposelayout</code></pre><pre><code class="language-none">LazyArrays.triangulardata</code></pre><pre><code class="language-none">LazyArrays.triangularlayout</code></pre><pre><code class="language-none">LazyArrays.⋆</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
