<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Making and Modifying Graphs · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><a class="toctext" href="../graphtypes/">Choosing A Graph Type</a></li><li><a class="toctext" href="../types/">LightGraphs Types</a></li><li><a class="toctext" href="../basicproperties/">Accessing Properties</a></li><li class="current"><a class="toctext" href>Making and Modifying Graphs</a><ul class="internal"><li><a class="toctext" href="#Modifying-graphs-1">Modifying graphs</a></li><li><a class="toctext" href="#Graph-Generators-1">Graph Generators</a></li><li><a class="toctext" href="#Datasets-1">Datasets</a></li></ul></li><li><a class="toctext" href="../persistence/">Reading / Writing Graphs</a></li><li><a class="toctext" href="../operators/">Operators</a></li><li><a class="toctext" href="../plotting/">Plotting Graphs</a></li><li><a class="toctext" href="../pathing/">Path and Traversal</a></li><li><a class="toctext" href="../distance/">Distance</a></li><li><a class="toctext" href="../centrality/">Centrality Measures</a></li><li><a class="toctext" href="../linalg/">Linear Algebra</a></li><li><a class="toctext" href="../matching/">Matching</a></li><li><a class="toctext" href="../community/">Community Structures</a></li><li><a class="toctext" href="../degeneracy/">Degeneracy</a></li><li><a class="toctext" href="../integration/">Integration with other packages</a></li><li><a class="toctext" href="../experimental/">Experimental Functionality</a></li><li><a class="toctext" href="../parallel/">Parallel Algorithms</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../developing/">Developer Notes</a></li><li><a class="toctext" href="../license/">License Information</a></li><li><a class="toctext" href="../citing/">Citing LightGraphs</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Making and Modifying Graphs</a></li></ul></nav><hr/><div id="topbar"><span>Making and Modifying Graphs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Making-and-Modifying-Graphs-1" href="#Making-and-Modifying-Graphs-1">Making and Modifying Graphs</a></h1><p><em>LightGraphs.jl</em> provides a number of methods for creating a graph object, including tools for building and modifying graph objects, a wide array of graph generator functions, and the ability to read and write graphs from files (using <a href="https://github.com/JuliaGraphs/GraphIO.jl">GraphIO.jl</a>).</p><h2><a class="nav-anchor" id="Modifying-graphs-1" href="#Modifying-graphs-1">Modifying graphs</a></h2><p><em>LightGraphs.jl</em> offers a range of tools for modifying graphs, including:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleGraph" href="#LightGraphs.SimpleGraphs.SimpleGraph"><code>LightGraphs.SimpleGraphs.SimpleGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimpleGraph{T}</code></pre><p>A type representing an undirected graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleGraphFromIterator" href="#LightGraphs.SimpleGraphs.SimpleGraphFromIterator"><code>LightGraphs.SimpleGraphs.SimpleGraphFromIterator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SimpleGraphFromIterator(iter)</code></pre><p>Create a <a href="#LightGraphs.SimpleGraphs.SimpleGraph"><code>SimpleGraph</code></a> from an iterator <code>iter</code>. The elements in iter must be of <code>type &lt;: SimpleEdge</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; h = SimpleGraphFromIterator(edges(g));

julia&gt; collect(edges(h))
2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleDiGraph" href="#LightGraphs.SimpleGraphs.SimpleDiGraph"><code>LightGraphs.SimpleGraphs.SimpleDiGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimpleDiGraph{T}</code></pre><p>A type representing a directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleDiGraphFromIterator" href="#LightGraphs.SimpleGraphs.SimpleDiGraphFromIterator"><code>LightGraphs.SimpleGraphs.SimpleDiGraphFromIterator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SimpleDiGraphFromIterator(iter)</code></pre><p>Create a <code>SimpleDiGraph</code> from an iterator <code>iter</code>. The elements in <code>iter</code> must be of <code>type &lt;: SimpleEdge</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleDiGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 1);

julia&gt; h = SimpleDiGraphFromIterator(edges(g))
{2, 2} directed simple Int64 graph

julia&gt; collect(edges(h))
2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.Edge" href="#LightGraphs.Edge"><code>LightGraphs.Edge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Edge</code></pre><p>A datastruture representing an edge between two vertices in a <code>Graph</code> or <code>DiGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.add_edge!" href="#LightGraphs.SimpleGraphs.add_edge!"><code>LightGraphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_edge!(g, e)</code></pre><p>Add an edge <code>e</code> to graph <code>g</code>. Return <code>true</code> if edge was added successfully, otherwise return <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2)
true

julia&gt; add_edge!(g, 2, 3)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.rem_edge!" href="#LightGraphs.SimpleGraphs.rem_edge!"><code>LightGraphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_edge!(g, e)</code></pre><p>Remove an edge <code>e</code> from graph <code>g</code>. Return <code>true</code> if edge was removed successfully, otherwise return <code>false</code>.</p><p><strong>Implementation Notes</strong></p><p>If <code>rem_edge!</code> returns <code>false</code>, the graph may be in an indeterminate state, as there are multiple points where the function can exit with <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; rem_edge!(g, 1, 2)
true

julia&gt; rem_edge!(g, 1, 2)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.add_vertex!" href="#LightGraphs.SimpleGraphs.add_vertex!"><code>LightGraphs.SimpleGraphs.add_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_vertex!(g)</code></pre><p>Add a new vertex to the graph <code>g</code>. Return <code>true</code> if addition was successful.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(Int8(typemax(Int8) - 1))
{126, 0} undirected simple Int8 graph

julia&gt; add_vertex!(g)
true

julia&gt; add_vertex!(g)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.add_vertices!" href="#LightGraphs.add_vertices!"><code>LightGraphs.add_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_vertices!(g, n)</code></pre><p>Add <code>n</code> new vertices to the graph <code>g</code>. Return the number of vertices that were added successfully.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph()
{0, 0} undirected simple Int64 graph

julia&gt; add_vertices!(g, 2)
2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.rem_vertex!" href="#LightGraphs.SimpleGraphs.rem_vertex!"><code>LightGraphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_vertex!(g, v)</code></pre><p>Remove the vertex <code>v</code> from graph <code>g</code>. Return <code>false</code> if removal fails (e.g., if vertex is not in the graph); <code>true</code> otherwise.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(k^2)$</span>, where <span>$k$</span> is the max of the degrees of vertex <span>$v$</span> and vertex <span>$|V|$</span>.</p><p><strong>Implementation Notes</strong></p><p>This operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices <code>v</code>  and <span>$|V|$</span>, and removing the last vertex <span>$|V|$</span> from the graph. After removal the vertices in <code>g</code> will be indexed by <span>$1:|V|-1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(2);

julia&gt; rem_vertex!(g, 2)
true

julia&gt; rem_vertex!(g, 2)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zero" href="#Base.zero"><code>Base.zero</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zero(g)</code></pre><p>Return a zero-vertex, zero-edge version of the same type of graph as <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; zero(g)
{0, 0} directed simple Int64 graph</code></pre></div></div></section><p>In addition to these core functions, more advanced operators can be found in <a href="../operators/#Operators-1">Operators</a>.</p><h2><a class="nav-anchor" id="Graph-Generators-1" href="#Graph-Generators-1">Graph Generators</a></h2><p><em>LightGraphs.jl</em> implements numerous graph generators, including random graph generators, constructors for classic graphs, numerous small graphs with familiar topologies, and random and static graphs embedded in Euclidean space.</p><ul><li><a href="#LightGraphs.Edge"><code>LightGraphs.Edge</code></a></li><li><a href="#LightGraphs.add_vertices!"><code>LightGraphs.add_vertices!</code></a></li></ul><h2><a class="nav-anchor" id="Datasets-1" href="#Datasets-1">Datasets</a></h2><p>Other notorious graphs and integration with the <code>MatrixDepot.jl</code> package are available in the <code>Datasets</code> submodule of the companion package <a href="https://github.com/JuliaGraphs/LightGraphsExtras.jl">LightGraphsExtras.jl</a>. Selected graphs from the <a href="https://snap.stanford.edu/data/index.html">Stanford Large Network Dataset Collection</a> may be found in the <a href="https://github.com/JuliaGraphs/SNAPDatasets.jl">SNAPDatasets.jl</a> package.</p><h3><a class="nav-anchor" id="All-Generators-1" href="#All-Generators-1">All Generators</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.SimpleDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SimpleDiGraph{T}(nv, ne; seed=-1)</code></pre><p>Construct a random <code>SimpleDiGraph{T}</code> with <code>nv</code> vertices and <code>ne</code> edges. The graph is sampled uniformly from all such graphs. If <code>seed &gt;= 0</code>, a random generator is seeded with this value. If not specified, the element type <code>T</code> is the type of <code>nv</code>.</p><p><strong>See also</strong></p><p><a href="#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Integer}"><code>erdos_renyi</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SimpleDiGraph(5, 7)
{5, 7} directed simple Int64 graph</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,Channel}" href="#LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,Channel}"><code>LightGraphs.SimpleGraphs.SimpleGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SimpleGraph{T}(nv, ne, edgestream::Channel)</code></pre><p>Construct a <code>SimpleGraph{T}</code> with <code>nv</code> vertices and <code>ne</code> edges from <code>edgestream</code>. Can result in less than <code>ne</code> edges if the channel <code>edgestream</code> is closed prematurely. Duplicate edges are only counted once. The element type is the type of <code>nv</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,StochasticBlockModel}" href="#LightGraphs.SimpleGraphs.SimpleGraph-Tuple{Integer,Integer,StochasticBlockModel}"><code>LightGraphs.SimpleGraphs.SimpleGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SimpleGraph{T}(nv, ne, smb::StochasticBlockModel)</code></pre><p>Construct a random <code>SimpleGraph{T}</code> with <code>nv</code> vertices and <code>ne</code> edges. The graph is sampled according to the stochastic block model <code>smb</code>. The element type is the type of <code>nv</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.SimpleGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.SimpleGraph-Union{Tuple{T}, Tuple{Integer,Integer}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.SimpleGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SimpleGraph{T}(nv, ne; seed=-1)</code></pre><p>Construct a random <code>SimpleGraph{T}</code> with <code>nv</code> vertices and <code>ne</code> edges. The graph is sampled uniformly from all such graphs. If <code>seed &gt;= 0</code>, a random generator is seeded with this value. If not specified, the element type <code>T</code> is the type of <code>nv</code>.</p><p><strong>See also</strong></p><p><a href="#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Integer}"><code>erdos_renyi</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SimpleGraph(5, 7)
{5, 7} undirected simple Int64 graph</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.StochasticBlockModel" href="#LightGraphs.SimpleGraphs.StochasticBlockModel"><code>LightGraphs.SimpleGraphs.StochasticBlockModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StochasticBlockModel{T,P}</code></pre><p>A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge <code>(i,j)</code> depends only on the block labels of vertex <code>i</code> and vertex <code>j</code>.</p><p>The assignement is stored in nodemap and the block affinities a <code>k</code> by <code>k</code> matrix is stored in affinities.</p><p><code>affinities[k,l]</code> is the probability of an edge between any vertex in block <code>k</code> and any vertex in block <code>l</code>.</p><p><strong>Implementation Notes</strong></p><p>Graphs are generated by taking random <span>$i,j ∈ V$</span> and flipping a coin with probability <code>affinities[nodemap[i],nodemap[j]]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.barabasi_albert!-Tuple{AbstractGraph,Integer,Integer}" href="#LightGraphs.SimpleGraphs.barabasi_albert!-Tuple{AbstractGraph,Integer,Integer}"><code>LightGraphs.SimpleGraphs.barabasi_albert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)</code></pre><p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph <code>g</code>. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer,Integer}" href="#LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer,Integer}"><code>LightGraphs.SimpleGraphs.barabasi_albert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">barabasi_albert(n::Integer, n0::Integer, k::Integer)</code></pre><p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph with <code>n0</code> vertices. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.</p><p><strong>Optional Arguments</strong></p><ul><li><code>is_directed=false</code>: if true, return a directed graph.</li><li><code>complete=false</code>: if true, use a complete graph for the initial graph.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer}" href="#LightGraphs.SimpleGraphs.barabasi_albert-Tuple{Integer,Integer}"><code>LightGraphs.SimpleGraphs.barabasi_albert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">barabasi_albert(n, k)</code></pre><p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph with <code>k</code> vertices. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.</p><p><strong>Optional Arguments</strong></p><ul><li><code>is_directed=false</code>: if true, return a directed graph.</li><li><code>complete=false</code>: if true, use a complete graph for the initial graph.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.blockcounts-Tuple{StochasticBlockModel,AbstractArray{T,2} where T}" href="#LightGraphs.SimpleGraphs.blockcounts-Tuple{StochasticBlockModel,AbstractArray{T,2} where T}"><code>LightGraphs.SimpleGraphs.blockcounts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">blockcounts(sbm, A)</code></pre><p>Count the number of edges that go between each block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.dorogovtsev_mendes-Tuple{Integer}" href="#LightGraphs.SimpleGraphs.dorogovtsev_mendes-Tuple{Integer}"><code>LightGraphs.SimpleGraphs.dorogovtsev_mendes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dorogovtsev_mendes(n)</code></pre><p>Generate a random <code>n</code> vertex graph by the Dorogovtsev-Mendes method (with <code>n \ge 3</code>).</p><p>The Dorogovtsev-Mendes process begins with a triangle graph and inserts <code>n-3</code> additional vertices. Each time a vertex is added, a random edge is selected and the new vertex is connected to the two  endpoints of the chosen edge. This creates graphs with a many triangles and a high local clustering coefficient.</p><p>It is often useful to track the evolution of the graph as vertices are added, you can access the graph from the <code>t</code>th stage of this algorithm by accessing the first <code>t</code> vertices with <code>g[1:t]</code>.</p><p><strong>References</strong></p><ul><li>http://graphstream-project.org/doc/Generators/Dorogovtsev-Mendes-generator/</li><li>https://arxiv.org/pdf/cond-mat/0106144.pdf#page=24</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Integer}" href="#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Integer}"><code>LightGraphs.SimpleGraphs.erdos_renyi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">erdos_renyi(n, ne)</code></pre><p>Create an <a href="http://en.wikipedia.org/wiki/Erdős–Rényi_model">Erdős–Rényi</a> random graph with <code>n</code> vertices and <code>ne</code> edges.</p><p><strong>Optional Arguments</strong></p><ul><li><code>is_directed=false</code>: if true, return a directed graph.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Real}" href="#LightGraphs.SimpleGraphs.erdos_renyi-Tuple{Integer,Real}"><code>LightGraphs.SimpleGraphs.erdos_renyi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">erdos_renyi(n, p)</code></pre><p>Create an <a href="http://en.wikipedia.org/wiki/Erdős–Rényi_model">Erdős–Rényi</a> random graph with <code>n</code> vertices. Edges are added between pairs of vertices with probability <code>p</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>is_directed=false</code>: if true, return a directed graph.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.expected_degree_graph-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real" href="#LightGraphs.SimpleGraphs.expected_degree_graph-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real"><code>LightGraphs.SimpleGraphs.expected_degree_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">expected_degree_graph(ω)</code></pre><p>Given a vector of expected degrees <code>ω</code> indexed by vertex, create a random undirected graph in which vertices <code>i</code> and <code>j</code> are connected with probability <code>ω[i]*ω[j]/sum(ω)</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul><p><strong>Implementation Notes</strong></p><p>The algorithm should work well for <code>maximum(ω) &lt;&lt; sum(ω)</code>. As <code>maximum(ω)</code> approaches <code>sum(ω)</code>, some deviations from the expected values are likely.</p><p><strong>References</strong></p><ul><li>Connected Components in Random Graphs with Given Expected Degree Sequences, Linyuan Lu and Fan Chung. <a href="https://link.springer.com/article/10.1007%2FPL00012580">https://link.springer.com/article/10.1007%2FPL00012580</a></li><li>Efficient Generation of Networks with Given Expected Degrees, Joel C. Miller and Aric Hagberg. <a href="https://doi.org/10.1007/978-3-642-21286-4_10">https://doi.org/10.1007/978-3-642-21286-4_10</a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.kronecker" href="#LightGraphs.SimpleGraphs.kronecker"><code>LightGraphs.SimpleGraphs.kronecker</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kronecker(SCALE, edgefactor, A=0.57, B=0.19, C=0.19)</code></pre><p>Generate a directed <a href="https://en.wikipedia.org/wiki/Kronecker_graph">Kronecker graph</a> with the default Graph500 parameters.</p><p><strong></strong></p><p>References</p><ul><li>http://www.graph500.org/specifications#alg:generator</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.make_edgestream-Tuple{StochasticBlockModel}" href="#LightGraphs.SimpleGraphs.make_edgestream-Tuple{StochasticBlockModel}"><code>LightGraphs.SimpleGraphs.make_edgestream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">make_edgestream(sbm)</code></pre><p>Take an infinite sample from the Stochastic Block Model <code>sbm</code>. Pass to <code>Graph(nvg, neg, edgestream)</code> to get a Graph object based on <code>sbm</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.random_configuration_model-Union{Tuple{T}, Tuple{Integer,Array{T,N} where N}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.random_configuration_model-Union{Tuple{T}, Tuple{Integer,Array{T,N} where N}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.random_configuration_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_configuration_model(n, ks)</code></pre><p>Create a random undirected graph according to the <a href="http://tuvalu.santafe.edu/~aaronc/courses/5352/fall2013/csci5352_2013_L11.pdf">configuration model</a> containing <code>n</code> vertices, with each node <code>i</code> having degree <code>k[i]</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li><li><code>check_graphical=false</code>: if true, ensure that <code>k</code> is a graphical sequence</li></ul><p>(see <a href="../pathing/#LightGraphs.isgraphical"><code>isgraphical</code></a>).</p><p><strong>Performance</strong></p><p>Time complexity is approximately <span>$\mathcal{O}(n \bar{k}^2)$</span>.</p><p><strong>Implementation Notes</strong></p><p>Allocates an array of <span>$n \bar{k}$</span> <code>Int</code>s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.random_regular_digraph-Tuple{Integer,Integer}" href="#LightGraphs.SimpleGraphs.random_regular_digraph-Tuple{Integer,Integer}"><code>LightGraphs.SimpleGraphs.random_regular_digraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_regular_digraph(n, k)</code></pre><p>Create a random directed <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: the direction of the edges for degree parameter.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul><p><strong>Implementation Notes</strong></p><p>Allocates an <span>$n × n$</span> sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.random_regular_graph-Tuple{Integer,Integer}" href="#LightGraphs.SimpleGraphs.random_regular_graph-Tuple{Integer,Integer}"><code>LightGraphs.SimpleGraphs.random_regular_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_regular_graph(n, k)</code></pre><p>Create a random undirected <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul><p><strong>Performance</strong></p><p>Time complexity is approximately <span>$\mathcal{O}(nk^2)$</span>.</p><p><strong>Implementation Notes</strong></p><p>Allocates an array of <code>nk</code> <code>Int</code>s, and . For <span>$k &gt; \frac{n}{2}$</span>, generates a graph of degree <span>$n-k-1$</span> and returns its complement.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.random_tournament_digraph-Tuple{Integer}" href="#LightGraphs.SimpleGraphs.random_tournament_digraph-Tuple{Integer}"><code>LightGraphs.SimpleGraphs.random_tournament_digraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_tournament_digraph(n)</code></pre><p>Create a random directed <a href="https://en.wikipedia.org/wiki/Tournament_%28graph_theory%29">tournament graph</a> with <code>n</code> vertices.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{Integer,Array{T,1}}} where T&lt;:Real" href="#LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{Integer,Array{T,1}}} where T&lt;:Real"><code>LightGraphs.SimpleGraphs.static_fitness_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">static_fitness_model(m, fitness)</code></pre><p>Generate a random graph with <span>$|fitness|$</span> vertices and <code>m</code> edges, in which the probability of the existence of <span>$Edge_{ij}$</span> is proportional to <span>$fitness_i × fitness_j$</span>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|V| + |E| log |E|)$</span>.</p><p><strong>References</strong></p><ul><li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{S}, Tuple{Integer,Array{T,1},Array{S,1}}} where T&lt;:Real where S&lt;:Real" href="#LightGraphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{S}, Tuple{Integer,Array{T,1},Array{S,1}}} where T&lt;:Real where S&lt;:Real"><code>LightGraphs.SimpleGraphs.static_fitness_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">static_fitness_model(m, fitness_out, fitness_in)</code></pre><p>Generate a random graph with <span>$|fitness\_out + fitness\_in|$</span> vertices and <code>m</code> edges, in which the probability of the existence of <span>$Edge_{ij}$</span> is proportional with respect to <span>$i ∝ fitness\_out$</span> and <span>$j ∝ fitness\_in$</span>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|V| + |E| log |E|)$</span>.</p><p><strong>References</strong></p><ul><li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real,Float64}" href="#LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real,Float64}"><code>LightGraphs.SimpleGraphs.static_scale_free</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">static_scale_free(n, m, α_out, α_in)</code></pre><p>Generate a random graph with <code>n</code> vertices, <code>m</code> edges and expected power-law degree distribution with exponent <code>α_out</code> for outbound edges and <code>α_in</code> for inbound edges.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li><li><code>finite_size_correction=true</code>: determines whether to use the finite size correction</li></ul><p>proposed by Cho et al.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|V| + |E| log |E|)$</span>.</p><p><strong>References</strong></p><ul><li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li><li>Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.</li><li>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real}" href="#LightGraphs.SimpleGraphs.static_scale_free-Tuple{Integer,Integer,Real}"><code>LightGraphs.SimpleGraphs.static_scale_free</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">static_scale_free(n, m, α)</code></pre><p>Generate a random graph with <code>n</code> vertices, <code>m</code> edges and expected power-law degree distribution with exponent <code>α</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li><li><code>finite_size_correction=true</code>: determines whether to use the finite size correction</li></ul><p>proposed by Cho et al.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|V| + |E| log |E|)$</span>.</p><p><strong>References</strong></p><ul><li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li><li>Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.</li><li>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{Array{T,2},Array{U,1}}} where T&lt;:Real where U&lt;:Integer" href="#LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{Array{T,2},Array{U,1}}} where T&lt;:Real where U&lt;:Integer"><code>LightGraphs.SimpleGraphs.stochastic_block_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stochastic_block_model(c, n)</code></pre><p>Return a Graph generated according to the Stochastic Block Model (SBM).</p><p><code>c[a,b]</code> : Mean number of neighbors of a vertex in block <code>a</code> belonging to block <code>b</code>.            Only the upper triangular part is considered, since the lower traingular is            determined by <span>$c[b,a] = c[a,b] * \frac{n[a]}{n[b]}$</span>. <code>n[a]</code> : Number of vertices in block <code>a</code></p><p><strong>Optional Arguments</strong></p><ul><li><code>seed=-1</code>: set the RNG seed.</li></ul><p>For a dynamic version of the SBM see the <a href="#LightGraphs.SimpleGraphs.StochasticBlockModel"><code>StochasticBlockModel</code></a> type and related functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{T,T,Array{U,1}}} where T&lt;:Real where U&lt;:Integer" href="#LightGraphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{T,T,Array{U,1}}} where T&lt;:Real where U&lt;:Integer"><code>LightGraphs.SimpleGraphs.stochastic_block_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stochastic_block_model(cint, cext, n)</code></pre><p>Return a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with <span>$c_{a,a}=cint$</span>, and <span>$c_{a,b}=cext$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.watts_strogatz-Tuple{Integer,Integer,Real}" href="#LightGraphs.SimpleGraphs.watts_strogatz-Tuple{Integer,Integer,Real}"><code>LightGraphs.SimpleGraphs.watts_strogatz</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">watts_strogatz(n, k, β)</code></pre><p>Return a <a href="https://en.wikipedia.org/wiki/Watts_and_Strogatz_model">Watts-Strogatz</a> small model random graph with <code>n</code> vertices, each with degree <code>k</code>. Edges are randomized per the model based on probability <code>β</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>is_directed=false</code>: if true, return a directed graph.</li><li><code>seed=-1</code>: set the RNG seed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.BinaryTree-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.BinaryTree-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.BinaryTree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">BinaryTree(k::Integer)</code></pre><p>Create a <a href="https://en.wikipedia.org/wiki/Binary_tree">binary tree</a> of depth <code>k</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CliqueGraph-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CliqueGraph-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CliqueGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CliqueGraph(k, n)</code></pre><p>Create a graph consisting of <code>n</code> connected <code>k</code>-cliques.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CompleteBipartiteGraph-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CompleteBipartiteGraph-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CompleteBipartiteGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CompleteBipartiteGraph(n1, n2)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Complete_bipartite_graph">complete bipartite graph</a> with <code>n1 + n2</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CompleteDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CompleteDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CompleteDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CompleteDiGraph(n)</code></pre><p>Create a directed <a href="https://en.wikipedia.org/wiki/Complete_graph">complete graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CompleteGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CompleteGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CompleteGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CompleteGraph(n)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Complete_graph">complete graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CycleDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CycleDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CycleDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CycleDiGraph(n)</code></pre><p>Create a directed <a href="https://en.wikipedia.org/wiki/Cycle_graph">cycle graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.CycleGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.CycleGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.CycleGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CycleGraph(n)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Cycle_graph">cycle graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.DoubleBinaryTree-Tuple{Integer}" href="#LightGraphs.SimpleGraphs.DoubleBinaryTree-Tuple{Integer}"><code>LightGraphs.SimpleGraphs.DoubleBinaryTree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">BinaryTree(k::Integer)</code></pre><p>Create a double complete binary tree with <code>k</code> levels.</p><p><strong>References</strong></p><ul><li>Used as an example for spectral clustering by Guattery and Miller 1998.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.Grid-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.Grid-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.Grid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Grid(dims; periodic=false)</code></pre><p>Create a <span>$|dims|$</span>-dimensional cubic lattice, with length <code>dims[i]</code> in dimension <code>i</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>periodic=false</code>: If true, the resulting lattice will have periodic boundary</li></ul><p>condition in each dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.PathDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.PathDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.PathDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PathDiGraph(n)</code></pre><p>Creates a directed <a href="https://en.wikipedia.org/wiki/Path_graph">path graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.PathGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.PathGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.PathGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PathGraph(n)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Path_graph">path graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.RoachGraph-Tuple{Integer}" href="#LightGraphs.SimpleGraphs.RoachGraph-Tuple{Integer}"><code>LightGraphs.SimpleGraphs.RoachGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">RoachGraph(k)</code></pre><p>Create a Roach Graph of size <code>k</code>.</p><p><strong>References</strong></p><ul><li>Guattery and Miller 1998</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.StarDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.StarDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.StarDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">StarDiGraph(n)</code></pre><p>Create a directed <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.StarGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.StarGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.StarGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">StarGraph(n)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.WheelDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.WheelDiGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.WheelDiGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">WheelDiGraph(n)</code></pre><p>Create a directed <a href="https://en.wikipedia.org/wiki/Wheel_graph">wheel graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.WheelGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer" href="#LightGraphs.SimpleGraphs.WheelGraph-Union{Tuple{T}, Tuple{T}} where T&lt;:Integer"><code>LightGraphs.SimpleGraphs.WheelGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">WheelGraph(n)</code></pre><p>Create an undirected <a href="https://en.wikipedia.org/wiki/Wheel_graph">wheel graph</a> with <code>n</code> vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.smallgraph-Tuple{Symbol}" href="#LightGraphs.SimpleGraphs.smallgraph-Tuple{Symbol}"><code>LightGraphs.SimpleGraphs.smallgraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">smallgraph(s)
smallgraph(s)</code></pre><p>Create a small graph of type <code>s</code>. Admissible values for <code>s</code> are:</p><table><tr><th><code>s</code></th><th>graph type</th></tr><tr><td>:bull</td><td>A <a href="https://en.wikipedia.org/wiki/Bull_graph">bull graph</a>.</td></tr><tr><td>:chvatal</td><td>A <a href="https://en.wikipedia.org/wiki/Chvátal_graph">Chvátal graph</a>.</td></tr><tr><td>:cubical</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic cubical graph</a>.</td></tr><tr><td>:desargues</td><td>A <a href="https://en.wikipedia.org/wiki/Desargues_graph">Desarguesgraph</a>.</td></tr><tr><td>:diamond</td><td>A <a href="http://en.wikipedia.org/wiki/Diamond_graph">diamond graph</a>.</td></tr><tr><td>:dodecahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic dodecahedral  graph</a>.</td></tr><tr><td>:frucht</td><td>A <a href="https://en.wikipedia.org/wiki/Frucht_graph">Frucht graph</a>.</td></tr><tr><td>:heawood</td><td>A <a href="https://en.wikipedia.org/wiki/Heawood_graph">Heawood graph</a>.</td></tr><tr><td>:house</td><td>A graph mimicing the classic outline of a house.</td></tr><tr><td>:housex</td><td>A house graph, with two edges crossing the bottom square.</td></tr><tr><td>:icosahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic icosahedral   graph</a>.</td></tr><tr><td>:krackhardtkite</td><td>A <a href="http://mathworld.wolfram.com/KrackhardtKite.html">Krackhardt-Kite social network  graph</a>.</td></tr><tr><td>:moebiuskantor</td><td>A <a href="http://en.wikipedia.org/wiki/Möbius–Kantor_graph">Möbius-Kantor graph</a>.</td></tr><tr><td>:octahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic octahedral graph</a>.</td></tr><tr><td>:pappus</td><td>A <a href="http://en.wikipedia.org/wiki/Pappus_graph">Pappus graph</a>.</td></tr><tr><td>:petersen</td><td>A <a href="http://en.wikipedia.org/wiki/Petersen_graph">Petersen graph</a>.</td></tr><tr><td>:sedgewickmaze</td><td>A simple maze graph used in Sedgewick&#39;s <em>Algorithms in C++: Graph  Algorithms (3rd ed.)</em></td></tr><tr><td>:tetrahedral</td><td>A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic tetrahedral  graph</a>.</td></tr><tr><td>:truncatedcube</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_cube">truncated cube graph</a>.</td></tr><tr><td>:truncatedtetrahedron</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron  graph</a>.</td></tr><tr><td>:truncatedtetrahedron_dir</td><td>A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron digraph</a>.</td></tr><tr><td>:tutte</td><td>A <a href="https://en.wikipedia.org/wiki/Tutte_graph">Tutte graph</a>.</td></tr></table></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Array{T,2} where T}" href="#LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Array{T,2} where T}"><code>LightGraphs.SimpleGraphs.euclidean_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">euclidean_graph(points)</code></pre><p>Given the <code>d×N</code> matrix <code>points</code> build an Euclidean graph of <code>N</code> vertices and return a graph and Dict containing the distance on each edge.</p><p><strong>Optional Arguments</strong></p><ul><li><code>L=1</code>: used to bound the <code>d</code> dimensional box from which points are selected.</li><li><code>p=2</code></li><li><code>bc=:open</code></li></ul><p><strong>Implementation Notes</strong></p><p>Defining the <code>d</code>-dimensional vectors <code>x[i] = points[:,i]</code>, an edge between vertices <code>i</code> and <code>j</code> is inserted if <code>norm(x[i]-x[j], p) &lt; cutoff</code>. In case of negative <code>cutoff</code> instead every edge is inserted. For <code>p=2</code> we have the standard Euclidean distance. Set <code>bc=:periodic</code> to impose periodic boundary conditions in the box <span>$[0,L]^d$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Int64,Int64}" href="#LightGraphs.SimpleGraphs.euclidean_graph-Tuple{Int64,Int64}"><code>LightGraphs.SimpleGraphs.euclidean_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)</code></pre><p>Generate <code>N</code> uniformly distributed points in the box <span>$[0,L]^{d}$</span> and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points&#39; positions.</p></div></div></section><footer><hr/><a class="previous" href="../basicproperties/"><span class="direction">Previous</span><span class="title">Accessing Properties</span></a><a class="next" href="../persistence/"><span class="direction">Next</span><span class="title">Reading / Writing Graphs</span></a></footer></article></body></html>
