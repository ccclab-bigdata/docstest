<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Yao.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.@bit_str" href="#Yao.Registers.@bit_str"><code>Yao.Registers.@bit_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@bit_str -&gt; QuBitStr</code></pre><p>Construct a bit string. such as <code>bit&quot;0000&quot;</code>. The bit strings also supports string concat. Just use it like normal strings.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.ConstGateTools.@const_gate" href="#Yao.Blocks.ConstGateTools.@const_gate"><code>Yao.Blocks.ConstGateTools.@const_gate</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@const_gate NAME = MAT_EXPR
@const_gate NAME::Type = MAT_EXPR
@const_Gate NAME::Type</code></pre><p>This macro simplify the definition of a constant gate. It will automatically bind the matrix form to a constant which will reduce memory allocation in the runtime.</p><pre><code class="language-julia">@const_gate X = ComplexF64[0 1;1 0]</code></pre><p>or</p><pre><code class="language-julia">@const_gate X::ComplexF64 = [0 1;1 0]</code></pre><p>You can bind new element types by simply re-declare with a type annotation.</p><pre><code class="language-julia">@const_gate X::ComplexF32</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.@fn" href="#Yao.Interfaces.@fn"><code>Yao.Interfaces.@fn</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">macro fn([name,] f)</code></pre><p>Define a in-place function on a register inside circuits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.AbstractRegister" href="#Yao.Registers.AbstractRegister"><code>Yao.Registers.AbstractRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractRegister{B, T}</code></pre><p>abstract type that registers will subtype from. <code>B</code> is the batch size, <code>T</code> is the data type.</p><p><strong>Required Properties</strong></p><table><tr><th>Property</th><th>Description</th><th>default</th></tr><tr><td><code>nqubits(reg)</code></td><td>get the total number of qubits.</td><td></td></tr><tr><td><code>nactive(reg)</code></td><td>get the number of active qubits.</td><td></td></tr><tr><td><code>nremain(reg)</code></td><td>get the number of remained qubits.</td><td>nqubits - nactive</td></tr><tr><td><code>nbatch(reg)</code></td><td>get the number of batch.</td><td><code>B</code></td></tr><tr><td><code>state(reg)</code></td><td>get the state of this register. It always return the matrix stored inside.</td><td></td></tr><tr><td><code>statevec(reg)</code></td><td>get the raveled state of this register.                                  .</td><td></td></tr><tr><td><code>hypercubic(reg)</code></td><td>get the hypercubic form of this register.                                  .</td><td></td></tr><tr><td><code>eltype(reg)</code></td><td>get the element type stored by this register on classical memory. (the type Julia should use to represent amplitude)</td><td><code>T</code></td></tr><tr><td><code>copy(reg)</code></td><td>copy this register.</td><td></td></tr><tr><td><code>similar(reg)</code></td><td>construct a new register with similar configuration.</td><td></td></tr></table><p><strong>Required Methods</strong></p><p><strong>Multiply</strong></p><pre><code class="language-none">*(op, reg)</code></pre><p>define how operator <code>op</code> act on this register. This is quite useful when there is a special approach to apply an operator on this register. (e.g a register with no batch, or a register with a MPS state, etc.)</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>be careful, generally, operators can only be applied to a register, thus we should only overload this operation and do not overload <code>*(reg, op)</code>.</p></div></div><p><strong>Pack Address</strong></p><p>pack <code>addrs</code> together to the first k-dimensions.</p><p><strong>Example</strong></p><p>Given a register with dimension <code>[2, 3, 1, 5, 4]</code>, we pack <code>[5, 4]</code> to the first 2 dimensions. We will get <code>[5, 4, 2, 3, 1]</code>.</p><p><strong>Focus Address</strong></p><pre><code class="language-none">focus!(reg, range)</code></pre><p>merge address in <code>range</code> together as one dimension (the active space).</p><p><strong>Example</strong></p><p>Given a register with dimension <code>(2^4)x3</code> and address [1, 2, 3, 4], we focus address <code>[3, 4]</code>, will pack <code>[3, 4]</code> together and merge them as the active space. Then we will have a register with size <code>2^2x(2^2x3)</code>, and address <code>[3, 4, 1, 2]</code>.</p><p><strong>Initializers</strong></p><p>Initializers are functions that provide specific quantum states, e.g zero states, random states, GHZ states and etc.</p><pre><code class="language-none">register(::Type{RT}, raw, nbatch)</code></pre><p>an general initializer for input raw state array.</p><pre><code class="language-none">register(::Val{InitMethod}, ::Type{RT}, ::Type{T}, n, nbatch)</code></pre><p>init register type <code>RT</code> with <code>InitMethod</code> type (e.g <code>Val{:zero}</code>) with element type <code>T</code> and total number qubits <code>n</code> with <code>nbatch</code>. This will be auto-binded to some shortcuts like <code>zero_state</code>, <code>rand_state</code>.</p></div></div></section><pre><code class="language-none">Yao.Blocks</code></pre><pre><code class="language-none">Yao.Boost</code></pre><pre><code class="language-none">Yao.C</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.DefaultRegister" href="#Yao.Registers.DefaultRegister"><code>Yao.Registers.DefaultRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultRegister{B, T} &lt;: AbstractRegister{B, T}</code></pre><p>Default type for a quantum register. It contains a dense array that represents a batched quantum state with batch size <code>B</code> of type <code>T</code>.</p></div></div></section><pre><code class="language-none">Yao.DefaultType</code></pre><pre><code class="language-none">Yao.DensityMatrix</code></pre><pre><code class="language-none">Yao.ENVNAME</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.H" href="#Yao.Blocks.H"><code>Yao.Blocks.H</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">H</code></pre><p>The Hadamard gate acts on a single qubit. It maps the basis state <span>$|0\rangle$</span> to <span>$\frac{|0\rangle + |1\rangle}{\sqrt{2}}$</span> and <span>$|1\rangle$</span> to <span>$\frac{|0\rangle - |1\rangle}{\sqrt{2}}$</span>, which means that a measurement will have equal probabilities to become 1 or 0. It is representated by the Hadamard matrix:</p><div>\[H = \frac{1}{\sqrt{2}} \begin{pmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{pmatrix}\]</div></div></div></section><pre><code class="language-none">Yao.I2</code></pre><pre><code class="language-none">Yao.Interfaces</code></pre><pre><code class="language-none">Yao.Intrinsics</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.InvOrder" href="#Yao.Interfaces.InvOrder"><code>Yao.Interfaces.InvOrder</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">InvOrder</code></pre><p>Return a <a href="@ref"><code>FunctionBlock</code></a> of inversing the order.</p></div></div></section><pre><code class="language-none">Yao.MEASURE</code></pre><pre><code class="language-none">Yao.MEASURE_REMOVE</code></pre><pre><code class="language-none">Yao.PKGNAME</code></pre><pre><code class="language-none">Yao.Register</code></pre><pre><code class="language-none">Yao.Registers</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Reset" href="#Yao.Interfaces.Reset"><code>Yao.Interfaces.Reset</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Reset</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Rx" href="#Yao.Interfaces.Rx"><code>Yao.Interfaces.Rx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Rx([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, X}</code></pre><p>Returns a rotation X gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Ry" href="#Yao.Interfaces.Ry"><code>Yao.Interfaces.Ry</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Ry([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, Y}</code></pre><p>Returns a rotation Y gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Rz" href="#Yao.Interfaces.Rz"><code>Yao.Interfaces.Rz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Rz([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, Z}</code></pre><p>Returns a rotation Z gate.</p></div></div></section><pre><code class="language-none">Yao.Signal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.X" href="#Yao.Blocks.X"><code>Yao.Blocks.X</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">X</code></pre><p>The Pauli-X gate acts on a single qubit. It is the quantum equivalent of the NOT gate for classical computers (with respect to the standard basis <span>$|0\rangle$</span>, <span>$|1\rangle$</span>). It is represented by the Pauli X matrix:</p><div>\[X = \begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.Y" href="#Yao.Blocks.Y"><code>Yao.Blocks.Y</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Y</code></pre><p>The Pauli-Y gate acts on a single qubit. It equates to a rotation around the Y-axis of the Bloch sphere by <span>$\pi$</span> radians. It maps <span>$|0\rangle$</span> to <span>$i|1\rangle$</span> and <span>$|1\rangle$</span> to <span>$-i|0\rangle$</span>. It is represented by the Pauli Y matrix:</p><div>\[Y = \begin{pmatrix}
0 &amp; -i\\
i &amp; 0
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Yao" href="#Yao.Yao"><code>Yao.Yao</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Extensible Framework for Quantum Algorithm Design for Humans.</p><p>简单易用可扩展的量子算法设计框架。</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.Z" href="#Yao.Blocks.Z"><code>Yao.Blocks.Z</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Z</code></pre><p>The Pauli-Z gate acts on a single qubit. It equates to a rotation around the Z-axis of the Bloch sphere by <span>$\pi$</span> radians. Thus, it is a special case of a phase shift gate (see <code>shift</code>) with <span>$\theta = \pi$</span>. It leaves the basis state <span>$|0\rangle$</span> unchanged and maps <span>$|1\rangle$</span> to <span>$-|1\rangle$</span>. Due to this nature, it is sometimes called phase-flip. It is represented by the Pauli Z matrix:</p><div>\[Z = \begin{pmatrix}
1 &amp; 0\\
0 &amp; -1
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.addbit" href="#Yao.Interfaces.addbit"><code>Yao.Interfaces.addbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addbit(n::Int) -&gt; FunctionBlock{:AddBit}</code></pre><p>Return a <a href="@ref"><code>FunctionBlock</code></a> of adding n bits.</p></div></div></section><pre><code class="language-none">Yao.addbit!</code></pre><pre><code class="language-none">Yao.adjoint</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.apply!" href="#Yao.Blocks.apply!"><code>Yao.Blocks.apply!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">apply!(reg, block, [signal])</code></pre><p>apply a <code>block</code> to a register <code>reg</code> with or without a cache signal.</p></div></div></section><pre><code class="language-none">Yao.asindex</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Intrinsics.basis" href="#Yao.Intrinsics.basis"><code>Yao.Intrinsics.basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis(num_bit::Int) -&gt; UnitRange{Int}
basis(state::AbstractArray) -&gt; UnitRange{Int}</code></pre><p>Returns the UnitRange for basis in Hilbert Space of num_bit qubits. If an array is supplied, it will return a basis having the same size with the first diemension of array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.blocks" href="#Yao.Blocks.blocks"><code>Yao.Blocks.blocks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">blocks(composite_block)</code></pre><p>get an iterator that iterate through all sub-blocks.</p></div></div></section><pre><code class="language-none">Yao.cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.chain" href="#Yao.Interfaces.chain"><code>Yao.Interfaces.chain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chain([T], n::Int) -&gt; ChainBlock
chain([n], blocks) -&gt; ChainBlock</code></pre><p>Returns a <code>ChainBlock</code>. This factory method can be called lazily if you missed the total number of qubits.</p><p>This chains several blocks with the same size together.</p></div></div></section><pre><code class="language-none">Yao.clearall!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.concentrate" href="#Yao.Interfaces.concentrate"><code>Yao.Interfaces.concentrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">concentrate(nbit::Int, block::AbstractBlock, addrs) -&gt; Concentrator{nbit}</code></pre><p>concentrate blocks on serveral addrs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.control" href="#Yao.Interfaces.control"><code>Yao.Interfaces.control</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">control([total], controls, target) -&gt; ControlBlock</code></pre><p>Constructs a <a href="@ref"><code>ControlBlock</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.datatype" href="#Yao.Blocks.datatype"><code>Yao.Blocks.datatype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">datatype(x) -&gt; DataType</code></pre><p>Returns the data type of x.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.density_matrix" href="#Yao.Registers.density_matrix"><code>Yao.Registers.density_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">density_matrix(register)</code></pre><p>Returns the density matrix of this register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.dispatch!" href="#Yao.Blocks.dispatch!"><code>Yao.Blocks.dispatch!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dispatch!(block, params)
dispatch!(block, params...)</code></pre><p>dispatch parameters to this block.</p></div></div></section><pre><code class="language-none">Yao.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.extend!" href="#Yao.Registers.extend!"><code>Yao.Registers.extend!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extend!(r::DefaultRegister, n::Int) -&gt; DefaultRegister
extend!(n::Int) -&gt; Function</code></pre><p>extend the register by n bits in state |0&gt;. i.e. |psi&gt; -&gt; |000&gt; ⊗ |psi&gt;, extended bits have higher indices. If only an integer is provided, then perform lazy evaluation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.fidelity" href="#Yao.Registers.fidelity"><code>Yao.Registers.fidelity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fidelity(reg1::DefaultRegister, reg2::DefaultRegister) -&gt; Vector</code></pre></div></div></section><pre><code class="language-none">Yao.focus</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.focus!" href="#Yao.Registers.focus!"><code>Yao.Registers.focus!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">focus!(reg::DefaultRegister, bits::Ints) -&gt; DefaultRegister
focus!(locs::Int...) -&gt; Function</code></pre><p>Focus register on specified active bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Intrinsics.hypercubic" href="#Yao.Intrinsics.hypercubic"><code>Yao.Intrinsics.hypercubic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypercubic(r::AbstractRegister) -&gt; AbstractArray</code></pre><p>Return the hypercubic form (high dimensional tensor) of this register, only active qubits are considered.</p></div></div></section><pre><code class="language-none">Yao.include</code></pre><pre><code class="language-none">Yao.invorder</code></pre><pre><code class="language-none">Yao.invorder!</code></pre><pre><code class="language-none">Yao.iscacheable</code></pre><pre><code class="language-none">Yao.iscached</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.isnormalized" href="#Yao.Registers.isnormalized"><code>Yao.Registers.isnormalized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnormalized(reg::DefaultRegister) -&gt; Bool</code></pre><p>Return true if a register is normalized else false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.mat" href="#Yao.Blocks.mat"><code>Yao.Blocks.mat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mat(block) -&gt; Matrix</code></pre><p>Returns the matrix form of this block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.matrixgate" href="#Yao.Interfaces.matrixgate"><code>Yao.Interfaces.matrixgate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">matrixgate(matrix::AbstractMatrix) -&gt; GeneralMatrixGate
matrixgate(matrix::MatrixBlock) -&gt; GeneralMatrixGate</code></pre><p>Construct a general matrix gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure" href="#Yao.Registers.measure"><code>Yao.Registers.measure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">measure(register, [n=1]) -&gt; Vector</code></pre><p>measure active qubits for <code>n</code> times.</p></div></div></section><pre><code class="language-none">Yao.measure!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure_remove!" href="#Yao.Registers.measure_remove!"><code>Yao.Registers.measure_remove!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">measure_remove!(register)</code></pre><p>measure the active qubits of this register and remove them.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.nactive" href="#Yao.nactive"><code>Yao.nactive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nactive(x) -&gt; Int</code></pre><p>Returns number of active qubits</p></div></div></section><pre><code class="language-none">Yao.nbatch</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.nparameters" href="#Yao.Blocks.nparameters"><code>Yao.Blocks.nparameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nparameters(x) -&gt; Integer</code></pre><p>Returns the number of parameters of <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.nqubits" href="#Yao.nqubits"><code>Yao.nqubits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nqubits(m::AbstractRegister) -&gt; Int</code></pre><p>Returns number of qubits in a register,</p><pre><code class="language-none">nqubits(m::AbstractBlock) -&gt; Int</code></pre><p>Returns number of qubits applied for a block,</p><pre><code class="language-none">nqubits(m::AbstractArray) -&gt; Int</code></pre><p>Returns size of the first dimension of an array, in 2^nqubits.</p></div></div></section><pre><code class="language-none">Yao.nremain</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.parameters" href="#Yao.Blocks.parameters"><code>Yao.Blocks.parameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parameters(block) -&gt; Vector</code></pre><p>Returns a list of all parameters in block.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.phase" href="#Yao.Interfaces.phase"><code>Yao.Interfaces.phase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phase([type=Yao.DefaultType], theta) -&gt; PhaseGate{:global}</code></pre><p>Returns a global phase gate.</p></div></div></section><pre><code class="language-none">Yao.probs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.product_state" href="#Yao.Registers.product_state"><code>Yao.Registers.product_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">product_state(::Type{T}, n::Int, config::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>a product state on given configuration <code>config</code>, e.g. product_state(ComplexF64, 5, 0) will give a zero state on a 5 qubit register.</p></div></div></section><pre><code class="language-none">Yao.pull</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.put" href="#Yao.Interfaces.put"><code>Yao.Interfaces.put</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">put([total::Int, ]pa::Pair) -&gt; PutBlock{total}</code></pre><p>put a block at the specific position(s), can be lazy constructed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.rand_state" href="#Yao.Registers.rand_state"><code>Yao.Registers.rand_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand_state(::Type{T}, n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>here, random complex numbers are generated using <code>randn(ComplexF64)</code>.</p></div></div></section><pre><code class="language-none">Yao.rank3</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.reflect" href="#Yao.Interfaces.reflect"><code>Yao.Interfaces.reflect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reflect(mirror::DefaultRegister{1}) -&gt; ReflectBlock
reflect(mirror::Vector) -&gt; ReflectBlock</code></pre><p>Return an ReflectBlock along with state vector mirror as the axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.register" href="#Yao.Registers.register"><code>Yao.Registers.register</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">register([type], bit_str, [nbatch=1]) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> by inputing a bit string, e.g</p><pre><code class="language-">using Yao
register(bit&quot;0000&quot;)</code></pre></div></div><div><div><pre><code class="language-none">register(raw) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> from a raw dense array (<code>Vector</code> or <code>Matrix</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.relax!" href="#Yao.Registers.relax!"><code>Yao.Registers.relax!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">relax!(reg::DefaultRegister; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(reg::DefaultRegister, bits::Ints; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(bits::Ints...; nbit::Int=-1) -&gt; Function</code></pre><p>Inverse transformation of focus, with nbit is the number of active bits of target register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.reorder" href="#Yao.reorder"><code>Yao.reorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reorder the lines of qubits.</p></div></div></section><pre><code class="language-none">Yao.reorder!</code></pre><pre><code class="language-none">Yao.reset!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.roll" href="#Yao.Interfaces.roll"><code>Yao.Interfaces.roll</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">roll([n::Int, ], blocks...,) -&gt; Roller{n}</code></pre><p>Construct a <a href="@ref"><code>Roller</code></a> block, which is a faster than <a href="@ref"><code>KronBlock</code></a> to calculate similar small blocks tile on the whole address.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.rollrepeat" href="#Yao.Interfaces.rollrepeat"><code>Yao.Interfaces.rollrepeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rollrepeat([n::Int,] block::MatrixBlock) -&gt; Roller{n}</code></pre><p>Construct a <a href="@ref"><code>Roller</code></a> block, which is a faster than <a href="@ref"><code>KronBlock</code></a> to calculate similar small blocks tile on the whole address.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.rot" href="#Yao.Interfaces.rot"><code>Yao.Interfaces.rot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rot([type=Yao.DefaultType], U, theta) -&gt; RotationGate{N, type, U}</code></pre><p>Returns an arbitrary rotation gate on U.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.select" href="#Yao.Registers.select"><code>Yao.Registers.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">select(reg::AbstractRegister, b::Integer) -&gt; AbstractRegister</code></pre><p>the non-inplace version of <a href="#Yao.Registers.select!"><code>select!</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.select!" href="#Yao.Registers.select!"><code>Yao.Registers.select!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">select!(reg::AbstractRegister, b::Integer) -&gt; AbstractRegister
select!(b::Integer) -&gt; Function</code></pre><p>select specific component of qubit, the inplace version, the currified version will return a Function.</p><p>e.g. <code>select!(reg, 0b110)</code> will select the subspace with (focused) configuration <code>110</code>. After selection, the focused qubit space is 0, so you may want call <code>relax!</code> manually.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.sequence" href="#Yao.Interfaces.sequence"><code>Yao.Interfaces.sequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a <code>Sequential</code> block. This factory method can be called lazily if you missed the total number of qubits.</p><p>This is the loose version of sequence, that does not support the <code>mat</code> related interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.shift" href="#Yao.Interfaces.shift"><code>Yao.Interfaces.shift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shift([type=Yao.DefaultType], theta) -&gt; PhaseGate{:shift}</code></pre><p>Returns a phase shift gate.</p></div></div></section><pre><code class="language-none">Yao.signal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.stack" href="#Yao.Registers.stack"><code>Yao.Registers.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stack(regs::DefaultRegister...) -&gt; DefaultRegister</code></pre><p>stack multiple registers into a batch.</p></div></div></section><pre><code class="language-none">Yao.state</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.statevec" href="#Yao.Registers.statevec"><code>Yao.Registers.statevec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">statevec(r::AbstractRegister) -&gt; AbstractArray</code></pre><p>Return the raveled state (vector) form of this register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.swap" href="#Yao.Interfaces.swap"><code>Yao.Interfaces.swap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">swap([n], [type], line1, line2) -&gt; Swap</code></pre><p>Returns a swap gate on <code>line1</code> and <code>line2</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.tracedist" href="#Yao.Registers.tracedist"><code>Yao.Registers.tracedist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracedist(reg1::DefaultRegister, reg2::DefaultRegister) -&gt; Vector
tracedist(reg1::DensityMatrix, reg2::DensityMatrix) -&gt; Vector</code></pre><p>trace distance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.uniform_state" href="#Yao.Registers.uniform_state"><code>Yao.Registers.uniform_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uniform_state(::Type{T}, n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>uniform state, the state after applying H gates on |0&gt; state.</p></div></div></section><pre><code class="language-none">Yao.update_cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.zero_state" href="#Yao.Registers.zero_state"><code>Yao.Registers.zero_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zero_state(::Type{T}, n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.ρ" href="#Yao.Registers.ρ"><code>Yao.Registers.ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ρ(register)</code></pre><p>Returns the density matrix of this register.</p></div></div></section><pre><code class="language-none">Yao.⊗</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.幺" href="#Yao.幺"><code>Yao.幺</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Extensible Framework for Quantum Algorithm Design for Humans.</p><p>简单易用可扩展的量子算法设计框架。</p><p>幺 means unitary in Chinese.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
