<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · Yao.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/man/interfaces/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/RegisterBasics/">Register Basics</a></li><li><a class="toctext" href="../../tutorial/BlockBasics/">Block Basics</a></li><li><a class="toctext" href="../../tutorial/Diff/">Automatic Differentiation</a></li><li><a class="toctext" href="../../tutorial/BinaryBasics/">Binary Basics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../../tutorial/Grover/">Grover Search and Quantum Inference</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../yao/">Yao</a></li><li class="current"><a class="toctext" href>Interfaces</a><ul class="internal"></ul></li><li><a class="toctext" href="../registers/">Registers</a></li><li><a class="toctext" href="../blocks/">Blocks System</a></li><li><a class="toctext" href="../intrinsics/">Intrinsics</a></li><li><a class="toctext" href="../boost/">Boost</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../dev/extending-blocks/">Extending Blocks</a></li><li><a class="toctext" href="../../dev/benchmark/">Benchmark with ProjectQ</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Interfaces</a></li></ul></nav><hr/><div id="topbar"><span>Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interfaces-1" href="#Interfaces-1">Interfaces</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.H" href="#Yao.Blocks.H"><code>Yao.Blocks.H</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">H</code></pre><p>The Hadamard gate acts on a single qubit. It maps the basis state <span>$|0\rangle$</span> to <span>$\frac{|0\rangle + |1\rangle}{\sqrt{2}}$</span> and <span>$|1\rangle$</span> to <span>$\frac{|0\rangle - |1\rangle}{\sqrt{2}}$</span>, which means that a measurement will have equal probabilities to become 1 or 0. It is representated by the Hadamard matrix:</p><div>\[H = \frac{1}{\sqrt{2}} \begin{pmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.X" href="#Yao.Blocks.X"><code>Yao.Blocks.X</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">X</code></pre><p>The Pauli-X gate acts on a single qubit. It is the quantum equivalent of the NOT gate for classical computers (with respect to the standard basis <span>$|0\rangle$</span>, <span>$|1\rangle$</span>). It is represented by the Pauli X matrix:</p><div>\[X = \begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.Y" href="#Yao.Blocks.Y"><code>Yao.Blocks.Y</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Y</code></pre><p>The Pauli-Y gate acts on a single qubit. It equates to a rotation around the Y-axis of the Bloch sphere by <span>$\pi$</span> radians. It maps <span>$|0\rangle$</span> to <span>$i|1\rangle$</span> and <span>$|1\rangle$</span> to <span>$-i|0\rangle$</span>. It is represented by the Pauli Y matrix:</p><div>\[Y = \begin{pmatrix}
0 &amp; -i\\
i &amp; 0
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.Z" href="#Yao.Blocks.Z"><code>Yao.Blocks.Z</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Z</code></pre><p>The Pauli-Z gate acts on a single qubit. It equates to a rotation around the Z-axis of the Bloch sphere by <span>$\pi$</span> radians. Thus, it is a special case of a phase shift gate (see <code>shift</code>) with <span>$\theta = \pi$</span>. It leaves the basis state <span>$|0\rangle$</span> unchanged and maps <span>$|1\rangle$</span> to <span>$-|1\rangle$</span>. Due to this nature, it is sometimes called phase-flip. It is represented by the Pauli Z matrix:</p><div>\[Z = \begin{pmatrix}
1 &amp; 0\\
0 &amp; -1
\end{pmatrix}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.InvOrder" href="#Yao.Interfaces.InvOrder"><code>Yao.Interfaces.InvOrder</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">InvOrder</code></pre><p>Return a <a href="../blocks/#Yao.Blocks.FunctionBlock"><code>FunctionBlock</code></a> of inversing the order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Reset" href="#Yao.Interfaces.Reset"><code>Yao.Interfaces.Reset</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Reset</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.StatFunctional" href="#Yao.Interfaces.StatFunctional"><code>Yao.Interfaces.StatFunctional</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StatFunctional{N, AT}
StatFunctional(array::AT&lt;:Array) -&gt; StatFunctional{N, &lt;:Array}
StatFunctional{N}(func::AT&lt;:Function) -&gt; StatFunctional{N, &lt;:Function}</code></pre><p>statistic functional, i.e.     * if <code>AT</code> is an array, A[i,j,k...], it is defined on finite Hilbert space, which is <code>∫A[i,j,k...]p[i]p[j]p[k]...</code>     * if <code>AT</code> is a function, F(xᵢ,xⱼ,xₖ...), this functional is <code>1/C(r,n)... ∑ᵢⱼₖ...F(xᵢ,xⱼ,xₖ...)</code>, see U-statistics for detail.</p><p>References:     U-statistics, http://personal.psu.edu/drh20/asymp/fall2006/lectures/ANGELchpt10.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.@fn" href="#Yao.Interfaces.@fn"><code>Yao.Interfaces.@fn</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">macro fn([name,] f)</code></pre><p>Define a in-place function on a register inside circuits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Rx" href="#Yao.Interfaces.Rx"><code>Yao.Interfaces.Rx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Rx([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, X}</code></pre><p>Returns a rotation X gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Ry" href="#Yao.Interfaces.Ry"><code>Yao.Interfaces.Ry</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Ry([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, Y}</code></pre><p>Returns a rotation Y gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.Rz" href="#Yao.Interfaces.Rz"><code>Yao.Interfaces.Rz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Rz([type=Yao.DefaultType], theta) -&gt; RotationGate{1, type, Z}</code></pre><p>Returns a rotation Z gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.add" href="#Yao.Interfaces.add"><code>Yao.Interfaces.add</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add([T], n::Int) -&gt; AddBlock
add([n], blocks) -&gt; AddBlock
add(blocks...) -&gt; AddBlock</code></pre><p>Returns a <code>AddBlock</code>. This factory method can be called lazily if you missed the total number of qubits.</p><p>This adds several blocks with the same size together.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.addbit-Tuple{Int64}" href="#Yao.Interfaces.addbit-Tuple{Int64}"><code>Yao.Interfaces.addbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addbit(n::Int) -&gt; FunctionBlock{:AddBit}</code></pre><p>Return a <a href="../blocks/#Yao.Blocks.FunctionBlock"><code>FunctionBlock</code></a> of adding n bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.autodiff" href="#Yao.Interfaces.autodiff"><code>Yao.Interfaces.autodiff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">autodiff(mode::Symbol, block::AbstractBlock) -&gt; AbstractBlock
autodiff(mode::Symbol) -&gt; Function</code></pre><p>automatically mark differentiable items in a block tree as differentiable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.chain" href="#Yao.Interfaces.chain"><code>Yao.Interfaces.chain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chain([T], n::Int) -&gt; ChainBlock
chain([n], blocks) -&gt; ChainBlock
chain(blocks...) -&gt; ChainBlock</code></pre><p>Returns a <code>ChainBlock</code>. This factory method can be called lazily if you missed the total number of qubits.</p><p>This chains several blocks with the same size together.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.concentrate-Tuple{Int64,AbstractBlock,Any}" href="#Yao.Interfaces.concentrate-Tuple{Int64,AbstractBlock,Any}"><code>Yao.Interfaces.concentrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">concentrate(nbit::Int, block::AbstractBlock, addrs) -&gt; Concentrator{nbit}</code></pre><p>concentrate blocks on serveral addrs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.control" href="#Yao.Interfaces.control"><code>Yao.Interfaces.control</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">control([total], controls, target) -&gt; ControlBlock</code></pre><p>Constructs a <a href="../blocks/#Yao.Blocks.ControlBlock"><code>ControlBlock</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.matrixgate-Tuple{AbstractArray{T,2} where T}" href="#Yao.Interfaces.matrixgate-Tuple{AbstractArray{T,2} where T}"><code>Yao.Interfaces.matrixgate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">matrixgate(matrix::AbstractMatrix) -&gt; GeneralMatrixGate
matrixgate(matrix::MatrixBlock) -&gt; GeneralMatrixGate</code></pre><p>Construct a general matrix gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.numdiff-Tuple{Any,AbstractDiff}" href="#Yao.Interfaces.numdiff-Tuple{Any,AbstractDiff}"><code>Yao.Interfaces.numdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">numdiff(loss, diffblock::AbstractDiff; δ::Real=1e-2)</code></pre><p>Numeric differentiation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.opdiff-Tuple{Any,AbstractDiff,MatrixBlock}" href="#Yao.Interfaces.opdiff-Tuple{Any,AbstractDiff,MatrixBlock}"><code>Yao.Interfaces.opdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">opdiff(psifunc, diffblock::AbstractDiff, op::MatrixBlock)</code></pre><p>Operator differentiation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.paulistring" href="#Yao.Interfaces.paulistring"><code>Yao.Interfaces.paulistring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">paulistring([n], blocks::PauliGate...) -&gt; PauliString
paulistring([n], blocks::Pair{Int, PauliGate}...) -&gt; PauliString</code></pre><p>Returns a <code>PauliString</code>. This factory method can be called lazily if you missed the total number of qubits.</p><p>This krons several pauli gates, either dict (more flexible) like input and chain like input are allowed. i.e. paulistring(3, X, Y, Z) is equivalent to paulistring(3, 1=&gt;X, 2=&gt;Y, 3=&gt;Z)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.phase" href="#Yao.Interfaces.phase"><code>Yao.Interfaces.phase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phase([type=Yao.DefaultType], theta) -&gt; PhaseGate{:global}</code></pre><p>Returns a global phase gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.put-Union{Tuple{M}, Tuple{Int64,Pair{Tuple{Vararg{Int64,M}},#s2205} where #s2205&lt;:AbstractBlock}} where M" href="#Yao.Interfaces.put-Union{Tuple{M}, Tuple{Int64,Pair{Tuple{Vararg{Int64,M}},#s2205} where #s2205&lt;:AbstractBlock}} where M"><code>Yao.Interfaces.put</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">put([total::Int, ]pa::Pair) -&gt; PutBlock{total}</code></pre><p>put a block at the specific position(s), can be lazy constructed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.reflect" href="#Yao.Interfaces.reflect"><code>Yao.Interfaces.reflect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reflect(mirror::DefaultRegister{1}) -&gt; ReflectBlock
reflect(mirror::Vector) -&gt; ReflectBlock</code></pre><p>Return an ReflectBlock along with state vector mirror as the axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.roll" href="#Yao.Interfaces.roll"><code>Yao.Interfaces.roll</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">roll([n::Int, ], blocks...,) -&gt; Roller{n}</code></pre><p>Construct a <a href="../blocks/#Yao.Blocks.Roller"><code>Roller</code></a> block, which is a faster than <a href="../blocks/#Yao.Blocks.KronBlock"><code>KronBlock</code></a> to calculate similar small blocks tile on the whole address.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.rollrepeat" href="#Yao.Interfaces.rollrepeat"><code>Yao.Interfaces.rollrepeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rollrepeat([n::Int,] block::MatrixBlock) -&gt; Roller{n}</code></pre><p>Construct a <a href="../blocks/#Yao.Blocks.Roller"><code>Roller</code></a> block, which is a faster than <a href="../blocks/#Yao.Blocks.KronBlock"><code>KronBlock</code></a> to calculate similar small blocks tile on the whole address.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.rot" href="#Yao.Interfaces.rot"><code>Yao.Interfaces.rot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rot([type=Yao.DefaultType], U, theta) -&gt; RotationGate{N, type, U}</code></pre><p>Returns an arbitrary rotation gate on U.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.sequence" href="#Yao.Interfaces.sequence"><code>Yao.Interfaces.sequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a <code>Sequential</code> block. This factory method can be called lazily if you missed the total number of qubits.</p><p>This is the loose version of sequence, that does not support the <code>mat</code> related interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.shift" href="#Yao.Interfaces.shift"><code>Yao.Interfaces.shift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shift([type=Yao.DefaultType], theta) -&gt; PhaseGate{:shift}</code></pre><p>Returns a phase shift gate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.statdiff-Tuple{Any,AbstractDiff,StatFunctional{2,AT} where AT}" href="#Yao.Interfaces.statdiff-Tuple{Any,AbstractDiff,StatFunctional{2,AT} where AT}"><code>Yao.Interfaces.statdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">statdiff(probfunc, diffblock::AbstractDiff, stat::StatFunctional{&lt;:Any, &lt;:AbstractArray}; initial::AbstractVector=probfunc())
statdiff(samplefunc, diffblock::AbstractDiff, stat::StatFunctional{&lt;:Any, &lt;:Function}; initial::AbstractVector=samplefunc())</code></pre><p>Differentiation for statistic functionals.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.swap" href="#Yao.Interfaces.swap"><code>Yao.Interfaces.swap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">swap([n], [type], line1, line2) -&gt; Swap</code></pre><p>Returns a swap gate on <code>line1</code> and <code>line2</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Interfaces.timeevolve" href="#Yao.Interfaces.timeevolve"><code>Yao.Interfaces.timeevolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timeevolve({block::MatrixBlock}, t::Real; tol::Real=1e-7) -&gt; TimeEvolution</code></pre><p>Make a time machine! If block is not provided, it will become lazy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.XGate" href="#Yao.Blocks.XGate"><code>Yao.Blocks.XGate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">XGate{T} &lt;: ConstantGate{1, T}</code></pre><p>The block type for Pauli-X gate. See docs for <code>X</code> for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.YGate" href="#Yao.Blocks.YGate"><code>Yao.Blocks.YGate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">YGate{T} &lt;: ConstantGate{1, T}</code></pre><p>The block type for Pauli-Y gate. See docs for <code>Y</code> for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Blocks.ZGate" href="#Yao.Blocks.ZGate"><code>Yao.Blocks.ZGate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ZGate{T} &lt;: ConstantGate{1, T}</code></pre><p>The block type for Pauli-Z gate. See docs for <code>Z</code> for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kron-Tuple{Int64,Vararg{Pair{Int64,#s2205} where #s2205&lt;:MatrixBlock,N} where N}" href="#Base.kron-Tuple{Int64,Vararg{Pair{Int64,#s2205} where #s2205&lt;:MatrixBlock,N} where N}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kron([total::Int, ]block0::Pair, blocks::Union{MatrixBlock, Pair}...,) -&gt; KronBlock{total}</code></pre><p>create a <a href="../blocks/#Yao.Blocks.KronBlock"><code>KronBlock</code></a> with a list of blocks or tuple of heads and blocks. If total is not provided, return a lazy constructor.</p><p><strong>Example</strong></p><pre><code class="language-">kron(4, 1=&gt;X, 3=&gt;Z, 4=&gt;Y)</code></pre><p>This will automatically generate a block list looks like</p><pre><code class="language-none">1 -- [X] --
2 ---------
3 -- [Z] --
4 -- [Y] --</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat-Tuple{Int64,MatrixBlock,Any}" href="#Base.repeat-Tuple{Int64,MatrixBlock,Any}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">repeat([n::Int,] x::MatrixBlock, [addrs]) -&gt; RepeatedBlock{n}</code></pre><p>Construct a <a href="../blocks/#Yao.Blocks.RepeatedBlock"><code>RepeatedBlock</code></a>, if n (the number of qubits) not supplied, using lazy evaluation. If addrs not supplied, blocks will fill the qubit space.</p></div></div></section><footer><hr/><a class="previous" href="../yao/"><span class="direction">Previous</span><span class="title">Yao</span></a><a class="next" href="../registers/"><span class="direction">Next</span><span class="title">Registers</span></a></footer></article></body></html>
