<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings Â· GDAL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GDAL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">GDAL.ALTER_ALL_FLAG</code></pre><pre><code class="language-none">GDAL.ALTER_DEFAULT_FLAG</code></pre><pre><code class="language-none">GDAL.ALTER_NAME_FLAG</code></pre><pre><code class="language-none">GDAL.ALTER_NULLABLE_FLAG</code></pre><pre><code class="language-none">GDAL.ALTER_TYPE_FLAG</code></pre><pre><code class="language-none">GDAL.ALTER_WIDTH_PRECISION_FLAG</code></pre><pre><code class="language-none">GDAL.C</code></pre><pre><code class="language-none">GDAL.CE_Debug</code></pre><pre><code class="language-none">GDAL.CE_Failure</code></pre><pre><code class="language-none">GDAL.CE_Fatal</code></pre><pre><code class="language-none">GDAL.CE_None</code></pre><pre><code class="language-none">GDAL.CE_Warning</code></pre><pre><code class="language-none">GDAL.CPLE_AWSAccessDenied</code></pre><pre><code class="language-none">GDAL.CPLE_AWSBucketNotFound</code></pre><pre><code class="language-none">GDAL.CPLE_AWSInvalidCredentials</code></pre><pre><code class="language-none">GDAL.CPLE_AWSObjectNotFound</code></pre><pre><code class="language-none">GDAL.CPLE_AWSSignatureDoesNotMatch</code></pre><pre><code class="language-none">GDAL.CPLE_AppDefined</code></pre><pre><code class="language-none">GDAL.CPLE_AssertionFailed</code></pre><pre><code class="language-none">GDAL.CPLE_FileIO</code></pre><pre><code class="language-none">GDAL.CPLE_HttpResponse</code></pre><pre><code class="language-none">GDAL.CPLE_IllegalArg</code></pre><pre><code class="language-none">GDAL.CPLE_NoWriteAccess</code></pre><pre><code class="language-none">GDAL.CPLE_None</code></pre><pre><code class="language-none">GDAL.CPLE_NotSupported</code></pre><pre><code class="language-none">GDAL.CPLE_ObjectNull</code></pre><pre><code class="language-none">GDAL.CPLE_OpenFailed</code></pre><pre><code class="language-none">GDAL.CPLE_OutOfMemory</code></pre><pre><code class="language-none">GDAL.CPLE_UserInterrupt</code></pre><pre><code class="language-none">GDAL.CPLErr</code></pre><pre><code class="language-none">GDAL.CPLErrorHandler</code></pre><pre><code class="language-none">GDAL.CPLErrorNum</code></pre><pre><code class="language-none">GDAL.CPLFileFinder</code></pre><pre><code class="language-none">GDAL.CPLSharedFileInfo</code></pre><pre><code class="language-none">GDAL.CPLVirtualMem</code></pre><pre><code class="language-none">GDAL.CPLVirtualMemAccessMode</code></pre><pre><code class="language-none">GDAL.CPLVirtualMemCachePageCbk</code></pre><pre><code class="language-none">GDAL.CPLVirtualMemFreeUserData</code></pre><pre><code class="language-none">GDAL.CPLVirtualMemUnCachePageCbk</code></pre><pre><code class="language-none">GDAL.CPLXMLNode</code></pre><pre><code class="language-none">GDAL.CPLXMLNodeType</code></pre><pre><code class="language-none">GDAL.CPL_FRMT_GB_WITHOUT_PREFIX</code></pre><pre><code class="language-none">GDAL.CPL_HAS_GINT64</code></pre><pre><code class="language-none">GDAL.CPL_IS_LSB</code></pre><pre><code class="language-none">GDAL.CXT_Attribute</code></pre><pre><code class="language-none">GDAL.CXT_Comment</code></pre><pre><code class="language-none">GDAL.CXT_Element</code></pre><pre><code class="language-none">GDAL.CXT_Literal</code></pre><pre><code class="language-none">GDAL.CXT_Text</code></pre><pre><code class="language-none">GDAL.FALSE</code></pre><pre><code class="language-none">GDAL.FILE</code></pre><pre><code class="language-none">GDAL.FilterFunc4ValuesType</code></pre><pre><code class="language-none">GDAL.FilterFuncType</code></pre><pre><code class="language-none">GDAL.GARIO_COMPLETE</code></pre><pre><code class="language-none">GDAL.GARIO_ERROR</code></pre><pre><code class="language-none">GDAL.GARIO_PENDING</code></pre><pre><code class="language-none">GDAL.GARIO_TypeCount</code></pre><pre><code class="language-none">GDAL.GARIO_UPDATE</code></pre><pre><code class="language-none">GDAL.GA_ReadOnly</code></pre><pre><code class="language-none">GDAL.GA_Update</code></pre><pre><code class="language-none">GDAL.GBool</code></pre><pre><code class="language-none">GDAL.GByte</code></pre><pre><code class="language-none">GDAL.GCI_AlphaBand</code></pre><pre><code class="language-none">GDAL.GCI_BlackBand</code></pre><pre><code class="language-none">GDAL.GCI_BlueBand</code></pre><pre><code class="language-none">GDAL.GCI_CyanBand</code></pre><pre><code class="language-none">GDAL.GCI_GrayIndex</code></pre><pre><code class="language-none">GDAL.GCI_GreenBand</code></pre><pre><code class="language-none">GDAL.GCI_HueBand</code></pre><pre><code class="language-none">GDAL.GCI_LightnessBand</code></pre><pre><code class="language-none">GDAL.GCI_MagentaBand</code></pre><pre><code class="language-none">GDAL.GCI_Max</code></pre><pre><code class="language-none">GDAL.GCI_PaletteIndex</code></pre><pre><code class="language-none">GDAL.GCI_RedBand</code></pre><pre><code class="language-none">GDAL.GCI_SaturationBand</code></pre><pre><code class="language-none">GDAL.GCI_Undefined</code></pre><pre><code class="language-none">GDAL.GCI_YCbCr_CbBand</code></pre><pre><code class="language-none">GDAL.GCI_YCbCr_CrBand</code></pre><pre><code class="language-none">GDAL.GCI_YCbCr_YBand</code></pre><pre><code class="language-none">GDAL.GCI_YellowBand</code></pre><pre><code class="language-none">GDAL.GDAL</code></pre><pre><code class="language-none">GDAL.GDALAccess</code></pre><pre><code class="language-none">GDAL.GDALAsyncReaderH</code></pre><pre><code class="language-none">GDAL.GDALAsyncStatusType</code></pre><pre><code class="language-none">GDAL.GDALBuildVRTOptions</code></pre><pre><code class="language-none">GDAL.GDALBuildVRTOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALColorEntry</code></pre><pre><code class="language-none">GDAL.GDALColorInterp</code></pre><pre><code class="language-none">GDAL.GDALColorTableH</code></pre><pre><code class="language-none">GDAL.GDALContourGeneratorH</code></pre><pre><code class="language-none">GDAL.GDALContourWriter</code></pre><pre><code class="language-none">GDAL.GDALDEMProcessingOptions</code></pre><pre><code class="language-none">GDAL.GDALDEMProcessingOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALDataType</code></pre><pre><code class="language-none">GDAL.GDALDatasetH</code></pre><pre><code class="language-none">GDAL.GDALDerivedPixelFunc</code></pre><pre><code class="language-none">GDAL.GDALDriverH</code></pre><pre><code class="language-none">GDAL.GDALError</code></pre><pre><code class="language-none">GDAL.GDALGridAlgorithm</code></pre><pre><code class="language-none">GDAL.GDALGridContext</code></pre><pre><code class="language-none">GDAL.GDALGridDataMetricsOptions</code></pre><pre><code class="language-none">GDAL.GDALGridInverseDistanceToAPowerNearestNeighborOptions</code></pre><pre><code class="language-none">GDAL.GDALGridInverseDistanceToAPowerOptions</code></pre><pre><code class="language-none">GDAL.GDALGridLinearOptions</code></pre><pre><code class="language-none">GDAL.GDALGridMovingAverageOptions</code></pre><pre><code class="language-none">GDAL.GDALGridNearestNeighborOptions</code></pre><pre><code class="language-none">GDAL.GDALGridOptions</code></pre><pre><code class="language-none">GDAL.GDALGridOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALInfoOptions</code></pre><pre><code class="language-none">GDAL.GDALInfoOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALMD_AOP_AREA</code></pre><pre><code class="language-none">GDAL.GDALMD_AOP_POINT</code></pre><pre><code class="language-none">GDAL.GDALMD_AREA_OR_POINT</code></pre><pre><code class="language-none">GDAL.GDALMajorObjectH</code></pre><pre><code class="language-none">GDAL.GDALMaskFunc</code></pre><pre><code class="language-none">GDAL.GDALNearblackOptions</code></pre><pre><code class="language-none">GDAL.GDALNearblackOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALPaletteInterp</code></pre><pre><code class="language-none">GDAL.GDALProgressFunc</code></pre><pre><code class="language-none">GDAL.GDALRATFieldType</code></pre><pre><code class="language-none">GDAL.GDALRATFieldUsage</code></pre><pre><code class="language-none">GDAL.GDALRIOResampleAlg</code></pre><pre><code class="language-none">GDAL.GDALRPCInfo</code></pre><pre><code class="language-none">GDAL.GDALRWFlag</code></pre><pre><code class="language-none">GDAL.GDALRasterAttributeTableH</code></pre><pre><code class="language-none">GDAL.GDALRasterBandH</code></pre><pre><code class="language-none">GDAL.GDALRasterIOExtraArg</code></pre><pre><code class="language-none">GDAL.GDALRasterizeOptions</code></pre><pre><code class="language-none">GDAL.GDALRasterizeOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALResampleAlg</code></pre><pre><code class="language-none">GDAL.GDALTileOrganization</code></pre><pre><code class="language-none">GDAL.GDALTransformerFunc</code></pre><pre><code class="language-none">GDAL.GDALTransformerInfo</code></pre><pre><code class="language-none">GDAL.GDALTranslateOptions</code></pre><pre><code class="language-none">GDAL.GDALTranslateOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALTriBarycentricCoefficients</code></pre><pre><code class="language-none">GDAL.GDALTriFacet</code></pre><pre><code class="language-none">GDAL.GDALTriangulation</code></pre><pre><code class="language-none">GDAL.GDALVERSION</code></pre><pre><code class="language-none">GDAL.GDALVectorTranslateOptions</code></pre><pre><code class="language-none">GDAL.GDALVectorTranslateOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALWarpAppOptions</code></pre><pre><code class="language-none">GDAL.GDALWarpAppOptionsForBinary</code></pre><pre><code class="language-none">GDAL.GDALWarpOperationH</code></pre><pre><code class="language-none">GDAL.GDALWarpOptions</code></pre><pre><code class="language-none">GDAL.GDAL_DATA</code></pre><pre><code class="language-none">GDAL.GDAL_DATA_COVERAGE_STATUS_DATA</code></pre><pre><code class="language-none">GDAL.GDAL_DATA_COVERAGE_STATUS_EMPTY</code></pre><pre><code class="language-none">GDAL.GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_CREATE</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_CREATECOPY</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_DEFAULT_FIELDS</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_GNM</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_NOTNULL_FIELDS</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_NOTNULL_GEOMFIELDS</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_OPEN</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_RASTER</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_VECTOR</code></pre><pre><code class="language-none">GDAL.GDAL_DCAP_VIRTUALIO</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_CONNECTION_PREFIX</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_CREATIONDATATYPES</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_CREATIONFIELDDATATYPES</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_CREATIONOPTIONLIST</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_EXTENSION</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_EXTENSIONS</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_HELPTOPIC</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_LONGNAME</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_MIMETYPE</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_OPENOPTIONLIST</code></pre><pre><code class="language-none">GDAL.GDAL_DMD_SUBDATASETS</code></pre><pre><code class="language-none">GDAL.GDAL_DS_LAYER_CREATIONOPTIONLIST</code></pre><pre><code class="language-none">GDAL.GDAL_GCP</code></pre><pre><code class="language-none">GDAL.GDAL_GTI2_SIGNATURE</code></pre><pre><code class="language-none">GDAL.GDAL_OF_ALL</code></pre><pre><code class="language-none">GDAL.GDAL_OF_ARRAY_BLOCK_ACCESS</code></pre><pre><code class="language-none">GDAL.GDAL_OF_BLOCK_ACCESS_MASK</code></pre><pre><code class="language-none">GDAL.GDAL_OF_DEFAULT_BLOCK_ACCESS</code></pre><pre><code class="language-none">GDAL.GDAL_OF_GNM</code></pre><pre><code class="language-none">GDAL.GDAL_OF_HASHSET_BLOCK_ACCESS</code></pre><pre><code class="language-none">GDAL.GDAL_OF_INTERNAL</code></pre><pre><code class="language-none">GDAL.GDAL_OF_KIND_MASK</code></pre><pre><code class="language-none">GDAL.GDAL_OF_RASTER</code></pre><pre><code class="language-none">GDAL.GDAL_OF_READONLY</code></pre><pre><code class="language-none">GDAL.GDAL_OF_RESERVED_1</code></pre><pre><code class="language-none">GDAL.GDAL_OF_SHARED</code></pre><pre><code class="language-none">GDAL.GDAL_OF_UPDATE</code></pre><pre><code class="language-none">GDAL.GDAL_OF_VECTOR</code></pre><pre><code class="language-none">GDAL.GDAL_OF_VERBOSE_ERROR</code></pre><pre><code class="language-none">GDAL.GDT_Byte</code></pre><pre><code class="language-none">GDAL.GDT_CFloat32</code></pre><pre><code class="language-none">GDAL.GDT_CFloat64</code></pre><pre><code class="language-none">GDAL.GDT_CInt16</code></pre><pre><code class="language-none">GDAL.GDT_CInt32</code></pre><pre><code class="language-none">GDAL.GDT_Float32</code></pre><pre><code class="language-none">GDAL.GDT_Float64</code></pre><pre><code class="language-none">GDAL.GDT_Int16</code></pre><pre><code class="language-none">GDAL.GDT_Int32</code></pre><pre><code class="language-none">GDAL.GDT_TypeCount</code></pre><pre><code class="language-none">GDAL.GDT_UInt16</code></pre><pre><code class="language-none">GDAL.GDT_UInt32</code></pre><pre><code class="language-none">GDAL.GDT_Unknown</code></pre><pre><code class="language-none">GDAL.GFT_Integer</code></pre><pre><code class="language-none">GDAL.GFT_Real</code></pre><pre><code class="language-none">GDAL.GFT_String</code></pre><pre><code class="language-none">GDAL.GFU_Alpha</code></pre><pre><code class="language-none">GDAL.GFU_AlphaMax</code></pre><pre><code class="language-none">GDAL.GFU_AlphaMin</code></pre><pre><code class="language-none">GDAL.GFU_Blue</code></pre><pre><code class="language-none">GDAL.GFU_BlueMax</code></pre><pre><code class="language-none">GDAL.GFU_BlueMin</code></pre><pre><code class="language-none">GDAL.GFU_Generic</code></pre><pre><code class="language-none">GDAL.GFU_Green</code></pre><pre><code class="language-none">GDAL.GFU_GreenMax</code></pre><pre><code class="language-none">GDAL.GFU_GreenMin</code></pre><pre><code class="language-none">GDAL.GFU_Max</code></pre><pre><code class="language-none">GDAL.GFU_MaxCount</code></pre><pre><code class="language-none">GDAL.GFU_Min</code></pre><pre><code class="language-none">GDAL.GFU_MinMax</code></pre><pre><code class="language-none">GDAL.GFU_Name</code></pre><pre><code class="language-none">GDAL.GFU_PixelCount</code></pre><pre><code class="language-none">GDAL.GFU_Red</code></pre><pre><code class="language-none">GDAL.GFU_RedMax</code></pre><pre><code class="language-none">GDAL.GFU_RedMin</code></pre><pre><code class="language-none">GDAL.GF_Read</code></pre><pre><code class="language-none">GDAL.GF_Write</code></pre><pre><code class="language-none">GDAL.GGA_InverseDistanceToAPower</code></pre><pre><code class="language-none">GDAL.GGA_InverseDistanceToAPowerNearestNeighbor</code></pre><pre><code class="language-none">GDAL.GGA_Linear</code></pre><pre><code class="language-none">GDAL.GGA_MetricAverageDistance</code></pre><pre><code class="language-none">GDAL.GGA_MetricAverageDistancePts</code></pre><pre><code class="language-none">GDAL.GGA_MetricCount</code></pre><pre><code class="language-none">GDAL.GGA_MetricMaximum</code></pre><pre><code class="language-none">GDAL.GGA_MetricMinimum</code></pre><pre><code class="language-none">GDAL.GGA_MetricRange</code></pre><pre><code class="language-none">GDAL.GGA_MovingAverage</code></pre><pre><code class="language-none">GDAL.GGA_NearestNeighbor</code></pre><pre><code class="language-none">GDAL.GInt16</code></pre><pre><code class="language-none">GDAL.GInt32</code></pre><pre><code class="language-none">GDAL.GInt64</code></pre><pre><code class="language-none">GDAL.GIntBig</code></pre><pre><code class="language-none">GDAL.GMF_ALL_VALID</code></pre><pre><code class="language-none">GDAL.GMF_ALPHA</code></pre><pre><code class="language-none">GDAL.GMF_NODATA</code></pre><pre><code class="language-none">GDAL.GMF_PER_DATASET</code></pre><pre><code class="language-none">GDAL.GPI_CMYK</code></pre><pre><code class="language-none">GDAL.GPI_Gray</code></pre><pre><code class="language-none">GDAL.GPI_HLS</code></pre><pre><code class="language-none">GDAL.GPI_RGB</code></pre><pre><code class="language-none">GDAL.GPtrDiff_t</code></pre><pre><code class="language-none">GDAL.GRA_Average</code></pre><pre><code class="language-none">GDAL.GRA_Bilinear</code></pre><pre><code class="language-none">GDAL.GRA_Cubic</code></pre><pre><code class="language-none">GDAL.GRA_CubicSpline</code></pre><pre><code class="language-none">GDAL.GRA_Lanczos</code></pre><pre><code class="language-none">GDAL.GRA_Max</code></pre><pre><code class="language-none">GDAL.GRA_Med</code></pre><pre><code class="language-none">GDAL.GRA_Min</code></pre><pre><code class="language-none">GDAL.GRA_Mode</code></pre><pre><code class="language-none">GDAL.GRA_NearestNeighbour</code></pre><pre><code class="language-none">GDAL.GRA_Q1</code></pre><pre><code class="language-none">GDAL.GRA_Q3</code></pre><pre><code class="language-none">GDAL.GRIORA_Average</code></pre><pre><code class="language-none">GDAL.GRIORA_Bilinear</code></pre><pre><code class="language-none">GDAL.GRIORA_Cubic</code></pre><pre><code class="language-none">GDAL.GRIORA_CubicSpline</code></pre><pre><code class="language-none">GDAL.GRIORA_Gauss</code></pre><pre><code class="language-none">GDAL.GRIORA_Lanczos</code></pre><pre><code class="language-none">GDAL.GRIORA_Mode</code></pre><pre><code class="language-none">GDAL.GRIORA_NearestNeighbour</code></pre><pre><code class="language-none">GDAL.GSpacing</code></pre><pre><code class="language-none">GDAL.GTO_BIT</code></pre><pre><code class="language-none">GDAL.GTO_BSQ</code></pre><pre><code class="language-none">GDAL.GTO_TIP</code></pre><pre><code class="language-none">GDAL.GUInt16</code></pre><pre><code class="language-none">GDAL.GUInt32</code></pre><pre><code class="language-none">GDAL.GUInt64</code></pre><pre><code class="language-none">GDAL.GUIntBig</code></pre><pre><code class="language-none">GDAL.GWKAOM_Average</code></pre><pre><code class="language-none">GDAL.GWKAOM_Fmode</code></pre><pre><code class="language-none">GDAL.GWKAOM_Imode</code></pre><pre><code class="language-none">GDAL.GWKAOM_Max</code></pre><pre><code class="language-none">GDAL.GWKAOM_Min</code></pre><pre><code class="language-none">GDAL.GWKAOM_Quant</code></pre><pre><code class="language-none">GDAL.GWKAverageOrModeAlg</code></pre><pre><code class="language-none">GDAL.OAO_Down</code></pre><pre><code class="language-none">GDAL.OAO_East</code></pre><pre><code class="language-none">GDAL.OAO_North</code></pre><pre><code class="language-none">GDAL.OAO_Other</code></pre><pre><code class="language-none">GDAL.OAO_South</code></pre><pre><code class="language-none">GDAL.OAO_Up</code></pre><pre><code class="language-none">GDAL.OAO_West</code></pre><pre><code class="language-none">GDAL.ODT_HD_Classic</code></pre><pre><code class="language-none">GDAL.ODT_HD_Geocentric</code></pre><pre><code class="language-none">GDAL.ODT_HD_Max</code></pre><pre><code class="language-none">GDAL.ODT_HD_Min</code></pre><pre><code class="language-none">GDAL.ODT_HD_Other</code></pre><pre><code class="language-none">GDAL.ODT_LD_Max</code></pre><pre><code class="language-none">GDAL.ODT_LD_Min</code></pre><pre><code class="language-none">GDAL.ODT_VD_AltitudeBarometric</code></pre><pre><code class="language-none">GDAL.ODT_VD_Depth</code></pre><pre><code class="language-none">GDAL.ODT_VD_Ellipsoidal</code></pre><pre><code class="language-none">GDAL.ODT_VD_GeoidModelDerived</code></pre><pre><code class="language-none">GDAL.ODT_VD_Max</code></pre><pre><code class="language-none">GDAL.ODT_VD_Min</code></pre><pre><code class="language-none">GDAL.ODT_VD_Normal</code></pre><pre><code class="language-none">GDAL.ODT_VD_Orthometric</code></pre><pre><code class="language-none">GDAL.ODT_VD_Other</code></pre><pre><code class="language-none">GDAL.ODrCCreateDataSource</code></pre><pre><code class="language-none">GDAL.ODrCDeleteDataSource</code></pre><pre><code class="language-none">GDAL.ODsCCreateGeomFieldAfterCreateLayer</code></pre><pre><code class="language-none">GDAL.ODsCCreateLayer</code></pre><pre><code class="language-none">GDAL.ODsCCurveGeometries</code></pre><pre><code class="language-none">GDAL.ODsCDeleteLayer</code></pre><pre><code class="language-none">GDAL.ODsCEmulatedTransactions</code></pre><pre><code class="language-none">GDAL.ODsCMeasuredGeometries</code></pre><pre><code class="language-none">GDAL.ODsCRandomLayerRead</code></pre><pre><code class="language-none">GDAL.ODsCRandomLayerWrite</code></pre><pre><code class="language-none">GDAL.ODsCTransactions</code></pre><pre><code class="language-none">GDAL.OFSTBoolean</code></pre><pre><code class="language-none">GDAL.OFSTFloat32</code></pre><pre><code class="language-none">GDAL.OFSTInt16</code></pre><pre><code class="language-none">GDAL.OFSTMaxSubType</code></pre><pre><code class="language-none">GDAL.OFSTNone</code></pre><pre><code class="language-none">GDAL.OFTBinary</code></pre><pre><code class="language-none">GDAL.OFTDate</code></pre><pre><code class="language-none">GDAL.OFTDateTime</code></pre><pre><code class="language-none">GDAL.OFTInteger</code></pre><pre><code class="language-none">GDAL.OFTInteger64</code></pre><pre><code class="language-none">GDAL.OFTInteger64List</code></pre><pre><code class="language-none">GDAL.OFTIntegerList</code></pre><pre><code class="language-none">GDAL.OFTMaxType</code></pre><pre><code class="language-none">GDAL.OFTReal</code></pre><pre><code class="language-none">GDAL.OFTRealList</code></pre><pre><code class="language-none">GDAL.OFTString</code></pre><pre><code class="language-none">GDAL.OFTStringList</code></pre><pre><code class="language-none">GDAL.OFTTime</code></pre><pre><code class="language-none">GDAL.OFTWideString</code></pre><pre><code class="language-none">GDAL.OFTWideStringList</code></pre><pre><code class="language-none">GDAL.OGRAxisOrientation</code></pre><pre><code class="language-none">GDAL.OGRBoolean</code></pre><pre><code class="language-none">GDAL.OGRContourWriterInfo</code></pre><pre><code class="language-none">GDAL.OGRCoordinateTransformationH</code></pre><pre><code class="language-none">GDAL.OGRDataSourceH</code></pre><pre><code class="language-none">GDAL.OGRDatumType</code></pre><pre><code class="language-none">GDAL.OGRERR_CORRUPT_DATA</code></pre><pre><code class="language-none">GDAL.OGRERR_FAILURE</code></pre><pre><code class="language-none">GDAL.OGRERR_INVALID_HANDLE</code></pre><pre><code class="language-none">GDAL.OGRERR_NONE</code></pre><pre><code class="language-none">GDAL.OGRERR_NON_EXISTING_FEATURE</code></pre><pre><code class="language-none">GDAL.OGRERR_NOT_ENOUGH_DATA</code></pre><pre><code class="language-none">GDAL.OGRERR_NOT_ENOUGH_MEMORY</code></pre><pre><code class="language-none">GDAL.OGRERR_UNSUPPORTED_GEOMETRY_TYPE</code></pre><pre><code class="language-none">GDAL.OGRERR_UNSUPPORTED_OPERATION</code></pre><pre><code class="language-none">GDAL.OGRERR_UNSUPPORTED_SRS</code></pre><pre><code class="language-none">GDAL.OGREnvelope</code></pre><pre><code class="language-none">GDAL.OGREnvelope3D</code></pre><pre><code class="language-none">GDAL.OGRErr</code></pre><pre><code class="language-none">GDAL.OGRFeatureDefnH</code></pre><pre><code class="language-none">GDAL.OGRFeatureH</code></pre><pre><code class="language-none">GDAL.OGRField</code></pre><pre><code class="language-none">GDAL.OGRFieldDefnH</code></pre><pre><code class="language-none">GDAL.OGRFieldSubType</code></pre><pre><code class="language-none">GDAL.OGRFieldType</code></pre><pre><code class="language-none">GDAL.OGRGeomFieldDefnH</code></pre><pre><code class="language-none">GDAL.OGRGeometryH</code></pre><pre><code class="language-none">GDAL.OGRJustification</code></pre><pre><code class="language-none">GDAL.OGRLayerH</code></pre><pre><code class="language-none">GDAL.OGRNullFID</code></pre><pre><code class="language-none">GDAL.OGRNullMarker</code></pre><pre><code class="language-none">GDAL.OGRSFDriverH</code></pre><pre><code class="language-none">GDAL.OGRSTBrushAngle</code></pre><pre><code class="language-none">GDAL.OGRSTBrushBColor</code></pre><pre><code class="language-none">GDAL.OGRSTBrushDx</code></pre><pre><code class="language-none">GDAL.OGRSTBrushDy</code></pre><pre><code class="language-none">GDAL.OGRSTBrushFColor</code></pre><pre><code class="language-none">GDAL.OGRSTBrushId</code></pre><pre><code class="language-none">GDAL.OGRSTBrushLast</code></pre><pre><code class="language-none">GDAL.OGRSTBrushParam</code></pre><pre><code class="language-none">GDAL.OGRSTBrushPriority</code></pre><pre><code class="language-none">GDAL.OGRSTBrushSize</code></pre><pre><code class="language-none">GDAL.OGRSTCBrush</code></pre><pre><code class="language-none">GDAL.OGRSTCLabel</code></pre><pre><code class="language-none">GDAL.OGRSTCNone</code></pre><pre><code class="language-none">GDAL.OGRSTCPen</code></pre><pre><code class="language-none">GDAL.OGRSTCSymbol</code></pre><pre><code class="language-none">GDAL.OGRSTCVector</code></pre><pre><code class="language-none">GDAL.OGRSTClassId</code></pre><pre><code class="language-none">GDAL.OGRSTLabelAdjHor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelAdjVert</code></pre><pre><code class="language-none">GDAL.OGRSTLabelAnchor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelAngle</code></pre><pre><code class="language-none">GDAL.OGRSTLabelBColor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelBold</code></pre><pre><code class="language-none">GDAL.OGRSTLabelDx</code></pre><pre><code class="language-none">GDAL.OGRSTLabelDy</code></pre><pre><code class="language-none">GDAL.OGRSTLabelFColor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelFontName</code></pre><pre><code class="language-none">GDAL.OGRSTLabelHColor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelItalic</code></pre><pre><code class="language-none">GDAL.OGRSTLabelLast</code></pre><pre><code class="language-none">GDAL.OGRSTLabelOColor</code></pre><pre><code class="language-none">GDAL.OGRSTLabelParam</code></pre><pre><code class="language-none">GDAL.OGRSTLabelPerp</code></pre><pre><code class="language-none">GDAL.OGRSTLabelPlacement</code></pre><pre><code class="language-none">GDAL.OGRSTLabelPriority</code></pre><pre><code class="language-none">GDAL.OGRSTLabelSize</code></pre><pre><code class="language-none">GDAL.OGRSTLabelStretch</code></pre><pre><code class="language-none">GDAL.OGRSTLabelStrikeout</code></pre><pre><code class="language-none">GDAL.OGRSTLabelTextString</code></pre><pre><code class="language-none">GDAL.OGRSTLabelUnderline</code></pre><pre><code class="language-none">GDAL.OGRSTPenCap</code></pre><pre><code class="language-none">GDAL.OGRSTPenColor</code></pre><pre><code class="language-none">GDAL.OGRSTPenId</code></pre><pre><code class="language-none">GDAL.OGRSTPenJoin</code></pre><pre><code class="language-none">GDAL.OGRSTPenLast</code></pre><pre><code class="language-none">GDAL.OGRSTPenParam</code></pre><pre><code class="language-none">GDAL.OGRSTPenPattern</code></pre><pre><code class="language-none">GDAL.OGRSTPenPerOffset</code></pre><pre><code class="language-none">GDAL.OGRSTPenPriority</code></pre><pre><code class="language-none">GDAL.OGRSTPenWidth</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolAngle</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolColor</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolDx</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolDy</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolFontName</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolId</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolLast</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolOColor</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolOffset</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolParam</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolPerp</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolPriority</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolSize</code></pre><pre><code class="language-none">GDAL.OGRSTSymbolStep</code></pre><pre><code class="language-none">GDAL.OGRSTUCM</code></pre><pre><code class="language-none">GDAL.OGRSTUGround</code></pre><pre><code class="language-none">GDAL.OGRSTUInches</code></pre><pre><code class="language-none">GDAL.OGRSTUMM</code></pre><pre><code class="language-none">GDAL.OGRSTUPixel</code></pre><pre><code class="language-none">GDAL.OGRSTUPoints</code></pre><pre><code class="language-none">GDAL.OGRSTUnitId</code></pre><pre><code class="language-none">GDAL.OGRSpatialReferenceH</code></pre><pre><code class="language-none">GDAL.OGRStyleMgrH</code></pre><pre><code class="language-none">GDAL.OGRStyleTableH</code></pre><pre><code class="language-none">GDAL.OGRStyleToolH</code></pre><pre><code class="language-none">GDAL.OGRUnsetMarker</code></pre><pre><code class="language-none">GDAL.OGR_F_VAL_ALLOW_DIFFERENT_GEOM_DIM</code></pre><pre><code class="language-none">GDAL.OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT</code></pre><pre><code class="language-none">GDAL.OGR_F_VAL_GEOM_TYPE</code></pre><pre><code class="language-none">GDAL.OGR_F_VAL_NULL</code></pre><pre><code class="language-none">GDAL.OGR_F_VAL_WIDTH</code></pre><pre><code class="language-none">GDAL.OGRwkbByteOrder</code></pre><pre><code class="language-none">GDAL.OGRwkbGeometryType</code></pre><pre><code class="language-none">GDAL.OGRwkbVariant</code></pre><pre><code class="language-none">GDAL.OJLeft</code></pre><pre><code class="language-none">GDAL.OJRight</code></pre><pre><code class="language-none">GDAL.OJUndefined</code></pre><pre><code class="language-none">GDAL.OLCAlterFieldDefn</code></pre><pre><code class="language-none">GDAL.OLCCreateField</code></pre><pre><code class="language-none">GDAL.OLCCreateGeomField</code></pre><pre><code class="language-none">GDAL.OLCCurveGeometries</code></pre><pre><code class="language-none">GDAL.OLCDeleteFeature</code></pre><pre><code class="language-none">GDAL.OLCDeleteField</code></pre><pre><code class="language-none">GDAL.OLCFastFeatureCount</code></pre><pre><code class="language-none">GDAL.OLCFastGetExtent</code></pre><pre><code class="language-none">GDAL.OLCFastSetNextByIndex</code></pre><pre><code class="language-none">GDAL.OLCFastSpatialFilter</code></pre><pre><code class="language-none">GDAL.OLCIgnoreFields</code></pre><pre><code class="language-none">GDAL.OLCMeasuredGeometries</code></pre><pre><code class="language-none">GDAL.OLCRandomRead</code></pre><pre><code class="language-none">GDAL.OLCRandomWrite</code></pre><pre><code class="language-none">GDAL.OLCReorderFields</code></pre><pre><code class="language-none">GDAL.OLCSequentialWrite</code></pre><pre><code class="language-none">GDAL.OLCStringsAsUTF8</code></pre><pre><code class="language-none">GDAL.OLCTransactions</code></pre><pre><code class="language-none">GDAL.OLMD_FID64</code></pre><pre><code class="language-none">GDAL.RASTERIO_EXTRA_ARG_CURRENT_VERSION</code></pre><pre><code class="language-none">GDAL.SRS_DN_NAD27</code></pre><pre><code class="language-none">GDAL.SRS_DN_NAD83</code></pre><pre><code class="language-none">GDAL.SRS_DN_WGS72</code></pre><pre><code class="language-none">GDAL.SRS_DN_WGS84</code></pre><pre><code class="language-none">GDAL.SRS_PM_GREENWICH</code></pre><pre><code class="language-none">GDAL.SRS_PP_AZIMUTH</code></pre><pre><code class="language-none">GDAL.SRS_PP_CENTRAL_MERIDIAN</code></pre><pre><code class="language-none">GDAL.SRS_PP_FALSE_EASTING</code></pre><pre><code class="language-none">GDAL.SRS_PP_FALSE_NORTHING</code></pre><pre><code class="language-none">GDAL.SRS_PP_FIPSZONE</code></pre><pre><code class="language-none">GDAL.SRS_PP_LANDSAT_NUMBER</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_1ST_POINT</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_2ND_POINT</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_CENTER</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_ORIGIN</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_POINT_1</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_POINT_2</code></pre><pre><code class="language-none">GDAL.SRS_PP_LATITUDE_OF_POINT_3</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_1ST_POINT</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_2ND_POINT</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_CENTER</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_ORIGIN</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_POINT_1</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_POINT_2</code></pre><pre><code class="language-none">GDAL.SRS_PP_LONGITUDE_OF_POINT_3</code></pre><pre><code class="language-none">GDAL.SRS_PP_PATH_NUMBER</code></pre><pre><code class="language-none">GDAL.SRS_PP_PEG_POINT_HEADING</code></pre><pre><code class="language-none">GDAL.SRS_PP_PEG_POINT_HEIGHT</code></pre><pre><code class="language-none">GDAL.SRS_PP_PEG_POINT_LATITUDE</code></pre><pre><code class="language-none">GDAL.SRS_PP_PEG_POINT_LONGITUDE</code></pre><pre><code class="language-none">GDAL.SRS_PP_PERSPECTIVE_POINT_HEIGHT</code></pre><pre><code class="language-none">GDAL.SRS_PP_PSEUDO_STD_PARALLEL_1</code></pre><pre><code class="language-none">GDAL.SRS_PP_RECTIFIED_GRID_ANGLE</code></pre><pre><code class="language-none">GDAL.SRS_PP_SATELLITE_HEIGHT</code></pre><pre><code class="language-none">GDAL.SRS_PP_SCALE_FACTOR</code></pre><pre><code class="language-none">GDAL.SRS_PP_STANDARD_PARALLEL_1</code></pre><pre><code class="language-none">GDAL.SRS_PP_STANDARD_PARALLEL_2</code></pre><pre><code class="language-none">GDAL.SRS_PP_ZONE</code></pre><pre><code class="language-none">GDAL.SRS_PT_AITOFF</code></pre><pre><code class="language-none">GDAL.SRS_PT_ALBERS_CONIC_EQUAL_AREA</code></pre><pre><code class="language-none">GDAL.SRS_PT_AZIMUTHAL_EQUIDISTANT</code></pre><pre><code class="language-none">GDAL.SRS_PT_BONNE</code></pre><pre><code class="language-none">GDAL.SRS_PT_CASSINI_SOLDNER</code></pre><pre><code class="language-none">GDAL.SRS_PT_CRASTER_PARABOLIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_CYLINDRICAL_EQUAL_AREA</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_I</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_II</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_III</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_IV</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_V</code></pre><pre><code class="language-none">GDAL.SRS_PT_ECKERT_VI</code></pre><pre><code class="language-none">GDAL.SRS_PT_EQUIDISTANT_CONIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_EQUIRECTANGULAR</code></pre><pre><code class="language-none">GDAL.SRS_PT_GALL_STEREOGRAPHIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_GAUSSSCHREIBERTMERCATOR</code></pre><pre><code class="language-none">GDAL.SRS_PT_GEOSTATIONARY_SATELLITE</code></pre><pre><code class="language-none">GDAL.SRS_PT_GNOMONIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_GOODE_HOMOLOSINE</code></pre><pre><code class="language-none">GDAL.SRS_PT_HOTINE_OBLIQUE_MERCATOR</code></pre><pre><code class="language-none">GDAL.SRS_PT_HOTINE_OBLIQUE_MERCATOR_AZIMUTH_CENTER</code></pre><pre><code class="language-none">GDAL.SRS_PT_HOTINE_OBLIQUE_MERCATOR_TWO_POINT_NATURAL_ORIGIN</code></pre><pre><code class="language-none">GDAL.SRS_PT_IGH</code></pre><pre><code class="language-none">GDAL.SRS_PT_IMW_POLYCONIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_KROVAK</code></pre><pre><code class="language-none">GDAL.SRS_PT_LABORDE_OBLIQUE_MERCATOR</code></pre><pre><code class="language-none">GDAL.SRS_PT_LAMBERT_AZIMUTHAL_EQUAL_AREA</code></pre><pre><code class="language-none">GDAL.SRS_PT_LAMBERT_CONFORMAL_CONIC_1SP</code></pre><pre><code class="language-none">GDAL.SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP</code></pre><pre><code class="language-none">GDAL.SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP_BELGIUM</code></pre><pre><code class="language-none">GDAL.SRS_PT_LOXIMUTHAL</code></pre><pre><code class="language-none">GDAL.SRS_PT_MERCATOR_1SP</code></pre><pre><code class="language-none">GDAL.SRS_PT_MERCATOR_2SP</code></pre><pre><code class="language-none">GDAL.SRS_PT_MERCATOR_AUXILIARY_SPHERE</code></pre><pre><code class="language-none">GDAL.SRS_PT_MILLER_CYLINDRICAL</code></pre><pre><code class="language-none">GDAL.SRS_PT_MOLLWEIDE</code></pre><pre><code class="language-none">GDAL.SRS_PT_NEW_ZEALAND_MAP_GRID</code></pre><pre><code class="language-none">GDAL.SRS_PT_OBLIQUE_STEREOGRAPHIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_ORTHOGRAPHIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_POLAR_STEREOGRAPHIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_POLYCONIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_QSC</code></pre><pre><code class="language-none">GDAL.SRS_PT_QUARTIC_AUTHALIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_ROBINSON</code></pre><pre><code class="language-none">GDAL.SRS_PT_SCH</code></pre><pre><code class="language-none">GDAL.SRS_PT_SINUSOIDAL</code></pre><pre><code class="language-none">GDAL.SRS_PT_STEREOGRAPHIC</code></pre><pre><code class="language-none">GDAL.SRS_PT_SWISS_OBLIQUE_CYLINDRICAL</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_MI_21</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_MI_22</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_MI_23</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_MI_24</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_MI_25</code></pre><pre><code class="language-none">GDAL.SRS_PT_TRANSVERSE_MERCATOR_SOUTH_ORIENTED</code></pre><pre><code class="language-none">GDAL.SRS_PT_TUNISIA_MINING_GRID</code></pre><pre><code class="language-none">GDAL.SRS_PT_TWO_POINT_EQUIDISTANT</code></pre><pre><code class="language-none">GDAL.SRS_PT_VANDERGRINTEN</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_I</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_II</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_III</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_IV</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_V</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_VI</code></pre><pre><code class="language-none">GDAL.SRS_PT_WAGNER_VII</code></pre><pre><code class="language-none">GDAL.SRS_PT_WINKEL_I</code></pre><pre><code class="language-none">GDAL.SRS_PT_WINKEL_II</code></pre><pre><code class="language-none">GDAL.SRS_PT_WINKEL_TRIPEL</code></pre><pre><code class="language-none">GDAL.SRS_UA_DEGREE</code></pre><pre><code class="language-none">GDAL.SRS_UA_DEGREE_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UA_RADIAN</code></pre><pre><code class="language-none">GDAL.SRS_UL_CENTIMETER</code></pre><pre><code class="language-none">GDAL.SRS_UL_CENTIMETER_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_CHAIN</code></pre><pre><code class="language-none">GDAL.SRS_UL_CHAIN_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_DECIMETER</code></pre><pre><code class="language-none">GDAL.SRS_UL_DECIMETER_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_FOOT</code></pre><pre><code class="language-none">GDAL.SRS_UL_FOOT_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_CHAIN</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_CHAIN_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_FOOT</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_FOOT_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_YARD</code></pre><pre><code class="language-none">GDAL.SRS_UL_INDIAN_YARD_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_CHAIN</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_CHAIN_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_FATHOM</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_FATHOM_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_FOOT</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_FOOT_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_INCH</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_INCH_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_LINK</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_LINK_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_NAUT_MILE</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_NAUT_MILE_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_STAT_MILE</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_STAT_MILE_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_YARD</code></pre><pre><code class="language-none">GDAL.SRS_UL_INTL_YARD_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_KILOMETER</code></pre><pre><code class="language-none">GDAL.SRS_UL_KILOMETER_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_LINK</code></pre><pre><code class="language-none">GDAL.SRS_UL_LINK_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_LINK_Clarke</code></pre><pre><code class="language-none">GDAL.SRS_UL_LINK_Clarke_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_METER</code></pre><pre><code class="language-none">GDAL.SRS_UL_MILLIMETER</code></pre><pre><code class="language-none">GDAL.SRS_UL_MILLIMETER_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_NAUTICAL_MILE</code></pre><pre><code class="language-none">GDAL.SRS_UL_NAUTICAL_MILE_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_ROD</code></pre><pre><code class="language-none">GDAL.SRS_UL_ROD_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_CHAIN</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_CHAIN_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_FOOT</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_FOOT_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_INCH</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_INCH_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_STAT_MILE</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_STAT_MILE_CONV</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_YARD</code></pre><pre><code class="language-none">GDAL.SRS_UL_US_YARD_CONV</code></pre><pre><code class="language-none">GDAL.SRS_WGS84_INVFLATTENING</code></pre><pre><code class="language-none">GDAL.SRS_WGS84_SEMIMAJOR</code></pre><pre><code class="language-none">GDAL.SRS_WKT_WGS84</code></pre><pre><code class="language-none">GDAL.TRUE</code></pre><pre><code class="language-none">GDAL.VIRTUALMEM_READONLY</code></pre><pre><code class="language-none">GDAL.VIRTUALMEM_READONLY_ENFORCED</code></pre><pre><code class="language-none">GDAL.VIRTUALMEM_READWRITE</code></pre><pre><code class="language-none">GDAL.VRTAverageFilteredSourceH</code></pre><pre><code class="language-none">GDAL.VRTAveragedSourceH</code></pre><pre><code class="language-none">GDAL.VRTComplexSourceH</code></pre><pre><code class="language-none">GDAL.VRTDatasetH</code></pre><pre><code class="language-none">GDAL.VRTDerivedRasterBandH</code></pre><pre><code class="language-none">GDAL.VRTDriverH</code></pre><pre><code class="language-none">GDAL.VRTFilteredSourceH</code></pre><pre><code class="language-none">GDAL.VRTFuncSourceH</code></pre><pre><code class="language-none">GDAL.VRTImageReadFunc</code></pre><pre><code class="language-none">GDAL.VRTKernelFilteredSourceH</code></pre><pre><code class="language-none">GDAL.VRTRasterBandH</code></pre><pre><code class="language-none">GDAL.VRTRawRasterBandH</code></pre><pre><code class="language-none">GDAL.VRTSimpleSourceH</code></pre><pre><code class="language-none">GDAL.VRTSourceH</code></pre><pre><code class="language-none">GDAL.VRTSourcedRasterBandH</code></pre><pre><code class="language-none">GDAL.VRTWarpedDatasetH</code></pre><pre><code class="language-none">GDAL.VRTWarpedRasterBandH</code></pre><pre><code class="language-none">GDAL.VRT_NODATA_UNSET</code></pre><pre><code class="language-none">GDAL.VSILFILE</code></pre><pre><code class="language-none">GDAL.VSIRangeStatus</code></pre><pre><code class="language-none">GDAL.VSIStatBuf</code></pre><pre><code class="language-none">GDAL.VSIStatBufL</code></pre><pre><code class="language-none">GDAL.VSI_RANGE_STATUS_DATA</code></pre><pre><code class="language-none">GDAL.VSI_RANGE_STATUS_HOLE</code></pre><pre><code class="language-none">GDAL.VSI_RANGE_STATUS_UNKNOWN</code></pre><pre><code class="language-none">GDAL.VSI_STAT_EXISTS_FLAG</code></pre><pre><code class="language-none">GDAL.VSI_STAT_NATURE_FLAG</code></pre><pre><code class="language-none">GDAL.VSI_STAT_SET_ERROR_FLAG</code></pre><pre><code class="language-none">GDAL.VSI_STAT_SIZE_FLAG</code></pre><pre><code class="language-none">GDAL._CPLXMLNode</code></pre><pre><code class="language-none">GDAL.__init__</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL._cplassert" href="#GDAL._cplassert"><code>GDAL._cplassert</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">_CPLAssert(const char * pszExpression,
           const char * pszFile,
           int iLine) -&gt; void</code></pre><p>Report failure of a logical assertion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addband" href="#GDAL.addband"><code>GDAL.addband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALAddBand(GDALDatasetH hDataset,
            GDALDataType eType,
            char ** papszOptions) -&gt; CPLErr</code></pre><p>Add a band to a dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addderivedbandpixelfunc" href="#GDAL.addderivedbandpixelfunc"><code>GDAL.addderivedbandpixelfunc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALAddDerivedBandPixelFunc(const char * pszName,
                            GDALDerivedPixelFunc pfnPixelFunc) -&gt; CPLErr</code></pre><p>This adds a pixel function to the global list of available pixel functions for derived bands.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFuncName</strong>: Name used to access pixel function</li><li><strong>pfnNewFunction</strong>: Pixel function associated with name. An existing pixel function registered with the same name will be replaced with the new one.</li></ul><p><strong>Returns</strong></p><p>CE_None, invalid (NULL) parameters are currently ignored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addfielddefn" href="#GDAL.addfielddefn"><code>GDAL.addfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_AddFieldDefn(OGRFeatureDefnH hDefn,
                    OGRFieldDefnH hNewField) -&gt; void</code></pre><p>Add a new field definition to the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to add the field definition to.</li><li><strong>hNewField</strong>: handle to the new field definition.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addgeometry" href="#GDAL.addgeometry"><code>GDAL.addgeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddGeometry(OGRGeometryH hGeom,
                  OGRGeometryH hNewSubGeom) -&gt; OGRErr</code></pre><p>Add a geometry to a geometry container.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: existing geometry container.</li><li><strong>hNewSubGeom</strong>: geometry to add to the container.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGRERR</em>UNSUPPORTED<em>GEOMETRY</em>TYPE if the geometry type is illegal for the type of existing geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addgeometrydirectly" href="#GDAL.addgeometrydirectly"><code>GDAL.addgeometrydirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddGeometryDirectly(OGRGeometryH hGeom,
                          OGRGeometryH hNewSubGeom) -&gt; OGRErr</code></pre><p>Add a geometry directly to an existing geometry container.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: existing geometry.</li><li><strong>hNewSubGeom</strong>: geometry to add to the existing geometry.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGRERR</em>UNSUPPORTED<em>GEOMETRY</em>TYPE if the geometry type is illegal for the type of geometry container.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addgeomfielddefn" href="#GDAL.addgeomfielddefn"><code>GDAL.addgeomfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn,
                        OGRGeomFieldDefnH hNewGeomField) -&gt; void</code></pre><p>Add a new field definition to the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to add the geometry field definition to.</li><li><strong>hNewGeomField</strong>: handle to the new field definition.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addpart" href="#GDAL.addpart"><code>GDAL.addpart</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_AddPart(OGRStyleMgrH hSM,
               OGRStyleToolH hST) -&gt; int</code></pre><p>Add a part (style tool) to the current style.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>hST</strong>: the style tool defining the part to add.</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addpoint" href="#GDAL.addpoint"><code>GDAL.addpoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddPoint(OGRGeometryH hGeom,
               double dfX,
               double dfY,
               double dfZ) -&gt; void</code></pre><p>Add a point to a geometry (line string or point).</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a point to.</li><li><strong>dfX</strong>: x coordinate of point to add.</li><li><strong>dfY</strong>: y coordinate of point to add.</li><li><strong>dfZ</strong>: z coordinate of point to add.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addpoint_2d" href="#GDAL.addpoint_2d"><code>GDAL.addpoint_2d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddPoint_2D(OGRGeometryH hGeom,
                  double dfX,
                  double dfY) -&gt; void</code></pre><p>Add a point to a geometry (line string or point).</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a point to.</li><li><strong>dfX</strong>: x coordinate of point to add.</li><li><strong>dfY</strong>: y coordinate of point to add.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addpointm" href="#GDAL.addpointm"><code>GDAL.addpointm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddPointM(OGRGeometryH hGeom,
                double dfX,
                double dfY,
                double dfM) -&gt; void</code></pre><p>Add a point to a geometry (line string or point).</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a point to.</li><li><strong>dfX</strong>: x coordinate of point to add.</li><li><strong>dfY</strong>: y coordinate of point to add.</li><li><strong>dfM</strong>: m coordinate of point to add.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addpointzm" href="#GDAL.addpointzm"><code>GDAL.addpointzm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AddPointZM(OGRGeometryH hGeom,
                 double dfX,
                 double dfY,
                 double dfZ,
                 double dfM) -&gt; void</code></pre><p>Add a point to a geometry (line string or point).</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a point to.</li><li><strong>dfX</strong>: x coordinate of point to add.</li><li><strong>dfY</strong>: y coordinate of point to add.</li><li><strong>dfZ</strong>: z coordinate of point to add.</li><li><strong>dfM</strong>: m coordinate of point to add.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.addstyle" href="#GDAL.addstyle"><code>GDAL.addstyle</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_AddStyle(OGRStyleMgrH hSM,
                const char * pszStyleName,
                const char * pszStyleString) -&gt; int</code></pre><p>Add a style to the current style table.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>pszStyleName</strong>: the name of the style to add.</li><li><strong>pszStyleString</strong>: the style string to use, or NULL to use the style stored in the manager.</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on errors.</p></div></div><div><div><pre><code class="language-none">OGR_STBL_AddStyle(OGRStyleTableH hStyleTable,
                  const char * pszName,
                  const char * pszStyleString) -&gt; int</code></pre><p>Add a new style in the table.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li><li><strong>pszName</strong>: the name the style to add.</li><li><strong>pszStyleString</strong>: the style string to add.</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.adjustvaluetodatatype" href="#GDAL.adjustvaluetodatatype"><code>GDAL.adjustvaluetodatatype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALAdjustValueToDataType(GDALDataType eDT,
                          double dfValue,
                          int * pbClamped,
                          int * pbRounded) -&gt; double</code></pre><p>Adjust a value to the output data type.</p><p><strong>Parameters</strong></p><ul><li><strong>eDT</strong>: target data type.</li><li><strong>dfValue</strong>: value to adjust.</li><li><strong>pbClamped</strong>: pointer to a integer(boolean) to indicate if clamping has been made, or NULL</li><li><strong>pbRounded</strong>: pointer to a integer(boolean) to indicate if rounding has been made, or NULL</li></ul><p><strong>Returns</strong></p><p>adjusted value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.allregister" href="#GDAL.allregister"><code>GDAL.allregister</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALAllRegister() -&gt; void</code></pre><p>Register all known configured GDAL drivers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.alterfielddefn" href="#GDAL.alterfielddefn"><code>GDAL.alterfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_AlterFieldDefn(OGRLayerH,
                     int iField,
                     OGRFieldDefnH hNewFieldDefn,
                     int nFlags) -&gt; OGRErr</code></pre><p>Alter the definition of an existing field on a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li><li><strong>iField</strong>: index of the field whose definition must be altered.</li><li><strong>hNewFieldDefn</strong>: new field definition</li><li><strong>nFlags</strong>: combination of ALTER<em>NAME</em>FLAG, ALTER<em>TYPE</em>FLAG, ALTER<em>WIDTH</em>PRECISION<em>FLAG, ALTER</em>NULLABLE<em>FLAG and ALTER</em>DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.applygeotransform" href="#GDAL.applygeotransform"><code>GDAL.applygeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALApplyGeoTransform(double * padfGeoTransform,
                      double dfPixel,
                      double dfLine,
                      double * pdfGeoX,
                      double * pdfGeoY) -&gt; void</code></pre><p>Apply GeoTransform to x/y coordinate.</p><p><strong>Parameters</strong></p><ul><li><strong>padfGeoTransform</strong>: Six coefficient GeoTransform to apply.</li><li><strong>dfPixel</strong>: Input pixel position.</li><li><strong>dfLine</strong>: Input line position.</li><li><strong>pdfGeoX</strong>: output location where geo_x (easting/longitude) location is placed.</li><li><strong>pdfGeoY</strong>: output location where geo_y (northing/latitude) location is placed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.applyverticalshiftgrid" href="#GDAL.applyverticalshiftgrid"><code>GDAL.applyverticalshiftgrid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALApplyVerticalShiftGrid(GDALDatasetH hSrcDataset,
                           GDALDatasetH hGridDataset,
                           int bInverse,
                           double dfSrcUnitToMeter,
                           double dfDstUnitToMeter,
                           const char *const * papszOptions) -&gt; GDALDatasetH</code></pre><p>Apply a vertical shift grid to a source (DEM typically) dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDataset</strong>: source (DEM) dataset. Must not be NULL.</li><li><strong>hGridDataset</strong>: vertical grid shift dataset. Must not be NULL.</li><li><strong>bInverse</strong>: if set to FALSE, hGridDataset values will be added to hSrcDataset. If set to TRUE, they will be subtracted.</li><li><strong>dfSrcUnitToMeter</strong>: the factor to convert values from hSrcDataset to meters (1.0 if source values are in meter).</li><li><strong>dfDstUnitToMeter</strong>: the factor to convert shifted values from meter (1.0 if output values must be in meter).</li><li><strong>papszOptions</strong>: list of options, or NULL. Supported options are: </li></ul><p>RESAMPLING=NEAREST/BILINEAR/CUBIC. Defaults to BILINEAR. </p><p>MAX_ERROR=val. Maximum error measured in input pixels that is allowed in approximating the transformation (0.0 for exact calculations). Defaults to 0.125 </p><p>DATATYPE=Byte/UInt16/Int16/Float32/Float64. Output data type. If not specified will be the same as the one of hSrcDataset. </p><p>ERROR<em>ON</em>MISSING<em>VERT</em>SHIFT=YES/NO. Whether a missing/nodata value in hGridDataset should cause I/O requests to fail. Default is NO (in which case 0 will be used) </p><p>SRC<em>SRS=srs</em>def. Override projection on hSrcDataset;</p><p><strong>Returns</strong></p><p>a new dataset corresponding to hSrcDataset adjusted with hGridDataset, or NULL. If not NULL, it must be closed with GDALClose().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.approximatearcangles" href="#GDAL.approximatearcangles"><code>GDAL.approximatearcangles</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ApproximateArcAngles(double dfCenterX,
                           double dfCenterY,
                           double dfZ,
                           double dfPrimaryRadius,
                           double dfSecondaryRadius,
                           double dfRotation,
                           double dfStartAngle,
                           double dfEndAngle,
                           double dfMaxAngleStepSizeDegrees) -&gt; OGRGeometryH</code></pre><p>Stroke arc to linestring.</p><p><strong>Parameters</strong></p><ul><li><strong>dfCenterX</strong>: center X</li><li><strong>dfCenterY</strong>: center Y</li><li><strong>dfZ</strong>: center Z</li><li><strong>dfPrimaryRadius</strong>: X radius of ellipse.</li><li><strong>dfSecondaryRadius</strong>: Y radius of ellipse.</li><li><strong>dfRotation</strong>: rotation of the ellipse clockwise.</li><li><strong>dfStartAngle</strong>: angle to first point on arc (clockwise of X-positive)</li><li><strong>dfEndAngle</strong>: angle to last point on arc (clockwise of X-positive)</li><li><strong>dfMaxAngleStepSizeDegrees</strong>: the largest step in degrees along the arc, zero to use the default setting.</li></ul><p><strong>Returns</strong></p><p>OGRLineString geometry representing an approximation of the arc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.approxtransform" href="#GDAL.approxtransform"><code>GDAL.approxtransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALApproxTransform(void * pCBData,
                    int bDstToSrc,
                    int nPoints,
                    double * x,
                    double * y,
                    double * z,
                    int * panSuccess) -&gt; int</code></pre><p>Perform approximate transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.approxtransformerownssubtransformer" href="#GDAL.approxtransformerownssubtransformer"><code>GDAL.approxtransformerownssubtransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALApproxTransformerOwnsSubtransformer(void * pCBData,
                                        int bOwnFlag) -&gt; void</code></pre><p>Set bOwnSubtransformer flag.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.area" href="#GDAL.area"><code>GDAL.area</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Area(OGRGeometryH hGeom) -&gt; double</code></pre><p>Compute geometry area.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the geometry to operate on.</li></ul><p><strong>Returns</strong></p><p>the area or 0.0 for unsupported geometry types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.aretypesubtypecompatible" href="#GDAL.aretypesubtypecompatible"><code>GDAL.aretypesubtypecompatible</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_AreTypeSubTypeCompatible(OGRFieldType eType,
                             OGRFieldSubType eSubType) -&gt; int</code></pre><p>Return if type and subtype are compatible.</p><p><strong>Parameters</strong></p><ul><li><strong>eType</strong>: the field type.</li><li><strong>eSubType</strong>: the field subtype.</li></ul><p><strong>Returns</strong></p><p>TRUE if type and subtype are compatible</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.argetnextupdatedregion" href="#GDAL.argetnextupdatedregion"><code>GDAL.argetnextupdatedregion</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALARGetNextUpdatedRegion(GDALAsyncReaderH hARIO,
                           double dfTimeout,
                           int * pnBufXOff,
                           int * pnBufYOff,
                           int * pnBufXSize,
                           int * pnBufYSize) -&gt; GDALAsyncStatusType</code></pre><p>Get async IO update.</p><p><strong>Parameters</strong></p><ul><li><strong>hARIO</strong>: handle to the async reader.</li><li><strong>dfTimeout</strong>: the number of seconds to wait for additional updates. Use -1 to wait indefinitely, or zero to not wait at all if there is no data available.</li><li><strong>pnBufXOff</strong>: location to return the X offset of the area of the request buffer that has been updated.</li><li><strong>pnBufYOff</strong>: location to return the Y offset of the area of the request buffer that has been updated.</li><li><strong>pnBufXSize</strong>: location to return the X size of the area of the request buffer that has been updated.</li><li><strong>pnBufYSize</strong>: location to return the Y size of the area of the request buffer that has been updated.</li></ul><p><strong>Returns</strong></p><p>GARIO_ status, details described above.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.arlockbuffer" href="#GDAL.arlockbuffer"><code>GDAL.arlockbuffer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALARLockBuffer(GDALAsyncReaderH hARIO,
                 double dfTimeout) -&gt; int</code></pre><p>Lock image buffer.</p><p><strong>Parameters</strong></p><ul><li><strong>hARIO</strong>: handle to async reader.</li><li><strong>dfTimeout</strong>: the time in seconds to wait attempting to lock the buffer. -1.0 to wait indefinitely and 0 to not wait at all if it can&#39;t be acquired immediately. Default is -1.0 (infinite wait).</li></ul><p><strong>Returns</strong></p><p>TRUE if successful, or FALSE on an error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.arunlockbuffer" href="#GDAL.arunlockbuffer"><code>GDAL.arunlockbuffer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALARUnlockBuffer(GDALAsyncReaderH hARIO) -&gt; void</code></pre><p>Unlock image buffer.</p><p><strong>Parameters</strong></p><ul><li><strong>hARIO</strong>: handle to async reader.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.assignspatialreference" href="#GDAL.assignspatialreference"><code>GDAL.assignspatialreference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_AssignSpatialReference(OGRGeometryH hGeom,
                             OGRSpatialReferenceH hSRS) -&gt; void</code></pre><p>Assign spatial reference to this object.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to apply the new spatial reference system.</li><li><strong>hSRS</strong>: handle on the new spatial reference system to apply.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.autoidentifyepsg" href="#GDAL.autoidentifyepsg"><code>GDAL.autoidentifyepsg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRAutoIdentifyEPSG(OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Set EPSG authority info if possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.axisenumtoname" href="#GDAL.axisenumtoname"><code>GDAL.axisenumtoname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRAxisEnumToName(OGRAxisOrientation eOrientation) -&gt; const char *</code></pre><p>Return the string representation for the OGRAxisOrientation enumeration.</p><p><strong>Returns</strong></p><p>an internal string</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.beginasyncreader" href="#GDAL.beginasyncreader"><code>GDAL.beginasyncreader</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBeginAsyncReader(GDALDatasetH hDS,
                     int nXOff,
                     int nYOff,
                     int nXSize,
                     int nYSize,
                     void * pBuf,
                     int nBufXSize,
                     int nBufYSize,
                     GDALDataType eBufType,
                     int nBandCount,
                     int * panBandMap,
                     int nPixelSpace,
                     int nLineSpace,
                     int nBandSpace,
                     char ** papszOptions) -&gt; GDALAsyncReaderH</code></pre><p>Sets up an asynchronous data request.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the dataset object.</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be accessed. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be accessed. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be accessed in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be accessed in lines.</li><li><strong>pBuf</strong>: The buffer into which the data should be read. This buffer must contain at least nBufXSize * nBufYSize * nBandCount words of type eBufType. It is organized in left to right,top to bottom pixel order. Spacing is controlled by the nPixelSpace, and nLineSpace parameters.</li><li><strong>nBufXSize</strong>: the width of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>nBufYSize</strong>: the height of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>eBufType</strong>: the type of the pixel values in the pData data buffer. The pixel values will automatically be translated to/from the GDALRasterBand data type as needed.</li><li><strong>nBandCount</strong>: the number of bands being read or written.</li><li><strong>panBandMap</strong>: the list of nBandCount band numbers being read/written. Note band numbers are 1 based. This may be NULL to select the first nBandCount bands.</li><li><strong>nPixelSpace</strong>: The byte offset from the start of one pixel value in pData to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</li><li><strong>nLineSpace</strong>: The byte offset from the start of one scanline in pData to the start of the next. If defaulted the size of the datatype eBufType * nBufXSize is used.</li><li><strong>nBandSpace</strong>: the byte offset from the start of one bands data to the start of the next. If defaulted (zero) the value will be nLineSpace * nBufYSize implying band sequential organization of the data buffer.</li><li><strong>papszOptions</strong>: Driver specific control options in a string list or NULL. Consult driver documentation for options supported.</li></ul><p><strong>Returns</strong></p><p>handle representing the request.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.boundary" href="#GDAL.boundary"><code>GDAL.boundary</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Boundary(OGRGeometryH hTarget) -&gt; OGRGeometryH</code></pre><p>Compute boundary.</p><p><strong>Parameters</strong></p><ul><li><strong>hTarget</strong>: The Geometry to calculate the boundary of.</li></ul><p><strong>Returns</strong></p><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buffer" href="#GDAL.buffer"><code>GDAL.buffer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Buffer(OGRGeometryH hTarget,
             double dfDist,
             int nQuadSegs) -&gt; OGRGeometryH</code></pre><p>Compute buffer of geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hTarget</strong>: the geometry.</li><li><strong>dfDist</strong>: the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</li><li><strong>nQuadSegs</strong>: the number of segments used to approximate a 90 degree (quadrant) of curvature.</li></ul><p><strong>Returns</strong></p><p>the newly created geometry, or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildoverviews" href="#GDAL.buildoverviews"><code>GDAL.buildoverviews</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBuildOverviews(GDALDatasetH hDataset,
                   const char * pszResampling,
                   int nOverviews,
                   int * panOverviewList,
                   int nListBands,
                   int * panBandList,
                   GDALProgressFunc pfnProgress,
                   void * pProgressData) -&gt; CPLErr</code></pre><p>Build raster overview(s)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildpolygonfromedges" href="#GDAL.buildpolygonfromedges"><code>GDAL.buildpolygonfromedges</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRBuildPolygonFromEdges(OGRGeometryH hLines,
                         int bBestEffort,
                         int bAutoClose,
                         double dfTolerance,
                         OGRErr * peErr) -&gt; OGRGeometryH</code></pre><p>Build a ring from a bunch of arcs.</p><p><strong>Parameters</strong></p><ul><li><strong>hLines</strong>: handle to an OGRGeometryCollection (or OGRMultiLineString) containing the line string geometries to be built into rings.</li><li><strong>bBestEffort</strong>: not yet implemented???.</li><li><strong>bAutoClose</strong>: indicates if the ring should be close when first and last points of the ring are the same.</li><li><strong>dfTolerance</strong>: tolerance into which two arcs are considered close enough to be joined.</li><li><strong>peErr</strong>: OGRERR<em>NONE on success, or OGRERR</em>FAILURE on failure.</li></ul><p><strong>Returns</strong></p><p>an handle to the new geometry, a polygon.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildvrt" href="#GDAL.buildvrt"><code>GDAL.buildvrt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBuildVRT(const char * pszDest,
             int nSrcCount,
             GDALDatasetH * pahSrcDS,
             const char *const * papszSrcDSNames,
             const GDALBuildVRTOptions * psOptionsIn,
             int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Build a VRT from a list of datasets.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path.</li><li><strong>nSrcCount</strong>: the number of input datasets.</li><li><strong>pahSrcDS</strong>: the list of input datasets (or NULL, exclusive with papszSrcDSNames)</li><li><strong>papszSrcDSNames</strong>: the list of input dataset names (or NULL, exclusive with pahSrcDS)</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALBuildVRTOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose()) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildvrtoptionsfree" href="#GDAL.buildvrtoptionsfree"><code>GDAL.buildvrtoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBuildVRTOptionsFree(GDALBuildVRTOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALBuildVRTOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALBuildVRT().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildvrtoptionsnew" href="#GDAL.buildvrtoptionsnew"><code>GDAL.buildvrtoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBuildVRTOptionsNew(char ** papszArgv,
                       GDALBuildVRTOptionsForBinary * psOptionsForBinary) -&gt; GDALBuildVRTOptions *</code></pre><p>Allocates a GDALBuildVRTOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdalbuildvrt utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALBuildVRTOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALBuildVRTOptions struct. Must be freed with GDALBuildVRTOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.buildvrtoptionssetprogress" href="#GDAL.buildvrtoptionssetprogress"><code>GDAL.buildvrtoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALBuildVRTOptionsSetProgress(GDALBuildVRTOptions * psOptions,
                               GDALProgressFunc pfnProgress,
                               void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALBuildVRT().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.calcinvflattening" href="#GDAL.calcinvflattening"><code>GDAL.calcinvflattening</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRCalcInvFlattening(double dfSemiMajor,
                     double dfSemiMinor) -&gt; double</code></pre><p>Compute inverse flattening from semi-major and semi-minor axis.</p><p><strong>Parameters</strong></p><ul><li><strong>dfSemiMajor</strong>: Semi-major axis length.</li><li><strong>dfSemiMinor</strong>: Semi-minor axis length.</li></ul><p><strong>Returns</strong></p><p>inverse flattening, or 0 if both axis are equal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.calcsemiminorfrominvflattening" href="#GDAL.calcsemiminorfrominvflattening"><code>GDAL.calcsemiminorfrominvflattening</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRCalcSemiMinorFromInvFlattening(double dfSemiMajor,
                                  double dfInvFlattening) -&gt; double</code></pre><p>Compute semi-minor axis from semi-major axis and inverse flattening.</p><p><strong>Parameters</strong></p><ul><li><strong>dfSemiMajor</strong>: Semi-major axis length.</li><li><strong>dfInvFlattening</strong>: Inverse flattening or 0 for sphere.</li></ul><p><strong>Returns</strong></p><p>semi-minor axis</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.centroid" href="#GDAL.centroid"><code>GDAL.centroid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Centroid(OGRGeometryH hGeom,
               OGRGeometryH hCentroidPoint) -&gt; int</code></pre><p>Compute the geometry centroid.</p><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success or OGRERR</em>FAILURE on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.cg_create" href="#GDAL.cg_create"><code>GDAL.cg_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDAL_CG_Create(int nWidth,
               int nHeight,
               int bNoDataSet,
               double dfNoDataValue,
               double dfContourInterval,
               double dfContourBase,
               GDALContourWriter pfnWriter,
               void * pCBData) -&gt; GDALContourGeneratorH</code></pre><p>Create contour generator.</p></div></div></section><pre><code class="language-none">GDAL.check_deps</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.checksumimage" href="#GDAL.checksumimage"><code>GDAL.checksumimage</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALChecksumImage(GDALRasterBandH hBand,
                  int nXOff,
                  int nYOff,
                  int nXSize,
                  int nYSize) -&gt; int</code></pre><p>Compute checksum for image region.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: the raster band to read from.</li><li><strong>nXOff</strong>: pixel offset of window to read.</li><li><strong>nYOff</strong>: line offset of window to read.</li><li><strong>nXSize</strong>: pixel size of window to read.</li><li><strong>nYSize</strong>: line size of window to read.</li></ul><p><strong>Returns</strong></p><p>Checksum value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.cleanup" href="#GDAL.cleanup"><code>GDAL.cleanup</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRCleanup(void) -&gt; void</code></pre><p>Cleanup cached SRS related memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.cleanupall" href="#GDAL.cleanupall"><code>GDAL.cleanupall</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRCleanupAll(void) -&gt; void</code></pre><p>Clean-up all drivers (including raster ones starting with GDAL 2.0.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.cleanuperrormutex" href="#GDAL.cleanuperrormutex"><code>GDAL.cleanuperrormutex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLCleanupErrorMutex() -&gt; void</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.clip" href="#GDAL.clip"><code>GDAL.clip</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_Clip(OGRLayerH pLayerInput,
           OGRLayerH pLayerMethod,
           OGRLayerH pLayerResult,
           char ** papszOptions,
           GDALProgressFunc pfnProgress,
           void * pProgressArg) -&gt; OGRErr</code></pre><p>Clip off areas that are not covered by the method layer.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.clone" href="#GDAL.clone"><code>GDAL.clone</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Clone(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Make a copy of this object.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to clone from.</li></ul><p><strong>Returns</strong></p><p>an handle on the copy of the geometry with the spatial reference system as the original.</p></div></div><div><div><pre><code class="language-none">OGR_F_Clone(OGRFeatureH hFeat) -&gt; OGRFeatureH</code></pre><p>Duplicate feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to clone.</li></ul><p><strong>Returns</strong></p><p>an handle to the new feature, exactly matching this feature.</p></div></div><div><div><pre><code class="language-none">OSRClone(OGRSpatialReferenceH hSRS) -&gt; OGRSpatialReferenceH</code></pre><p>Make a duplicate of this OGRSpatialReference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.clonecolortable" href="#GDAL.clonecolortable"><code>GDAL.clonecolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCloneColorTable(GDALColorTableH hTable) -&gt; GDALColorTableH</code></pre><p>Make a copy of a color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.clonegeogcs" href="#GDAL.clonegeogcs"><code>GDAL.clonegeogcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRCloneGeogCS(OGRSpatialReferenceH hSource) -&gt; OGRSpatialReferenceH</code></pre><p>Make a duplicate of the GEOGCS node of this OGRSpatialReference object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.close" href="#GDAL.close"><code>GDAL.close</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALClose(GDALDatasetH hDS) -&gt; friend void</code></pre><p>Close GDAL dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: The dataset to close. May be cast from a &quot;GDALDataset *&quot;.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.closerings" href="#GDAL.closerings"><code>GDAL.closerings</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CloseRings(OGRGeometryH hGeom) -&gt; void</code></pre><p>Force rings to be closed.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.committransaction" href="#GDAL.committransaction"><code>GDAL.committransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_CommitTransaction(OGRLayerH) -&gt; OGRErr</code></pre><p>For datasources which support transactions, CommitTransaction commits a transaction.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.composegeotransforms" href="#GDAL.composegeotransforms"><code>GDAL.composegeotransforms</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComposeGeoTransforms(const double * padfGeoTransform1,
                         const double * padfGeoTransform2,
                         double * padfGeoTransformOut) -&gt; void</code></pre><p>Compose two geotransforms.</p><p><strong>Parameters</strong></p><ul><li><strong>padfGT1</strong>: the first geotransform, six values.</li><li><strong>padfGT2</strong>: the second geotransform, six values.</li><li><strong>padfGTOut</strong>: the output geotransform, six values, may safely be the same array as padfGT1 or padfGT2.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computebandstats" href="#GDAL.computebandstats"><code>GDAL.computebandstats</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeBandStats(GDALRasterBandH hBand,
                     int nSampleStep,
                     double * pdfMean,
                     double * pdfStdDev,
                     GDALProgressFunc pfnProgress,
                     void * pProgressData) -&gt; CPLErr</code></pre><p>Undocumented.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: undocumented.</li><li><strong>nSampleStep</strong>: undocumented.</li><li><strong>pdfMean</strong>: undocumented.</li><li><strong>pdfStdDev</strong>: undocumented.</li><li><strong>pfnProgress</strong>: undocumented.</li><li><strong>pProgressData</strong>: undocumented.</li></ul><p><strong>Returns</strong></p><p>undocumented</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computematchingpoints" href="#GDAL.computematchingpoints"><code>GDAL.computematchingpoints</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeMatchingPoints(GDALDatasetH hFirstImage,
                          GDALDatasetH hSecondImage,
                          char ** papszOptions,
                          int * pnGCPCount) -&gt; GDAL_GCP *</code></pre><p>GDALComputeMatchingPoints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computemediancutpct" href="#GDAL.computemediancutpct"><code>GDAL.computemediancutpct</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeMedianCutPCT(GDALRasterBandH hRed,
                        GDALRasterBandH hGreen,
                        GDALRasterBandH hBlue,
                        int(*)(int, int, void *) pfnIncludePixel,
                        int nColors,
                        GDALColorTableH hColorTable,
                        GDALProgressFunc pfnProgress,
                        void * pProgressArg) -&gt; int</code></pre><p>Compute optimal PCT for RGB image.</p><p><strong>Parameters</strong></p><ul><li><strong>hRed</strong>: Red input band.</li><li><strong>hGreen</strong>: Green input band.</li><li><strong>hBlue</strong>: Blue input band.</li><li><strong>pfnIncludePixel</strong>: function used to test which pixels should be included in the analysis. At this time this argument is ignored and all pixels are utilized. This should normally be NULL.</li><li><strong>nColors</strong>: the desired number of colors to be returned (2-256).</li><li><strong>hColorTable</strong>: the colors will be returned in this color table object.</li><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li></ul><p><strong>Returns</strong></p><p>returns CE<em>None on success or CE</em>Failure if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computeproximity" href="#GDAL.computeproximity"><code>GDAL.computeproximity</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeProximity(GDALRasterBandH hSrcBand,
                     GDALRasterBandH hProximityBand,
                     char ** papszOptions,
                     GDALProgressFunc pfnProgress,
                     void * pProgressArg) -&gt; CPLErr</code></pre><p>Compute the proximity of all pixels in the image to a set of pixels in the source image.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computerasterminmax" href="#GDAL.computerasterminmax"><code>GDAL.computerasterminmax</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeRasterMinMax(GDALRasterBandH hBand,
                        int bApproxOK,
                        double adfMinMax) -&gt; void</code></pre><p>Compute the min/max values for a band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.computerasterstatistics" href="#GDAL.computerasterstatistics"><code>GDAL.computerasterstatistics</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALComputeRasterStatistics(GDALRasterBandH hBand,
                            int bApproxOK,
                            double * pdfMin,
                            double * pdfMax,
                            double * pdfMean,
                            double * pdfStdDev,
                            GDALProgressFunc pfnProgress,
                            void * pProgressData) -&gt; CPLErr</code></pre><p>Compute image statistics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.contains" href="#GDAL.contains"><code>GDAL.contains</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Contains(OGRGeometryH hThis,
               OGRGeometryH hOther) -&gt; int</code></pre><p>Test for containment.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if hThis contains hOther geometry, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.contourgenerate" href="#GDAL.contourgenerate"><code>GDAL.contourgenerate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALContourGenerate(GDALRasterBandH hBand,
                    double dfContourInterval,
                    double dfContourBase,
                    int nFixedLevelCount,
                    double * padfFixedLevels,
                    int bUseNoData,
                    double dfNoDataValue,
                    void * hLayer,
                    int iIDField,
                    int iElevField,
                    GDALProgressFunc pfnProgress,
                    void * pProgressArg) -&gt; CPLErr</code></pre><p>Create vector contours from raster DEM.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: The band to read raster data from. The whole band will be processed.</li><li><strong>dfContourInterval</strong>: The elevation interval between contours generated.</li><li><strong>dfContourBase</strong>: The &quot;base&quot; relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the ContourBase would be 5.</li><li><strong>nFixedLevelCount</strong>: The number of fixed levels. If this is greater than zero, then fixed levels will be used, and ContourInterval and ContourBase are ignored.</li><li><strong>padfFixedLevels</strong>: The list of fixed contour levels at which contours should be generated. It will contain FixedLevelCount entries, and may be NULL if fixed levels are disabled (FixedLevelCount = 0).</li><li><strong>bUseNoData</strong>: If TRUE the dfNoDataValue will be used.</li><li><strong>dfNoDataValue</strong>: The value to use as a &quot;nodata&quot; value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</li><li><strong>hLayer</strong>: The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it. This is really of type OGRLayerH, but void * is used to avoid pulling the ogr_api.h file in here.</li><li><strong>iIDField</strong>: If not -1 this will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</li><li><strong>iElevField</strong>: If not -1 this will be used as a field index to indicate where the elevation value of the contour should be written.</li><li><strong>pfnProgress</strong>: A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</li><li><strong>pProgressArg</strong>: The callback data for the pfnProgress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.contourwriter" href="#GDAL.contourwriter"><code>GDAL.contourwriter</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRContourWriter(double dfLevel,
                 int nPoints,
                 double * padfX,
                 double * padfY,
                 void * pInfo) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.convexhull" href="#GDAL.convexhull"><code>GDAL.convexhull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ConvexHull(OGRGeometryH hTarget) -&gt; OGRGeometryH</code></pre><p>Compute convex hull.</p><p><strong>Parameters</strong></p><ul><li><strong>hTarget</strong>: The Geometry to calculate the convex hull of.</li></ul><p><strong>Returns</strong></p><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.coordinatedimension" href="#GDAL.coordinatedimension"><code>GDAL.coordinatedimension</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CoordinateDimension(OGRGeometryH hGeom) -&gt; int</code></pre><p>Get the dimension of the coordinates in this geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get the dimension of the coordinates from.</li></ul><p><strong>Returns</strong></p><p>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copybits" href="#GDAL.copybits"><code>GDAL.copybits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCopyBits(const GByte * pabySrcData,
             int nSrcOffset,
             int nSrcStep,
             GByte * pabyDstData,
             int nDstOffset,
             int nDstStep,
             int nBitCount,
             int nStepCount) -&gt; void</code></pre><p>Bitwise word copying.</p><p><strong>Parameters</strong></p><ul><li><strong>pabySrcData</strong>: the source data buffer.</li><li><strong>nSrcOffset</strong>: the offset (in bits) in pabySrcData to the start of the first word to copy.</li><li><strong>nSrcStep</strong>: the offset in bits from the start one source word to the start of the next.</li><li><strong>pabyDstData</strong>: the destination data buffer.</li><li><strong>nDstOffset</strong>: the offset (in bits) in pabyDstData to the start of the first word to copy over.</li><li><strong>nDstStep</strong>: the offset in bits from the start one word to the start of the next.</li><li><strong>nBitCount</strong>: the number of bits in a word to be copied.</li><li><strong>nStepCount</strong>: the number of words to copy.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copydatasetfiles" href="#GDAL.copydatasetfiles"><code>GDAL.copydatasetfiles</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCopyDatasetFiles(GDALDriverH hDriver,
                     const char * pszNewName,
                     const char * pszOldName) -&gt; CPLErr</code></pre><p>Copy the files of a dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copydatasource" href="#GDAL.copydatasource"><code>GDAL.copydatasource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Dr_CopyDataSource(OGRSFDriverH,
                      OGRDataSourceH,
                      const char *,
                      char **) -&gt; OGRDataSourceH</code></pre><p>This function creates a new datasource by copying all the layers from the source datasource.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver on which data source creation is based.</li><li><strong>hSrcDS</strong>: source datasource</li><li><strong>pszNewName</strong>: the name for the new data source.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: http://www.gdal.org/ogr_formats.html</li></ul><p><strong>Returns</strong></p><p>NULL is returned on failure, or a new OGRDataSource handle on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copygeogcsfrom" href="#GDAL.copygeogcsfrom"><code>GDAL.copygeogcsfrom</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRCopyGeogCSFrom(OGRSpatialReferenceH hSRS,
                  const OGRSpatialReferenceH hSrcSRS) -&gt; OGRErr</code></pre><p>Copy GEOGCS from another OGRSpatialReference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copylayer" href="#GDAL.copylayer"><code>GDAL.copylayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_CopyLayer(OGRDataSourceH,
                 OGRLayerH,
                 const char *,
                 char **) -&gt; OGRLayerH</code></pre><p>Duplicate an existing layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source where to create the new layer</li><li><strong>hSrcLayer</strong>: handle to the source layer.</li><li><strong>pszNewName</strong>: the name of the layer to create.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific.</li></ul><p><strong>Returns</strong></p><p>an handle to the layer, or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.copywords" href="#GDAL.copywords"><code>GDAL.copywords</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCopyWords(const void *CPL_RESTRICT pSrcData,
              GDALDataType eSrcType,
              int nSrcPixelOffset,
              void *CPL_RESTRICT pDstData,
              GDALDataType eDstType,
              int nDstPixelOffset,
              int nWordCount) -&gt; void</code></pre><p>Copy pixel words from buffer to buffer.</p><p><strong>Parameters</strong></p><ul><li><strong>pSrcData</strong>: Pointer to source data to be converted.</li><li><strong>eSrcType</strong>: the source data type (see GDALDataType enum)</li><li><strong>nSrcPixelStride</strong>: Source pixel stride (i.e. distance between 2 words), in bytes</li><li><strong>pDstData</strong>: Pointer to buffer where destination data should go</li><li><strong>eDstType</strong>: the destination data type (see GDALDataType enum)</li><li><strong>nDstPixelStride</strong>: Destination pixel stride (i.e. distance between 2 words), in bytes</li><li><strong>nWordCount</strong>: number of words to be copied</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.create" href="#GDAL.create"><code>GDAL.create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreate(GDALDriverH hDriver,
           const char * pszFilename,
           int nXSize,
           int nYSize,
           int nBands,
           GDALDataType eBandType,
           char ** papszOptions) -&gt; GDALDatasetH</code></pre><p>Create a new dataset with this driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createapproxtransformer" href="#GDAL.createapproxtransformer"><code>GDAL.createapproxtransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateApproxTransformer(GDALTransformerFunc pfnBaseTransformer,
                            void * pBaseTransformArg,
                            double dfMaxError) -&gt; void *</code></pre><p>Create an approximating transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pfnBaseTransformer</strong>: the high precision transformer which should be approximated.</li><li><strong>pBaseTransformArg</strong>: the callback argument for the high precision transformer.</li><li><strong>dfMaxError</strong>: the maximum cartesian error in the &quot;output&quot; space that is to be accepted in the linear approximation.</li></ul><p><strong>Returns</strong></p><p>callback pointer suitable for use with GDALApproxTransform(). It should be deallocated with GDALDestroyApproxTransformer().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createcolorramp" href="#GDAL.createcolorramp"><code>GDAL.createcolorramp</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateColorRamp(GDALColorTableH hTable,
                    int nStartIndex,
                    const GDALColorEntry * psStartColor,
                    int nEndIndex,
                    const GDALColorEntry * psEndColor) -&gt; void</code></pre><p>Create color ramp.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createcolortable" href="#GDAL.createcolortable"><code>GDAL.createcolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateColorTable(GDALPaletteInterp eInterp) -&gt; GDALColorTableH</code></pre><p>Construct a new color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createcopy" href="#GDAL.createcopy"><code>GDAL.createcopy</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateCopy(GDALDriverH hDriver,
               const char * pszFilename,
               GDALDatasetH hSrcDS,
               int bStrict,
               char ** papszOptions,
               GDALProgressFunc pfnProgress,
               void * pProgressData) -&gt; GDALDatasetH</code></pre><p>Create a copy of a dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createdatasetmaskband" href="#GDAL.createdatasetmaskband"><code>GDAL.createdatasetmaskband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateDatasetMaskBand(GDALDatasetH hDS,
                          int nFlags) -&gt; CPLErr</code></pre><p>Adds a mask band to the dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createdatasource" href="#GDAL.createdatasource"><code>GDAL.createdatasource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Dr_CreateDataSource(OGRSFDriverH,
                        const char *,
                        char **) -&gt; OGRDataSourceH</code></pre><p>This function attempts to create a new data source based on the passed driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver on which data source creation is based.</li><li><strong>pszName</strong>: the name for the new data source. UTF-8 encoded.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: http://www.gdal.org/ogr_formats.html</li></ul><p><strong>Returns</strong></p><p>NULL is returned on failure, or a new OGRDataSource handle on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfeature" href="#GDAL.createfeature"><code>GDAL.createfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_CreateFeature(OGRLayerH,
                    OGRFeatureH) -&gt; OGRErr</code></pre><p>Create and write a new feature within a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to write the feature to.</li><li><strong>hFeat</strong>: the handle of the feature to write to disk.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfield" href="#GDAL.createfield"><code>GDAL.createfield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_CreateField(OGRLayerH,
                  OGRFieldDefnH,
                  int) -&gt; OGRErr</code></pre><p>Create a new field on a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to write the field definition.</li><li><strong>hField</strong>: handle of the field definition to write to disk.</li><li><strong>bApproxOK</strong>: If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfromfgf" href="#GDAL.createfromfgf"><code>GDAL.createfromfgf</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateFromFgf(unsigned char * pabyData,
                    OGRSpatialReferenceH hSRS,
                    OGRGeometryH * phGeometry,
                    int nBytes,
                    int * pnBytesConsumed) -&gt; OGRErr</code></pre><p>Create a geometry object of the appropriate type from it&#39;s FGF (FDO Geometry Format) binary representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfromgml" href="#GDAL.createfromgml"><code>GDAL.createfromgml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateFromGML(const char * pszGML) -&gt; OGRGeometryH</code></pre><p>Create geometry from GML.</p><p><strong>Parameters</strong></p><ul><li><strong>pszGML</strong>: The GML fragment for the geometry.</li></ul><p><strong>Returns</strong></p><p>a geometry on success, or NULL on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfromgmltree" href="#GDAL.createfromgmltree"><code>GDAL.createfromgmltree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateFromGMLTree(const CPLXMLNode * psTree) -&gt; OGRGeometryH</code></pre><p>Create geometry from GML.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfromwkb" href="#GDAL.createfromwkb"><code>GDAL.createfromwkb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateFromWkb(unsigned char * pabyData,
                    OGRSpatialReferenceH hSRS,
                    OGRGeometryH * phGeometry,
                    int nBytes) -&gt; OGRErr</code></pre><p>Create a geometry object of the appropriate type from it&#39;s well known binary representation.</p><p><strong>Parameters</strong></p><ul><li><strong>pabyData</strong>: pointer to the input BLOB data.</li><li><strong>hSRS</strong>: handle to the spatial reference to be assigned to the created geometry object. This may be NULL.</li><li><strong>phGeometry</strong>: the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with OGR<em>G</em>DestroyGeometry() after use.</li><li><strong>nBytes</strong>: the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if all goes well, otherwise any of OGRERR</em>NOT<em>ENOUGH</em>DATA, OGRERR<em>UNSUPPORTED</em>GEOMETRY<em>TYPE, or OGRERR</em>CORRUPT_DATA may be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createfromwkt" href="#GDAL.createfromwkt"><code>GDAL.createfromwkt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateFromWkt(char ** ppszData,
                    OGRSpatialReferenceH hSRS,
                    OGRGeometryH * phGeometry) -&gt; OGRErr</code></pre><p>Create a geometry object of the appropriate type from it&#39;s well known text representation.</p><p><strong>Parameters</strong></p><ul><li><strong>ppszData</strong>: input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed.</li><li><strong>hSRS</strong>: handle to the spatial reference to be assigned to the created geometry object. This may be NULL.</li><li><strong>phGeometry</strong>: the newly created geometry object will be assigned to the indicated handle on return. This will be NULL if the method fails. If not NULL, *phGeometry should be freed with OGR<em>G</em>DestroyGeometry() after use.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if all goes well, otherwise any of OGRERR</em>NOT<em>ENOUGH</em>DATA, OGRERR<em>UNSUPPORTED</em>GEOMETRY<em>TYPE, or OGRERR</em>CORRUPT_DATA may be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategcprefinetransformer" href="#GDAL.creategcprefinetransformer"><code>GDAL.creategcprefinetransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGCPRefineTransformer(int nGCPCount,
                               const GDAL_GCP * pasGCPList,
                               int nReqOrder,
                               int bReversed,
                               double tolerance,
                               int minimumGcps) -&gt; void *</code></pre><p>Create GCP based polynomial transformer, with a tolerance threshold to discard GCPs that transform badly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategcptransformer" href="#GDAL.creategcptransformer"><code>GDAL.creategcptransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGCPTransformer(int nGCPCount,
                         const GDAL_GCP * pasGCPList,
                         int nReqOrder,
                         int bReversed) -&gt; void *</code></pre><p>Create GCP based polynomial transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>nGCPCount</strong>: the number of GCPs in pasGCPList.</li><li><strong>pasGCPList</strong>: an array of GCPs to be used as input.</li><li><strong>nReqOrder</strong>: the requested polynomial order. It should be 1, 2 or 3.</li><li><strong>nGCPCount</strong>: the number of GCPs in pasGCPList.</li><li><strong>pasGCPList</strong>: an array of GCPs to be used as input.</li><li><strong>nReqOrder</strong>: the requested polynomial order. It should be 1, 2 or 3.</li><li><strong>bReversed</strong>: set it to TRUE to compute the reversed transformation.</li></ul><p><strong>Returns</strong></p><p>the transform argument or NULL if creation fails.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategenimgprojtransformer" href="#GDAL.creategenimgprojtransformer"><code>GDAL.creategenimgprojtransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGenImgProjTransformer(GDALDatasetH hSrcDS,
                                const char * pszSrcWKT,
                                GDALDatasetH hDstDS,
                                const char * pszDstWKT,
                                int bGCPUseOK,
                                double dfGCPErrorThreshold,
                                int nOrder) -&gt; void *</code></pre><p>Create image to image transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: source dataset, or NULL.</li><li><strong>pszSrcWKT</strong>: the coordinate system for the source dataset. If NULL, it will be read from the dataset itself.</li><li><strong>hDstDS</strong>: destination dataset (or NULL).</li><li><strong>pszDstWKT</strong>: the coordinate system for the destination dataset. If NULL, and hDstDS not NULL, it will be read from the destination dataset.</li><li><strong>bGCPUseOK</strong>: TRUE if GCPs should be used if the geotransform is not available on the source dataset (not destination).</li><li><strong>dfGCPErrorThreshold</strong>: ignored/deprecated.</li><li><strong>nOrder</strong>: the maximum order to use for GCP derived polynomials if possible. Use 0 to autoselect, or -1 for thin plate splines.</li></ul><p><strong>Returns</strong></p><p>handle suitable for use GDALGenImgProjTransform(), and to be deallocated with GDALDestroyGenImgProjTransformer().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategenimgprojtransformer2" href="#GDAL.creategenimgprojtransformer2"><code>GDAL.creategenimgprojtransformer2</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGenImgProjTransformer2(GDALDatasetH hSrcDS,
                                 GDALDatasetH hDstDS,
                                 char ** papszOptions) -&gt; void *</code></pre><p>Create image to image transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: source dataset, or NULL.</li><li><strong>hDstDS</strong>: destination dataset (or NULL).</li><li><strong>papszOptions</strong>: NULL-terminated list of string options (or NULL).</li></ul><p><strong>Returns</strong></p><p>handle suitable for use GDALGenImgProjTransform(), and to be deallocated with GDALDestroyGenImgProjTransformer() or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategenimgprojtransformer3" href="#GDAL.creategenimgprojtransformer3"><code>GDAL.creategenimgprojtransformer3</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGenImgProjTransformer3(const char * pszSrcWKT,
                                 const double * padfSrcGeoTransform,
                                 const char * pszDstWKT,
                                 const double * padfDstGeoTransform) -&gt; void *</code></pre><p>Create image to image transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pszSrcWKT</strong>: source WKT (or NULL).</li><li><strong>padfSrcGeoTransform</strong>: source geotransform (or NULL).</li><li><strong>pszDstWKT</strong>: destination WKT (or NULL).</li><li><strong>padfDstGeoTransform</strong>: destination geotransform (or NULL).</li></ul><p><strong>Returns</strong></p><p>handle suitable for use GDALGenImgProjTransform(), and to be deallocated with GDALDestroyGenImgProjTransformer() or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategeoloctransformer" href="#GDAL.creategeoloctransformer"><code>GDAL.creategeoloctransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateGeoLocTransformer(GDALDatasetH hBaseDS,
                            char ** papszGeolocationInfo,
                            int bReversed) -&gt; void *</code></pre><p>Create GeoLocation transformer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategeometry" href="#GDAL.creategeometry"><code>GDAL.creategeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateGeometry(OGRwkbGeometryType eGeometryType) -&gt; OGRGeometryH</code></pre><p>Create an empty geometry of desired type.</p><p><strong>Parameters</strong></p><ul><li><strong>eGeometryType</strong>: the type code of the geometry to be created.</li></ul><p><strong>Returns</strong></p><p>handle to the newly create geometry or NULL on failure. Should be freed with OGR<em>G</em>DestroyGeometry() after use.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategeometryfromjson" href="#GDAL.creategeometryfromjson"><code>GDAL.creategeometryfromjson</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_CreateGeometryFromJson(const char *) -&gt; OGRGeometryH</code></pre><p>Create a OGR geometry from a GeoJSON geometry object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.creategeomfield" href="#GDAL.creategeomfield"><code>GDAL.creategeomfield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_CreateGeomField(OGRLayerH hLayer,
                      OGRGeomFieldDefnH hFieldDefn,
                      int bForce) -&gt; OGRErr</code></pre><p>Create a new geometry field on a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to write the field definition.</li><li><strong>hField</strong>: handle of the geometry field definition to write to disk.</li><li><strong>bApproxOK</strong>: If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createlayer" href="#GDAL.createlayer"><code>GDAL.createlayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_CreateLayer(OGRDataSourceH,
                   const char *,
                   OGRSpatialReferenceH,
                   OGRwkbGeometryType,
                   char **) -&gt; OGRLayerH</code></pre><p>This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: The dataset handle.</li><li><strong>pszName</strong>: the name for the new layer. This should ideally not match any existing layer on the datasource.</li><li><strong>hSpatialRef</strong>: handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available.</li><li><strong>eType</strong>: the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: http://www.gdal.org/ogr_formats.html</li></ul><p><strong>Returns</strong></p><p>NULL is returned on failure, or a new OGRLayer handle on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createmaskband" href="#GDAL.createmaskband"><code>GDAL.createmaskband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateMaskBand(GDALRasterBandH hBand,
                   int nFlags) -&gt; CPLErr</code></pre><p>Adds a mask band to the current band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createpansharpenedvrt" href="#GDAL.createpansharpenedvrt"><code>GDAL.createpansharpenedvrt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreatePansharpenedVRT(const char * pszXML,
                          GDALRasterBandH hPanchroBand,
                          int nInputSpectralBands,
                          GDALRasterBandH * pahInputSpectralBands) -&gt; GDALDatasetH</code></pre><p>Create a virtual pansharpened dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>pszXML</strong>: Pansharpened VRT XML where &lt;SpectralBand&gt; elements have no explicit SourceFilename and SourceBand. The spectral bands in the XML will be assigned the successive values of the pahInputSpectralBands array. Must not be NULL.</li><li><strong>hPanchroBand</strong>: Panchromatic band. Must not be NULL.</li><li><strong>nInputSpectralBands</strong>: Number of input spectral bands. Must be greater than zero.</li><li><strong>pahInputSpectralBands</strong>: Array of nInputSpectralBands spectral bands.</li></ul><p><strong>Returns</strong></p><p>NULL on failure, or a new virtual dataset handle on success to be closed with GDALClose().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createrasterattributetable" href="#GDAL.createrasterattributetable"><code>GDAL.createrasterattributetable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateRasterAttributeTable(void) -&gt; GDALRasterAttributeTableH</code></pre><p>Construct empty table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createreprojectiontransformer" href="#GDAL.createreprojectiontransformer"><code>GDAL.createreprojectiontransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateReprojectionTransformer(const char * pszSrcWKT,
                                  const char * pszDstWKT) -&gt; void *</code></pre><p>Create reprojection transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pszSrcWKT</strong>: the coordinate system for the source coordinate system.</li><li><strong>pszDstWKT</strong>: the coordinate system for the destination coordinate system.</li></ul><p><strong>Returns</strong></p><p>Handle for use with GDALReprojectionTransform(), or NULL if the system fails to initialize the reprojection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createrpctransformer" href="#GDAL.createrpctransformer"><code>GDAL.createrpctransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateRPCTransformer(GDALRPCInfo * psRPC,
                         int bReversed,
                         double dfPixErrThreshold,
                         char ** papszOptions) -&gt; void *</code></pre><p>Create an RPC based transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>psRPCInfo</strong>: Definition of the RPC parameters.</li><li><strong>bReversed</strong>: If true &quot;forward&quot; transformation will be lat/long to pixel/line instead of the normal pixel/line to lat/long.</li><li><strong>dfPixErrThreshold</strong>: the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations). Starting with GDAL 2.1, this may also be set through the RPC<em>PIXEL</em>ERROR_THRESHOLD transformer option. If a negative or null value is provided, then this defaults to 0.1 pixel.</li><li><strong>papszOptions</strong>: Other transformer options (i.e. RPC_HEIGHT=z).</li></ul><p><strong>Returns</strong></p><p>transformer callback data (deallocate with GDALDestroyTransformer()).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createsimilartransformer" href="#GDAL.createsimilartransformer"><code>GDAL.createsimilartransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateSimilarTransformer(void * pTransformArg,
                             double dfRatioX,
                             double dfRatioY) -&gt; void *</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.createtpstransformer" href="#GDAL.createtpstransformer"><code>GDAL.createtpstransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALCreateTPSTransformer(int nGCPCount,
                         const GDAL_GCP * pasGCPList,
                         int bReversed) -&gt; void *</code></pre><p>Create Thin Plate Spline transformer from GCPs.</p><p><strong>Parameters</strong></p><ul><li><strong>nGCPCount</strong>: the number of GCPs in pasGCPList.</li><li><strong>pasGCPList</strong>: an array of GCPs to be used as input.</li><li><strong>bReversed</strong>: set it to TRUE to compute the reversed transformation.</li></ul><p><strong>Returns</strong></p><p>the transform argument or NULL if creation fails.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.crosses" href="#GDAL.crosses"><code>GDAL.crosses</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Crosses(OGRGeometryH hThis,
              OGRGeometryH hOther) -&gt; int</code></pre><p>Test for crossing.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if they are crossing, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetadviseread" href="#GDAL.datasetadviseread"><code>GDAL.datasetadviseread</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetAdviseRead(GDALDatasetH hDS,
                      int nXOff,
                      int nYOff,
                      int nXSize,
                      int nYSize,
                      int nBufXSize,
                      int nBufYSize,
                      GDALDataType eDT,
                      int nBandCount,
                      int * panBandMap,
                      char ** papszOptions) -&gt; CPLErr</code></pre><p>Advise driver of upcoming read requests.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetcommittransaction" href="#GDAL.datasetcommittransaction"><code>GDAL.datasetcommittransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetCommitTransaction(GDALDatasetH hDS) -&gt; OGRErr</code></pre><p>For datasources which support transactions, CommitTransaction commits a transaction.</p><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetcopylayer" href="#GDAL.datasetcopylayer"><code>GDAL.datasetcopylayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetCopyLayer(GDALDatasetH hDS,
                     OGRLayerH hSrcLayer,
                     const char * pszNewName,
                     char ** papszOptions) -&gt; OGRLayerH</code></pre><p>Duplicate an existing layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>hSrcLayer</strong>: source layer.</li><li><strong>pszNewName</strong>: the name of the layer to create.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific.</li></ul><p><strong>Returns</strong></p><p>an handle to the layer, or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetcopywholeraster" href="#GDAL.datasetcopywholeraster"><code>GDAL.datasetcopywholeraster</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetCopyWholeRaster(GDALDatasetH hSrcDS,
                           GDALDatasetH hDstDS,
                           char ** papszOptions,
                           GDALProgressFunc pfnProgress,
                           void * pProgressData) -&gt; CPLErr</code></pre><p>Copy all dataset raster data.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: the source dataset</li><li><strong>hDstDS</strong>: the destination dataset</li><li><strong>papszOptions</strong>: transfer hints in &quot;StringList&quot; Name=Value format.</li><li><strong>pfnProgress</strong>: progress reporting function.</li><li><strong>pProgressData</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success, or CE</em>Failure on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetcreatelayer" href="#GDAL.datasetcreatelayer"><code>GDAL.datasetcreatelayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetCreateLayer(GDALDatasetH hDS,
                       const char * pszName,
                       OGRSpatialReferenceH hSpatialRef,
                       OGRwkbGeometryType eGType,
                       char ** papszOptions) -&gt; OGRLayerH</code></pre><p>This function attempts to create a new layer on the dataset with the indicated name, coordinate system, geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle</li><li><strong>pszName</strong>: the name for the new layer. This should ideally not match any existing layer on the datasource.</li><li><strong>hSpatialRef</strong>: the coordinate system to use for the new layer, or NULL if no coordinate system is available.</li><li><strong>eGType</strong>: the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written.</li><li><strong>papszOptions</strong>: a StringList of name=value options. Options are driver specific.</li></ul><p><strong>Returns</strong></p><p>NULL is returned on failure, or a new OGRLayer handle on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetdeletelayer" href="#GDAL.datasetdeletelayer"><code>GDAL.datasetdeletelayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetDeleteLayer(GDALDatasetH hDS,
                       int iLayer) -&gt; OGRErr</code></pre><p>Delete the indicated layer from the datasource.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>iLayer</strong>: the index of the layer to delete.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, or OGRERR</em>UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetexecutesql" href="#GDAL.datasetexecutesql"><code>GDAL.datasetexecutesql</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetExecuteSQL(GDALDatasetH hDS,
                      const char * pszStatement,
                      OGRGeometryH hSpatialFilter,
                      const char * pszDialect) -&gt; OGRLayerH</code></pre><p>Execute an SQL statement against the data store.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>pszStatement</strong>: the SQL statement to execute.</li><li><strong>hSpatialFilter</strong>: geometry which represents a spatial filter. Can be NULL.</li><li><strong>pszDialect</strong>: allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.</li></ul><p><strong>Returns</strong></p><p>an OGRLayer containing the results of the query. Deallocate with ReleaseResultSet().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetlayer" href="#GDAL.datasetgetlayer"><code>GDAL.datasetgetlayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetLayer(GDALDatasetH hDS,
                    int iLayer) -&gt; OGRLayerH</code></pre><p>Fetch a layer by index.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>iLayer</strong>: a layer number between 0 and GetLayerCount()-1.</li></ul><p><strong>Returns</strong></p><p>the layer, or NULL if iLayer is out of range or an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetlayerbyname" href="#GDAL.datasetgetlayerbyname"><code>GDAL.datasetgetlayerbyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetLayerByName(GDALDatasetH hDS,
                          const char * pszName) -&gt; OGRLayerH</code></pre><p>Fetch a layer by name.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>pszName</strong>: the layer name of the layer to fetch.</li></ul><p><strong>Returns</strong></p><p>the layer, or NULL if Layer is not found or an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetlayercount" href="#GDAL.datasetgetlayercount"><code>GDAL.datasetgetlayercount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetLayerCount(GDALDatasetH hDS) -&gt; int</code></pre><p>Get the number of layers in this dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li></ul><p><strong>Returns</strong></p><p>layer count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetnextfeature" href="#GDAL.datasetgetnextfeature"><code>GDAL.datasetgetnextfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetNextFeature(GDALDatasetH hDS,
                          OGRLayerH * phBelongingLayer,
                          double * pdfProgressPct,
                          GDALProgressFunc pfnProgress,
                          void * pProgressData) -&gt; OGRFeatureH</code></pre><p>Fetch the next available feature from this dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: dataset handle.</li><li><strong>phBelongingLayer</strong>: a pointer to a OGRLayer* variable to receive the layer to which the object belongs to, or NULL. It is possible that the output of *ppoBelongingLayer to be NULL despite the feature not being NULL.</li><li><strong>pdfProgressPct</strong>: a pointer to a double variable to receive the percentage progress (in [0,1] range), or NULL. On return, the pointed value might be negative if determining the progress is not possible.</li><li><strong>pfnProgress</strong>: a progress callback to report progress (for GetNextFeature() calls that might have a long duration) and offer cancellation possibility, or NULL</li><li><strong>pProgressData</strong>: user data provided to pfnProgress, or NULL</li></ul><p><strong>Returns</strong></p><p>a feature, or NULL if no more features are available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetstyletable" href="#GDAL.datasetgetstyletable"><code>GDAL.datasetgetstyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetStyleTable(GDALDatasetH hDS) -&gt; OGRStyleTableH</code></pre><p>Returns dataset style table.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle</li></ul><p><strong>Returns</strong></p><p>handle to a style table which should not be modified or freed by the caller.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgettiledvirtualmem" href="#GDAL.datasetgettiledvirtualmem"><code>GDAL.datasetgettiledvirtualmem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetTiledVirtualMem(GDALDatasetH hDS,
                              GDALRWFlag eRWFlag,
                              int nXOff,
                              int nYOff,
                              int nXSize,
                              int nYSize,
                              int nTileXSize,
                              int nTileYSize,
                              GDALDataType eBufType,
                              int nBandCount,
                              int * panBandMap,
                              GDALTileOrganization eTileOrganization,
                              size_t nCacheSize,
                              int bSingleThreadUsage,
                              char ** papszOptions) -&gt; CPLVirtualMem *</code></pre><p>Create a CPLVirtualMem object from a GDAL dataset object, with tiling organization.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: Dataset object</li><li><strong>eRWFlag</strong>: Either GF<em>Read to read a region of data, or GF</em>Write to write a region of data.</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be accessed. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be accessed. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be accessed in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be accessed in lines.</li><li><strong>nTileXSize</strong>: the width of the tiles.</li><li><strong>nTileYSize</strong>: the height of the tiles.</li><li><strong>eBufType</strong>: the type of the pixel values in the data buffer. The pixel values will automatically be translated to/from the GDALRasterBand data type as needed.</li><li><strong>nBandCount</strong>: the number of bands being read or written.</li><li><strong>panBandMap</strong>: the list of nBandCount band numbers being read/written. Note band numbers are 1 based. This may be NULL to select the first nBandCount bands.</li><li><strong>eTileOrganization</strong>: tile organization.</li><li><strong>nCacheSize</strong>: size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM)</li><li><strong>bSingleThreadUsage</strong>: set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. If set to FALSE, CPLVirtualMemDeclareThread() must be called.</li><li><strong>papszOptions</strong>: NULL terminated list of options. Unused for now.</li></ul><p><strong>Returns</strong></p><p>a virtual memory object that must be freed by CPLVirtualMemFree(), or NULL in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetgetvirtualmem" href="#GDAL.datasetgetvirtualmem"><code>GDAL.datasetgetvirtualmem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetGetVirtualMem(GDALDatasetH hDS,
                         GDALRWFlag eRWFlag,
                         int nXOff,
                         int nYOff,
                         int nXSize,
                         int nYSize,
                         int nBufXSize,
                         int nBufYSize,
                         GDALDataType eBufType,
                         int nBandCount,
                         int * panBandMap,
                         int nPixelSpace,
                         GIntBig nLineSpace,
                         GIntBig nBandSpace,
                         size_t nCacheSize,
                         size_t nPageSizeHint,
                         int bSingleThreadUsage,
                         char ** papszOptions) -&gt; CPLVirtualMem *</code></pre><p>Create a CPLVirtualMem object from a GDAL dataset object.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: Dataset object</li><li><strong>eRWFlag</strong>: Either GF<em>Read to read a region of data, or GF</em>Write to write a region of data.</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be accessed. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be accessed. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be accessed in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be accessed in lines.</li><li><strong>nBufXSize</strong>: the width of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>nBufYSize</strong>: the height of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>eBufType</strong>: the type of the pixel values in the data buffer. The pixel values will automatically be translated to/from the GDALRasterBand data type as needed.</li><li><strong>nBandCount</strong>: the number of bands being read or written.</li><li><strong>panBandMap</strong>: the list of nBandCount band numbers being read/written. Note band numbers are 1 based. This may be NULL to select the first nBandCount bands.</li><li><strong>nPixelSpace</strong>: The byte offset from the start of one pixel value in the buffer to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</li><li><strong>nLineSpace</strong>: The byte offset from the start of one scanline in the buffer to the start of the next. If defaulted (0) the size of the datatype eBufType * nBufXSize is used.</li><li><strong>nBandSpace</strong>: the byte offset from the start of one bands data to the start of the next. If defaulted (0) the value will be nLineSpace * nBufYSize implying band sequential organization of the data buffer.</li><li><strong>nCacheSize</strong>: size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM)</li><li><strong>nPageSizeHint</strong>: hint for the page size. Must be a multiple of the system page size, returned by CPLGetPageSize(). Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size.</li><li><strong>bSingleThreadUsage</strong>: set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. If set to FALSE, CPLVirtualMemDeclareThread() must be called.</li><li><strong>papszOptions</strong>: NULL terminated list of options. Unused for now.</li></ul><p><strong>Returns</strong></p><p>a virtual memory object that must be freed by CPLVirtualMemFree(), or NULL in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetrasterio" href="#GDAL.datasetrasterio"><code>GDAL.datasetrasterio</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetRasterIO(GDALDatasetH hDS,
                    GDALRWFlag eRWFlag,
                    int nXOff,
                    int nYOff,
                    int nXSize,
                    int nYSize,
                    void * pData,
                    int nBufXSize,
                    int nBufYSize,
                    GDALDataType eBufType,
                    int nBandCount,
                    int * panBandMap,
                    int nPixelSpace,
                    int nLineSpace,
                    int nBandSpace) -&gt; CPLErr</code></pre><p>Read/write a region of image data from multiple bands.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetrasterioex" href="#GDAL.datasetrasterioex"><code>GDAL.datasetrasterioex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetRasterIOEx(GDALDatasetH hDS,
                      GDALRWFlag eRWFlag,
                      int nXOff,
                      int nYOff,
                      int nXSize,
                      int nYSize,
                      void * pData,
                      int nBufXSize,
                      int nBufYSize,
                      GDALDataType eBufType,
                      int nBandCount,
                      int * panBandMap,
                      GSpacing nPixelSpace,
                      GSpacing nLineSpace,
                      GSpacing nBandSpace,
                      GDALRasterIOExtraArg * psExtraArg) -&gt; CPLErr</code></pre><p>Read/write a region of image data from multiple bands.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetreleaseresultset" href="#GDAL.datasetreleaseresultset"><code>GDAL.datasetreleaseresultset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetReleaseResultSet(GDALDatasetH hDS,
                            OGRLayerH hLayer) -&gt; void</code></pre><p>Release results of ExecuteSQL().</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>hLayer</strong>: the result of a previous ExecuteSQL() call.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetresetreading" href="#GDAL.datasetresetreading"><code>GDAL.datasetresetreading</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetResetReading(GDALDatasetH hDS) -&gt; void</code></pre><p>Reset feature reading to start on the first feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: dataset handle</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetrollbacktransaction" href="#GDAL.datasetrollbacktransaction"><code>GDAL.datasetrollbacktransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetRollbackTransaction(GDALDatasetH hDS) -&gt; OGRErr</code></pre><p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.</p><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetsetstyletable" href="#GDAL.datasetsetstyletable"><code>GDAL.datasetsetstyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetSetStyleTable(GDALDatasetH hDS,
                         OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set dataset style table.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle</li><li><strong>hStyleTable</strong>: style table handle to set</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetsetstyletabledirectly" href="#GDAL.datasetsetstyletabledirectly"><code>GDAL.datasetsetstyletabledirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetSetStyleTableDirectly(GDALDatasetH hDS,
                                 OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set dataset style table.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle</li><li><strong>hStyleTable</strong>: style table handle to set</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasetstarttransaction" href="#GDAL.datasetstarttransaction"><code>GDAL.datasetstarttransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetStartTransaction(GDALDatasetH hDS,
                            int bForce) -&gt; OGRErr</code></pre><p>For datasources which support transactions, StartTransaction creates a transaction.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>bForce</strong>: can be set to TRUE if an emulation, possibly slow, of a transaction mechanism is acceptable.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datasettestcapability" href="#GDAL.datasettestcapability"><code>GDAL.datasettestcapability</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDatasetTestCapability(GDALDatasetH hDS,
                          const char * pszCap) -&gt; int</code></pre><p>Test if capability is available.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: the dataset handle.</li><li><strong>pszCap</strong>: the capability to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if capability available otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datatypeiscomplex" href="#GDAL.datatypeiscomplex"><code>GDAL.datatypeiscomplex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDataTypeIsComplex(GDALDataType) -&gt; int</code></pre><p>Is data type complex?</p><p><strong>Returns</strong></p><p>TRUE if the passed type is complex (one of GDT<em>CInt16, GDT</em>CInt32, GDT<em>CFloat32 or GDT</em>CFloat64), that is it consists of a real and imaginary component.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.datatypeunion" href="#GDAL.datatypeunion"><code>GDAL.datatypeunion</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDataTypeUnion(GDALDataType,
                  GDALDataType) -&gt; GDALDataType</code></pre><p>Return the smallest data type that can fully express both input data types.</p><p><strong>Parameters</strong></p><ul><li><strong>eType1</strong>: first data type.</li><li><strong>eType2</strong>: second data type.</li></ul><p><strong>Returns</strong></p><p>a data type able to express eType1 and eType2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dectodms" href="#GDAL.dectodms"><code>GDAL.dectodms</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDecToDMS(double,
             const char *,
             int) -&gt; const char *</code></pre><p>Translate a decimal degrees value to a DMS string with hemisphere.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dectopackeddms" href="#GDAL.dectopackeddms"><code>GDAL.dectopackeddms</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDecToPackedDMS(double) -&gt; double</code></pre><p>Convert decimal degrees into packed DMS value (DDDMMMSSS.SS).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.defaulterrorhandler" href="#GDAL.defaulterrorhandler"><code>GDAL.defaulterrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLDefaultErrorHandler(CPLErr eErrClass,
                       CPLErrorNum nError,
                       const char * pszErrorMsg) -&gt; void</code></pre><p>Default error handler.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deinitgcps" href="#GDAL.deinitgcps"><code>GDAL.deinitgcps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDeinitGCPs(int,
               GDAL_GCP *) -&gt; void</code></pre><p>De-initialize an array of GCPs (initialized with GDALInitGCPs())</p><p><strong>Parameters</strong></p><ul><li><strong>nCount</strong>: number of GCPs in psGCP</li><li><strong>psGCP</strong>: array of GCPs of size nCount.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.delaunaytriangulation" href="#GDAL.delaunaytriangulation"><code>GDAL.delaunaytriangulation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_DelaunayTriangulation(OGRGeometryH hThis,
                            double dfTolerance,
                            int bOnlyEdges) -&gt; OGRGeometryH</code></pre><p>Return a Delaunay triangulation of the vertices of the geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>dfTolerance</strong>: optional snapping tolerance to use for improved robustness</li><li><strong>bOnlyEdges</strong>: if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</li></ul><p><strong>Returns</strong></p><p>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletedataset" href="#GDAL.deletedataset"><code>GDAL.deletedataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDeleteDataset(GDALDriverH hDriver,
                  const char * pszFilename) -&gt; CPLErr</code></pre><p>Delete named dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletedatasource" href="#GDAL.deletedatasource"><code>GDAL.deletedatasource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Dr_DeleteDataSource(OGRSFDriverH,
                        const char *) -&gt; OGRErr</code></pre><p>Delete a datasource.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver on which data source deletion is based.</li><li><strong>pszDataSource</strong>: the name of the datasource to delete.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, and OGRERR</em>UNSUPPORTED_OPERATION if this is not supported by this driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletefeature" href="#GDAL.deletefeature"><code>GDAL.deletefeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_DeleteFeature(OGRLayerH,
                    GIntBig) -&gt; OGRErr</code></pre><p>Delete feature from layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li><li><strong>nFID</strong>: the feature id to be deleted from the layer</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if the operation works, otherwise an appropriate error code (e.g OGRERR</em>NON<em>EXISTING</em>FEATURE if the feature does not exist).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletefield" href="#GDAL.deletefield"><code>GDAL.deletefield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_DeleteField(OGRLayerH,
                  int iField) -&gt; OGRErr</code></pre><p>Delete an existing field on a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li><li><strong>iField</strong>: index of the field to delete.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletefielddefn" href="#GDAL.deletefielddefn"><code>GDAL.deletefielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_DeleteFieldDefn(OGRFeatureDefnH hDefn,
                       int iField) -&gt; OGRErr</code></pre><p>Delete an existing field definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition.</li><li><strong>iField</strong>: the index of the field definition.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE in case of success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletegeomfielddefn" href="#GDAL.deletegeomfielddefn"><code>GDAL.deletegeomfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_DeleteGeomFieldDefn(OGRFeatureDefnH hDefn,
                           int iGeomField) -&gt; OGRErr</code></pre><p>Delete an existing geometry field definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition.</li><li><strong>iGeomField</strong>: the index of the geometry field definition.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE in case of success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deletelayer" href="#GDAL.deletelayer"><code>GDAL.deletelayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_DeleteLayer(OGRDataSourceH,
                   int) -&gt; OGRErr</code></pre><p>Delete the indicated layer from the datasource.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the datasource</li><li><strong>iLayer</strong>: the index of the layer to delete.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, or OGRERR</em>UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deleterasternodatavalue" href="#GDAL.deleterasternodatavalue"><code>GDAL.deleterasternodatavalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDeleteRasterNoDataValue(GDALRasterBandH hBand) -&gt; CPLErr</code></pre><p>Remove the no data value for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.demprocessing" href="#GDAL.demprocessing"><code>GDAL.demprocessing</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDEMProcessing(const char * pszDest,
                  GDALDatasetH hSrcDataset,
                  const char * pszProcessing,
                  const char * pszColorFilename,
                  const GDALDEMProcessingOptions * psOptionsIn,
                  int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Apply a DEM processing.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path.</li><li><strong>hSrcDataset</strong>: the source dataset handle.</li><li><strong>pszProcessing</strong>: the processing to apply (one of &quot;hillshade&quot;, &quot;slope&quot;, &quot;aspect&quot;, &quot;color-relief&quot;, &quot;TRI&quot;, &quot;TPI&quot;, &quot;Roughness&quot;)</li><li><strong>pszColorFilename</strong>: color file (mandatory for &quot;color-relief&quot; processing, should be NULL otherwise)</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALDEMProcessingOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred or NULL.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose()) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.demprocessingoptionsfree" href="#GDAL.demprocessingoptionsfree"><code>GDAL.demprocessingoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDEMProcessingOptionsFree(GDALDEMProcessingOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALDEMProcessingOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALDEMProcessing().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.demprocessingoptionsnew" href="#GDAL.demprocessingoptionsnew"><code>GDAL.demprocessingoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDEMProcessingOptionsNew(char ** papszArgv,
                            GDALDEMProcessingOptionsForBinary * psOptionsForBinary) -&gt; GDALDEMProcessingOptions *</code></pre><p>Allocates a GDALDEMProcessingOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdaldem utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALDEMProcessingOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALDEMProcessingOptions struct. Must be freed with GDALDEMProcessingOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.demprocessingoptionssetprogress" href="#GDAL.demprocessingoptionssetprogress"><code>GDAL.demprocessingoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDEMProcessingOptionsSetProgress(GDALDEMProcessingOptions * psOptions,
                                    GDALProgressFunc pfnProgress,
                                    void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALDEMProcessing().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><pre><code class="language-none">GDAL.depsjl_path</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dereference" href="#GDAL.dereference"><code>GDAL.dereference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_Dereference(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Decrements the reference count by one.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li></ul><p><strong>Returns</strong></p><p>the updated reference count.</p></div></div><div><div><pre><code class="language-none">OGR_L_Dereference(OGRLayerH hLayer) -&gt; int</code></pre></div></div><div><div><pre><code class="language-none">OGR_DS_Dereference(OGRDataSourceH hDataSource) -&gt; int</code></pre></div></div><div><div><pre><code class="language-none">OSRDereference(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Decrements the reference count by one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dereferencedataset" href="#GDAL.dereferencedataset"><code>GDAL.dereferencedataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDereferenceDataset(GDALDatasetH hDataset) -&gt; int</code></pre><p>Subtract one from dataset reference count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deregisterdriver" href="#GDAL.deregisterdriver"><code>GDAL.deregisterdriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDeregisterDriver(GDALDriverH hDriver) -&gt; void</code></pre><p>Deregister the passed driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.deserializetransformer" href="#GDAL.deserializetransformer"><code>GDAL.deserializetransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDeserializeTransformer(CPLXMLNode * psTree,
                           GDALTransformerFunc * ppfnFunc,
                           void ** ppTransformArg) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroy" href="#GDAL.destroy"><code>GDAL.destroy</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroy(void) -&gt; void</code></pre></div></div><div><div><pre><code class="language-none">GDAL_CG_Destroy(GDALContourGeneratorH hCG) -&gt; void</code></pre><p>Destroy contour generator.</p></div></div><div><div><pre><code class="language-none">OGR_Fld_Destroy(OGRFieldDefnH hDefn) -&gt; void</code></pre><p>Destroy a field definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to destroy.</li></ul></div></div><div><div><pre><code class="language-none">OGR_GFld_Destroy(OGRGeomFieldDefnH hDefn) -&gt; void</code></pre><p>Destroy a geometry field definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition to destroy.</li></ul></div></div><div><div><pre><code class="language-none">OGR_FD_Destroy(OGRFeatureDefnH hDefn) -&gt; void</code></pre><p>Destroy a feature definition object and release all memory associated with it.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to be destroyed.</li></ul></div></div><div><div><pre><code class="language-none">OGR_F_Destroy(OGRFeatureH hFeat) -&gt; void</code></pre><p>Destroy feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to destroy.</li></ul></div></div><div><div><pre><code class="language-none">OGR_DS_Destroy(OGRDataSourceH) -&gt; void</code></pre><p>Closes opened datasource and releases allocated resources.</p><p><strong>Parameters</strong></p><ul><li><strong>hDataSource</strong>: handle to allocated datasource object.</li></ul></div></div><div><div><pre><code class="language-none">OGR_SM_Destroy(OGRStyleMgrH hSM) -&gt; void</code></pre><p>Destroy Style Manager.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager to destroy.</li></ul></div></div><div><div><pre><code class="language-none">OGR_ST_Destroy(OGRStyleToolH hST) -&gt; void</code></pre><p>Destroy Style Tool.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool to destroy.</li></ul></div></div><div><div><pre><code class="language-none">OGR_STBL_Destroy(OGRStyleTableH hSTBL) -&gt; void</code></pre><p>Destroy Style Table.</p><p><strong>Parameters</strong></p><ul><li><strong>hSTBL</strong>: handle to the style table to destroy.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroyapproxtransformer" href="#GDAL.destroyapproxtransformer"><code>GDAL.destroyapproxtransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyApproxTransformer(void * pCBData) -&gt; void</code></pre><p>Cleanup approximate transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pCBData</strong>: callback data originally returned by GDALCreateApproxTransformer().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroycolortable" href="#GDAL.destroycolortable"><code>GDAL.destroycolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyColorTable(GDALColorTableH hTable) -&gt; void</code></pre><p>Destroys a color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroydriver" href="#GDAL.destroydriver"><code>GDAL.destroydriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyDriver(GDALDriverH hDriver) -&gt; void</code></pre><p>Destroy a GDALDriver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the driver to destroy.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroydrivermanager" href="#GDAL.destroydrivermanager"><code>GDAL.destroydrivermanager</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyDriverManager(void) -&gt; void</code></pre><p>Destroy the driver manager.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroygcptransformer" href="#GDAL.destroygcptransformer"><code>GDAL.destroygcptransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyGCPTransformer(void * pTransformArg) -&gt; void</code></pre><p>Destroy GCP transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: the transform arg previously returned by GDALCreateGCPTransformer().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroygenimgprojtransformer" href="#GDAL.destroygenimgprojtransformer"><code>GDAL.destroygenimgprojtransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyGenImgProjTransformer(void * hTransformArg) -&gt; void</code></pre><p>GenImgProjTransformer deallocator.</p><p><strong>Parameters</strong></p><ul><li><strong>hTransformArg</strong>: the handle to deallocate.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroygeoloctransformer" href="#GDAL.destroygeoloctransformer"><code>GDAL.destroygeoloctransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyGeoLocTransformer(void * pTransformAlg) -&gt; void</code></pre><p>Destroy GeoLocation transformer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroygeometry" href="#GDAL.destroygeometry"><code>GDAL.destroygeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_DestroyGeometry(OGRGeometryH hGeom) -&gt; void</code></pre><p>Destroy geometry object.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to delete.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroyrasterattributetable" href="#GDAL.destroyrasterattributetable"><code>GDAL.destroyrasterattributetable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyRasterAttributeTable(GDALRasterAttributeTableH) -&gt; void</code></pre><p>Destroys a RAT.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroyreprojectiontransformer" href="#GDAL.destroyreprojectiontransformer"><code>GDAL.destroyreprojectiontransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyReprojectionTransformer(void * pTransformArg) -&gt; void</code></pre><p>Destroy reprojection transformation.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: the transformation handle returned by GDALCreateReprojectionTransformer().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroyrpctransformer" href="#GDAL.destroyrpctransformer"><code>GDAL.destroyrpctransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyRPCTransformer(void * pTransformArg) -&gt; void</code></pre><p>Destroy RPC tranformer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroyspatialreference" href="#GDAL.destroyspatialreference"><code>GDAL.destroyspatialreference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRDestroySpatialReference(OGRSpatialReferenceH hSRS) -&gt; void</code></pre><p>OGRSpatialReference destructor.</p><p><strong>Parameters</strong></p><ul><li><strong>hSRS</strong>: the object to delete</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroytpstransformer" href="#GDAL.destroytpstransformer"><code>GDAL.destroytpstransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyTPSTransformer(void * pTransformArg) -&gt; void</code></pre><p>Destroy TPS transformer.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: the transform arg previously returned by GDALCreateTPSTransformer().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.destroytransformer" href="#GDAL.destroytransformer"><code>GDAL.destroytransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDestroyTransformer(void * pTransformArg) -&gt; void</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.difference" href="#GDAL.difference"><code>GDAL.difference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Difference(OGRGeometryH hThis,
                 OGRGeometryH hOther) -&gt; OGRGeometryH</code></pre><p>Compute difference.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>hOther</strong>: the other geometry.</li></ul><p><strong>Returns</strong></p><p>a new geometry representing the difference or NULL if the difference is empty or an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.disjoint" href="#GDAL.disjoint"><code>GDAL.disjoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Disjoint(OGRGeometryH hThis,
               OGRGeometryH hOther) -&gt; int</code></pre><p>Test for disjointness.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if they are disjoint, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.distance" href="#GDAL.distance"><code>GDAL.distance</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Distance(OGRGeometryH hFirst,
               OGRGeometryH hOther) -&gt; double</code></pre><p>Compute distance between two geometries.</p><p><strong>Parameters</strong></p><ul><li><strong>hFirst</strong>: the first geometry to compare against.</li><li><strong>hOther</strong>: the other geometry to compare against.</li></ul><p><strong>Returns</strong></p><p>the distance between the geometries or -1 if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.distance3d" href="#GDAL.distance3d"><code>GDAL.distance3d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Distance3D(OGRGeometryH hFirst,
                 OGRGeometryH hOther) -&gt; double</code></pre><p>Returns the 3D distance between two geometries.</p><p><strong>Parameters</strong></p><ul><li><strong>hFirst</strong>: the first geometry to compare against.</li><li><strong>hOther</strong>: the other geometry to compare against.</li></ul><p><strong>Returns</strong></p><p>distance between the two geometries</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ditherrgb2pct" href="#GDAL.ditherrgb2pct"><code>GDAL.ditherrgb2pct</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDitherRGB2PCT(GDALRasterBandH hRed,
                  GDALRasterBandH hGreen,
                  GDALRasterBandH hBlue,
                  GDALRasterBandH hTarget,
                  GDALColorTableH hColorTable,
                  GDALProgressFunc pfnProgress,
                  void * pProgressArg) -&gt; int</code></pre><p>24bit to 8bit conversion with dithering.</p><p><strong>Parameters</strong></p><ul><li><strong>hRed</strong>: Red input band.</li><li><strong>hGreen</strong>: Green input band.</li><li><strong>hBlue</strong>: Blue input band.</li><li><strong>hTarget</strong>: Output band.</li><li><strong>hColorTable</strong>: the color table to use with the output band.</li><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dumpopendatasets" href="#GDAL.dumpopendatasets"><code>GDAL.dumpopendatasets</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDumpOpenDatasets(FILE * fp) -&gt; int</code></pre><p>List open datasets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.dumpreadable" href="#GDAL.dumpreadable"><code>GDAL.dumpreadable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_DumpReadable(OGRGeometryH hGeom,
                   FILE * fp,
                   const char * pszPrefix) -&gt; void</code></pre><p>Dump geometry in well known text format to indicated output file.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to dump.</li><li><strong>fp</strong>: the text file to write the geometry to.</li><li><strong>pszPrefix</strong>: the prefix to put on each line of output.</li></ul></div></div><div><div><pre><code class="language-none">OGR_F_DumpReadable(OGRFeatureH hFeat,
                   FILE * fpOut) -&gt; void</code></pre><p>Dump this feature in a human readable form.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to dump.</li><li><strong>fpOut</strong>: the stream to write to, such as strout.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.duplicategcps" href="#GDAL.duplicategcps"><code>GDAL.duplicategcps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALDuplicateGCPs(int,
                  const GDAL_GCP *) -&gt; GDAL_GCP *</code></pre><p>Duplicate an array of GCPs.</p><p><strong>Parameters</strong></p><ul><li><strong>nCount</strong>: number of GCPs in psGCP</li><li><strong>pasGCPList</strong>: array of GCPs of size nCount.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.emergencyerror" href="#GDAL.emergencyerror"><code>GDAL.emergencyerror</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLEmergencyError(const char * pszMessage) -&gt; void</code></pre><p>Fatal error when things are bad.</p><p><strong>Parameters</strong></p><ul><li><strong>pszMessage</strong>: the error message to report.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.empty" href="#GDAL.empty"><code>GDAL.empty</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Empty(OGRGeometryH hGeom) -&gt; void</code></pre><p>Clear geometry information.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to empty.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.endasyncreader" href="#GDAL.endasyncreader"><code>GDAL.endasyncreader</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALEndAsyncReader(GDALDatasetH hDS,
                   GDALAsyncReaderH hAsyncReaderH) -&gt; void</code></pre><p>End asynchronous request.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the dataset object.</li><li><strong>hAsyncReaderH</strong>: handle returned by GDALBeginAsyncReader()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.epsgtreatsaslatlong" href="#GDAL.epsgtreatsaslatlong"><code>GDAL.epsgtreatsaslatlong</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSREPSGTreatsAsLatLong(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>This function returns TRUE if EPSG feels this geographic coordinate system should be treated as having lat/long coordinate ordering.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.epsgtreatsasnorthingeasting" href="#GDAL.epsgtreatsasnorthingeasting"><code>GDAL.epsgtreatsasnorthingeasting</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSREPSGTreatsAsNorthingEasting(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>This function returns TRUE if EPSG feels this geographic coordinate system should be treated as having northing/easting coordinate ordering.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.equal" href="#GDAL.equal"><code>GDAL.equal</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_Equal(OGRFeatureH hFeat,
            OGRFeatureH hOtherFeat) -&gt; int</code></pre><p>Test if two features are the same.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to one of the feature.</li><li><strong>hOtherFeat</strong>: handle to the other feature to test this one against.</li></ul><p><strong>Returns</strong></p><p>TRUE if they are equal, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.equals" href="#GDAL.equals"><code>GDAL.equals</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Equals(OGRGeometryH hGeom,
             OGRGeometryH hOther) -&gt; int</code></pre><p>Returns TRUE if two geometries are equivalent.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the first geometry.</li><li><strong>hOther</strong>: handle on the other geometry to test against.</li></ul><p><strong>Returns</strong></p><p>TRUE if equivalent or FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.erase" href="#GDAL.erase"><code>GDAL.erase</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_Erase(OGRLayerH pLayerInput,
            OGRLayerH pLayerMethod,
            OGRLayerH pLayerResult,
            char ** papszOptions,
            GDALProgressFunc pfnProgress,
            void * pProgressArg) -&gt; OGRErr</code></pre><p>Remove areas that are covered by the method layer.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.errorreset" href="#GDAL.errorreset"><code>GDAL.errorreset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLErrorReset() -&gt; void</code></pre><p>Erase any traces of previous errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.errorsetstate" href="#GDAL.errorsetstate"><code>GDAL.errorsetstate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLErrorSetState(CPLErr eErrClass,
                 CPLErrorNum err_no,
                 const char * pszMsg) -&gt; void</code></pre><p>Restore an error state, without emitting an error.</p></div></div></section><pre><code class="language-none">GDAL.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.executesql" href="#GDAL.executesql"><code>GDAL.executesql</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_ExecuteSQL(OGRDataSourceH,
                  const char *,
                  OGRGeometryH,
                  const char *) -&gt; OGRLayerH</code></pre><p>Execute an SQL statement against the data store.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source on which the SQL query is executed.</li><li><strong>pszSQLCommand</strong>: the SQL statement to execute.</li><li><strong>hSpatialFilter</strong>: handle to a geometry which represents a spatial filter. Can be NULL.</li><li><strong>pszDialect</strong>: allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.</li></ul><p><strong>Returns</strong></p><p>an handle to a OGRLayer containing the results of the query. Deallocate with OGR<em>DS</em>ReleaseResultSet().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exportenvelopetogmltree" href="#GDAL.exportenvelopetogmltree"><code>GDAL.exportenvelopetogmltree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportEnvelopeToGMLTree(OGRGeometryH hGeometry) -&gt; CPLXMLNode *</code></pre><p>Export the envelope of a geometry as a gml:Box.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoerm" href="#GDAL.exporttoerm"><code>GDAL.exporttoerm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToERM(OGRSpatialReferenceH,
               char *,
               char *,
               char *) -&gt; OGRErr</code></pre><p>Convert coordinate system to ERMapper format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttogml" href="#GDAL.exporttogml"><code>GDAL.exporttogml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToGML(OGRGeometryH hGeometry) -&gt; char *</code></pre><p>Convert a geometry into GML format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeometry</strong>: handle to the geometry.</li></ul><p><strong>Returns</strong></p><p>A GML fragment or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttogmlex" href="#GDAL.exporttogmlex"><code>GDAL.exporttogmlex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToGMLEx(OGRGeometryH hGeometry,
                    char ** papszOptions) -&gt; char *</code></pre><p>Convert a geometry into GML format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeometry</strong>: handle to the geometry.</li><li><strong>papszOptions</strong>: NULL-terminated list of options.</li></ul><p><strong>Returns</strong></p><p>A GML fragment or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttogmltree" href="#GDAL.exporttogmltree"><code>GDAL.exporttogmltree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToGMLTree(OGRGeometryH hGeometry) -&gt; CPLXMLNode *</code></pre><p>Convert a geometry into GML format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoisowkb" href="#GDAL.exporttoisowkb"><code>GDAL.exporttoisowkb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToIsoWkb(OGRGeometryH hGeom,
                     OGRwkbByteOrder eOrder,
                     unsigned char * pabyDstBuffer) -&gt; OGRErr</code></pre><p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to convert to a well know binary data from.</li><li><strong>eOrder</strong>: One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively.</li><li><strong>pabyDstBuffer</strong>: a buffer into which the binary representation is written. This buffer must be at least OGR<em>G</em>WkbSize() byte in size.</li></ul><p><strong>Returns</strong></p><p>Currently OGRERR_NONE is always returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoisowkt" href="#GDAL.exporttoisowkt"><code>GDAL.exporttoisowkt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToIsoWkt(OGRGeometryH hGeom,
                     char ** ppszSrcText) -&gt; OGRErr</code></pre><p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to convert to a text format from.</li><li><strong>ppszSrcText</strong>: a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with CPLFree().</li></ul><p><strong>Returns</strong></p><p>Currently OGRERR_NONE is always returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttojson" href="#GDAL.exporttojson"><code>GDAL.exporttojson</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToJson(OGRGeometryH hGeometry) -&gt; char *</code></pre><p>Convert a geometry into GeoJSON format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeometry</strong>: handle to the geometry.</li></ul><p><strong>Returns</strong></p><p>A GeoJSON fragment or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttojsonex" href="#GDAL.exporttojsonex"><code>GDAL.exporttojsonex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToJsonEx(OGRGeometryH hGeometry,
                     char ** papszOptions) -&gt; char *</code></pre><p>Convert a geometry into GeoJSON format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeometry</strong>: handle to the geometry.</li><li><strong>papszOptions</strong>: a null terminated list of options.</li></ul><p><strong>Returns</strong></p><p>A GeoJSON fragment or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttokml" href="#GDAL.exporttokml"><code>GDAL.exporttokml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToKML(OGRGeometryH hGeometry,
                  const char * pszAltitudeMode) -&gt; char *</code></pre><p>Convert a geometry into KML format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeometry</strong>: handle to the geometry.</li><li><strong>pszAltitudeMode</strong>: value to write in altitudeMode element, or NULL.</li></ul><p><strong>Returns</strong></p><p>A KML fragment or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttomicoordsys" href="#GDAL.exporttomicoordsys"><code>GDAL.exporttomicoordsys</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToMICoordSys(OGRSpatialReferenceH hSRS,
                      char ** ppszReturn) -&gt; OGRErr</code></pre><p>Export coordinate system in Mapinfo style CoordSys format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttopanorama" href="#GDAL.exporttopanorama"><code>GDAL.exporttopanorama</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToPanorama(OGRSpatialReferenceH,
                    long *,
                    long *,
                    long *,
                    long *,
                    double *) -&gt; OGRErr</code></pre><p>Export coordinate system in &quot;Panorama&quot; GIS projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttopci" href="#GDAL.exporttopci"><code>GDAL.exporttopci</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToPCI(OGRSpatialReferenceH,
               char **,
               char **,
               double **) -&gt; OGRErr</code></pre><p>Export coordinate system in PCI projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoprettywkt" href="#GDAL.exporttoprettywkt"><code>GDAL.exporttoprettywkt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToPrettyWkt(OGRSpatialReferenceH hSRS,
                     char ** ppszReturn,
                     int bSimplify) -&gt; OGRErr</code></pre><p>Convert this SRS into a nicely formatted WKT string for display to a person.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoproj4" href="#GDAL.exporttoproj4"><code>GDAL.exporttoproj4</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToProj4(OGRSpatialReferenceH,
                 char **) -&gt; OGRErr</code></pre><p>Export coordinate system in PROJ.4 format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttousgs" href="#GDAL.exporttousgs"><code>GDAL.exporttousgs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToUSGS(OGRSpatialReferenceH,
                long *,
                long *,
                double **,
                long *) -&gt; OGRErr</code></pre><p>Export coordinate system in USGS GCTP projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttowkb" href="#GDAL.exporttowkb"><code>GDAL.exporttowkb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToWkb(OGRGeometryH hGeom,
                  OGRwkbByteOrder eOrder,
                  unsigned char * pabyDstBuffer) -&gt; OGRErr</code></pre><p>Convert a geometry well known binary format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to convert to a well know binary data from.</li><li><strong>eOrder</strong>: One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively.</li><li><strong>pabyDstBuffer</strong>: a buffer into which the binary representation is written. This buffer must be at least OGR<em>G</em>WkbSize() byte in size.</li></ul><p><strong>Returns</strong></p><p>Currently OGRERR_NONE is always returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttowkt" href="#GDAL.exporttowkt"><code>GDAL.exporttowkt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ExportToWkt(OGRGeometryH hGeom,
                  char ** ppszSrcText) -&gt; OGRErr</code></pre><p>Convert a geometry into well known text format.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to convert to a text format from.</li><li><strong>ppszSrcText</strong>: a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with CPLFree().</li></ul><p><strong>Returns</strong></p><p>Currently OGRERR_NONE is always returned.</p></div></div><div><div><pre><code class="language-none">OSRExportToWkt(OGRSpatialReferenceH hSRS,
               char ** ppszReturn) -&gt; OGRErr</code></pre><p>Convert this SRS into WKT format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.exporttoxml" href="#GDAL.exporttoxml"><code>GDAL.exporttoxml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRExportToXML(OGRSpatialReferenceH,
               char **,
               const char *) -&gt; OGRErr</code></pre><p>Export coordinate system in XML format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.extractrpcinfo" href="#GDAL.extractrpcinfo"><code>GDAL.extractrpcinfo</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALExtractRPCInfo(char **,
                   GDALRPCInfo *) -&gt; int</code></pre><p>Extract RPC info from metadata, and apply to an RPCInfo structure.</p><p><strong>Parameters</strong></p><ul><li><strong>papszMD</strong>: Dictionary of metadata representing RPC</li><li><strong>psRPC</strong>: (output) Pointer to structure to hold the RPC values.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success. FALSE in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.f_create" href="#GDAL.f_create"><code>GDAL.f_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_Create(OGRFeatureDefnH hDefn) -&gt; OGRFeatureH</code></pre><p>Feature factory.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature class (layer) definition to which the feature will adhere.</li></ul><p><strong>Returns</strong></p><p>an handle to the new feature object with null fields and no geometry, or, starting with GDAL 2.1, NULL in case out of memory situation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.failsafe" href="#GDAL.failsafe"><code>GDAL.failsafe</code></a> â <span class="docstring-category">Function</span>.</div><div><div><p>Throw an error if a pointer is null and GDAL reports an error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fd_create" href="#GDAL.fd_create"><code>GDAL.fd_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_Create(const char * pszName) -&gt; OGRFeatureDefnH</code></pre><p>Create a new feature definition object to hold the field definitions.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the name to be assigned to this layer/class. It does not need to be unique.</li></ul><p><strong>Returns</strong></p><p>handle to the newly created feature definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.feedline" href="#GDAL.feedline"><code>GDAL.feedline</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDAL_CG_FeedLine(GDALContourGeneratorH hCG,
                 double * padfScanline) -&gt; CPLErr</code></pre><p>Feed a line to the contour generator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fillnodata" href="#GDAL.fillnodata"><code>GDAL.fillnodata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFillNodata(GDALRasterBandH hTargetBand,
               GDALRasterBandH hMaskBand,
               double dfMaxSearchDist,
               int bDeprecatedOption,
               int nSmoothingIterations,
               char ** papszOptions,
               GDALProgressFunc pfnProgress,
               void * pProgressArg) -&gt; CPLErr</code></pre><p>Fill selected raster regions by interpolation from the edges.</p><p><strong>Parameters</strong></p><ul><li><strong>hTargetBand</strong>: the raster band to be modified in place.</li><li><strong>hMaskBand</strong>: a mask band indicating pixels to be interpolated (zero valued).</li><li><strong>dfMaxSearchDist</strong>: the maximum number of pixels to search in all directions to find values to interpolate from.</li><li><strong>bDeprecatedOption</strong>: unused argument, should be zero.</li><li><strong>nSmoothingIterations</strong>: the number of 3x3 smoothing filter passes to run (0 or more).</li><li><strong>papszOptions</strong>: additional name=value options in a string list (the temporary file driver can be specified like TEMP<em>FILE</em>DRIVER=MEM).</li><li><strong>pfnProgress</strong>: the progress function to report completion.</li><li><strong>pProgressArg</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if something goes wrong.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fillraster" href="#GDAL.fillraster"><code>GDAL.fillraster</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFillRaster(GDALRasterBandH hBand,
               double dfRealValue,
               double dfImaginaryValue) -&gt; CPLErr</code></pre><p>Fill this band with a constant value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fillunsetwithdefault" href="#GDAL.fillunsetwithdefault"><code>GDAL.fillunsetwithdefault</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat,
                           int bNotNullableOnly,
                           char ** papszOptions) -&gt; void</code></pre><p>Fill unset fields with default values that might be defined.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature.</li><li><strong>bNotNullableOnly</strong>: if we should fill only unset fields with a not-null constraint.</li><li><strong>papszOptions</strong>: unused currently. Must be set to NULL.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.find" href="#GDAL.find"><code>GDAL.find</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_Find(OGRStyleTableH hStyleTable,
              const char * pszName) -&gt; const char *</code></pre><p>Get a style string by name.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li><li><strong>pszName</strong>: the name of the style string to find.</li></ul><p><strong>Returns</strong></p><p>the style string matching the name or NULL if not found or error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.findfieldindex" href="#GDAL.findfieldindex"><code>GDAL.findfieldindex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_FindFieldIndex(OGRLayerH,
                     const char *,
                     int bExactMatch) -&gt; int</code></pre><p>Find the index of field in a layer.</p><p><strong>Returns</strong></p><p>field index, or -1 if the field doesn&#39;t exist</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fixup" href="#GDAL.fixup"><code>GDAL.fixup</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRFixup(OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Fixup as needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fixupordering" href="#GDAL.fixupordering"><code>GDAL.fixupordering</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRFixupOrdering(OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Correct parameter ordering to match CT Specification.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.flattento2d" href="#GDAL.flattento2d"><code>GDAL.flattento2d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_FlattenTo2D(OGRGeometryH hGeom) -&gt; void</code></pre><p>Convert geometry to strictly 2D.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to convert.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fld_create" href="#GDAL.fld_create"><code>GDAL.fld_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_Create(const char * pszName,
               OGRFieldType eType) -&gt; OGRFieldDefnH</code></pre><p>Create a new field definition.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the name of the new field definition.</li><li><strong>eType</strong>: the type of the new field definition.</li></ul><p><strong>Returns</strong></p><p>handle to the new field definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.flushcache" href="#GDAL.flushcache"><code>GDAL.flushcache</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFlushCache(GDALDatasetH hDS) -&gt; void</code></pre><p>Flush all write cached data to disk.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.flushcacheblock" href="#GDAL.flushcacheblock"><code>GDAL.flushcacheblock</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFlushCacheBlock() -&gt; int</code></pre><p>Try to flush one cached raster block.</p><p><strong>Returns</strong></p><p>TRUE if one block was flushed, FALSE if there are no cached blocks or if they are currently locked.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.flushrastercache" href="#GDAL.flushrastercache"><code>GDAL.flushrastercache</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFlushRasterCache(GDALRasterBandH hBand) -&gt; CPLErr</code></pre><p>Flush raster data cache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forceto" href="#GDAL.forceto"><code>GDAL.forceto</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceTo(OGRGeometryH hGeom,
              OGRwkbGeometryType eTargetType,
              char ** papszOptions) -&gt; OGRGeometryH</code></pre><p>Convert to another geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the input geometry - ownership is passed to the method.</li><li><strong>eTargetType</strong>: target output geometry type.</li><li><strong>papszOptions</strong>: options as a null-terminated list of strings or NULL.</li></ul><p><strong>Returns</strong></p><p>new geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forcetolinestring" href="#GDAL.forcetolinestring"><code>GDAL.forcetolinestring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceToLineString(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Convert to line string.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to convert (ownership surrendered).</li></ul><p><strong>Returns</strong></p><p>the converted geometry (ownership to caller).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forcetomultilinestring" href="#GDAL.forcetomultilinestring"><code>GDAL.forcetomultilinestring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceToMultiLineString(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Convert to multilinestring.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to convert (ownership surrendered).</li></ul><p><strong>Returns</strong></p><p>the converted geometry (ownership to caller).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forcetomultipoint" href="#GDAL.forcetomultipoint"><code>GDAL.forcetomultipoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceToMultiPoint(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Convert to multipoint.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to convert (ownership surrendered).</li></ul><p><strong>Returns</strong></p><p>the converted geometry (ownership to caller).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forcetomultipolygon" href="#GDAL.forcetomultipolygon"><code>GDAL.forcetomultipolygon</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceToMultiPolygon(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Convert to multipolygon.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to convert (ownership surrendered).</li></ul><p><strong>Returns</strong></p><p>the converted geometry (ownership to caller).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.forcetopolygon" href="#GDAL.forcetopolygon"><code>GDAL.forcetopolygon</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ForceToPolygon(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Convert to polygon.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to convert (ownership surrendered).</li></ul><p><strong>Returns</strong></p><p>the converted geometry (ownership to caller).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.fpolygonize" href="#GDAL.fpolygonize"><code>GDAL.fpolygonize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALFPolygonize(GDALRasterBandH hSrcBand,
                GDALRasterBandH hMaskBand,
                OGRLayerH hOutLayer,
                int iPixValField,
                char ** papszOptions,
                GDALProgressFunc pfnProgress,
                void * pProgressArg) -&gt; CPLErr</code></pre><p>Create polygon coverage from raster data.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: the source raster band to be processed.</li><li><strong>hMaskBand</strong>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons.</li><li><strong>hOutLayer</strong>: the vector feature layer to which the polygons should be written.</li><li><strong>iPixValField</strong>: the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written.</li><li><strong>papszOptions</strong>: a name/value list of additional options </li></ul><p>&quot;8CONNECTED&quot;: May be set to &quot;8&quot; to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm</p><ul><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on a failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gcpstogeotransform" href="#GDAL.gcpstogeotransform"><code>GDAL.gcpstogeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGCPsToGeoTransform(int nGCPCount,
                       const GDAL_GCP * pasGCPs,
                       double * padfGeoTransform,
                       int bApproxOK) -&gt; int</code></pre><p>Generate Geotransform from GCPs.</p><p><strong>Parameters</strong></p><ul><li><strong>nGCPCount</strong>: the number of GCPs being passed in.</li><li><strong>pasGCPs</strong>: the list of GCP structures.</li><li><strong>padfGeoTransform</strong>: the six double array in which the affine geotransformation will be returned.</li><li><strong>bApproxOK</strong>: If FALSE the function will fail if the geotransform is not essentially an exact fit (within 0.25 pixel) for all GCPs.</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE if there aren&#39;t enough points to prepare a geotransform, the pointers are ill-determined or if bApproxOK is FALSE and the fit is poor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gcptransform" href="#GDAL.gcptransform"><code>GDAL.gcptransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGCPTransform(void * pTransformArg,
                 int bDstToSrc,
                 int nPointCount,
                 double * x,
                 double * y,
                 double * z,
                 int * panSuccess) -&gt; int</code></pre><p>Transforms point based on GCP derived polynomial model.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: return value from GDALCreateGCPTransformer().</li><li><strong>bDstToSrc</strong>: TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates.</li><li><strong>nPointCount</strong>: the number of values in the x, y and z arrays.</li><li><strong>x</strong>: array containing the X values to be transformed.</li><li><strong>y</strong>: array containing the Y values to be transformed.</li><li><strong>z</strong>: array containing the Z values to be transformed.</li><li><strong>panSuccess</strong>: array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</li></ul><p><strong>Returns</strong></p><p>TRUE.</p></div></div></section><pre><code class="language-none">GDAL.gdal_translate_path</code></pre><pre><code class="language-none">GDAL.gdalinfo_path</code></pre><pre><code class="language-none">GDAL.gdaljl_errorhandler</code></pre><pre><code class="language-none">GDAL.gdalwarp_path</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.generalcmdlineprocessor" href="#GDAL.generalcmdlineprocessor"><code>GDAL.generalcmdlineprocessor</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGeneralCmdLineProcessor(int nArgc,
                            char *** ppapszArgv,
                            int nOptions) -&gt; int</code></pre><p>General utility option processing.</p><p><strong>Parameters</strong></p><ul><li><strong>nArgc</strong>: number of values in the argument list.</li><li><strong>ppapszArgv</strong>: pointer to the argument list array (will be updated in place).</li><li><strong>nOptions</strong>: a or-able combination of GDAL<em>OF</em>RASTER and GDAL<em>OF</em>VECTOR to determine which drivers should be displayed by formats. If set to 0, GDAL<em>OF</em>RASTER is assumed.</li></ul><p><strong>Returns</strong></p><p>updated nArgc argument count. Return of 0 requests terminate without error, return of -1 requests exit with error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.genimgprojtransform" href="#GDAL.genimgprojtransform"><code>GDAL.genimgprojtransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGenImgProjTransform(void * pTransformArgIn,
                        int bDstToSrc,
                        int nPointCount,
                        double * padfX,
                        double * padfY,
                        double * padfZ,
                        int * panSuccess) -&gt; int</code></pre><p>Perform general image reprojection transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.geoloctransform" href="#GDAL.geoloctransform"><code>GDAL.geoloctransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGeoLocTransform(void * pTransformArg,
                    int bDstToSrc,
                    int nPointCount,
                    double * padfX,
                    double * padfY,
                    double * padfZ,
                    int * panSuccess) -&gt; int</code></pre><p>Use GeoLocation transformer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getaccess" href="#GDAL.getaccess"><code>GDAL.getaccess</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetAccess(GDALDatasetH hDS) -&gt; int</code></pre><p>Return access flag.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getactualblocksize" href="#GDAL.getactualblocksize"><code>GDAL.getactualblocksize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetActualBlockSize(GDALRasterBandH hBand,
                       int nXBlockOff,
                       int nYBlockOff,
                       int * pnXValid,
                       int * pnYValid) -&gt; CPLErr</code></pre><p>Retrieve the actual block size for a given block offset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getangularunits" href="#GDAL.getangularunits"><code>GDAL.getangularunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetAngularUnits(OGRSpatialReferenceH hSRS,
                   char ** ppszName) -&gt; double</code></pre><p>Fetch angular geographic coordinate system units.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getarea" href="#GDAL.getarea"><code>GDAL.getarea</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetArea(OGRGeometryH hGeom) -&gt; double</code></pre><p>Compute geometry area (deprecated)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getasyncstatustypebyname" href="#GDAL.getasyncstatustypebyname"><code>GDAL.getasyncstatustypebyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetAsyncStatusTypeByName(const char *) -&gt; GDALAsyncStatusType</code></pre><p>Get AsyncStatusType by symbolic name.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: string containing the symbolic name of the type.</li></ul><p><strong>Returns</strong></p><p>GDAL AsyncStatus type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getasyncstatustypename" href="#GDAL.getasyncstatustypename"><code>GDAL.getasyncstatustypename</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetAsyncStatusTypeName(GDALAsyncStatusType) -&gt; const char *</code></pre><p>Get name of AsyncStatus data type.</p><p><strong>Parameters</strong></p><ul><li><strong>eAsyncStatusType</strong>: type to get name of.</li></ul><p><strong>Returns</strong></p><p>string corresponding to type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getattrvalue" href="#GDAL.getattrvalue"><code>GDAL.getattrvalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetAttrValue(OGRSpatialReferenceH hSRS,
                const char * pszKey,
                int iChild) -&gt; const char *</code></pre><p>Fetch indicated attribute of named node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getauthoritycode" href="#GDAL.getauthoritycode"><code>GDAL.getauthoritycode</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetAuthorityCode(OGRSpatialReferenceH hSRS,
                    const char * pszTargetKey) -&gt; const char *</code></pre><p>Get the authority code for a node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getauthorityname" href="#GDAL.getauthorityname"><code>GDAL.getauthorityname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetAuthorityName(OGRSpatialReferenceH hSRS,
                    const char * pszTargetKey) -&gt; const char *</code></pre><p>Get the authority name for a node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getaxis" href="#GDAL.getaxis"><code>GDAL.getaxis</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetAxis(OGRSpatialReferenceH hSRS,
           const char * pszTargetKey,
           int iAxis,
           OGRAxisOrientation * peOrientation) -&gt; const char *</code></pre><p>Fetch the orientation of one axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getbanddataset" href="#GDAL.getbanddataset"><code>GDAL.getbanddataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetBandDataset(GDALRasterBandH hBand) -&gt; GDALDatasetH</code></pre><p>Fetch the owning dataset handle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getbandnumber" href="#GDAL.getbandnumber"><code>GDAL.getbandnumber</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetBandNumber(GDALRasterBandH hBand) -&gt; int</code></pre><p>Fetch the band number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getblocksize" href="#GDAL.getblocksize"><code>GDAL.getblocksize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetBlockSize(GDALRasterBandH hBand,
                 int * pnXSize,
                 int * pnYSize) -&gt; void</code></pre><p>Fetch the &quot;natural&quot; block size of this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getboundary" href="#GDAL.getboundary"><code>GDAL.getboundary</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetBoundary(OGRGeometryH hTarget) -&gt; OGRGeometryH</code></pre><p>Compute boundary (deprecated)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcachemax" href="#GDAL.getcachemax"><code>GDAL.getcachemax</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetCacheMax() -&gt; int</code></pre><p>Get maximum cache memory.</p><p><strong>Returns</strong></p><p>maximum in bytes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcachemax64" href="#GDAL.getcachemax64"><code>GDAL.getcachemax64</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetCacheMax64() -&gt; GIntBig</code></pre><p>Get maximum cache memory.</p><p><strong>Returns</strong></p><p>maximum in bytes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcacheused" href="#GDAL.getcacheused"><code>GDAL.getcacheused</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetCacheUsed() -&gt; int</code></pre><p>Get cache memory used.</p><p><strong>Returns</strong></p><p>the number of bytes of memory currently in use by the GDALRasterBlock memory caching.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcacheused64" href="#GDAL.getcacheused64"><code>GDAL.getcacheused64</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetCacheUsed64() -&gt; GIntBig</code></pre><p>Get cache memory used.</p><p><strong>Returns</strong></p><p>the number of bytes of memory currently in use by the GDALRasterBlock memory caching.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcolorentry" href="#GDAL.getcolorentry"><code>GDAL.getcolorentry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetColorEntry(GDALColorTableH hTable,
                  int i) -&gt; const GDALColorEntry *</code></pre><p>Fetch a color entry from table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcolorentryasrgb" href="#GDAL.getcolorentryasrgb"><code>GDAL.getcolorentryasrgb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetColorEntryAsRGB(GDALColorTableH hTable,
                       int i,
                       GDALColorEntry * poEntry) -&gt; int</code></pre><p>Fetch a table entry in RGB format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcolorentrycount" href="#GDAL.getcolorentrycount"><code>GDAL.getcolorentrycount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetColorEntryCount(GDALColorTableH hTable) -&gt; int</code></pre><p>Get number of color entries in table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcolorinterpretationbyname" href="#GDAL.getcolorinterpretationbyname"><code>GDAL.getcolorinterpretationbyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetColorInterpretationByName(const char * pszName) -&gt; GDALColorInterp</code></pre><p>Get color interpretation by symbolic name.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: string containing the symbolic name of the color interpretation.</li></ul><p><strong>Returns</strong></p><p>GDAL color interpretation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcolorinterpretationname" href="#GDAL.getcolorinterpretationname"><code>GDAL.getcolorinterpretationname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetColorInterpretationName(GDALColorInterp) -&gt; const char *</code></pre><p>Get name of color interpretation.</p><p><strong>Parameters</strong></p><ul><li><strong>eInterp</strong>: color interpretation to get name of.</li></ul><p><strong>Returns</strong></p><p>string corresponding to color interpretation or NULL pointer if invalid enumerator given.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcoordinatedimension" href="#GDAL.getcoordinatedimension"><code>GDAL.getcoordinatedimension</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetCoordinateDimension(OGRGeometryH hGeom) -&gt; int</code></pre><p>Get the dimension of the coordinates in this geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get the dimension of the coordinates from.</li></ul><p><strong>Returns</strong></p><p>this will return 2 or 3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getcurvegeometry" href="#GDAL.getcurvegeometry"><code>GDAL.getcurvegeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetCurveGeometry(OGRGeometryH hGeom,
                       char ** papszOptions) -&gt; OGRGeometryH</code></pre><p>Return curve version of this geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the geometry to operate on.</li><li><strong>papszOptions</strong>: options as a null-terminated list of strings. Unused for now. Must be set to NULL.</li></ul><p><strong>Returns</strong></p><p>a new geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatacoveragestatus" href="#GDAL.getdatacoveragestatus"><code>GDAL.getdatacoveragestatus</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataCoverageStatus(GDALRasterBandH hBand,
                          int nXOff,
                          int nYOff,
                          int nXSize,
                          int nYSize,
                          int nMaskFlagStop,
                          double * pdfDataPct) -&gt; int</code></pre><p>Get the coverage status of a sub-window of the raster.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: raster band</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be queried. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be queried. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be queried in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be queried in lines.</li><li><strong>nMaskFlagStop</strong>: 0, or a binary-or&#39;ed mask of possible values GDAL<em>DATA</em>COVERAGE<em>STATUS</em>UNIMPLEMENTED, GDAL<em>DATA</em>COVERAGE<em>STATUS</em>DATA and GDAL<em>DATA</em>COVERAGE<em>STATUS</em>EMPTY. As soon as the computation of the coverage matches the mask, the computation will be stopped. *pdfDataPct will not be valid in that case.</li><li><strong>pdfDataPct</strong>: Optional output parameter whose pointed value will be set to the (approximate) percentage in [0,100] of pixels in the queried sub-window that have valid values. The implementation might not always be able to compute it, in which case it will be set to a negative value.</li></ul><p><strong>Returns</strong></p><p>a binary-or&#39;ed combination of possible values GDAL<em>DATA</em>COVERAGE<em>STATUS</em>UNIMPLEMENTED, GDAL<em>DATA</em>COVERAGE<em>STATUS</em>DATA and GDAL<em>DATA</em>COVERAGE<em>STATUS</em>EMPTY</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatasetdriver" href="#GDAL.getdatasetdriver"><code>GDAL.getdatasetdriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDatasetDriver(GDALDatasetH hDataset) -&gt; GDALDriverH</code></pre><p>Fetch the driver to which this dataset relates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatatypebyname" href="#GDAL.getdatatypebyname"><code>GDAL.getdatatypebyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataTypeByName(const char *) -&gt; GDALDataType</code></pre><p>Get data type by symbolic name.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: string containing the symbolic name of the type.</li></ul><p><strong>Returns</strong></p><p>GDAL data type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatatypename" href="#GDAL.getdatatypename"><code>GDAL.getdatatypename</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataTypeName(GDALDataType) -&gt; const char *</code></pre><p>Get name of data type.</p><p><strong>Parameters</strong></p><ul><li><strong>eDataType</strong>: type to get name of.</li></ul><p><strong>Returns</strong></p><p>string corresponding to existing data type or NULL pointer if invalid type given.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatatypesize" href="#GDAL.getdatatypesize"><code>GDAL.getdatatypesize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataTypeSize(GDALDataType) -&gt; int</code></pre><p>Get data type size in bits.</p><p><strong>Parameters</strong></p><ul><li><strong>eDataType</strong>: type, such as GDT_Byte.</li></ul><p><strong>Returns</strong></p><p>the number of bits or zero if it is not recognised.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatatypesizebits" href="#GDAL.getdatatypesizebits"><code>GDAL.getdatatypesizebits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataTypeSizeBits(GDALDataType eDataType) -&gt; int</code></pre><p>Get data type size in bits.</p><p><strong>Parameters</strong></p><ul><li><strong>eDataType</strong>: type, such as GDT_Byte.</li></ul><p><strong>Returns</strong></p><p>the number of bits or zero if it is not recognised.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdatatypesizebytes" href="#GDAL.getdatatypesizebytes"><code>GDAL.getdatatypesizebytes</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDataTypeSizeBytes(GDALDataType) -&gt; int</code></pre><p>Get data type size in bytes.</p><p><strong>Parameters</strong></p><ul><li><strong>eDataType</strong>: type, such as GDT_Byte.</li></ul><p><strong>Returns</strong></p><p>the number of bytes or zero if it is not recognised.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdefault" href="#GDAL.getdefault"><code>GDAL.getdefault</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetDefault(OGRFieldDefnH hDefn) -&gt; const char *</code></pre><p>Get default field value.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition.</li></ul><p><strong>Returns</strong></p><p>default field value or NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdefaulthistogram" href="#GDAL.getdefaulthistogram"><code>GDAL.getdefaulthistogram</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDefaultHistogram(GDALRasterBandH hBand,
                        double * pdfMin,
                        double * pdfMax,
                        int * pnBuckets,
                        int ** ppanHistogram,
                        int bForce,
                        GDALProgressFunc pfnProgress,
                        void * pProgressData) -&gt; CPLErr</code></pre><p>Fetch default raster histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdefaulthistogramex" href="#GDAL.getdefaulthistogramex"><code>GDAL.getdefaulthistogramex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDefaultHistogramEx(GDALRasterBandH hBand,
                          double * pdfMin,
                          double * pdfMax,
                          int * pnBuckets,
                          GUIntBig ** ppanHistogram,
                          int bForce,
                          GDALProgressFunc pfnProgress,
                          void * pProgressData) -&gt; CPLErr</code></pre><p>Fetch default raster histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdefaultrat" href="#GDAL.getdefaultrat"><code>GDAL.getdefaultrat</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDefaultRAT(GDALRasterBandH hBand) -&gt; GDALRasterAttributeTableH</code></pre><p>Fetch default Raster Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdefnref" href="#GDAL.getdefnref"><code>GDAL.getdefnref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetDefnRef(OGRFeatureH hFeat) -&gt; OGRFeatureDefnH</code></pre><p>Fetch feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get the feature definition from.</li></ul><p><strong>Returns</strong></p><p>an handle to the feature definition object on which feature depends.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdescription" href="#GDAL.getdescription"><code>GDAL.getdescription</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDescription(GDALMajorObjectH hObject) -&gt; const char *</code></pre><p>Fetch object description.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdimension" href="#GDAL.getdimension"><code>GDAL.getdimension</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetDimension(OGRGeometryH hGeom) -&gt; int</code></pre><p>Get the dimension of this geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get the dimension from.</li></ul><p><strong>Returns</strong></p><p>0 for points, 1 for lines and 2 for surfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdriver" href="#GDAL.getdriver"><code>GDAL.getdriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriver(int iDriver) -&gt; GDALDriverH</code></pre><p>Fetch driver by index.</p></div></div><div><div><pre><code class="language-none">OGR_DS_GetDriver(OGRDataSourceH) -&gt; OGRSFDriverH</code></pre><p>Returns the driver that the dataset was opened with.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the datasource</li></ul><p><strong>Returns</strong></p><p>NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdriverbyname" href="#GDAL.getdriverbyname"><code>GDAL.getdriverbyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverByName(const char * pszName) -&gt; GDALDriverH</code></pre><p>Fetch a driver based on the short name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdrivercount" href="#GDAL.getdrivercount"><code>GDAL.getdrivercount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverCount() -&gt; int</code></pre><p>Fetch the number of registered drivers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdrivercreationoptionlist" href="#GDAL.getdrivercreationoptionlist"><code>GDAL.getdrivercreationoptionlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverCreationOptionList(GDALDriverH hDriver) -&gt; const char *</code></pre><p>Return the list of creation options of the driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the handle of the driver</li></ul><p><strong>Returns</strong></p><p>an XML string that describes the list of creation options or empty string. The returned string should not be freed and is owned by the driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdriverhelptopic" href="#GDAL.getdriverhelptopic"><code>GDAL.getdriverhelptopic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverHelpTopic(GDALDriverH hDriver) -&gt; const char *</code></pre><p>Return the URL to the help that describes the driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the handle of the driver</li></ul><p><strong>Returns</strong></p><p>the URL to the help that describes the driver or NULL. The returned string should not be freed and is owned by the driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdriverlongname" href="#GDAL.getdriverlongname"><code>GDAL.getdriverlongname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverLongName(GDALDriverH hDriver) -&gt; const char *</code></pre><p>Return the long name of a driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the handle of the driver</li></ul><p><strong>Returns</strong></p><p>the long name of the driver or empty string. The returned string should not be freed and is owned by the driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getdrivershortname" href="#GDAL.getdrivershortname"><code>GDAL.getdrivershortname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetDriverShortName(GDALDriverH hDriver) -&gt; const char *</code></pre><p>Return the short name of a driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the handle of the driver</li></ul><p><strong>Returns</strong></p><p>the short name of the driver. The returned string should not be freed and is owned by the driver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getenvelope" href="#GDAL.getenvelope"><code>GDAL.getenvelope</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetEnvelope(OGRGeometryH hGeom,
                  OGREnvelope * psEnvelope) -&gt; void</code></pre><p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle of the geometry to get envelope from.</li><li><strong>psEnvelope</strong>: the structure in which to place the results.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getenvelope3d" href="#GDAL.getenvelope3d"><code>GDAL.getenvelope3d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetEnvelope3D(OGRGeometryH hGeom,
                    OGREnvelope3D * psEnvelope) -&gt; void</code></pre><p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle of the geometry to get envelope from.</li><li><strong>psEnvelope</strong>: the structure in which to place the results.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.geterrorhandleruserdata" href="#GDAL.geterrorhandleruserdata"><code>GDAL.geterrorhandleruserdata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLGetErrorHandlerUserData(void) -&gt; void *</code></pre><p>Fetch the user data for the error context.</p><p><strong>Returns</strong></p><p>the user data pointer for the error context</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getextent" href="#GDAL.getextent"><code>GDAL.getextent</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetExtent(OGRLayerH,
                OGREnvelope *,
                int) -&gt; OGRErr</code></pre><p>Fetch the extent of this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer from which to get extent.</li><li><strong>psExtent</strong>: the structure in which the extent value will be returned.</li><li><strong>bForce</strong>: Flag indicating whether the extent should be computed even if it is expensive.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, OGRERR</em>FAILURE if extent not known.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getextentex" href="#GDAL.getextentex"><code>GDAL.getextentex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetExtentEx(OGRLayerH,
                  int iGeomField,
                  OGREnvelope * psExtent,
                  int bForce) -&gt; OGRErr</code></pre><p>Fetch the extent of this layer, on the specified geometry field.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer from which to get extent.</li><li><strong>iGeomField</strong>: the index of the geometry field on which to compute the extent.</li><li><strong>psExtent</strong>: the structure in which the extent value will be returned.</li><li><strong>bForce</strong>: Flag indicating whether the extent should be computed even if it is expensive.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, OGRERR</em>FAILURE if extent not known.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfeature" href="#GDAL.getfeature"><code>GDAL.getfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetFeature(OGRLayerH,
                 GIntBig) -&gt; OGRFeatureH</code></pre><p>Fetch a feature by its identifier.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer that owned the feature.</li><li><strong>nFeatureId</strong>: the feature id of the feature to read.</li></ul><p><strong>Returns</strong></p><p>an handle to a feature now owned by the caller, or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfeaturecount" href="#GDAL.getfeaturecount"><code>GDAL.getfeaturecount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetFeatureCount(OGRLayerH,
                      int) -&gt; GIntBig</code></pre><p>Fetch the feature count in this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer that owned the features.</li><li><strong>bForce</strong>: Flag indicating whether the count should be computed even if it is expensive.</li></ul><p><strong>Returns</strong></p><p>feature count, -1 if count not known.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfeaturesread" href="#GDAL.getfeaturesread"><code>GDAL.getfeaturesread</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetFeaturesRead(OGRLayerH hLayer) -&gt; GIntBig</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfid" href="#GDAL.getfid"><code>GDAL.getfid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFID(OGRFeatureH hFeat) -&gt; GIntBig</code></pre><p>Get feature identifier.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature from which to get the feature identifier.</li></ul><p><strong>Returns</strong></p><p>feature id or OGRNullFID if none has been assigned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfidcolumn" href="#GDAL.getfidcolumn"><code>GDAL.getfidcolumn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetFIDColumn(OGRLayerH) -&gt; const char *</code></pre><p>This method returns the name of the underlying database column being used as the FID column, or &quot;&quot; if not supported.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>fid column name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasbinary" href="#GDAL.getfieldasbinary"><code>GDAL.getfieldasbinary</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsBinary(OGRFeatureH hFeat,
                       int iField,
                       int * pnBytes) -&gt; GByte *</code></pre><p>Fetch field value as binary.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnBytes</strong>: location to place count of bytes returned.</li></ul><p><strong>Returns</strong></p><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasdatetime" href="#GDAL.getfieldasdatetime"><code>GDAL.getfieldasdatetime</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat,
                         int iField,
                         int * pnYear,
                         int * pnMonth,
                         int * pnDay,
                         int * pnHour,
                         int * pnMinute,
                         int * pnSecond,
                         int * pnTZFlag) -&gt; int</code></pre><p>Fetch field value as date and time.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnYear</strong>: (including century)</li><li><strong>pnMonth</strong>: (1-12)</li><li><strong>pnDay</strong>: (1-31)</li><li><strong>pnHour</strong>: (0-23)</li><li><strong>pnMinute</strong>: (0-59)</li><li><strong>pnSecond</strong>: (0-59)</li><li><strong>pnTZFlag</strong>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasdatetimeex" href="#GDAL.getfieldasdatetimeex"><code>GDAL.getfieldasdatetimeex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsDateTimeEx(OGRFeatureH hFeat,
                           int iField,
                           int * pnYear,
                           int * pnMonth,
                           int * pnDay,
                           int * pnHour,
                           int * pnMinute,
                           float * pfSecond,
                           int * pnTZFlag) -&gt; int</code></pre><p>Fetch field value as date and time.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnYear</strong>: (including century)</li><li><strong>pnMonth</strong>: (1-12)</li><li><strong>pnDay</strong>: (1-31)</li><li><strong>pnHour</strong>: (0-23)</li><li><strong>pnMinute</strong>: (0-59)</li><li><strong>pfSecond</strong>: (0-59 with millisecond accuracy)</li><li><strong>pnTZFlag</strong>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasdouble" href="#GDAL.getfieldasdouble"><code>GDAL.getfieldasdouble</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsDouble(OGRFeatureH hFeat,
                       int iField) -&gt; double</code></pre><p>Fetch field value as a double.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the field value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasdoublelist" href="#GDAL.getfieldasdoublelist"><code>GDAL.getfieldasdoublelist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsDoubleList(OGRFeatureH hFeat,
                           int iField,
                           int * pnCount) -&gt; const double *</code></pre><p>Fetch field value as a list of doubles.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnCount</strong>: an integer to put the list count (number of doubles) into.</li></ul><p><strong>Returns</strong></p><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasinteger" href="#GDAL.getfieldasinteger"><code>GDAL.getfieldasinteger</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsInteger(OGRFeatureH hFeat,
                        int iField) -&gt; int</code></pre><p>Fetch field value as integer.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the field value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasinteger64" href="#GDAL.getfieldasinteger64"><code>GDAL.getfieldasinteger64</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsInteger64(OGRFeatureH hFeat,
                          int iField) -&gt; GIntBig</code></pre><p>Fetch field value as integer 64 bit.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the field value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasinteger64list" href="#GDAL.getfieldasinteger64list"><code>GDAL.getfieldasinteger64list</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsInteger64List(OGRFeatureH hFeat,
                              int iField,
                              int * pnCount) -&gt; const GIntBig *</code></pre><p>Fetch field value as a list of 64 bit integers.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnCount</strong>: an integer to put the list count (number of integers) into.</li></ul><p><strong>Returns</strong></p><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasintegerlist" href="#GDAL.getfieldasintegerlist"><code>GDAL.getfieldasintegerlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsIntegerList(OGRFeatureH hFeat,
                            int iField,
                            int * pnCount) -&gt; const int *</code></pre><p>Fetch field value as a list of integers.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pnCount</strong>: an integer to put the list count (number of integers) into.</li></ul><p><strong>Returns</strong></p><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasstring" href="#GDAL.getfieldasstring"><code>GDAL.getfieldasstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsString(OGRFeatureH hFeat,
                       int iField) -&gt; const char *</code></pre><p>Fetch field value as a string.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldasstringlist" href="#GDAL.getfieldasstringlist"><code>GDAL.getfieldasstringlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldAsStringList(OGRFeatureH hFeat,
                           int iField) -&gt; char **</code></pre><p>Fetch field value as a list of strings.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldcount" href="#GDAL.getfieldcount"><code>GDAL.getfieldcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetFieldCount(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Fetch number of fields on the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the fields count from.</li></ul><p><strong>Returns</strong></p><p>count of fields.</p></div></div><div><div><pre><code class="language-none">OGR_F_GetFieldCount(OGRFeatureH hFeat) -&gt; int</code></pre><p>Fetch number of fields on this feature This will always be the same as the field count for the OGRFeatureDefn.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get the fields count from.</li></ul><p><strong>Returns</strong></p><p>count of fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfielddefn" href="#GDAL.getfielddefn"><code>GDAL.getfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetFieldDefn(OGRFeatureDefnH hDefn,
                    int iField) -&gt; OGRFieldDefnH</code></pre><p>Fetch field definition of the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the field definition from.</li><li><strong>iField</strong>: the field to fetch, between 0 and GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfielddefnref" href="#GDAL.getfielddefnref"><code>GDAL.getfielddefnref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetFieldDefnRef(OGRFeatureH hFeat,
                      int i) -&gt; OGRFieldDefnH</code></pre><p>Fetch definition for this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is found.</li><li><strong>i</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>an handle to the field definition (from the OGRFeatureDefn). This is an internal reference, and should not be deleted or modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldindex" href="#GDAL.getfieldindex"><code>GDAL.getfieldindex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn,
                     const char * pszFieldName) -&gt; int</code></pre><p>Find field by name.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get field index from.</li><li><strong>pszFieldName</strong>: the field name to search for.</li></ul><p><strong>Returns</strong></p><p>the field index, or -1 if no match found.</p></div></div><div><div><pre><code class="language-none">OGR_F_GetFieldIndex(OGRFeatureH hFeat,
                    const char * pszName) -&gt; int</code></pre><p>Fetch the field index given field name.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is found.</li><li><strong>pszName</strong>: the name of the field to search for.</li></ul><p><strong>Returns</strong></p><p>the field index, or -1 if no matching field is found.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldsubtypename" href="#GDAL.getfieldsubtypename"><code>GDAL.getfieldsubtypename</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_GetFieldSubTypeName(OGRFieldSubType eSubType) -&gt; const char *</code></pre><p>Fetch human readable name for a field subtype.</p><p><strong>Parameters</strong></p><ul><li><strong>eSubType</strong>: the field subtype to get name for.</li></ul><p><strong>Returns</strong></p><p>the name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfieldtypename" href="#GDAL.getfieldtypename"><code>GDAL.getfieldtypename</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_GetFieldTypeName(OGRFieldType eType) -&gt; const char *</code></pre><p>Fetch human readable name for a field type.</p><p><strong>Parameters</strong></p><ul><li><strong>eType</strong>: the field type to get name for.</li></ul><p><strong>Returns</strong></p><p>the name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getfilelist" href="#GDAL.getfilelist"><code>GDAL.getfilelist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetFileList(GDALDatasetH hDS) -&gt; char **</code></pre><p>Fetch files forming dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgcpcount" href="#GDAL.getgcpcount"><code>GDAL.getgcpcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetGCPCount(GDALDatasetH hDS) -&gt; int</code></pre><p>Get number of GCPs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgcpprojection" href="#GDAL.getgcpprojection"><code>GDAL.getgcpprojection</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetGCPProjection(GDALDatasetH hDS) -&gt; const char *</code></pre><p>Get output projection for GCPs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgcps" href="#GDAL.getgcps"><code>GDAL.getgcps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetGCPs(GDALDatasetH hDS) -&gt; const GDAL_GCP *</code></pre><p>Fetch GCPs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgenerate_db2_v72_byte_order" href="#GDAL.getgenerate_db2_v72_byte_order"><code>GDAL.getgenerate_db2_v72_byte_order</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRGetGenerate_DB2_V72_BYTE_ORDER() -&gt; int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeometrycolumn" href="#GDAL.getgeometrycolumn"><code>GDAL.getgeometrycolumn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetGeometryColumn(OGRLayerH) -&gt; const char *</code></pre><p>This method returns the name of the underlying database column being used as the geometry column, or &quot;&quot; if not supported.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>geometry column name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeometrycount" href="#GDAL.getgeometrycount"><code>GDAL.getgeometrycount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetGeometryCount(OGRGeometryH hGeom) -&gt; int</code></pre><p>Fetch the number of elements in a geometry or number of geometries in container.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: single geometry or geometry container from which to get the number of elements.</li></ul><p><strong>Returns</strong></p><p>the number of elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeometryname" href="#GDAL.getgeometryname"><code>GDAL.getgeometryname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetGeometryName(OGRGeometryH hGeom) -&gt; const char *</code></pre><p>Fetch WKT name for geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get name from.</li></ul><p><strong>Returns</strong></p><p>name used for this geometry type in well known text format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeometryref" href="#GDAL.getgeometryref"><code>GDAL.getgeometryref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetGeometryRef(OGRGeometryH hGeom,
                     int iSubGeom) -&gt; OGRGeometryH</code></pre><p>Fetch geometry from a geometry container.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry container from which to get a geometry from.</li><li><strong>iSubGeom</strong>: the index of the geometry to fetch, between 0 and getNumGeometries() - 1.</li></ul><p><strong>Returns</strong></p><p>handle to the requested geometry.</p></div></div><div><div><pre><code class="language-none">OGR_F_GetGeometryRef(OGRFeatureH hFeat) -&gt; OGRGeometryH</code></pre><p>Fetch an handle to feature geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get geometry from.</li></ul><p><strong>Returns</strong></p><p>an handle to internal feature geometry. This object should not be modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeometrytype" href="#GDAL.getgeometrytype"><code>GDAL.getgeometrytype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetGeometryType(OGRGeometryH hGeom) -&gt; OGRwkbGeometryType</code></pre><p>Fetch geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get type from.</li></ul><p><strong>Returns</strong></p><p>the geometry type code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomfieldcount" href="#GDAL.getgeomfieldcount"><code>GDAL.getgeomfieldcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetGeomFieldCount(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Fetch number of geometry fields on the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the fields count from.</li></ul><p><strong>Returns</strong></p><p>count of geometry fields.</p></div></div><div><div><pre><code class="language-none">OGR_F_GetGeomFieldCount(OGRFeatureH hFeat) -&gt; int</code></pre><p>Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the OGRFeatureDefn.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get the geometry fields count from.</li></ul><p><strong>Returns</strong></p><p>count of geometry fields.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomfielddefn" href="#GDAL.getgeomfielddefn"><code>GDAL.getgeomfielddefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetGeomFieldDefn(OGRFeatureDefnH hDefn,
                        int iGeomField) -&gt; OGRGeomFieldDefnH</code></pre><p>Fetch geometry field definition of the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the field definition from.</li><li><strong>iGeomField</strong>: the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.</li></ul><p><strong>Returns</strong></p><p>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomfielddefnref" href="#GDAL.getgeomfielddefnref"><code>GDAL.getgeomfielddefnref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetGeomFieldDefnRef(OGRFeatureH hFeat,
                          int i) -&gt; OGRGeomFieldDefnH</code></pre><p>Fetch definition for this geometry field.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is found.</li><li><strong>i</strong>: the field to fetch, from 0 to GetGeomFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>an handle to the field definition (from the OGRFeatureDefn). This is an internal reference, and should not be deleted or modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomfieldindex" href="#GDAL.getgeomfieldindex"><code>GDAL.getgeomfieldindex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn,
                         const char * pszGeomFieldName) -&gt; int</code></pre><p>Find geometry field by name.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get field index from.</li><li><strong>pszGeomFieldName</strong>: the geometry field name to search for.</li></ul><p><strong>Returns</strong></p><p>the geometry field index, or -1 if no match found.</p></div></div><div><div><pre><code class="language-none">OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat,
                        const char * pszName) -&gt; int</code></pre><p>Fetch the geometry field index given geometry field name.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the geometry field is found.</li><li><strong>pszName</strong>: the name of the geometry field to search for.</li></ul><p><strong>Returns</strong></p><p>the geometry field index, or -1 if no matching geometry field is found.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomfieldref" href="#GDAL.getgeomfieldref"><code>GDAL.getgeomfieldref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetGeomFieldRef(OGRFeatureH hFeat,
                      int iField) -&gt; OGRGeometryH</code></pre><p>Fetch an handle to feature geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get geometry from.</li><li><strong>iField</strong>: geometry field to get.</li></ul><p><strong>Returns</strong></p><p>an handle to internal feature geometry. This object should not be modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeomtype" href="#GDAL.getgeomtype"><code>GDAL.getgeomtype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetGeomType(OGRFeatureDefnH hDefn) -&gt; OGRwkbGeometryType</code></pre><p>Fetch the geometry base type of the passed feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the geometry type from.</li></ul><p><strong>Returns</strong></p><p>the base type for all geometry related to this definition.</p></div></div><div><div><pre><code class="language-none">OGR_L_GetGeomType(OGRLayerH) -&gt; OGRwkbGeometryType</code></pre><p>Return the layer geometry type.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li></ul><p><strong>Returns</strong></p><p>the geometry type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getgeotransform" href="#GDAL.getgeotransform"><code>GDAL.getgeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetGeoTransform(GDALDatasetH hDS,
                    double * padfTransform) -&gt; CPLErr</code></pre><p>Fetch the affine transformation coefficients.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getinternalhandle" href="#GDAL.getinternalhandle"><code>GDAL.getinternalhandle</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetInternalHandle(GDALDatasetH hDS,
                      const char * pszRequest) -&gt; void *</code></pre><p>Fetch a format specific internally meaningful handle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getinvflattening" href="#GDAL.getinvflattening"><code>GDAL.getinvflattening</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetInvFlattening(OGRSpatialReferenceH hSRS,
                    OGRErr * pnErr) -&gt; double</code></pre><p>Get spheroid inverse flattening.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getjpeg2000structure" href="#GDAL.getjpeg2000structure"><code>GDAL.getjpeg2000structure</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetJPEG2000Structure(const char * pszFilename,
                         char ** papszOptions) -&gt; CPLXMLNode *</code></pre><p>Dump the structure of a JPEG2000 file as a XML tree.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: filename.</li><li><strong>papszOptions</strong>: NULL terminated list of options, or NULL. Allowed options are BINARY<em>CONTENT=YES, TEXT</em>CONTENT=YES, CODESTREAM=YES, ALL=YES.</li></ul><p><strong>Returns</strong></p><p>XML tree (to be freed with CPLDestroyXMLNode()) or NULL in case of error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getjustify" href="#GDAL.getjustify"><code>GDAL.getjustify</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetJustify(OGRFieldDefnH hDefn) -&gt; OGRJustification</code></pre><p>Get the justification for this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to get justification from.</li></ul><p><strong>Returns</strong></p><p>the justification.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlasterrormsg" href="#GDAL.getlasterrormsg"><code>GDAL.getlasterrormsg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLGetLastErrorMsg() -&gt; const char *</code></pre><p>Get the last error message.</p><p><strong>Returns</strong></p><p>the last error message, or NULL if there is no posted error message.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlasterrorno" href="#GDAL.getlasterrorno"><code>GDAL.getlasterrorno</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLGetLastErrorNo() -&gt; CPLErrorNum</code></pre><p>Fetch the last error number.</p><p><strong>Returns</strong></p><p>the error number of the last error to occur, or CPLE_None (0) if there are no posted errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlasterrortype" href="#GDAL.getlasterrortype"><code>GDAL.getlasterrortype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLGetLastErrorType() -&gt; CPLErr</code></pre><p>Fetch the last error type.</p><p><strong>Returns</strong></p><p>the error type of the last error to occur, or CE_None (0) if there are no posted errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlaststylename" href="#GDAL.getlaststylename"><code>GDAL.getlaststylename</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_GetLastStyleName(OGRStyleTableH hStyleTable) -&gt; const char *</code></pre><p>Get the style name of the last style string fetched with OGR<em>STBL</em>GetNextStyle.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li></ul><p><strong>Returns</strong></p><p>the Name of the last style string or NULL on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlayer" href="#GDAL.getlayer"><code>GDAL.getlayer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_GetLayer(OGRDataSourceH,
                int) -&gt; OGRLayerH</code></pre><p>Fetch a layer by index.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source from which to get the layer.</li><li><strong>iLayer</strong>: a layer number between 0 and OGR<em>DS</em>GetLayerCount()-1.</li></ul><p><strong>Returns</strong></p><p>an handle to the layer, or NULL if iLayer is out of range or an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlayerbyname" href="#GDAL.getlayerbyname"><code>GDAL.getlayerbyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_GetLayerByName(OGRDataSourceH,
                      const char *) -&gt; OGRLayerH</code></pre><p>Fetch a layer by name.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source from which to get the layer.</li><li><strong>pszLayerName</strong>: Layer the layer name of the layer to fetch.</li></ul><p><strong>Returns</strong></p><p>an handle to the layer, or NULL if the layer is not found or an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlayercount" href="#GDAL.getlayercount"><code>GDAL.getlayercount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_GetLayerCount(OGRDataSourceH) -&gt; int</code></pre><p>Get the number of layers in this data source.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source from which to get the number of layers.</li></ul><p><strong>Returns</strong></p><p>layer count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlayerdefn" href="#GDAL.getlayerdefn"><code>GDAL.getlayerdefn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetLayerDefn(OGRLayerH) -&gt; OGRFeatureDefnH</code></pre><p>Fetch the schema information for this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to get the schema information.</li></ul><p><strong>Returns</strong></p><p>an handle to the feature definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlineargeometry" href="#GDAL.getlineargeometry"><code>GDAL.getlineargeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetLinearGeometry(OGRGeometryH hGeom,
                        double dfMaxAngleStepSizeDegrees,
                        char ** papszOptions) -&gt; OGRGeometryH</code></pre><p>Return, possibly approximate, linear version of this geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the geometry to operate on.</li><li><strong>dfMaxAngleStepSizeDegrees</strong>: the largest step in degrees along the arc, zero to use the default setting.</li><li><strong>papszOptions</strong>: options as a null-terminated list of strings or NULL. See OGRGeometryFactory::curveToLineString() for valid options.</li></ul><p><strong>Returns</strong></p><p>a new geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getlinearunits" href="#GDAL.getlinearunits"><code>GDAL.getlinearunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetLinearUnits(OGRSpatialReferenceH hSRS,
                  char ** ppszName) -&gt; double</code></pre><p>Fetch linear projection units.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getm" href="#GDAL.getm"><code>GDAL.getm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetM(OGRGeometryH hGeom,
           int i) -&gt; double</code></pre><p>Fetch the m coordinate of a point from a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the M coordinate.</li><li><strong>i</strong>: point to get the M coordinate.</li></ul><p><strong>Returns</strong></p><p>the M coordinate of this point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getmaskband" href="#GDAL.getmaskband"><code>GDAL.getmaskband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetMaskBand(GDALRasterBandH hBand) -&gt; GDALRasterBandH</code></pre><p>Return the mask band associated with the band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getmaskflags" href="#GDAL.getmaskflags"><code>GDAL.getmaskflags</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetMaskFlags(GDALRasterBandH hBand) -&gt; int</code></pre><p>Return the status flags of the mask band associated with the band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getmetadata" href="#GDAL.getmetadata"><code>GDAL.getmetadata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetMetadata(GDALMajorObjectH hObject,
                const char * pszDomain) -&gt; char **</code></pre><p>Fetch metadata.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getmetadatadomainlist" href="#GDAL.getmetadatadomainlist"><code>GDAL.getmetadatadomainlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetMetadataDomainList(GDALMajorObjectH hObject) -&gt; char **</code></pre><p>Fetch list of metadata domains.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getmetadataitem" href="#GDAL.getmetadataitem"><code>GDAL.getmetadataitem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetMetadataItem(GDALMajorObjectH hObject,
                    const char * pszName,
                    const char * pszDomain) -&gt; const char *</code></pre><p>Fetch single metadata item.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getname" href="#GDAL.getname"><code>GDAL.getname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetName(OGRFeatureDefnH hDefn) -&gt; const char *</code></pre><p>Get name of the OGRFeatureDefn passed as an argument.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to get the name from.</li></ul><p><strong>Returns</strong></p><p>the name. This name is internal and should not be modified, or freed.</p></div></div><div><div><pre><code class="language-none">OGR_L_GetName(OGRLayerH) -&gt; const char *</code></pre><p>Return the layer name.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li></ul><p><strong>Returns</strong></p><p>the layer name (must not been freed)</p></div></div><div><div><pre><code class="language-none">OGR_DS_GetName(OGRDataSourceH) -&gt; const char *</code></pre><p>Returns the name of the data source.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source to get the name from.</li></ul><p><strong>Returns</strong></p><p>pointer to an internal name string which should not be modified or freed by the caller.</p></div></div><div><div><pre><code class="language-none">OGR_Dr_GetName(OGRSFDriverH) -&gt; const char *</code></pre><p>Fetch name of driver (file format).</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver to get the name from.</li></ul><p><strong>Returns</strong></p><p>driver name. This is an internal string and should not be modified or freed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnameref" href="#GDAL.getnameref"><code>GDAL.getnameref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetNameRef(OGRFieldDefnH hDefn) -&gt; const char *</code></pre><p>Fetch name of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition.</li></ul><p><strong>Returns</strong></p><p>the name of the field definition.</p></div></div><div><div><pre><code class="language-none">OGR_GFld_GetNameRef(OGRGeomFieldDefnH hDefn) -&gt; const char *</code></pre><p>Fetch name of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition.</li></ul><p><strong>Returns</strong></p><p>the name of the geometry field definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnativedata" href="#GDAL.getnativedata"><code>GDAL.getnativedata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetNativeData(OGRFeatureH hFeat) -&gt; const char *</code></pre><p>Returns the native data for the feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature.</li></ul><p><strong>Returns</strong></p><p>a string with the native data, or NULL if there is none.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnativemediatype" href="#GDAL.getnativemediatype"><code>GDAL.getnativemediatype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetNativeMediaType(OGRFeatureH hFeat) -&gt; const char *</code></pre><p>Returns the native media type for the feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature.</li></ul><p><strong>Returns</strong></p><p>a string with the native media type, or NULL if there is none.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnextfeature" href="#GDAL.getnextfeature"><code>GDAL.getnextfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetNextFeature(OGRLayerH) -&gt; OGRFeatureH</code></pre><p>Fetch the next available feature from this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer from which feature are read.</li></ul><p><strong>Returns</strong></p><p>an handle to a feature, or NULL if no more features are available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnextstyle" href="#GDAL.getnextstyle"><code>GDAL.getnextstyle</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_GetNextStyle(OGRStyleTableH hStyleTable) -&gt; const char *</code></pre><p>Get the next style string from the table.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li></ul><p><strong>Returns</strong></p><p>the next style string or NULL on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnoncomplexdatatype" href="#GDAL.getnoncomplexdatatype"><code>GDAL.getnoncomplexdatatype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetNonComplexDataType(GDALDataType) -&gt; GDALDataType</code></pre><p>Return the base data type for the specified input.</p><p><strong>Parameters</strong></p><ul><li><strong>eDataType</strong>: type, such as GDT_CFloat32.</li></ul><p><strong>Returns</strong></p><p>GDAL data type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnonlineargeometriesenabledflag" href="#GDAL.getnonlineargeometriesenabledflag"><code>GDAL.getnonlineargeometriesenabledflag</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRGetNonLinearGeometriesEnabledFlag(void) -&gt; int</code></pre><p>Get flag to enable/disable returning non-linear geometries in the C API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getnormprojparm" href="#GDAL.getnormprojparm"><code>GDAL.getnormprojparm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetNormProjParm(OGRSpatialReferenceH hSRS,
                   const char * pszName,
                   double dfDefaultValue,
                   OGRErr * pnErr) -&gt; double</code></pre><p>This function is the same as OGRSpatialReference::</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getopendatasets" href="#GDAL.getopendatasets"><code>GDAL.getopendatasets</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetOpenDatasets(GDALDatasetH ** ppahDSList,
                    int * pnCount) -&gt; void</code></pre><p>Fetch all open GDAL dataset handles.</p></div></div></section><pre><code class="language-none">GDAL.getopends</code></pre><pre><code class="language-none">GDAL.getopendscount</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getoverview" href="#GDAL.getoverview"><code>GDAL.getoverview</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetOverview(GDALRasterBandH hBand,
                int i) -&gt; GDALRasterBandH</code></pre><p>Fetch overview raster band object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getoverviewcount" href="#GDAL.getoverviewcount"><code>GDAL.getoverviewcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetOverviewCount(GDALRasterBandH hBand) -&gt; int</code></pre><p>Return the number of overview layers available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpaletteinterpretation" href="#GDAL.getpaletteinterpretation"><code>GDAL.getpaletteinterpretation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetPaletteInterpretation(GDALColorTableH hTable) -&gt; GDALPaletteInterp</code></pre><p>Fetch palette interpretation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpaletteinterpretationname" href="#GDAL.getpaletteinterpretationname"><code>GDAL.getpaletteinterpretationname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetPaletteInterpretationName(GDALPaletteInterp) -&gt; const char *</code></pre><p>Get name of palette interpretation.</p><p><strong>Parameters</strong></p><ul><li><strong>eInterp</strong>: palette interpretation to get name of.</li></ul><p><strong>Returns</strong></p><p>string corresponding to palette interpretation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getparamdbl" href="#GDAL.getparamdbl"><code>GDAL.getparamdbl</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_GetParamDbl(OGRStyleToolH hST,
                   int eParam,
                   int * bValueIsNull) -&gt; double</code></pre><p>Get Style Tool parameter value as a double.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>bValueIsNull</strong>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</li></ul><p><strong>Returns</strong></p><p>the parameter value as double and sets bValueIsNull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getparamnum" href="#GDAL.getparamnum"><code>GDAL.getparamnum</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_GetParamNum(OGRStyleToolH hST,
                   int eParam,
                   int * bValueIsNull) -&gt; int</code></pre><p>Get Style Tool parameter value as an integer.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>bValueIsNull</strong>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</li></ul><p><strong>Returns</strong></p><p>the parameter value as integer and sets bValueIsNull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getparamstr" href="#GDAL.getparamstr"><code>GDAL.getparamstr</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_GetParamStr(OGRStyleToolH hST,
                   int eParam,
                   int * bValueIsNull) -&gt; const char *</code></pre><p>Get Style Tool parameter value as string.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>bValueIsNull</strong>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</li></ul><p><strong>Returns</strong></p><p>the parameter value as string and sets bValueIsNull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpart" href="#GDAL.getpart"><code>GDAL.getpart</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_GetPart(OGRStyleMgrH hSM,
               int nPartId,
               const char * pszStyleString) -&gt; OGRStyleToolH</code></pre><p>Fetch a part (style tool) from the current style.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>nPartId</strong>: the part number (0-based index).</li><li><strong>pszStyleString</strong>: (optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</li></ul><p><strong>Returns</strong></p><p>OGRStyleToolH of the requested part (style tools) or NULL on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpartcount" href="#GDAL.getpartcount"><code>GDAL.getpartcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_GetPartCount(OGRStyleMgrH hSM,
                    const char * pszStyleString) -&gt; int</code></pre><p>Get the number of parts in a style.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>pszStyleString</strong>: (optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</li></ul><p><strong>Returns</strong></p><p>the number of parts (style tools) in the style.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpoint" href="#GDAL.getpoint"><code>GDAL.getpoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetPoint(OGRGeometryH hGeom,
               int i,
               double * pdfX,
               double * pdfY,
               double * pdfZ) -&gt; void</code></pre><p>Fetch a point in line string or a point geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the coordinates.</li><li><strong>i</strong>: the vertex to fetch, from 0 to getNumPoints()-1, zero for a point.</li><li><strong>pdfX</strong>: value of x coordinate.</li><li><strong>pdfY</strong>: value of y coordinate.</li><li><strong>pdfZ</strong>: value of z coordinate.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpointcount" href="#GDAL.getpointcount"><code>GDAL.getpointcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetPointCount(OGRGeometryH hGeom) -&gt; int</code></pre><p>Fetch number of points from a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the number of points.</li></ul><p><strong>Returns</strong></p><p>the number of points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpoints" href="#GDAL.getpoints"><code>GDAL.getpoints</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetPoints(OGRGeometryH hGeom,
                void * pabyX,
                int nXStride,
                void * pabyY,
                int nYStride,
                void * pabyZ,
                int nZStride) -&gt; int</code></pre><p>Returns all points of line string.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the coordinates.</li><li><strong>pabyX</strong>: a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL.</li><li><strong>nXStride</strong>: the number of bytes between 2 elements of pabyX.</li><li><strong>pabyY</strong>: a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL.</li><li><strong>nYStride</strong>: the number of bytes between 2 elements of pabyY.</li><li><strong>pabyZ</strong>: a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL.</li><li><strong>nZStride</strong>: the number of bytes between 2 elements of pabyZ.</li></ul><p><strong>Returns</strong></p><p>the number of points</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpointszm" href="#GDAL.getpointszm"><code>GDAL.getpointszm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetPointsZM(OGRGeometryH hGeom,
                  void * pabyX,
                  int nXStride,
                  void * pabyY,
                  int nYStride,
                  void * pabyZ,
                  int nZStride,
                  void * pabyM,
                  int nMStride) -&gt; int</code></pre><p>Returns all points of line string.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the coordinates.</li><li><strong>pabyX</strong>: a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL.</li><li><strong>nXStride</strong>: the number of bytes between 2 elements of pabyX.</li><li><strong>pabyY</strong>: a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL.</li><li><strong>nYStride</strong>: the number of bytes between 2 elements of pabyY.</li><li><strong>pabyZ</strong>: a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL.</li><li><strong>nZStride</strong>: the number of bytes between 2 elements of pabyZ.</li><li><strong>pabyM</strong>: a buffer of at last size (sizeof(double) * nMStride * nPointCount) bytes, may be NULL.</li><li><strong>nMStride</strong>: the number of bytes between 2 elements of pabyM.</li></ul><p><strong>Returns</strong></p><p>the number of points</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getpointzm" href="#GDAL.getpointzm"><code>GDAL.getpointzm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetPointZM(OGRGeometryH hGeom,
                 int i,
                 double * pdfX,
                 double * pdfY,
                 double * pdfZ,
                 double * pdfM) -&gt; void</code></pre><p>Fetch a point in line string or a point geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the coordinates.</li><li><strong>i</strong>: the vertex to fetch, from 0 to getNumPoints()-1, zero for a point.</li><li><strong>pdfX</strong>: value of x coordinate.</li><li><strong>pdfY</strong>: value of y coordinate.</li><li><strong>pdfZ</strong>: value of z coordinate.</li><li><strong>pdfM</strong>: value of m coordinate.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getprecision" href="#GDAL.getprecision"><code>GDAL.getprecision</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetPrecision(OGRFieldDefnH hDefn) -&gt; int</code></pre><p>Get the formatting precision for this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to get precision from.</li></ul><p><strong>Returns</strong></p><p>the precision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getprimemeridian" href="#GDAL.getprimemeridian"><code>GDAL.getprimemeridian</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetPrimeMeridian(OGRSpatialReferenceH hSRS,
                    char ** ppszName) -&gt; double</code></pre><p>Fetch prime meridian info.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getprojectionref" href="#GDAL.getprojectionref"><code>GDAL.getprojectionref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetProjectionRef(GDALDatasetH hDS) -&gt; const char *</code></pre><p>Fetch the projection definition string for this dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getprojparm" href="#GDAL.getprojparm"><code>GDAL.getprojparm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetProjParm(OGRSpatialReferenceH hSRS,
               const char * pszName,
               double dfDefaultValue,
               OGRErr * pnErr) -&gt; double</code></pre><p>Fetch a projection parameter value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrandomrastersample" href="#GDAL.getrandomrastersample"><code>GDAL.getrandomrastersample</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRandomRasterSample(GDALRasterBandH,
                          int,
                          float *) -&gt; int</code></pre><p>Undocumented.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: undocumented.</li><li><strong>nSamples</strong>: undocumented.</li><li><strong>pafSampleBuf</strong>: undocumented.</li></ul><p><strong>Returns</strong></p><p>undocumented</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasteraccess" href="#GDAL.getrasteraccess"><code>GDAL.getrasteraccess</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterAccess(GDALRasterBandH hBand) -&gt; GDALAccess</code></pre><p>Find out if we have update permission for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterband" href="#GDAL.getrasterband"><code>GDAL.getrasterband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterBand(GDALDatasetH hDS,
                  int nBandId) -&gt; GDALRasterBandH</code></pre><p>Fetch a band object for a dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterbandxsize" href="#GDAL.getrasterbandxsize"><code>GDAL.getrasterbandxsize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterBandXSize(GDALRasterBandH hBand) -&gt; int</code></pre><p>Fetch XSize of raster.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterbandysize" href="#GDAL.getrasterbandysize"><code>GDAL.getrasterbandysize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterBandYSize(GDALRasterBandH hBand) -&gt; int</code></pre><p>Fetch YSize of raster.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastercategorynames" href="#GDAL.getrastercategorynames"><code>GDAL.getrastercategorynames</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterCategoryNames(GDALRasterBandH hBand) -&gt; char **</code></pre><p>Fetch the list of category names for this raster.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastercolorinterpretation" href="#GDAL.getrastercolorinterpretation"><code>GDAL.getrastercolorinterpretation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterColorInterpretation(GDALRasterBandH hBand) -&gt; GDALColorInterp</code></pre><p>How should this band be interpreted as color?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastercolortable" href="#GDAL.getrastercolortable"><code>GDAL.getrastercolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterColorTable(GDALRasterBandH hBand) -&gt; GDALColorTableH</code></pre><p>Fetch the color table associated with band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastercount" href="#GDAL.getrastercount"><code>GDAL.getrastercount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterCount(GDALDatasetH hDS) -&gt; int</code></pre><p>Fetch the number of raster bands on this dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterdatatype" href="#GDAL.getrasterdatatype"><code>GDAL.getrasterdatatype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterDataType(GDALRasterBandH hBand) -&gt; GDALDataType</code></pre><p>Fetch the pixel data type for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterhistogram" href="#GDAL.getrasterhistogram"><code>GDAL.getrasterhistogram</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterHistogram(GDALRasterBandH hBand,
                       double dfMin,
                       double dfMax,
                       int nBuckets,
                       int * panHistogram,
                       int bIncludeOutOfRange,
                       int bApproxOK,
                       GDALProgressFunc pfnProgress,
                       void * pProgressData) -&gt; CPLErr</code></pre><p>Compute raster histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterhistogramex" href="#GDAL.getrasterhistogramex"><code>GDAL.getrasterhistogramex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterHistogramEx(GDALRasterBandH hBand,
                         double dfMin,
                         double dfMax,
                         int nBuckets,
                         GUIntBig * panHistogram,
                         int bIncludeOutOfRange,
                         int bApproxOK,
                         GDALProgressFunc pfnProgress,
                         void * pProgressData) -&gt; CPLErr</code></pre><p>Compute raster histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastermaximum" href="#GDAL.getrastermaximum"><code>GDAL.getrastermaximum</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterMaximum(GDALRasterBandH hBand,
                     int * pbSuccess) -&gt; double</code></pre><p>Fetch the maximum value for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterminimum" href="#GDAL.getrasterminimum"><code>GDAL.getrasterminimum</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterMinimum(GDALRasterBandH hBand,
                     int * pbSuccess) -&gt; double</code></pre><p>Fetch the minimum value for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasternodatavalue" href="#GDAL.getrasternodatavalue"><code>GDAL.getrasternodatavalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterNoDataValue(GDALRasterBandH hBand,
                         int * pbSuccess) -&gt; double</code></pre><p>Fetch the no data value for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasteroffset" href="#GDAL.getrasteroffset"><code>GDAL.getrasteroffset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterOffset(GDALRasterBandH hBand,
                    int * pbSuccess) -&gt; double</code></pre><p>Fetch the raster value offset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastersampleoverview" href="#GDAL.getrastersampleoverview"><code>GDAL.getrastersampleoverview</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterSampleOverview(GDALRasterBandH hBand,
                            int nDesiredSamples) -&gt; GDALRasterBandH</code></pre><p>Fetch best sampling overview.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrastersampleoverviewex" href="#GDAL.getrastersampleoverviewex"><code>GDAL.getrastersampleoverviewex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterSampleOverviewEx(GDALRasterBandH hBand,
                              GUIntBig nDesiredSamples) -&gt; GDALRasterBandH</code></pre><p>Fetch best sampling overview.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterscale" href="#GDAL.getrasterscale"><code>GDAL.getrasterscale</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterScale(GDALRasterBandH hBand,
                   int * pbSuccess) -&gt; double</code></pre><p>Fetch the raster value scale.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterstatistics" href="#GDAL.getrasterstatistics"><code>GDAL.getrasterstatistics</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterStatistics(GDALRasterBandH hBand,
                        int bApproxOK,
                        int bForce,
                        double * pdfMin,
                        double * pdfMax,
                        double * pdfMean,
                        double * pdfStdDev) -&gt; CPLErr</code></pre><p>Fetch image statistics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterunittype" href="#GDAL.getrasterunittype"><code>GDAL.getrasterunittype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterUnitType(GDALRasterBandH hBand) -&gt; const char *</code></pre><p>Return raster unit type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterxsize" href="#GDAL.getrasterxsize"><code>GDAL.getrasterxsize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterXSize(GDALDatasetH hDataset) -&gt; int</code></pre><p>Fetch raster width in pixels.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrasterysize" href="#GDAL.getrasterysize"><code>GDAL.getrasterysize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetRasterYSize(GDALDatasetH hDataset) -&gt; int</code></pre><p>Fetch raster height in pixels.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrawfieldref" href="#GDAL.getrawfieldref"><code>GDAL.getrawfieldref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetRawFieldRef(OGRFeatureH hFeat,
                     int iField) -&gt; OGRField *</code></pre><p>Fetch an handle to the internal field value given the index.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which field is found.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li></ul><p><strong>Returns</strong></p><p>the returned handle is to an internal data structure, and should not be freed, or modified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrefcount" href="#GDAL.getrefcount"><code>GDAL.getrefcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetRefCount(OGRLayerH hLayer) -&gt; int</code></pre></div></div><div><div><pre><code class="language-none">OGR_DS_GetRefCount(OGRDataSourceH hDataSource) -&gt; int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getreferencecount" href="#GDAL.getreferencecount"><code>GDAL.getreferencecount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_GetReferenceCount(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Fetch current reference count.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li></ul><p><strong>Returns</strong></p><p>the current reference count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getrgbfromstring" href="#GDAL.getrgbfromstring"><code>GDAL.getrgbfromstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_GetRGBFromString(OGRStyleToolH hST,
                        const char * pszColor,
                        int * pnRed,
                        int * pnGreen,
                        int * pnBlue,
                        int * pnAlpha) -&gt; int</code></pre><p>Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>pszColor</strong>: the color to parse</li><li><strong>pnRed</strong>: pointer to an int in which the red value will be returned</li><li><strong>pnGreen</strong>: pointer to an int in which the green value will be returned</li><li><strong>pnBlue</strong>: pointer to an int in which the blue value will be returned</li><li><strong>pnAlpha</strong>: pointer to an int in which the (optional) alpha value will be returned</li></ul><p><strong>Returns</strong></p><p>TRUE if the color could be successfully parsed, or FALSE in case of errors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getsemimajor" href="#GDAL.getsemimajor"><code>GDAL.getsemimajor</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetSemiMajor(OGRSpatialReferenceH hSRS,
                OGRErr * pnErr) -&gt; double</code></pre><p>Get spheroid semi major axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getsemiminor" href="#GDAL.getsemiminor"><code>GDAL.getsemiminor</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetSemiMinor(OGRSpatialReferenceH hSRS,
                OGRErr * pnErr) -&gt; double</code></pre><p>Get spheroid semi minor axis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getspatialfilter" href="#GDAL.getspatialfilter"><code>GDAL.getspatialfilter</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_GetSpatialFilter(OGRLayerH) -&gt; OGRGeometryH</code></pre><p>This function returns the current spatial filter for this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to get the spatial filter from.</li></ul><p><strong>Returns</strong></p><p>an handle to the spatial filter geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getspatialref" href="#GDAL.getspatialref"><code>GDAL.getspatialref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_GFld_GetSpatialRef(OGRGeomFieldDefnH hDefn) -&gt; OGRSpatialReferenceH</code></pre><p>Fetch spatial reference system of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition</li></ul><p><strong>Returns</strong></p><p>field spatial reference system.</p></div></div><div><div><pre><code class="language-none">OGR_L_GetSpatialRef(OGRLayerH) -&gt; OGRSpatialReferenceH</code></pre><p>Fetch the spatial reference system for this layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to get the spatial reference from.</li></ul><p><strong>Returns</strong></p><p>spatial reference, or NULL if there isn&#39;t one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getspatialreference" href="#GDAL.getspatialreference"><code>GDAL.getspatialreference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetSpatialReference(OGRGeometryH hGeom) -&gt; OGRSpatialReferenceH</code></pre><p>Returns spatial reference system for geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get spatial reference from.</li></ul><p><strong>Returns</strong></p><p>a reference to the spatial reference geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getstylestring" href="#GDAL.getstylestring"><code>GDAL.getstylestring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetStyleString(OGRFeatureH hFeat) -&gt; const char *</code></pre><p>Fetch style string for this feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to get the style from.</li></ul><p><strong>Returns</strong></p><p>a reference to a representation in string format, or NULL if there isn&#39;t one.</p></div></div><div><div><pre><code class="language-none">OGR_ST_GetStyleString(OGRStyleToolH hST) -&gt; const char *</code></pre><p>Get the style string for this Style Tool.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li></ul><p><strong>Returns</strong></p><p>the style string for this style tool or &quot;&quot; if the hST is invalid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getstyletable" href="#GDAL.getstyletable"><code>GDAL.getstyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_GetStyleTable(OGRFeatureH hFeat) -&gt; OGRStyleTableH</code></pre><p>Return style table.</p></div></div><div><div><pre><code class="language-none">OGR_L_GetStyleTable(OGRLayerH hLayer) -&gt; OGRStyleTableH</code></pre><p>Get style table.</p></div></div><div><div><pre><code class="language-none">OGR_DS_GetStyleTable(OGRDataSourceH hDS) -&gt; OGRStyleTableH</code></pre><p>Get style table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getsubtype" href="#GDAL.getsubtype"><code>GDAL.getsubtype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetSubType(OGRFieldDefnH hDefn) -&gt; OGRFieldSubType</code></pre><p>Fetch subtype of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to get subtype from.</li></ul><p><strong>Returns</strong></p><p>field subtype.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getsummaryrefcount" href="#GDAL.getsummaryrefcount"><code>GDAL.getsummaryrefcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_GetSummaryRefCount(OGRDataSourceH hDataSource) -&gt; int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gettargetlinearunits" href="#GDAL.gettargetlinearunits"><code>GDAL.gettargetlinearunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetTargetLinearUnits(OGRSpatialReferenceH hSRS,
                        const char * pszTargetKey,
                        char ** ppszName) -&gt; double</code></pre><p>Fetch linear projection units.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gettowgs84" href="#GDAL.gettowgs84"><code>GDAL.gettowgs84</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetTOWGS84(OGRSpatialReferenceH hSRS,
              double * padfCoeff,
              int nCoeffCount) -&gt; OGRErr</code></pre><p>Fetch TOWGS84 parameters, if available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gettype" href="#GDAL.gettype"><code>GDAL.gettype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetType(OGRFieldDefnH hDefn) -&gt; OGRFieldType</code></pre><p>Fetch type of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to get type from.</li></ul><p><strong>Returns</strong></p><p>field type.</p></div></div><div><div><pre><code class="language-none">OGR_GFld_GetType(OGRGeomFieldDefnH hDefn) -&gt; OGRwkbGeometryType</code></pre><p>Fetch geometry type of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition to get type from.</li></ul><p><strong>Returns</strong></p><p>field geometry type.</p></div></div><div><div><pre><code class="language-none">OGR_ST_GetType(OGRStyleToolH hST) -&gt; OGRSTClassId</code></pre><p>Determine type of Style Tool.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li></ul><p><strong>Returns</strong></p><p>the style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getunit" href="#GDAL.getunit"><code>GDAL.getunit</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_GetUnit(OGRStyleToolH hST) -&gt; OGRSTUnitId</code></pre><p>Get Style Tool units.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li></ul><p><strong>Returns</strong></p><p>the style tool units.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getutmzone" href="#GDAL.getutmzone"><code>GDAL.getutmzone</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRGetUTMZone(OGRSpatialReferenceH hSRS,
              int * pbNorth) -&gt; int</code></pre><p>Get utm zone information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getvirtualmemauto" href="#GDAL.getvirtualmemauto"><code>GDAL.getvirtualmemauto</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGetVirtualMemAuto(GDALRasterBandH hBand,
                      GDALRWFlag eRWFlag,
                      int * pnPixelSpace,
                      GIntBig * pnLineSpace,
                      char ** papszOptions) -&gt; CPLVirtualMem *</code></pre><p>Create a CPLVirtualMem object from a GDAL raster band object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getwidth" href="#GDAL.getwidth"><code>GDAL.getwidth</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_GetWidth(OGRFieldDefnH hDefn) -&gt; int</code></pre><p>Get the formatting width for this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to get width from.</li></ul><p><strong>Returns</strong></p><p>the width, zero means no specified width.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getx" href="#GDAL.getx"><code>GDAL.getx</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetX(OGRGeometryH hGeom,
           int i) -&gt; double</code></pre><p>Fetch the x coordinate of a point from a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the x coordinate.</li><li><strong>i</strong>: point to get the x coordinate.</li></ul><p><strong>Returns</strong></p><p>the X coordinate of this point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gety" href="#GDAL.gety"><code>GDAL.gety</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetY(OGRGeometryH hGeom,
           int i) -&gt; double</code></pre><p>Fetch the x coordinate of a point from a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the y coordinate.</li><li><strong>i</strong>: point to get the Y coordinate.</li></ul><p><strong>Returns</strong></p><p>the Y coordinate of this point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.getz" href="#GDAL.getz"><code>GDAL.getz</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_GetZ(OGRGeometryH hGeom,
           int i) -&gt; double</code></pre><p>Fetch the z coordinate of a point from a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry from which to get the Z coordinate.</li><li><strong>i</strong>: point to get the Z coordinate.</li></ul><p><strong>Returns</strong></p><p>the Z coordinate of this point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gfld_create" href="#GDAL.gfld_create"><code>GDAL.gfld_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_GFld_Create(const char * pszName,
                OGRwkbGeometryType eType) -&gt; OGRGeomFieldDefnH</code></pre><p>Create a new field geometry definition.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the name of the new field definition.</li><li><strong>eType</strong>: the type of the new field definition.</li></ul><p><strong>Returns</strong></p><p>handle to the new field definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.grid" href="#GDAL.grid"><code>GDAL.grid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGrid(const char * pszDest,
         GDALDatasetH hSrcDataset,
         const GDALGridOptions * psOptionsIn,
         int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Create raster from the scattered data.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path.</li><li><strong>hSrcDataset</strong>: the source dataset handle.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALGridOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred or NULL.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose()) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridcontextcreate" href="#GDAL.gridcontextcreate"><code>GDAL.gridcontextcreate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridContextCreate(GDALGridAlgorithm eAlgorithm,
                      const void * poOptions,
                      GUInt32 nPoints,
                      const double * padfX,
                      const double * padfY,
                      const double * padfZ,
                      int bCallerWillKeepPointArraysAlive) -&gt; GDALGridContext *</code></pre><p>Creates a context to do regular gridding from the scattered data.</p><p><strong>Parameters</strong></p><ul><li><strong>eAlgorithm</strong>: Gridding method.</li><li><strong>poOptions</strong>: Options to control chosen gridding method.</li><li><strong>nPoints</strong>: Number of elements in input arrays.</li><li><strong>padfX</strong>: Input array of X coordinates.</li><li><strong>padfY</strong>: Input array of Y coordinates.</li><li><strong>padfZ</strong>: Input array of Z values.</li><li><strong>bCallerWillKeepPointArraysAlive</strong>: Whether the provided padfX, padfY, padfZ arrays will still be &quot;alive&quot; during the calls to GDALGridContextProcess(). Setting to TRUE prevent them from being duplicated in the context. If unsure, set to FALSE.</li></ul><p><strong>Returns</strong></p><p>the context (to be freed with GDALGridContextFree()) or NULL in case or error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridcontextfree" href="#GDAL.gridcontextfree"><code>GDAL.gridcontextfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridContextFree(GDALGridContext * psContext) -&gt; void</code></pre><p>Free a context used created by GDALGridContextCreate()</p><p><strong>Parameters</strong></p><ul><li><strong>psContext</strong>: the context.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridcontextprocess" href="#GDAL.gridcontextprocess"><code>GDAL.gridcontextprocess</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridContextProcess(GDALGridContext * psContext,
                       double dfXMin,
                       double dfXMax,
                       double dfYMin,
                       double dfYMax,
                       GUInt32 nXSize,
                       GUInt32 nYSize,
                       GDALDataType eType,
                       void * pData,
                       GDALProgressFunc pfnProgress,
                       void * pProgressArg) -&gt; CPLErr</code></pre><p>Do the gridding of a window of a raster.</p><p><strong>Parameters</strong></p><ul><li><strong>psContext</strong>: Gridding context.</li><li><strong>dfXMin</strong>: Lowest X border of output grid.</li><li><strong>dfXMax</strong>: Highest X border of output grid.</li><li><strong>dfYMin</strong>: Lowest Y border of output grid.</li><li><strong>dfYMax</strong>: Highest Y border of output grid.</li><li><strong>nXSize</strong>: Number of columns in output grid.</li><li><strong>nYSize</strong>: Number of rows in output grid.</li><li><strong>eType</strong>: Data type of output array.</li><li><strong>pData</strong>: Pointer to array where the computed grid will be stored.</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if something goes wrong.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridcreate" href="#GDAL.gridcreate"><code>GDAL.gridcreate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridCreate(GDALGridAlgorithm eAlgorithm,
               const void * poOptions,
               GUInt32 nPoints,
               const double * padfX,
               const double * padfY,
               const double * padfZ,
               double dfXMin,
               double dfXMax,
               double dfYMin,
               double dfYMax,
               GUInt32 nXSize,
               GUInt32 nYSize,
               GDALDataType eType,
               void * pData,
               GDALProgressFunc pfnProgress,
               void * pProgressArg) -&gt; CPLErr</code></pre><p>Create regular grid from the scattered data.</p><p><strong>Parameters</strong></p><ul><li><strong>eAlgorithm</strong>: Gridding method.</li><li><strong>poOptions</strong>: Options to control chosen gridding method.</li><li><strong>nPoints</strong>: Number of elements in input arrays.</li><li><strong>padfX</strong>: Input array of X coordinates.</li><li><strong>padfY</strong>: Input array of Y coordinates.</li><li><strong>padfZ</strong>: Input array of Z values.</li><li><strong>dfXMin</strong>: Lowest X border of output grid.</li><li><strong>dfXMax</strong>: Highest X border of output grid.</li><li><strong>dfYMin</strong>: Lowest Y border of output grid.</li><li><strong>dfYMax</strong>: Highest Y border of output grid.</li><li><strong>nXSize</strong>: Number of columns in output grid.</li><li><strong>nYSize</strong>: Number of rows in output grid.</li><li><strong>eType</strong>: Data type of output array.</li><li><strong>pData</strong>: Pointer to array where the computed grid will be stored.</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if something goes wrong.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridoptionsfree" href="#GDAL.gridoptionsfree"><code>GDAL.gridoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridOptionsFree(GDALGridOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALGridOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALGrid().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridoptionsnew" href="#GDAL.gridoptionsnew"><code>GDAL.gridoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridOptionsNew(char ** papszArgv,
                   GDALGridOptionsForBinary * psOptionsForBinary) -&gt; GDALGridOptions *</code></pre><p>Allocates a GDALGridOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdal_translate utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALGridOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALGridOptions struct. Must be freed with GDALGridOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.gridoptionssetprogress" href="#GDAL.gridoptionssetprogress"><code>GDAL.gridoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALGridOptionsSetProgress(GDALGridOptions * psOptions,
                           GDALProgressFunc pfnProgress,
                           void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALGrid().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.hasarbitraryoverviews" href="#GDAL.hasarbitraryoverviews"><code>GDAL.hasarbitraryoverviews</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALHasArbitraryOverviews(GDALRasterBandH hBand) -&gt; int</code></pre><p>Check for arbitrary overviews.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.hascurvegeometry" href="#GDAL.hascurvegeometry"><code>GDAL.hascurvegeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_HasCurveGeometry(OGRGeometryH hGeom,
                       int bLookForNonLinear) -&gt; int</code></pre><p>Returns if this geometry is or has curve geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the geometry to operate on.</li><li><strong>bLookForNonLinear</strong>: set it to TRUE to check if the geometry is or contains a CIRCULARSTRING.</li></ul><p><strong>Returns</strong></p><p>TRUE if this geometry is or has curve geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.hastriangulation" href="#GDAL.hastriangulation"><code>GDAL.hastriangulation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALHasTriangulation() -&gt; int</code></pre><p>Returns if GDAL is built with Delaunay triangulation support.</p><p><strong>Returns</strong></p><p>TRUE if GDAL is built with Delaunay triangulation support.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.identifydriver" href="#GDAL.identifydriver"><code>GDAL.identifydriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALIdentifyDriver(const char * pszFilename,
                   char ** papszFileList) -&gt; GDALDriverH</code></pre><p>Identify the driver that can open a raster file.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the name of the file to access. In the case of exotic drivers this may not refer to a physical file, but instead contain information for the driver on how to access a dataset.</li><li><strong>papszFileList</strong>: an array of strings, whose last element is the NULL pointer. These strings are filenames that are auxiliary to the main filename. The passed value may be NULL.</li></ul><p><strong>Returns</strong></p><p>A GDALDriverH handle or NULL on failure. For C++ applications this handle can be cast to a GDALDriver *.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.identifydriverex" href="#GDAL.identifydriverex"><code>GDAL.identifydriverex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALIdentifyDriverEx(const char * pszFilename,
                     unsigned int nIdentifyFlags,
                     const char *const * papszAllowedDrivers,
                     const char *const * papszFileList) -&gt; GDALDriverH</code></pre><p>Identify the driver that can open a raster file.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the name of the file to access. In the case of exotic drivers this may not refer to a physical file, but instead contain information for the driver on how to access a dataset.</li><li><strong>nIdentifyFlags</strong>: a combination of GDAL<em>OF</em>RASTER for raster drivers or GDAL<em>OF</em>VECTOR for vector drivers. If none of the value is specified, both kinds are implied.</li><li><strong>papszAllowedDrivers</strong>: NULL to consider all candidate drivers, or a NULL terminated list of strings with the driver short names that must be considered.</li><li><strong>papszFileList</strong>: an array of strings, whose last element is the NULL pointer. These strings are filenames that are auxiliary to the main filename. The passed value may be NULL.</li></ul><p><strong>Returns</strong></p><p>A GDALDriverH handle or NULL on failure. For C++ applications this handle can be cast to a GDALDriver *.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.identity" href="#GDAL.identity"><code>GDAL.identity</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_Identity(OGRLayerH pLayerInput,
               OGRLayerH pLayerMethod,
               OGRLayerH pLayerResult,
               char ** papszOptions,
               GDALProgressFunc pfnProgress,
               void * pProgressArg) -&gt; OGRErr</code></pre><p>Identify the features of this layer with the ones from the identity layer.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromdict" href="#GDAL.importfromdict"><code>GDAL.importfromdict</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromDict(OGRSpatialReferenceH,
                  const char *,
                  const char *) -&gt; OGRErr</code></pre><p>Read SRS from WKT dictionary.</p><p><strong>Parameters</strong></p><ul><li><strong>hSRS</strong>: spatial reference system handle.</li><li><strong>pszDictFile</strong>: the name of the dictionary file to load.</li><li><strong>pszCode</strong>: the code to lookup in the dictionary.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE on success, or OGRERR</em>SRS<em>UNSUPPORTED if the code isn&#39;t found, and OGRERR</em>SRS_FAILURE if something more dramatic goes wrong.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromepsg" href="#GDAL.importfromepsg"><code>GDAL.importfromepsg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromEPSG(OGRSpatialReferenceH hSRS,
                  int nCode) -&gt; OGRErr</code></pre><p>Initialize SRS based on EPSG GCS or PCS code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromepsga" href="#GDAL.importfromepsga"><code>GDAL.importfromepsga</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromEPSGA(OGRSpatialReferenceH hSRS,
                   int nCode) -&gt; OGRErr</code></pre><p>Initialize SRS based on EPSG GCS or PCS code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromerm" href="#GDAL.importfromerm"><code>GDAL.importfromerm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromERM(OGRSpatialReferenceH,
                 const char *,
                 const char *,
                 const char *) -&gt; OGRErr</code></pre><p>Create OGR WKT from ERMapper projection definitions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromesri" href="#GDAL.importfromesri"><code>GDAL.importfromesri</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromESRI(OGRSpatialReferenceH,
                  char **) -&gt; OGRErr</code></pre><p>Import coordinate system from ESRI .prj format(s).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfrommicoordsys" href="#GDAL.importfrommicoordsys"><code>GDAL.importfrommicoordsys</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromMICoordSys(OGRSpatialReferenceH hSRS,
                        const char * pszCoordSys) -&gt; OGRErr</code></pre><p>Import Mapinfo style CoordSys definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromozi" href="#GDAL.importfromozi"><code>GDAL.importfromozi</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromOzi(OGRSpatialReferenceH,
                 const char *const *) -&gt; OGRErr</code></pre><p>Import coordinate system from OziExplorer projection definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hSRS</strong>: spatial reference object.</li><li><strong>papszLines</strong>: Map file lines. This is an array of strings containing the whole OziExplorer .MAP file. The array is terminated by a NULL pointer.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success or an error code in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfrompanorama" href="#GDAL.importfrompanorama"><code>GDAL.importfrompanorama</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromPanorama(OGRSpatialReferenceH,
                      long,
                      long,
                      long,
                      double *) -&gt; OGRErr</code></pre><p>Import coordinate system from &quot;Panorama&quot; GIS projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfrompci" href="#GDAL.importfrompci"><code>GDAL.importfrompci</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromPCI(OGRSpatialReferenceH hSRS,
                 const char *,
                 const char *,
                 double *) -&gt; OGRErr</code></pre><p>Import coordinate system from PCI projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromproj4" href="#GDAL.importfromproj4"><code>GDAL.importfromproj4</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromProj4(OGRSpatialReferenceH,
                   const char *) -&gt; OGRErr</code></pre><p>Import PROJ.4 coordinate string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromurl" href="#GDAL.importfromurl"><code>GDAL.importfromurl</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromUrl(OGRSpatialReferenceH hSRS,
                 const char * pszUrl) -&gt; OGRErr</code></pre><p>Set spatial reference from a URL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromusgs" href="#GDAL.importfromusgs"><code>GDAL.importfromusgs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromUSGS(OGRSpatialReferenceH,
                  long,
                  long,
                  double *,
                  long) -&gt; OGRErr</code></pre><p>Import coordinate system from USGS projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromwkb" href="#GDAL.importfromwkb"><code>GDAL.importfromwkb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ImportFromWkb(OGRGeometryH hGeom,
                    unsigned char * pabyData,
                    int nSize) -&gt; OGRErr</code></pre><p>Assign geometry from well known binary data.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to assign the well know binary data to.</li><li><strong>pabyData</strong>: the binary input data.</li><li><strong>nSize</strong>: the size of pabyData in bytes, or zero if not known.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if all goes well, otherwise any of OGRERR</em>NOT<em>ENOUGH</em>DATA, OGRERR<em>UNSUPPORTED</em>GEOMETRY<em>TYPE, or OGRERR</em>CORRUPT_DATA may be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromwkt" href="#GDAL.importfromwkt"><code>GDAL.importfromwkt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_ImportFromWkt(OGRGeometryH hGeom,
                    char ** ppszSrcText) -&gt; OGRErr</code></pre><p>Assign geometry from well known text data.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to assign well know text data to.</li><li><strong>ppszSrcText</strong>: pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if all goes well, otherwise any of OGRERR</em>NOT<em>ENOUGH</em>DATA, OGRERR<em>UNSUPPORTED</em>GEOMETRY<em>TYPE, or OGRERR</em>CORRUPT_DATA may be returned.</p></div></div><div><div><pre><code class="language-none">OSRImportFromWkt(OGRSpatialReferenceH hSRS,
                 char ** ppszInput) -&gt; OGRErr</code></pre><p>Import from WKT string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.importfromxml" href="#GDAL.importfromxml"><code>GDAL.importfromxml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRImportFromXML(OGRSpatialReferenceH,
                 const char *) -&gt; OGRErr</code></pre><p>Import coordinate system from XML format (GML only currently).</p></div></div></section><pre><code class="language-none">GDAL.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.info" href="#GDAL.info"><code>GDAL.info</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALInfo(GDALDatasetH hDataset,
         const GDALInfoOptions * psOptions) -&gt; char *</code></pre><p>Lists various information about a GDAL supported raster dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>hDataset</strong>: the dataset handle.</li><li><strong>psOptions</strong>: the options structure returned by GDALInfoOptionsNew() or NULL.</li></ul><p><strong>Returns</strong></p><p>string corresponding to the information about the raster dataset (must be freed with CPLFree()), or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.infooptionsfree" href="#GDAL.infooptionsfree"><code>GDAL.infooptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALInfoOptionsFree(GDALInfoOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALInfoOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALInfo().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.infooptionsnew" href="#GDAL.infooptionsnew"><code>GDAL.infooptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALInfoOptionsNew(char ** papszArgv,
                   GDALInfoOptionsForBinary * psOptionsForBinary) -&gt; GDALInfoOptions *</code></pre><p>Allocates a GDALInfoOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdalinfo utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdalinfo_bin.cpp use case) must be allocated with GDALInfoOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options, subdataset number...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALInfoOptions struct. Must be freed with GDALInfoOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.initfromfeature" href="#GDAL.initfromfeature"><code>GDAL.initfromfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_InitFromFeature(OGRStyleMgrH hSM,
                       OGRFeatureH hFeat) -&gt; const char *</code></pre><p>Initialize style manager from the style string of a feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>hFeat</strong>: handle to the new feature from which to read the style.</li></ul><p><strong>Returns</strong></p><p>a reference to the style string read from the feature, or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.initgcps" href="#GDAL.initgcps"><code>GDAL.initgcps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALInitGCPs(int,
             GDAL_GCP *) -&gt; void</code></pre><p>Initialize an array of GCPs.</p><p><strong>Parameters</strong></p><ul><li><strong>nCount</strong>: number of GCPs in psGCP</li><li><strong>psGCP</strong>: array of GCPs of size nCount.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.initstylestring" href="#GDAL.initstylestring"><code>GDAL.initstylestring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_InitStyleString(OGRStyleMgrH hSM,
                       const char * pszStyleString) -&gt; int</code></pre><p>Initialize style manager from the style string.</p><p><strong>Parameters</strong></p><ul><li><strong>hSM</strong>: handle to the style manager.</li><li><strong>pszStyleString</strong>: the style string to use (can be NULL).</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on errors.</p></div></div></section><pre><code class="language-none">GDAL.intersect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.intersection" href="#GDAL.intersection"><code>GDAL.intersection</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Intersection(OGRGeometryH hThis,
                   OGRGeometryH hOther) -&gt; OGRGeometryH</code></pre><p>Compute intersection.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>hOther</strong>: the other geometry.</li></ul><p><strong>Returns</strong></p><p>a new geometry representing the intersection or NULL if there is no intersection or an error occurs.</p></div></div><div><div><pre><code class="language-none">OGR_L_Intersection(OGRLayerH pLayerInput,
                   OGRLayerH pLayerMethod,
                   OGRLayerH pLayerResult,
                   char ** papszOptions,
                   GDALProgressFunc pfnProgress,
                   void * pProgressArg) -&gt; OGRErr</code></pre><p>Intersection of two layers.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.intersects" href="#GDAL.intersects"><code>GDAL.intersects</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Intersects(OGRGeometryH hGeom,
                 OGRGeometryH hOtherGeom) -&gt; int</code></pre><p>Do these features intersect?</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the first geometry.</li><li><strong>hOtherGeom</strong>: handle on the other geometry to test against.</li></ul><p><strong>Returns</strong></p><p>TRUE if the geometries intersect, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.invgeotransform" href="#GDAL.invgeotransform"><code>GDAL.invgeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALInvGeoTransform(double * gt_in,
                    double * gt_out) -&gt; int</code></pre><p>Invert Geotransform.</p><p><strong>Parameters</strong></p><ul><li><strong>gt_in</strong>: Input geotransform (six doubles - unaltered).</li><li><strong>gt_out</strong>: Output geotransform (six doubles - updated).</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE if the equation is uninvertable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.is3d" href="#GDAL.is3d"><code>GDAL.is3d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Is3D(OGRGeometryH hGeom) -&gt; int</code></pre><p>See whether this geometry has Z coordinates.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to check whether it has Z coordinates.</li></ul><p><strong>Returns</strong></p><p>TRUE if the geometry has Z coordinates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.iscompound" href="#GDAL.iscompound"><code>GDAL.iscompound</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsCompound(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if the coordinate system is compound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isdefaultdriverspecific" href="#GDAL.isdefaultdriverspecific"><code>GDAL.isdefaultdriverspecific</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_IsDefaultDriverSpecific(OGRFieldDefnH hDefn) -&gt; int</code></pre><p>Returns whether the default value is driver specific.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li></ul><p><strong>Returns</strong></p><p>TRUE if the default value is driver specific.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isfieldnull" href="#GDAL.isfieldnull"><code>GDAL.isfieldnull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_IsFieldNull(OGRFeatureH hFeat,
                  int iField) -&gt; int</code></pre><p>Test if a field is null.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is.</li><li><strong>iField</strong>: the field to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the field is null, otherwise false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isfieldset" href="#GDAL.isfieldset"><code>GDAL.isfieldset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_IsFieldSet(OGRFeatureH hFeat,
                 int iField) -&gt; int</code></pre><p>Test if a field has ever been assigned a value or not.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is.</li><li><strong>iField</strong>: the field to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the field has been set, otherwise false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isfieldsetandnotnull" href="#GDAL.isfieldsetandnotnull"><code>GDAL.isfieldsetandnotnull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_IsFieldSetAndNotNull(OGRFeatureH hFeat,
                           int iField) -&gt; int</code></pre><p>Test if a field is set and not null.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is.</li><li><strong>iField</strong>: the field to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the field is set and not null, otherwise false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isgeocentric" href="#GDAL.isgeocentric"><code>GDAL.isgeocentric</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsGeocentric(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if geocentric coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isgeographic" href="#GDAL.isgeographic"><code>GDAL.isgeographic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsGeographic(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if geographic coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isgeometryignored" href="#GDAL.isgeometryignored"><code>GDAL.isgeometryignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_IsGeometryIgnored(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Determine whether the geometry can be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li></ul><p><strong>Returns</strong></p><p>ignore state</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isignored" href="#GDAL.isignored"><code>GDAL.isignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_IsIgnored(OGRFieldDefnH hDefn) -&gt; int</code></pre><p>Return whether this field should be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li></ul><p><strong>Returns</strong></p><p>ignore state</p></div></div><div><div><pre><code class="language-none">OGR_GFld_IsIgnored(OGRGeomFieldDefnH hDefn) -&gt; int</code></pre><p>Return whether this field should be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition</li></ul><p><strong>Returns</strong></p><p>ignore state</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.islocal" href="#GDAL.islocal"><code>GDAL.islocal</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsLocal(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if local coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ismeasured" href="#GDAL.ismeasured"><code>GDAL.ismeasured</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_IsMeasured(OGRGeometryH hGeom) -&gt; int</code></pre><p>See whether this geometry is measured.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to check whether it is measured.</li></ul><p><strong>Returns</strong></p><p>TRUE if the geometry has M coordinates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isnullable" href="#GDAL.isnullable"><code>GDAL.isnullable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_IsNullable(OGRFieldDefnH hDefn) -&gt; int</code></pre><p>Return whether this field can receive null values.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li></ul><p><strong>Returns</strong></p><p>TRUE if the field is authorized to be null.</p></div></div><div><div><pre><code class="language-none">OGR_GFld_IsNullable(OGRGeomFieldDefnH hDefn) -&gt; int</code></pre><p>Return whether this geometry field can receive null values.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li></ul><p><strong>Returns</strong></p><p>TRUE if the field is authorized to be null.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isprojected" href="#GDAL.isprojected"><code>GDAL.isprojected</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsProjected(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if projected coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isring" href="#GDAL.isring"><code>GDAL.isring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_IsRing(OGRGeometryH hGeom) -&gt; int</code></pre><p>Test if the geometry is a ring.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: The Geometry to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the geometry has no points, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.issame" href="#GDAL.issame"><code>GDAL.issame</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_IsSame(OGRFeatureDefnH hFDefn,
              OGRFeatureDefnH hOtherFDefn) -&gt; int</code></pre><p>Test if the feature definition is identical to the other one.</p><p><strong>Parameters</strong></p><ul><li><strong>hFDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li><li><strong>hOtherFDefn</strong>: handle to the other feature definition to compare to.</li></ul><p><strong>Returns</strong></p><p>TRUE if the feature definition is identical to the other one.</p></div></div><div><div><pre><code class="language-none">OSRIsSame(OGRSpatialReferenceH hSRS1,
          OGRSpatialReferenceH hSRS2) -&gt; int</code></pre><p>Do these two spatial references describe the same system ?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.issamegeogcs" href="#GDAL.issamegeogcs"><code>GDAL.issamegeogcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsSameGeogCS(OGRSpatialReferenceH hSRS1,
                OGRSpatialReferenceH hSRS2) -&gt; int</code></pre><p>Do the GeogCS&#39;es match?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.issamevertcs" href="#GDAL.issamevertcs"><code>GDAL.issamevertcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsSameVertCS(OGRSpatialReferenceH hSRS1,
                OGRSpatialReferenceH hSRS2) -&gt; int</code></pre><p>Do the VertCS&#39;es match?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.issimple" href="#GDAL.issimple"><code>GDAL.issimple</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_IsSimple(OGRGeometryH hGeom) -&gt; int</code></pre><p>Returns TRUE if the geometry is simple.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: The Geometry to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if object is simple, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isstyleignored" href="#GDAL.isstyleignored"><code>GDAL.isstyleignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_IsStyleIgnored(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Determine whether the style can be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on which OGRFeature are based on.</li></ul><p><strong>Returns</strong></p><p>ignore state</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isvalid" href="#GDAL.isvalid"><code>GDAL.isvalid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_IsValid(OGRGeometryH hGeom) -&gt; int</code></pre><p>Test if the geometry is valid.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: The Geometry to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the geometry has no points, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.isvertical" href="#GDAL.isvertical"><code>GDAL.isvertical</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRIsVertical(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Check if vertical coordinate system.</p></div></div></section><pre><code class="language-none">GDAL.libgdal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.loadozimapfile" href="#GDAL.loadozimapfile"><code>GDAL.loadozimapfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALLoadOziMapFile(const char *,
                   double *,
                   char **,
                   int *,
                   GDAL_GCP **) -&gt; int</code></pre><p>Helper function for translator implementer wanting support for OZI .map.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: filename of .tab file</li><li><strong>padfGeoTransform</strong>: output geotransform. Must hold 6 doubles.</li><li><strong>ppszWKT</strong>: output pointer to a string that will be allocated with CPLMalloc().</li><li><strong>pnGCPCount</strong>: output pointer to GCP count.</li><li><strong>ppasGCPs</strong>: outputer pointer to an array of GCPs.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success, FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.loadstyletable" href="#GDAL.loadstyletable"><code>GDAL.loadstyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_LoadStyleTable(OGRStyleTableH hStyleTable,
                        const char * pszFilename) -&gt; int</code></pre><p>Load a style table from a file.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li><li><strong>pszFilename</strong>: the name of the file to load from.</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.loadtabfile" href="#GDAL.loadtabfile"><code>GDAL.loadtabfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALLoadTabFile(const char *,
                double *,
                char **,
                int *,
                GDAL_GCP **) -&gt; int</code></pre><p>Helper function for translator implementer wanting support for MapInfo .tab files.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: filename of .tab</li><li><strong>padfGeoTransform</strong>: output geotransform. Must hold 6 doubles.</li><li><strong>ppszWKT</strong>: output pointer to a string that will be allocated with CPLMalloc().</li><li><strong>pnGCPCount</strong>: output pointer to GCP count.</li><li><strong>ppasGCPs</strong>: outputer pointer to an array of GCPs.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success, FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.loadworldfile" href="#GDAL.loadworldfile"><code>GDAL.loadworldfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALLoadWorldFile(const char *,
                  double *) -&gt; int</code></pre><p>Read ESRI world file.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the world file name.</li><li><strong>padfGeoTransform</strong>: the six double array into which the geotransformation should be placed.</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.loggingerrorhandler" href="#GDAL.loggingerrorhandler"><code>GDAL.loggingerrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLLoggingErrorHandler(CPLErr eErrClass,
                       CPLErrorNum nError,
                       const char * pszErrorMsg) -&gt; void</code></pre><p>Error handler that logs into the file defined by the CPL_LOG configuration option, or stderr otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.morphfromesri" href="#GDAL.morphfromesri"><code>GDAL.morphfromesri</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRMorphFromESRI(OGRSpatialReferenceH) -&gt; OGRErr</code></pre><p>Convert in place from ESRI WKT format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.morphtoesri" href="#GDAL.morphtoesri"><code>GDAL.morphtoesri</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRMorphToESRI(OGRSpatialReferenceH) -&gt; OGRErr</code></pre><p>Convert in place to ESRI WKT format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.nearblack" href="#GDAL.nearblack"><code>GDAL.nearblack</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALNearblack(const char * pszDest,
              GDALDatasetH hDstDS,
              GDALDatasetH hSrcDS,
              const GDALNearblackOptions * psOptions,
              int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Convert nearly black/white borders to exact value.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path or NULL.</li><li><strong>hDstDS</strong>: the destination dataset or NULL. Might be equal to hSrcDataset.</li><li><strong>hSrcDataset</strong>: the source dataset handle.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALNearblackOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred or NULL.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose(), or hDstDS is not NULL) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.nearblackoptionsfree" href="#GDAL.nearblackoptionsfree"><code>GDAL.nearblackoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALNearblackOptionsFree(GDALNearblackOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALNearblackOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALNearblack().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.nearblackoptionsnew" href="#GDAL.nearblackoptionsnew"><code>GDAL.nearblackoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALNearblackOptionsNew(char ** papszArgv,
                        GDALNearblackOptionsForBinary * psOptionsForBinary) -&gt; GDALNearblackOptions *</code></pre><p>Allocates a GDALNearblackOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the nearblack utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALNearblackOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALNearblackOptions struct. Must be freed with GDALNearblackOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.nearblackoptionssetprogress" href="#GDAL.nearblackoptionssetprogress"><code>GDAL.nearblackoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALNearblackOptionsSetProgress(GDALNearblackOptions * psOptions,
                                GDALProgressFunc pfnProgress,
                                void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALNearblack().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.newspatialreference" href="#GDAL.newspatialreference"><code>GDAL.newspatialreference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRNewSpatialReference(const char * pszWKT) -&gt; OGRSpatialReferenceH</code></pre><p>Constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octcleanupprojmutex" href="#GDAL.octcleanupprojmutex"><code>GDAL.octcleanupprojmutex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTCleanupProjMutex() -&gt; void</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octdestroycoordinatetransformation" href="#GDAL.octdestroycoordinatetransformation"><code>GDAL.octdestroycoordinatetransformation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTDestroyCoordinateTransformation(OGRCoordinateTransformationH hCT) -&gt; void</code></pre><p>OGRCoordinateTransformation destructor.</p><p><strong>Parameters</strong></p><ul><li><strong>hCT</strong>: the object to delete</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octnewcoordinatetransformation" href="#GDAL.octnewcoordinatetransformation"><code>GDAL.octnewcoordinatetransformation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTNewCoordinateTransformation(OGRSpatialReferenceH hSourceSRS,
                               OGRSpatialReferenceH hTargetSRS) -&gt; OGRCoordinateTransformationH</code></pre><p>Create transformation object.</p><p><strong>Parameters</strong></p><ul><li><strong>hSourceSRS</strong>: source spatial reference system.</li><li><strong>hTargetSRS</strong>: target spatial reference system.</li></ul><p><strong>Returns</strong></p><p>NULL on failure or a ready to use transformation object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octproj4normalize" href="#GDAL.octproj4normalize"><code>GDAL.octproj4normalize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTProj4Normalize(const char * pszProj4Src) -&gt; char *</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octtransform" href="#GDAL.octtransform"><code>GDAL.octtransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTTransform(OGRCoordinateTransformationH hTransform,
             int nCount,
             double * x,
             double * y,
             double * z) -&gt; int</code></pre><p>Transform an array of points.</p><p><strong>Parameters</strong></p><ul><li><strong>hTransform</strong>: Transformation object</li><li><strong>nCount</strong>: Number of points</li><li><strong>x</strong>: Array of nCount x values.</li><li><strong>y</strong>: Array of nCount y values.</li><li><strong>z</strong>: Array of nCount z values.</li></ul><p><strong>Returns</strong></p><p>TRUE or FALSE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.octtransformex" href="#GDAL.octtransformex"><code>GDAL.octtransformex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OCTTransformEx(OGRCoordinateTransformationH hTransform,
               int nCount,
               double * x,
               double * y,
               double * z,
               int * pabSuccess) -&gt; int</code></pre><p>Transform an array of points.</p><p><strong>Parameters</strong></p><ul><li><strong>hTransform</strong>: Transformation object</li><li><strong>nCount</strong>: Number of points</li><li><strong>x</strong>: Array of nCount x values.</li><li><strong>y</strong>: Array of nCount y values.</li><li><strong>z</strong>: Array of nCount z values.</li><li><strong>pabSuccess</strong>: Output array of nCount value that will be set to TRUE/FALSE</li></ul><p><strong>Returns</strong></p><p>TRUE or FALSE</p></div></div></section><pre><code class="language-none">GDAL.ogr2ogr_path</code></pre><pre><code class="language-none">GDAL.ogrZMarker</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ogrgetdriver" href="#GDAL.ogrgetdriver"><code>GDAL.ogrgetdriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRGetDriver(int) -&gt; OGRSFDriverH</code></pre><p>Fetch the indicated driver.</p><p><strong>Parameters</strong></p><ul><li><strong>iDriver</strong>: the driver index, from 0 to GetDriverCount()-1.</li></ul><p><strong>Returns</strong></p><p>handle to the driver, or NULL if iDriver is out of range.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ogrgetdriverbyname" href="#GDAL.ogrgetdriverbyname"><code>GDAL.ogrgetdriverbyname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRGetDriverByName(const char *) -&gt; OGRSFDriverH</code></pre><p>Fetch the indicated driver.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the driver name</li></ul><p><strong>Returns</strong></p><p>the driver, or NULL if no driver with that name is found</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ogrgetdrivercount" href="#GDAL.ogrgetdrivercount"><code>GDAL.ogrgetdrivercount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRGetDriverCount(void) -&gt; int</code></pre><p>Fetch the number of registered drivers.</p><p><strong>Returns</strong></p><p>the drivers count.</p></div></div></section><pre><code class="language-none">GDAL.ogrinfo_path</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.open" href="#GDAL.open"><code>GDAL.open</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALOpen(const char * pszFilename,
         GDALAccess eAccess) -&gt; GDALDatasetH</code></pre><p>Open a raster file as a GDALDataset.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the name of the file to access. In the case of exotic drivers this may not refer to a physical file, but instead contain information for the driver on how to access a dataset. It should be in UTF-8 encoding.</li><li><strong>eAccess</strong>: the desired access, either GA<em>Update or GA</em>ReadOnly. Many drivers support only read only access.</li></ul><p><strong>Returns</strong></p><p>A GDALDatasetH handle or NULL on failure. For C++ applications this handle can be cast to a GDALDataset *.</p></div></div><div><div><pre><code class="language-none">OGR_Dr_Open(OGRSFDriverH,
            const char *,
            int) -&gt; OGRDataSourceH</code></pre><p>Attempt to open file with this driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver that is used to open file.</li><li><strong>pszName</strong>: the name of the file, or data source to try and open.</li><li><strong>bUpdate</strong>: TRUE if update access is required, otherwise FALSE (the default).</li></ul><p><strong>Returns</strong></p><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a GDALDataset. This GDALDataset should be closed by deleting the object when it is no longer needed.</p></div></div><div><div><pre><code class="language-none">OGROpen(const char *,
        int,
        OGRSFDriverH *) -&gt; OGRDataSourceH</code></pre><p>Open a file / data source with one of the registered drivers.</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the name of the file, or data source to open.</li><li><strong>bUpdate</strong>: FALSE for read-only access (the default) or TRUE for read-write access.</li><li><strong>pahDriverList</strong>: if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</li></ul><p><strong>Returns</strong></p><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a GDALDataset. This GDALDataset should be closed by deleting the object when it is no longer needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.openex" href="#GDAL.openex"><code>GDAL.openex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALOpenEx(const char * pszFilename,
           unsigned int nOpenFlags,
           const char *const * papszAllowedDrivers,
           const char *const * papszOpenOptions,
           const char *const * papszSiblingFiles) -&gt; friend GDALDatasetH</code></pre><p>Open a raster or vector file as a GDALDataset.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the name of the file to access. In the case of exotic drivers this may not refer to a physical file, but instead contain information for the driver on how to access a dataset. It should be in UTF-8 encoding.</li><li><strong>nOpenFlags</strong>: a combination of GDAL<em>OF</em> flags that may be combined through logical or operator. </li></ul><p>Driver kind: GDAL<em>OF</em>RASTER for raster drivers, GDAL<em>OF</em>VECTOR for vector drivers. If none of the value is specified, both kinds are implied. </p><p>Access mode: GDAL<em>OF</em>READONLY (exclusive)or GDAL<em>OF</em>UPDATE. </p><p>Shared mode: GDAL<em>OF</em>SHARED. If set, it allows the sharing of GDALDataset handles for a dataset with other callers that have set GDAL<em>OF</em>SHARED. In particular, GDALOpenEx() will first consult its list of currently open and shared GDALDataset&#39;s, and if the GetDescription() name for one exactly matches the pszFilename passed to GDALOpenEx() it will be referenced and returned, if GDALOpenEx() is called from the same thread. </p><p>Verbose error: GDAL<em>OF</em>VERBOSE_ERROR. If set, a failed attempt to open the file will lead to an error message to be reported.</p><ul><li><strong>papszAllowedDrivers</strong>: NULL to consider all candidate drivers, or a NULL terminated list of strings with the driver short names that must be considered.</li><li><strong>papszOpenOptions</strong>: NULL, or a NULL terminated list of strings with open options passed to candidate drivers. An option exists for all drivers, OVERVIEW<em>LEVEL=level, to select a particular overview level of a dataset. The level index starts at 0. The level number can be suffixed by &quot;only&quot; to specify that only this overview level must be visible, and not sub-levels. Open options are validated by default, and a warning is emitted in case the option is not recognized. In some scenarios, it might be not desirable (e.g. when not knowing which driver will open the file), so the special open option VALIDATE</em>OPEN_OPTIONS can be set to NO to avoid such warnings. Alternatively, since GDAL 2.1, an option name can be preceded by the @ character to indicate that it may not cause a warning if the driver doesn&#39;t declare this option.</li><li><strong>papszSiblingFiles</strong>: NULL, or a NULL terminated list of strings that are filenames that are auxiliary to the main filename. If NULL is passed, a probing of the file system will be done.</li></ul><p><strong>Returns</strong></p><p>A GDALDatasetH handle or NULL on failure. For C++ applications this handle can be cast to a GDALDataset *.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.openshared" href="#GDAL.openshared"><code>GDAL.openshared</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALOpenShared(const char * pszFilename,
               GDALAccess eAccess) -&gt; GDALDatasetH</code></pre><p>Open a raster file as a GDALDataset.</p><p><strong>Parameters</strong></p><ul><li><strong>pszFilename</strong>: the name of the file to access. In the case of exotic drivers this may not refer to a physical file, but instead contain information for the driver on how to access a dataset. It should be in UTF-8 encoding.</li><li><strong>eAccess</strong>: the desired access, either GA<em>Update or GA</em>ReadOnly. Many drivers support only read only access.</li></ul><p><strong>Returns</strong></p><p>A GDALDatasetH handle or NULL on failure. For C++ applications this handle can be cast to a GDALDataset *.</p></div></div><div><div><pre><code class="language-none">OGROpenShared(const char *,
              int,
              OGRSFDriverH *) -&gt; OGRDataSourceH</code></pre><p>Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with OGROpenShared()</p><p><strong>Parameters</strong></p><ul><li><strong>pszName</strong>: the name of the file, or data source to open.</li><li><strong>bUpdate</strong>: FALSE for read-only access (the default) or TRUE for read-write access.</li><li><strong>pahDriverList</strong>: if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</li></ul><p><strong>Returns</strong></p><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a GDALDataset. This GDALDataset should be closed by deleting the object when it is no longer needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.openverticalshiftgrid" href="#GDAL.openverticalshiftgrid"><code>GDAL.openverticalshiftgrid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALOpenVerticalShiftGrid(const char * pszProj4Geoidgrids,
                          int * pbError) -&gt; GDALDatasetH</code></pre><p>Load proj.4 geoidgrids as GDAL dataset.</p><p><strong>Parameters</strong></p><ul><li><strong>pszProj4Geoidgrids</strong>: Value of proj.4 geoidgrids parameter.</li><li><strong>pbError</strong>: If not NULL, the pointed value will be set to TRUE if an error occurred.</li></ul><p><strong>Returns</strong></p><p>a dataset. If not NULL, it must be closed with GDALClose().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.optgetparameterinfo" href="#GDAL.optgetparameterinfo"><code>GDAL.optgetparameterinfo</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OPTGetParameterInfo(const char * pszProjectionMethod,
                    const char * pszParameterName,
                    char ** ppszUserName,
                    char ** ppszType,
                    double * pdfDefaultValue) -&gt; int</code></pre><p>Fetch information about a single parameter of a projection method.</p><p><strong>Parameters</strong></p><ul><li><strong>pszProjectionMethod</strong>: name of projection method for which the parameter applies. Not currently used, but in the future this could affect defaults. This is the internal projection method name, such as &quot;Tranverse_Mercator&quot;.</li><li><strong>pszParameterName</strong>: name of the parameter to fetch information about. This is the internal name such as &quot;central<em>meridian&quot; (SRS</em>PP<em>CENTRAL</em>MERIDIAN).</li><li><strong>ppszUserName</strong>: location at which to return the user visible name for the parameter. This pointer may be NULL to skip the user name. The returned name should not be modified or freed.</li><li><strong>ppszType</strong>: location at which to return the parameter type for the parameter. This pointer may be NULL to skip. The returned type should not be modified or freed. The type values are described above.</li><li><strong>pdfDefaultValue</strong>: location at which to put the default value for this parameter. The pointer may be NULL.</li></ul><p><strong>Returns</strong></p><p>TRUE if parameter found, or FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.optgetparameterlist" href="#GDAL.optgetparameterlist"><code>GDAL.optgetparameterlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OPTGetParameterList(const char * pszProjectionMethod,
                    char ** ppszUserName) -&gt; char **</code></pre><p>Fetch the parameters for a given projection method.</p><p><strong>Parameters</strong></p><ul><li><strong>pszProjectionMethod</strong>: internal name of projection methods to fetch the parameters for, such as &quot;Transverse<em>Mercator&quot; (SRS</em>PT<em>TRANSVERSE</em>MERCATOR).</li><li><strong>ppszUserName</strong>: pointer in which to return a user visible name for the projection name. The returned string should not be modified or freed by the caller. Legal to pass in NULL if user name not required.</li></ul><p><strong>Returns</strong></p><p>returns a NULL terminated list of internal parameter names that should be freed by the caller when no longer needed. Returns NULL if projection method is unknown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.optgetprojectionmethods" href="#GDAL.optgetprojectionmethods"><code>GDAL.optgetprojectionmethods</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OPTGetProjectionMethods() -&gt; char **</code></pre><p>Fetch list of possible projection methods.</p><p><strong>Returns</strong></p><p>Returns NULL terminated list of projection methods. This should be freed with CSLDestroy() when no longer needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.overlaps" href="#GDAL.overlaps"><code>GDAL.overlaps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Overlaps(OGRGeometryH hThis,
               OGRGeometryH hOther) -&gt; int</code></pre><p>Test for overlap.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if they are overlapping, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.overviewmagnitudecorrection" href="#GDAL.overviewmagnitudecorrection"><code>GDAL.overviewmagnitudecorrection</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALOverviewMagnitudeCorrection(GDALRasterBandH hBaseBand,
                                int nOverviewCount,
                                GDALRasterBandH * pahOverviews,
                                GDALProgressFunc pfnProgress,
                                void * pProgressData) -&gt; CPLErr</code></pre><p>Undocumented.</p><p><strong>Parameters</strong></p><ul><li><strong>hBaseBand</strong>: undocumented.</li><li><strong>nOverviewCount</strong>: undocumented.</li><li><strong>pahOverviews</strong>: undocumented.</li><li><strong>pfnProgress</strong>: undocumented.</li><li><strong>pProgressData</strong>: undocumented.</li></ul><p><strong>Returns</strong></p><p>undocumented</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.packeddmstodec" href="#GDAL.packeddmstodec"><code>GDAL.packeddmstodec</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALPackedDMSToDec(double) -&gt; double</code></pre><p>Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.pointonsurface" href="#GDAL.pointonsurface"><code>GDAL.pointonsurface</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_PointOnSurface(OGRGeometryH hGeom) -&gt; OGRGeometryH</code></pre><p>Returns a point guaranteed to lie on the surface.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the geometry to operate on.</li></ul><p><strong>Returns</strong></p><p>a point guaranteed to lie on the surface or NULL if an error occurred.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.polygonize" href="#GDAL.polygonize"><code>GDAL.polygonize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALPolygonize(GDALRasterBandH hSrcBand,
               GDALRasterBandH hMaskBand,
               OGRLayerH hOutLayer,
               int iPixValField,
               char ** papszOptions,
               GDALProgressFunc pfnProgress,
               void * pProgressArg) -&gt; CPLErr</code></pre><p>Create polygon coverage from raster data.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: the source raster band to be processed.</li><li><strong>hMaskBand</strong>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons.</li><li><strong>hOutLayer</strong>: the vector feature layer to which the polygons should be written.</li><li><strong>iPixValField</strong>: the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written.</li><li><strong>papszOptions</strong>: a name/value list of additional options </li></ul><p>&quot;8CONNECTED&quot;: May be set to &quot;8&quot; to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm</p><ul><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on a failure.</p></div></div><div><div><pre><code class="language-none">OGR_G_Polygonize(OGRGeometryH hTarget) -&gt; OGRGeometryH</code></pre><p>Polygonizes a set of sparse edges.</p><p><strong>Parameters</strong></p><ul><li><strong>hTarget</strong>: The Geometry to be polygonized.</li></ul><p><strong>Returns</strong></p><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.poperrorhandler" href="#GDAL.poperrorhandler"><code>GDAL.poperrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLPopErrorHandler() -&gt; void</code></pre><p>Pop error handler off stack.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.pusherrorhandler" href="#GDAL.pusherrorhandler"><code>GDAL.pusherrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLPushErrorHandler(CPLErrorHandler pfnErrorHandlerNew) -&gt; void</code></pre><p>Push a new CPLError handler.</p><p><strong>Parameters</strong></p><ul><li><strong>pfnErrorHandlerNew</strong>: new error handler function.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.pusherrorhandlerex" href="#GDAL.pusherrorhandlerex"><code>GDAL.pusherrorhandlerex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLPushErrorHandlerEx(CPLErrorHandler pfnErrorHandlerNew,
                      void * pUserData) -&gt; void</code></pre><p>Push a new CPLError handler with user data on the error context.</p><p><strong>Parameters</strong></p><ul><li><strong>pfnErrorHandlerNew</strong>: new error handler function.</li><li><strong>pUserData</strong>: User data to put on the error context.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.quieterrorhandler" href="#GDAL.quieterrorhandler"><code>GDAL.quieterrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLQuietErrorHandler(CPLErr eErrClass,
                     CPLErrorNum nError,
                     const char * pszErrorMsg) -&gt; void</code></pre><p>Error handler that does not do anything, except for debug messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasteradviseread" href="#GDAL.rasteradviseread"><code>GDAL.rasteradviseread</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterAdviseRead(GDALRasterBandH hBand,
                     int nXOff,
                     int nYOff,
                     int nXSize,
                     int nYSize,
                     int nBufXSize,
                     int nBufYSize,
                     GDALDataType eDT,
                     char ** papszOptions) -&gt; CPLErr</code></pre><p>Advise driver of upcoming read requests.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterbandcopywholeraster" href="#GDAL.rasterbandcopywholeraster"><code>GDAL.rasterbandcopywholeraster</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterBandCopyWholeRaster(GDALRasterBandH hSrcBand,
                              GDALRasterBandH hDstBand,
                              const char *const * constpapszOptions,
                              GDALProgressFunc pfnProgress,
                              void * pProgressData) -&gt; CPLErr</code></pre><p>Copy all raster band raster data.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: the source band</li><li><strong>hDstBand</strong>: the destination band</li><li><strong>papszOptions</strong>: transfer hints in &quot;StringList&quot; Name=Value format.</li><li><strong>pfnProgress</strong>: progress reporting function.</li><li><strong>pProgressData</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success, or CE</em>Failure on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterbandgettiledvirtualmem" href="#GDAL.rasterbandgettiledvirtualmem"><code>GDAL.rasterbandgettiledvirtualmem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterBandGetTiledVirtualMem(GDALRasterBandH hBand,
                                 GDALRWFlag eRWFlag,
                                 int nXOff,
                                 int nYOff,
                                 int nXSize,
                                 int nYSize,
                                 int nTileXSize,
                                 int nTileYSize,
                                 GDALDataType eBufType,
                                 size_t nCacheSize,
                                 int bSingleThreadUsage,
                                 char ** papszOptions) -&gt; CPLVirtualMem *</code></pre><p>Create a CPLVirtualMem object from a GDAL rasterband object, with tiling organization.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: Rasterband object</li><li><strong>eRWFlag</strong>: Either GF<em>Read to read a region of data, or GF</em>Write to write a region of data.</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be accessed. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be accessed. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be accessed in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be accessed in lines.</li><li><strong>nTileXSize</strong>: the width of the tiles.</li><li><strong>nTileYSize</strong>: the height of the tiles.</li><li><strong>eBufType</strong>: the type of the pixel values in the data buffer. The pixel values will automatically be translated to/from the GDALRasterBand data type as needed.</li><li><strong>nCacheSize</strong>: size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM)</li><li><strong>bSingleThreadUsage</strong>: set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. If set to FALSE, CPLVirtualMemDeclareThread() must be called.</li><li><strong>papszOptions</strong>: NULL terminated list of options. Unused for now.</li></ul><p><strong>Returns</strong></p><p>a virtual memory object that must be freed by CPLVirtualMemFree(), or NULL in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterbandgetvirtualmem" href="#GDAL.rasterbandgetvirtualmem"><code>GDAL.rasterbandgetvirtualmem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterBandGetVirtualMem(GDALRasterBandH hBand,
                            GDALRWFlag eRWFlag,
                            int nXOff,
                            int nYOff,
                            int nXSize,
                            int nYSize,
                            int nBufXSize,
                            int nBufYSize,
                            GDALDataType eBufType,
                            int nPixelSpace,
                            GIntBig nLineSpace,
                            size_t nCacheSize,
                            size_t nPageSizeHint,
                            int bSingleThreadUsage,
                            char ** papszOptions) -&gt; CPLVirtualMem *</code></pre><p>Create a CPLVirtualMem object from a GDAL raster band object.</p><p><strong>Parameters</strong></p><ul><li><strong>hBand</strong>: Rasterband object</li><li><strong>eRWFlag</strong>: Either GF<em>Read to read a region of data, or GF</em>Write to write a region of data.</li><li><strong>nXOff</strong>: The pixel offset to the top left corner of the region of the band to be accessed. This would be zero to start from the left side.</li><li><strong>nYOff</strong>: The line offset to the top left corner of the region of the band to be accessed. This would be zero to start from the top.</li><li><strong>nXSize</strong>: The width of the region of the band to be accessed in pixels.</li><li><strong>nYSize</strong>: The height of the region of the band to be accessed in lines.</li><li><strong>nBufXSize</strong>: the width of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>nBufYSize</strong>: the height of the buffer image into which the desired region is to be read, or from which it is to be written.</li><li><strong>eBufType</strong>: the type of the pixel values in the data buffer. The pixel values will automatically be translated to/from the GDALRasterBand data type as needed.</li><li><strong>nPixelSpace</strong>: The byte offset from the start of one pixel value in the buffer to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</li><li><strong>nLineSpace</strong>: The byte offset from the start of one scanline in the buffer to the start of the next. If defaulted (0) the size of the datatype eBufType * nBufXSize is used.</li><li><strong>nCacheSize</strong>: size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM)</li><li><strong>nPageSizeHint</strong>: hint for the page size. Must be a multiple of the system page size, returned by CPLGetPageSize(). Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size.</li><li><strong>bSingleThreadUsage</strong>: set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. If set to FALSE, CPLVirtualMemDeclareThread() must be called.</li><li><strong>papszOptions</strong>: NULL terminated list of options. Unused for now.</li></ul><p><strong>Returns</strong></p><p>a virtual memory object that must be freed by CPLVirtualMemFree(), or NULL in case of failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterio" href="#GDAL.rasterio"><code>GDAL.rasterio</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterIO(GDALRasterBandH hBand,
             GDALRWFlag eRWFlag,
             int nXOff,
             int nYOff,
             int nXSize,
             int nYSize,
             void * pData,
             int nBufXSize,
             int nBufYSize,
             GDALDataType eBufType,
             int nPixelSpace,
             int nLineSpace) -&gt; CPLErr</code></pre><p>Read/write a region of image data for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterioex" href="#GDAL.rasterioex"><code>GDAL.rasterioex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterIOEx(GDALRasterBandH hBand,
               GDALRWFlag eRWFlag,
               int nXOff,
               int nYOff,
               int nXSize,
               int nYSize,
               void * pData,
               int nBufXSize,
               int nBufYSize,
               GDALDataType eBufType,
               GSpacing nPixelSpace,
               GSpacing nLineSpace,
               GDALRasterIOExtraArg * psExtraArg) -&gt; CPLErr</code></pre><p>Read/write a region of image data for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterize" href="#GDAL.rasterize"><code>GDAL.rasterize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterize(const char * pszDest,
              GDALDatasetH hDstDS,
              GDALDatasetH hSrcDataset,
              const GDALRasterizeOptions * psOptionsIn,
              int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Burns vector geometries into a raster.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path or NULL.</li><li><strong>hDstDS</strong>: the destination dataset or NULL.</li><li><strong>hSrcDataset</strong>: the source dataset handle.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALRasterizeOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred or NULL.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose(), or hDstDS is not NULL) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizegeometries" href="#GDAL.rasterizegeometries"><code>GDAL.rasterizegeometries</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeGeometries(GDALDatasetH hDS,
                        int nBandCount,
                        int * panBandList,
                        int nGeomCount,
                        OGRGeometryH * pahGeometries,
                        GDALTransformerFunc pfnTransformer,
                        void * pTransformArg,
                        double * padfGeomBurnValue,
                        char ** papszOptions,
                        GDALProgressFunc pfnProgress,
                        void * pProgressArg) -&gt; CPLErr</code></pre><p>Burn geometries into raster.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: output data, must be opened in update mode.</li><li><strong>nBandCount</strong>: the number of bands to be updated.</li><li><strong>panBandList</strong>: the list of bands to be updated.</li><li><strong>nGeomCount</strong>: the number of geometries being passed in pahGeometries.</li><li><strong>pahGeometries</strong>: the array of geometries to burn in.</li><li><strong>pfnTransformer</strong>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</li><li><strong>pTransformArg</strong>: callback data for transformer.</li><li><strong>padfGeomBurnValue</strong>: the array of values to burn into the raster. There should be nBandCount values for each geometry.</li><li><strong>papszOptions</strong>: special options controlling rasterization </li></ul><p>&quot;ALL_TOUCHED&quot;: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p><p>&quot;BURN<em>VALUE</em>FROM&quot;: May be set to &quot;Z&quot; to use the Z values of the geometries. dfBurnValue is added to this before burning. Defaults to GDALBurnValueSrc.GBV_UserBurnValue in which case just the dfBurnValue is burned. This is implemented only for points and lines for now. The M value may be supported in the future. </p><p>&quot;MERGE_ALG&quot;: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance.</p><ul><li><strong>pfnProgress</strong>: the progress function to report completion.</li><li><strong>pProgressArg</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizelayers" href="#GDAL.rasterizelayers"><code>GDAL.rasterizelayers</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeLayers(GDALDatasetH hDS,
                    int nBandCount,
                    int * panBandList,
                    int nLayerCount,
                    OGRLayerH * pahLayers,
                    GDALTransformerFunc pfnTransformer,
                    void * pTransformArg,
                    double * padfLayerBurnValues,
                    char ** papszOptions,
                    GDALProgressFunc pfnProgress,
                    void * pProgressArg) -&gt; CPLErr</code></pre><p>Burn geometries from the specified list of layers into raster.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: output data, must be opened in update mode.</li><li><strong>nBandCount</strong>: the number of bands to be updated.</li><li><strong>panBandList</strong>: the list of bands to be updated.</li><li><strong>nLayerCount</strong>: the number of layers being passed in pahLayers array.</li><li><strong>pahLayers</strong>: the array of layers to burn in.</li><li><strong>pfnTransformer</strong>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</li><li><strong>pTransformArg</strong>: callback data for transformer.</li><li><strong>padfLayerBurnValues</strong>: the array of values to burn into the raster. There should be nBandCount values for each layer.</li><li><strong>papszOptions</strong>: special options controlling rasterization: </li></ul><p>&quot;ATTRIBUTE&quot;: Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </p><p>&quot;CHUNKYSIZE&quot;: The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache<em>size</em>bytes/scanline<em>size</em>bytes, so the chunk will not exceed the cache. </p><p>&quot;ALL_TOUCHED&quot;: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p><p>&quot;BURN<em>VALUE</em>FROM&quot;: May be set to &quot;Z&quot; to use the Z values of the geometries. The value from padfLayerBurnValues or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </p><p>&quot;MERGE_ALG&quot;: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance.</p><ul><li><strong>pfnProgress</strong>: the progress function to report completion.</li><li><strong>pProgressArg</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizelayersbuf" href="#GDAL.rasterizelayersbuf"><code>GDAL.rasterizelayersbuf</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeLayersBuf(void * pData,
                       int nBufXSize,
                       int nBufYSize,
                       GDALDataType eBufType,
                       int nPixelSpace,
                       int nLineSpace,
                       int nLayerCount,
                       OGRLayerH * pahLayers,
                       const char * pszDstProjection,
                       double * padfDstGeoTransform,
                       GDALTransformerFunc pfnTransformer,
                       void * pTransformArg,
                       double dfBurnValue,
                       char ** papszOptions,
                       GDALProgressFunc pfnProgress,
                       void * pProgressArg) -&gt; CPLErr</code></pre><p>Burn geometries from the specified list of layer into raster.</p><p><strong>Parameters</strong></p><ul><li><strong>pData</strong>: pointer to the output data array.</li><li><strong>nBufXSize</strong>: width of the output data array in pixels.</li><li><strong>nBufYSize</strong>: height of the output data array in pixels.</li><li><strong>eBufType</strong>: data type of the output data array.</li><li><strong>nPixelSpace</strong>: The byte offset from the start of one pixel value in pData to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</li><li><strong>nLineSpace</strong>: The byte offset from the start of one scanline in pData to the start of the next. If defaulted the size of the datatype eBufType * nBufXSize is used.</li><li><strong>nLayerCount</strong>: the number of layers being passed in pahLayers array.</li><li><strong>pahLayers</strong>: the array of layers to burn in.</li><li><strong>pszDstProjection</strong>: WKT defining the coordinate system of the target raster.</li><li><strong>padfDstGeoTransform</strong>: geotransformation matrix of the target raster.</li><li><strong>pfnTransformer</strong>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</li><li><strong>pTransformArg</strong>: callback data for transformer.</li><li><strong>dfBurnValue</strong>: the value to burn into the raster.</li><li><strong>papszOptions</strong>: special options controlling rasterization: </li></ul><p>&quot;ATTRIBUTE&quot;: Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </p><p>&quot;ALL_TOUCHED&quot;: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p><p>&quot;BURN<em>VALUE</em>FROM&quot;: May be set to &quot;Z&quot; to use the Z values of the geometries. dfBurnValue or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </p><p>&quot;MERGE_ALG&quot;: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance.</p><ul><li><strong>pfnProgress</strong>: the progress function to report completion.</li><li><strong>pProgressArg</strong>: callback data for progress function.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizeoptionsfree" href="#GDAL.rasterizeoptionsfree"><code>GDAL.rasterizeoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeOptionsFree(GDALRasterizeOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALRasterizeOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALRasterize().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizeoptionsnew" href="#GDAL.rasterizeoptionsnew"><code>GDAL.rasterizeoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeOptionsNew(char ** papszArgv,
                        GDALRasterizeOptionsForBinary * psOptionsForBinary) -&gt; GDALRasterizeOptions *</code></pre><p>Allocates a GDALRasterizeOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdal_rasterize utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALRasterizeOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALRasterizeOptions struct. Must be freed with GDALRasterizeOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rasterizeoptionssetprogress" href="#GDAL.rasterizeoptionssetprogress"><code>GDAL.rasterizeoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRasterizeOptionsSetProgress(GDALRasterizeOptions * psOptions,
                                GDALProgressFunc pfnProgress,
                                void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALRasterize().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratchangesarewrittentofile" href="#GDAL.ratchangesarewrittentofile"><code>GDAL.ratchangesarewrittentofile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATChangesAreWrittenToFile(GDALRasterAttributeTableH hRAT) -&gt; int</code></pre><p>Determine whether changes made to this RAT are reflected directly in the dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratclone" href="#GDAL.ratclone"><code>GDAL.ratclone</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATClone(GDALRasterAttributeTableH) -&gt; GDALRasterAttributeTableH</code></pre><p>Copy Raster Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratcreatecolumn" href="#GDAL.ratcreatecolumn"><code>GDAL.ratcreatecolumn</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATCreateColumn(GDALRasterAttributeTableH,
                    const char *,
                    GDALRATFieldType,
                    GDALRATFieldUsage) -&gt; CPLErr</code></pre><p>Create new column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratdumpreadable" href="#GDAL.ratdumpreadable"><code>GDAL.ratdumpreadable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATDumpReadable(GDALRasterAttributeTableH,
                    FILE *) -&gt; void</code></pre><p>Dump RAT in readable form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetcolofusage" href="#GDAL.ratgetcolofusage"><code>GDAL.ratgetcolofusage</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetColOfUsage(GDALRasterAttributeTableH,
                     GDALRATFieldUsage) -&gt; int</code></pre><p>Fetch column index for given usage.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetcolumncount" href="#GDAL.ratgetcolumncount"><code>GDAL.ratgetcolumncount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetColumnCount(GDALRasterAttributeTableH) -&gt; int</code></pre><p>Fetch table column count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetlinearbinning" href="#GDAL.ratgetlinearbinning"><code>GDAL.ratgetlinearbinning</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetLinearBinning(GDALRasterAttributeTableH,
                        double *,
                        double *) -&gt; int</code></pre><p>Get linear binning information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetnameofcol" href="#GDAL.ratgetnameofcol"><code>GDAL.ratgetnameofcol</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetNameOfCol(GDALRasterAttributeTableH,
                    int) -&gt; const char *</code></pre><p>Fetch name of indicated column.</p><p><strong>Parameters</strong></p><ul><li><strong>hRAT</strong>: RAT handle.</li><li><strong>iCol</strong>: column index.</li></ul><p><strong>Returns</strong></p><p>name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetrowcount" href="#GDAL.ratgetrowcount"><code>GDAL.ratgetrowcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetRowCount(GDALRasterAttributeTableH) -&gt; int</code></pre><p>Fetch row count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetrowofvalue" href="#GDAL.ratgetrowofvalue"><code>GDAL.ratgetrowofvalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetRowOfValue(GDALRasterAttributeTableH,
                     double) -&gt; int</code></pre><p>Get row for pixel value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgettypeofcol" href="#GDAL.ratgettypeofcol"><code>GDAL.ratgettypeofcol</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetTypeOfCol(GDALRasterAttributeTableH,
                    int) -&gt; GDALRATFieldType</code></pre><p>Fetch column type.</p><p><strong>Parameters</strong></p><ul><li><strong>hRAT</strong>: RAT handle.</li><li><strong>iCol</strong>: column index.</li></ul><p><strong>Returns</strong></p><p>type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetusageofcol" href="#GDAL.ratgetusageofcol"><code>GDAL.ratgetusageofcol</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetUsageOfCol(GDALRasterAttributeTableH,
                     int) -&gt; GDALRATFieldUsage</code></pre><p>Fetch column usage value.</p><p><strong>Parameters</strong></p><ul><li><strong>hRAT</strong>: RAT handle.</li><li><strong>iCol</strong>: column index.</li></ul><p><strong>Returns</strong></p><p>usage.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetvalueasdouble" href="#GDAL.ratgetvalueasdouble"><code>GDAL.ratgetvalueasdouble</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetValueAsDouble(GDALRasterAttributeTableH,
                        int,
                        int) -&gt; double</code></pre><p>Fetch field value as a double.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetvalueasint" href="#GDAL.ratgetvalueasint"><code>GDAL.ratgetvalueasint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetValueAsInt(GDALRasterAttributeTableH,
                     int,
                     int) -&gt; int</code></pre><p>Fetch field value as a integer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratgetvalueasstring" href="#GDAL.ratgetvalueasstring"><code>GDAL.ratgetvalueasstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATGetValueAsString(GDALRasterAttributeTableH,
                        int,
                        int) -&gt; const char *</code></pre><p>Fetch field value as a string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratinitializefromcolortable" href="#GDAL.ratinitializefromcolortable"><code>GDAL.ratinitializefromcolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATInitializeFromColorTable(GDALRasterAttributeTableH,
                                GDALColorTableH) -&gt; CPLErr</code></pre><p>Initialize from color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratserializejson" href="#GDAL.ratserializejson"><code>GDAL.ratserializejson</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSerializeJSON(GDALRasterAttributeTableH) -&gt; void *</code></pre><p>Serialize Raster Attribute Table in Json format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratsetlinearbinning" href="#GDAL.ratsetlinearbinning"><code>GDAL.ratsetlinearbinning</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSetLinearBinning(GDALRasterAttributeTableH,
                        double,
                        double) -&gt; CPLErr</code></pre><p>Set linear binning information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratsetrowcount" href="#GDAL.ratsetrowcount"><code>GDAL.ratsetrowcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSetRowCount(GDALRasterAttributeTableH,
                   int) -&gt; void</code></pre><p>Set row count.</p><p><strong>Parameters</strong></p><ul><li><strong>hRAT</strong>: RAT handle.</li><li><strong>nNewCount</strong>: the new number of rows.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratsetvalueasdouble" href="#GDAL.ratsetvalueasdouble"><code>GDAL.ratsetvalueasdouble</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSetValueAsDouble(GDALRasterAttributeTableH,
                        int,
                        int,
                        double) -&gt; void</code></pre><p>Set field value from double.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratsetvalueasint" href="#GDAL.ratsetvalueasint"><code>GDAL.ratsetvalueasint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSetValueAsInt(GDALRasterAttributeTableH,
                     int,
                     int,
                     int) -&gt; void</code></pre><p>Set field value from integer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratsetvalueasstring" href="#GDAL.ratsetvalueasstring"><code>GDAL.ratsetvalueasstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATSetValueAsString(GDALRasterAttributeTableH,
                        int,
                        int,
                        const char *) -&gt; void</code></pre><p>Set field value from string.</p><p><strong>Parameters</strong></p><ul><li><strong>hRAT</strong>: RAT handle.</li><li><strong>iRow</strong>: row index.</li><li><strong>iField</strong>: field index.</li><li><strong>pszValue</strong>: value.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rattranslatetocolortable" href="#GDAL.rattranslatetocolortable"><code>GDAL.rattranslatetocolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATTranslateToColorTable(GDALRasterAttributeTableH,
                             int nEntryCount) -&gt; GDALColorTableH</code></pre><p>Translate to a color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratvaluesioasdouble" href="#GDAL.ratvaluesioasdouble"><code>GDAL.ratvaluesioasdouble</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATValuesIOAsDouble(GDALRasterAttributeTableH hRAT,
                        GDALRWFlag eRWFlag,
                        int iField,
                        int iStartRow,
                        int iLength,
                        double * pdfData) -&gt; CPLErr</code></pre><p>Read or Write a block of doubles to/from the Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratvaluesioasinteger" href="#GDAL.ratvaluesioasinteger"><code>GDAL.ratvaluesioasinteger</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATValuesIOAsInteger(GDALRasterAttributeTableH hRAT,
                         GDALRWFlag eRWFlag,
                         int iField,
                         int iStartRow,
                         int iLength,
                         int * pnData) -&gt; CPLErr</code></pre><p>Read or Write a block of ints to/from the Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.ratvaluesioasstring" href="#GDAL.ratvaluesioasstring"><code>GDAL.ratvaluesioasstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRATValuesIOAsString(GDALRasterAttributeTableH hRAT,
                        GDALRWFlag eRWFlag,
                        int iField,
                        int iStartRow,
                        int iLength,
                        char ** papszStrList) -&gt; CPLErr</code></pre><p>Read or Write a block of strings to/from the Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rawfield_isnull" href="#GDAL.rawfield_isnull"><code>GDAL.rawfield_isnull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_RawField_IsNull(const OGRField * puField) -&gt; int</code></pre><p>Returns whether a raw field is null.</p><p><strong>Parameters</strong></p><ul><li><strong>puField</strong>: pointer to raw field.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rawfield_isunset" href="#GDAL.rawfield_isunset"><code>GDAL.rawfield_isunset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_RawField_IsUnset(const OGRField * puField) -&gt; int</code></pre><p>Returns whether a raw field is unset.</p><p><strong>Parameters</strong></p><ul><li><strong>puField</strong>: pointer to raw field.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rawfield_setnull" href="#GDAL.rawfield_setnull"><code>GDAL.rawfield_setnull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_RawField_SetNull(OGRField * puField) -&gt; void</code></pre><p>Mark a raw field as null.</p><p><strong>Parameters</strong></p><ul><li><strong>puField</strong>: pointer to raw field.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rawfield_setunset" href="#GDAL.rawfield_setunset"><code>GDAL.rawfield_setunset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_RawField_SetUnset(OGRField * puField) -&gt; void</code></pre><p>Mark a raw field as unset.</p><p><strong>Parameters</strong></p><ul><li><strong>puField</strong>: pointer to raw field.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.readblock" href="#GDAL.readblock"><code>GDAL.readblock</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReadBlock(GDALRasterBandH hBand,
              int nXOff,
              int nYOff,
              void * pData) -&gt; CPLErr</code></pre><p>Read a block of image data efficiently.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.readozimapfile" href="#GDAL.readozimapfile"><code>GDAL.readozimapfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReadOziMapFile(const char *,
                   double *,
                   char **,
                   int *,
                   GDAL_GCP **) -&gt; int</code></pre><p>Helper function for translator implementer wanting support for OZI .map.</p><p><strong>Parameters</strong></p><ul><li><strong>pszBaseFilename</strong>: filename whose basename will help building the .map filename.</li><li><strong>padfGeoTransform</strong>: output geotransform. Must hold 6 doubles.</li><li><strong>ppszWKT</strong>: output pointer to a string that will be allocated with CPLMalloc().</li><li><strong>pnGCPCount</strong>: output pointer to GCP count.</li><li><strong>ppasGCPs</strong>: outputer pointer to an array of GCPs.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success, FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.readtabfile" href="#GDAL.readtabfile"><code>GDAL.readtabfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReadTabFile(const char *,
                double *,
                char **,
                int *,
                GDAL_GCP **) -&gt; int</code></pre><p>Helper function for translator implementer wanting support for MapInfo .tab files.</p><p><strong>Parameters</strong></p><ul><li><strong>pszBaseFilename</strong>: filename whose basename will help building the .tab filename.</li><li><strong>padfGeoTransform</strong>: output geotransform. Must hold 6 doubles.</li><li><strong>ppszWKT</strong>: output pointer to a string that will be allocated with CPLMalloc().</li><li><strong>pnGCPCount</strong>: output pointer to GCP count.</li><li><strong>ppasGCPs</strong>: outputer pointer to an array of GCPs.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success, FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.readworldfile" href="#GDAL.readworldfile"><code>GDAL.readworldfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReadWorldFile(const char *,
                  const char *,
                  double *) -&gt; int</code></pre><p>Read ESRI world file.</p><p><strong>Parameters</strong></p><ul><li><strong>pszBaseFilename</strong>: the target raster file.</li><li><strong>pszExtension</strong>: the extension to use (i.e. &quot;.wld&quot;) or NULL to derive it from the pszBaseFilename</li><li><strong>padfGeoTransform</strong>: the six double array into which the geotransformation should be placed.</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.reference" href="#GDAL.reference"><code>GDAL.reference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_Reference(OGRFeatureDefnH hDefn) -&gt; int</code></pre><p>Increments the reference count by one.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li></ul><p><strong>Returns</strong></p><p>the updated reference count.</p></div></div><div><div><pre><code class="language-none">OGR_L_Reference(OGRLayerH hLayer) -&gt; int</code></pre></div></div><div><div><pre><code class="language-none">OGR_DS_Reference(OGRDataSourceH hDataSource) -&gt; int</code></pre></div></div><div><div><pre><code class="language-none">OSRReference(OGRSpatialReferenceH hSRS) -&gt; int</code></pre><p>Increments the reference count by one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.referencedataset" href="#GDAL.referencedataset"><code>GDAL.referencedataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReferenceDataset(GDALDatasetH hDataset) -&gt; int</code></pre><p>Add one to dataset reference count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.regenerateoverviews" href="#GDAL.regenerateoverviews"><code>GDAL.regenerateoverviews</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRegenerateOverviews(GDALRasterBandH hSrcBand,
                        int nOverviewCount,
                        GDALRasterBandH * pahOverviewBands,
                        const char * pszResampling,
                        GDALProgressFunc pfnProgress,
                        void * pProgressData) -&gt; CPLErr</code></pre><p>Generate downsampled overviews.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: the source (base level) band.</li><li><strong>nOverviewCount</strong>: the number of downsampled bands being generated.</li><li><strong>pahOvrBands</strong>: the list of downsampled bands to be generated.</li><li><strong>pszResampling</strong>: Resampling algorithm (e.g. &quot;AVERAGE&quot;).</li><li><strong>pfnProgress</strong>: progress report function.</li><li><strong>pProgressData</strong>: progress function callback data.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure on failure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.registerall" href="#GDAL.registerall"><code>GDAL.registerall</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRRegisterAll(void) -&gt; void</code></pre><p>Register all drivers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.registerdriver" href="#GDAL.registerdriver"><code>GDAL.registerdriver</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRegisterDriver(GDALDriverH hDriver) -&gt; int</code></pre><p>Register a driver for use.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.release" href="#GDAL.release"><code>GDAL.release</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_Release(OGRFeatureDefnH hDefn) -&gt; void</code></pre><p>Drop a reference, and destroy if unreferenced.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition to be released.</li></ul></div></div><div><div><pre><code class="language-none">OSRRelease(OGRSpatialReferenceH hSRS) -&gt; void</code></pre><p>Decrements the reference count by one, and destroy if zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.releasedataset" href="#GDAL.releasedataset"><code>GDAL.releasedataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReleaseDataset(GDALDatasetH hDataset) -&gt; int</code></pre><p>Drop a reference to this object, and destroy if no longer referenced.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.releasedatasource" href="#GDAL.releasedatasource"><code>GDAL.releasedatasource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRReleaseDataSource(OGRDataSourceH) -&gt; OGRErr</code></pre><p>Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source to release</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success or an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.releaseresultset" href="#GDAL.releaseresultset"><code>GDAL.releaseresultset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_DS_ReleaseResultSet(OGRDataSourceH,
                        OGRLayerH) -&gt; void</code></pre><p>Release results of OGR<em>DS</em>ExecuteSQL().</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: an handle to the data source on which was executed an SQL query.</li><li><strong>hLayer</strong>: handle to the result of a previous OGR<em>DS</em>ExecuteSQL() call.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.removegeometry" href="#GDAL.removegeometry"><code>GDAL.removegeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_RemoveGeometry(OGRGeometryH hGeom,
                     int iGeom,
                     int bDelete) -&gt; OGRErr</code></pre><p>Remove a geometry from an exiting geometry container.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: the existing geometry to delete from.</li><li><strong>iGeom</strong>: the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</li><li><strong>bDelete</strong>: if TRUE the geometry will be destroyed, otherwise it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGRERR</em>FAILURE if the index is out of range.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.renamedataset" href="#GDAL.renamedataset"><code>GDAL.renamedataset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRenameDataset(GDALDriverH hDriver,
                  const char * pszNewName,
                  const char * pszOldName) -&gt; CPLErr</code></pre><p>Rename a dataset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.reorderfield" href="#GDAL.reorderfield"><code>GDAL.reorderfield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_ReorderField(OGRLayerH,
                   int iOldFieldPos,
                   int iNewFieldPos) -&gt; OGRErr</code></pre><p>Reorder an existing field on a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li><li><strong>iOldFieldPos</strong>: previous position of the field to move. Must be in the range [0,GetFieldCount()-1].</li><li><strong>iNewFieldPos</strong>: new position of the field to move. Must be in the range [0,GetFieldCount()-1].</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.reorderfielddefns" href="#GDAL.reorderfielddefns"><code>GDAL.reorderfielddefns</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_ReorderFieldDefns(OGRFeatureDefnH hDefn,
                         int * panMap) -&gt; OGRErr</code></pre><p>Reorder the field definitions in the array of the feature definition.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition.</li><li><strong>panMap</strong>: an array of GetFieldCount() elements which is a permutation of [0, GetFieldCount()-1]. panMap is such that, for each field definition at position i after reordering, its position before reordering was panMap[i].</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE in case of success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.reorderfields" href="#GDAL.reorderfields"><code>GDAL.reorderfields</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_ReorderFields(OGRLayerH,
                    int * panMap) -&gt; OGRErr</code></pre><p>Reorder all the fields of a layer.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer.</li><li><strong>panMap</strong>: an array of GetLayerDefn()-&gt;OGRFeatureDefn::GetFieldCount() elements which is a permutation of [0, GetLayerDefn()-&gt;OGRFeatureDefn::GetFieldCount()-1].</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.reprojectiontransform" href="#GDAL.reprojectiontransform"><code>GDAL.reprojectiontransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALReprojectionTransform(void * pTransformArg,
                          int bDstToSrc,
                          int nPointCount,
                          double * padfX,
                          double * padfY,
                          double * padfZ,
                          int * panSuccess) -&gt; int</code></pre><p>Perform reprojection transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.resetreading" href="#GDAL.resetreading"><code>GDAL.resetreading</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_ResetReading(OGRLayerH) -&gt; void</code></pre><p>Reset feature reading to start on the first feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which features are read.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.resetstylestringreading" href="#GDAL.resetstylestringreading"><code>GDAL.resetstylestringreading</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_ResetStyleStringReading(OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Reset the next style pointer to 0.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rollbacktransaction" href="#GDAL.rollbacktransaction"><code>GDAL.rollbacktransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_RollbackTransaction(OGRLayerH) -&gt; OGRErr</code></pre><p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rpcinfotomd" href="#GDAL.rpcinfotomd"><code>GDAL.rpcinfotomd</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">RPCInfoToMD(GDALRPCInfo * psRPCInfo) -&gt; char **</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.rpctransform" href="#GDAL.rpctransform"><code>GDAL.rpctransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALRPCTransform(void * pTransformArg,
                 int bDstToSrc,
                 int nPointCount,
                 double * x,
                 double * y,
                 double * z,
                 int * panSuccess) -&gt; int</code></pre><p>RPC transform.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.savestyletable" href="#GDAL.savestyletable"><code>GDAL.savestyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_SaveStyleTable(OGRStyleTableH hStyleTable,
                        const char * pszFilename) -&gt; int</code></pre><p>Save a style table to a file.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: handle to the style table.</li><li><strong>pszFilename</strong>: the name of the file to save to.</li></ul><p><strong>Returns</strong></p><p>TRUE on success, FALSE on error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.segmentize" href="#GDAL.segmentize"><code>GDAL.segmentize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Segmentize(OGRGeometryH hGeom,
                 double dfMaxLength) -&gt; void</code></pre><p>Modify the geometry such it has no segment longer then the given distance.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to segmentize</li><li><strong>dfMaxLength</strong>: the maximum distance between 2 points after segmentization</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.serializetransformer" href="#GDAL.serializetransformer"><code>GDAL.serializetransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSerializeTransformer(GDALTransformerFunc,
                         void * pTransformArg) -&gt; CPLXMLNode *</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.set" href="#GDAL.set"><code>GDAL.set</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_Set(OGRFieldDefnH hDefn,
            const char * pszNameIn,
            OGRFieldType eTypeIn,
            int nWidthIn,
            int nPrecisionIn,
            OGRJustification eJustifyIn) -&gt; void</code></pre><p>Set defining parameters for a field in one call.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set to.</li><li><strong>pszNameIn</strong>: the new name to assign.</li><li><strong>eTypeIn</strong>: the new type (one of the OFT values like OFTInteger).</li><li><strong>nWidthIn</strong>: the preferred formatting width. Defaults to zero indicating undefined.</li><li><strong>nPrecisionIn</strong>: number of decimals places for formatting, defaults to zero indicating undefined.</li><li><strong>eJustifyIn</strong>: the formatting justification (OJLeft or OJRight), defaults to OJUndefined.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.set3d" href="#GDAL.set3d"><code>GDAL.set3d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Set3D(OGRGeometryH hGeom,
            int bIs3D) -&gt; void</code></pre><p>Add or remove the Z coordinate dimension.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to set or unset the Z dimension.</li><li><strong>bIs3D</strong>: Should the geometry have a Z dimension, either TRUE or FALSE.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setacea" href="#GDAL.setacea"><code>GDAL.setacea</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetACEA(OGRSpatialReferenceH hSRS,
           double dfStdP1,
           double dfStdP2,
           double dfCenterLat,
           double dfCenterLong,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Albers Conic Equal Area.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setae" href="#GDAL.setae"><code>GDAL.setae</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetAE(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Azimuthal Equidistant.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setangularunits" href="#GDAL.setangularunits"><code>GDAL.setangularunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetAngularUnits(OGRSpatialReferenceH hSRS,
                   const char * pszUnits,
                   double dfInRadians) -&gt; OGRErr</code></pre><p>Set the angular units for the geographic coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setattributefilter" href="#GDAL.setattributefilter"><code>GDAL.setattributefilter</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetAttributeFilter(OGRLayerH,
                         const char *) -&gt; OGRErr</code></pre><p>Set a new attribute query.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which attribute query will be executed.</li><li><strong>pszQuery</strong>: query in restricted SQL WHERE format, or NULL to clear the current query.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setattrvalue" href="#GDAL.setattrvalue"><code>GDAL.setattrvalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetAttrValue(OGRSpatialReferenceH hSRS,
                const char * pszPath,
                const char * pszValue) -&gt; OGRErr</code></pre><p>Set attribute value in spatial reference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setauthority" href="#GDAL.setauthority"><code>GDAL.setauthority</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetAuthority(OGRSpatialReferenceH hSRS,
                const char * pszTargetKey,
                const char * pszAuthority,
                int nCode) -&gt; OGRErr</code></pre><p>Set the authority for a node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setaxes" href="#GDAL.setaxes"><code>GDAL.setaxes</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetAxes(OGRSpatialReferenceH hSRS,
           const char * pszTargetKey,
           const char * pszXAxisName,
           OGRAxisOrientation eXAxisOrientation,
           const char * pszYAxisName,
           OGRAxisOrientation eYAxisOrientation) -&gt; OGRErr</code></pre><p>Set the axes for a coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setbonne" href="#GDAL.setbonne"><code>GDAL.setbonne</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetBonne(OGRSpatialReferenceH hSRS,
            double dfStdP1,
            double dfCentralMeridian,
            double dfFalseEasting,
            double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Bonne.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcachemax" href="#GDAL.setcachemax"><code>GDAL.setcachemax</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetCacheMax(int nNewSizeInBytes) -&gt; void</code></pre><p>Set maximum cache memory.</p><p><strong>Parameters</strong></p><ul><li><strong>nNewSizeInBytes</strong>: the maximum number of bytes for caching.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcachemax64" href="#GDAL.setcachemax64"><code>GDAL.setcachemax64</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetCacheMax64(GIntBig nNewSizeInBytes) -&gt; void</code></pre><p>Set maximum cache memory.</p><p><strong>Parameters</strong></p><ul><li><strong>nNewSizeInBytes</strong>: the maximum number of bytes for caching.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcea" href="#GDAL.setcea"><code>GDAL.setcea</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetCEA(OGRSpatialReferenceH hSRS,
          double dfStdP1,
          double dfCentralMeridian,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Cylindrical Equal Area.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcolorentry" href="#GDAL.setcolorentry"><code>GDAL.setcolorentry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetColorEntry(GDALColorTableH hTable,
                  int i,
                  const GDALColorEntry * poEntry) -&gt; void</code></pre><p>Set entry in color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcompoundcs" href="#GDAL.setcompoundcs"><code>GDAL.setcompoundcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetCompoundCS(OGRSpatialReferenceH hSRS,
                 const char * pszName,
                 OGRSpatialReferenceH hHorizSRS,
                 OGRSpatialReferenceH hVertSRS) -&gt; OGRErr</code></pre><p>Setup a compound coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcoordinatedimension" href="#GDAL.setcoordinatedimension"><code>GDAL.setcoordinatedimension</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetCoordinateDimension(OGRGeometryH hGeom,
                             int nNewDimension) -&gt; void</code></pre><p>Set the coordinate dimension.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to set the dimension of the coordinates.</li><li><strong>nNewDimension</strong>: New coordinate dimension value, either 2 or 3.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcs" href="#GDAL.setcs"><code>GDAL.setcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetCS(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Cassini-Soldner.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setcurrenterrorhandlercatchdebug" href="#GDAL.setcurrenterrorhandlercatchdebug"><code>GDAL.setcurrenterrorhandlercatchdebug</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLSetCurrentErrorHandlerCatchDebug(int bCatchDebug) -&gt; void</code></pre><p>Set if the current error handler should intercept debug messages, or if they should be processed by the previous handler.</p><p><strong>Parameters</strong></p><ul><li><strong>bCatchDebug</strong>: FALSE if the current error handler should not intercept debug messages</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setdefault" href="#GDAL.setdefault"><code>GDAL.setdefault</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetDefault(OGRFieldDefnH hDefn,
                   const char * pszDefault) -&gt; void</code></pre><p>Set default field value.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition.</li><li><strong>pszDefault</strong>: new default field value or NULL pointer.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setdefaulthistogram" href="#GDAL.setdefaulthistogram"><code>GDAL.setdefaulthistogram</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetDefaultHistogram(GDALRasterBandH hBand,
                        double dfMin,
                        double dfMax,
                        int nBuckets,
                        int * panHistogram) -&gt; CPLErr</code></pre><p>Set default histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setdefaulthistogramex" href="#GDAL.setdefaulthistogramex"><code>GDAL.setdefaulthistogramex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetDefaultHistogramEx(GDALRasterBandH hBand,
                          double dfMin,
                          double dfMax,
                          int nBuckets,
                          GUIntBig * panHistogram) -&gt; CPLErr</code></pre><p>Set default histogram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setdefaultrat" href="#GDAL.setdefaultrat"><code>GDAL.setdefaultrat</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetDefaultRAT(GDALRasterBandH hBand,
                  GDALRasterAttributeTableH hRAT) -&gt; CPLErr</code></pre><p>Set default Raster Attribute Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setdescription" href="#GDAL.setdescription"><code>GDAL.setdescription</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetDescription(GDALMajorObjectH hObject,
                   const char * pszNewDesc) -&gt; void</code></pre><p>Set object description.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setec" href="#GDAL.setec"><code>GDAL.setec</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEC(OGRSpatialReferenceH hSRS,
         double dfStdP1,
         double dfStdP2,
         double dfCenterLat,
         double dfCenterLong,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Equidistant Conic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.seteckert" href="#GDAL.seteckert"><code>GDAL.seteckert</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEckert(OGRSpatialReferenceH hSRS,
             int nVariation,
             double dfCentralMeridian,
             double dfFalseEasting,
             double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Eckert I-VI.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.seteckertiv" href="#GDAL.seteckertiv"><code>GDAL.seteckertiv</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEckertIV(OGRSpatialReferenceH hSRS,
               double dfCentralMeridian,
               double dfFalseEasting,
               double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Eckert IV.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.seteckertvi" href="#GDAL.seteckertvi"><code>GDAL.seteckertvi</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEckertVI(OGRSpatialReferenceH hSRS,
               double dfCentralMeridian,
               double dfFalseEasting,
               double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Eckert VI.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setequirectangular" href="#GDAL.setequirectangular"><code>GDAL.setequirectangular</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEquirectangular(OGRSpatialReferenceH hSRS,
                      double dfCenterLat,
                      double dfCenterLong,
                      double dfFalseEasting,
                      double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Equirectangular.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setequirectangular2" href="#GDAL.setequirectangular2"><code>GDAL.setequirectangular2</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetEquirectangular2(OGRSpatialReferenceH hSRS,
                       double dfCenterLat,
                       double dfCenterLong,
                       double dfStdParallel1,
                       double dfFalseEasting,
                       double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Equirectangular generalized form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.seterrorhandler" href="#GDAL.seterrorhandler"><code>GDAL.seterrorhandler</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLSetErrorHandler(CPLErrorHandler pfnErrorHandlerNew) -&gt; CPLErrorHandler</code></pre><p>Install custom error handler.</p><p><strong>Parameters</strong></p><ul><li><strong>pfnErrorHandlerNew</strong>: new error handler function.</li></ul><p><strong>Returns</strong></p><p>returns the previously installed error handler.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.seterrorhandlerex" href="#GDAL.seterrorhandlerex"><code>GDAL.seterrorhandlerex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLSetErrorHandlerEx(CPLErrorHandler pfnErrorHandlerNew,
                     void * pUserData) -&gt; CPLErrorHandler</code></pre><p>Install custom error handle with user&#39;s data.</p><p><strong>Parameters</strong></p><ul><li><strong>pfnErrorHandlerNew</strong>: new error handler function.</li><li><strong>pUserData</strong>: User data to carry along with the error context.</li></ul><p><strong>Returns</strong></p><p>returns the previously installed error handler.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfeature" href="#GDAL.setfeature"><code>GDAL.setfeature</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetFeature(OGRLayerH,
                 OGRFeatureH) -&gt; OGRErr</code></pre><p>Rewrite an existing feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to write the feature.</li><li><strong>hFeat</strong>: the feature to write.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if the operation works, otherwise an appropriate error code (e.g OGRERR</em>NON<em>EXISTING</em>FEATURE if the feature does not exist).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfid" href="#GDAL.setfid"><code>GDAL.setfid</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFID(OGRFeatureH hFeat,
             GIntBig nFID) -&gt; OGRErr</code></pre><p>Set the feature identifier.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to set the feature id to.</li><li><strong>nFID</strong>: the new feature identifier value to assign.</li></ul><p><strong>Returns</strong></p><p>On success OGRERR_NONE, or on failure some other value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldbinary" href="#GDAL.setfieldbinary"><code>GDAL.setfieldbinary</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldBinary(OGRFeatureH hFeat,
                     int iField,
                     int nBytes,
                     GByte * pabyData) -&gt; void</code></pre><p>Set field to binary data.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nBytes</strong>: the number of bytes in pabyData array.</li><li><strong>pabyData</strong>: the data to apply.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfielddatetime" href="#GDAL.setfielddatetime"><code>GDAL.setfielddatetime</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldDateTime(OGRFeatureH hFeat,
                       int iField,
                       int nYear,
                       int nMonth,
                       int nDay,
                       int nHour,
                       int nMinute,
                       int nSecond,
                       int nTZFlag) -&gt; void</code></pre><p>Set field to datetime.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nYear</strong>: (including century)</li><li><strong>nMonth</strong>: (1-12)</li><li><strong>nDay</strong>: (1-31)</li><li><strong>nHour</strong>: (0-23)</li><li><strong>nMinute</strong>: (0-59)</li><li><strong>nSecond</strong>: (0-59)</li><li><strong>nTZFlag</strong>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfielddatetimeex" href="#GDAL.setfielddatetimeex"><code>GDAL.setfielddatetimeex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldDateTimeEx(OGRFeatureH hFeat,
                         int iField,
                         int nYear,
                         int nMonth,
                         int nDay,
                         int nHour,
                         int nMinute,
                         float fSecond,
                         int nTZFlag) -&gt; void</code></pre><p>Set field to datetime.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nYear</strong>: (including century)</li><li><strong>nMonth</strong>: (1-12)</li><li><strong>nDay</strong>: (1-31)</li><li><strong>nHour</strong>: (0-23)</li><li><strong>nMinute</strong>: (0-59)</li><li><strong>fSecond</strong>: (0-59, with millisecond accuracy)</li><li><strong>nTZFlag</strong>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfielddouble" href="#GDAL.setfielddouble"><code>GDAL.setfielddouble</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldDouble(OGRFeatureH hFeat,
                     int iField,
                     double dfValue) -&gt; void</code></pre><p>Set field to double value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>dfValue</strong>: the value to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfielddoublelist" href="#GDAL.setfielddoublelist"><code>GDAL.setfielddoublelist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldDoubleList(OGRFeatureH hFeat,
                         int iField,
                         int nCount,
                         double * padfValues) -&gt; void</code></pre><p>Set field to list of doubles value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nCount</strong>: the number of values in the list being assigned.</li><li><strong>padfValues</strong>: the values to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldinteger" href="#GDAL.setfieldinteger"><code>GDAL.setfieldinteger</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldInteger(OGRFeatureH hFeat,
                      int iField,
                      int nValue) -&gt; void</code></pre><p>Set field to integer value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>nValue</strong>: the value to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldinteger64" href="#GDAL.setfieldinteger64"><code>GDAL.setfieldinteger64</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldInteger64(OGRFeatureH hFeat,
                        int iField,
                        GIntBig nValue) -&gt; void</code></pre><p>Set field to 64 bit integer value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>nValue</strong>: the value to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldinteger64list" href="#GDAL.setfieldinteger64list"><code>GDAL.setfieldinteger64list</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldInteger64List(OGRFeatureH hFeat,
                            int iField,
                            int nCount,
                            const GIntBig * panValues) -&gt; void</code></pre><p>Set field to list of 64 bit integers value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nCount</strong>: the number of values in the list being assigned.</li><li><strong>panValues</strong>: the values to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldintegerlist" href="#GDAL.setfieldintegerlist"><code>GDAL.setfieldintegerlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldIntegerList(OGRFeatureH hFeat,
                          int iField,
                          int nCount,
                          int * panValues) -&gt; void</code></pre><p>Set field to list of integers value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>nCount</strong>: the number of values in the list being assigned.</li><li><strong>panValues</strong>: the values to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldnull" href="#GDAL.setfieldnull"><code>GDAL.setfieldnull</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldNull(OGRFeatureH hFeat,
                   int iField) -&gt; void</code></pre><p>Clear a field, marking it as null.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is.</li><li><strong>iField</strong>: the field to set to null.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldraw" href="#GDAL.setfieldraw"><code>GDAL.setfieldraw</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldRaw(OGRFeatureH hFeat,
                  int iField,
                  OGRField * psValue) -&gt; void</code></pre><p>Set field.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>psValue</strong>: handle on the value to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldstring" href="#GDAL.setfieldstring"><code>GDAL.setfieldstring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldString(OGRFeatureH hFeat,
                     int iField,
                     const char * pszValue) -&gt; void</code></pre><p>Set field to string value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to fetch, from 0 to GetFieldCount()-1.</li><li><strong>pszValue</strong>: the value to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfieldstringlist" href="#GDAL.setfieldstringlist"><code>GDAL.setfieldstringlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFieldStringList(OGRFeatureH hFeat,
                         int iField,
                         char ** papszValues) -&gt; void</code></pre><p>Set field to list of strings value.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature that owned the field.</li><li><strong>iField</strong>: the field to set, from 0 to GetFieldCount()-1.</li><li><strong>papszValues</strong>: the values to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfrom" href="#GDAL.setfrom"><code>GDAL.setfrom</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFrom(OGRFeatureH hFeat,
              OGRFeatureH hOtherFeat,
              int bForgiving) -&gt; OGRErr</code></pre><p>Set one feature from another.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to set to.</li><li><strong>hOtherFeat</strong>: handle to the feature from which geometry, and field values will be copied.</li><li><strong>bForgiving</strong>: TRUE if the operation should continue despite lacking output fields matching some of the source fields.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfromuserinput" href="#GDAL.setfromuserinput"><code>GDAL.setfromuserinput</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetFromUserInput(OGRSpatialReferenceH hSRS,
                    const char * pszDef) -&gt; OGRErr</code></pre><p>Set spatial reference from various text formats.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setfromwithmap" href="#GDAL.setfromwithmap"><code>GDAL.setfromwithmap</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetFromWithMap(OGRFeatureH hFeat,
                     OGRFeatureH hOtherFeat,
                     int bForgiving,
                     int * panMap) -&gt; OGRErr</code></pre><p>Set one feature from another.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to set to.</li><li><strong>hOtherFeat</strong>: handle to the feature from which geometry, and field values will be copied.</li><li><strong>panMap</strong>: Array of the indices of the destination feature&#39;s fields stored at the corresponding index of the source feature&#39;s fields. A value of -1 should be used to ignore the source&#39;s field. The array should not be NULL and be as long as the number of fields in the source feature.</li><li><strong>bForgiving</strong>: TRUE if the operation should continue despite lacking output fields matching some of the source fields.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgaussschreibertmercator" href="#GDAL.setgaussschreibertmercator"><code>GDAL.setgaussschreibertmercator</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGaussSchreiberTMercator(OGRSpatialReferenceH hSRS,
                              double dfCenterLat,
                              double dfCenterLong,
                              double dfScale,
                              double dfFalseEasting,
                              double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Gauss Schreiber Transverse Mercator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgcps" href="#GDAL.setgcps"><code>GDAL.setgcps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetGCPs(GDALDatasetH hDS,
            int nGCPCount,
            const GDAL_GCP * pasGCPList,
            const char * pszGCPProjection) -&gt; CPLErr</code></pre><p>Assign GCPs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgenerate_db2_v72_byte_order" href="#GDAL.setgenerate_db2_v72_byte_order"><code>GDAL.setgenerate_db2_v72_byte_order</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRSetGenerate_DB2_V72_BYTE_ORDER(int bGenerate_DB2_V72_BYTE_ORDER) -&gt; OGRErr</code></pre><p>Special entry point to enable the hack for generating DB2 V7.2 style WKB.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgenimgprojtransformerdstgeotransform" href="#GDAL.setgenimgprojtransformerdstgeotransform"><code>GDAL.setgenimgprojtransformerdstgeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetGenImgProjTransformerDstGeoTransform(void * hTransformArg,
                                            const double * padfGeoTransform) -&gt; void</code></pre><p>Set GenImgProj output geotransform.</p><p><strong>Parameters</strong></p><ul><li><strong>hTransformArg</strong>: the handle to update.</li><li><strong>padfGeoTransform</strong>: the destination geotransform to apply (six doubles).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeoccs" href="#GDAL.setgeoccs"><code>GDAL.setgeoccs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGeocCS(OGRSpatialReferenceH hSRS,
             const char * pszName) -&gt; OGRErr</code></pre><p>Set the user visible PROJCS name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeogcs" href="#GDAL.setgeogcs"><code>GDAL.setgeogcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGeogCS(OGRSpatialReferenceH hSRS,
             const char * pszGeogName,
             const char * pszDatumName,
             const char * pszSpheroidName,
             double dfSemiMajor,
             double dfInvFlattening,
             const char * pszPMName,
             double dfPMOffset,
             const char * pszAngularUnits,
             double dfConvertToRadians) -&gt; OGRErr</code></pre><p>Set geographic coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeometry" href="#GDAL.setgeometry"><code>GDAL.setgeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetGeometry(OGRFeatureH hFeat,
                  OGRGeometryH hGeom) -&gt; OGRErr</code></pre><p>Set feature geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which new geometry is applied to.</li><li><strong>hGeom</strong>: handle to the new geometry to apply to feature.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGR</em>UNSUPPORTED<em>GEOMETRY</em>TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeometrydirectly" href="#GDAL.setgeometrydirectly"><code>GDAL.setgeometrydirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetGeometryDirectly(OGRFeatureH hFeat,
                          OGRGeometryH hGeom) -&gt; OGRErr</code></pre><p>Set feature geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which to apply the geometry.</li><li><strong>hGeom</strong>: handle to the new geometry to apply to feature.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGR</em>UNSUPPORTED<em>GEOMETRY</em>TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeometryignored" href="#GDAL.setgeometryignored"><code>GDAL.setgeometryignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_SetGeometryIgnored(OGRFeatureDefnH hDefn,
                          int bIgnore) -&gt; void</code></pre><p>Set whether the geometry can be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li><li><strong>bIgnore</strong>: ignore state</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeomfield" href="#GDAL.setgeomfield"><code>GDAL.setgeomfield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetGeomField(OGRFeatureH hFeat,
                   int iField,
                   OGRGeometryH hGeom) -&gt; OGRErr</code></pre><p>Set feature geometry of a specified geometry field.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which new geometry is applied to.</li><li><strong>iField</strong>: geometry field to set.</li><li><strong>hGeom</strong>: handle to the new geometry to apply to feature.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGR</em>UNSUPPORTED<em>GEOMETRY</em>TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeomfielddirectly" href="#GDAL.setgeomfielddirectly"><code>GDAL.setgeomfielddirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetGeomFieldDirectly(OGRFeatureH hFeat,
                           int iField,
                           OGRGeometryH hGeom) -&gt; OGRErr</code></pre><p>Set feature geometry of a specified geometry field.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which to apply the geometry.</li><li><strong>iField</strong>: geometry field to set.</li><li><strong>hGeom</strong>: handle to the new geometry to apply to feature.</li></ul><p><strong>Returns</strong></p><p>OGRERR<em>NONE if successful, or OGRERR</em>FAILURE if the index is invalid, or OGR<em>UNSUPPORTED</em>GEOMETRY_TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeomtype" href="#GDAL.setgeomtype"><code>GDAL.setgeomtype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_SetGeomType(OGRFeatureDefnH hDefn,
                   OGRwkbGeometryType eType) -&gt; void</code></pre><p>Assign the base geometry type for the passed layer (the same as the feature definition).</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the layer or feature definition to set the geometry type to.</li><li><strong>eType</strong>: the new type to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeos" href="#GDAL.setgeos"><code>GDAL.setgeos</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGEOS(OGRSpatialReferenceH hSRS,
           double dfCentralMeridian,
           double dfSatelliteHeight,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>GEOS - Geostationary Satellite View.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgeotransform" href="#GDAL.setgeotransform"><code>GDAL.setgeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetGeoTransform(GDALDatasetH hDS,
                    double * padfTransform) -&gt; CPLErr</code></pre><p>Set the affine transformation coefficients.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgh" href="#GDAL.setgh"><code>GDAL.setgh</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGH(OGRSpatialReferenceH hSRS,
         double dfCentralMeridian,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Goode Homolosine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgnomonic" href="#GDAL.setgnomonic"><code>GDAL.setgnomonic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGnomonic(OGRSpatialReferenceH hSRS,
               double dfCenterLat,
               double dfCenterLong,
               double dfFalseEasting,
               double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Gnomonic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setgs" href="#GDAL.setgs"><code>GDAL.setgs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetGS(OGRSpatialReferenceH hSRS,
         double dfCentralMeridian,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Gall Stereograpic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.sethom" href="#GDAL.sethom"><code>GDAL.sethom</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetHOM(OGRSpatialReferenceH hSRS,
          double dfCenterLat,
          double dfCenterLong,
          double dfAzimuth,
          double dfRectToSkew,
          double dfScale,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Set a Hotine Oblique Mercator projection using azimuth angle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.sethom2pno" href="#GDAL.sethom2pno"><code>GDAL.sethom2pno</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetHOM2PNO(OGRSpatialReferenceH hSRS,
              double dfCenterLat,
              double dfLat1,
              double dfLong1,
              double dfLat2,
              double dfLong2,
              double dfScale,
              double dfFalseEasting,
              double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Set a Hotine Oblique Mercator projection using two points on projection centerline.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.sethomac" href="#GDAL.sethomac"><code>GDAL.sethomac</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetHOMAC(OGRSpatialReferenceH hSRS,
            double dfCenterLat,
            double dfCenterLong,
            double dfAzimuth,
            double dfRectToSkew,
            double dfScale,
            double dfFalseEasting,
            double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Set an Oblique Mercator projection using azimuth angle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setigh" href="#GDAL.setigh"><code>GDAL.setigh</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetIGH(OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Interrupted Goode Homolosine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setignored" href="#GDAL.setignored"><code>GDAL.setignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetIgnored(OGRFieldDefnH hDefn,
                   int ignore) -&gt; void</code></pre><p>Set whether this field should be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li><li><strong>ignore</strong>: ignore state</li></ul></div></div><div><div><pre><code class="language-none">OGR_GFld_SetIgnored(OGRGeomFieldDefnH hDefn,
                    int ignore) -&gt; void</code></pre><p>Set whether this field should be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition</li><li><strong>ignore</strong>: ignore state</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setignoredfields" href="#GDAL.setignoredfields"><code>GDAL.setignoredfields</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetIgnoredFields(OGRLayerH,
                       const char **) -&gt; OGRErr</code></pre><p>Set which fields can be omitted when retrieving features from the layer.</p><p><strong>Parameters</strong></p><ul><li><strong>papszFields</strong>: an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setiwmpolyconic" href="#GDAL.setiwmpolyconic"><code>GDAL.setiwmpolyconic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetIWMPolyconic(OGRSpatialReferenceH hSRS,
                   double dfLat1,
                   double dfLat2,
                   double dfCenterLong,
                   double dfFalseEasting,
                   double dfFalseNorthing) -&gt; OGRErr</code></pre><p>International Map of the World Polyconic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setjustify" href="#GDAL.setjustify"><code>GDAL.setjustify</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetJustify(OGRFieldDefnH hDefn,
                   OGRJustification eJustify) -&gt; void</code></pre><p>Set the justification for this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set justification to.</li><li><strong>eJustify</strong>: the new justification.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setkrovak" href="#GDAL.setkrovak"><code>GDAL.setkrovak</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetKrovak(OGRSpatialReferenceH hSRS,
             double dfCenterLat,
             double dfCenterLong,
             double dfAzimuth,
             double dfPseudoStdParallel1,
             double dfScale,
             double dfFalseEasting,
             double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Krovak Oblique Conic Conformal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlaea" href="#GDAL.setlaea"><code>GDAL.setlaea</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLAEA(OGRSpatialReferenceH hSRS,
           double dfCenterLat,
           double dfCenterLong,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Lambert Azimuthal Equal-Area.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlcc" href="#GDAL.setlcc"><code>GDAL.setlcc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLCC(OGRSpatialReferenceH hSRS,
          double dfStdP1,
          double dfStdP2,
          double dfCenterLat,
          double dfCenterLong,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Lambert Conformal Conic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlcc1sp" href="#GDAL.setlcc1sp"><code>GDAL.setlcc1sp</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLCC1SP(OGRSpatialReferenceH hSRS,
             double dfCenterLat,
             double dfCenterLong,
             double dfScale,
             double dfFalseEasting,
             double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Lambert Conformal Conic 1SP.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlccb" href="#GDAL.setlccb"><code>GDAL.setlccb</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLCCB(OGRSpatialReferenceH hSRS,
           double dfStdP1,
           double dfStdP2,
           double dfCenterLat,
           double dfCenterLong,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Lambert Conformal Conic (Belgium)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlinearunits" href="#GDAL.setlinearunits"><code>GDAL.setlinearunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLinearUnits(OGRSpatialReferenceH hSRS,
                  const char * pszUnits,
                  double dfInMeters) -&gt; OGRErr</code></pre><p>Set the linear units for the projection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlinearunitsandupdateparameters" href="#GDAL.setlinearunitsandupdateparameters"><code>GDAL.setlinearunitsandupdateparameters</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLinearUnitsAndUpdateParameters(OGRSpatialReferenceH hSRS,
                                     const char * pszUnits,
                                     double dfInMeters) -&gt; OGRErr</code></pre><p>Set the linear units for the projection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setlocalcs" href="#GDAL.setlocalcs"><code>GDAL.setlocalcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetLocalCS(OGRSpatialReferenceH hSRS,
              const char * pszName) -&gt; OGRErr</code></pre><p>Set the user visible LOCAL_CS name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmc" href="#GDAL.setmc"><code>GDAL.setmc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetMC(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Miller Cylindrical.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmeasured" href="#GDAL.setmeasured"><code>GDAL.setmeasured</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetMeasured(OGRGeometryH hGeom,
                  int bIsMeasured) -&gt; void</code></pre><p>Add or remove the M coordinate dimension.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to set or unset the M dimension.</li><li><strong>bIsMeasured</strong>: Should the geometry have a M dimension, either TRUE or FALSE.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmercator" href="#GDAL.setmercator"><code>GDAL.setmercator</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetMercator(OGRSpatialReferenceH hSRS,
               double dfCenterLat,
               double dfCenterLong,
               double dfScale,
               double dfFalseEasting,
               double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Mercator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmercator2sp" href="#GDAL.setmercator2sp"><code>GDAL.setmercator2sp</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetMercator2SP(OGRSpatialReferenceH hSRS,
                  double dfStdP1,
                  double dfCenterLat,
                  double dfCenterLong,
                  double dfFalseEasting,
                  double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Mercator 2SP.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmetadata" href="#GDAL.setmetadata"><code>GDAL.setmetadata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetMetadata(GDALMajorObjectH hObject,
                char ** papszMD,
                const char * pszDomain) -&gt; CPLErr</code></pre><p>Set metadata.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmetadataitem" href="#GDAL.setmetadataitem"><code>GDAL.setmetadataitem</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetMetadataItem(GDALMajorObjectH hObject,
                    const char * pszName,
                    const char * pszValue,
                    const char * pszDomain) -&gt; CPLErr</code></pre><p>Set single metadata item.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setmollweide" href="#GDAL.setmollweide"><code>GDAL.setmollweide</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetMollweide(OGRSpatialReferenceH hSRS,
                double dfCentralMeridian,
                double dfFalseEasting,
                double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Mollweide.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setname" href="#GDAL.setname"><code>GDAL.setname</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetName(OGRFieldDefnH hDefn,
                const char * pszName) -&gt; void</code></pre><p>Reset the name of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to apply the new name to.</li><li><strong>pszName</strong>: the new name to apply.</li></ul></div></div><div><div><pre><code class="language-none">OGR_GFld_SetName(OGRGeomFieldDefnH hDefn,
                 const char * pszName) -&gt; void</code></pre><p>Reset the name of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition to apply the new name to.</li><li><strong>pszName</strong>: the new name to apply.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnativedata" href="#GDAL.setnativedata"><code>GDAL.setnativedata</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetNativeData(OGRFeatureH hFeat,
                    const char * pszNativeData) -&gt; void</code></pre><p>Sets the native data for the feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature.</li><li><strong>pszNativeData</strong>: a string with the native data, or NULL if there is none.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnativemediatype" href="#GDAL.setnativemediatype"><code>GDAL.setnativemediatype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetNativeMediaType(OGRFeatureH hFeat,
                         const char * pszNativeMediaType) -&gt; void</code></pre><p>Sets the native media type for the feature.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature.</li><li><strong>pszNativeMediaType</strong>: a string with the native media type, or NULL if there is none.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnextbyindex" href="#GDAL.setnextbyindex"><code>GDAL.setnextbyindex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetNextByIndex(OGRLayerH,
                     GIntBig) -&gt; OGRErr</code></pre><p>Move read cursor to the nIndex&#39;th feature in the current resultset.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li><li><strong>nIndex</strong>: the index indicating how many steps into the result set to seek.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success or an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnonlineargeometriesenabledflag" href="#GDAL.setnonlineargeometriesenabledflag"><code>GDAL.setnonlineargeometriesenabledflag</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGRSetNonLinearGeometriesEnabledFlag(int bFlag) -&gt; void</code></pre><p>Set flag to enable/disable returning non-linear geometries in the C API.</p><p><strong>Parameters</strong></p><ul><li><strong>bFlag</strong>: TRUE if non-linear geometries might be returned (default value). FALSE to ask for non-linear geometries to be approximated as linear geometries.</li></ul><p><strong>Returns</strong></p><p>a point or NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnormprojparm" href="#GDAL.setnormprojparm"><code>GDAL.setnormprojparm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetNormProjParm(OGRSpatialReferenceH hSRS,
                   const char * pszParmName,
                   double dfValue) -&gt; OGRErr</code></pre><p>Set a projection parameter with a normalized value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnullable" href="#GDAL.setnullable"><code>GDAL.setnullable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetNullable(OGRFieldDefnH hDefn,
                    int bNullableIn) -&gt; void</code></pre><p>Set whether this field can receive null values.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li><li><strong>bNullableIn</strong>: FALSE if the field must have a not-null constraint.</li></ul></div></div><div><div><pre><code class="language-none">OGR_GFld_SetNullable(OGRGeomFieldDefnH hDefn,
                     int bNullableIn) -&gt; void</code></pre><p>Set whether this geometry field can receive null values.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition</li><li><strong>bNullableIn</strong>: FALSE if the field must have a not-null constraint.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setnzmg" href="#GDAL.setnzmg"><code>GDAL.setnzmg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetNZMG(OGRSpatialReferenceH hSRS,
           double dfCenterLat,
           double dfCenterLong,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>New Zealand Map Grid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setom" href="#GDAL.setom"><code>GDAL.setom</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetOM(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfAzimuth,
         double dfRectToSkew,
         double dfScale,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Oblique Mercator (aka HOM (variant B)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setorthographic" href="#GDAL.setorthographic"><code>GDAL.setorthographic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetOrthographic(OGRSpatialReferenceH hSRS,
                   double dfCenterLat,
                   double dfCenterLong,
                   double dfFalseEasting,
                   double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Orthographic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setos" href="#GDAL.setos"><code>GDAL.setos</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetOS(OGRSpatialReferenceH hSRS,
         double dfOriginLat,
         double dfCMeridian,
         double dfScale,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Oblique Stereographic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setparamdbl" href="#GDAL.setparamdbl"><code>GDAL.setparamdbl</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_SetParamDbl(OGRStyleToolH hST,
                   int eParam,
                   double dfValue) -&gt; void</code></pre><p>Set Style Tool parameter value from a double.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>dfValue</strong>: the new parameter value</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setparamnum" href="#GDAL.setparamnum"><code>GDAL.setparamnum</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_SetParamNum(OGRStyleToolH hST,
                   int eParam,
                   int nValue) -&gt; void</code></pre><p>Set Style Tool parameter value from an integer.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>nValue</strong>: the new parameter value</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setparamstr" href="#GDAL.setparamstr"><code>GDAL.setparamstr</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_SetParamStr(OGRStyleToolH hST,
                   int eParam,
                   const char * pszValue) -&gt; void</code></pre><p>Set Style Tool parameter value from a string.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eParam</strong>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations)</li><li><strong>pszValue</strong>: the new parameter value</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpoint" href="#GDAL.setpoint"><code>GDAL.setpoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPoint(OGRGeometryH hGeom,
               int i,
               double dfX,
               double dfY,
               double dfZ) -&gt; void</code></pre><p>Set the location of a vertex in a point or linestring geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a vertex to.</li><li><strong>i</strong>: the index of the vertex to assign (zero based) or zero for a point.</li><li><strong>dfX</strong>: input X coordinate to assign.</li><li><strong>dfY</strong>: input Y coordinate to assign.</li><li><strong>dfZ</strong>: input Z coordinate to assign (defaults to zero).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpoint_2d" href="#GDAL.setpoint_2d"><code>GDAL.setpoint_2d</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPoint_2D(OGRGeometryH hGeom,
                  int i,
                  double dfX,
                  double dfY) -&gt; void</code></pre><p>Set the location of a vertex in a point or linestring geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a vertex to.</li><li><strong>i</strong>: the index of the vertex to assign (zero based) or zero for a point.</li><li><strong>dfX</strong>: input X coordinate to assign.</li><li><strong>dfY</strong>: input Y coordinate to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpointcount" href="#GDAL.setpointcount"><code>GDAL.setpointcount</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPointCount(OGRGeometryH hGeom,
                    int nNewPointCount) -&gt; void</code></pre><p>Set number of points in a geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry.</li><li><strong>nNewPointCount</strong>: the new number of points for geometry.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpointm" href="#GDAL.setpointm"><code>GDAL.setpointm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPointM(OGRGeometryH hGeom,
                int i,
                double dfX,
                double dfY,
                double dfM) -&gt; void</code></pre><p>Set the location of a vertex in a point or linestring geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a vertex to.</li><li><strong>i</strong>: the index of the vertex to assign (zero based) or zero for a point.</li><li><strong>dfX</strong>: input X coordinate to assign.</li><li><strong>dfY</strong>: input Y coordinate to assign.</li><li><strong>dfM</strong>: input M coordinate to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpoints" href="#GDAL.setpoints"><code>GDAL.setpoints</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPoints(OGRGeometryH hGeom,
                int nPointsIn,
                void * pabyX,
                int nXStride,
                void * pabyY,
                int nYStride,
                void * pabyZ,
                int nZStride) -&gt; void</code></pre><p>Assign all points in a point or a line string geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to set the coordinates.</li><li><strong>nPointsIn</strong>: number of points being passed in padfX and padfY.</li><li><strong>pabyX</strong>: list of X coordinates (double values) of points being assigned.</li><li><strong>nXStride</strong>: the number of bytes between 2 elements of pabyX.</li><li><strong>pabyY</strong>: list of Y coordinates (double values) of points being assigned.</li><li><strong>nYStride</strong>: the number of bytes between 2 elements of pabyY.</li><li><strong>pabyZ</strong>: list of Z coordinates (double values) of points being assigned (defaults to NULL for 2D objects).</li><li><strong>nZStride</strong>: the number of bytes between 2 elements of pabyZ.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpointszm" href="#GDAL.setpointszm"><code>GDAL.setpointszm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPointsZM(OGRGeometryH hGeom,
                  int nPointsIn,
                  void * pabyX,
                  int nXStride,
                  void * pabyY,
                  int nYStride,
                  void * pabyZ,
                  int nZStride,
                  void * pabyM,
                  int nMStride) -&gt; void</code></pre><p>Assign all points in a point or a line string geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to set the coordinates.</li><li><strong>nPointsIn</strong>: number of points being passed in padfX and padfY.</li><li><strong>pabyX</strong>: list of X coordinates (double values) of points being assigned.</li><li><strong>nXStride</strong>: the number of bytes between 2 elements of pabyX.</li><li><strong>pabyY</strong>: list of Y coordinates (double values) of points being assigned.</li><li><strong>nYStride</strong>: the number of bytes between 2 elements of pabyY.</li><li><strong>pabyZ</strong>: list of Z coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have Z coordinate).</li><li><strong>nZStride</strong>: the number of bytes between 2 elements of pabyZ.</li><li><strong>pabyM</strong>: list of M coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have M coordinate).</li><li><strong>nMStride</strong>: the number of bytes between 2 elements of pabyM.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpointzm" href="#GDAL.setpointzm"><code>GDAL.setpointzm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SetPointZM(OGRGeometryH hGeom,
                 int i,
                 double dfX,
                 double dfY,
                 double dfZ,
                 double dfM) -&gt; void</code></pre><p>Set the location of a vertex in a point or linestring geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle to the geometry to add a vertex to.</li><li><strong>i</strong>: the index of the vertex to assign (zero based) or zero for a point.</li><li><strong>dfX</strong>: input X coordinate to assign.</li><li><strong>dfY</strong>: input Y coordinate to assign.</li><li><strong>dfZ</strong>: input Z coordinate to assign.</li><li><strong>dfM</strong>: input M coordinate to assign.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setpolyconic" href="#GDAL.setpolyconic"><code>GDAL.setpolyconic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetPolyconic(OGRSpatialReferenceH hSRS,
                double dfCenterLat,
                double dfCenterLong,
                double dfFalseEasting,
                double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Polyconic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setprecision" href="#GDAL.setprecision"><code>GDAL.setprecision</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetPrecision(OGRFieldDefnH hDefn,
                     int nPrecision) -&gt; void</code></pre><p>Set the formatting precision for this field in characters.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set precision to.</li><li><strong>nPrecision</strong>: the new precision.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setprojcs" href="#GDAL.setprojcs"><code>GDAL.setprojcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetProjCS(OGRSpatialReferenceH hSRS,
             const char * pszName) -&gt; OGRErr</code></pre><p>Set the user visible PROJCS name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setprojection" href="#GDAL.setprojection"><code>GDAL.setprojection</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetProjection(GDALDatasetH hDS,
                  const char * pszProjection) -&gt; CPLErr</code></pre><p>Set the projection reference string for this dataset.</p></div></div><div><div><pre><code class="language-none">OSRSetProjection(OGRSpatialReferenceH hSRS,
                 const char * pszProjection) -&gt; OGRErr</code></pre><p>Set a projection name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setprojparm" href="#GDAL.setprojparm"><code>GDAL.setprojparm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetProjParm(OGRSpatialReferenceH hSRS,
               const char * pszParmName,
               double dfValue) -&gt; OGRErr</code></pre><p>Set a projection parameter value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setps" href="#GDAL.setps"><code>GDAL.setps</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetPS(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfScale,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Polar Stereographic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setqsc" href="#GDAL.setqsc"><code>GDAL.setqsc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetQSC(OGRSpatialReferenceH hSRS,
          double dfCenterLat,
          double dfCenterLong) -&gt; OGRErr</code></pre><p>Quadrilateralized Spherical Cube.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrastercategorynames" href="#GDAL.setrastercategorynames"><code>GDAL.setrastercategorynames</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterCategoryNames(GDALRasterBandH hBand,
                           char ** papszNames) -&gt; CPLErr</code></pre><p>Set the category names for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrastercolorinterpretation" href="#GDAL.setrastercolorinterpretation"><code>GDAL.setrastercolorinterpretation</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterColorInterpretation(GDALRasterBandH hBand,
                                 GDALColorInterp eColorInterp) -&gt; CPLErr</code></pre><p>Set color interpretation of a band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrastercolortable" href="#GDAL.setrastercolortable"><code>GDAL.setrastercolortable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterColorTable(GDALRasterBandH hBand,
                        GDALColorTableH hCT) -&gt; CPLErr</code></pre><p>Set the raster color table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrasternodatavalue" href="#GDAL.setrasternodatavalue"><code>GDAL.setrasternodatavalue</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterNoDataValue(GDALRasterBandH hBand,
                         double dfValue) -&gt; CPLErr</code></pre><p>Set the no data value for this band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrasteroffset" href="#GDAL.setrasteroffset"><code>GDAL.setrasteroffset</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterOffset(GDALRasterBandH hBand,
                    double dfNewOffset) -&gt; CPLErr</code></pre><p>Set scaling offset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrasterscale" href="#GDAL.setrasterscale"><code>GDAL.setrasterscale</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterScale(GDALRasterBandH hBand,
                   double dfNewOffset) -&gt; CPLErr</code></pre><p>Set scaling ratio.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrasterstatistics" href="#GDAL.setrasterstatistics"><code>GDAL.setrasterstatistics</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterStatistics(GDALRasterBandH hBand,
                        double dfMin,
                        double dfMax,
                        double dfMean,
                        double dfStdDev) -&gt; CPLErr</code></pre><p>Set statistics on band.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrasterunittype" href="#GDAL.setrasterunittype"><code>GDAL.setrasterunittype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetRasterUnitType(GDALRasterBandH hBand,
                      const char * pszNewValue) -&gt; CPLErr</code></pre><p>Set unit type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setrobinson" href="#GDAL.setrobinson"><code>GDAL.setrobinson</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetRobinson(OGRSpatialReferenceH hSRS,
               double dfCenterLong,
               double dfFalseEasting,
               double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Robinson.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setsch" href="#GDAL.setsch"><code>GDAL.setsch</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetSCH(OGRSpatialReferenceH hSRS,
          double dfPegLat,
          double dfPegLong,
          double dfPegHeading,
          double dfPegHgt) -&gt; OGRErr</code></pre><p>Spherical, Cross-track, Height.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setsinusoidal" href="#GDAL.setsinusoidal"><code>GDAL.setsinusoidal</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetSinusoidal(OGRSpatialReferenceH hSRS,
                 double dfCenterLong,
                 double dfFalseEasting,
                 double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Sinusoidal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setsoc" href="#GDAL.setsoc"><code>GDAL.setsoc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetSOC(OGRSpatialReferenceH hSRS,
          double dfLatitudeOfOrigin,
          double dfCentralMeridian,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Swiss Oblique Cylindrical.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setspatialfilter" href="#GDAL.setspatialfilter"><code>GDAL.setspatialfilter</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetSpatialFilter(OGRLayerH,
                       OGRGeometryH) -&gt; void</code></pre><p>Set a new spatial filter.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which to set the spatial filter.</li><li><strong>hGeom</strong>: handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setspatialfilterex" href="#GDAL.setspatialfilterex"><code>GDAL.setspatialfilterex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetSpatialFilterEx(OGRLayerH,
                         int iGeomField,
                         OGRGeometryH hGeom) -&gt; void</code></pre><p>Set a new spatial filter.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which to set the spatial filter.</li><li><strong>iGeomField</strong>: index of the geometry field on which the spatial filter operates.</li><li><strong>hGeom</strong>: handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setspatialfilterrect" href="#GDAL.setspatialfilterrect"><code>GDAL.setspatialfilterrect</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetSpatialFilterRect(OGRLayerH,
                           double,
                           double,
                           double,
                           double) -&gt; void</code></pre><p>Set a new rectangular spatial filter.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which to set the spatial filter.</li><li><strong>dfMinX</strong>: the minimum X coordinate for the rectangular region.</li><li><strong>dfMinY</strong>: the minimum Y coordinate for the rectangular region.</li><li><strong>dfMaxX</strong>: the maximum X coordinate for the rectangular region.</li><li><strong>dfMaxY</strong>: the maximum Y coordinate for the rectangular region.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setspatialfilterrectex" href="#GDAL.setspatialfilterrectex"><code>GDAL.setspatialfilterrectex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SetSpatialFilterRectEx(OGRLayerH,
                             int iGeomField,
                             double dfMinX,
                             double dfMinY,
                             double dfMaxX,
                             double dfMaxY) -&gt; void</code></pre><p>Set a new rectangular spatial filter.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer on which to set the spatial filter.</li><li><strong>iGeomField</strong>: index of the geometry field on which the spatial filter operates.</li><li><strong>dfMinX</strong>: the minimum X coordinate for the rectangular region.</li><li><strong>dfMinY</strong>: the minimum Y coordinate for the rectangular region.</li><li><strong>dfMaxX</strong>: the maximum X coordinate for the rectangular region.</li><li><strong>dfMaxY</strong>: the maximum Y coordinate for the rectangular region.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setspatialref" href="#GDAL.setspatialref"><code>GDAL.setspatialref</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_GFld_SetSpatialRef(OGRGeomFieldDefnH hDefn,
                       OGRSpatialReferenceH hSRS) -&gt; void</code></pre><p>Set the spatial reference of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition</li><li><strong>hSRS</strong>: the new SRS to apply.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstateplane" href="#GDAL.setstateplane"><code>GDAL.setstateplane</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetStatePlane(OGRSpatialReferenceH hSRS,
                 int nZone,
                 int bNAD83) -&gt; OGRErr</code></pre><p>Set State Plane projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstateplanewithunits" href="#GDAL.setstateplanewithunits"><code>GDAL.setstateplanewithunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetStatePlaneWithUnits(OGRSpatialReferenceH hSRS,
                          int nZone,
                          int bNAD83,
                          const char * pszOverrideUnitName,
                          double dfOverrideUnit) -&gt; OGRErr</code></pre><p>Set State Plane projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstereographic" href="#GDAL.setstereographic"><code>GDAL.setstereographic</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetStereographic(OGRSpatialReferenceH hSRS,
                    double dfOriginLat,
                    double dfCMeridian,
                    double dfScale,
                    double dfFalseEasting,
                    double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Stereographic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstyleignored" href="#GDAL.setstyleignored"><code>GDAL.setstyleignored</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_FD_SetStyleIgnored(OGRFeatureDefnH hDefn,
                       int bIgnore) -&gt; void</code></pre><p>Set whether the style can be omitted when fetching features.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the feature definition on witch OGRFeature are based on.</li><li><strong>bIgnore</strong>: ignore state</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstylestring" href="#GDAL.setstylestring"><code>GDAL.setstylestring</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetStyleString(OGRFeatureH hFeat,
                     const char * pszStyle) -&gt; void</code></pre><p>Set feature style string.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to set style to.</li><li><strong>pszStyle</strong>: the style string to apply to this feature, cannot be NULL.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstylestringdirectly" href="#GDAL.setstylestringdirectly"><code>GDAL.setstylestringdirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetStyleStringDirectly(OGRFeatureH hFeat,
                             char * pszStyle) -&gt; void</code></pre><p>Set feature style string.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to set style to.</li><li><strong>pszStyle</strong>: the style string to apply to this feature, cannot be NULL.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstyletable" href="#GDAL.setstyletable"><code>GDAL.setstyletable</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetStyleTable(OGRFeatureH hFeat,
                    OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table.</p></div></div><div><div><pre><code class="language-none">OGR_L_SetStyleTable(OGRLayerH hLayer,
                    OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table.</p></div></div><div><div><pre><code class="language-none">OGR_DS_SetStyleTable(OGRDataSourceH hDS,
                     OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setstyletabledirectly" href="#GDAL.setstyletabledirectly"><code>GDAL.setstyletabledirectly</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_SetStyleTableDirectly(OGRFeatureH hFeat,
                            OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table and take ownership.</p></div></div><div><div><pre><code class="language-none">OGR_L_SetStyleTableDirectly(OGRLayerH hLayer,
                            OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table (and take ownership)</p></div></div><div><div><pre><code class="language-none">OGR_DS_SetStyleTableDirectly(OGRDataSourceH hDS,
                             OGRStyleTableH hStyleTable) -&gt; void</code></pre><p>Set style table (and take ownership)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setsubtype" href="#GDAL.setsubtype"><code>GDAL.setsubtype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetSubType(OGRFieldDefnH hDefn,
                   OGRFieldSubType eSubType) -&gt; void</code></pre><p>Set the subtype of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set type to.</li><li><strong>eSubType</strong>: the new field subtype.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settargetlinearunits" href="#GDAL.settargetlinearunits"><code>GDAL.settargetlinearunits</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTargetLinearUnits(OGRSpatialReferenceH hSRS,
                        const char * pszTargetKey,
                        const char * pszUnits,
                        double dfInMeters) -&gt; OGRErr</code></pre><p>Set the linear units for the target node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settm" href="#GDAL.settm"><code>GDAL.settm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTM(OGRSpatialReferenceH hSRS,
         double dfCenterLat,
         double dfCenterLong,
         double dfScale,
         double dfFalseEasting,
         double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Transverse Mercator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settmg" href="#GDAL.settmg"><code>GDAL.settmg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTMG(OGRSpatialReferenceH hSRS,
          double dfCenterLat,
          double dfCenterLong,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Tunesia Mining Grid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settmso" href="#GDAL.settmso"><code>GDAL.settmso</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTMSO(OGRSpatialReferenceH hSRS,
           double dfCenterLat,
           double dfCenterLong,
           double dfScale,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Transverse Mercator (South Oriented)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settmvariant" href="#GDAL.settmvariant"><code>GDAL.settmvariant</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTMVariant(OGRSpatialReferenceH hSRS,
                const char * pszVariantName,
                double dfCenterLat,
                double dfCenterLong,
                double dfScale,
                double dfFalseEasting,
                double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Transverse Mercator variant.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settowgs84" href="#GDAL.settowgs84"><code>GDAL.settowgs84</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTOWGS84(OGRSpatialReferenceH hSRS,
              double dfDX,
              double dfDY,
              double dfDZ,
              double dfEX,
              double dfEY,
              double dfEZ,
              double dfPPM) -&gt; OGRErr</code></pre><p>Set the Bursa-Wolf conversion to WGS84.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settped" href="#GDAL.settped"><code>GDAL.settped</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetTPED(OGRSpatialReferenceH hSRS,
           double dfLat1,
           double dfLong1,
           double dfLat2,
           double dfLong2,
           double dfFalseEasting,
           double dfFalseNorthing) -&gt; OGRErr</code></pre><p>TPED (Two Point Equi Distant)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settransformerdstgeotransform" href="#GDAL.settransformerdstgeotransform"><code>GDAL.settransformerdstgeotransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSetTransformerDstGeoTransform(void * pTransformArg,
                                  const double * padfGeoTransform) -&gt; void</code></pre><p>Set ApproxTransformer or GenImgProj output geotransform.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: the handle to update.</li><li><strong>padfGeoTransform</strong>: the destination geotransform to apply (six doubles).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.settype" href="#GDAL.settype"><code>GDAL.settype</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetType(OGRFieldDefnH hDefn,
                OGRFieldType eType) -&gt; void</code></pre><p>Set the type of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set type to.</li><li><strong>eType</strong>: the new field type.</li></ul></div></div><div><div><pre><code class="language-none">OGR_GFld_SetType(OGRGeomFieldDefnH hDefn,
                 OGRwkbGeometryType eType) -&gt; void</code></pre><p>Set the geometry type of this field.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the geometry field definition to set type to.</li><li><strong>eType</strong>: the new field geometry type.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setunit" href="#GDAL.setunit"><code>GDAL.setunit</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_SetUnit(OGRStyleToolH hST,
               OGRSTUnitId eUnit,
               double dfGroundPaperScale) -&gt; void</code></pre><p>Set Style Tool units.</p><p><strong>Parameters</strong></p><ul><li><strong>hST</strong>: handle to the style tool.</li><li><strong>eUnit</strong>: the new unit.</li><li><strong>dfGroundPaperScale</strong>: ground to paper scale factor.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setutm" href="#GDAL.setutm"><code>GDAL.setutm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetUTM(OGRSpatialReferenceH hSRS,
          int nZone,
          int bNorth) -&gt; OGRErr</code></pre><p>Set UTM projection definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setvdg" href="#GDAL.setvdg"><code>GDAL.setvdg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetVDG(OGRSpatialReferenceH hSRS,
          double dfCentralMeridian,
          double dfFalseEasting,
          double dfFalseNorthing) -&gt; OGRErr</code></pre><p>VanDerGrinten.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setvertcs" href="#GDAL.setvertcs"><code>GDAL.setvertcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetVertCS(OGRSpatialReferenceH hSRS,
             const char * pszVertCSName,
             const char * pszVertDatumName,
             int nVertDatumType) -&gt; OGRErr</code></pre><p>Setup the vertical coordinate system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setwagner" href="#GDAL.setwagner"><code>GDAL.setwagner</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetWagner(OGRSpatialReferenceH hSRS,
             int nVariation,
             double dfCenterLat,
             double dfFalseEasting,
             double dfFalseNorthing) -&gt; OGRErr</code></pre><p>Wagner I  VII.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setwellknowngeogcs" href="#GDAL.setwellknowngeogcs"><code>GDAL.setwellknowngeogcs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRSetWellKnownGeogCS(OGRSpatialReferenceH hSRS,
                      const char * pszName) -&gt; OGRErr</code></pre><p>Set a GeogCS based on well known name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.setwidth" href="#GDAL.setwidth"><code>GDAL.setwidth</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_Fld_SetWidth(OGRFieldDefnH hDefn,
                 int nNewWidth) -&gt; void</code></pre><p>Set the formatting width for this field in characters.</p><p><strong>Parameters</strong></p><ul><li><strong>hDefn</strong>: handle to the field definition to set width to.</li><li><strong>nNewWidth</strong>: the new width.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.sievefilter" href="#GDAL.sievefilter"><code>GDAL.sievefilter</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSieveFilter(GDALRasterBandH hSrcBand,
                GDALRasterBandH hMaskBand,
                GDALRasterBandH hDstBand,
                int nSizeThreshold,
                int nConnectedness,
                char ** papszOptions,
                GDALProgressFunc pfnProgress,
                void * pProgressArg) -&gt; CPLErr</code></pre><p>Removes small raster polygons.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcBand</strong>: the source raster band to be processed.</li><li><strong>hMaskBand</strong>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons.</li><li><strong>hDstBand</strong>: the output raster band. It may be the same as hSrcBand to update the source in place.</li><li><strong>nSizeThreshold</strong>: raster polygons with sizes smaller than this will be merged into their largest neighbour.</li><li><strong>nConnectedness</strong>: either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are.</li><li><strong>papszOptions</strong>: algorithm options in name=value list form. None currently supported.</li><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.simpleimagewarp" href="#GDAL.simpleimagewarp"><code>GDAL.simpleimagewarp</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSimpleImageWarp(GDALDatasetH hSrcDS,
                    GDALDatasetH hDstDS,
                    int nBandCount,
                    int * panBandList,
                    GDALTransformerFunc pfnTransform,
                    void * pTransformArg,
                    GDALProgressFunc pfnProgress,
                    void * pProgressArg,
                    char ** papszWarpOptions) -&gt; int</code></pre><p>Perform simple image warp.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: the source image dataset.</li><li><strong>hDstDS</strong>: the destination image dataset.</li><li><strong>nBandCount</strong>: the number of bands to be warped. If zero, all bands will be processed.</li><li><strong>panBandList</strong>: the list of bands to translate.</li><li><strong>pfnTransform</strong>: the transformation function to call. See GDALTransformerFunc().</li><li><strong>pTransformArg</strong>: the callback handle to pass to pfnTransform.</li><li><strong>pfnProgress</strong>: the function used to report progress. See GDALProgressFunc().</li><li><strong>pProgressArg</strong>: the callback handle to pass to pfnProgress.</li><li><strong>papszWarpOptions</strong>: additional options controlling the warp.</li></ul><p><strong>Returns</strong></p><p>TRUE if the operation completes, or FALSE if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.simplify" href="#GDAL.simplify"><code>GDAL.simplify</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Simplify(OGRGeometryH hThis,
               double dTolerance) -&gt; OGRGeometryH</code></pre><p>Compute a simplified geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>dTolerance</strong>: the distance tolerance for the simplification.</li></ul><p><strong>Returns</strong></p><p>the simplified geometry or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.simplifypreservetopology" href="#GDAL.simplifypreservetopology"><code>GDAL.simplifypreservetopology</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SimplifyPreserveTopology(OGRGeometryH hThis,
                               double dTolerance) -&gt; OGRGeometryH</code></pre><p>Simplify the geometry while preserving topology.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>dTolerance</strong>: the distance tolerance for the simplification.</li></ul><p><strong>Returns</strong></p><p>the simplified geometry or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.sm_create" href="#GDAL.sm_create"><code>GDAL.sm_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_SM_Create(OGRStyleTableH hStyleTable) -&gt; OGRStyleMgrH</code></pre><p>OGRStyleMgr factory.</p><p><strong>Parameters</strong></p><ul><li><strong>hStyleTable</strong>: pointer to OGRStyleTable or NULL if not working with a style table.</li></ul><p><strong>Returns</strong></p><p>an handle to the new style manager object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.st_create" href="#GDAL.st_create"><code>GDAL.st_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_ST_Create(OGRSTClassId eClassId) -&gt; OGRStyleToolH</code></pre><p>OGRStyleTool factory.</p><p><strong>Parameters</strong></p><ul><li><strong>eClassId</strong>: subclass of style tool to create. One of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).</li></ul><p><strong>Returns</strong></p><p>an handle to the new style tool object or NULL if the creation failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.starttransaction" href="#GDAL.starttransaction"><code>GDAL.starttransaction</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_StartTransaction(OGRLayerH) -&gt; OGRErr</code></pre><p>For datasources which support transactions, StartTransaction creates a transaction.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.stbl_create" href="#GDAL.stbl_create"><code>GDAL.stbl_create</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_STBL_Create(void) -&gt; OGRStyleTableH</code></pre><p>OGRStyleTable factory.</p><p><strong>Returns</strong></p><p>an handle to the new style table object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.stealgeometry" href="#GDAL.stealgeometry"><code>GDAL.stealgeometry</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_StealGeometry(OGRFeatureH hFeat) -&gt; OGRGeometryH</code></pre><p>Take away ownership of geometry.</p><p><strong>Returns</strong></p><p>the pointer to the geometry.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.stripctparms" href="#GDAL.stripctparms"><code>GDAL.stripctparms</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OSRStripCTParms(OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Strip OGC CT Parameters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.suggestedwarpoutput" href="#GDAL.suggestedwarpoutput"><code>GDAL.suggestedwarpoutput</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSuggestedWarpOutput(GDALDatasetH hSrcDS,
                        GDALTransformerFunc pfnTransformer,
                        void * pTransformArg,
                        double * padfGeoTransformOut,
                        int * pnPixels,
                        int * pnLines) -&gt; CPLErr</code></pre><p>Suggest output file size.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: the input image (it is assumed the whole input images is being transformed).</li><li><strong>pfnTransformer</strong>: the transformer function.</li><li><strong>pTransformArg</strong>: the callback data for the transformer function.</li><li><strong>padfGeoTransformOut</strong>: the array of six doubles in which the suggested geotransform is returned.</li><li><strong>pnPixels</strong>: int in which the suggest pixel width of output is returned.</li><li><strong>pnLines</strong>: int in which the suggest pixel height of output is returned.</li></ul><p><strong>Returns</strong></p><p>CE<em>None if successful or CE</em>Failure otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.suggestedwarpoutput2" href="#GDAL.suggestedwarpoutput2"><code>GDAL.suggestedwarpoutput2</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSuggestedWarpOutput2(GDALDatasetH hSrcDS,
                         GDALTransformerFunc pfnTransformer,
                         void * pTransformArg,
                         double * padfGeoTransformOut,
                         int * pnPixels,
                         int * pnLines,
                         double * padfExtent,
                         int nOptions) -&gt; CPLErr</code></pre><p>Suggest output file size.</p><p><strong>Parameters</strong></p><ul><li><strong>hSrcDS</strong>: the input image (it is assumed the whole input images is being transformed).</li><li><strong>pfnTransformer</strong>: the transformer function.</li><li><strong>pTransformArg</strong>: the callback data for the transformer function.</li><li><strong>padfGeoTransformOut</strong>: the array of six doubles in which the suggested geotransform is returned.</li><li><strong>pnPixels</strong>: int in which the suggest pixel width of output is returned.</li><li><strong>pnLines</strong>: int in which the suggest pixel height of output is returned.</li><li><strong>padfExtent</strong>: Four entry array to return extents as (xmin, ymin, xmax, ymax).</li><li><strong>nOptions</strong>: Options, currently always zero.</li></ul><p><strong>Returns</strong></p><p>CE<em>None if successful or CE</em>Failure otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.swapwords" href="#GDAL.swapwords"><code>GDAL.swapwords</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSwapWords(void * pData,
              int nWordSize,
              int nWordCount,
              int nWordSkip) -&gt; void</code></pre><p>Byte swap words in-place.</p><p><strong>Parameters</strong></p><ul><li><strong>pData</strong>: pointer to start of data buffer.</li><li><strong>nWordSize</strong>: size of words being swapped in bytes. Normally 2, 4 or 8.</li><li><strong>nWordCount</strong>: the number of words to be swapped in this call.</li><li><strong>nWordSkip</strong>: the byte offset from the start of one word to the start of the next. For packed buffers this is the same as nWordSize.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.swapwordsex" href="#GDAL.swapwordsex"><code>GDAL.swapwordsex</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALSwapWordsEx(void * pData,
                int nWordSize,
                size_t nWordCount,
                int nWordSkip) -&gt; void</code></pre><p>Byte swap words in-place.</p><p><strong>Parameters</strong></p><ul><li><strong>pData</strong>: pointer to start of data buffer.</li><li><strong>nWordSize</strong>: size of words being swapped in bytes. Normally 2, 4 or 8.</li><li><strong>nWordCount</strong>: the number of words to be swapped in this call.</li><li><strong>nWordSkip</strong>: the byte offset from the start of one word to the start of the next. For packed buffers this is the same as nWordSize.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.symdifference" href="#GDAL.symdifference"><code>GDAL.symdifference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SymDifference(OGRGeometryH hThis,
                    OGRGeometryH hOther) -&gt; OGRGeometryH</code></pre><p>Compute symmetric difference.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>hOther</strong>: the other geometry.</li></ul><p><strong>Returns</strong></p><p>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</p></div></div><div><div><pre><code class="language-none">OGR_L_SymDifference(OGRLayerH pLayerInput,
                    OGRLayerH pLayerMethod,
                    OGRLayerH pLayerResult,
                    char ** papszOptions,
                    GDALProgressFunc pfnProgress,
                    void * pProgressArg) -&gt; OGRErr</code></pre><p>Symmetrical difference of two layers.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.symmetricdifference" href="#GDAL.symmetricdifference"><code>GDAL.symmetricdifference</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_SymmetricDifference(OGRGeometryH hThis,
                          OGRGeometryH hOther) -&gt; OGRGeometryH</code></pre><p>Compute symmetric difference (deprecated)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.synctodisk" href="#GDAL.synctodisk"><code>GDAL.synctodisk</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_SyncToDisk(OGRLayerH) -&gt; OGRErr</code></pre><p>Flush pending changes to disk.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE if no error occurs (even if nothing is done) or an error code.</p></div></div><div><div><pre><code class="language-none">OGR_DS_SyncToDisk(OGRDataSourceH) -&gt; OGRErr</code></pre><p>Flush pending changes to disk.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.testcapability" href="#GDAL.testcapability"><code>GDAL.testcapability</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_TestCapability(OGRLayerH,
                     const char *) -&gt; int</code></pre><p>Test if this layer supported the named capability.</p><p><strong>Parameters</strong></p><ul><li><strong>hLayer</strong>: handle to the layer to get the capability from.</li><li><strong>pszCap</strong>: the name of the capability to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</p></div></div><div><div><pre><code class="language-none">OGR_DS_TestCapability(OGRDataSourceH,
                      const char *) -&gt; int</code></pre><p>Test if capability is available.</p><p><strong>Parameters</strong></p><ul><li><strong>hDS</strong>: handle to the data source against which to test the capability.</li><li><strong>pszCapability</strong>: the capability to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if capability available otherwise FALSE.</p></div></div><div><div><pre><code class="language-none">OGR_Dr_TestCapability(OGRSFDriverH,
                      const char *) -&gt; int</code></pre><p>Test if capability is available.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: handle to the driver to test the capability against.</li><li><strong>pszCap</strong>: the capability to test.</li></ul><p><strong>Returns</strong></p><p>TRUE if capability available otherwise FALSE.</p></div></div></section><pre><code class="language-none">GDAL.throw_class</code></pre><pre><code class="language-none">GDAL.time_t</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.touches" href="#GDAL.touches"><code>GDAL.touches</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Touches(OGRGeometryH hThis,
              OGRGeometryH hOther) -&gt; int</code></pre><p>Test for touching.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if they are touching, otherwise FALSE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.tpstransform" href="#GDAL.tpstransform"><code>GDAL.tpstransform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTPSTransform(void * pTransformArg,
                 int bDstToSrc,
                 int nPointCount,
                 double * x,
                 double * y,
                 double * z,
                 int * panSuccess) -&gt; int</code></pre><p>Transforms point based on GCP derived polynomial model.</p><p><strong>Parameters</strong></p><ul><li><strong>pTransformArg</strong>: return value from GDALCreateTPSTransformer().</li><li><strong>bDstToSrc</strong>: TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates.</li><li><strong>nPointCount</strong>: the number of values in the x, y and z arrays.</li><li><strong>x</strong>: array containing the X values to be transformed.</li><li><strong>y</strong>: array containing the Y values to be transformed.</li><li><strong>z</strong>: array containing the Z values to be transformed.</li><li><strong>panSuccess</strong>: array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</li></ul><p><strong>Returns</strong></p><p>TRUE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.transform" href="#GDAL.transform"><code>GDAL.transform</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Transform(OGRGeometryH hGeom,
                OGRCoordinateTransformationH hTransform) -&gt; OGRErr</code></pre><p>Apply arbitrary coordinate transformation to geometry.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to apply the transform to.</li><li><strong>hTransform</strong>: handle on the transformation to apply.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success or an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.transformgeolocations" href="#GDAL.transformgeolocations"><code>GDAL.transformgeolocations</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTransformGeolocations(GDALRasterBandH hXBand,
                          GDALRasterBandH hYBand,
                          GDALRasterBandH hZBand,
                          GDALTransformerFunc pfnTransformer,
                          void * pTransformArg,
                          GDALProgressFunc pfnProgress,
                          void * pProgressArg,
                          char ** papszOptions) -&gt; CPLErr</code></pre><p>Transform locations held in bands.</p><p><strong>Parameters</strong></p><ul><li><strong>hXBand</strong>: the band containing the X locations (usually long/easting).</li><li><strong>hYBand</strong>: the band containing the Y locations (usually lat/northing).</li><li><strong>hZBand</strong>: the band containing the Z locations (may be NULL).</li><li><strong>pfnTransformer</strong>: the transformer function.</li><li><strong>pTransformArg</strong>: the callback data for the transformer function.</li><li><strong>pfnProgress</strong>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL.</li><li><strong>pProgressArg</strong>: callback argument passed to pfnProgress.</li><li><strong>papszOptions</strong>: list of name/value options - none currently supported.</li></ul><p><strong>Returns</strong></p><p>CE<em>None on success or CE</em>Failure if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.transformto" href="#GDAL.transformto"><code>GDAL.transformto</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_TransformTo(OGRGeometryH hGeom,
                  OGRSpatialReferenceH hSRS) -&gt; OGRErr</code></pre><p>Transform geometry to new spatial reference system.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to apply the transform to.</li><li><strong>hSRS</strong>: handle on the spatial reference system to apply.</li></ul><p><strong>Returns</strong></p><p>OGRERR_NONE on success, or an error code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.translate" href="#GDAL.translate"><code>GDAL.translate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTranslate(const char * pszDest,
              GDALDatasetH hSrcDataset,
              const GDALTranslateOptions * psOptionsIn,
              int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Converts raster data between different formats.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path.</li><li><strong>hSrcDataset</strong>: the source dataset handle.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALTranslateOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred or NULL.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose()) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.translateoptionsfree" href="#GDAL.translateoptionsfree"><code>GDAL.translateoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTranslateOptionsFree(GDALTranslateOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALTranslateOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALTranslate().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.translateoptionsnew" href="#GDAL.translateoptionsnew"><code>GDAL.translateoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTranslateOptionsNew(char ** papszArgv,
                        GDALTranslateOptionsForBinary * psOptionsForBinary) -&gt; GDALTranslateOptions *</code></pre><p>Allocates a GDALTranslateOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdal_translate utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALTranslateOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALTranslateOptions struct. Must be freed with GDALTranslateOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.translateoptionssetprogress" href="#GDAL.translateoptionssetprogress"><code>GDAL.translateoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTranslateOptionsSetProgress(GDALTranslateOptions * psOptions,
                                GDALProgressFunc pfnProgress,
                                void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALTranslate().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationcomputebarycentriccoefficients" href="#GDAL.triangulationcomputebarycentriccoefficients"><code>GDAL.triangulationcomputebarycentriccoefficients</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationComputeBarycentricCoefficients(GDALTriangulation * psDT,
                                                const double * padfX,
                                                const double * padfY) -&gt; int</code></pre><p>Computes barycentric coefficients for each triangles of the triangulation.</p><p><strong>Parameters</strong></p><ul><li><strong>psDT</strong>: triangulation.</li><li><strong>padfX</strong>: x coordinates of the points. Must be identical to the one passed to GDALTriangulationCreateDelaunay().</li><li><strong>padfY</strong>: y coordinates of the points. Must be identical to the one passed to GDALTriangulationCreateDelaunay().</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationcomputebarycentriccoordinates" href="#GDAL.triangulationcomputebarycentriccoordinates"><code>GDAL.triangulationcomputebarycentriccoordinates</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationComputeBarycentricCoordinates(const GDALTriangulation * psDT,
                                               int nFacetIdx,
                                               double dfX,
                                               double dfY,
                                               double * pdfL1,
                                               double * pdfL2,
                                               double * pdfL3) -&gt; int</code></pre><p>Computes the barycentric coordinates of a point.</p><p><strong>Parameters</strong></p><ul><li><strong>psDT</strong>: triangulation.</li><li><strong>nFacetIdx</strong>: index of the triangle in the triangulation</li><li><strong>dfX</strong>: x coordinate of the point.</li><li><strong>dfY</strong>: y coordinate of the point.</li><li><strong>pdfL1</strong>: (output) pointer to the 1st barycentric coordinate.</li><li><strong>pdfL2</strong>: (output) pointer to the 2nd barycentric coordinate.</li><li><strong>pdfL3</strong>: (output) pointer to the 2nd barycentric coordinate.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationcreatedelaunay" href="#GDAL.triangulationcreatedelaunay"><code>GDAL.triangulationcreatedelaunay</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationCreateDelaunay(int nPoints,
                                const double * padfX,
                                const double * padfY) -&gt; GDALTriangulation *</code></pre><p>Computes a Delaunay triangulation of the passed points.</p><p><strong>Parameters</strong></p><ul><li><strong>nPoints</strong>: number of points</li><li><strong>padfX</strong>: x coordinates of the points.</li><li><strong>padfY</strong>: y coordinates of the points.</li></ul><p><strong>Returns</strong></p><p>triangulation that must be freed with GDALTriangulationFree(), or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationfindfacetbruteforce" href="#GDAL.triangulationfindfacetbruteforce"><code>GDAL.triangulationfindfacetbruteforce</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationFindFacetBruteForce(const GDALTriangulation * psDT,
                                     double dfX,
                                     double dfY,
                                     int * panOutputFacetIdx) -&gt; int</code></pre><p>Returns the index of the triangle that contains the point by iterating over all triangles.</p><p><strong>Parameters</strong></p><ul><li><strong>psDT</strong>: triangulation.</li><li><strong>dfX</strong>: x coordinate of the point.</li><li><strong>dfY</strong>: y coordinate of the point.</li><li><strong>panOutputFacetIdx</strong>: (output) pointer to the index of the triangle.</li></ul><p><strong>Returns</strong></p><p>index &gt;= 0 of the triangle in case of success, -1 otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationfindfacetdirected" href="#GDAL.triangulationfindfacetdirected"><code>GDAL.triangulationfindfacetdirected</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationFindFacetDirected(const GDALTriangulation * psDT,
                                   int nFacetIdx,
                                   double dfX,
                                   double dfY,
                                   int * panOutputFacetIdx) -&gt; int</code></pre><p>Returns the index of the triangle that contains the point by walking in the triangulation.</p><p><strong>Parameters</strong></p><ul><li><strong>psDT</strong>: triangulation.</li><li><strong>nFacetIdx</strong>: index of first triangle to start with.</li><li><strong>dfX</strong>: x coordinate of the point.</li><li><strong>dfY</strong>: y coordinate of the point.</li><li><strong>panOutputFacetIdx</strong>: (output) pointer to the index of the triangle.</li></ul><p><strong>Returns</strong></p><p>TRUE in case of success, -1 otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationfree" href="#GDAL.triangulationfree"><code>GDAL.triangulationfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationFree(GDALTriangulation * psDT) -&gt; void</code></pre><p>Free a triangulation.</p><p><strong>Parameters</strong></p><ul><li><strong>psDT</strong>: triangulation.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.triangulationterminate" href="#GDAL.triangulationterminate"><code>GDAL.triangulationterminate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALTriangulationTerminate() -&gt; void</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.turnfailureintowarning" href="#GDAL.turnfailureintowarning"><code>GDAL.turnfailureintowarning</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">CPLTurnFailureIntoWarning(int bOn) -&gt; void</code></pre><p>Whether failures should be turned into warnings.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.union" href="#GDAL.union"><code>GDAL.union</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Union(OGRGeometryH hThis,
            OGRGeometryH hOther) -&gt; OGRGeometryH</code></pre><p>Compute union.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li><li><strong>hOther</strong>: the other geometry.</li></ul><p><strong>Returns</strong></p><p>a new geometry representing the union or NULL if an error occurs.</p></div></div><div><div><pre><code class="language-none">OGR_L_Union(OGRLayerH pLayerInput,
            OGRLayerH pLayerMethod,
            OGRLayerH pLayerResult,
            char ** papszOptions,
            GDALProgressFunc pfnProgress,
            void * pProgressArg) -&gt; OGRErr</code></pre><p>Union of two layers.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.unioncascaded" href="#GDAL.unioncascaded"><code>GDAL.unioncascaded</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_UnionCascaded(OGRGeometryH hThis) -&gt; OGRGeometryH</code></pre><p>Compute union using cascading.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry.</li></ul><p><strong>Returns</strong></p><p>a new geometry representing the union or NULL if an error occurs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.unsafe_loadstringlist" href="#GDAL.unsafe_loadstringlist"><code>GDAL.unsafe_loadstringlist</code></a> â <span class="docstring-category">Function</span>.</div><div><div><p>Load a null-terminated list of strings</p><p>That is it expects a <code>StringList</code>, in the sense of the CPL functions, as a null-terminated array of strings.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.unsetfield" href="#GDAL.unsetfield"><code>GDAL.unsetfield</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_UnsetField(OGRFeatureH hFeat,
                 int iField) -&gt; void</code></pre><p>Clear a field, marking it as unset.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature on which the field is.</li><li><strong>iField</strong>: the field to unset.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.update" href="#GDAL.update"><code>GDAL.update</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_L_Update(OGRLayerH pLayerInput,
             OGRLayerH pLayerMethod,
             OGRLayerH pLayerResult,
             char ** papszOptions,
             GDALProgressFunc pfnProgress,
             void * pProgressArg) -&gt; OGRErr</code></pre><p>Update this layer with features from the update layer.</p><p><strong>Parameters</strong></p><ul><li><strong>pLayerInput</strong>: the input layer. Should not be NULL.</li><li><strong>pLayerMethod</strong>: the method layer. Should not be NULL.</li><li><strong>pLayerResult</strong>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</li><li><strong>papszOptions</strong>: NULL terminated list of options (may be NULL).</li><li><strong>pfnProgress</strong>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</li><li><strong>pProgressArg</strong>: argument to be passed to pfnProgress. May be NULL.</li></ul><p><strong>Returns</strong></p><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.usetransformer" href="#GDAL.usetransformer"><code>GDAL.usetransformer</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALUseTransformer(void * pTransformArg,
                   int bDstToSrc,
                   int nPointCount,
                   double * x,
                   double * y,
                   double * z,
                   int * panSuccess) -&gt; int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.validate" href="#GDAL.validate"><code>GDAL.validate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_F_Validate(OGRFeatureH hFeat,
               int nValidateFlags,
               int bEmitError) -&gt; int</code></pre><p>Validate that a feature meets constraints of its schema.</p><p><strong>Parameters</strong></p><ul><li><strong>hFeat</strong>: handle to the feature to validate.</li><li><strong>nValidateFlags</strong>: OGR<em>F</em>VAL<em>ALL or combination of OGR</em>F<em>VAL</em>NULL, OGR<em>F</em>VAL<em>GEOM</em>TYPE, OGR<em>F</em>VAL<em>WIDTH and OGR</em>F<em>VAL</em>ALLOW<em>NULL</em>WHEN_DEFAULT with &#39;|&#39; operator</li><li><strong>bEmitError</strong>: TRUE if a CPLError() must be emitted when a check fails</li></ul><p><strong>Returns</strong></p><p>TRUE if all enabled validation tests pass.</p></div></div><div><div><pre><code class="language-none">OSRValidate(OGRSpatialReferenceH) -&gt; OGRErr</code></pre><p>Validate SRS tokens.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.validatecreationoptions" href="#GDAL.validatecreationoptions"><code>GDAL.validatecreationoptions</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALValidateCreationOptions(GDALDriverH hDriver,
                            char ** papszCreationOptions) -&gt; int</code></pre><p>Validate the list of creation options that are handled by a driver.</p><p><strong>Parameters</strong></p><ul><li><strong>hDriver</strong>: the handle of the driver with whom the lists of creation option must be validated</li><li><strong>papszCreationOptions</strong>: the list of creation options. An array of strings, whose last element is a NULL pointer</li></ul><p><strong>Returns</strong></p><p>TRUE if the list of creation options is compatible with the Create() and CreateCopy() method of the driver, FALSE otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.value" href="#GDAL.value"><code>GDAL.value</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Value(OGRGeometryH hGeom,
            double dfDistance) -&gt; OGRGeometryH</code></pre><p>Fetch point at given distance along curve.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: curve geometry.</li><li><strong>dfDistance</strong>: distance along the curve at which to sample position. This distance should be between zero and get_Length() for this curve.</li></ul><p><strong>Returns</strong></p><p>a point or NULL.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vectortranslate" href="#GDAL.vectortranslate"><code>GDAL.vectortranslate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALVectorTranslate(const char * pszDest,
                    GDALDatasetH hDstDS,
                    int nSrcCount,
                    GDALDatasetH * pahSrcDS,
                    const GDALVectorTranslateOptions * psOptions,
                    int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Converts vector data between file formats.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path or NULL.</li><li><strong>hDstDS</strong>: the destination dataset or NULL.</li><li><strong>nSrcCount</strong>: the number of input datasets (only 1 supported currently)</li><li><strong>pahSrcDS</strong>: the list of input datasets.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALVectorTranslateOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose(), or hDstDS is not NULL) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vectortranslateoptionsfree" href="#GDAL.vectortranslateoptionsfree"><code>GDAL.vectortranslateoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALVectorTranslateOptionsFree(GDALVectorTranslateOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALVectorTranslateOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALVectorTranslate().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vectortranslateoptionsnew" href="#GDAL.vectortranslateoptionsnew"><code>GDAL.vectortranslateoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALVectorTranslateOptionsNew(char ** papszArgv,
                              GDALVectorTranslateOptionsForBinary * psOptionsForBinary) -&gt; GDALVectorTranslateOptions *</code></pre><p>allocates a GDALVectorTranslateOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the ogr2ogr utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALVectorTranslateOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALVectorTranslateOptions struct. Must be freed with GDALVectorTranslateOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vectortranslateoptionssetprogress" href="#GDAL.vectortranslateoptionssetprogress"><code>GDAL.vectortranslateoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALVectorTranslateOptionsSetProgress(GDALVectorTranslateOptions * psOptions,
                                      GDALProgressFunc pfnProgress,
                                      void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALVectorTranslate().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtaddband" href="#GDAL.vrtaddband"><code>GDAL.vrtaddband</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTAddBand(VRTDatasetH,
           GDALDataType,
           char **) -&gt; int</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtaddcomplexsource" href="#GDAL.vrtaddcomplexsource"><code>GDAL.vrtaddcomplexsource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTAddComplexSource(VRTSourcedRasterBandH,
                    GDALRasterBandH,
                    int,
                    int,
                    int,
                    int,
                    int,
                    int,
                    int,
                    int,
                    double,
                    double,
                    double) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtaddfuncsource" href="#GDAL.vrtaddfuncsource"><code>GDAL.vrtaddfuncsource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTAddFuncSource(VRTSourcedRasterBandH,
                 VRTImageReadFunc,
                 void *,
                 double) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtaddsimplesource" href="#GDAL.vrtaddsimplesource"><code>GDAL.vrtaddsimplesource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTAddSimpleSource(VRTSourcedRasterBandH,
                   GDALRasterBandH,
                   int,
                   int,
                   int,
                   int,
                   int,
                   int,
                   int,
                   int,
                   const char *,
                   double) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtaddsource" href="#GDAL.vrtaddsource"><code>GDAL.vrtaddsource</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTAddSource(VRTSourcedRasterBandH,
             VRTSourceH) -&gt; CPLErr</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtcreate" href="#GDAL.vrtcreate"><code>GDAL.vrtcreate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTCreate(int,
          int) -&gt; VRTDatasetH</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtflushcache" href="#GDAL.vrtflushcache"><code>GDAL.vrtflushcache</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTFlushCache(VRTDatasetH) -&gt; void</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.vrtserializetoxml" href="#GDAL.vrtserializetoxml"><code>GDAL.vrtserializetoxml</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">VRTSerializeToXML(VRTDatasetH,
                  const char *) -&gt; CPLXMLNode *</code></pre></div></div></section><pre><code class="language-none">GDAL.vsi_l_offset</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.warp" href="#GDAL.warp"><code>GDAL.warp</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWarp(const char * pszDest,
         GDALDatasetH hDstDS,
         int nSrcCount,
         GDALDatasetH * pahSrcDS,
         const GDALWarpAppOptions * psOptionsIn,
         int * pbUsageError) -&gt; GDALDatasetH</code></pre><p>Image reprojection and warping function.</p><p><strong>Parameters</strong></p><ul><li><strong>pszDest</strong>: the destination dataset path or NULL.</li><li><strong>hDstDS</strong>: the destination dataset or NULL.</li><li><strong>nSrcCount</strong>: the number of input datasets.</li><li><strong>pahSrcDS</strong>: the list of input datasets.</li><li><strong>psOptionsIn</strong>: the options struct returned by GDALWarpAppOptionsNew() or NULL.</li><li><strong>pbUsageError</strong>: the pointer to int variable to determine any usage error has occurred.</li></ul><p><strong>Returns</strong></p><p>the output dataset (new dataset that must be closed using GDALClose(), or hDstDS if not NULL) or NULL in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.warpappoptionsfree" href="#GDAL.warpappoptionsfree"><code>GDAL.warpappoptionsfree</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWarpAppOptionsFree(GDALWarpAppOptions * psOptions) -&gt; void</code></pre><p>Frees the GDALWarpAppOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALWarp().</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.warpappoptionsnew" href="#GDAL.warpappoptionsnew"><code>GDAL.warpappoptionsnew</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWarpAppOptionsNew(char ** papszArgv,
                      GDALWarpAppOptionsForBinary * psOptionsForBinary) -&gt; GDALWarpAppOptions *</code></pre><p>Allocates a GDALWarpAppOptions struct.</p><p><strong>Parameters</strong></p><ul><li><strong>papszArgv</strong>: NULL terminated list of options (potentially including filename and open options too), or NULL. The accepted options are the ones of the gdalwarp utility.</li><li><strong>psOptionsForBinary</strong>: (output) may be NULL (and should generally be NULL), otherwise (gdal<em>translate</em>bin.cpp use case) must be allocated with GDALWarpAppOptionsForBinaryNew() prior to this function. Will be filled with potentially present filename, open options,...</li></ul><p><strong>Returns</strong></p><p>pointer to the allocated GDALWarpAppOptions struct. Must be freed with GDALWarpAppOptionsFree().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.warpappoptionssetprogress" href="#GDAL.warpappoptionssetprogress"><code>GDAL.warpappoptionssetprogress</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWarpAppOptionsSetProgress(GDALWarpAppOptions * psOptions,
                              GDALProgressFunc pfnProgress,
                              void * pProgressData) -&gt; void</code></pre><p>Set a progress function.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALWarpApp().</li><li><strong>pfnProgress</strong>: the progress callback.</li><li><strong>pProgressData</strong>: the user data for the progress callback.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.warpappoptionssetwarpoption" href="#GDAL.warpappoptionssetwarpoption"><code>GDAL.warpappoptionssetwarpoption</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWarpAppOptionsSetWarpOption(GDALWarpAppOptions * psOptions,
                                const char * pszKey,
                                const char * pszValue) -&gt; void</code></pre><p>Set a warp option.</p><p><strong>Parameters</strong></p><ul><li><strong>psOptions</strong>: the options struct for GDALWarpApp().</li><li><strong>pszKey</strong>: key.</li><li><strong>pszValue</strong>: value.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.within" href="#GDAL.within"><code>GDAL.within</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_Within(OGRGeometryH hThis,
             OGRGeometryH hOther) -&gt; int</code></pre><p>Test for containment.</p><p><strong>Parameters</strong></p><ul><li><strong>hThis</strong>: the geometry to compare.</li><li><strong>hOther</strong>: the other geometry to compare.</li></ul><p><strong>Returns</strong></p><p>TRUE if hThis is within hOther, otherwise FALSE.</p></div></div></section><pre><code class="language-none">GDAL.wkb25DBit</code></pre><pre><code class="language-none">GDAL.wkbCircularString</code></pre><pre><code class="language-none">GDAL.wkbCircularStringM</code></pre><pre><code class="language-none">GDAL.wkbCircularStringZ</code></pre><pre><code class="language-none">GDAL.wkbCircularStringZM</code></pre><pre><code class="language-none">GDAL.wkbCompoundCurve</code></pre><pre><code class="language-none">GDAL.wkbCompoundCurveM</code></pre><pre><code class="language-none">GDAL.wkbCompoundCurveZ</code></pre><pre><code class="language-none">GDAL.wkbCompoundCurveZM</code></pre><pre><code class="language-none">GDAL.wkbCurve</code></pre><pre><code class="language-none">GDAL.wkbCurveM</code></pre><pre><code class="language-none">GDAL.wkbCurvePolygon</code></pre><pre><code class="language-none">GDAL.wkbCurvePolygonM</code></pre><pre><code class="language-none">GDAL.wkbCurvePolygonZ</code></pre><pre><code class="language-none">GDAL.wkbCurvePolygonZM</code></pre><pre><code class="language-none">GDAL.wkbCurveZ</code></pre><pre><code class="language-none">GDAL.wkbCurveZM</code></pre><pre><code class="language-none">GDAL.wkbGeometryCollection</code></pre><pre><code class="language-none">GDAL.wkbGeometryCollection25D</code></pre><pre><code class="language-none">GDAL.wkbGeometryCollectionM</code></pre><pre><code class="language-none">GDAL.wkbGeometryCollectionZM</code></pre><pre><code class="language-none">GDAL.wkbLineString</code></pre><pre><code class="language-none">GDAL.wkbLineString25D</code></pre><pre><code class="language-none">GDAL.wkbLineStringM</code></pre><pre><code class="language-none">GDAL.wkbLineStringZM</code></pre><pre><code class="language-none">GDAL.wkbLinearRing</code></pre><pre><code class="language-none">GDAL.wkbMultiCurve</code></pre><pre><code class="language-none">GDAL.wkbMultiCurveM</code></pre><pre><code class="language-none">GDAL.wkbMultiCurveZ</code></pre><pre><code class="language-none">GDAL.wkbMultiCurveZM</code></pre><pre><code class="language-none">GDAL.wkbMultiLineString</code></pre><pre><code class="language-none">GDAL.wkbMultiLineString25D</code></pre><pre><code class="language-none">GDAL.wkbMultiLineStringM</code></pre><pre><code class="language-none">GDAL.wkbMultiLineStringZM</code></pre><pre><code class="language-none">GDAL.wkbMultiPoint</code></pre><pre><code class="language-none">GDAL.wkbMultiPoint25D</code></pre><pre><code class="language-none">GDAL.wkbMultiPointM</code></pre><pre><code class="language-none">GDAL.wkbMultiPointZM</code></pre><pre><code class="language-none">GDAL.wkbMultiPolygon</code></pre><pre><code class="language-none">GDAL.wkbMultiPolygon25D</code></pre><pre><code class="language-none">GDAL.wkbMultiPolygonM</code></pre><pre><code class="language-none">GDAL.wkbMultiPolygonZM</code></pre><pre><code class="language-none">GDAL.wkbMultiSurface</code></pre><pre><code class="language-none">GDAL.wkbMultiSurfaceM</code></pre><pre><code class="language-none">GDAL.wkbMultiSurfaceZ</code></pre><pre><code class="language-none">GDAL.wkbMultiSurfaceZM</code></pre><pre><code class="language-none">GDAL.wkbNDR</code></pre><pre><code class="language-none">GDAL.wkbNone</code></pre><pre><code class="language-none">GDAL.wkbPoint</code></pre><pre><code class="language-none">GDAL.wkbPoint25D</code></pre><pre><code class="language-none">GDAL.wkbPointM</code></pre><pre><code class="language-none">GDAL.wkbPointZM</code></pre><pre><code class="language-none">GDAL.wkbPolygon</code></pre><pre><code class="language-none">GDAL.wkbPolygon25D</code></pre><pre><code class="language-none">GDAL.wkbPolygonM</code></pre><pre><code class="language-none">GDAL.wkbPolygonZM</code></pre><pre><code class="language-none">GDAL.wkbPolyhedralSurface</code></pre><pre><code class="language-none">GDAL.wkbPolyhedralSurfaceM</code></pre><pre><code class="language-none">GDAL.wkbPolyhedralSurfaceZ</code></pre><pre><code class="language-none">GDAL.wkbPolyhedralSurfaceZM</code></pre><pre><code class="language-none">GDAL.wkbSurface</code></pre><pre><code class="language-none">GDAL.wkbSurfaceM</code></pre><pre><code class="language-none">GDAL.wkbSurfaceZ</code></pre><pre><code class="language-none">GDAL.wkbSurfaceZM</code></pre><pre><code class="language-none">GDAL.wkbTIN</code></pre><pre><code class="language-none">GDAL.wkbTINM</code></pre><pre><code class="language-none">GDAL.wkbTINZ</code></pre><pre><code class="language-none">GDAL.wkbTINZM</code></pre><pre><code class="language-none">GDAL.wkbTriangle</code></pre><pre><code class="language-none">GDAL.wkbTriangleM</code></pre><pre><code class="language-none">GDAL.wkbTriangleZ</code></pre><pre><code class="language-none">GDAL.wkbTriangleZM</code></pre><pre><code class="language-none">GDAL.wkbUnknown</code></pre><pre><code class="language-none">GDAL.wkbVariantIso</code></pre><pre><code class="language-none">GDAL.wkbVariantOldOgc</code></pre><pre><code class="language-none">GDAL.wkbVariantPostGIS1</code></pre><pre><code class="language-none">GDAL.wkbXDR</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.wkbsize" href="#GDAL.wkbsize"><code>GDAL.wkbsize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">OGR_G_WkbSize(OGRGeometryH hGeom) -&gt; int</code></pre><p>Returns size of related binary representation.</p><p><strong>Parameters</strong></p><ul><li><strong>hGeom</strong>: handle on the geometry to get the binary size from.</li></ul><p><strong>Returns</strong></p><p>size of binary representation in bytes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.writeblock" href="#GDAL.writeblock"><code>GDAL.writeblock</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWriteBlock(GDALRasterBandH hBand,
               int nXOff,
               int nYOff,
               void * pData) -&gt; CPLErr</code></pre><p>Write a block of image data efficiently.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GDAL.writeworldfile" href="#GDAL.writeworldfile"><code>GDAL.writeworldfile</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">GDALWriteWorldFile(const char *,
                   const char *,
                   double *) -&gt; int</code></pre><p>Write ESRI world file.</p><p><strong>Parameters</strong></p><ul><li><strong>pszBaseFilename</strong>: the target raster file.</li><li><strong>pszExtension</strong>: the extension to use (i.e. &quot;.wld&quot;). Must not be NULL</li><li><strong>padfGeoTransform</strong>: the six double array from which the geotransformation should be read.</li></ul><p><strong>Returns</strong></p><p>TRUE on success or FALSE on failure.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
