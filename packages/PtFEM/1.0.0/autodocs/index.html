<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · PtFEM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PtFEM.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Beam" href="#PtFEM.Beam"><code>PtFEM.Beam</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Beam</strong></p><p>Concrete structural element with transverse and moment loading.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Beam(ndim, nst, nxe, nip, direction, fin_el, axisymmetric)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nxe::Int              : Number of different property types
* nip::Int              : Number of integration points
* direction::Symbol     : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)
* axisymmetric::Bool    : Axisymmetric if true</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement      : Help on structural elements
?FiniteElement          : Help on finite element types
?Line                   : Help on a Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.FEM" href="#PtFEM.FEM"><code>PtFEM.FEM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>FEM</strong></p><p>Computational structure used in chapter 5 (Skyline format used)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.FiniteElement" href="#PtFEM.FiniteElement"><code>PtFEM.FiniteElement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>FiniteElement</strong></p><p>Abstract finite element type.</p><p><strong>Type</strong></p><pre><code class="language-julia">abstract type FiniteElement end</code></pre><p><strong>Subtypes</strong></p><pre><code class="language-julia">* Line::FiniteElement          : 1D Line(nod, nodof)
* Triangle::FiniteElement      : 2D Triangle(nod, nodof)
* Quadrilateral::FiniteElement : 2D Quadrilateral(nod, nodof)
* Hexahedron::FiniteElement    : 3D Hexahedron(nod, nodof)
* Tetrahedron::FiniteElement   : 3D Tetrahedron(nod, nodof)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Frame" href="#PtFEM.Frame"><code>PtFEM.Frame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Frame</strong></p><p>Pin- or rigid-jointed structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Frame(nels, nn, ndim, finite_element(nod, nodof))</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nels::Int             : Number of elements
* nn:Int                : Number of nodes
* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types
?Line               : Help on a Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.GenericSolid" href="#PtFEM.GenericSolid"><code>PtFEM.GenericSolid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>GenericSolid</strong></p><p>Solid structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">GenericSolid(ndim, nst, nels, nn, nip, finite_element(nod, nodof), axisymmetric)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int               : Number of dimensions
* nst::Int                : Number of stress terms
* nels::Int               : Number of finite elements
* nn::Int                 : Number of nodes
* nip::Int                : Number of integration points
* fin_el::FiniteElement   : Finite element type used
* axisymmetric::Bool      : Axisymmetric</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Hexahedron" href="#PtFEM.Hexahedron"><code>PtFEM.Hexahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>hexahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Hexahedron(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (8, 14, 20)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Line" href="#PtFEM.Line"><code>PtFEM.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Line (Interval)</strong></p><p>1D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Line(nod, nodof)
Line(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element, defaults to 2
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div></div></section><pre><code class="language-none">PtFEM.OffsetArray</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Plane" href="#PtFEM.Plane"><code>PtFEM.Plane</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Plane</strong></p><p>Plate structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Plane(ndim, nst, nxe, nye, nip, dir, finite_element(nod, nodof), axisymmetric)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int               : Number of dimensions
* nst::Int                : Number of stress terms
* nxe::Int                : Number of elements in x direction
* nye::Int                : Number of elements in y direction
* nip::Int                : Number of integration points
* dir::Symbol             : Direction of node numbering
* fin_el::FiniteElement   : Line(nod, nodof)
* axisymmetric::Bool      : Axisymmetric</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types
?Line               : Help on a Line finite element</code></pre></div></div></section><pre><code class="language-none">PtFEM.PtFEM</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Quadrilateral" href="#PtFEM.Quadrilateral"><code>PtFEM.Quadrilateral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Quadrilateral</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Quadrilateral(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (4, 8, 9)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Rod" href="#PtFEM.Rod"><code>PtFEM.Rod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Rod</strong></p><p>Concrete 1D structural element with only axial stresses.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Rod(nels, np_types, nip, fin_el)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nels::Int             : Number of fin_els (stored in field nxe)
* np_types::Int         : Number of different property types
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement      : Help on structural elements
?FiniteElement          : Help on finite element types
?Line                   : Help on a Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Solid" href="#PtFEM.Solid"><code>PtFEM.Solid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Solid</strong></p><p>Solid structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Solid(ndim, nst, nxe, nye, nze, nip, finite_element(nod, nodof))</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nxe::Int              : Number of elements in x direction
* nye::Int              : Number of elements in y direction
* nze::Int              : Number of elements in z direction
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.StructuralElement" href="#PtFEM.StructuralElement"><code>PtFEM.StructuralElement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>StructuralElement</strong></p><p>Abstract structural element type.</p><p><strong>Type</strong></p><pre><code class="language-julia">abstract type StructuralElement end</code></pre><p><strong>Subtypes</strong></p><pre><code class="language-julia">* Rod::StructuralElement          : Rod(nxe, np_types, nip, fin_el)
* Beam::StructuralElement         : Beam(nod, nodof)
* Frame::StructuralElement        : Frame(nod, nodof)
* Plane::StructuralElement        : Plane(nod, nodof)
* Solid::StructuralElement        : Solid(nod, nodof)
* GenericSolid::StructuralElement : GenericSolid(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement                    : Show all finite elements
?Rod                              : Help on Rod structural element
?Beam                             : Help on Beam structural element
?Frame                            : Help on Frame structural element
?Plane                            : Help on Plane structural element
?Solid                            : Help on Solid structural element
?GenericSolid                     : Help on GenericSolid structural element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Tetrahedron" href="#PtFEM.Tetrahedron"><code>PtFEM.Tetrahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Tetrahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Tetrahedron(nod, nodof)
Tetrahedron(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (defaults to 4)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Triangle" href="#PtFEM.Triangle"><code>PtFEM.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Triangle</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Triangle(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (3, 6, 10, 15)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div></div></section><pre><code class="language-none">PtFEM.UnknownStructuralElement</code></pre><pre><code class="language-none">PtFEM.bc_rect!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_gm" href="#PtFEM.beam_gm"><code>PtFEM.beam_gm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>beam_gm</strong></p><p>This subroutine forms the beam geometric matrix for stability analysis.</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_gm(ell::Float64)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ell::Float64                   : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* gm::::Matrix{Float64}(4,4)     : Geometric matrix for beam element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_km" href="#PtFEM.beam_km"><code>PtFEM.beam_km</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>beam_km</strong></p><p>This subroutine forms the stiffness matrix of a beam element (bending only).</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_km(ei, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ei::Float64               : Element stiffness
* ell::Float64              : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* km::::Matrix{Float64}     : Stiiness matrix for beam element (Updated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_mm" href="#PtFEM.beam_mm"><code>PtFEM.beam_mm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>beam_mm</strong></p><p>This subroutine forms the stiffness matrix of a beam element (bending only).</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_mm(ei, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fs::Float64               : Element density
* ell::Float64              : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* mm::::Matrix{Float64}     : Mass matrix for beam elembeam_mmated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beemat!" href="#PtFEM.beemat!"><code>PtFEM.beemat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>beemat!</strong></p><p>This subroutine forms the strain-displacement matrix for axisymmetric solids subjected to non-axisymmetric loading.</p><p><strong>Method</strong></p><pre><code class="language-julia">beemat!(bee, deriv)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* bee::Matrix{Float64}         : Bee matrix (Updated)
* deriv::Matrix{Float64}       : Derivative</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.bmat_nonaxi!" href="#PtFEM.bmat_nonaxi!"><code>PtFEM.bmat_nonaxi!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>bmat_nonaxi!</strong></p><p>This subroutine forms the strain-displacement matrix for axisymmetric solids subjected to non-axisymmetric loading.</p><p><strong>Method</strong></p><pre><code class="language-julia">bmat_nonaxi!(bee, radius, coord, deriv, fun, iflag, lth)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* bee::Matrix{Float64}         : Bee matrix (Updated)
* radius::Float64              : r coordinate of the Gauss point
* coord::Matrix{Float64}       : Nodal coordinate matrix
* deriv::Matrix{Float64}       : Derivative
* fun::Vector{Float64}         : Shape function
* iflag::Int                 : 1 = symmetric, -1 = anti-symmetric
* lth::Int                   : Harmonic</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.checon" href="#PtFEM.checon"><code>PtFEM.checon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>checon</strong></p><p>This subroutine sets converged to .FALSE. if relative change in loads and oldlds is greater than tol and updates oldlds.</p><p><strong>Method</strong></p><pre><code class="language-julia">checon(loads, oldlds, tol)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loads::Vector{Float64}        : Displacements vector/OffsetArray
* oldlds::Vector{Float64}       : Previous displacement vector/OffsetArray
* tol::Float64                  : Convergence tolerance</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* ::Bool                        : Convergence achieved</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.deemat!" href="#PtFEM.deemat!"><code>PtFEM.deemat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>deemat!</strong></p><p>This subroutine returns the elastic dee matrix for ih=3 (plane strain), ih=4 (axisymmetry or plane strain elastoplasticity) or ih=6 (three dimensions).</p><p><strong>Method</strong></p><pre><code class="language-julia">deemat!(dee, e, v)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* dee::Matrix{Float64}         : Dee matrix (Updated)
* e::Float64                   : Young&#39;s modulus
* v::Float64                   : Poisson&#39;s ratio</code></pre></div></div></section><pre><code class="language-none">PtFEM.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fkdiag!" href="#PtFEM.fkdiag!"><code>PtFEM.fkdiag!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>fkdiag!</strong></p><p>This subroutine returns the elastic dee matrix for ih=3 (plane strain), ih=4 (axisymmetry or plane strain elastoplasticity) or ih=6 (three dimensions).</p><p><strong>Method</strong></p><pre><code class="language-julia">fkdiag!(kdiag, g)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kdiag::Vector{Int}      : Bandwidth vector (Updated)
* g::Vector{Int}          : Element steering vector</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fmplat!" href="#PtFEM.fmplat!"><code>PtFEM.fmplat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>fmplat!</strong></p><p>This subroutine forms the 2nd derivatives for rectangular plate bending fin_els.</p><p><strong>Method</strong></p><pre><code class="language-julia">fmplat!(d2x, d2y, d2xy, points, aa, bb, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* d2x::Vector{Float64}       : x derivative term (Updated)
* d2y::Vector{Float64}       : y derivative term (Updated)
* d2xy::Vector{Float64}      : x,y derivative term (Updated)
* points::Matrix{Float64}    : Location of Gauss points
* aa::Float64                : Dimension of plate
* bb::Float64                : Dimension of plate
* i::Int                   : Gauss point to use</code></pre></div></div></section><pre><code class="language-none">PtFEM.format_loads_line!</code></pre><pre><code class="language-none">PtFEM.format_nf_line!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.formm!" href="#PtFEM.formm!"><code>PtFEM.formm!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>formm!</strong></p><p>This subroutine forms the derivatives of the invariants with respect to stress in 2- or 3-d. See equation 6.25.</p><p><strong>Function</strong></p><pre><code class="language-julia">formm!(stress, m1, m2, m3)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector, see eq 6.25
* m1::Matrix{Float64}        : m1 matrix
* m2::Matrix{Float64}        : m2 matrix
* m3::Matrix{Float64}        : m3 matrix</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* m1::Matrix{Float64}        : m1 matrix
* m2::Matrix{Float64}        : m2 matrix
* m3::Matrix{Float64}        : m3 matrix</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.formnf!" href="#PtFEM.formnf!"><code>PtFEM.formnf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>formnf!</strong></p><p>Returns nodal freedom numbering array nf</p><p><strong>Function</strong></p><pre><code class="language-julia">formnf!(nodof, nn, nf)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nodof::Int       : Number of degrees of freedom for each node
* nn::Int          : Number of nodes in mesh
* nf::Array{Int,2} : Nodal freedom matrix (updated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fromSkyline" href="#PtFEM.fromSkyline"><code>PtFEM.fromSkyline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>fromSkyline</strong></p><p>Helper function to convert a Skyline vector to a full matrix.</p><p><strong>Type</strong></p><pre><code class="language-julia">fromSkyline(skyline::Vector{Float64}, kdiag::Vector{Int})</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* skyline::Vector{Float64}     : 1D Line(nod, nodof)
* kdiag::Vector{Int}         : 2D Triangle(nod, nodof)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fsparm!" href="#PtFEM.fsparm!"><code>PtFEM.fsparm!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>fsparm!</strong></p><p>Function fsparm assembles fin_el matrices into a Julia sparse global stiffness matrix.</p><p><strong>Method</strong></p><pre><code class="language-julia">fsparm!(gsm, g, km)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* gsm::SparseArrays{Float64, Float64}   : Sparse stiffnes matrix (Updated)
* g::Vector{Int}                      : Global coordinate vector.
* km::Matrix{Float64}                   : Stiffness matrix.</code></pre></div></div></section><pre><code class="language-none">PtFEM.fsparv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fsparv!" href="#PtFEM.fsparv!"><code>PtFEM.fsparv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>fsparv!</strong></p><p>Function fsparv! assembles fin_el matrices into a symmetric skyline global matrix. The Skyline vector kv is updated.</p><p><strong>Method</strong></p><pre><code class="language-julia">fsparv!(kv, km, g, km)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}        : Sparse stiffnes matrix (Updated)
* km::Matrix{Float64}        : Symmetric element stiffnes matrix
* g::Vector{Int}           : Global steering vector.
* kdiag::Vector{Int}       : Location of diagoinal terms</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.geom_rect!" href="#PtFEM.geom_rect!"><code>PtFEM.geom_rect!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>geom_rect!</strong></p><p>This subroutine forms the coordinates and connectivity for a rectangular mesh of right angled triangular elements (3, 6, 10 or 15-node) or quadrilateral elements (4, 8 or 9-node) counting in the x- or y-dir. </p><p><strong>Method</strong></p><pre><code class="language-julia">geom_rect!(fin_el, iel, x_coords, y_coords, coord, num, dir)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement            : Shape of finite element
                                     (Trangle or Quadrilateral)
* iel::Int                       : Element number
* x_coords::FloatRange{Float64}    : x coordinates
* y_coords::FloatRange{Float64}    : y coordinates
* coord::Matrix{Float64}           : Nodal coordinates (Updated)
* num::Vector{Int}               : Node numbers (Updated)
* dir::Symbol                      : Node numbering direction</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.glob_to_axial" href="#PtFEM.glob_to_axial"><code>PtFEM.glob_to_axial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>glob<em>to</em>axial</strong></p><p>This subroutine transforms the global end reactions into an axial force for rod fin_els (2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">glob_to_axial(glob, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* glob::Vector{Float64}      : Globale forces and moments
* coord::Matrix{Float64}     : Nodal coordinates</code></pre><p><strong>REturn value</strong></p><pre><code class="language-julia">* ::Float64                  : Axial force</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.glob_to_loc!" href="#PtFEM.glob_to_loc!"><code>PtFEM.glob_to_loc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>glob<em>to</em>loc!</strong></p><p>This subroutine transforms the global end reactions and moments into the local system (2- or 3-d). Called from hinge!().</p><p><strong>Function</strong></p><pre><code class="language-julia">glob_to_loc!(loc, glob, gamma, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loc::Vector{Float64}       : Local force and momemts (Updated)
* glob::Vector{Float64}      : Globale forces and moments
* gamma::Float64             : Element orientation angle (3D)
* coord::Matrix{Float64}     : Nodal coordinates</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.hexahedron_xz!" href="#PtFEM.hexahedron_xz!"><code>PtFEM.hexahedron_xz!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>hexahedron_xz!</strong></p><p>This subroutine generates nodal coordinates and numbering for 8, 14 or 20-node &quot;bricks&quot; counting x-z planes in the y-direction. </p><p><strong>Method</strong></p><pre><code class="language-julia">hexahedron_xz!(iel, x_coords, y_coords, z_coords, coord, num)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* iel::Int                       : Element number
* x_coords::FloatRange{Float64}    : x coordinates
* y_coords::FloatRange{Float64}    : y coordinates
* z_coords::FloatRange{Float64}    : y coordinates
* coord::Matrix{Float64}           : Nodal coordinates (Updated)
* num::Vector{Int}               : Node numbers (Updated)
* dir::Symbol                      : Node numbering direction</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.hinge!" href="#PtFEM.hinge!"><code>PtFEM.hinge!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>hinge!</strong></p><p>This subroutine forms the end forces and moments to be applied to a member if a joint has gone plastic.</p><p><strong>Function</strong></p><pre><code class="language-julia">hinge!(coord, holdr, action, react, prop, iel, etype, gamma)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* coord::Matrix{Float64}     : Nodal coordinates
* holdr::Matrix{Float64}     : Existing reactions
* action::Vector{Float64}    : Incremental reactions
* react::Vector{Float64}     : Correction to reactions (Updated)
* prop::Matrix{Float64}      : Beam properties
* iel::Int                 : Element number
* etype::Vector{Int}       : Element type
* gamma::Vector{Float64}     : Element orientation (3D)</code></pre></div></div></section><pre><code class="language-none">PtFEM.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.invar" href="#PtFEM.invar"><code>PtFEM.invar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>invar</strong></p><p>This subroutine forms the stress invariants in 2- or 3-d. See equations 6.3 and 6.4</p><p><strong>Function</strong></p><pre><code class="language-julia">invar(stress, sigm, dsbar, theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector
* sigm::Float64              : Invariant, eq 6.4 (Updated)
* dsbar::Float64             : Invariant, eq 6.4 (Updated)
* theta::Float64             : Invariant, eq 6.3 (Updated)</code></pre><p><strong>REturn values</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector
* sigm::Float64              : Invariant, eq 6.4 (Updated)
* dsbar::Float64             : Invariant, eq 6.4 (Updated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.jFEM" href="#PtFEM.jFEM"><code>PtFEM.jFEM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>jFEM</strong></p><p>Computational structure used in chapter 4 (Julia Sparse matrices used)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.linmul_sky!" href="#PtFEM.linmul_sky!"><code>PtFEM.linmul_sky!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>linmul_sky!</strong></p><p>This subroutine forms the product of symmetric matrix stored as a skyline and a vector.</p><p><strong>Method</strong></p><pre><code class="language-julia">linmul_sky!(kv, disps, loads, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Sparse stiffnes matrix (Skyline format)
* disps::Vector{Float64}    : Displacements
* loads::Vector{Float64}    : Loads vector (Updated)
* kdiag::Vector{Int}      : Bandwidth vector</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.loc_to_glob!" href="#PtFEM.loc_to_glob!"><code>PtFEM.loc_to_glob!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>loc<em>to</em>glob!</strong></p><p>This subroutine transforms the local end reactions and moments into the global system (3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">loc_to_glob!(loc, glob, gamma, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loc::Vector{Float64}       : Local force and momemts (Updated)
* glob::Vector{Float64}      : Globale forces and moments
* gamma::Float64             : Element orientation angle (3D)
* coord::Matrix{Float64}     : Nodal coordinates</code></pre></div></div></section><pre><code class="language-none">PtFEM.mesh</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mesh_size" href="#PtFEM.mesh_size"><code>PtFEM.mesh_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>mesh_size</strong></p><p>Function mesh<em>size returns the number of fin</em>els (nels) and the number of nodes (nn) in a 1, 2 or 3-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, [nye[, nze]])</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement   : Shape of finite element
                            1D: Line
                            2D: Trangle or Quadrilateral
                            3D: Hexahedron
* nxe::Int              : Number of fin_els in x direction
* nye::Int              : Number of fin_els in y direction (for 2D and 3D)
* nze::Int              : Number of fin_els in z direction (3D only)</code></pre></div></div><div><div><p><strong>mesh_size</strong></p><p>mesh<em>size: The function mesh</em>size returns the number of fin_els (nels) and the number of nodes (nn) in a 2-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Triangle)
* `nxe` : Number of fin_els in x direction
* `nxe` : Number of fin_els in y direction</code></pre></div></div><div><div><p><strong>mesh_size</strong></p><p>mesh<em>size: The function mesh</em>size returns the number of fin_els (nels) and the number of nodes (nn) in a 2-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, nye)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Quadrilateral)
* `nxe` : Number of fin_els in x direction
* `nye` : Number of fin_els in y direction</code></pre></div></div><div><div><p><strong>mesh_size</strong></p><p>mesh<em>size: The function mesh</em>size returns the number of fin_els (nels) and the number of nodes (nn) in a 3-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, nye, nze)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Hexahedron)
* `nxe` : Number of fin_els in x direction
* `nye` : Number of fin_els in y direction
* `nxe` : Number of fin_els in x direction</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mocouf" href="#PtFEM.mocouf"><code>PtFEM.mocouf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>mocouf</strong></p><p>This subroutine calculates the value of the yield function for a Mohr-Coulomb material (phi in degrees).</p><p><strong>Function</strong></p><pre><code class="language-julia">mocouf(phi, c, sigm, dsbar, theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* psi::Float64              : Local force and momemts (Updated)
* c::Float64                : Globale forces and moments
* sigm::Float64             : Element orientation angle (3D)
* dsbar::Float64            : Globale forces and moments
* theta::Float64            : Element orientation angle (3D)</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* ::Float64                 : Value of yield function</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mocouq" href="#PtFEM.mocouq"><code>PtFEM.mocouq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>mocouq</strong></p><p>This subroutine forms the derivatives of a Mohr-Coulomb potential function with respect to the three invariants (psi in degrees).</p><p><strong>Function</strong></p><pre><code class="language-julia">(dq1,dq2,dq3) = mocouq(psi,dsbar,theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* psi::Float64               : Local force and momemts (Updated)
* dsbar::Float64             : Globale forces and moments
* theta::Float64             : Element orientation angle (3D)</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* dq1::Float64               : Local force and momemts (Updated)
* dq2::Float64               : Globale forces and moments
* dq3::Float64               : Element orientation angle (3D)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.num_to_g!" href="#PtFEM.num_to_g!"><code>PtFEM.num_to_g!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>num<em>to</em>g!</strong></p><p>Returns the element steering vector g from the element node numbering num and the nodal freedom array nf.</p><p><strong>Function</strong></p><pre><code class="language-julia">num_to_g!(num, nf, g)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* num::Vector{Int}       : Node numbering vector
* nf::Matrix{Int}        : Nodal freedom array
* g::Vector{Int}         : Element steering vector (Updated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p41" href="#PtFEM.p41"><code>PtFEM.p41</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_df, fm_df)        : Tuple of jFem, dis_df and fm_df
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_df        : Displacement data table
                                    fm_df         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div></div><div><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(m, data) # Re-use factored global stiffness matrix</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `m::jFEM`                  : Previously created jFEM model
* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_df, fm_df)        : Tuple of jFem, dis_df and fm_df
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_df        : Displacement data table
                                    fm_df         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p42" href="#PtFEM.p42"><code>PtFEM.p42</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p42</strong></p><p>Analysis of elastic pin-jointed frames using 2-node rod elements in 2- or 3-dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p42(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::Vector{Float64}                            : x coordinate vector
* y_coords::Vector{Float64}                            : y coordinate vector
* g_num::Array{Int,2}                                : Element node connections</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* penalty::Float64             : Penalty for fixed freedoms
* etype::Vector{Int}         : Element material vector
* z_coords::Vector{Float64}    : z coordinate vector (3D)
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_df, fm_df)        : Tuple of jFem, dis_df and fm_df
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_df        : Displacement data table
                                    fm_df         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural element types
?Frame              : Help on a Rod structural fin_el
?FiniteElement      : List finite element types
?Line               : Help on Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p43" href="#PtFEM.p43"><code>PtFEM.p43</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>p43</strong></p><p>Analysis of elastic beams using 2-node Beam structural elements and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p43(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::LinSpace{Float64}                          : x coordinate vector
* g_num::Array{Int,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_df, fm_df)        : Tuple of jFem, dis_df and fm_df
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_df        : Displacement data table
                                    fm_df         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Rod                : Help on a Rod structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p44" href="#PtFEM.p44"><code>PtFEM.p44</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>p44</strong></p><p>Analysis of elastic rigid-jointed frames using a 2-node Frame structural element and Line finite elements in 2 or 3 dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p44(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x coordinate vector
* y_coords::FloatRange{Float64}                        : y coordinate vector
* g_num::Array{Int,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* z_coords::FloatRange{Float64}                        : z coordinate vector
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_df, fm_df)        : Tuple of jFem, dis_df and fm_df
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_df        : Displacement data table
                                    fm_df         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Beam               : Help on a Beam structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p45" href="#PtFEM.p45"><code>PtFEM.p45</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p45</strong></p><p>Analysis of elasto-plastic beams or rigid-jointed frames using a 2-node Frame structural element in 1, 2 or 3 dimensions. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p45(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector
* dload::FloatRange{Float64}                           : load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20                 : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1
* y_coords::FloatRange{Float64}  : y-coordinate vector (2D)
* z_coords::FloatRange{Float64}  : x-coordinate vector (3D)
* limit = 250                    : Iteration limit
* tol = 0.0001                   : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Frame                         : Help on a Frame structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p46" href="#PtFEM.p46"><code>PtFEM.p46</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p46</strong></p><p>Stability (buckling) analysis of elastic beams using a 2-node Beam structural element and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p46(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* limit = 250                  : Iteration limit
* tol = 0.0001                 : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Beam                          : Help on a Beam structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p47" href="#PtFEM.p47"><code>PtFEM.p47</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p47</strong></p><p>Analysis of plates (Plane structural element) using 4-node Quadrilateral finite elements. Homogeneous material with identical elements. Mesh numbered in x or y direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p47(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fm_df, sigma_df)            : Tuple of jFem, dis_df and fm_df
                                  where:
                                    fm_df         : Forces and moments data table
                                    sigma_df      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p51" href="#PtFEM.p51"><code>PtFEM.p51</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p51</strong></p><p>Plane or axisymmetric strain analysis of an elastic solid (Plane structural element) using 3-, 6-, 10- or 15-node right-angled triangles (Triangle finite elements) or 4-, 8- or 9-node rectangular quadrilaterals (Quadrilateral finite elements). Mesh numbered in x(r)- or y(z)- direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p51(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}            : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1}   : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20             : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fem, fm_df, sigma_df)     : Tuple of jFem, dis_df and fm_df
                               where:
                                 fm_df         : Forces and moments data table
                                 sigma_df      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement           : List of available structural element types
?Plane                       : Help on a Plane structural element
?FiniteElement               : List finite element types
?Quadrilateral               : Help on Quadrilateral finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p51_skyline" href="#PtFEM.p51_skyline"><code>PtFEM.p51_skyline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p51_skyline</strong></p><p>Plane or axisymmetric strain analysis of an elastic solid (Plane structural element) using 3-, 6-, 10- or 15-node right-angled triangles (Triangle finite elements) or 4-, 8- or 9-node rectangular quadrilaterals (Quadrilateral finite elements). Mesh numbered in x(r)- or y(z)- direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p51(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* fem                          : Fem object</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><pre><code class="language-none">PtFEM.p52</code></pre><pre><code class="language-none">PtFEM.p53</code></pre><pre><code class="language-none">PtFEM.p54</code></pre><pre><code class="language-none">PtFEM.p55</code></pre><pre><code class="language-none">PtFEM.p56</code></pre><pre><code class="language-none">PtFEM.p56_skyline</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p61" href="#PtFEM.p61"><code>PtFEM.p61</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p61</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (von Mises) material using 8-node rectangular quadrilaterals. Viscoplastic strain method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p61(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate
* tol::Float64                                         : Convergence tolerance
* qincs::Vector{Float64}                               : Incremental load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* limit = 250                  : Iteration limit
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p62" href="#PtFEM.p62"><code>PtFEM.p62</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p62</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (von Mises) material using 8-node rectangular quadrilaterals.</p><p>Viscoplastic strain method.</p><p>No global stiffness matrix assembly.</p><p>Diagonally preconditioned conjugate gradient solver.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p62(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate
* tol::Float64                                         : Convergence tolerance
* qincs::Vector{Float64}                               : Incremental load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* limit = 250                  : Iteration limit
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><pre><code class="language-none">PtFEM.p62a</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p63" href="#PtFEM.p63"><code>PtFEM.p63</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p63</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (Mohr-Coulomb) material using 8-node rectangular quadrilaterals. Rigid smooth footing. Displacement control. Viscoplastic strain method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p63(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* tol::Float64                 : Convergence tolerance
* limit = 250                  : Iteration limit
* incs::Int                    : Incremental load steps
* presc::Float64               : Wall displacement increment
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p63_skyline" href="#PtFEM.p63_skyline"><code>PtFEM.p63_skyline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Method p63_skyline</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (Mohr-Coulomb) material using 8-node rectangular quadrilaterals. Rigid smooth footing. Displacement control. Viscoplastic strain method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p63_skyline(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* tol::Float64                 : Convergence tolerance
* limit = 250                  : Iteration limit
* incs::Int                    : Incremental load steps
* presc::Float64               : Wall displacement increment
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.pin_jointed!" href="#PtFEM.pin_jointed!"><code>PtFEM.pin_jointed!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>pin_jointed!</strong></p><p>This subroutine forms the global stiffness matrix of a general pin-joionted structural element (1-, 2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">pin_jointed!(km, ea, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* ea::Float64               : Element stiffness
* coord::Matrix{Float64}}   : Element nodal coordinates</code></pre></div></div></section><pre><code class="language-none">PtFEM.pp62</code></pre><pre><code class="language-none">PtFEM.read_loads_file</code></pre><pre><code class="language-none">PtFEM.read_nf_file</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rigid_jointed!" href="#PtFEM.rigid_jointed!"><code>PtFEM.rigid_jointed!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>rigid_jointed!</strong></p><p>This subroutine forms the global stiffness matrix of a general pin-joionted structural element (1-, 2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">rigid_jointed!(km, prop, gamma, etype, iel, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* prop::Matrix{Float64}     : Element properties
* gamma::Vector{Float64}    : Element orientations (3D)
* etype::Vector{Int}        : Element type vector
* iel::Int                  : Element number
* coord::Matrix{Float64}}   : Element nodal coordinates</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rod_km!" href="#PtFEM.rod_km!"><code>PtFEM.rod_km!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>rod_km!</strong></p><p>This subroutine forms the stiffness matrix of a 1-d &quot;rod&quot; fin_el.</p><p><strong>Function</strong></p><pre><code class="language-julia">rod_km!(km, ea, length)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* ea::Float64               : Element stiffness
* ell::Float64              : Element length</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rod_mm!" href="#PtFEM.rod_mm!"><code>PtFEM.rod_mm!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>rod_mm!</strong></p><p>This subroutine forms the consistent mass matrix of a 1-d &quot;rod&quot; fin_el.</p><p><strong>Function</strong></p><pre><code class="language-julia">rod_mm!(km, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* mm::Matrix{Float64}       : Element mass matrix (Updated)
* ell::Float64              : Element length</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.sample!" href="#PtFEM.sample!"><code>PtFEM.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>sample!</strong></p><p>This subroutine returns the local coordinates and weighting coefficients of the integrating points.</p><p><strong>Function</strong></p><pre><code class="language-julia">sample!(fin_el, s, wt)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement      : Finite element type
* s::Matrix{Float64}        : Local coordinates (Updated)
* wt::Vector{Float64}       : Weighting coefficients (Updated)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.shape_der!" href="#PtFEM.shape_der!"><code>PtFEM.shape_der!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>shape_der!</strong></p><p>This subroutine produces derivatives of shape functions with respect to local coordinates.</p><p><strong>Function</strong></p><pre><code class="language-julia">shape_der!(der, point, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* der::Matrix{Float64}       : Function derivative (Updated)
* points::Matrix{Float64}    : Local coordinates of integration points
* i::Int                   : Integration point</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.shape_fun!" href="#PtFEM.shape_fun!"><code>PtFEM.shape_fun!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>shape_fun!</strong></p><p>This subroutine produces derivatives of shape functions with respect to local coordinates.</p><p><strong>Function</strong></p><pre><code class="language-julia">shape_fun!(fun, point, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fun::Vector{Float64}       : Shape function (Updated)
* points::Matrix{Float64}    : Local coordinates of integration points
* i::Int                   : Integration point</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.skyline2sparse" href="#PtFEM.skyline2sparse"><code>PtFEM.skyline2sparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>skyline2sparse</strong></p><p>Converts a Skyline matrix to a Julia Sparse matrix</p><p><strong>Function</strong></p><pre><code class="language-julia">skyline2sparse(skyline, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* skyline::Vector{Float64}         : Skyline matrix
* kdiag::Vector{Int}             : Element diagonal index vector</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.spabac!" href="#PtFEM.spabac!"><code>PtFEM.spabac!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>spabac!</strong></p><p>Function spabac! performs Cholesky forward and back-substitution on a symmetric skyline global matrix. The loads vector is updated.</p><p>###Arguments</p><pre><code class="language-julia">spabac!(kv, loads, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Skyline vector of global stiffness matrix
* loads::Vector{Float64}    : Load vector (Updated)
* kdiag::Vector{Int}      : Diagonal elemnt index vector</code></pre></div></div></section><pre><code class="language-none">PtFEM.sparin</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.sparin!" href="#PtFEM.sparin!"><code>PtFEM.sparin!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>sparin!</strong></p><p>Function sparin! performs Cholesky factorisation on a symmetric skyline global matrix. The vector kv is updated.</p><p>###Arguments</p><pre><code class="language-julia">sparin!(kv, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Global stiffness matrix (Updated)
* kdiag::Vector{Int}      : Diagonal elemnt index vector</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.stability" href="#PtFEM.stability"><code>PtFEM.stability</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>stability</strong></p><p>Function spabac! performs Cholesky forward and back-substitution on a symmetric skyline global matrix. The loads vector is updated.</p><p>###Arguments</p><pre><code class="language-julia">stability(gsm, ggm, tol, limit)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* gsm::SparseMatrixCSC{Float64,Int}   : Factored global stiffness matrix
* ggm::SparseMatrixCSC{Float64,Int}   : Factored geometric matrix
* tol::Float64                          : Convergence tolerance
* limit::Int                          : Iteration limit</code></pre></div></div></section><pre><code class="language-none">PtFEM.useplots</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
