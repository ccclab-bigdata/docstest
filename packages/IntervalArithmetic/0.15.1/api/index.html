<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IntervalArithmetic</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IntervalArithmetic</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Package</a></li><li><a class="toctext" href="../intro/">Interval Arithmetic</a></li><li><a class="toctext" href="../construction/">Constructing intervals</a></li><li><a class="toctext" href="../usage/">Basic usage</a></li><li><a class="toctext" href="../decorations/">Decorations</a></li><li><a class="toctext" href="../multidim/">Multi-dimensional boxes</a></li><li><a class="toctext" href="../rounding/">Rounding</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><ul><li><a href="#IntervalArithmetic.DECORATION"><code>IntervalArithmetic.DECORATION</code></a></li><li><a href="#IntervalArithmetic.DecoratedInterval"><code>IntervalArithmetic.DecoratedInterval</code></a></li><li><a href="#IntervalArithmetic.IntervalBox"><code>IntervalArithmetic.IntervalBox</code></a></li><li><a href="#IntervalArithmetic.IntervalRounding"><code>IntervalArithmetic.IntervalRounding</code></a></li><li><a href="#IntervalArithmetic.@biginterval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@biginterval</code></a></li><li><a href="#IntervalArithmetic.@floatinterval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@floatinterval</code></a></li><li><a href="#IntervalArithmetic.@format-Tuple"><code>IntervalArithmetic.@format</code></a></li><li><a href="#IntervalArithmetic.@interval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@interval</code></a></li><li><a href="#IntervalArithmetic.@round-Tuple{Any,Any}"><code>IntervalArithmetic.@round</code></a></li><li><a href="#Base.:==-Tuple{Interval,Interval}"><code>Base.:==</code></a></li><li><a href="#Base.:⊆-Tuple{Interval,Interval}"><code>Base.:⊆</code></a></li><li><a href="#Base.Rounding.setrounding-Tuple{Type{Interval},Symbol}"><code>Base.Rounding.setrounding</code></a></li><li><a href="#Base.hash-Tuple{Interval,UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.in-Union{Tuple{T}, Tuple{T,Interval}} where T&lt;:Real"><code>Base.in</code></a></li><li><a href="#Base.intersect"><code>Base.intersect</code></a></li><li><a href="#Base.intersect-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T"><code>Base.intersect</code></a></li><li><a href="#Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T}},AbstractString}} where T"><code>Base.parse</code></a></li><li><a href="#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}},AbstractString}} where T"><code>Base.parse</code></a></li><li><a href="#Base.round-Tuple{Interval}"><code>Base.round</code></a></li><li><a href="#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N"><code>Base.setdiff</code></a></li><li><a href="#Base.setdiff-Tuple{Interval,Interval}"><code>Base.setdiff</code></a></li><li><a href="#Base.union"><code>Base.union</code></a></li><li><a href="#Base.union-Tuple{Interval,Interval}"><code>Base.union</code></a></li><li><a href="#Base.widen-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.widen</code></a></li><li><a href="#IntervalArithmetic.atomic"><code>IntervalArithmetic.atomic</code></a></li><li><a href="#IntervalArithmetic.big53-Tuple{Interval{Float64}}"><code>IntervalArithmetic.big53</code></a></li><li><a href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a></li><li><a href="#IntervalArithmetic.cancelminus"><code>IntervalArithmetic.cancelminus</code></a></li><li><a href="#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T&lt;:Real"><code>IntervalArithmetic.cancelminus</code></a></li><li><a href="#IntervalArithmetic.cancelplus"><code>IntervalArithmetic.cancelplus</code></a></li><li><a href="#IntervalArithmetic.cancelplus-Tuple{Interval,Interval}"><code>IntervalArithmetic.cancelplus</code></a></li><li><a href="#IntervalArithmetic.checked_mult-Union{Tuple{T}, Tuple{T,T,RoundingMode}} where T"><code>IntervalArithmetic.checked_mult</code></a></li><li><a href="#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.diam</code></a></li><li><a href="#IntervalArithmetic.emptyinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.emptyinterval</code></a></li><li><a href="#IntervalArithmetic.entireinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.entireinterval</code></a></li><li><a href="#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{T}} where T"><code>IntervalArithmetic.find_quadrants</code></a></li><li><a href="#IntervalArithmetic.force_interval-Tuple{Any,Any}"><code>IntervalArithmetic.force_interval</code></a></li><li><a href="#IntervalArithmetic.hull"><code>IntervalArithmetic.hull</code></a></li><li><a href="#IntervalArithmetic.hull-Tuple{Interval,Interval}"><code>IntervalArithmetic.hull</code></a></li><li><a href="#IntervalArithmetic.interval-Tuple{Real,Real}"><code>IntervalArithmetic.interval</code></a></li><li><a href="#IntervalArithmetic.is_valid_interval-Tuple{Real,Real}"><code>IntervalArithmetic.is_valid_interval</code></a></li><li><a href="#IntervalArithmetic.isatomic-Tuple{Interval}"><code>IntervalArithmetic.isatomic</code></a></li><li><a href="#IntervalArithmetic.iscommon-Tuple{Interval}"><code>IntervalArithmetic.iscommon</code></a></li><li><a href="#IntervalArithmetic.isthin-Tuple{Interval}"><code>IntervalArithmetic.isthin</code></a></li><li><a href="#IntervalArithmetic.labelled_setdiff-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T"><code>IntervalArithmetic.labelled_setdiff</code></a></li><li><a href="#IntervalArithmetic.make_interval-Tuple{Any,Any,Any}"><code>IntervalArithmetic.make_interval</code></a></li><li><a href="#IntervalArithmetic.mid-Union{Tuple{T}, Tuple{Interval{T},Any}} where T"><code>IntervalArithmetic.mid</code></a></li><li><a href="#IntervalArithmetic.mid-Tuple{IntervalBox}"><code>IntervalArithmetic.mid</code></a></li><li><a href="#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T"><code>IntervalArithmetic.mid</code></a></li><li><a href="#IntervalArithmetic.multiply_by_positive_constant-Tuple{Any,Interval}"><code>IntervalArithmetic.multiply_by_positive_constant</code></a></li><li><a href="#IntervalArithmetic.nai-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.nai</code></a></li><li><a href="#IntervalArithmetic.pow-Tuple{Interval,Integer}"><code>IntervalArithmetic.pow</code></a></li><li><a href="#IntervalArithmetic.radius-Tuple{Interval}"><code>IntervalArithmetic.radius</code></a></li><li><a href="#IntervalArithmetic.round_expr-Tuple{Expr,RoundingMode}"><code>IntervalArithmetic.round_expr</code></a></li><li><a href="#IntervalArithmetic.setformat"><code>IntervalArithmetic.setformat</code></a></li><li><a href="#IntervalArithmetic.transform-Tuple{Symbol,Any,Any}"><code>IntervalArithmetic.transform</code></a></li><li><a href="#IntervalArithmetic.wideinterval-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFloat"><code>IntervalArithmetic.wideinterval</code></a></li><li><a href="#IntervalArithmetic.Region"><code>IntervalArithmetic.Region</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.DecoratedInterval" href="#IntervalArithmetic.DecoratedInterval"><code>IntervalArithmetic.DecoratedInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DecoratedInterval</code></pre><p>A <code>DecoratedInterval</code> is an interval, together with a <em>decoration</em>, i.e. a flag that records the status of the interval when thought of as the result of a previously executed sequence of functions acting on an initial interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.IntervalBox" href="#IntervalArithmetic.IntervalBox"><code>IntervalArithmetic.IntervalBox</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>IntervalBox</code> is an <code>N</code>-dimensional rectangular box, given by a Cartesian product of a vector of <code>N</code> <code>Interval</code>s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.@biginterval-Tuple{Any,Vararg{Any,N} where N}" href="#IntervalArithmetic.@biginterval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@biginterval</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>The <code>@biginterval</code> macro constructs an interval with <code>BigFloat</code> entries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.@floatinterval-Tuple{Any,Vararg{Any,N} where N}" href="#IntervalArithmetic.@floatinterval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@floatinterval</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>The <code>@floatinterval</code> macro constructs an interval with <code>Float64</code> entries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.@format-Tuple" href="#IntervalArithmetic.@format-Tuple"><code>IntervalArithmetic.@format</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@format [style::Symbol] [decorations::Bool] [sigfigs::Integer]</code></pre><p>The <code>@format</code> macro provides a simple interface to control the output format for intervals. These options are passed to the <code>setformat</code> function. It returns the new <code>DisplayParameters</code> object.</p><p>The arguments may be in any order and of type:</p><ul><li><code>Symbol</code>: the output format (<code>:full</code>, <code>:standard</code> or <code>:midpoint</code>)</li><li><code>Bool</code>: whether to display decorations</li><li><code>Integer</code>: the number of significant figures</li></ul><p>E.g.</p><pre><code class="language-none">julia&gt; x = 0.1..0.3
@[0.0999999, 0.300001]

julia&gt; @format full
Display parameters:
- format: full
- decorations: false
- significant figures: 6

julia&gt; x
Interval(0.09999999999999999, 0.30000000000000004)

julia&gt; @format standard 3
Display parameters:
- format: standard
- decorations: false
- significant figures: 3

julia&gt; x
[0.0999, 0.301]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.@interval-Tuple{Any,Vararg{Any,N} where N}" href="#IntervalArithmetic.@interval-Tuple{Any,Vararg{Any,N} where N}"><code>IntervalArithmetic.@interval</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>The <code>@interval</code> macro is the main method to create an interval. It converts each expression into a narrow interval that is guaranteed to contain the true value passed by the user in the one or two expressions passed to it. When passed two expressions, it takes the hull of the resulting intervals to give a guaranteed containing interval.</p><p>Examples:</p><pre><code class="language-none">    @interval(0.1)

    @interval(0.1, 0.2)

    @interval(1/3, 1/6)

    @interval(1/3^2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.widen-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Base.widen-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.widen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>widen(x)</code> widens the lowest and highest bounds of <code>x</code> to the previous and next representable floating-point numbers, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.bisect" href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bisect(X::Interval, α=0.49609375)</code></pre><p>Split the interval <code>X</code> at position α; α=0.5 corresponds to the midpoint. Returns a tuple of the new intervals.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.bisect" href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bisect(X::IntervalBox, i::Integer, α=0.49609375)</code></pre><p>Bisect the <code>IntervalBox</code> in side number <code>i</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.bisect" href="#IntervalArithmetic.bisect"><code>IntervalArithmetic.bisect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bisect(X::IntervalBox, α=0.49609375)</code></pre><p>Bisect the <code>IntervalBox</code> <code>X</code> at position α ∈ [0,1] along its longest side.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.cancelminus" href="#IntervalArithmetic.cancelminus"><code>IntervalArithmetic.cancelminus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cancelminus(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T&lt;:Real" href="#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T&lt;:Real"><code>IntervalArithmetic.cancelminus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cancelminus(a, b)</code></pre><p>Return the unique interval <code>c</code> such that <code>b+c=a</code>.</p><p>See Section 12.12.5 of the IEEE-1788 Standard for Interval Arithmetic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.cancelplus" href="#IntervalArithmetic.cancelplus"><code>IntervalArithmetic.cancelplus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cancelplus(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.cancelplus-Tuple{Interval,Interval}" href="#IntervalArithmetic.cancelplus-Tuple{Interval,Interval}"><code>IntervalArithmetic.cancelplus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cancelplus(a, b)</code></pre><p>Returns the unique interval <code>c</code> such that <code>b-c=a</code>; it is equivalent to <code>cancelminus(a, −b)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real" href="#IntervalArithmetic.diam-Union{Tuple{Interval{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.diam</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">diam(a::Interval)</code></pre><p>Return the diameter (length) of the <code>Interval</code> <code>a</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.emptyinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#IntervalArithmetic.emptyinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.emptyinterval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>emptyinterval</code>s are represented as the interval [∞, -∞]; note that this interval is an exception to the fact that the lower bound is larger than the upper one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.entireinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#IntervalArithmetic.entireinterval-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.entireinterval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>entireinterval</code>s represent the whole Real line: [-∞, ∞].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.hull" href="#IntervalArithmetic.hull"><code>IntervalArithmetic.hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hull(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.hull-Tuple{Interval,Interval}" href="#IntervalArithmetic.hull-Tuple{Interval,Interval}"><code>IntervalArithmetic.hull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hull(a, b)</code></pre><p>Returns the &quot;interval hull&quot; of the intervals <code>a</code> and <code>b</code>, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of <code>a</code> and <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.interval-Tuple{Real,Real}" href="#IntervalArithmetic.interval-Tuple{Real,Real}"><code>IntervalArithmetic.interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interval(a, b)</code></pre><p><code>interval(a, b)</code> checks whether [a, b] is a valid <code>Interval</code>, which is the case if <code>-∞ &lt;= a &lt;= b &lt;= ∞</code>, using the (non-exported) <code>is_valid_interval</code> function. If so, then an <code>Interval(a, b)</code> object is returned; if not, then an error is thrown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.isatomic-Tuple{Interval}" href="#IntervalArithmetic.isatomic-Tuple{Interval}"><code>IntervalArithmetic.isatomic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isatomic(x::Interval)</code></pre><p>Check whether an interval <code>x</code> is <em>atomic</em>, i.e. is unable to be split. This occurs when the interval is empty, or when the upper bound equals the lower bound or the <code>nextfloat</code> of the lower bound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.iscommon-Tuple{Interval}" href="#IntervalArithmetic.iscommon-Tuple{Interval}"><code>IntervalArithmetic.iscommon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iscommon(x)</code></pre><p>Checks if <code>x</code> is a <strong>common interval</strong>, i.e. a non-empty, bounded, real interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.isthin-Tuple{Interval}" href="#IntervalArithmetic.isthin-Tuple{Interval}"><code>IntervalArithmetic.isthin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isthin(x)</code></pre><p>Checks if <code>x</code> is the set consisting of a single exactly representable float. Any float which is not exactly representable does <em>not</em> yield a thin interval. Corresponds to <code>isSingleton</code> of the standard.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.mid-Tuple{IntervalBox}" href="#IntervalArithmetic.mid-Tuple{IntervalBox}"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mid(X::IntervalBox, α=0.5)</code></pre><p>Return a vector of the <code>mid</code> of each interval composing the <code>IntervalBox</code>.</p><p>See <code>mid(X::Interval, α=0.5)</code> for more informations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T" href="#IntervalArithmetic.mid-Union{Tuple{Interval{T}}, Tuple{T}} where T"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mid(a::Interval)</code></pre><p>Find the midpoint of interval <code>a</code>.</p><p>For intervals of the form <code>[-∞, x]</code> or <code>[x, +∞]</code> where <code>x</code> is finite, return respectively <code>nextfloat(-∞)</code> and <code>prevfloat(+∞)</code>. Note that it differs from the behavior of <code>mid(a, α=0.5)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.mid-Union{Tuple{T}, Tuple{Interval{T},Any}} where T" href="#IntervalArithmetic.mid-Union{Tuple{T}, Tuple{Interval{T},Any}} where T"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mid(a::Interval, α=0.5)</code></pre><p>Find an intermediate point at a relative position <code>α</code><code>in the interval</code>a<code>. The default is the true midpoint at</code>α = 0.5`.</p><p>Assumes 0 ≤ α ≤ 1.</p><p>Warning: if the parameter <code>α = 0.5</code> is explicitely set, the behavior differs from the default case if the provided <code>Interval</code> is not finite, since when <code>α</code> is provided <code>mid</code> simply replaces <code>+∞</code> (respectively <code>-∞</code>) by <code>prevfloat(+∞)</code> (respecively <code>nextfloat(-∞)</code>) for the computation of the intermediate point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.nai-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#IntervalArithmetic.nai-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>IntervalArithmetic.nai</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>NaI</code> not-an-interval: [NaN, NaN].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.pow-Tuple{Interval,Integer}" href="#IntervalArithmetic.pow-Tuple{Interval,Integer}"><code>IntervalArithmetic.pow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pow(x::Interval, n::Integer)</code></pre><p>A faster implementation of <code>x^n</code>, currently using <code>power_by_squaring</code>. <code>pow(x, n)</code> will usually return an interval that is slightly larger than that calculated by <code>x^n</code>, but is guaranteed to be a correct enclosure when using multiplication with correct rounding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.radius-Tuple{Interval}" href="#IntervalArithmetic.radius-Tuple{Interval}"><code>IntervalArithmetic.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius(a::Interval)</code></pre><p>Return the radius of the <code>Interval</code> <code>a</code>, such that <code>a ⊆ m ± radius</code>, where <code>m = mid(a)</code> is the midpoint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.setformat" href="#IntervalArithmetic.setformat"><code>IntervalArithmetic.setformat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setformat(format=none; decorations=none, sigfigs=none)</code></pre><p><code>setformat</code> changes how intervals are displayed. It returns the new <code>DisplayParameters</code> object.</p><p>Note that The <code>@format</code> macro is more user-friendly.</p><p>The following options are available:</p><ul><li><p><code>format</code>: interval output format</p><ul><li><code>:standard</code>: <code>[1, 2]</code></li><li><code>:full</code>: <code>Interval(1, 2)</code></li><li><code>:midpoint</code>: 1.5 ± 0.5</li></ul></li><li><p><code>sigfigs</code>: number of significant figures to show in <code>standard</code> mode; the default is 6</p></li><li><p><code>decorations</code> (boolean):  show decorations or not</p></li></ul><p>Example:</p><pre><code class="language-none">julia&gt; setformat(:full, decorations=true)
Display parameters:
- format: full
- decorations: true
- significant figures: 6</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.Region" href="#IntervalArithmetic.Region"><code>IntervalArithmetic.Region</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Region{T} = Union{Interval{T}, IntervalBox{T}}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.DECORATION" href="#IntervalArithmetic.DECORATION"><code>IntervalArithmetic.DECORATION</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DECORATION</code></pre><p>Enumeration constant for the types of interval decorations. The nomenclature of the follows the IEEE-1788 (2015) standard (sect 11.2):</p><ul><li><code>com -&gt; 4</code>: common: bounded, non-empty</li><li><code>dac -&gt; 3</code>: defined (nonempty) and continuous</li><li><code>def -&gt; 2</code>: defined (nonempty)</li><li><code>trv -&gt; 1</code>: always true (no information)</li><li><code>ill -&gt; 0</code>: nai (&quot;not an interval&quot;)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.IntervalRounding" href="#IntervalArithmetic.IntervalRounding"><code>IntervalArithmetic.IntervalRounding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Interval rounding trait type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.@round-Tuple{Any,Any}" href="#IntervalArithmetic.@round-Tuple{Any,Any}"><code>IntervalArithmetic.@round</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@round(ex1, ex2)</code></pre><p>Macro for internal use that creates an interval by rounding down <code>ex1</code> and rounding up <code>ex2</code>. Each expression may consist of only a <em>single</em> operation that needs rounding, e.g. <code>a.lo + b.lo</code> or <code>sin(a.lo)</code>. It also handles <code>min(...)</code> and <code>max(...)</code>, where the arguments are each themselves single operations.</p><p>The macro uses the internal <code>round_expr</code> function to transform e.g. <code>a + b</code> into <code>+(a, b, RoundDown)</code>.</p><p>The user-facing equivalent is <code>@interval</code>, which can handle much more general cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{Interval,Interval}" href="#Base.:==-Tuple{Interval,Interval}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(a,b)</code></pre><p>Checks if the intervals <code>a</code> and <code>b</code> are equal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{Interval,Interval}" href="#Base.:⊆-Tuple{Interval,Interval}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">issubset(a,b)
⊆(a,b)</code></pre><p>Checks if all the points of the interval <code>a</code> are within the interval <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Rounding.setrounding-Tuple{Type{Interval},Symbol}" href="#Base.Rounding.setrounding-Tuple{Type{Interval},Symbol}"><code>Base.Rounding.setrounding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setrounding(Interval, rounding_type::Symbol)</code></pre><p>Set the rounding type used for all interval calculations on Julia v0.6 and above. Valid <code>rounding_type</code>s are (:tight, :accurate, :slow, :none).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hash-Tuple{Interval,UInt64}" href="#Base.hash-Tuple{Interval,UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Computes the integer hash code for an <code>Interval</code> using the method for composite types used in <code>AutoHashEquals.jl</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Union{Tuple{T}, Tuple{T,Interval}} where T&lt;:Real" href="#Base.in-Union{Tuple{T}, Tuple{T,Interval}} where T&lt;:Real"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">in(x, a)
∈(x, a)</code></pre><p>Checks if the number <code>x</code> is a member of the interval <code>a</code>, treated as a set. Corresponds to <code>isMember</code> in the ITF-1788 Standard.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersect(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T" href="#Base.intersect-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersect(a, b)
∩(a,b)</code></pre><p>Returns the intersection of the intervals <code>a</code> and <code>b</code>, considered as (extended) sets of real numbers. That is, the set that contains the points common in <code>a</code> and <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}},AbstractString}} where T" href="#Base.parse-Union{Tuple{T}, Tuple{Type{DecoratedInterval{T}},AbstractString}} where T"><code>Base.parse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parse{T}(DecoratedInterval{T}, s::AbstractString)</code></pre><p>Parse a string of the form <code>&quot;[a, b]_dec&quot;</code> as a <code>DecoratedInterval</code> with decoration <code>dec</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T}},AbstractString}} where T" href="#Base.parse-Union{Tuple{T}, Tuple{Type{Interval{T}},AbstractString}} where T"><code>Base.parse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parse{T}(Interval{T}, s::AbstractString)</code></pre><p>Parse a string as an interval. Formats allowed include:</p><ul><li>&quot;1&quot;</li><li>&quot;[1]&quot;</li><li>&quot;[3.5, 7.2]&quot;</li><li>&quot;[-0x1.3p-1, 2/3]&quot;  # use numerical expressions</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.round-Tuple{Interval}" href="#Base.round-Tuple{Interval}"><code>Base.round</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">round(a::Interval[, RoundingMode])</code></pre><p>Returns the interval with rounded to an interger limits.</p><p>For compliance with the IEEE Std 1788-2015, &quot;roundTiesToEven&quot; corresponds to <code>round(a)</code> or <code>round(a, RoundNearest)</code>, and &quot;roundTiesToAway&quot; to <code>round(a, RoundNearestTiesAway)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff-Tuple{Interval,Interval}" href="#Base.setdiff-Tuple{Interval,Interval}"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setdiff(x::Interval, y::Interval)</code></pre><p>Calculate the set difference <code>x ∖ y</code>, i.e. the set of values that are inside the interval <code>x</code> but not inside <code>y</code>.</p><p>Returns an array of intervals. The array may:</p><ul><li>be empty if <code>x ⊆ y</code>;</li><li>contain a single interval, if <code>y</code> overlaps <code>x</code></li><li>contain two intervals, if <code>y</code> is strictly contained within <code>x</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N" href="#Base.setdiff-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setdiff(A::IntervalBox{N,T}, B::IntervalBox{N,T})</code></pre><p>Returns a vector of <code>IntervalBox</code>es that are in the set difference <code>A ∖ B</code>, i.e. the set of <code>x</code> that are in <code>A</code> but not in <code>B</code>.</p><p>Algorithm: Start from the total overlap (in all directions); expand each direction in turn.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union(xx, yy)</code></pre><p>Decorated interval extension; the result is decorated as <code>trv</code>, following the IEEE-1788 Standard (see Sect. 11.7.1, pp 47).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union-Tuple{Interval,Interval}" href="#Base.union-Tuple{Interval,Interval}"><code>Base.union</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">union(a, b)
∪(a,b)</code></pre><p>Returns the union (convex hull) of the intervals <code>a</code> and <code>b</code>; it is equivalent to <code>hull(a,b)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.atomic" href="#IntervalArithmetic.atomic"><code>IntervalArithmetic.atomic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">atomic(::Type{&lt;:Interval}, x)</code></pre><p>Construct the tightest interval of a given type that contains the value <code>x</code>.</p><p>If <code>x</code> is an <code>AbstractString</code>, the interval will be created by calling <code>parse</code>.</p><p><strong>Examples</strong></p><p>Construct an <code>Interval{Float64}</code> containing a given <code>BigFloat</code>:</p><pre><code class="language-julia">julia&gt; x = big&quot;0.1&quot;
1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01

julia&gt; i = IntervalArithmetic.atomic(Interval{Float64}, x)
[0.0999999, 0.100001]

julia&gt; i isa Interval{Float64}
true

julia&gt; i.lo &lt;= x &lt;= i.hi
true

julia&gt; i.hi === nextfloat(i.lo)
true</code></pre><p>Construct an <code>Interval{Float32}</code> containing a the real number 0.1 in two ways:</p><pre><code class="language-julia">julia&gt; i1 = IntervalArithmetic.atomic(Interval{Float32}, &quot;0.1&quot;)
[0.0999999, 0.100001]

julia&gt; i2 = IntervalArithmetic.atomic(Interval{Float32}, 1//10)
[0.0999999, 0.100001]

julia&gt; i1 === i2
true

julia&gt; i.lo &lt;= 1//10 &lt;= i.hi
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.big53-Tuple{Interval{Float64}}" href="#IntervalArithmetic.big53-Tuple{Interval{Float64}}"><code>IntervalArithmetic.big53</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>big53</code> creates an equivalent <code>BigFloat</code> interval to a given <code>Float64</code> interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.checked_mult-Union{Tuple{T}, Tuple{T,T,RoundingMode}} where T" href="#IntervalArithmetic.checked_mult-Union{Tuple{T}, Tuple{T,T,RoundingMode}} where T"><code>IntervalArithmetic.checked_mult</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a * b where 0 * Inf is special-cased</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{T}} where T" href="#IntervalArithmetic.find_quadrants-Union{Tuple{T}, Tuple{T}} where T"><code>IntervalArithmetic.find_quadrants</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Finds the quadrant(s) corresponding to a given floating-point number. The quadrants are labelled as 0 for x ∈ [0, π/2], etc. For numbers very near a boundary of the quadrant, a tuple of two quadrants is returned. The minimum or maximum must then be chosen appropriately.</p><p>This is a rather indirect way to determine if π/2 and 3π/2 are contained in the interval; cf. the formula for sine of an interval in Tucker, <em>Validated Numerics</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.force_interval-Tuple{Any,Any}" href="#IntervalArithmetic.force_interval-Tuple{Any,Any}"><code>IntervalArithmetic.force_interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Make an interval even if a &gt; b</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.is_valid_interval-Tuple{Real,Real}" href="#IntervalArithmetic.is_valid_interval-Tuple{Real,Real}"><code>IntervalArithmetic.is_valid_interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_valid_interval(a::Real, b::Real)</code></pre><p>Check if <code>(a, b)</code> constitute a valid interval</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.labelled_setdiff-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T" href="#IntervalArithmetic.labelled_setdiff-Union{Tuple{T}, Tuple{Interval{T},Interval{T}}} where T"><code>IntervalArithmetic.labelled_setdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a list of pairs (interval, label) label is 1 if the interval is <em>excluded</em> from the setdiff label is 0 if the interval is included in the setdiff label is -1 if the intersection of the two intervals was empty</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.make_interval-Tuple{Any,Any,Any}" href="#IntervalArithmetic.make_interval-Tuple{Any,Any,Any}"><code>IntervalArithmetic.make_interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>make_interval</code> does the hard work of taking expressions and making each literal (0.1, 1, etc.) into a corresponding interval construction, by calling <code>transform</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.multiply_by_positive_constant-Tuple{Any,Interval}" href="#IntervalArithmetic.multiply_by_positive_constant-Tuple{Any,Interval}"><code>IntervalArithmetic.multiply_by_positive_constant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Multiply an interval by a positive constant. For efficiency, does not check that the constant is positive.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.round_expr-Tuple{Expr,RoundingMode}" href="#IntervalArithmetic.round_expr-Tuple{Expr,RoundingMode}"><code>IntervalArithmetic.round_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">round_expr(ex::Expr, rounding_mode::RoundingMode)</code></pre><p>Transforms a single expression by applying a rounding mode, e.g.</p><ul><li><code>a + b</code> into <code>+(a, b, RoundDown)</code></li><li><code>sin(a)</code> into <code>sin(a, RoundDown)</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.transform-Tuple{Symbol,Any,Any}" href="#IntervalArithmetic.transform-Tuple{Symbol,Any,Any}"><code>IntervalArithmetic.transform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>transform</code> transforms a string by applying the function <code>f</code> and type <code>T</code> to each argument, i.e. <code>:(x+y)</code> is transformed to <code>:(f(T, x) + f(T, y))</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.wideinterval-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFloat" href="#IntervalArithmetic.wideinterval-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFloat"><code>IntervalArithmetic.wideinterval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wideinterval(x::AbstractFloat)</code></pre><p>Returns the interval Interval( prevfloat(x), nextfloat(x) ).</p></div></div></section><footer><hr/><a class="previous" href="../rounding/"><span class="direction">Previous</span><span class="title">Rounding</span></a></footer></article></body></html>
