<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Inflate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Inflate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#In-Memory-Decompression-1">In-Memory Decompression</a></li><li><a class="toctext" href="#Streaming-Decompression-1">Streaming Decompression</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Inflate.jl-1" href="#Inflate.jl-1">Inflate.jl</a></h1><p>Inflate provides a pure Julia implementation of <a href="https://zlib.net">zlib</a> <em>de</em>compression functionality, with both in- memory and streaming interfaces. This covers decompression of the Deflate algorithm and the Zlib and Gzip wrapper formats, as specified in <a href="https://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>, <a href="https://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a>, and <a href="https://www.ietf.org/rfc/rfc1952.txt">RFC 1952</a>.</p><p>The main reasons to choose Inflate over <a href="https://github.com/bicycle1885/CodecZlib.jl">CodecZlib</a> are:</p><ul><li>100% Julia code - great for Julia purists.</li><li>No binary dependencies.</li><li>Actually no dependencies at all.</li><li>Can read gzip headers.</li></ul><p>You should choose CodecZlib over Inflate if the points above are not compelling or one or more of the following applies to you:</p><ul><li>Need to compress, not only decompress.</li><li>Want higher speed.</li><li>Want a full-featured streaming interface.</li><li>Want a battle-proven library.</li></ul><h2><a class="nav-anchor" id="In-Memory-Decompression-1" href="#In-Memory-Decompression-1">In-Memory Decompression</a></h2><p>In-memory decompression is done by the following functions:</p><table><tr><th>function</th><th>decompresses</th></tr><tr><td><code>inflate(data::Vector{UInt8})</code></td><td>raw Deflate data</td></tr><tr><td><code>inflate_zlib(data::Vector{UInt8})</code></td><td>Zlib data</td></tr><tr><td><code>inflate_gzip(data::Vector{UInt8})</code></td><td>Gzip data</td></tr></table><p>They all take a <code>Vector{UInt8}</code> with compressed data as input and return a <code>Vector{UInt8}</code> of decompressed data. Additionally</p><pre><code class="language-none">gzip_headers = Dict{String, Any}()
out = inflate_gzip(data, headers = gzip_headers)</code></pre><p>fills in <code>gzip_headers</code> with the Gzip headers present in <code>data</code>.</p><p>Both <code>inflate_zlib</code> and <code>inflate_gzip</code> accept the keyword argument <code>ignore_checksum</code>, which if set to true skips consistency checking by means of Adler and CRC checksums respectively. This disables the computation of the checksums, saving time.</p><p>Finally, there is also a convenience function to read a compressed text file in gzip format</p><pre><code class="language-none">out = inflate_gzip(filename::String)</code></pre><p>This returns the decompressed file as a string.</p><h2><a class="nav-anchor" id="Streaming-Decompression-1" href="#Streaming-Decompression-1">Streaming Decompression</a></h2><p>Streaming decompression is done using the following types:</p><table><tr><th>stream</th><th>decompresses</th></tr><tr><td><code>InflateStream(stream::IO)</code></td><td>raw Deflate stream</td></tr><tr><td><code>InflateZlibStream(stream::IO)</code></td><td>Zlib stream</td></tr><tr><td><code>InflateGzipStream(stream::IO)</code></td><td>Gzip stream</td></tr></table><p>The stream types are subtypes of <code>IO</code> and decompression is done by reading from instances of the types.</p><p>Example:</p><pre><code class="language-none">f = open(&quot;compressed_file.gz&quot;, &quot;r&quot;)
gz = InflateGzipStream(f)
for line in readlines(gz)
    println(line)
end
close(f)</code></pre><p>The streaming interface is minimalistic. If you need a full-featured interface, the CodecZlib package is likely to be a better fit.</p><p>Reading of Gzip headers can be done from the streaming interface too.</p><pre><code class="language-none">gzip_headers = Dict{String, Any}()
gz = InflateGzipStream(stream, headers = gzip_headers)</code></pre><p>The retrieved headers will be available immediately upon construction of the <code>InflateGzipStream</code>. It is not necessary to read any data first.</p><p>Likewise both <code>InflateZlibStream</code> and <code>InflateGzipStream</code> accept the keyword argument <code>ignore_checksum</code> in the same way as the non-streaming functions <code>inflate_zlib</code> and <code>inflate_gzip</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
