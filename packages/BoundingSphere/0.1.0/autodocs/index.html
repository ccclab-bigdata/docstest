<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BoundingSphere.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BoundingSphere.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.BoundaryDevice" href="#BoundingSphere.BoundaryDevice"><code>BoundingSphere.BoundaryDevice</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BoundaryDevice</code></pre><p>Finds unique spheres determined by prescribed affine independent boundary points. In the welzl algorithm this problem needs to be solved in series, where points are pushed and popped from to the boundary.</p><p>Subtypes must implement the following interface:</p><ul><li>push<em>if</em>stable!(device, pt)::Bool :</li><li>pop!(device): Remove last point from the boundary.</li><li>get_ball(device)::SqBall : Get the last ball from the device.</li><li>length(device)::Int : Get the current count of boundary points</li><li>ismaxlength(device)::Bool: Check if there are dim+1 boundary points in the device</li></ul></div></div></section><pre><code class="language-none">BoundingSphere.BoundingSphere</code></pre><pre><code class="language-none">BoundingSphere.BoundingSphereAlg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.GaertnerBdry" href="#BoundingSphere.GaertnerBdry"><code>BoundingSphere.GaertnerBdry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaertnerBdry</code></pre><p>BoundaryDevice that corresponds to M_B in Section 4 of Gaertners paper.</p><p>See also: <a href="@ref">BoundaryDevice</a></p></div></div></section><pre><code class="language-none">BoundingSphere.ProjectorStack</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.Ritter" href="#BoundingSphere.Ritter"><code>BoundingSphere.Ritter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Ritter()</code></pre><p><strong>Pros</strong></p><ul><li>extremly fast</li><li>simple</li></ul><p><strong>Cons</strong></p><ul><li>Very inaccurate.</li></ul></div></div></section><pre><code class="language-none">BoundingSphere.SqBall</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.WelzlMTF" href="#BoundingSphere.WelzlMTF"><code>BoundingSphere.WelzlMTF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WelzlMTF()</code></pre><p>Welzl algorithm with move to front heuristic. See Algorithm I in https://people.inf.ethz.ch/gaertner/subdir/texts/own<em>work/esa99</em>final.pdf. In almost all situations it is better to use <a href="#BoundingSphere.WelzlPivot"><code>WelzlPivot</code></a> instead.</p><p><strong>Pros</strong></p><ul><li>Fast for small examples</li></ul><p><strong>Cons</strong></p><ul><li>Prone to numerical stability issues</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.WelzlPivot" href="#BoundingSphere.WelzlPivot"><code>BoundingSphere.WelzlPivot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WelzlPivot(;max_iterations=1000)</code></pre><p>Welzl algorithm with pivoting. See Algorithm II in https://people.inf.ethz.ch/gaertner/subdir/texts/own<em>work/esa99</em>final.pdf.</p><p><strong>Pros</strong></p><ul><li>Fast</li></ul><p><strong>Cons</strong></p><ul><li>In very rare cases can be numerically instable</li></ul></div></div></section><pre><code class="language-none">BoundingSphere.allinside</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BoundingSphere.boundingsphere" href="#BoundingSphere.boundingsphere"><code>BoundingSphere.boundingsphere</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">center, radius = boundingsphere(pts [, algorithm=WelzlPivot()])</code></pre><p>Compute the smallest sphere that contains each point in <code>pts</code>.</p><p><strong>Arguments</strong></p><ul><li>pts: A list of points. Points should be vectors with floating point entries.</li><li>algorithm: An optional algorithm to do the computation. See names(BoundingSphere) to get</li></ul></div></div></section><pre><code class="language-none">BoundingSphere.boundingsphere!</code></pre><pre><code class="language-none">BoundingSphere.center</code></pre><pre><code class="language-none">BoundingSphere.create_boundary_device</code></pre><pre><code class="language-none">BoundingSphere.dist</code></pre><pre><code class="language-none">BoundingSphere.eval</code></pre><pre><code class="language-none">BoundingSphere.find_max_excess</code></pre><pre><code class="language-none">BoundingSphere.get_ball</code></pre><pre><code class="language-none">BoundingSphere.include</code></pre><pre><code class="language-none">BoundingSphere.isinside</code></pre><pre><code class="language-none">BoundingSphere.ismaxlength</code></pre><pre><code class="language-none">BoundingSphere.leq_approx</code></pre><pre><code class="language-none">BoundingSphere.max_distance_point</code></pre><pre><code class="language-none">BoundingSphere.move_to_front!</code></pre><pre><code class="language-none">BoundingSphere.prefix</code></pre><pre><code class="language-none">BoundingSphere.push_if_stable!</code></pre><pre><code class="language-none">BoundingSphere.radius</code></pre><pre><code class="language-none">BoundingSphere.ritter</code></pre><pre><code class="language-none">BoundingSphere.sqdist</code></pre><pre><code class="language-none">BoundingSphere.sqnorm</code></pre><pre><code class="language-none">BoundingSphere.sqradius</code></pre><pre><code class="language-none">BoundingSphere.sqsphere_two_points</code></pre><pre><code class="language-none">BoundingSphere.welzl!</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
