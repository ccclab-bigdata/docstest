<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Frames · ModiaMath</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModiaMath</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/Overview.html">Overview</a></li><li><a class="toctext" href="../man/Plans.html">Plans for version 1.0</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="SimulationEngine.html">SimulationEngine</a></li><li><a class="toctext" href="Result.html">Result</a></li><li><a class="toctext" href="DAE.html">DAE</a></li><li><a class="toctext" href="NonlinearEquations.html">NonlinearEquations</a></li><li><a class="toctext" href="Variables.html">Variables</a></li><li><a class="toctext" href="Logging.html">Logging</a></li><li class="current"><a class="toctext" href="Frames.html">Frames</a><ul class="internal"></ul></li><li><a class="toctext" href="Utilities.html">Utilities</a></li><li><a class="toctext" href="ModiaMath.html">ModiaMath Constants and Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="Frames.html">Frames</a></li></ul></nav><hr/><div id="topbar"><span>Frames</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Frames-1" href="#Frames-1">Frames</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames" href="#ModiaMath.Frames"><code>ModiaMath.Frames</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">module ModiaMath.Frames</code></pre><p>This module contains functions for <strong>frames</strong> that is coordinate systems in 3D. The orientation of a frame is described either with a 3x3 <strong>rotation matrix</strong>  or with a <strong>quaternion vector</strong> and its origin is described with a <strong>Vector3D</strong>:</p><ul><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a> = SMatrix{3,3,Float64,9}`:  Type of a Rotation matrix to rotate from a frame 1 into a frame 2.</p></li><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a> = SVector{4,Float64}`: Type of a Quaternion vector to rotate from a frame 1 into a frame 2.</p></li><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.Vector3D"><code>ModiaMath.Vector3D</code></a> = SVector{3,Float64}`: Type of a vector in 3D space (e.g. position vector of the origin of a frame).</p></li></ul><p>The following constants are defined</p><ul><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.NullRotation"><code>ModiaMath.NullRotation</code></a>:  RotationMatrix with no rotation from a frame 1 into a frame 2.</p></li><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.NullQuaternion"><code>ModiaMath.NullQuaternion</code></a>: Quaternion vector with no rotation from a frame 1 into a frame 2.</p></li><li><p><code>const</code><a href="Frames.html#ModiaMath.Frames.ZeroVector3D"><code>ModiaMath.ZeroVector3D</code></a>: Vector3D with only zero elements.</p></li></ul><p>If an angle is given as an argument to one of the functions below, it might be a number (interpreted as having unit <code>rad</code>) or a number with a unit (for example: <code>using Unitful; angle = 90u&quot;°&quot;</code>).</p><p><strong>Constructors for a RotationMatrix R</strong></p><p>The following functions return a <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a><code>R</code> to rotate a frame 1 into a frame 2.</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot1-Tuple{Number}"><code>ModiaMath.rot1</code></a>(angle)</td><td>Rotate around <code>angle</code> along x-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot2-Tuple{Number}"><code>ModiaMath.rot2</code></a>(angle)</td><td>Rotate around <code>angle</code> along y-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot3-Tuple{Number}"><code>ModiaMath.rot3</code></a>(angle)</td><td>Rotate around <code>angle</code> along z-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot123-Tuple{Number,Number,Number}"><code>ModiaMath.rot123</code></a>(angle1, angle2, angle3)</td><td>Rotate around angles along x,y,z-axes</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}"><code>ModiaMath.rot_e</code></a>(e, angle)</td><td>Rotate around <code>angle</code> along unit vector <code>e</code></td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.rot_nxy-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.rot_nxy</code></a>(nx, ny)</td><td><code>nx</code>/<code>ny</code> are in x/y-direction of frame 2</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.from_q-Tuple{StaticArrays.SArray{Tuple{4},Float64,1,4}}"><code>ModiaMath.from_q</code></a>(q)</td><td>Return <code>R</code> from Quaternion <code>q</code></td></tr></table><p><strong>Constructors for a Quaternion q</strong></p><p>The following functions return a <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a><code>q</code> to rotate a frame 1 into a frame 2. Since <code>q</code> and <code>-q</code> define the same rotation the constructor functions have a keyword argument <code>q_guess::Quaternion = NullQuaternion</code>. From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code>.</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot1-Tuple{Number}"><code>ModiaMath.qrot1</code></a>(angle)</td><td>Rotate around <code>angle</code> along x-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot2-Tuple{Number}"><code>ModiaMath.qrot2</code></a>(angle)</td><td>Rotate around <code>angle</code> along y-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot3-Tuple{Number}"><code>ModiaMath.qrot3</code></a>(angle)</td><td>Rotate around <code>angle</code> along z-axis</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot123-Tuple{Number,Number,Number}"><code>ModiaMath.qrot123</code></a>(angle1, angle2, angle3)</td><td>Rotate around angles along x,y,z-axes</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}"><code>ModiaMath.qrot_e</code></a>(e, angle)</td><td>Rotate around <code>angle</code> along unit vector <code>e</code></td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.qrot_nxy-Tuple{Any,Any}"><code>ModiaMath.qrot_nxy</code></a>(nx, ny)</td><td><code>nx</code>/<code>ny</code> are in x/y-direction of frame 2</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.from_R-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.from_R</code></a>(R)</td><td>Return <code>q</code> from RotationMatrix <code>R</code></td></tr></table><p><strong>Operations on Frames</strong></p><p>The following functions provide operations on frames. The orientation of a frame is  defined with argument <code>Rq</code> meaning it can be either a  <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a> <code>R</code> or a  <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a> <code>q</code> (to rotate a frame 1 into a frame 2).</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="Frames.html#ModiaMath.Frames.resolve1-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.resolve1</code></a>(Rq, v2)</td><td>Transform vector <code>v</code> from frame 2 to frame 1</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.resolve2-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.resolve2</code></a>(Rq, v1)</td><td>Transform vector <code>v</code> from frame 1 to frame 2</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.absoluteRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.absoluteRotation</code></a>(Rq01, Rq12)</td><td>Return rotation 0-&gt;2 from rot. 0-&gt;1 and 1-&gt;2</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.relativeRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.relativeRotation</code></a>(Rq01, Rq02)</td><td>Return rotation 1-&gt;2 from rot. 0-&gt;1 and 0-&gt;2</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.inverseRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.inverseRotation</code></a>(Rq01)</td><td>Return rotation 1-&gt;0 from rot, 0-&gt;1</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>ModiaMath.planarRotationAngle</code></a>(e,v1,v2)</td><td>Return angle of planar rotation along <code>e</code></td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.eAxis-Tuple{Int64}"><code>ModiaMath.eAxis</code></a>(axis)</td><td>Return unit vector <code>e</code> in direction of <code>axis</code></td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.skew-Tuple{AbstractArray{T,1} where T}"><code>ModiaMath.skew</code></a>(v)</td><td>Return skew-symmetric matrix of vector v</td></tr></table><p><strong>Interpolation of Frames</strong></p><p>Given a set of frames by a vector <code>r</code> of position vectors to their origins and  and an optional vector <code>q</code> of Quaternions of their absolute orientations, then the following functions interpolate linearly in these frames:</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="Frames.html#ModiaMath.Frames.Path"><code>ModiaMath.Path</code></a>(r,q)</td><td>Return path defined by a vector of frames</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.t_pathEnd-Tuple{ModiaMath.Frames.Path}"><code>ModiaMath.t_pathEnd</code></a>(path)</td><td>Return path parameter <code>t_end</code> of last frame</td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.interpolate-Tuple{ModiaMath.Frames.Path,Number}"><code>ModiaMath.interpolate</code></a>(path,t)</td><td>Return <code>(rt,qt)</code> of Path at path parameter <code>t</code></td></tr><tr><td><a href="Frames.html#ModiaMath.Frames.interpolate_r-Tuple{ModiaMath.Frames.Path,Number}"><code>ModiaMath.interpolate_r</code></a>(path,t)</td><td>Return <code>rt</code> of Path at path parameter <code>t</code></td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia">using ModiaMath
using Unitful

# R1,R2,R3 are the same RotationMatrices
R1 = ModiaMath.rot1(pi/2)
R2 = ModiaMath.rot1(90u&quot;°&quot;)
R3 = ModiaMath.rot_e([1,0,0], pi/2)</code></pre><p><strong>Main developer</strong></p><p><a href="https://rmc.dlr.de/sr/de/staff/martin.otter/">Martin Otter</a>,  <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p><p><em>The functions of this module are mostly a mapping of some of the functions of the Modelica Standard Library from Modelica  (<a href="https://doc.modelica.org/help/Modelica_Mechanics_MultiBody_Frames.html#Modelica.Mechanics.MultiBody.Frames">Modelica.Mechanics.MultiBody.Frames</a>) to Julia (taking advantage of Julia features  such as multiple dispatch and unit package Unitful)</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.NullQuaternion" href="#ModiaMath.Frames.NullQuaternion"><code>ModiaMath.Frames.NullQuaternion</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">const ModiaMath.NullQuaternion = Quaternion(0,0,0,1)</code></pre><p>Constant Quaternion vector of a null rotation (= no rotation from frame 1 to frame 2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.NullRotation" href="#ModiaMath.Frames.NullRotation"><code>ModiaMath.Frames.NullRotation</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>@static if VERSION &gt;= v&quot;0.7.0-DEV.2005&quot;     const ModiaMath.NullRotation = ModiaMath.RotationMatrix(Matrix(1.0I, 3, 3)) else     const ModiaMath.NullRotation = ModiaMath.RotationMatrix(eye(3)) end</p><p>Constant RotationMatrix that defines no rotation from frame 1 to frame 2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.ZeroVector3D" href="#ModiaMath.Frames.ZeroVector3D"><code>ModiaMath.Frames.ZeroVector3D</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">const ModiaMath.ZeroVector3D = Vector3D(0.0, 0.0, 0.0)</code></pre><p>Constant of a Vector3D where all elements are zero</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.Path" href="#ModiaMath.Frames.Path"><code>ModiaMath.Frames.Path</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">path = ModiaMath.Path(r::Vector{Vector3D},
                      q::Vector{Quaternion} = Quaternion[];
                      v = ones(length(r)))</code></pre><p>Return an instance of a new Path object. The Path object consists of n frames defined by the position vectors of their origins (<code>r[i]</code> for frame <code>i</code>)  and optionally of their absolute rotation quaternions (<code>q[i]</code> for frame <code>i</code>) describing the rotation from the world frame to the respective frame.</p><p>A path parameter <code>t</code> is defined in the following way on these frames:</p><ul><li><code>t[1] = 0.0</code>.</li><li><code>t[i] = t[i-1] + pathLength_i/(v[i]+v[i-1])/2</code> if the origins of frames <code>i-1</code> and <code>i</code> do not coincide.</li><li><code>t[i] = t[i-1] + pathAngle_i/(v[i]+v[i-1])/2</code> if the origins of frames <code>i-1</code> and <code>i</code> do coincide.</li></ul><p>Hereby <code>pathLength_i</code> is the distance between the origins of frames <code>i-1</code> and <code>i</code> in [m] and <code>pathAngle_i</code> is the planar rotation angle between frames <code>i-1</code> and <code>i</code> in [rad].</p><p>If <code>v[i]</code> is the desired velocity or angular velocity at frame <code>i</code>, then path parameter <code>t</code> is approximately the time to move along the path. The time instant <code>t_end</code> of the last frame can be inquired with <code>ModiaMath.t_pathEnd(path)</code>. For example, if a simulation shall be performed in such  a way that the simulation should start with the first frame and end at <code>stopTime</code> at the last frame, then the path parameter should be selected as <code>t = time*t_end/stopTime</code>.</p><p>Given the actual path parameter, typically <code>0 &lt;= t &lt;= t_end</code> (if <code>t</code> is outside of this interval, the frame at <code>t</code> is determined by extrapolation through the first two or the last two frames),  the corresponding frame is determined by linear interpolation in the following way:</p><pre><code class="language-julia">(rt, qt) = interpolate(  path,t)
 rt      = interpolate_r(path,t)</code></pre><p>where <code>rt</code> is the position vector to the origin of the frame at path parameter <code>t</code> and <code>qt</code> is the absolute quaternion of the frame at path parameter <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">import ModiaMath
using Unitful

r = [ ModiaMath.Vector3D(1,0,0),
      ModiaMath.Vector3D(0,1,0),
      ModiaMath.Vector3D(0,0,1) ]
q = [ ModiaMath.NullQuaternion,
      ModiaMath.qrot1(45u&quot;°&quot;),
      ModiaMath.qrot2(60u&quot;°&quot;)]

path     = ModiaMath.Path(r,q)
t_end    = ModiaMath.t_pathEnd(path)
dt       = 0.1
stopTime = 2.0 
time     = 0.0

while time &lt;= stopTime
   (rt, qt) = ModiaMath.interpolate(path, time*t_end/stopTime)
   time += dt
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.Quaternion" href="#ModiaMath.Frames.Quaternion"><code>ModiaMath.Frames.Quaternion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const ModiaMath.Quaternion = SVector{4,Float64}</code></pre><p>Describes the rotation from a frame 1 into a frame 2 with a quaternion vector. If <code>e</code> is the (normalized) axis of rotation to rotate frame 1 into frame 2 (either resolved in frame 1 or frame 2) and <code>angle</code> is the rotation angle for this rotation then the quaternion vector <code>q::ModiaMath.Quaternions</code> is defined as:</p><pre><code class="language-julia">q = [e*sin(angle/2),
       cos(angle/2]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.RotationMatrix" href="#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.Frames.RotationMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const ModiaMath.RotationMatrix = SMatrix{3,3,Float64,9}</code></pre><p>Describes the rotation from a frame 1 into a frame 2. An instance <code>R</code> of <code>RotationMatrix</code> has the following interpretation:</p><pre><code class="language-julia">R::RotationMatrix = [ex ey ez]   </code></pre><p>where <code>ex</code>, <code>ey</code>, <code>ez</code> are unit vectors in the direction of the x-axis, y-axis, and z-axis of frame 1, resolved in frame 2, respectively (for example ex=[1.0, 0.0, 0.0]) Therefore, if <code>v1</code> is vector <code>v</code> resolved in frame 1 and <code>v2</code> is vector <code>v</code> resolved in frame 2, the following relationship holds: </p><pre><code class="language-julia">v2 = R*v1   
v1 = R&#39;*v2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.Vector3D" href="#ModiaMath.Frames.Vector3D"><code>ModiaMath.Frames.Vector3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const ModiaMath.Vector3D = SVector{3,Float64}</code></pre><p>Type of a vector in 3D space (e.g. position vector of the origin of a frame)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.absoluteRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}" href="#ModiaMath.Frames.absoluteRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.Frames.absoluteRotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> R2 = ModiaMath.absoluteRotation(R1, R_rel) 
 q2 = ModiaMath.absoluteRotation(q1, q_rel)</code></pre><p>Return <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a><code>R2</code> or <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a><code>q2</code> defining the rotation from frame 0 to frame 2 from RotationMatrix <code>R1</code> or Quaternion <code>q1</code>that define the rotation from frame 0 to frame 1 and the relative RotationMatrix <code>R_rel</code> or the relative Quaternion <code>q_rel</code> that define the rotation from frame 1 to frame 2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.assertQuaternion-Tuple{AbstractArray{T,1} where T}" href="#ModiaMath.Frames.assertQuaternion-Tuple{AbstractArray{T,1} where T}"><code>ModiaMath.Frames.assertQuaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.assertQuaternion(q::AbstractVector)</code></pre><p>Assert that vector <code>q</code> has the properties of a <code>Quaternion</code> vector (has 4 elements, <code>norm(q) = 1</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.assertRotationMatrix-Tuple{AbstractArray{T,2} where T}" href="#ModiaMath.Frames.assertRotationMatrix-Tuple{AbstractArray{T,2} where T}"><code>ModiaMath.Frames.assertRotationMatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.assertRotationMatrix(R::AbstractMatrix)</code></pre><p>Assert that matrix R has the properties of a rotation matrix (is 3x3 and R&#39;*R - eye(3) = zeros(3,3))</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.eAxis-Tuple{Int64}" href="#ModiaMath.Frames.eAxis-Tuple{Int64}"><code>ModiaMath.Frames.eAxis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">e = eAxis(axis::Int)</code></pre><p>Return unit vector <code>e</code> in direction of axis <code>axis</code> (<code>axis</code> = 1,2,3 or -1,-2-,3).</p><p><strong>Example</strong></p><pre><code class="language-julia">import ModiaMath

e1 = ModiMath.eAxis(1)    # e1 = Vector3D(1.0,  0.0, 0.0)
e2 = ModiMath.eAxis(-2)   # d2 = Vector3D(0.0, -1.0, 0.0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.from_R-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}" href="#ModiaMath.Frames.from_R-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.Frames.from_R</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.from_R(R::ModiaMath.RotationMatrix;
                     q_guess = NullQuaternion)</code></pre><p>Return <code>Quaternion q</code> from <code>RotationMatrix R</code>.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.from_q-Tuple{StaticArrays.SArray{Tuple{4},Float64,1,4}}" href="#ModiaMath.Frames.from_q-Tuple{StaticArrays.SArray{Tuple{4},Float64,1,4}}"><code>ModiaMath.Frames.from_q</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.from_q(q::ModiaMath.Quaternion)</code></pre><p>Return RotationMatrix <code>R</code> from Quaternion <code>q</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.interpolate-Tuple{ModiaMath.Frames.Path,Number}" href="#ModiaMath.Frames.interpolate-Tuple{ModiaMath.Frames.Path,Number}"><code>ModiaMath.Frames.interpolate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(rt, qt) = ModiaMath.interpolate(path, t)</code></pre><p>Return position <code>rt</code>and Quaternion <code>qt</code> of <code>path::</code><a href="Frames.html#ModiaMath.Frames.Path"><code>ModiaMath.Path</code></a> at path parameter <code>t::Number</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.interpolate_r-Tuple{ModiaMath.Frames.Path,Number}" href="#ModiaMath.Frames.interpolate_r-Tuple{ModiaMath.Frames.Path,Number}"><code>ModiaMath.Frames.interpolate_r</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rt = ModiaMath.interpolate_r(path, t)</code></pre><p>Return position <code>r</code> of <code>path::</code><a href="Frames.html#ModiaMath.Frames.Path"><code>ModiaMath.Path</code></a> at path parameter <code>t::Number</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.inverseRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}" href="#ModiaMath.Frames.inverseRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.Frames.inverseRotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> R_inv = ModiaMath.inverseRotation(R) 
 q_inv = ModiaMath.inverseRotation(q)</code></pre><p>Return inverse <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a><code>R_inv</code> or inverse <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a><code>q_inv</code> defining the rotation from frame 1 to frame 0  from RotationMatrix <code>R</code> or Quaternion <code>q</code>that define the rotation from frame 0 to frame 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#ModiaMath.Frames.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>ModiaMath.Frames.planarRotationAngle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">angle = planarRotationAngle(e, v1, v2; angle_guess = 0.0)</code></pre><p>Return <code>angle</code> of a planar rotation, given the normalized axis of rotation to rotate frame 1 around <code>e</code> into frame 2 (norm(e) == 1 required), and the representations of a vector in frame 1 (<code>v1</code>) and frame 2 (<code>v2</code>). Hereby, it is required that <code>v1</code> is not parallel to <code>e</code>. The returned angle is in the range <code>-pi &lt;= angle - angle_guess &lt;= pi</code> (from the infinite many solutions, the one is returned that is closest to <code>angle_guess</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia">import ModiaMath
using Unitful

angle1 = 45u&quot;°&quot;
e      = normalize([1.0, 1.0, 1.0])
R      = ModiaMath.rot_e(e, angle1)

v1 = [1.0, 2.0, 3.0]
v2 = ModiaMath.resolve2(R, v1)

angle2 = planarRotationAngle(e, v1, v2)
isapprox(angle1, angle2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot1-Tuple{Number}" href="#ModiaMath.Frames.qrot1-Tuple{Number}"><code>ModiaMath.Frames.qrot1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot1(angle; q_guess = NullQuaternion)</code></pre><p>Return Quaternion <code>q</code> that rotates with angle <code>angle</code> along the x-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot123-Tuple{Number,Number,Number}" href="#ModiaMath.Frames.qrot123-Tuple{Number,Number,Number}"><code>ModiaMath.Frames.qrot123</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot123(angle1, angle2, angle3)</code></pre><p>Return Quaternion <code>q</code> by rotating with angle1 along the x-axis of frame 1, then with angle2 along the y-axis of this frame and then with angle3 along the z-axis of this frame.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot2-Tuple{Number}" href="#ModiaMath.Frames.qrot2-Tuple{Number}"><code>ModiaMath.Frames.qrot2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot2(angle; q_guess = NullQuaternion)</code></pre><p>Return Quaternion <code>q</code> that rotates with angle <code>angle</code> along the y-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot3-Tuple{Number}" href="#ModiaMath.Frames.qrot3-Tuple{Number}"><code>ModiaMath.Frames.qrot3</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot3(angle; q_guess = NullQuaternion)</code></pre><p>Return Quaternion <code>q</code> that rotates with angle <code>angle</code> along the z-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}" href="#ModiaMath.Frames.qrot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}"><code>ModiaMath.Frames.qrot_e</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot_e(e, angle; q_guess = NullQuaternion)</code></pre><p>Return Quaternion <code>q</code> that rotates with angle <code>angle</code> along unit axis <code>e</code>. This function assumes that <code>norm(e) == 1</code>.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer  to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.qrot_nxy-Tuple{Any,Any}" href="#ModiaMath.Frames.qrot_nxy-Tuple{Any,Any}"><code>ModiaMath.Frames.qrot_nxy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">q = ModiaMath.qrot_nxy(nx, ny)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>ny</code> are resolved in frame 1 and are directed along the x and y axis of frame 2. The function returns the Quaternion <code>q</code> to rotate from frame 1 to frame 2. </p><p>The function is robust in the sense that it returns always a Quaternion <code>q</code>, even if <code>ny</code> is not orthogonal to <code>nx</code> or if one or both vectors have zero length. This is performed in the following way:  If <code>nx</code> and <code>ny</code> are not orthogonal to each other, first a unit vector <code>ey</code> is  determined that is orthogonal to <code>nx</code> and is lying in the plane spanned by  <code>nx</code> and <code>ny</code>. If <code>nx</code> and <code>ny</code> are parallel or nearly parallel to each other  or <code>ny</code> is a vector with zero or nearly zero length, a vector <code>ey</code> is selected arbitrarily such that <code>ex</code> and <code>ey</code> are orthogonal to each other.  If both <code>nx</code> and <code>ny</code> are vectors with zero or nearly zero length, an arbitrary Quaternion <code>q</code> is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Unitful
import ModiaMath

q1 = ModiaMath.qrot1(90u&quot;°&quot;)
q2 = ModiaMath.qrot_nxy([1  , 0, 0], [0  , 0, 1  ])
q3 = ModiaMath.qrot_nxy([0.9, 0, 0], [1.1, 0, 1.1])
isapprox(q1,q2)   # returns true
isapprox(q1,q3)   # returns true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.relativeRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}" href="#ModiaMath.Frames.relativeRotation-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3,3},Float64,2,9}}"><code>ModiaMath.Frames.relativeRotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> R_rel = ModiaMath.relativeRotation(R1, R2) 
 q_rel = ModiaMath.relativeRotation(q1, q2)</code></pre><p>Return relative <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a><code>R_rel</code> or relative <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a><code>q_rel</code> defining the rotation from frame 1 to frame 2  from absolute RotationMatrix <code>R1</code> or absolute Quaternion <code>q1</code>that define the rotation from frame 0 to frame 1 and the absolute RotationMatrix <code>R2</code> or the absolute Quaternion <code>q2</code> that define the rotation from frame 0 to frame 2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.resolve1-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}" href="#ModiaMath.Frames.resolve1-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.Frames.resolve1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">v1 = ModiaMath.resolve1([R|q], v2)</code></pre><p>Transform vector v2 (v resolved in frame 2) to vector v1 (v resolved in frame 1) given either <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a> <code>R</code> or  <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a> <code>q</code> (to rotate a frame 1 into a frame 2).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.resolve2-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}" href="#ModiaMath.Frames.resolve2-Tuple{StaticArrays.SArray{Tuple{3,3},Float64,2,9},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.Frames.resolve2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">v2 = ModiaMath.resolve2([R|q], v1)</code></pre><p>Transform vector v1 (v resolved in frame 1) to vector v2 (v resolved in frame 2) given either <a href="Frames.html#ModiaMath.Frames.RotationMatrix"><code>ModiaMath.RotationMatrix</code></a> <code>R</code> or  <a href="Frames.html#ModiaMath.Frames.Quaternion"><code>ModiaMath.Quaternion</code></a> <code>q</code> (to rotate a frame 1 into a frame 2).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot1-Tuple{Number}" href="#ModiaMath.Frames.rot1-Tuple{Number}"><code>ModiaMath.Frames.rot1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot1(angle)</code></pre><p>Return RotationMatrix R that rotates with angle <code>angle</code> along the x-axis of frame 1. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot123-Tuple{Number,Number,Number}" href="#ModiaMath.Frames.rot123-Tuple{Number,Number,Number}"><code>ModiaMath.Frames.rot123</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot123(angle1, angle2, angle3)</code></pre><p>Return RotationMatrix R by rotating with angle1 along the x-axis of frame 1, then with angle2 along the y-axis of this frame and then with angle3 along the z-axis of this frame.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot2-Tuple{Number}" href="#ModiaMath.Frames.rot2-Tuple{Number}"><code>ModiaMath.Frames.rot2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot2(angle)</code></pre><p>Return RotationMatrix R that rotates with angle <code>angle</code> in [radian] along the y-axis of frame 1. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot3-Tuple{Number}" href="#ModiaMath.Frames.rot3-Tuple{Number}"><code>ModiaMath.Frames.rot3</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot3(angle)</code></pre><p>Return RotationMatrix R that rotates with angle <code>angle</code> in [radian] along the z-axis of frame 1. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}" href="#ModiaMath.Frames.rot_e-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},Number}"><code>ModiaMath.Frames.rot_e</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot_e(e, angle)</code></pre><p>Return RotationMatrix that rotates around angle <code>angle</code> along unit axis <code>e</code>. This function assumes that <code>norm(e) == 1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.rot_nxy-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}" href="#ModiaMath.Frames.rot_nxy-Tuple{StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>ModiaMath.Frames.rot_nxy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">R = ModiaMath.rot_nxy(nx, ny)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>ny</code> are resolved in frame 1 and are directed along the x and y axis of frame 2. The function returns the RotationMatrix R to rotate from frame 1 to frame 2. </p><p>The function is robust in the sense that it returns always a RotationMatrix R, even if <code>ny</code> is not orthogonal to <code>nx</code> or if one or both vectors have zero length. This is performed in the following way:  If <code>nx</code> and <code>ny</code> are not orthogonal to each other, first a unit vector <code>ey</code> is  determined that is orthogonal to <code>nx</code> and is lying in the plane spanned by  <code>nx</code> and <code>ny</code>. If <code>nx</code> and <code>ny</code> are parallel or nearly parallel to each other  or <code>ny</code> is a vector with zero or nearly zero length, a vector <code>ey</code> is selected arbitrarily such that <code>ex</code> and <code>ey</code> are orthogonal to each other.  If both <code>nx</code> and <code>ny</code> are vectors with zero or nearly zero length, an arbitrary rotation matrix is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Unitful
import ModiaMath

R1 = ModiaMath.rot1(90u&quot;°&quot;)
R2 = ModiaMath.rot_nxy([1  , 0, 0], [0  , 0, 1  ])
R3 = ModiaMath.rot_nxy([0.9, 0, 0], [1.1, 0, 1.1])
isapprox(R1,R2)   # returns true
isapprox(R1,R3)   # returns true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.skew-Tuple{AbstractArray{T,1} where T}" href="#ModiaMath.Frames.skew-Tuple{AbstractArray{T,1} where T}"><code>ModiaMath.Frames.skew</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">M = ModiaMath.skew(e::AbstractVector)</code></pre><p>Return the skew symmetric matrix <code>M::SMatrix{3,3,Float64,9}</code> of vector <code>e</code> (<code>length(e) = 3</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.Frames.t_pathEnd-Tuple{ModiaMath.Frames.Path}" href="#ModiaMath.Frames.t_pathEnd-Tuple{ModiaMath.Frames.Path}"><code>ModiaMath.Frames.t_pathEnd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t_end = ModiaMath.t_pathEnd(path::[`ModiaMath.Path`](@ref))</code></pre><p>Return the final path parameter <code>t</code>of the last frame in path (path parameter of first frame = 0.0).</p></div></div></section><footer><hr/><a class="previous" href="Logging.html"><span class="direction">Previous</span><span class="title">Logging</span></a><a class="next" href="Utilities.html"><span class="direction">Next</span><span class="title">Utilities</span></a></footer></article></body></html>
