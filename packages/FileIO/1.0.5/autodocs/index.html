<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FileIO.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FileIO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">FileIO.@format_str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.DataFormat" href="#FileIO.DataFormat"><code>FileIO.DataFormat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DataFormat{sym}()</code> indicates a known binary or text format of kind <code>sym</code>, where <code>sym</code> is always a symbol. For example, a .csv file might have <code>DataFormat{:CSV}()</code>.</p><p>An easy way to write <code>DataFormat{:CSV}</code> is <code>format&quot;CSV&quot;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.File" href="#FileIO.File"><code>FileIO.File</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>File(fmt, filename)</code> indicates that <code>filename</code> is a file of known DataFormat <code>fmt</code>.  For example, <code>File{fmtpng}(filename)</code> would indicate a PNG file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.FileIO" href="#FileIO.FileIO"><code>FileIO.FileIO</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><code>FileIO</code> API (brief summary, see individual functions for more detail):</p><ul><li><p><code>format&quot;PNG&quot;</code>: specifies a particular defined format</p></li><li><p><code>File{fmt}</code> and <code>Stream{fmt}</code>: types of objects that declare that a resource has a particular format <code>fmt</code></p></li><li><p><code>load([filename|stream])</code>: read data in formatted file, inferring the format</p></li><li><p><code>load(File(format&quot;PNG&quot;,filename))</code>: specify the format manually</p></li><li><p><code>loadstreaming([filename|stream])</code>: similar to <code>load</code>, except that it returns an object that can be read from</p></li><li><p><code>save(filename, data...)</code> for similar operations involving saving data</p></li><li><p><code>savestreaming([filename|stream])</code>: similar to <code>save</code>, except that it returns an object that can be written to</p></li><li><p><code>io = open(f::File, args...)</code> opens a file</p></li><li><p><code>io = stream(s::Stream)</code> returns the IOStream from the query object <code>s</code></p></li><li><p><code>query([filename|stream])</code>: attempt to infer the format of <code>filename</code></p></li><li><p><code>unknown(q)</code> returns true if a query can&#39;t be resolved</p></li><li><p><code>skipmagic(io, fmt)</code> sets the position of <code>io</code> to just after the magic bytes</p></li><li><p><code>magic(fmt)</code> returns the magic bytes for format <code>fmt</code></p></li><li><p><code>info(fmt)</code> returns <code>(magic, extensions)</code> for format <code>fmt</code></p></li><li><p><code>add_format(fmt, magic, extension)</code>: register a new format</p></li><li><p><code>add_loader(fmt, :Package)</code>: indicate that <code>Package</code> supports loading files of type <code>fmt</code></p></li><li><p><code>add_saver(fmt, :Package)</code>: indicate that <code>Package</code> supports saving files of type <code>fmt</code></p></li></ul></div></div></section><pre><code class="language-none">FileIO.Formatted</code></pre><pre><code class="language-none">FileIO.LOAD</code></pre><pre><code class="language-none">FileIO.Linux</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.LoaderError" href="#FileIO.LoaderError"><code>FileIO.LoaderError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>LoaderError</code> should be thrown when loader library code fails, and other libraries should be given the chance to recover from the error.  Reports the library name and an error message: LoaderError(&quot;ImageMagick&quot;, &quot;Foo not available&quot;)</p></div></div></section><pre><code class="language-none">FileIO.MimeWriter</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.NotInstalledError" href="#FileIO.NotInstalledError"><code>FileIO.NotInstalledError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>NotInstalledError</code> should be thrown when a library is currently not installed.</p></div></div></section><pre><code class="language-none">FileIO.OS</code></pre><pre><code class="language-none">FileIO.OSX</code></pre><pre><code class="language-none">FileIO.SAVE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.Stream" href="#FileIO.Stream"><code>FileIO.Stream</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Stream(fmt, io, [filename])</code> indicates that the stream <code>io</code> is written in known <code>Format</code>.  For example, <code>Stream{PNG}(io)</code> would indicate PNG format.  If known, the optional <code>filename</code> argument can be used to improve error messages, etc.</p></div></div></section><pre><code class="language-none">FileIO.Unix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.UnknownFormat" href="#FileIO.UnknownFormat"><code>FileIO.UnknownFormat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>UnknownFormat</code> gets thrown when FileIO can&#39;t recognize the format of a file.</p></div></div></section><pre><code class="language-none">FileIO.Windows</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.WriterError" href="#FileIO.WriterError"><code>FileIO.WriterError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>WriterError</code> should be thrown when writer library code fails, and other libraries should be given the chance to recover from the error.  Reports the library name and an error message: WriterError(&quot;ImageMagick&quot;, &quot;Foo not available&quot;)</p></div></div></section><pre><code class="language-none">FileIO._findmod</code></pre><pre><code class="language-none">FileIO.add_extension</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.add_format" href="#FileIO.add_format"><code>FileIO.add_format</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_format(fmt, magic, extention)</code> registers a new <code>DataFormat</code>. For example:</p><pre><code class="language-none">add_format(format&quot;PNG&quot;, (UInt8[0x4d,0x4d,0x00,0x2b], UInt8[0x49,0x49,0x2a,0x00]), [&quot;.tiff&quot;, &quot;.tif&quot;])
add_format(format&quot;PNG&quot;, [0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a], &quot;.png&quot;)
add_format(format&quot;NRRD&quot;, &quot;NRRD&quot;, [&quot;.nrrd&quot;,&quot;.nhdr&quot;])</code></pre><p>Note that extensions, magic numbers, and format-identifiers are case-sensitive.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.add_loader" href="#FileIO.add_loader"><code>FileIO.add_loader</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_loader(fmt, :Package)</code> triggers <code>using Package</code> before loading format <code>fmt</code></p></div></div></section><pre><code class="language-none">FileIO.add_loadsave</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.add_saver" href="#FileIO.add_saver"><code>FileIO.add_saver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>add_saver(fmt, :Package)</code> triggers <code>using Package</code> before saving format <code>fmt</code></p></div></div></section><pre><code class="language-none">FileIO.applicable_loaders</code></pre><pre><code class="language-none">FileIO.applicable_savers</code></pre><pre><code class="language-none">FileIO.applies_to_os</code></pre><pre><code class="language-none">FileIO.canonicalize_magic</code></pre><pre><code class="language-none">FileIO.checked_import</code></pre><pre><code class="language-none">FileIO.del_extension</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.del_format" href="#FileIO.del_format"><code>FileIO.del_format</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>del_format(fmt::DataFormat)</code> deletes <code>fmt</code> from the format registry.</p></div></div></section><pre><code class="language-none">FileIO.del_magic</code></pre><pre><code class="language-none">FileIO.detect_bedgraph</code></pre><pre><code class="language-none">FileIO.detect_noometiff</code></pre><pre><code class="language-none">FileIO.detect_ometiff</code></pre><pre><code class="language-none">FileIO.detect_rdata</code></pre><pre><code class="language-none">FileIO.detect_rdata_single</code></pre><pre><code class="language-none">FileIO.detect_stlascii</code></pre><pre><code class="language-none">FileIO.detect_stlbinary</code></pre><pre><code class="language-none">FileIO.detectavi</code></pre><pre><code class="language-none">FileIO.detecthdf5</code></pre><pre><code class="language-none">FileIO.detecttiff</code></pre><pre><code class="language-none">FileIO.detectwav</code></pre><pre><code class="language-none">FileIO.eval</code></pre><pre><code class="language-none">FileIO.ext2sym</code></pre><pre><code class="language-none">FileIO.file!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.file_extension" href="#FileIO.file_extension"><code>FileIO.file_extension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>file_extension(file)</code> returns the file extension associated with <code>File</code> <code>file</code>.</p></div></div><div><div><p><code>file_extension(file)</code> returns a nullable-string for the file extension associated with <code>Stream</code> <code>stream</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.filename" href="#FileIO.filename"><code>FileIO.filename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>filename(file)</code> returns the filename associated with <code>File</code> <code>file</code>.</p></div></div><div><div><p><code>filename(stream)</code> returns a string of the filename associated with <code>Stream</code> <code>stream</code>, or nothing if there is no file associated.</p></div></div></section><pre><code class="language-none">FileIO.getmodule</code></pre><pre><code class="language-none">FileIO.h5magic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.handle_current_error" href="#FileIO.handle_current_error"><code>FileIO.handle_current_error</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Handles error as soon as they get thrown while doing IO</p></div></div></section><pre><code class="language-none">FileIO.handle_error</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.handle_exceptions" href="#FileIO.handle_exceptions"><code>FileIO.handle_exceptions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Handles a list of thrown errors after no IO library was found working</p></div></div></section><pre><code class="language-none">FileIO.has_method_from</code></pre><pre><code class="language-none">FileIO.hasfunction</code></pre><pre><code class="language-none">FileIO.hasmagic</code></pre><pre><code class="language-none">FileIO.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.info" href="#FileIO.info"><code>FileIO.info</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>info(fmt)</code> returns the magic bytes/extension information for <code>DataFormat</code> <code>fmt</code>.</p></div></div></section><pre><code class="language-none">FileIO.is_installed</code></pre><pre><code class="language-none">FileIO.iter_eq</code></pre><pre><code class="language-none">FileIO.lensym</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.load" href="#FileIO.load"><code>FileIO.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><ul><li><code>load(filename)</code> loads the contents of a formatted file, trying to infer</li></ul><p>the format from <code>filename</code> and/or magic bytes in the file.</p><ul><li><code>load(strm)</code> loads from an <code>IOStream</code> or similar object. In this case,</li></ul><p>there is no filename extension, so we rely on the magic bytes for format identification.</p><ul><li><code>load(File(format&quot;PNG&quot;, filename))</code> specifies the format directly, and bypasses inference.</li><li><code>load(Stream(format&quot;PNG&quot;, io))</code> specifies the format directly, and bypasses inference.</li><li><code>load(f; options...)</code> passes keyword arguments on to the loader.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.loadstreaming" href="#FileIO.loadstreaming"><code>FileIO.loadstreaming</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Some packages may implement a streaming API, where the contents of the file can be read in chunks and processed, rather than all at once. Reading from these higher-level streams should return a formatted object, like an image or chunk of video or audio.</p><ul><li><code>loadstreaming(filename)</code> loads the contents of a formatted file, trying to infer</li></ul><p>the format from <code>filename</code> and/or magic bytes in the file. It returns a streaming type that can be read from in chunks, rather than loading the whole contents all at once</p><ul><li><code>loadstreaming(strm)</code> loads the stream from an <code>IOStream</code> or similar object.</li></ul><p>In this case, there is no filename extension, so we rely on the magic bytes for format identification.</p><ul><li><code>loadstreaming(File(format&quot;WAV&quot;,filename))</code> specifies the format directly, and</li></ul><p>bypasses inference.</p><ul><li><code>loadstreaming(Stream(format&quot;WAV&quot;, io))</code> specifies the format directly, and</li></ul><p>bypasses inference.</p><ul><li><code>loadstreaming(f; options...)</code> passes keyword arguments on to the loader.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.magic" href="#FileIO.magic"><code>FileIO.magic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>magic(fmt)</code> returns the magic bytes of format <code>fmt</code></p></div></div></section><pre><code class="language-none">FileIO.magic_cmp</code></pre><pre><code class="language-none">FileIO.magic_equal</code></pre><pre><code class="language-none">FileIO.magic_func</code></pre><pre><code class="language-none">FileIO.magic_list</code></pre><pre><code class="language-none">FileIO.metadata</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.query" href="#FileIO.query"><code>FileIO.query</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>query(filename)</code> returns a <code>File</code> object with information about the format inferred from the file&#39;s extension and/or magic bytes.</p></div></div><div><div><p><code>query(io, [filename])</code> returns a <code>Stream</code> object with information about the format inferred from the magic bytes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.save" href="#FileIO.save"><code>FileIO.save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><ul><li><code>save(filename, data...)</code> saves the contents of a formatted file,</li></ul><p>trying to infer the format from <code>filename</code>.</p><ul><li><code>save(Stream(format&quot;PNG&quot;,io), data...)</code> specifies the format directly, and bypasses inference.</li><li><code>save(File(format&quot;PNG&quot;,filename), data...)</code> specifies the format directly, and bypasses inference.</li><li><code>save(f, data...; options...)</code> passes keyword arguments on to the saver.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.savestreaming" href="#FileIO.savestreaming"><code>FileIO.savestreaming</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Some packages may implement a streaming API, where the contents of the file can be written in chunks, rather than all at once. These higher-level streams should accept formatted objects, like an image or chunk of video or audio.</p><ul><li><code>savestreaming(filename, data...)</code> saves the contents of a formatted file,</li></ul><p>trying to infer the format from <code>filename</code>.</p><ul><li><code>savestreaming(File(format&quot;WAV&quot;,filename))</code> specifies the format directly, and</li></ul><p>bypasses inference.</p><ul><li><code>savestreaming(Stream(format&quot;WAV&quot;, io))</code> specifies the format directly, and</li></ul><p>bypasses inference.</p><ul><li><code>savestreaming(f, data...; options...)</code> passes keyword arguments on to the saver.</li></ul></div></div></section><pre><code class="language-none">FileIO.seekable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.skipmagic" href="#FileIO.skipmagic"><code>FileIO.skipmagic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>skipmagic(s)</code> sets the position of <code>Stream</code> <code>s</code> to be just after the magic bytes. For a plain IO object, you can use <code>skipmagic(io, fmt)</code>.</p></div></div></section><pre><code class="language-none">FileIO.split_predicates</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.stream" href="#FileIO.stream"><code>FileIO.stream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>stream(s)</code> returns the stream associated with <code>Stream</code> <code>s</code></p></div></div></section><pre><code class="language-none">FileIO.sym2info</code></pre><pre><code class="language-none">FileIO.sym2loader</code></pre><pre><code class="language-none">FileIO.sym2saver</code></pre><pre><code class="language-none">FileIO.tiff_magic</code></pre><pre><code class="language-none">FileIO.topimport</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.unknown" href="#FileIO.unknown"><code>FileIO.unknown</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>unknown(f)</code> returns true if the format of <code>f</code> is unknown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.unknown_df" href="#FileIO.unknown_df"><code>FileIO.unknown_df</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DataFormat{sym}()</code> indicates a known binary or text format of kind <code>sym</code>, where <code>sym</code> is always a symbol. For example, a .csv file might have <code>DataFormat{:CSV}()</code>.</p><p>An easy way to write <code>DataFormat{:CSV}</code> is <code>format&quot;CSV&quot;</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
