<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ImageSegmentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ImageSegmentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.ImageEdge" href="#ImageSegmentation.ImageEdge"><code>ImageSegmentation.ImageEdge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">edge = ImageEdge(index1, index2, weight)</code></pre><p>Construct an edge in a Region Adjacency Graph. <code>index1</code> and <code>index2</code> are the integers corresponding to individual pixels/voxels (in the sense of linear indexing via <code>sub2ind</code>), and <code>weight</code> is the edge weight (measures the dissimilarity between pixels/voxels).</p></div></div></section><pre><code class="language-none">ImageSegmentation.ImageSegmentation</code></pre><pre><code class="language-none">ImageSegmentation.PixelKey</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.SegmentedImage" href="#ImageSegmentation.SegmentedImage"><code>ImageSegmentation.SegmentedImage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SegmentedImage</code> type contains the index-label mapping, assigned labels, segment mean intensity and pixel count of each segment.</p></div></div></section><pre><code class="language-none">ImageSegmentation._colon</code></pre><pre><code class="language-none">ImageSegmentation.adaptive_thres</code></pre><pre><code class="language-none">ImageSegmentation.default_diff_fn</code></pre><pre><code class="language-none">ImageSegmentation.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.fast_scanning" href="#ImageSegmentation.fast_scanning"><code>ImageSegmentation.fast_scanning</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seg_img = fast_scanning(img, threshold, [diff_fn])</code></pre><p>Segments the N-D image using a fast scanning algorithm and returns a <a href="#ImageSegmentation.SegmentedImage"><code>SegmentedImage</code></a> containing information about the segments.</p><p><strong>Arguments:</strong></p><ul><li><code>img</code>         : N-D image to be segmented (arbitrary axes are allowed)</li><li><code>threshold</code>   : Upper bound of the difference measure (δ) for considering                 pixel into same segment; an <code>AbstractArray</code> can be passed                 having same number of dimensions as that of <code>img</code> for adaptive                 thresholding</li><li><code>diff_fn</code>     : (Optional) Function that returns a difference measure (δ)                 between the mean color of a region and color of a point</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; img = zeros(Float64, (3,3));

julia&gt; img[2,:] .= 0.5;

julia&gt; img[:,2] .= 0.6;

julia&gt; seg = fast_scanning(img, 0.2);

julia&gt; labels_map(seg)
3×3 Array{Int64,2}:
 1  4  5
 4  4  4
 3  4  6</code></pre><p><strong>Citation:</strong></p><p>Jian-Jiun Ding, Cheng-Jin Kuo, Wen-Chih Hong, &quot;An efficient image segmentation technique by fast scanning and adaptive merging&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.felzenszwalb" href="#ImageSegmentation.felzenszwalb"><code>ImageSegmentation.felzenszwalb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segments                = felzenszwalb(img, k, [min_size])
index_map, num_segments = felzenszwalb(edges, num_vertices, k, [min_size])</code></pre><p>Segments an image using Felzenszwalb&#39;s graph-based algorithm. The function can be used in either of two ways -</p><ol><li><code>segments = felzenszwalb(img, k, [min_size])</code></li></ol><p>Segments an image using Felzenszwalb&#39;s segmentation algorithm and returns the result as <code>SegmentedImage</code>. The algorithm uses euclidean distance in color space as edge weights for the region adjacency graph.</p><p>Parameters:</p><ul><li>img            = input image</li><li>k              = Threshold for region merging step. Larger threshold will result in bigger segments.</li><li>min_size       = Minimum segment size</li></ul><ol><li><code>index_map, num_segments = felzenszwalb(edges, num_vertices, k, [min_size])</code></li></ol><p>Segments an image represented as Region Adjacency Graph(RAG) using Felzenszwalb&#39;s segmentation algorithm. Each pixel/region  corresponds to a node in the graph and weights on each edge measure the dissimilarity between pixels. The function returns the number of segments and index mapping from nodes of the RAG to segments.</p><p>Parameters:</p><ul><li>edges          = Array of edges in RAG. Each edge is represented as <code>ImageEdge</code>.</li><li>num_vertices   = Number of vertices in RAG</li><li>k              = Threshold for region merging step. Larger threshold will result in bigger segments.</li><li>min_size       = Minimum segment size</li></ul></div></div></section><pre><code class="language-none">ImageSegmentation.fill_recursive!</code></pre><pre><code class="language-none">ImageSegmentation.fuzzy_cmeans</code></pre><pre><code class="language-none">ImageSegmentation.getscalar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.hmin_transform" href="#ImageSegmentation.hmin_transform"><code>ImageSegmentation.hmin_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">out = hmin_transform(img, h)</code></pre><p>Suppresses all minima in grayscale image whose depth is less than h.</p><p>H-minima transform is defined as the reconstruction by erosion of (img + h) by img. See Morphological image analysis by Soille pg 170-172.</p></div></div></section><pre><code class="language-none">ImageSegmentation.img_to_data</code></pre><pre><code class="language-none">ImageSegmentation.include</code></pre><pre><code class="language-none">ImageSegmentation.kmeans</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.labels_map" href="#ImageSegmentation.labels_map"><code>ImageSegmentation.labels_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">img_labeled = labels_map(seg)</code></pre><p>Return an array containing the label assigned to each pixel.</p></div></div></section><pre><code class="language-none">ImageSegmentation.makebt</code></pre><pre><code class="language-none">ImageSegmentation.makert</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.meanshift" href="#ImageSegmentation.meanshift"><code>ImageSegmentation.meanshift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segments                = meanshift(img, spatial_radius, range_radius; iter=50, eps=0.01))</code></pre><p>Segments the image using meanshift clustering. Returns a <code>SegmentedImage</code>.</p><p>Parameters:</p><ul><li>img                            = input grayscale image</li><li>spatial<em>radius/range</em>radius    = bandwidth parameters of truncated normal kernel. Controlling the size of the kernel determines the resolution of the mode detection.</li><li>iter/eps                       = stopping criterion for meanshift procedure. The algorithm stops after iter iterations or if kernel center moves less than eps distance in an update step, whichever comes first.</li></ul></div></div></section><pre><code class="language-none">ImageSegmentation.meantype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.prune_segments" href="#ImageSegmentation.prune_segments"><code>ImageSegmentation.prune_segments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">new_seg = prune_segments(seg, rem_labels, diff_fn)</code></pre><p>Removes all segments that have labels in <code>rem_labels</code> replacing them with their neighbouring segment having least <code>diff_fn</code>. <code>rem_labels</code> is a <code>Vector</code> of labels.</p><pre><code class="language-none">new_seg = prune_segments(seg, is_rem, diff_fn)</code></pre><p>Removes all segments for which <code>is_rem</code> returns true replacing them with their neighbouring segment having least <code>diff_fn</code>.</p><pre><code class="language-none">is_rem(label) -&gt; Bool</code></pre><p>Returns true if label <code>label</code> is to be removed otherwise false.</p><pre><code class="language-none">d = diff_fn(rem_label, neigh_label)</code></pre><p>A difference measure between label to be removed and its neighbors. <code>isless</code> must be defined for objects of the type of <code>d</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.region_adjacency_graph" href="#ImageSegmentation.region_adjacency_graph"><code>ImageSegmentation.region_adjacency_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">G, vert_map = region_adjacency_graph(seg, weight_fn)</code></pre><p>Constructs a region adjacency graph (RAG) from the <code>SegmentedImage</code>. It returns the RAG along with a Dict(label=&gt;vertex) map. <code>weight_fn</code> is used to assign weights to the edges.</p><pre><code class="language-none">weight_fn(label1, label2)</code></pre><p>Returns a real number corresponding to the weight of the edge between label1 and label2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.region_splitting" href="#ImageSegmentation.region_splitting"><code>ImageSegmentation.region_splitting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seg = region_splitting(img, homogeneous)</code></pre><p>Segments <code>img</code> by recursively splitting it until all the segments are homogeneous.</p><pre><code class="language-none">b = homogeneous(img)</code></pre><p>Returns true if <code>img</code> is homogeneous.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; img = 0.1*rand(6, 6);

julia&gt; img[4:end, 4:end] .+= 10;

julia&gt; function homogeneous(img)
           min, max = extrema(img)
           max - min &lt; 0.2
       end
homogeneous (generic function with 1 method)

julia&gt; seg = region_splitting(img, homogeneous);</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.region_tree" href="#ImageSegmentation.region_tree"><code>ImageSegmentation.region_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">t = region_tree(img, homogeneous)</code></pre><p>Creates a region tree from <code>img</code> by splitting it recursively until all the regions are homogeneous.</p><pre><code class="language-none">b = homogeneous(img)</code></pre><p>Returns true if <code>img</code> is homogeneous.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; img = 0.1*rand(6, 6);

julia&gt; img[4:end, 4:end] .+= 10;

julia&gt; function homogeneous(img)
           min, max = extrema(img)
           max - min &lt; 0.2
       end
homogeneous (generic function with 1 method)

julia&gt; t = region_tree(img, homogeneous);</code></pre></div></div></section><pre><code class="language-none">ImageSegmentation.region_tree!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.rem_segment" href="#ImageSegmentation.rem_segment"><code>ImageSegmentation.rem_segment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">new_seg = rem_segment(seg, label, diff_fn)</code></pre><p>Removes the segment having label <code>label</code> and returns the new <code>SegmentedImage</code>. For more info, see <a href="@ref"><code>remove_segment!</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.rem_segment!" href="#ImageSegmentation.rem_segment!"><code>ImageSegmentation.rem_segment!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem_segment!(seg, label, diff_fn)</code></pre><p>In place removal of the segment having label <code>label</code>, replacing it with the neighboring segment having least <code>diff_fn</code> value.</p><pre><code class="language-none">d = diff_fn(rem_label, neigh_label)</code></pre><p>A difference measure between label to be removed and its neighbors. <code>isless</code> must be defined for objects of the type of <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">    # This removes the label `l` and replaces it with the label of
    # neighbor having maximum pixel count.
    julia&gt; rem_segment!(seg, l, (i,j)-&gt;(-seg.segment_pixel_count[j]))

    # This removes the label `l` and replaces it with the label of
    # neighbor having the least value of euclidian metric.
    julia&gt; rem_segment!(seg, l, (i,j)-&gt;sum(abs2, seg.segment_means[i]-seg.segment_means[j]))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.seeded_region_growing" href="#ImageSegmentation.seeded_region_growing"><code>ImageSegmentation.seeded_region_growing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seg_img = seeded_region_growing(img, seeds, [kernel_dim], [diff_fn])
seg_img = seeded_region_growing(img, seeds, [neighbourhood], [diff_fn])</code></pre><p>Segments the N-D image <code>img</code> using the seeded region growing algorithm and returns a <a href="#ImageSegmentation.SegmentedImage"><code>SegmentedImage</code></a> containing information about the segments.</p><p><strong>Arguments:</strong></p><ul><li><code>img</code>             :  N-D image to be segmented (arbitrary axes are allowed)</li><li><code>seeds</code>           :  <code>Vector</code> containing seeds. Each seed is a Tuple of a                      CartesianIndex{N} and a label. See below note for more                      information on labels.</li><li><code>kernel_dim</code>      :  (Optional) <code>Vector{Int}</code> having length N or a <code>NTuple{N,Int}</code>                      whose ith element is an odd positive integer representing                      the length of the ith edge of the N-orthotopic neighbourhood</li><li><code>neighbourhood</code>   :  (Optional) Function taking CartesianIndex{N} as input and                      returning the neighbourhood of that point.</li><li><code>diff_fn</code>         :  (Optional) Function that returns a difference measure(δ)                      between the mean color of a region and color of a point</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The labels attached to points must be positive integers, although multiple points can be assigned the same label. The output includes a labelled array that has same indexing as that of input image. Every index is assigned to either one of labels or a special label &#39;0&#39; indicating that the algorithm was unable to assign that index to a unique label.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; img = zeros(Gray{N0f8},4,4);

julia&gt; img[2:4,2:4] .= 1;

julia&gt; seeds = [(CartesianIndex(3,1),1),(CartesianIndex(2,2),2)];

julia&gt; seg = seeded_region_growing(img, seeds);

julia&gt; labels_map(seg)
4×4 Array{Int64,2}:
 1  1  1  1
 1  2  2  2
 1  2  2  2
 1  2  2  2</code></pre><p><strong>Citation:</strong></p><p>Albert Mehnert, Paul Jackaway (1997), &quot;An improved seeded region growing algorithm&quot;, Pattern Recognition Letters 18 (1997), 1065-1071</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.segment_labels" href="#ImageSegmentation.segment_labels"><code>ImageSegmentation.segment_labels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">labels = segment_labels(seg)</code></pre><p>Returns the list of assigned labels</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.segment_mean" href="#ImageSegmentation.segment_mean"><code>ImageSegmentation.segment_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">m = segment_mean(seg, l)</code></pre><p>Returns the mean intensity of label <code>l</code>. If no label is supplied, it returns a Dict(label=&gt;mean) of all the labels.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.segment_pixel_count" href="#ImageSegmentation.segment_pixel_count"><code>ImageSegmentation.segment_pixel_count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">c = segment_pixel_count(seg, l)</code></pre><p>Returns the count of pixels that are assigned label <code>l</code>. If no label is supplied, it returns a Dict(label=&gt;pixel_count) of all the labels.</p></div></div></section><pre><code class="language-none">ImageSegmentation.sharpness</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.unseeded_region_growing" href="#ImageSegmentation.unseeded_region_growing"><code>ImageSegmentation.unseeded_region_growing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seg_img = unseeded_region_growing(img, threshold, [kernel_dim], [diff_fn])
seg_img = unseeded_region_growing(img, threshold, [neighbourhood], [diff_fn])</code></pre><p>Segments the N-D image using automatic (unseeded) region growing algorithm and returns a <a href="#ImageSegmentation.SegmentedImage"><code>SegmentedImage</code></a> containing information about the segments.</p><p><strong>Arguments:</strong></p><ul><li><code>img</code>             :  N-D image to be segmented (arbitrary axes are allowed)</li><li><code>threshold</code>       :  Upper bound of the difference measure (δ) for considering                      pixel into same segment</li><li><code>kernel_dim</code>      :  (Optional) <code>Vector{Int}</code> having length N or a <code>NTuple{N,Int}</code>                      whose ith element is an odd positive integer representing                      the length of the ith edge of the N-orthotopic neighbourhood</li><li><code>neighbourhood</code>   :  (Optional) Function taking CartesianIndex{N} as input and                      returning the neighbourhood of that point.</li><li><code>diff_fn</code>         :  (Optional) Function that returns a difference measure (δ)                      between the mean color of a region and color of a point</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; img = zeros(Gray{N0f8},4,4);

julia&gt; img[2:4,2:4] .= 1;

julia&gt; seg = unseeded_region_growing(img, 0.2);

julia&gt; labels_map(seg)
4×4 Array{Int64,2}:
 1  1  1  1
 1  2  2  2
 1  2  2  2
 1  2  2  2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageSegmentation.watershed" href="#ImageSegmentation.watershed"><code>ImageSegmentation.watershed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segments                = watershed(img, markers)</code></pre><p>Segments the image using watershed transform. Each basin formed by watershed transform corresponds to a segment. If you are using image local minimas as markers, consider using <a href="#ImageSegmentation.hmin_transform"><code>hmin_transform</code></a> to avoid oversegmentation.</p><p>Parameters:</p><ul><li>img            = input grayscale image</li><li>markers        = An array (same size as img) with each region&#39;s marker assigned a index starting from 1. Zero means not a marker.                     If two markers have the same index, their regions will be merged into a single region.                     If you have markers as a boolean array, use <code>label_components</code>.</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
