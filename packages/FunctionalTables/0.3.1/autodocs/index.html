<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FunctionalTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FunctionalTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnOrdering" href="#FunctionalTables.ColumnOrdering"><code>FunctionalTables.ColumnOrdering</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ColumnOrdering{K, R}</code></pre><p>Ordering specification for a column. <code>K::Symbol</code> is a key for ordering by <code>isless</code>, <code>R::Bool == true</code> reverses that for this key. <em>Internal.</em></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnOrderingSpecification" href="#FunctionalTables.ColumnOrderingSpecification"><code>FunctionalTables.ColumnOrderingSpecification</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Types accepted as valid column ordering specifications in the user API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.FunctionalTable" href="#FunctionalTables.FunctionalTable"><code>FunctionalTables.FunctionalTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct FunctionalTable{C&lt;:NamedTuple, O&lt;:Tuple{Vararg{FunctionalTables.ColumnOrdering,N} where N}}</code></pre><p><strong>Internal notes</strong></p><ul><li><p>Use accessors <code>length</code>, <code>colums</code>, and <code>ordering</code> to access the fields, property accessors are forwarded to <code>columns</code>.</p></li><li><p>The only inner constructor is the one where both the length and the ordering is trusted (and thus unchecked). Outer constructors should first wrap the ordering rule, then compute/verify length.</p></li></ul></div></div></section><pre><code class="language-none">FunctionalTables.FunctionalTables</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.Key" href="#FunctionalTables.Key"><code>FunctionalTables.Key</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for keys, used internally.</p></div></div></section><pre><code class="language-none">FunctionalTables.Keys</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.OrderingRule" href="#FunctionalTables.OrderingRule"><code>FunctionalTables.OrderingRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct OrderingRule{R, O&lt;:Tuple{Vararg{FunctionalTables.ColumnOrdering,N} where N}}</code></pre><p>Rule for dealing with specified orderings. Verifies key uniqueness.</p><p>See <a href="#FunctionalTables.VerifyOrdering"><code>VerifyOrdering</code></a>, <a href="#FunctionalTables.TrustOrdering"><code>TrustOrdering</code></a>, and <a href="#FunctionalTables.TryOrdering"><code>TryOrdering</code></a>.</p><p>This type and its methods are <em>internal</em>.</p></div></div></section><pre><code class="language-none">FunctionalTables.Picking</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RLEVector" href="#FunctionalTables.RLEVector"><code>FunctionalTables.RLEVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RLEVector{C, T, S, anyS}</code></pre><p>An RLE encoded vector, using negative lengths for missing values. Use the <code>RLEVector{S}(C, T)</code> constructor for creating an empty one.</p><p>When an elemenet in <code>counts</code> is positive, it encodes that many of the corresponding element in <code>data</code>.</p><p>Negative <code>counts</code> encode values of type <code>S</code> (has to be a concrete singleton). In this case there is no corresponding value in <code>data</code>, ie <code>data</code> may have <em>fewer elements</em> than <code>counts</code>. Note that <code>0</code> values in count are reserved, and currently should not happen.</p><p>The flag <code>anyS::Bool</code> is <code>true</code> iff there are <em>any</em> values of type <code>S</code> in object.</p><p>An RLEVector is iterable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RepeatRow" href="#FunctionalTables.RepeatRow"><code>FunctionalTables.RepeatRow</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>RepeatRow(row)</p><p>A row repeated as many times as needed. Can be <code>merge</code>d to a <code>FunctionalTable</code>, or instantiated with <code>FunctionalTable(len, repeat_row)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RepeatValue" href="#FunctionalTables.RepeatValue"><code>FunctionalTables.RepeatValue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>RepeatValue(value, len)</p><p>Equivalent to a vector containing <code>len</code> instances of <code>value</code>. Used <em>internally</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SHOWROWS" href="#FunctionalTables.SHOWROWS"><code>FunctionalTables.SHOWROWS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Shows this many values from each column in a <code>FunctionalTable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SINKCONFIG" href="#FunctionalTables.SINKCONFIG"><code>FunctionalTables.SINKCONFIG</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Default sink configuration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SINKVECTORS" href="#FunctionalTables.SINKVECTORS"><code>FunctionalTables.SINKVECTORS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Sink configuration that collects to vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SinkConfig" href="#FunctionalTables.SinkConfig"><code>FunctionalTables.SinkConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SinkConfig{useRLE, M}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SplitTable" href="#FunctionalTables.SplitTable"><code>FunctionalTables.SplitTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SplitTable{K&lt;:NamedTuple, B&lt;:NamedTuple, O&lt;:Tuple{Vararg{FunctionalTables.ColumnOrdering,N} where N}, T&lt;:FunctionalTable}</code></pre><p>Implements <a href="#FunctionalTables.by"><code>by</code></a> using an iterator.</p><p><strong>Internals</strong></p><p>Each rows from the underlying <code>FunctionalTable</code> is split into <code>index</code> and <code>rest</code>.</p><p>Iterator state is</p><ol><li><p><code>nothing</code> when the rows of the underlying FunctionalTable have been exhausted,</p></li><li><p><code>index</code>, <code>rest</code>, <code>itrstate</code> for the next block, where <code>index</code> and <code>rest</code> are the first</p></li></ol><p>(mismatching) row that has <em>not</em> been pushed to the buffers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TableOrdering" href="#FunctionalTables.TableOrdering"><code>FunctionalTables.TableOrdering</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Shorthand for table ordering. <em>Internal.</em></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrustLength" href="#FunctionalTables.TrustLength"><code>FunctionalTables.TrustLength</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct TrustLength</code></pre><p>Wrapper type to indicate that the length should not be checked.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The perfect footgun. Only use when the lengths are known and verified by construction.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrustOrdering" href="#FunctionalTables.TrustOrdering"><code>FunctionalTables.TrustOrdering</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Accept the specified ordering to hold without any checks (except for verifying that column names are valid).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This can lead to incorrect results, use cautiously. <a href="#FunctionalTables.VerifyOrdering"><code>VerifyOrdering</code></a> is recommended instead as it has little overhead.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TryOrdering" href="#FunctionalTables.TryOrdering"><code>FunctionalTables.TryOrdering</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Try the specified ordering, when necesary degrade to a subset of it that holds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.VerifyOrdering" href="#FunctionalTables.VerifyOrdering"><code>FunctionalTables.VerifyOrdering</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Verify that the specified ordering holds. This is the default ordering rule.</p></div></div></section><pre><code class="language-none">FunctionalTables.Wrapping</code></pre><pre><code class="language-none">FunctionalTables._cmp_table_ordering</code></pre><pre><code class="language-none">FunctionalTables._retained_table_ordering</code></pre><pre><code class="language-none">FunctionalTables._showcolcontents</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.aggregator" href="#FunctionalTables.aggregator"><code>FunctionalTables.aggregator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">aggregator(f)
</code></pre><p>Wrap a function so that it maps columns of a <code>FunctionalTable</code> to a table with a single row, columwise, ignoring the index. Returns a closure.</p><p><strong>Example</strong></p><pre><code class="language-julia">map(aggregator(mean), by(ft, :col))</code></pre><p>will calculate means after grouping by <code>:col</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.append1" href="#FunctionalTables.append1"><code>FunctionalTables.append1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append1(v, elt)
</code></pre><p>Append <code>elt</code> to <code>v</code>, allocating a new vector and copying the contents.</p><p>Type of new collection is calculated using <code>promote_type</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.by" href="#FunctionalTables.by"><code>FunctionalTables.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">by(ft, splitkeys)
</code></pre><p>An iterator that groups rows of tables by the columns <code>splitkeys</code>, returning <code>(index::NamedTupe, table::FunctionalTable)</code> for each contiguous block of the index keys.</p><p>The function has a convenience form <code>by(ft, splitkeys...; ...)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cancontain" href="#FunctionalTables.cancontain"><code>FunctionalTables.cancontain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cancontain(T, elt)
</code></pre><p>Test if a collection of element type <code>T</code> can contain a new element <code>elt</code> without <em>any</em> loss of precision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cmp_ordering" href="#FunctionalTables.cmp_ordering"><code>FunctionalTables.cmp_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cmp_ordering(ordering, a, b)
</code></pre><p>Compare <code>a</code> and <code>b</code> given the <code>ordering</code>.</p><p><em>Internal</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_column" href="#FunctionalTables.collect_column"><code>FunctionalTables.collect_column</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collect_column(cfg, itr)
</code></pre><p>Collect results from <code>itr</code> into a sink (using config <code>cfg</code>), then finalize and return the column.</p></div></div></section><pre><code class="language-none">FunctionalTables.collect_column!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_columns" href="#FunctionalTables.collect_columns"><code>FunctionalTables.collect_columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>len, columns, ordering_rule = </p><pre><code class="language-julia">collect_columns(cfg, itr, ordering_rule)
collect_columns(cfg, itr, ordering_rule, known_types)
</code></pre><p>Collect results from <code>itr</code>, which are supposed to be <code>NamedTuple</code>s with the same names, into sinks (using config <code>cfg</code>), then finalize and return</p><ol><li><p>the length,</p></li><li><p>the <code>NamedTuple</code> of the columns, and</p></li><li><p>the ordering rule (which is always <code>::TrustOrdering</code>, by construction).</p></li></ol><p>Determine the names and types from the first named tuple, using <code>known_types</code> as the narrowest types for the given columns.</p><p><strong>Special rules for empty iterators</strong></p><p>When <code>itr</code> is empty, use a <code>known_types</code> will be used to create empty columns, and only the <code>TryOrdering</code> rule will be narrowed to these. Other rule with more column names may cause an error in the callee, which is intentional.</p></div></div></section><pre><code class="language-none">FunctionalTables.collect_columns!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.columns" href="#FunctionalTables.columns"><code>FunctionalTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">columns(ft)
</code></pre><p>Return the columns in a <code>NamedTuple</code>.</p><p>Each column is an iterable, but not necessarily an <code>&lt;: AbstractVector</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Never mutate columns obtained by this method</strong>, as that will violate invariants assumed by the implementation. Use <code>map(collect, columns(ft))</code> or similar to obtain mutable vectors.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.empty_sinks" href="#FunctionalTables.empty_sinks"><code>FunctionalTables.empty_sinks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">empty_sinks(cfg, ?)
</code></pre><p>Empty sinks for a named tuple of elements, using a type.</p></div></div></section><pre><code class="language-none">FunctionalTables.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sink" href="#FunctionalTables.finalize_sink"><code>FunctionalTables.finalize_sink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finalize_sink(?, sink)
</code></pre><p>Convert <code>sink</code> to a <em>column</em>.</p><p><code>sink</code> may share structure with the result and is not supposed to be used for saving any more elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sinks" href="#FunctionalTables.finalize_sinks"><code>FunctionalTables.finalize_sinks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finalize_sinks(cfg, sinks)
</code></pre><p>Finalize a (named) tuple of sinks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.fuse" href="#FunctionalTables.fuse"><code>FunctionalTables.fuse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fuse(f, index, tables)
</code></pre><p>Prepend the <code>index</code> as repeated columns to <code>f(index, tables...)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ignoreindex" href="#FunctionalTables.ignoreindex"><code>FunctionalTables.ignoreindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ignoreindex(f)
</code></pre><p>Wrap a function returning a closure that ignores the first argument (the index in <a href="#FunctionalTables.by"><code>by</code></a> mappings).</p></div></div></section><pre><code class="language-none">FunctionalTables.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.is_prefix" href="#FunctionalTables.is_prefix"><code>FunctionalTables.is_prefix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_prefix(a, b)
</code></pre><p>Test if <code>b</code> starts with <code>a</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.isless_ordering</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.key_in" href="#FunctionalTables.key_in"><code>FunctionalTables.key_in</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">key_in(key, keys)
</code></pre><p>Check if a <code>key</code> is in <code>itr</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.key_issubset</code></pre><pre><code class="language-none">FunctionalTables.key_setdiff</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.make_sink" href="#FunctionalTables.make_sink"><code>FunctionalTables.make_sink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_sink(cfg, ?)
</code></pre><p>Create and return a sink using configuration <code>cfg</code> that stores elements of type <code>T</code>. When <code>T</code> is unkown, use <code>Base.Bottom</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.mask_ordering" href="#FunctionalTables.mask_ordering"><code>FunctionalTables.mask_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mask_ordering(ordering, keys)
mask_ordering(ordering, keys, invert)
</code></pre><p>When <code>invert == false</code>, keep the initial part of ordering that has keys in <code>keys</code>. Not having a key in <code>keys</code> invalidates the tail ordering from that point. This is useful for selecting subsets of orderings.</p><p>When <code>invert == true</code>, <em>having a key</em> in <code>keys</code> invalidates the ordering. This is useful for orderings of merged and dropped columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.mask_try_ordering" href="#FunctionalTables.mask_try_ordering"><code>FunctionalTables.mask_try_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mask_try_ordering(ordering_rule, keys)
</code></pre><p>For <code>TryOrdering</code>, return a masked ordering rule that is is defined on <code>keys</code> so that comparisons make sense, otherwise return the original <code>ordering_rule</code> (that will just error for undefined keys).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.merge_default_types" href="#FunctionalTables.merge_default_types"><code>FunctionalTables.merge_default_types</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">merge_default_types(rowtype, defaults)
</code></pre><p>Whenever <code>defaults</code> has a given key, use the corresponding type in <code>rowtype</code>, otherwise <code>Union{}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.narrow" href="#FunctionalTables.narrow"><code>FunctionalTables.narrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">narrow(x)
</code></pre><p>Convert the argument to a narrower type if possible without losing precision.</p><p>!!! NOTE     This function is not type stable, use only when new container types are determined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ordering" href="#FunctionalTables.ordering"><code>FunctionalTables.ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ordering(ft)
</code></pre><p>Return the ordering of the table, which is a tuple of <code>ColumnOrdering</code> objects.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ordering_repr" href="#FunctionalTables.ordering_repr"><code>FunctionalTables.ordering_repr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ordering_repr(ordering)
</code></pre><p>A string representation of an ordering, eg for use in <code>show</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.orderkey" href="#FunctionalTables.orderkey"><code>FunctionalTables.orderkey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Accessor for key. <em>Internal.</em></p></div></div></section><pre><code class="language-none">FunctionalTables.orderrev</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.picking" href="#FunctionalTables.picking"><code>FunctionalTables.picking</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">picking(key)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.rename" href="#FunctionalTables.rename"><code>FunctionalTables.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rename(ft, changes)
</code></pre><p>Rename the columns of a <code>FunctionalTable</code>. The second argument should be a <code>NamedTuple</code> of <code>src = dest</code> pairs, where <code>dest</code> is a symbol.</p><p><strong>Example</strong></p><pre><code class="language-julia">rename(ft, (α = :a, β = :b)) # rename `α` to `a` and `β` to `b`</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.retained_ordering" href="#FunctionalTables.retained_ordering"><code>FunctionalTables.retained_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">retained_ordering(ordering, a, b)
</code></pre><p>Return the (initial) part of <code>ordering</code> under which <code>a ≤ b</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.sort_in_memory</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.split_compatible_ordering" href="#FunctionalTables.split_compatible_ordering"><code>FunctionalTables.split_compatible_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split_compatible_ordering(ordering, splitkeys)
</code></pre><p>Extend <code>ordering</code> so that it can be used to split a table with <code>splitkeys</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.split_namedtuple" href="#FunctionalTables.split_namedtuple"><code>FunctionalTables.split_namedtuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split_namedtuple(?, nt)
</code></pre><p>Splits a named tuple in two, based on the names in <code>splitter</code>.</p><p>Returns two <code>NamedTuple</code>s; the first one is ordered as <code>splitter</code>, the second one with the remaining values as in the original argument.</p><pre><code class="language-julia-repl">julia&gt; split_namedtuple(NamedTuple{(:a, :c)}, (c = 1, b = 2, a = 3, d = 4))
((a = 3, c = 1), (b = 2, d = 4))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.split_table" href="#FunctionalTables.split_table"><code>FunctionalTables.split_table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split_table(ft, splitkeys)
</code></pre><p>Helper function to set up a <code>SplitTable</code>. <em>Internal</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.start_sinks" href="#FunctionalTables.start_sinks"><code>FunctionalTables.start_sinks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">start_sinks(cfg, row, known_types)
</code></pre><p>Start sinks using row, using the default <code>known_types</code> when available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.store!_or_reallocate" href="#FunctionalTables.store!_or_reallocate"><code>FunctionalTables.store!_or_reallocate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">store!_or_reallocate(?, sink, elt)
</code></pre><p>Either store <code>elt</code> in <code>sink</code> (in which case the returned value is <code>≡ sink</code>), or allocate a new sink that can do this, copy the contents, save <code>elt</code> and return that (then the returned value is <code>≢ sink</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.store!_or_reallocate_row" href="#FunctionalTables.store!_or_reallocate_row"><code>FunctionalTables.store!_or_reallocate_row</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">store!_or_reallocate_row(cfg, sinks, elts)
</code></pre><p>Broadcast <code>store!_or_rellocate</code> for a compatible (named) tuple of <code>sinks</code> and <code>elts</code>. Return the (potentially) new sinks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.table_ordering" href="#FunctionalTables.table_ordering"><code>FunctionalTables.table_ordering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">table_ordering(column_ordering_specifications)
</code></pre><p>Process ordering specifications for columns (an iterable or possibly a TableOrdering), return a <code>TableOrdering</code>. Check for uniqueness (but not validity) of keys.</p><p>Accepted syntax:</p><ul><li><p><code>:key</code>, for ordering a column in ascending order,</p></li><li><p><code>:key =&gt; reverse</code>, for ordering a column in descending order.</p></li></ul><p>All functions which accept ordering specifications should use this, but the function itself is not part of the API.</p></div></div></section><pre><code class="language-none">FunctionalTables.use_rle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.wrapping" href="#FunctionalTables.wrapping"><code>FunctionalTables.wrapping</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wrapping(key)
</code></pre><p>Return a callable that wraps its argument in a <code>NamedTuple</code> with a given <code>key</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
