<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · FunctionalTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FunctionalTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnSort" href="#FunctionalTables.ColumnSort"><code>FunctionalTables.ColumnSort</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ColumnSort{K, R}</code></pre><p>Sort specification for a column. <code>K::Symbol</code> is a key for sorting, <code>R::Bool</code> reverses sorting for this key.</p><p>This type is <em>not part of the interface</em>, for internal representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnSorting" href="#FunctionalTables.ColumnSorting"><code>FunctionalTables.ColumnSorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for sorting, used internally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.FunctionalTable" href="#FunctionalTables.FunctionalTable"><code>FunctionalTables.FunctionalTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FunctionalTable(itr)
FunctionalTable(itr, sortspecs)
FunctionalTable(itr, sortspecs, sortingpolicy; cfg)
</code></pre><p>Create a <code>FunctionalTable</code> from an iterable that returns <code>NamedTuple</code>s.</p><p>Returned values need to have the same names (but not necessarily types).</p><p><code>sorting</code> specifies sorting, and is a tuple of <code>:key</code> or <code>:key =&gt; reverse</code> elements.</p><p><code>cfg</code> determines sink configuration for collecting elements of the columns, see <a href="#FunctionalTables.SinkConfig"><code>SinkConfig</code></a>.</p></div></div></section><pre><code class="language-none">FunctionalTables.FunctionalTables</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.Keys" href="#FunctionalTables.Keys"><code>FunctionalTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for keys, used internally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RLEVector" href="#FunctionalTables.RLEVector"><code>FunctionalTables.RLEVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RLEVector{C, T, S}</code></pre><p>An RLE encoded vector, using negative lengths for missing values.</p><p>When an elemenet in <code>counts</code> is positive, it encodes that many of the corresponding element in <code>data</code>.</p><p>Negative <code>counts</code> encode missing values of type <code>S</code> (has to be a concrete singleton). In this case there is no corresponding value in <code>data</code>, ie <code>data</code> may have <em>fewer elements</em> than <code>counts</code>.</p><p>An RLEVector can also act as a column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RepeatedValue" href="#FunctionalTables.RepeatedValue"><code>FunctionalTables.RepeatedValue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>RepeatedValue(value, len)</p><p>Equivalent to a vector containing <code>len</code> instances of <code>value</code>. Used <em>internally</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SHOWROWS" href="#FunctionalTables.SHOWROWS"><code>FunctionalTables.SHOWROWS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Shows this many values from each column in a <code>FunctionalTable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SINKCONFIG" href="#FunctionalTables.SINKCONFIG"><code>FunctionalTables.SINKCONFIG</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Default sink configuration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SINKVECTORS" href="#FunctionalTables.SINKVECTORS"><code>FunctionalTables.SINKVECTORS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Sink configuration that collects to vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SinkConfig" href="#FunctionalTables.SinkConfig"><code>FunctionalTables.SinkConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SinkConfig{M}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SortingPolicy" href="#FunctionalTables.SortingPolicy"><code>FunctionalTables.SortingPolicy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SortingPolicy{K}</code></pre><p>Policy for dealing with specified sortings.</p><p>See <a href="#FunctionalTables.VerifySorting"><code>VerifySorting</code></a>, <a href="#FunctionalTables.TrustSorting"><code>TrustSorting</code></a>, and <a href="#FunctionalTables.TrySorting"><code>TrySorting</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SplitTable" href="#FunctionalTables.SplitTable"><code>FunctionalTables.SplitTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SplitTable{K, T&lt;:FunctionalTable, C&lt;:SinkConfig}</code></pre><p>Implements <a href="#FunctionalTables.by"><code>by</code></a>.</p><p>Iterator state is a tuple, with</p><ol><li><p><code>sinks</code> and <code>firstkey</code>, created from the element with a non-matching key,</p></li><li><p><code>itrstate</code>, the iteration state for <code>itr</code>.</p></li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrustSorting" href="#FunctionalTables.TrustSorting"><code>FunctionalTables.TrustSorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Accept the specified sorting to hold without any checks (except for verifying that column names are valid).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This can lead to incorrect results, use cautiously. <a href="#FunctionalTables.VerifySorting"><code>VerifySorting</code></a> is recommended instead as it has little overhead.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrySorting" href="#FunctionalTables.TrySorting"><code>FunctionalTables.TrySorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Try the specified sorting, then gracefully degrade to a subset of it that holds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.VerifySorting" href="#FunctionalTables.VerifySorting"><code>FunctionalTables.VerifySorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Verify that the specified sorting holds. This is the default sorting policy.</p></div></div></section><pre><code class="language-none">FunctionalTables._cmp_sorting</code></pre><pre><code class="language-none">FunctionalTables._collect_block!</code></pre><pre><code class="language-none">FunctionalTables._retained_sorting</code></pre><pre><code class="language-none">FunctionalTables._select_sorting</code></pre><pre><code class="language-none">FunctionalTables._showcolcontents</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.append1" href="#FunctionalTables.append1"><code>FunctionalTables.append1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append1(v, elt)
</code></pre><p>Append <code>elt</code> to <code>v</code>, allocating a new vector and copying the contents.</p><p>Type of new collection is calculated using <code>promote_type</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.by" href="#FunctionalTables.by"><code>FunctionalTables.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">by(indexkeys, ft; cfg)
</code></pre><p>An iterator that groups rows of tables by the columns <code>indexkeys</code>, returning <code>(index::NamedTupe, table::FunctionalTable)</code> for each contiguous block of the index keys.</p><p><code>cfg</code> is used for collecting <code>table</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cancontain" href="#FunctionalTables.cancontain"><code>FunctionalTables.cancontain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cancontain(T, elt)
</code></pre><p>Test if a collection of element type <code>T</code> can contain a new element <code>elt</code> without <em>any</em> loss of precision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.checkvalidkeys" href="#FunctionalTables.checkvalidkeys"><code>FunctionalTables.checkvalidkeys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">checkvalidkeys(argkeys, validkeys)
</code></pre><p>Check that <code>argkeys</code> are a subset of the valid keys.</p><p>When that does not hold, throw and error with an informative message.</p></div></div></section><pre><code class="language-none">FunctionalTables.cmp_columnsort</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cmp_sorting" href="#FunctionalTables.cmp_sorting"><code>FunctionalTables.cmp_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cmp_sorting(cs, a, b)
</code></pre><p>Compare rows <code>a</code> and <code>b</code>, which support the <code>getproperty</code> interface, with the given column sorting.</p><p><em>Internal</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_column" href="#FunctionalTables.collect_column"><code>FunctionalTables.collect_column</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collect_column(cfg, itr)
</code></pre><p>Collect results from <code>itr</code> into a sink (using config <code>cfg</code>), then finalize and return the column.</p></div></div></section><pre><code class="language-none">FunctionalTables.collect_column!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_columns" href="#FunctionalTables.collect_columns"><code>FunctionalTables.collect_columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>columns, sorting = </p><pre><code class="language-julia">collect_columns(cfg, itr, sorting, sortingpolicy)
</code></pre><p>Collect results from <code>itr</code>, which are supposed to be <code>NamedTuple</code>s with the same names, into sinks (using config <code>cfg</code>), then finalize and return the <code>NamedTuple</code> of the columns and the sorting (which is <code>≡ sorting</code> unless <code>sortingpolicy ≡ SortingPolicy(:prefix)</code>).</p><p><code>sorting</code> is ignored when <code>sortingpolicy ≡ SortingPolicy(:accept)</code>, otherwise used according to the value of the latter.</p></div></div></section><pre><code class="language-none">FunctionalTables.collect_columns!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.column_sorting" href="#FunctionalTables.column_sorting"><code>FunctionalTables.column_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">column_sorting(sortspecs)
column_sorting(sortspecs, colkeys)
</code></pre><p>Process sorting specifications for columns (an iterable or possibly a ColumnSorting), return a value of type <code>ColumnSorting</code>.</p><p>Verify that sort keys are unique. When <code>colkeys</code> is given, verify that the sort keys are a subset of it.</p><p>Accepted syntax:</p><ul><li><p><code>:key</code>, for sorting a column in ascending order</p></li><li><p><code>:key =&gt; reverse</code>, for sorting a column in descending order</p></li></ul><p>All functions which accept sort specs should use this, but the function itself is not part of the API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.columns" href="#FunctionalTables.columns"><code>FunctionalTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">columns(ft; vector, mutable)
</code></pre><p>Return the columns in a <code>NamedTuple</code>.</p><p>When <code>mutable</code>, all columns will be mutable <code>&lt;: AbstractVector</code>, and not share (shallow) structure.</p><p>When <code>vector</code>, all columns will be <code>&lt;: AbstractVector</code>, but may be immutable or share structure.</p></div></div></section><pre><code class="language-none">FunctionalTables.contiguous_blocks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.dropkeys" href="#FunctionalTables.dropkeys"><code>FunctionalTables.dropkeys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropkeys(ftkeys, drop)
</code></pre><p>Check that <code>drop ⊆ ftkeys</code>, then return <code>ftkeys ∖ drop</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sink" href="#FunctionalTables.finalize_sink"><code>FunctionalTables.finalize_sink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finalize_sink(?, sink)
</code></pre><p>Convert <code>sink</code> to a <em>column</em>.</p><p><code>sink</code> may share structure with the result and is not supposed to be used for saving any more elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sinks" href="#FunctionalTables.finalize_sinks"><code>FunctionalTables.finalize_sinks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finalize_sinks(cfg, sinks)
</code></pre><p>Finalize a (named) tuple of sinks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.fuse" href="#FunctionalTables.fuse"><code>FunctionalTables.fuse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fuse(f, index, tables)
</code></pre><p>Prepend the <code>index</code> as repeated columns to <code>f(index, tables...)</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.getsorting</code></pre><pre><code class="language-none">FunctionalTables.include</code></pre><pre><code class="language-none">FunctionalTables.isless_sorting</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.make_sink" href="#FunctionalTables.make_sink"><code>FunctionalTables.make_sink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_sink(cfg, elt)
</code></pre><p>Create and return a sink using configuration <code>cfg</code> that stores <code>elt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.make_sinks" href="#FunctionalTables.make_sinks"><code>FunctionalTables.make_sinks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_sinks(cfg, elts)
</code></pre><p>Make sinks for a (named) tuple pf elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.merge_repeated" href="#FunctionalTables.merge_repeated"><code>FunctionalTables.merge_repeated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">merge_repeated(index, ft)
</code></pre><p>Make a functional table from <code>index</code>, repeating each value for a column to match the length of <code>ft</code>, then merge the two.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.merge_sorting" href="#FunctionalTables.merge_sorting"><code>FunctionalTables.merge_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">merge_sorting(cs, otherkeys)
</code></pre><p>Calculate sorting when a table with <code>sorting</code> is merged with a table containing <code>otherkeys</code>, which may replace columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.narrow" href="#FunctionalTables.narrow"><code>FunctionalTables.narrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">narrow(x)
</code></pre><p>Convert the argument to a narrower type if possible without losing precision.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function is not type stable, use only when new container types are determined.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.retained_sorting" href="#FunctionalTables.retained_sorting"><code>FunctionalTables.retained_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">retained_sorting(cs, a, b)
</code></pre><p>Return the part of <code>sorting</code> under which <code>a ≤ b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.select" href="#FunctionalTables.select"><code>FunctionalTables.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select(ft, keep)
</code></pre><p>select(ft, keep...) select(ft; drop)</p><p>Select a subset of columns from the table.</p><p><code>select(ft, keep)</code> and <code>select(ft, keep...)</code> returns the table with the given columns.</p><p><code>select(ft; drop = keys)</code> is a convenience form for keeping <strong>all but</strong> the given columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.select_sorting" href="#FunctionalTables.select_sorting"><code>FunctionalTables.select_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select_sorting(cs, keep)
</code></pre><p>Calculate sorting when only <code>keep</code> keys are kept.</p><p><code>keep</code> may contain keys not in the sorting, ie those of a <code>FunctionalTable</code>.</p></div></div></section><pre><code class="language-none">FunctionalTables.sort_in_memory</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.sortkey" href="#FunctionalTables.sortkey"><code>FunctionalTables.sortkey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Accessor for sort key. <em>Internal.</em></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.split_namedtuple" href="#FunctionalTables.split_namedtuple"><code>FunctionalTables.split_namedtuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split_namedtuple(splitter, nt)
</code></pre><p>Splits a named tuple in two, based on the names in <code>splitter</code>.</p><p>Returns two <code>NamedTuple</code>s; the first one is ordered as <code>splitter</code>, the second one with the remaining values as in the original argument.</p><pre><code class="language-julia-repl">julia&gt; split_namedtuple(NamedTuple{(:a, :c)}, (c = 1, b = 2, a = 3, d = 4))
((a = 3, c = 1), (b = 2, d = 4))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.store!_or_reallocate" href="#FunctionalTables.store!_or_reallocate"><code>FunctionalTables.store!_or_reallocate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">store!_or_reallocate(?, sink, elt)
</code></pre><p>Either store <code>elt</code> in <code>sink</code> (in which case the returned value is <code>≡ sink</code>), or allocate a new sink that can do this, copy the contents, save <code>elt</code> and return that (then the returned value is <code>≢ sink</code>).</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
