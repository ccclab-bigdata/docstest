<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MatrixNetworks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MatrixNetworks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.Biconnected_components_output" href="#MatrixNetworks.Biconnected_components_output"><code>MatrixNetworks.Biconnected_components_output</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>biconnected component decomposition</strong></p><p>Any connected graph decomposes into a tree of biconnected components  called the block-cut tree of the graph. The blocks are attached to each  other at shared vertices called cut vertices or articulation points.</p><p>This implementation is based on the algorithm provided by Tarjan  in &quot;Depth-First Search and Linear Graph Algorithms&quot;.  </p></div></div></section><pre><code class="language-none">MatrixNetworks.Matching_output</code></pre><pre><code class="language-none">MatrixNetworks.Matching_setup</code></pre><pre><code class="language-none">MatrixNetworks.MatrixNetwork</code></pre><pre><code class="language-none">MatrixNetworks.MatrixNetworkMetadata</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.MatrixNetworkStochasticMult" href="#MatrixNetworks.MatrixNetworkStochasticMult"><code>MatrixNetworks.MatrixNetworkStochasticMult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong><code>MatrixNetworkStochasticMult</code></strong></p><p><strong>Expert interface</strong> </p><p>This type is the result of creating an implicit stochastic operator for a matrix network type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.MatrixNetworks" href="#MatrixNetworks.MatrixNetworks"><code>MatrixNetworks.MatrixNetworks</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Module <span>$MatrixNetworks$</span>: Documentation on the module</p><ul><li>Option 1: start with a sparse matrix A:</li><li>example: <span>$M = MatrixNetwork(A)$</span></li><li>Option 2: start with row and column indexes for the nonzeros in the matrix</li><li>example: <span>$M = MatrixNetwork(ei,ej)$</span></li></ul><p>Available functions: (use ?function_name to get more documentation)</p><ul><li>bfs</li><li>bipartite_matching</li><li>clustercoeffs</li><li>corenums</li><li>cosineknn</li><li>csr<em>to</em>sparse</li><li>dfs</li><li>biconnected_components</li><li>dijkstra</li><li>dirclustercoeffs</li><li>floydwarshall</li><li>largest_component</li><li>mst_prim</li><li>scomponents</li><li>sparse<em>to</em>csr</li></ul><p>You can check the readme file here: </p><p>&quot;https://github.com/nassarhuda/MatrixNetworks.jl/blob/master/README.md&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.RankedArray" href="#MatrixNetworks.RankedArray"><code>MatrixNetworks.RankedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>RankedArray</strong></p><p>This is a data-type that functions as a union between a sparse and dense array. It allows us to check if an element is not in the array (i.e. it&#39;s too long) by adding a getindex function to the array type.</p><p>It&#39;s called a RankedArray because the idea is that the elements of the array are the ranks of the nodes in a sorted vector.</p><p>This should not be used externally.</p><p><strong>Example</strong></p><p>v = rand(10) r = RankedArray(sortperm(v)) haskey(r,11) # returns false haskey(r,1) # returns true haskey(r,0) # returns false</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.SparseMatrixStochasticMult" href="#MatrixNetworks.SparseMatrixStochasticMult"><code>MatrixNetworks.SparseMatrixStochasticMult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong><code>SparseMatrixStochasticMult</code></strong></p><p><strong>Expert interface</strong> </p><p>This type is the result of creating an implicit stochastic operator for a sparse matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.SpectralCut" href="#MatrixNetworks.SpectralCut"><code>MatrixNetworks.SpectralCut</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong><code>SpectralCut</code></strong></p><p>The return type from the <code>spectral_cut</code></p><p><strong>Fields</strong></p><ul><li><code>set</code>: the small side of the spectral cut</li><li><code>A</code>: the network of the largest strong component of the network</li><li><code>lam2</code>: the eigenvalue of the normalized Laplacian</li><li><code>x</code>: the Fiedler vector for spectral partitioning</li><li><code>sweepcut_profile</code>: the sweepcut profile output</li><li><code>comps</code>: the output from the strong_components function   check comps.number to get the number of components</li><li><code>largest_component</code>: the index of the largest strong component</li></ul><p>The most useful outputs are <code>set</code> and <code>lam2</code>; the others are provided for experts who wish to use some of the diagonstics provided.</p></div></div></section><pre><code class="language-none">MatrixNetworks.Strong_components_output</code></pre><pre><code class="language-none">MatrixNetworks.Strong_components_rich_output</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.SweepcutProfile" href="#MatrixNetworks.SweepcutProfile"><code>MatrixNetworks.SweepcutProfile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>SweepcutProfile</strong></p><p>This type is the result of a sweepcut operation. It stores a number of vectors associated with a sweep cut including the cut and volume associated with each.</p><p><strong>Methods</strong></p><ul><li><code>bestset(P::SweepcutProfile)</code> return the best set identified in the sweepcut. This is usually what you want.</li></ul><p><strong>Example</strong></p><p>See <code>sweepcut</code></p><p><strong>See also</strong></p><ul><li><code>spectral_cut</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._applyv!" href="#MatrixNetworks._applyv!"><code>MatrixNetworks._applyv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>_applyv!</code></strong></p><p>The fully generic function to compute <code>x &lt;- alpha*x + gamma*v</code></p><p><strong>Functions</strong></p><ul><li><code>_applyv!(x, v, alpha, gamma)</code> </li></ul><p><strong>Example</strong></p><p>Internal function</p></div></div></section><pre><code class="language-none">MatrixNetworks._check_for_two_distinct_nodes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._check_negative" href="#MatrixNetworks._check_negative"><code>MatrixNetworks._check_negative</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return true if any element is negative.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._chung_lu_dense_undirected" href="#MatrixNetworks._chung_lu_dense_undirected"><code>MatrixNetworks._chung_lu_dense_undirected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Not public right now</p></div></div></section><pre><code class="language-none">MatrixNetworks._create_stochastic_mult</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._densevec" href="#MatrixNetworks._densevec"><code>MatrixNetworks._densevec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert a sparse representation into a dense vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._havel_hakimi" href="#MatrixNetworks._havel_hakimi"><code>MatrixNetworks._havel_hakimi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The internal Havel-Hakimi function has an optional store behavior that saves the edges as they come out of the algorithm. This enables us to generate a Havel Hakimi graph, which can be useful.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._hk_taylor_degree" href="#MatrixNetworks._hk_taylor_degree"><code>MatrixNetworks._hk_taylor_degree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the number of terms of a Taylor series approximation to exp(-t(I-P)) sufficient to guarantee eps accuracy in the one norm when P is a stochastic matrix. </p><p>Since this is actually exp(-t) exp(tP) and P is a stochastic matrix, if we want  $ \| e^{-t} \exp(tP) - e^{-t} TaylorPoly(e^t) \|<em>1 \le \eps $ then it is equivalent to get $ \| \exp(tP) -  TaylorPoly(e^t) \|</em>1 \le \eps e^t  $ and that is what this code computes. </p><p>Returns -1 if maxdeg is insufficient</p></div></div></section><pre><code class="language-none">MatrixNetworks._matrix_network_direct</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._noiterfunc" href="#MatrixNetworks._noiterfunc"><code>MatrixNetworks._noiterfunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A simple function that doesn&#39;t report any output</p></div></div></section><pre><code class="language-none">MatrixNetworks._personalized_pagerank_validated</code></pre><pre><code class="language-none">MatrixNetworks._second</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._seeded_heat_kernel_validated" href="#MatrixNetworks._seeded_heat_kernel_validated"><code>MatrixNetworks._seeded_heat_kernel_validated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This internal function actually allocates the memory and calls the  heat kernel algorithm. This could change in the future based on the  type of graph provided. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks._symeigs_smallest_arpack" href="#MatrixNetworks._symeigs_smallest_arpack"><code>MatrixNetworks._symeigs_smallest_arpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>_symeigs_smallest_arpack</code></strong></p><p>Compute eigenvalues and vectors using direct calls to the ARPACK wrappers to get type-stability. This function works for symmetric matrices.</p><p>This function works on Float32 and Float64-valued sparse matrices. It returns the smallest set of eigenvalues and vectors.</p><p>It only works on matrices with more than 21 rows and columns. (Use a dense eigensolver for smaller problems.)</p><p><strong>Functions</strong></p><ul><li><code>(evals,evecs) = _symeigs_smallest_arpack(A::SparseMatrixCSC{V,Int},                       nev::Int,tol::V,maxiter::Int, v0::Vector{V})</code></li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: the sparse matrix, must be symmetric</li><li><code>nev</code>: the number of eigenvectors requested</li><li><code>tol</code>: the relative tolerance of the eigenvalue computation</li><li><code>maxiter</code>: the maximum number of restarts</li><li><code>v0</code>: the initial vector for the Lanczos process</li></ul><p><strong>Example</strong></p><p>This is an internal function.</p></div></div></section><pre><code class="language-none">MatrixNetworks.bestset</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.bfs" href="#MatrixNetworks.bfs"><code>MatrixNetworks.bfs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>BFS</strong></p><pre><code class="language-none">compute breadth first search distances and returns a distance(d), 
the discover time(dt), predecessor array(pred) in the tuple (d,dt,pred)
pred[i] = 0 if vertex i is in a component not reachable from u and i != u.
Search stops when it hits the vertex target.</code></pre><p><strong>Functions</strong></p><ul><li>(d,dt,pred) = bfs(A::MatrixNetwork,u::Int64,target::Int64)</li><li>(d,dt,pred) = bfs{T}(A::SparseMatrixCSC{T,Int64}),u::Int64,target::Int64)</li><li>(d,dt,pred) = bfs(ei::Vector{Int64},ej::Vector{Int64},u::Int64,target::Int64)</li></ul><p>If target is not specified, it is assigned to 0</p><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;bfs_example&quot;)
(d,dt,pred) = bfs(A,1)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.biconnected_components" href="#MatrixNetworks.biconnected_components"><code>MatrixNetworks.biconnected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>biconnected_components</code></strong></p><p>This function requires a symmetric matrix as input. Depending on the user input this function returns either the biconnected component number associated with each edge  or articlation points or both.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: the adjacency matrix</li><li>Optional Keyword inputs<ul><li><code>art=true</code>: returns the articulation points of the graph.</li><li><code>components=true</code>:returns the biconnected component labels associated with each </li></ul>edge.</li></ul><p><strong>Returns</strong></p><ul><li>Returns a <code>Biconnected_components_output</code> type which includes</li></ul><p><code>map</code> : biconnected component labels associated with each edge,  <code>articulation_points</code>: boolean array that signifies whether a vertex is an articulation point and <code>number</code>: Number of biconnected components in the graph.</p><p><strong>Example</strong></p><p>A = load<em>matrix</em>network(&quot;biconnected<em>example&quot;) B = MatrixNetwork(A) bcc = biconnected</em>components(B) map = bcc.map articulation<em>vector = bcc.articulation</em>points number<em>of</em>components = bcc.number</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.biconnected_components!" href="#MatrixNetworks.biconnected_components!"><code>MatrixNetworks.biconnected_components!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>biconnected_components!</code></strong></p><p>This function returns the number of biconnected components in the  underlying graph. It expects an undirected graph as its input.</p><p><strong>Functions</strong></p><ul><li><code>number = biconnected_components!(A::MatrixNetwork, articulation::Vector{Bool}, map::Vector{Int64})</code></li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: the adjacency matrix.</li><li><code>articulation</code>: A boolean array, where each element is initialized to false.</li><li><code>map</code>: Vector of size equal to the number of edges.</li></ul><p><strong>Returns</strong></p><ul><li><code>cn</code>: The number of biconnected components in the graph</li></ul><p><strong>Example</strong></p><p>A = load<em>matrix</em>network(&quot;biconnected<em>example&quot;) B = MatrixNetwork(A) number</em>of<em>components = biconnected</em>components!(B, zeros(Bool,0), zeros(Int64,0))</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.bipartite_matching" href="#MatrixNetworks.bipartite_matching"><code>MatrixNetworks.bipartite_matching</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>BIPARTITE MATCHING</strong></p><pre><code class="language-none">return a maximum weight bipartite matching of a graph</code></pre><p><strong>Functions</strong></p><ul><li>Matching<em>Setup = bipartite</em>matching_setup{T}(A::SparseMatrixCSC{T,Int64})</li><li>Matching<em>Setup = bipartite</em>matching_setup{T}(x::Vector{T},ei::Vector{Int64},ej::Vector{Int64},m::Int64,n::Int64)</li><li>Matching<em>Output = bipartite</em>matching<em>primal</em>dual{T}(rp::Vector{Int64}, ci::Vector{Int64},ai::Vector{T}, m::Int64, n::Int64)</li><li>Matching<em>Output = bipartite</em>matching{T}(A::SparseMatrixCSC{T,Int64})</li><li>Matching<em>Output = bipartite</em>matching{T}(w::Vector{T},ei::Vector{Int64},ej::Vector{Int64},m::Int64,n::Int64)</li><li>Matching<em>Output = bipartite</em>matching{T}(w::Vector{T},ei::Vector{Int64},ej::Vector{Int64})</li><li>ind = bipartite<em>matching</em>indicator{T}(w::Vector{T},ei::Vector{Int64},ej::Vector{Int64})</li><li>(m1,m2) = edge<em>list(M</em>output::Matching_output)</li><li>S = create<em>sparse(M</em>output::Matching_output)</li></ul><p>You can check the documentation of each of the output modifiers functions separately.</p><p><strong>Example</strong></p><pre><code class="language-none">W = sprand(10,8,0.5)
bipartite_matching(W)
ei = [1;2;3]
ej = [3;2;4]
Matching_Output = bipartite_matching([10;12;13],ei,ej)
Matching_Output.weight
Matching_Output.cardinality
Matching_Output.match
S = create_sparse(bipartite_matching(W)) # get the sparse matrix
(m1,m2) = edge_list(bipartite_matching(W)) # get the edgelist</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.bipartite_matching_indicator" href="#MatrixNetworks.bipartite_matching_indicator"><code>MatrixNetworks.bipartite_matching_indicator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the matching indicator of a matrix stored in triplet format Example: bipartite<em>matching</em>indicator([10;12;13],[1;2;3],[3;2;4])</p></div></div></section><pre><code class="language-none">MatrixNetworks.bipartite_matching_primal_dual</code></pre><pre><code class="language-none">MatrixNetworks.bipartite_matching_setup</code></pre><pre><code class="language-none">MatrixNetworks.bipartite_matching_setup_phase1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.chung_lu_undirected" href="#MatrixNetworks.chung_lu_undirected"><code>MatrixNetworks.chung_lu_undirected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>chung_lu_undirected</code></strong></p><p>Generate an approximate undirected Chung-Lu graph. The approximation is because we draw exactly |E| edges where each edge is sampled from the Chung-Lu model. But then we discard duplicate edges and self-loops. So the new graph will always have fewer edges than the input degree sequence.</p><p><strong>This will likely change in future versions and provide an exact Chung-Lu model.</strong></p><p>If the graph is </p><p><strong>Usage</strong></p><ul><li><code>chung_lu_undirected(d)</code></li><li><code>chung_lu_undirected(d,nedges)</code> </li></ul><p><strong>Input</strong></p><ul><li><code>d</code>: the degree sequence vector. This vector is non-negative and has the expected</li></ul><p>degree for each vertex.</p><p><strong>Output</strong></p><ul><li>A MatrixNetwork for the undirected graph that results from the Chung-Lu sample.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;tapir&quot;)
d = vec(sum(A,1))
B = sparse(chung_lu_undirected(d))
nnz(A)
nnz(B)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.clustercoeffs" href="#MatrixNetworks.clustercoeffs"><code>MatrixNetworks.clustercoeffs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>CLUSTERCOEFFS</strong></p><pre><code class="language-none">compute undirected clustering coefficients for a graph. clustercoeffs(A) computes a 
normalized, weighted clustering coefficients from a graph represented by a symmetric 
adjacency matrix A. clustercoeffs(A,weighted,normalized), with weighted and normalized 
boolean values indicating whether the computation has to be weighted and/or normalized.</code></pre><p><strong>Functions</strong></p><ul><li>cc = clustercoeffs(A::MatrixNetwork,weighted::Bool,normalized::Bool)</li><li>cc = clustercoeffs{T}(A::SparseMatrixCSC{T,Int64},weighted::Bool,normalized::Bool)</li></ul><p>If weighted and normalized are not specified, they are understood as true</p><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;clique-10&quot;)    
cc = clustercoeffs(MatrixNetwork(A))    </code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.clustercoeffs_phase2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.corenums" href="#MatrixNetworks.corenums"><code>MatrixNetworks.corenums</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>CORENUMS</strong></p><pre><code class="language-none">compute the core number for each vertex in the graph and returns the core
numbers for each vertex of the graph A along with the removal order of the vertex in the 
tuple (d,rt). This function works on directed graphs but gives the in-degree core number.
To get the out-degree core numbers call corenums(A&#39;)</code></pre><p><strong>Functions</strong></p><ul><li>(d,rt) = corenums(A::MatrixNetwork)</li><li>(d,rt) = corenums{T}(A::SparseMatrixCSC{T,Int64})</li><li>(d,rt) = corenums(ei::Vector{Int64},ej::Vector{Int64})</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;cores_example&quot;)
(d,rt) = corenums(A)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.cosineknn" href="#MatrixNetworks.cosineknn"><code>MatrixNetworks.cosineknn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>COSINEKNN</strong></p><pre><code class="language-none">compute the k-nearest neighbors similarity metric between the
vertices of A or the upper half of a bipartite graph A.</code></pre><p><strong>Functions</strong></p><ul><li>S = cosineknn{T}(A::SparseMatrixCSC{T,Int64},K::Int64)</li><li>S = cosineknn(A::MatrixNetwork,K::Int64)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;bfs_example&quot;)
S = cosineknn(A,2)</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.cosineknn_internal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.create_sparse" href="#MatrixNetworks.create_sparse"><code>MatrixNetworks.create_sparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates and returns a sparse matrix that represents the outputed matching Example: M<em>out = bipartite</em>matching([10;12;13],[1;2;3],[3;2;4]) create<em>sparse(M</em>out)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.csr_to_sparse" href="#MatrixNetworks.csr_to_sparse"><code>MatrixNetworks.csr_to_sparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>CSRTOSPARSE</strong></p><pre><code class="language-none">convert a matrix from compressed sparse row to a sparse matrix A.
It returns the arrays that feed the sparse function in julia.</code></pre><p><strong>Functions</strong></p><ul><li>(nzi,nzj,nzv) = csr<em>to</em>sparse{T}(rp::Vector{Int64},ci::Vector{Int64},ai::Vector{T})</li><li>(nzi,nzj,nzv) = csr<em>to</em>sparse{T}(rp::Vector{Int64},ci::Vector{Int64},ai::Vector{T},nrows::Int64)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">i = [1;2;3]
j = [3;4;4]
v = [8;9;10]
(rp,ci,ai,m) = sparse_to_csr(i,j,v)
(nzi,nzj,nzv) = csr_to_sparse(rp,ci,ai)
A = sparse(nzi,nzj,nzv,length(rp)-1,maximum(ci))
B = csr_to_sparse_matrix(rp,ci,ai)
isequal(A,B)</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.csr_to_sparse_matrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.dfs" href="#MatrixNetworks.dfs"><code>MatrixNetworks.dfs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>DFS</strong></p><pre><code class="language-none">compute depth first search distances and returns the distance (d), the discover (dt),
the finish time(ft), and the predecessor array (pred) in the tuple (d,dt,ft, pred).

pred[i] = 0 if vertex i is in a component not reachable from u and i != u.</code></pre><p><strong>Functions</strong></p><ul><li>(d,dt,ft,pred) = dfs(A::MatrixNetwork,u::Int64,full::Int64,target::Int64)</li><li>(d,dt,ft,pred) = dfs(A::MatrixNetwork,u::Int64)</li><li>(d,dt,ft,pred) = dfs{T}(A::SparseMatrixCSC{T,Int64},u::Int64,full::Int64,target::Int64)</li><li>(d,dt,ft,pred) = dfs{T}(A::SparseMatrixCSC{T,Int64},u::Int64)</li><li>(d,dt,ft,pred) = dfs(ei::Vector{Int64},ej::Vector{Int64},u::Int64,full::Int64,target::Int64)</li><li>(d,dt,ft,pred) = dfs(ei::Vector{Int64},ej::Vector{Int64},u::Int64)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;dfs_example&quot;)
(d,dt,ft,pred)  = dfs(A,1)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.dijkstra" href="#MatrixNetworks.dijkstra"><code>MatrixNetworks.dijkstra</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>DIJKSTRA</strong></p><pre><code class="language-none">compute shortest paths using Dijkstra&#39;s algorithm.
d = dijkstra(A,u) computes the shortest path from vertex u to all nodes 
reachable from vertex u using Dijkstra&#39;s algorithm for the problem.  
The graph is given by the weighted sparse matrix A, where A(i,j) is 
the distance between vertex i and j.  In the output vector d, 
the entry d[v] is the minimum distance between vertex u and vertex v.
A vertex w unreachable from u has d(w)=Inf.
pred is the predecessor tree to generate the actual shorest paths. 
In the predecessor tree pred[v] is the vertex preceeding v in the 
shortest path and pred[u]=0. Any unreachable vertex has pred[w]=0 as well.  
If your network is unweighted, then use bfs instead.</code></pre><p><strong>Functions</strong></p><ul><li>(d,pred) = dijkstra(A::MatrixNetwork,u::Int64)</li><li>(d,pred) = dijkstra{F}(A::SparseMatrixCSC{F,Int64},u::Int64)</li></ul><p><strong>Example</strong></p><pre><code class="language-none"># Find the minimum travel time between Los Angeles (LAX) and
# Rochester Minnesota (RST).

(A,xy,labels) = load_matrix_network_metadata(&quot;airports&quot;)
A = -A; # fix funny encoding of airport data
lax = 247; rst = 355
(d,pred) = dijkstra(A,lax)
@printf(&quot;Minimum time: %d&quot;,d[rst]); #Print the path
@printf(&quot;Path:&quot;)
u = rst
while(u != lax)
    @printf(&quot;%s &lt;-- &quot;, labels[u])
    u = pred[u];
    if (u == lax)
        @printf(&quot;%s&quot;, labels[lax])
    end
end</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.dijkstra_internal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.dirclustercoeffs" href="#MatrixNetworks.dirclustercoeffs"><code>MatrixNetworks.dirclustercoeffs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>DIRCLUSTERCOEFFS</strong></p><pre><code class="language-none">compute clustering coefficients for a directed graph.
cc = dirclustercoeffs(A) returns the directed clustering coefficients
(which generalize the clustering coefficients of an undirected graph, 
and so calling this function on an undirected graph will produce the same
answer as clustercoeffs, but less efficiently.)

This function implements the algorithm from Fagiolo, Phys Rev. E. 
76026107 (doi:10:1103/PhysRevE.76.026107).  

(cc,cccyc,ccmid,ccin,ccout,nf) = dirclusteringcoeffs(A) returns different 
components of the clustering coefficients corresponding to cycles,
middles, in triangles, and out triangles.  See the manuscript for a 
description of the various types of triangles counted in the above metrics.</code></pre><p><strong>Functions</strong></p><ul><li>(cc,cccyc,ccmid,ccin,ccout,nf) = dirclustercoeffs{T}(A::SparseMatrixCSC{T,Int64},weighted::Bool)</li><li>(cc,cccyc,ccmid,ccin,ccout,nf) = dirclustercoeffs{T}(A::SparseMatrixCSC{T,Int64})</li><li>(cc,cccyc,ccmid,ccin,ccout,nf) = dirclustercoeffs{T}(A::SparseMatrixCSC{T,Int64},weighted::Bool,normalized::Bool)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">(A,xy,labels) = load_matrix_network_metadata(&quot;celegans&quot;)
(cc, cccyc, ccmid, ccin, ccout, nf) = dirclustercoeffs(A, true, true)
(maxval, maxind) = findmax(cc)
labels[maxind]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.directed_edges" href="#MatrixNetworks.directed_edges"><code>MatrixNetworks.directed_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">directed_edges(A) -&gt; srcs,dsts</code></pre><p>Produce lists just for all edges of the graph, including both sides for undirected edges. This is essentially the same as findnz for a sparse matrix, optimized not to return the values. </p></div></div></section><pre><code class="language-none">MatrixNetworks.edge_indicator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.edge_list" href="#MatrixNetworks.edge_list"><code>MatrixNetworks.edge_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the edge list of a matching output Example: M<em>out = bipartite</em>matching([10;12;13],[1;2;3],[3;2;4]) edge<em>list(M</em>out)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.empty_graph" href="#MatrixNetworks.empty_graph"><code>MatrixNetworks.empty_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>empty_graph</code></strong></p><p>Returns an empty graph with n vertices and zero edges</p><p><strong>Functions</strong></p><ul><li><code>A = empty_graph(n)</code> generates an empty graph on n edges.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">is_connected(empty_graph(0))
is_connected(empty_graph(1))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.enrich" href="#MatrixNetworks.enrich"><code>MatrixNetworks.enrich</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function adds the following helpers variables</p><ul><li>reduction_matrix - a reduction matrix to project down to the component graph</li><li>transitive_order - a transitive ordering of the components</li><li>transitive_map - a map to components that respects the transitive ordering</li><li>largest</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.erdos_renyi_directed" href="#MatrixNetworks.erdos_renyi_directed"><code>MatrixNetworks.erdos_renyi_directed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>erdos_renyi_directed</code></strong></p><p>Generate an directed Erdős-Rényi graph. A directed  Erdős-Rényi graph is generated by letting each directed edge between <code>n</code> nodes be present with probability <code>p</code>.</p><p>There is another form of the call where the input is the average degree of the generated graph. </p><p><strong>The current implementation uses sprand, this may change in the future.</strong> <strong>Do not depend on this routine for reliable output between versions.</strong></p><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes</li><li><code>p</code>: the probability of an edge.</li><li><code>d</code>: the average degree </li></ul><p><strong>Functions</strong></p><ul><li><code>erdos_renyi_directed(n::Int,p::Float64)</code> specify the probability (p &lt; 1.) or the average degree (p &gt;= 1.) </li><li><code>erdos_renyi_directed(n::Int,d::Int)</code> specify the average degree directly </li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the Erdős-Rényi graph. </li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.erdos_renyi_undirected" href="#MatrixNetworks.erdos_renyi_undirected"><code>MatrixNetworks.erdos_renyi_undirected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>erdos_renyi_undirected</code></strong></p><p>Generate an undirected Erdős-Rényi graph. An undirected   Erdős-Rényi graph is generated by letting each undirected edge between <code>n</code> nodes be present with probability <code>p</code>.</p><p>There is another form of the call where the input is the average degree of the generated graph. </p><p><strong>The current implementation uses sprand, this may change in the future.</strong> <strong>Do not depend on this routine for reliable output between versions.</strong></p><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes</li><li><code>p</code>: the probability of an edge, or the average degree.   if <span>$`p` &gt;= 1$</span>, then <span>$`p`$</span> is interpreted as an average degree  instead of a probability. (There is no point in generating  an Erdős-Rényi graph with probability <span>$`p`=1$</span>)</li><li><code>d</code>: The desired average degree, converted into a probabiltity   via d/n</li></ul><p><strong>Functions</strong></p><ul><li><code>erdos_renyi_undirected(n::Int,p::Float64)</code> specify the  probability or average degree</li><li><code>erdos_renyi_undirected(n::Int,d::Int)</code> specify the average degree directly         </li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the Erdős-Rényi graph.</li></ul><p><strong>Example</strong></p><pre><code class="language-none"># show the connected phase transition
n = 100
avgdegs = linspace(1.,2*log(n),100) 
compsizes = map( (dbar) -&gt; 
        maximum(scomponents(erdos_renyi_undirected(n,dbar)).sizes),
    avgdegs )
using Plots
unicodeplots()
plot(avgdegs,compsizes,xaxis=(&quot;average degree&quot;),yaxis=(&quot;largest component size&quot;))    </code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.erdős_rényi_directed" href="#MatrixNetworks.erdős_rényi_directed"><code>MatrixNetworks.erdős_rényi_directed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>erdos_renyi_directed</code></strong></p><p>Generate an directed Erdős-Rényi graph. A directed  Erdős-Rényi graph is generated by letting each directed edge between <code>n</code> nodes be present with probability <code>p</code>.</p><p>There is another form of the call where the input is the average degree of the generated graph. </p><p><strong>The current implementation uses sprand, this may change in the future.</strong> <strong>Do not depend on this routine for reliable output between versions.</strong></p><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes</li><li><code>p</code>: the probability of an edge.</li><li><code>d</code>: the average degree </li></ul><p><strong>Functions</strong></p><ul><li><code>erdos_renyi_directed(n::Int,p::Float64)</code> specify the probability (p &lt; 1.) or the average degree (p &gt;= 1.) </li><li><code>erdos_renyi_directed(n::Int,d::Int)</code> specify the average degree directly </li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the Erdős-Rényi graph. </li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.erdős_rényi_undirected" href="#MatrixNetworks.erdős_rényi_undirected"><code>MatrixNetworks.erdős_rényi_undirected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>erdos_renyi_undirected</code></strong></p><p>Generate an undirected Erdős-Rényi graph. An undirected   Erdős-Rényi graph is generated by letting each undirected edge between <code>n</code> nodes be present with probability <code>p</code>.</p><p>There is another form of the call where the input is the average degree of the generated graph. </p><p><strong>The current implementation uses sprand, this may change in the future.</strong> <strong>Do not depend on this routine for reliable output between versions.</strong></p><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes</li><li><code>p</code>: the probability of an edge, or the average degree.   if <span>$`p` &gt;= 1$</span>, then <span>$`p`$</span> is interpreted as an average degree  instead of a probability. (There is no point in generating  an Erdős-Rényi graph with probability <span>$`p`=1$</span>)</li><li><code>d</code>: The desired average degree, converted into a probabiltity   via d/n</li></ul><p><strong>Functions</strong></p><ul><li><code>erdos_renyi_undirected(n::Int,p::Float64)</code> specify the  probability or average degree</li><li><code>erdos_renyi_undirected(n::Int,d::Int)</code> specify the average degree directly         </li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the Erdős-Rényi graph.</li></ul><p><strong>Example</strong></p><pre><code class="language-none"># show the connected phase transition
n = 100
avgdegs = linspace(1.,2*log(n),100) 
compsizes = map( (dbar) -&gt; 
        maximum(scomponents(erdos_renyi_undirected(n,dbar)).sizes),
    avgdegs )
using Plots
unicodeplots()
plot(avgdegs,compsizes,xaxis=(&quot;average degree&quot;),yaxis=(&quot;largest component size&quot;))    </code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.fiedler_vector" href="#MatrixNetworks.fiedler_vector"><code>MatrixNetworks.fiedler_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>fiedler_vector</code></strong></p><p>Compute the Fiedler vector associated with the normalized Laplacian of the graph with adjacency matrix A.</p><p>This function works with Float32 and Float64-valued sparse matrices and vectors.</p><p>It requires a symmetric input matrix representing the adjacency matrix of an undirected graph. If the input is a disconnected network then the result may not</p><p>The return vector is signed so that the number of positive entries is at least the number of negative entries. This will always give a unique, deterministic output in the case of a non-repeated second eigenvalue.</p><p><strong>Functions</strong></p><ul><li><code>(v,lam2) = fiedler_vector(A::SparseMatrixCSC{V,Int})</code></li><li><code>(v,lam2) = fiedler_vector(A::MatrixNetwork{V,Int})</code></li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: the adjacency matrix</li><li>Optional Keywoard Inputs<ul><li><code>checksym</code>: ensure the matrix is symmetric</li><li><code>tol</code>: the residual tolerance in the eigenvalue, eigenvector estimate. (This is an absolute error)</li><li><code>maxiter</code>: the maximum iteration for ARPACK</li><li><code>nev</code>: the number of eigenvectors estimated by ARPACK</li><li><code>dense</code>: the threshold for a dense (LAPACK) computation instead of a sparse (ARPACK) computation. If the size of the matrix is less than <code>dense</code> then maxiter and nev are ignored and LAPACK computes all the eigenvalues.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>v</code>: The Fiedler vector as an array</li><li><code>lam2</code>: the eigenvalue itself</li></ul><p><strong>Example</strong></p><pre><code class="language-none"># construct an n-node path graph
n = 25
A = sparse(1:n-1,2:n,1.,n,n)
A = A + A&#39;
(v,lam2) = fiedler_vector(A) # returns a cosine-like fiedler vector
# using UnicodePlots; lineplot(v)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.floydwarshall" href="#MatrixNetworks.floydwarshall"><code>MatrixNetworks.floydwarshall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>FLOYDWARSHALL</strong></p><pre><code class="language-none">compute all shortest paths using the Floyd-Warshall algorithm.

(D,P) = floydwarshall(A) returns the shortest distance matrix between all pairs
of nodes in the graph A in matrix D.  If A has a negative weight cycle, then this
algorithm will throw an error. P is the matrix of predecessors.</code></pre><p><strong>Functions</strong></p><ul><li>(D,P) = floydwarshall(A::MatrixNetwork)</li><li>(D,P) = floydwarshall{T}(A::SparseMatrixCSC{T,Int64})</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;all_shortest_paths_example&quot;)
(D,P) = floydwarshall(A)</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.floydwarshall_phase1</code></pre><pre><code class="language-none">MatrixNetworks.floydwarshall_phase2</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.generalized_preferential_attachment_edges!" href="#MatrixNetworks.generalized_preferential_attachment_edges!"><code>MatrixNetworks.generalized_preferential_attachment_edges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>&#39;generalized<em>preferential</em>attachment_graph&#39;</strong></p><p>Generate an instance of a generalized preferential attachment graph which follows the Avin,Lotker,Nahum,Peleg description. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique</li><li>Add n - k0 vertices where at each time step one of three events occurs: A new</li></ul><p>node is added with probability p, a new edge between two existing nodes is added with probability r, two new nodes with an edge between them is added with probability 1 - p - r</p><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li>&#39;generalized<em>preferential</em>attachment_graph&#39;</li><li>&#39;gpa_graph&#39;</li></ul><p>and</p><ul><li>&#39;generalized<em>preferential</em>attachment_edges!&#39;</li><li>&#39;gpa_edges!&#39;</li></ul><p>The computational functions are</p><ul><li>&#39;gpa_graph(n,p,r,k0)&#39; Generate a GPA graph with a k0 clique and n total nodes.   This returns a MatrixNetwork type</li><li>&#39;gpa_graph(n,p,r,k0,Val{true})&#39; Generate a GPA graph with a k0 clique and   n total nodes, allowing self-loops. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li>&#39;gpa_edges!(n,p,r,edges,n0)&#39; Add new edges to an existing set, by taking   n0 time steps. Edges are added in one of three ways: From a new node to   an existing node with probability p, between two existing nodes with   probability r, between two new nodes with probability 1-p-r</li><li>&#39;gpa_edges!(n,p,r,edges,n0,Val{true})&#39; Add new edges to an existing set, by   taking n0 time steps. Edges are added in one of three ways: From a new node   to an existing node with probability p, between two existing nodes with   probability r (allowing self-loops), between two new nodes with probability   1-p-r</li></ul><p><strong>Input</strong></p><ul><li>&#39;n&#39;: the number of nodes in the final graph.</li><li>&#39;p&#39;: The probability of a node event, p must be a constant.</li><li>&#39;r&#39;: The probability of an edge event, r must be a constant. p+r &lt;=1</li><li>&#39;k0&#39;: the number of nodes in the starting clique.</li><li>&#39;Val{true}&#39;: Include this parameter if self-loops are allowed. Default is false</li><li>&#39;edges&#39;: A list of edges to be manipulated in the process of generating         new edges.</li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the generalized preferential attachment graph.</li><li>&#39;edges&#39;: An updated list of edges.</li></ul><p>Example: generalized<em>preferential</em>attachment_graph(100,1/3,1/2,2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.generalized_preferential_attachment_graph" href="#MatrixNetworks.generalized_preferential_attachment_graph"><code>MatrixNetworks.generalized_preferential_attachment_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>&#39;generalized<em>preferential</em>attachment_graph&#39;</strong></p><p>Generate an instance of a generalized preferential attachment graph which follows the Avin,Lotker,Nahum,Peleg description. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique</li><li>Add n - k0 vertices where at each time step one of three events occurs: A new</li></ul><p>node is added with probability p, a new edge between two existing nodes is added with probability r, two new nodes with an edge between them is added with probability 1 - p - r</p><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li>&#39;generalized<em>preferential</em>attachment_graph&#39;</li><li>&#39;gpa_graph&#39;</li></ul><p>and</p><ul><li>&#39;generalized<em>preferential</em>attachment_edges!&#39;</li><li>&#39;gpa_edges!&#39;</li></ul><p>The computational functions are</p><ul><li>&#39;gpa_graph(n,p,r,k0)&#39; Generate a GPA graph with a k0 clique and n total nodes.   This returns a MatrixNetwork type</li><li>&#39;gpa_graph(n,p,r,k0,Val{true})&#39; Generate a GPA graph with a k0 clique and   n total nodes, allowing self-loops. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li>&#39;gpa_edges!(n,p,r,edges,n0)&#39; Add new edges to an existing set, by taking   n0 time steps. Edges are added in one of three ways: From a new node to   an existing node with probability p, between two existing nodes with   probability r, between two new nodes with probability 1-p-r</li><li>&#39;gpa_edges!(n,p,r,edges,n0,Val{true})&#39; Add new edges to an existing set, by   taking n0 time steps. Edges are added in one of three ways: From a new node   to an existing node with probability p, between two existing nodes with   probability r (allowing self-loops), between two new nodes with probability   1-p-r</li></ul><p><strong>Input</strong></p><ul><li>&#39;n&#39;: the number of nodes in the final graph.</li><li>&#39;p&#39;: The probability of a node event, p must be a constant.</li><li>&#39;r&#39;: The probability of an edge event, r must be a constant. p+r &lt;=1</li><li>&#39;k0&#39;: the number of nodes in the starting clique.</li><li>&#39;Val{true}&#39;: Include this parameter if self-loops are allowed. Default is false</li><li>&#39;edges&#39;: A list of edges to be manipulated in the process of generating         new edges.</li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the generalized preferential attachment graph.</li><li>&#39;edges&#39;: An updated list of edges.</li></ul><p>Example: generalized<em>preferential</em>attachment_graph(100,1/3,1/2,2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.gpa_edges!" href="#MatrixNetworks.gpa_edges!"><code>MatrixNetworks.gpa_edges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>&#39;generalized<em>preferential</em>attachment_graph&#39;</strong></p><p>Generate an instance of a generalized preferential attachment graph which follows the Avin,Lotker,Nahum,Peleg description. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique</li><li>Add n - k0 vertices where at each time step one of three events occurs: A new</li></ul><p>node is added with probability p, a new edge between two existing nodes is added with probability r, two new nodes with an edge between them is added with probability 1 - p - r</p><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li>&#39;generalized<em>preferential</em>attachment_graph&#39;</li><li>&#39;gpa_graph&#39;</li></ul><p>and</p><ul><li>&#39;generalized<em>preferential</em>attachment_edges!&#39;</li><li>&#39;gpa_edges!&#39;</li></ul><p>The computational functions are</p><ul><li>&#39;gpa_graph(n,p,r,k0)&#39; Generate a GPA graph with a k0 clique and n total nodes.   This returns a MatrixNetwork type</li><li>&#39;gpa_graph(n,p,r,k0,Val{true})&#39; Generate a GPA graph with a k0 clique and   n total nodes, allowing self-loops. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li>&#39;gpa_edges!(n,p,r,edges,n0)&#39; Add new edges to an existing set, by taking   n0 time steps. Edges are added in one of three ways: From a new node to   an existing node with probability p, between two existing nodes with   probability r, between two new nodes with probability 1-p-r</li><li>&#39;gpa_edges!(n,p,r,edges,n0,Val{true})&#39; Add new edges to an existing set, by   taking n0 time steps. Edges are added in one of three ways: From a new node   to an existing node with probability p, between two existing nodes with   probability r (allowing self-loops), between two new nodes with probability   1-p-r</li></ul><p><strong>Input</strong></p><ul><li>&#39;n&#39;: the number of nodes in the final graph.</li><li>&#39;p&#39;: The probability of a node event, p must be a constant.</li><li>&#39;r&#39;: The probability of an edge event, r must be a constant. p+r &lt;=1</li><li>&#39;k0&#39;: the number of nodes in the starting clique.</li><li>&#39;Val{true}&#39;: Include this parameter if self-loops are allowed. Default is false</li><li>&#39;edges&#39;: A list of edges to be manipulated in the process of generating         new edges.</li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the generalized preferential attachment graph.</li><li>&#39;edges&#39;: An updated list of edges.</li></ul><p>Example: generalized<em>preferential</em>attachment_graph(100,1/3,1/2,2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.gpa_graph" href="#MatrixNetworks.gpa_graph"><code>MatrixNetworks.gpa_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>&#39;generalized<em>preferential</em>attachment_graph&#39;</strong></p><p>Generate an instance of a generalized preferential attachment graph which follows the Avin,Lotker,Nahum,Peleg description. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique</li><li>Add n - k0 vertices where at each time step one of three events occurs: A new</li></ul><p>node is added with probability p, a new edge between two existing nodes is added with probability r, two new nodes with an edge between them is added with probability 1 - p - r</p><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li>&#39;generalized<em>preferential</em>attachment_graph&#39;</li><li>&#39;gpa_graph&#39;</li></ul><p>and</p><ul><li>&#39;generalized<em>preferential</em>attachment_edges!&#39;</li><li>&#39;gpa_edges!&#39;</li></ul><p>The computational functions are</p><ul><li>&#39;gpa_graph(n,p,r,k0)&#39; Generate a GPA graph with a k0 clique and n total nodes.   This returns a MatrixNetwork type</li><li>&#39;gpa_graph(n,p,r,k0,Val{true})&#39; Generate a GPA graph with a k0 clique and   n total nodes, allowing self-loops. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li>&#39;gpa_edges!(n,p,r,edges,n0)&#39; Add new edges to an existing set, by taking   n0 time steps. Edges are added in one of three ways: From a new node to   an existing node with probability p, between two existing nodes with   probability r, between two new nodes with probability 1-p-r</li><li>&#39;gpa_edges!(n,p,r,edges,n0,Val{true})&#39; Add new edges to an existing set, by   taking n0 time steps. Edges are added in one of three ways: From a new node   to an existing node with probability p, between two existing nodes with   probability r (allowing self-loops), between two new nodes with probability   1-p-r</li></ul><p><strong>Input</strong></p><ul><li>&#39;n&#39;: the number of nodes in the final graph.</li><li>&#39;p&#39;: The probability of a node event, p must be a constant.</li><li>&#39;r&#39;: The probability of an edge event, r must be a constant. p+r &lt;=1</li><li>&#39;k0&#39;: the number of nodes in the starting clique.</li><li>&#39;Val{true}&#39;: Include this parameter if self-loops are allowed. Default is false</li><li>&#39;edges&#39;: A list of edges to be manipulated in the process of generating         new edges.</li></ul><p><strong>Output</strong></p><ul><li>A matrix network type for the generalized preferential attachment graph.</li><li>&#39;edges&#39;: An updated list of edges.</li></ul><p>Example: generalized<em>preferential</em>attachment_graph(100,1/3,1/2,2)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.havel_hakimi_graph" href="#MatrixNetworks.havel_hakimi_graph"><code>MatrixNetworks.havel_hakimi_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>havel_hakimi_graph</code></strong></p><p>Create a graph with a given degree sequence </p><p><strong>Usage</strong></p><p><code>A = havel_hakimi_graph(d)</code> returns an instance of the  a graph with degree sequence d or throws ArgumentError if the degree sequence is not graphical.   </p><p><strong>Input</strong></p><ul><li><code>d::Vector{Int}</code>:  a vector of integer valued degrees</li></ul><p><strong>Output</strong></p><p>-<code>A</code>: a matrix network for the undirected graph that results from the Havel-Hakimi procedure.</p></div></div></section><pre><code class="language-none">MatrixNetworks.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.is_connected" href="#MatrixNetworks.is_connected"><code>MatrixNetworks.is_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>is_connected</code></strong></p><p>Check the matrix associated with a matrix network for (strong) connectivity  </p><p><strong>Usage</strong></p><ul><li><code>is_connected(A)</code></li></ul><p><strong>Input</strong></p><ul><li><code>A</code>: a <code>MatrixNetwork</code> or <code>SparseMatrixCSC</code> class</li></ul><p><strong>Returns</strong></p><ul><li><code>bool</code> with true indicating the matrix is strongly connected</li></ul><p>and false indicating </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.is_empty" href="#MatrixNetworks.is_empty"><code>MatrixNetworks.is_empty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>is_empty</code></strong></p><p>Return true if the graph is the empty graph and  false otherwise. </p><p><strong>Functions</strong></p><p>-<code>is_empty(A::MatrixNetwork)</code></p><p><strong>Example</strong></p><pre><code class="language-none">is_empty(MatrixNetwork(Int[],Int[],0))
is_empty(erdos_renyi_undirected(0,0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.is_graphical_sequence" href="#MatrixNetworks.is_graphical_sequence"><code>MatrixNetworks.is_graphical_sequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>is_graphical_sequence</code></strong></p><p>Check whether or not a degree sequence is graphical, which means that it is a valid degree sequence for  an undirected graph.</p><p>Note that this does not mean it is a valid degree sequence for a connected undirected graph. So, for instance,  <code>[1,1,1,1]</code>  is a valid degree sequence for two disconnected edges</p><p><strong>Usage</strong></p><p><code>is_graphical_sequence(d)</code> returns true or false </p><p><strong>Input</strong></p><ul><li><code>d::Vector{Int}</code>:  a vector of integer valued degrees</li></ul><p><strong>Output</strong></p><ul><li>a boolean that is true if the sequence is graphical</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.is_undirected" href="#MatrixNetworks.is_undirected"><code>MatrixNetworks.is_undirected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>is_undirected</code></strong></p><p>Check the matrix associated with a matrix network for symmetry. </p><p><strong>Input</strong></p><ul><li><code>A</code>: a matrix network</li></ul><p><strong>Returns</strong></p><ul><li><code>bool</code> with true indicating the network is undirected   and the matrix is symmetric</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.largest_component" href="#MatrixNetworks.largest_component"><code>MatrixNetworks.largest_component</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>LARGEST_COMPONENT</strong></p><pre><code class="language-none">return the largest connected component of A.
Acc = largest_component(A) returns the largest connected component
of the graph A.  If A is directed, this returns the largest
strongly connected component.

Acc = largest_component(A,true) returns the largest connected piece of
a directed graph where connectivity is undirected.  Algorithmically,
this takes A, drops the directions, then components the largest component
and returns just this piece of the original _directed_ network.  So the
output Acc is directed in this case.

(Acc,p) = largest_component(A) also returns a logical vector
indicating which vertices in A were chosen.</code></pre><p><strong>Functions</strong></p><ul><li>(Acc,p) = largest_component{T}(A::SparseMatrixCSC{T,Int64})</li><li>(Acc,p) = largest_component{T}(A::SparseMatrixCSC{T,Int64},sym::Bool)</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;dfs_example&quot;)
(Acc,p) = largest_component(A)</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.load_matrix_network</code></pre><pre><code class="language-none">MatrixNetworks.load_matrix_network_all</code></pre><pre><code class="language-none">MatrixNetworks.load_matrix_network_metadata</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.lollipop_graph" href="#MatrixNetworks.lollipop_graph"><code>MatrixNetworks.lollipop_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>lollipop_graph</code></strong></p><p>Generate a lollipop graph, which consists of a clique with a line tail, so it looks like a lollipop.</p><p><strong>Functions</strong></p><ul><li><code>lollipop_graph(n)</code> generate the graph with an n-node tail and n-node clique</li><li><code>lollipop_graph(n,m)</code> generate the graph with an n-node tail and m-node clique</li><li><code>lollipop_graph(n,m,Val{true})</code> produce and return xy coordinates as well. </li></ul><p><strong>Examples</strong></p></div></div></section><pre><code class="language-none">MatrixNetworks.matrix_network_datasets</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.mst_prim" href="#MatrixNetworks.mst_prim"><code>MatrixNetworks.mst_prim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>MST_PRIM</strong></p><pre><code class="language-none">compute a minimum spanning tree with Prim&#39;s algorithm.
T = mst_prim_matrix(A) computes a minimum spanning tree T using Prim&#39;s algorithm
for the spanning tree of a graph with non-negative edge weights.

T = mst_prim_matrix(A,false) produces an MST for just the component at A containing
vertex 1.  T = mst_prim_matrix(A,0,u) produces the MST for the component
containing vertex u.

(ti,tj,tv,nverts) = mst_prim(A) returns the edges from the matrix and does not
convert to a sparse matrix structure.  This saves a bit of work and is
required when there are 0 edge weights.</code></pre><p><strong>Functions</strong></p><ul><li>(ti,tj,tv,nverts) = mst_prim(A::MatrixNetwork,full::Bool,u::Int64)</li><li>(ti,tj,tv,nverts) = mst_prim(A::MatrixNetwork)</li><li>(ti,tj,tv,nverts) = mst_prim{T}(A::SparseMatrixCSC{T,Int64},full::Bool,u::Int64)</li><li>(ti,tj,tv,nverts) = mst_prim{T}(A::SparseMatrixCSC{T,Int64})</li><li>T = mst<em>prim</em>matrix(A::MatrixNetwork,full::Bool,u::Int64) #output modifier</li><li>T = mst<em>prim</em>matrix(A::MatrixNetwork) #output modifier</li><li>T = mst<em>prim</em>matrix{T}(A::SparseMatrixCSC{T,Int64},full::Bool,u::Int64) #output modifier</li><li>T = mst<em>prim</em>matrix{T}(A::SparseMatrixCSC{T,Int64}) #output modifier</li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;airports&quot;)
A = -A #convert to travel time
A = max.(A,A&#39;)
A = sparse(A)
(ti,tj,tv,nverts) = mst_prim(A)</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.mst_prim_matrix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.pa_edges!" href="#MatrixNetworks.pa_edges!"><code>MatrixNetworks.pa_edges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>preferential_attachment_graph</code></strong></p><p>Generate an instance of a preferential attachment graph. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique. </li><li>Add n-k0 vertices where     each vertex links to k nodes chosen    based their degree (and repeats    are allowed).</li></ul><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li><code>preferential_attachment_graph</code></li><li><code>pa_graph</code></li></ul><p>and</p><ul><li><code>preferential_attachment_edges!</code></li><li><code>pa_edges!</code></li></ul><p>The computational functions are</p><ul><li><code>pa_graph(n,k,k0)</code> Generate a PA graph with a k0 node clique and n total nodes and k edges added per node. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li><code>pa_edges!(nnew,k,edges)</code> Add new edges to an  existing set by adding <code>nnew</code> nodes to the set of edges where each node picks k edges based on the degrees. The new node ids are based on the largest entry in the edges array. </li><li><code>pa_edges!(nnew,k,edges,n0)</code> Generate a set of edges total` nodes to the set of edges where n0+1 is the starting index for the new set of nodes   </li></ul><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes in the final graph</li><li><code>k</code>: the number of links picked by each node when it is added. The actual degree can be larger or smaller than this number because of links from other nodes or duplicates selected. </li><li><code>k0</code>: The number of nodes in the starting clique. </li><li><code>edges</code>: A list of edges to be manipulated in the process of </li></ul><p>generating new edges. </p><p><strong>Output</strong></p><ul><li>A matrix network type for the preferential attachment graph.</li><li><code>edges</code> An updated list of edges. </li></ul><p><strong>Example</strong></p><pre><code class="language-none">pa_graph(100,5,2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.pa_graph" href="#MatrixNetworks.pa_graph"><code>MatrixNetworks.pa_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>preferential_attachment_graph</code></strong></p><p>Generate an instance of a preferential attachment graph. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique. </li><li>Add n-k0 vertices where     each vertex links to k nodes chosen    based their degree (and repeats    are allowed).</li></ul><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li><code>preferential_attachment_graph</code></li><li><code>pa_graph</code></li></ul><p>and</p><ul><li><code>preferential_attachment_edges!</code></li><li><code>pa_edges!</code></li></ul><p>The computational functions are</p><ul><li><code>pa_graph(n,k,k0)</code> Generate a PA graph with a k0 node clique and n total nodes and k edges added per node. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li><code>pa_edges!(nnew,k,edges)</code> Add new edges to an  existing set by adding <code>nnew</code> nodes to the set of edges where each node picks k edges based on the degrees. The new node ids are based on the largest entry in the edges array. </li><li><code>pa_edges!(nnew,k,edges,n0)</code> Generate a set of edges total` nodes to the set of edges where n0+1 is the starting index for the new set of nodes   </li></ul><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes in the final graph</li><li><code>k</code>: the number of links picked by each node when it is added. The actual degree can be larger or smaller than this number because of links from other nodes or duplicates selected. </li><li><code>k0</code>: The number of nodes in the starting clique. </li><li><code>edges</code>: A list of edges to be manipulated in the process of </li></ul><p>generating new edges. </p><p><strong>Output</strong></p><ul><li>A matrix network type for the preferential attachment graph.</li><li><code>edges</code> An updated list of edges. </li></ul><p><strong>Example</strong></p><pre><code class="language-none">pa_graph(100,5,2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.pagerank" href="#MatrixNetworks.pagerank"><code>MatrixNetworks.pagerank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>pagerank</code></strong></p><p>PageRank is the stationary distribution of a Markov chain defined as follows. The behavior of the chain at state i is: </p><ul><li>with probability <span>$lpha$</span>, randomly transition to an out-neighbor of the current node (based on a weighted probabilities if the graph has non-negative weights).</li><li>with probability <span>$1-lpha$</span>, jump to a random node chosen anywhere in the network. </li><li>if there are no out-neighbors, then jump anywhere in the network  with equal probability. </li></ul><p>The solution satisfies a linear system of equations. This function will solve that linear system to a 1-norm error of <code>tol</code> where <code>tol</code> is chosen by default to be the machine precision. </p><p>The solution is always a probability distribution.        </p><p><strong>Functions</strong></p><ul><li><code>x = pagerank(A::SparseMatrixCSC{V,Int},alpha::Float64)</code></li><li><code>x = pagerank(A::MatrixNetwork{V},alpha::Float64)</code></li><li><code>x = pagerank(A,alpha,eps::Float64)</code> specifies solution tolerance too.        </li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: The sparse matrix or matrix network that you wish to use to compute PageRank. In the case of a sparse matrix, it must have non-negative values and the values will impact the  computation as we will compute a stochastic normalization  as part of the algorithm.  </li><li><code>alpha</code>: the teleportation parameter given above.</li><li><code>tol</code>: the tolerance, the default choice is machine precision  for floating point, which is more than enough for almost all  applications. </li></ul><p><strong>Examples</strong></p><pre><code class="language-none">pagerank(A,alpha) 
            # return the standard PageRank vector 
            # with uniform teleportation and alpha=0.85 
            # computed to machine precision            </code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.pagerank_power!" href="#MatrixNetworks.pagerank_power!"><code>MatrixNetworks.pagerank_power!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>pagerank_power!</code></strong></p><p><strong>Expert interface</strong></p><p>This function computes the strongly personalized PageRank vector of a column sub-stochastic matrix P.</p><p>This is a powerful internal function and you most likely don&#39;t want  to use it unless you know what you are doing.  </p><p>This call is duck-typed so that it can work with arbitrary input matrix types as well as arbitrary vectors v. This enables it to be efficient in the case of sparse or dense vectors v.</p><p>The solution returned will satisfy the strongly-personalized PageRank equation to the given tolerance accuracy in the 1-norm. Formally, it&#39;ll </p><p>This call allocates no extra memory and only uses the memory included with the vectors x and y. </p><p><strong>Functions</strong></p><ul><li><code>pagerank_power!{T&lt;Float}!(x::Vector{T}, y::Vector{T},        P, alpha::T, v, tol::T, maxiter::Int, iterfunc::Function)</code> </li></ul><p><strong>Inputs</strong></p><ul><li><code>x</code>: a vector (of length n, where there are n nodes of the graph) that will store </li><li><code>y</code>: a vector that is used as part of the matrix-vector multiplication and the iteration procedure. It is just extra memory.</li><li><code>P</code>: a duck typed matrix to apply the stochastic operator     the type P must support P<em>x and P</em>y    </li><li><code>alpha</code>: the teleportation parameter, alpha must be between 0 and 1. This is the probability that the model follows the graph (so the problem is hard when alpha is close to 1).</li><li><code>v</code>: a duck typed vector to apply the personalization       the type v must support x += v where x is a Vector{T}       examples of v include a scalar, a sparsevec, or a Vector{T}</li><li><code>tol</code>: the solution tolerance in the error 1-norm.</li><li><code>maxiter</code>: the maximum number of iterations</li><li><code>iterfunc</code>: a function that will be called on each iteration</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: The PageRank vector (just another reference to the input x)</li></ul><p><strong>Example</strong></p><pre><code class="language-none"></code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.personalized_pagerank</code></pre><pre><code class="language-none">MatrixNetworks.personalized_pagerank!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.preferential_attachment_edges!" href="#MatrixNetworks.preferential_attachment_edges!"><code>MatrixNetworks.preferential_attachment_edges!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>preferential_attachment_graph</code></strong></p><p>Generate an instance of a preferential attachment graph. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique. </li><li>Add n-k0 vertices where     each vertex links to k nodes chosen    based their degree (and repeats    are allowed).</li></ul><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li><code>preferential_attachment_graph</code></li><li><code>pa_graph</code></li></ul><p>and</p><ul><li><code>preferential_attachment_edges!</code></li><li><code>pa_edges!</code></li></ul><p>The computational functions are</p><ul><li><code>pa_graph(n,k,k0)</code> Generate a PA graph with a k0 node clique and n total nodes and k edges added per node. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li><code>pa_edges!(nnew,k,edges)</code> Add new edges to an  existing set by adding <code>nnew</code> nodes to the set of edges where each node picks k edges based on the degrees. The new node ids are based on the largest entry in the edges array. </li><li><code>pa_edges!(nnew,k,edges,n0)</code> Generate a set of edges total` nodes to the set of edges where n0+1 is the starting index for the new set of nodes   </li></ul><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes in the final graph</li><li><code>k</code>: the number of links picked by each node when it is added. The actual degree can be larger or smaller than this number because of links from other nodes or duplicates selected. </li><li><code>k0</code>: The number of nodes in the starting clique. </li><li><code>edges</code>: A list of edges to be manipulated in the process of </li></ul><p>generating new edges. </p><p><strong>Output</strong></p><ul><li>A matrix network type for the preferential attachment graph.</li><li><code>edges</code> An updated list of edges. </li></ul><p><strong>Example</strong></p><pre><code class="language-none">pa_graph(100,5,2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.preferential_attachment_graph" href="#MatrixNetworks.preferential_attachment_graph"><code>MatrixNetworks.preferential_attachment_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>preferential_attachment_graph</code></strong></p><p>Generate an instance of a preferential attachment graph. This is an undirected graph that is generated as follows:</p><ul><li>Start with a k0-node clique. </li><li>Add n-k0 vertices where     each vertex links to k nodes chosen    based their degree (and repeats    are allowed).</li></ul><p><strong>Functions</strong></p><p>The following functions are synonyms</p><ul><li><code>preferential_attachment_graph</code></li><li><code>pa_graph</code></li></ul><p>and</p><ul><li><code>preferential_attachment_edges!</code></li><li><code>pa_edges!</code></li></ul><p>The computational functions are</p><ul><li><code>pa_graph(n,k,k0)</code> Generate a PA graph with a k0 node clique and n total nodes and k edges added per node. This returns a MatrixNetwork type</li></ul><p>The edge functions are</p><ul><li><code>pa_edges!(nnew,k,edges)</code> Add new edges to an  existing set by adding <code>nnew</code> nodes to the set of edges where each node picks k edges based on the degrees. The new node ids are based on the largest entry in the edges array. </li><li><code>pa_edges!(nnew,k,edges,n0)</code> Generate a set of edges total` nodes to the set of edges where n0+1 is the starting index for the new set of nodes   </li></ul><p><strong>Input</strong></p><ul><li><code>n</code>: the number of nodes in the final graph</li><li><code>k</code>: the number of links picked by each node when it is added. The actual degree can be larger or smaller than this number because of links from other nodes or duplicates selected. </li><li><code>k0</code>: The number of nodes in the starting clique. </li><li><code>edges</code>: A list of edges to be manipulated in the process of </li></ul><p>generating new edges. </p><p><strong>Output</strong></p><ul><li>A matrix network type for the preferential attachment graph.</li><li><code>edges</code> An updated list of edges. </li></ul><p><strong>Example</strong></p><pre><code class="language-none">pa_graph(100,5,2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.random_edge" href="#MatrixNetworks.random_edge"><code>MatrixNetworks.random_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>random_edge</code></strong></p><p>Identify a random edge of a matrix network or sparse matrix.</p><p><strong>Functions</strong></p><ul><li><code>random_edge(A::MatrixNetwork) -&gt; (ei,ej,ind)</code>   gets a random edge/non-zero from the matrix</li><li><code>random_edge(A::SparseMatrixCSC) -&gt; (ei,ej,ind)</code>   gets a random non-zero from the matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-none">G = lollipop_graph(5,3)
# count the number of edges we randomly see between the regions
C = Dict{Symbol,Int}()
M = zeros(8,8)
for i=1:1000000
  ei,ej = MatrixNetwork.random_edge(G)
  M[ei,ej] += 1
  if 1 &lt;= ei &lt;= 5 &amp;&amp; 1 &lt;= ej &lt;= 5
    C[:Stem] = get(C, :Stem, 0) + 1
  elseif 6 &lt;= ei &lt;= 10 &amp;&amp; 6 &lt;= ej &lt;= 10
    C[:Pop] = get(C, :Pop, 0) + 1  
  else
    C[:Bridge] = get(C, :Bridge, 0) + 1  
  end
end
# 4 edges in stem, 3 edges in pop, 1 edge in bridge 
@show C
@show M</code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.readSMAT</code></pre><pre><code class="language-none">MatrixNetworks.rewire_graph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.roach_graph" href="#MatrixNetworks.roach_graph"><code>MatrixNetworks.roach_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>roach_graph</code></strong></p><p>Generate a roach graph on 4n vertices which follows the Guattery-Miller  description. The roach graph has a body that consists of 2n vertices which ard two n-vertex line-graphs that have been connected together. The body has two antennae that result from adding an n-vertex line graph  to one vertex on each side. </p><pre><code class="language-none"># the graph looks like
#
# (           top body               )   (       top antennae       )    
#
# o - o - o - ... n vertices total - o - o - ... n vertices total - 0
# |   |   |   ...    |   |   |   |   |
# o - o - o - ... n vertices total - o - o - ... n vertices total - 0
#
# (         bottom body              )   (     bottom antennae      )
#
# there are 4n vertices and 2(2n-1) + n edges</code></pre><p><strong>Functions</strong></p><ul><li><code>roach_graph(n) -&gt; A::MatrixNetwork</code></li><li><code>roach_graph(n, Val{true}) -&gt; (A::MatrixNetwork, Matrix{Float64})</code> this also returns coordinates for the graph. </li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = sparse_transpose(roach_graph(3, Val{true})) # get back the matrix 
L = spdiagm(vec(sum(A,2))) - A

#lams,vecs = eig(full(L))
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.scomponents" href="#MatrixNetworks.scomponents"><code>MatrixNetworks.scomponents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>SCOMPONENTS</strong></p><pre><code class="language-none">compute the strongly connected components of a graph

ci=scomponents(A) returns an index for the component number of every 
vertex in the graph A.  The total number of components is maximum(ci).
If the input is undirected, then this algorithm outputs just the 
connected components.  Otherwise, it output the strongly connected components.

The implementation is from Tarjan&#39;s 1972 paper: Depth-first search and 
linear graph algorithms. In SIAM&#39;s Journal of Computing, 1972, 1, 
pp.146-160.</code></pre><p><strong>Functions</strong></p><ul><li><code>cc = scomponents(A::MatrixNetwork)</code></li><li><code>cc = scomponents{T}(A::SparseMatrixCSC{T,Int64})</code></li><li><code>sci = strong_components_map(A::MatrixNetwork)</code></li><li><code>sci = strong_components_map{T}(A::SparseMatrixCSC{T,Int64})</code></li><li><code>sc_rich = enrich(cc::Strong_components_output) # check ?enrich for more</code></li></ul><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;cores_example&quot;)
cc = scomponents(A)
scomponents(A).number
scomponents(A).sizes      
scomponents(A).map  
strong_components_map(A)     # if you just want the map
enrich(scomponents(A)) # produce additional enriched output

# Can work on [ei,ej]
ei = [1;2;3]
ej = [2;4;1]
cc = scomponents(ei,ej)

# Can work on sparse matrix A
A = sprand(5,5,0.5)
cc = scomponents(A)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.seeded_pagerank" href="#MatrixNetworks.seeded_pagerank"><code>MatrixNetworks.seeded_pagerank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>seeded_pagerank</code></strong></p><p>PageRank is the stationary distribution of a Markov chain defined as follows. The behavior of the chain at state i is: </p><ul><li>with probability <span>$lpha$</span>, randomly transition to an out-neighbor of the current node (based on a weighted probabilities if the graph has non-negative weights).</li><li>with probability <span>$1-lpha$</span>, jump according to a distribution called the teleportation distribution and given by a vector <span>$v$</span>. (In the standard case, <span>$v$</span> is the uniform distribution over nodes, but this is a parameter).</li><li>if there are no out-neighbors, then transition according to the teleportation distribution (this is the strongly-personalized problem).</li></ul><p>When <span>$v$</span> is the uniform vector, then we compute the same thing as the PageRank call itself.    </p><p>The solution satisfies a linear system of equations. This function will solve that linear system to a 1-norm error of <code>tol</code> where <code>tol</code> is chosen by default to be the machine precision. </p><p>The solution is always a probability distribution.</p><p><strong>Functions</strong></p><ul><li>For any input, A can be either <code>A::SparseMatrixCSC{V,Int}</code> for some value type V or <code>A::MatrixNetwork{V}</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Float64)</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Int)</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Set{Int})</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Dict{Int,Float64})</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::SparseMatrixCSC{Float64})</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::SparseVector{Float64})</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Vector{Float64})</code></li><li><code>x = seeded_pagerank(A,alpha::Float64,v::Vector{Float64})</code></li><li><code>x = seeded_pagerank(A,alpha,v,eps::Float64)</code> specifies solution tolerance too.        </li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: The sparse matrix or matrix network that you wish to use to compute PageRank. In the case of a sparse matrix, it must have non-negative values and the values will impact the  computation as we will compute a stochastic normalization  as part of the algorithm.  </li><li><code>alpha</code>: the teleportation parameter given above.</li><li><code>v</code>: the teleportation distribution vector. This can be an integer to teleport to a single node, a set to teleport (uniformly) to a set of nodes, a dictionary or sparse vector to weight the teleportation. Or a general dense vector. </li><li><code>tol</code>: the tolerance that we solve the linear system to (this is an error guarantee)  </li></ul><p><strong>Examples</strong></p><pre><code class="language-none">seeded_pagerank(A,alpha,5) 
            # return the seeded PageRank vector 
            # with teleportation to node 5 
            # computed to machine precision            </code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.seeded_stochastic_heat_kernel" href="#MatrixNetworks.seeded_stochastic_heat_kernel"><code>MatrixNetworks.seeded_stochastic_heat_kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>seeded_stochastic_heat_kernel</code></strong></p><p>Compute the stochastic heat kernel, the result of <span>$x = \exp(-t(I - P)) s $ where $s$</span> is a stochastic seed vector and <span>$t$</span> is a time parameter and <span>$P$</span> is a column-stochastic or sub-stochastic matrix. </p><p>This function will return a vector <span>$x$</span> such that $ \| x - x<em>{\mbox{exact}} \|</em>1 \le $ <code>eps</code>, and this function further guarantees  <span>$x_{\mbox{exact}} - x \ge 0$</span>.</p><p><strong>Functions</strong></p><ul><li>The input A can be either a <code>A::SparseMatrixCSC{V,Int}</code> or <code>A::MatrixNetwork{V}</code> for some value type <code>V</code> </li><li><code>seeded_stochastic_heat_kernel(A,t::Float64,s)</code> provides the stochastic seed <code>s</code> in any of the following forms:</li><li><code>seeded_stochastic_heat_kernel(A,t,s::Float64)</code>: s must be the number 1/size(A,1) and this corresponds to using the all-ones vector. </li><li><code>seeded_stochastic_heat_kernel(A,t,s::Int)</code> use the vector with just a single non-zero</li><li><code>seeded_stochastic_heat_kernel(A,t,s::Set{Int})</code> </li><li><code>seeded_stochastic_heat_kernel(A,t,s::Dict{Int,Float64})</code></li><li><code>seeded_stochastic_heat_kernel(A,t,s::SparseMatrixCSC{Float64,Int})</code></li><li><code>seeded_stochastic_heat_kernel(A,t,s::SparseVector{Float64,Int})</code></li><li><code>seeded_stochastic_heat_kernel(A,t,s::Vector{Float64})</code>      </li><li><code>seeded_stochastic_heat_kernel(A,t::Float64,s,eps::Float64)</code>: specifies  the solution tolerance (default <code>eps=eps(Float64)</code>)</li></ul><p><strong>Inputs</strong></p><p>-<code>A</code>: A sparse matrix with non-negative entries or a matrix network object  -<code>t</code>: the value of time in the heat kernel <span>$0 &lt;= t$</span> -<code>eps</code>: the solution tolerance $ 0 &lt; eps &lt; 1 $ -<code>s</code>: the stochastic seed vector, this will be normalized to be stochastic</p><p><strong>Returns</strong></p><p>-<code>x</code>: the result of the stochastic heat kernel evaluation</p><p><strong>Examples</strong></p><pre><code class="language-none"></code></pre></div></div></section><pre><code class="language-none">MatrixNetworks.seeded_stochastic_heat_kernel!</code></pre><pre><code class="language-none">MatrixNetworks.show</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.sparse_to_csr" href="#MatrixNetworks.sparse_to_csr"><code>MatrixNetworks.sparse_to_csr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>SPARSETOCSR</strong></p><pre><code class="language-none">convert sparse matrix into compressed row storage arrays
and returns the row pointer (rp), column index (ci) and value index (ai) arrays 
of a compressed sparse representation of the matrix A (or its triplet format storage)</code></pre><p><strong>Functions</strong></p><ul><li>(rp,ci,ai,m) = sparse<em>to</em>csr{T}(A::SparseMatrixCSC{T,Int64})</li><li>(rp,ci,ai,m) = sparse<em>to</em>csr{T}(nzi::Array{Int64,1},nzj::Array{Int64,1},nzv::Array{T,1}) </li></ul><p><strong>Example</strong></p><pre><code class="language-none">i = [1;2;3]
j = [3;4;4]
v = [8;9;10]
(rp,ci,ai,m) = sparse_to_csr(i,j,v)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.sparse_transpose" href="#MatrixNetworks.sparse_transpose"><code>MatrixNetworks.sparse_transpose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return back an adjacency matrix representation of the transpose. This requires no work. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.spectral_cut" href="#MatrixNetworks.spectral_cut"><code>MatrixNetworks.spectral_cut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>spectral_cut</code></strong></p><p><code>spectral_cut</code> will produce a spectral cut partition of the graph into two pieces.</p><p>Special cases</p><ul><li>if your graph is disconnected, then we will partition it into the</li></ul><p>largest connected component (chosen arbitrary if there are multiple) and produce a cut of just the largest connected component.</p><ul><li>if your graph is a single node, we will partition it into the empty</li></ul><p>cut.</p><p><strong>Output</strong></p><p>The output has type SpectralCut We always return the smaller side of the cut in terms of total volume.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: The sparse matrix or martrix network that you want to find the spectral cut for.</li><li><code>checksym</code>: Should we check symmetry? Don&#39;t set this to false unless you have checked symmetry in another call. <em>This may go away in future interfaces</em></li><li><code>ccwarn</code>: Turn off the warning for disconnected graphs. This useful in larger subroutines where this is handled through another mechanism.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.stochastic_heat_kernel_series!" href="#MatrixNetworks.stochastic_heat_kernel_series!"><code>MatrixNetworks.stochastic_heat_kernel_series!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>stochastic_heat_kernel_series!</code></strong></p><p>Compute the stochastic heat kernel, the result of <span>$x = \exp(-t(I - P)) s $ where $s$</span> is a stochastic seed vector and <span>$t$</span> is a time parameter and <span>$P$</span> is a column-stochastic or sub-stochastic matrix. </p><p>This function will return a vector <span>$x$</span> such that $ \| x - x<em>{\mbox{exact}} \|</em>1 \le $ <code>eps</code>, and this function further guarantees  <span>$x_{\mbox{exact}} - x \ge 0$</span>.</p><p>The algorithm is just a direct evaluation of the power series represented by the heat kernel operation.  </p><p>** Expert interface, see <code>seeded_stochastic_heat_kernel</code>  for more user-friendly interfaces.**</p><p><strong>Inputs</strong></p><p>-<code>x</code>: The solution vector  -<code>y</code>: An intermediate vector  -<code>z</code>: Another intermediate vector -<code>P</code>: a variable that can be used with A<em>mul</em>B!        in order to apply the stochastic or sub-stochastic matrix       (column) -<code>t</code>: the value of time in the heat kernel <span>$0 &lt;= t$</span> -<code>eps</code>: the solution tolerance $ 0 &lt; eps &lt; 1 $ -<code>maxiter</code>: the maximum number of series terms to use</p><p><strong>Returns</strong></p><p>-<code>x</code>: the result of the stochastic heat kernel evaluation</p><p><strong>Example</strong></p><pre><code class="language-none"># TODO Show an example of how to use the expert interface</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.stochastic_mult" href="#MatrixNetworks.stochastic_mult"><code>MatrixNetworks.stochastic_mult</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>stochastic_mult</code></strong></p><p><strong>Expert interface</strong></p><p>This function computes <code>output</code> = <span>$A^T (b .* d)$</span>, i.e. the matrix <span>$A$</span> tranposed times the vector <span>$b$</span> element-wise multiplied by elements in <span>$d$</span>. The idea is that <span>$d$</span> is the inverse of the row-sums of <span>$A$</span> so that this  operation computes the (column)-stochastic (or sub-stochastic) product <code>output</code> = <span>$P b$</span> where P_{i,j} = A_{j,i} / $ <code>degree(j)</code>.</p><p>This function is used by the StochasticMult operators.  </p><p><strong>Functions</strong></p><ul><li><code>stochastic_mult!!(output::StridedVecOrMat, A::SparseMatrixCSC,        b::StridedVecOrMat, d::StridedVecOrMat)</code> </li><li><code>stochastic_mult!!(output::StridedVecOrMat, A::MatrixNetwork,        b::StridedVecOrMat, d::StridedVecOrMat)</code>       </li></ul><p><strong>Inputs</strong></p><ul><li><code>output</code>: See above </li><li><code>A</code>: See above</li><li><code>b</code>: See above</li><li><code>d</code>: the vector that will be multipled against b in-place </li></ul><p><strong>Returns</strong></p><ul><li><code>output</code>: the output input is returned as well (as well as updated in place)        </li></ul></div></div></section><pre><code class="language-none">MatrixNetworks.stochastic_mult!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.strong_components_map" href="#MatrixNetworks.strong_components_map"><code>MatrixNetworks.strong_components_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return information on the strongly connected components of a graph that  is the minimum required computation. Example: <span>$strong_components_map(MatrixNetwork(sprand(5,4,0.1)))$</span>	</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.sweepcut" href="#MatrixNetworks.sweepcut"><code>MatrixNetworks.sweepcut</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>sweepcut</code></strong></p><p>A sweepcut is an operation that takes an order to the vertices of a graph and evaluates the cut and volume of every partition induced by a prefix of that ordering. That is, if the order of vertices is</p><pre><code class="language-none">v1, v2, v3, ...</code></pre><p>the the sweep cut evaluates</p><pre><code class="language-none">cut({v1}), vol({v1})
cut({v1,v2}), vol({v1,v2})
cut({v1,v2,v3}), vol({v1,v2,v3})
...</code></pre><p>where cut is the total edge weight that connects vertices in S to the graph. And vol is the total edge weight connecting</p><p><strong>Functions</strong></p><ul><li><p><code>profile = sweepcut(A,x::Vector{T})</code> A standard sweepcut call that will get a sweepcut for a vector where x is sorted to get the order of the vertices (decreasing order). This is useful if you have a vector that should indicate good cuts in the graph, such as the Fiedler vector.</p></li><li><p><code>profile = sweepcut(A,p,r,totalvol,maxvol)</code> the in-depth call that all others are converted into. We strongly recommend against calling this yourself unless you understand the sweepcut code.</p></li></ul><p><strong>Inputs</strong></p><ul><li><code>A</code>: the sparse matrix representing the symmetric graph</li><li><code>x</code>: A vector scoring each vertex. This will be sorted and      turned into one of the other inputs.</li><li><code>p</code>: a partial permutation vector over the vertices of the graph       This vector needs to list every vertex at most once.       It could be shorter and need not list every vertex.</li><li><code>r</code>: A general data structure that gives       the rank of an item in the permutation vector       p should be sorted in decreasing order so that       i &lt; j means that r[p[i]] &lt; r[p[j]]</li><li><code>totalvol</code>: the total volume of the graph</li><li><code>maxvol</code>: the maximum volume of any set considered</li></ul><p><strong>Returns</strong></p><p>A <code>SweepcutProfile</code> type with all the information computed in the sweepcut. Most likely, you want the result <code>bestset</code> as indicated below.</p><p><strong>Example</strong></p><pre><code class="language-none">A = load_matrix_network(&quot;minnesota&quot;)
v = fiedler_vector(A)[1] # get the
p = sweepcut(A,v)
S = bestset(p) # get the bestset from the profile
T = spectral_cut(A).set # should give you the same set
# using UnicodePlots; lineplot(p.conductance) # show the conductance</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixNetworks.undirected_edges" href="#MatrixNetworks.undirected_edges"><code>MatrixNetworks.undirected_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">undirected_edges(A) -&gt; srcs,dsts</code></pre><p>Produce lists just for the undirected edges. This assumes you want only those edges where (target &gt;= source). </p></div></div></section><pre><code class="language-none">MatrixNetworks.unique_edge_sample_undirected</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
