<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · MatrixNetworks.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MatrixNetworks.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Package-Installation:-1">Package Installation:</a></li><li><a class="toctext" href="#Data-available:-1">Data available:</a></li><li><a class="toctext" href="#Some-examples:-1">Some examples:</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/nassarhuda/MatrixNetworks.jl"><img src="https://travis-ci.org/nassarhuda/MatrixNetworks.jl.svg?branch=master" alt="Build Result"/></a>  <a href="http://codecov.io/github/nassarhuda/MatrixNetworks.jl?branch=master"><img src="http://codecov.io/github/nassarhuda/MatrixNetworks.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><h1><a class="nav-anchor" id="MatrixNetworks-1" href="#MatrixNetworks-1">MatrixNetworks</a></h1><p>This package consists of a collection of network algorithms. In short, the major difference between MatrixNetworks.jl and packages like LightGraphs.jl or Graphs.jl is the way graphs are treated.</p><p>In <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>, graphs are created through Graph() and DiGraph() which are based on the representation of G as G = (V,E). Similar types exist in <a href="https://github.com/JuliaLang/Graphs.jl">Graphs.jl</a> (EdgeList, AdjacencyList, IncidenceList, Graph) - this is again based on viewing a graph G as a set of nodes and edges. Our viewpoint is different.</p><p>MatrixNetworks is based on the philosophy that there should be no distinction between a matrix and a network - thus the name.</p><p>For example, <code>d,dt,p = bfs(A,1)</code> computes the bfs distance from the node represented by row 1 to all other nodes of the graph with adjacency matrix A. (A can be of type <code>SparseMatrixCSC</code> or <code>MatrixNetwork</code>). This representation can be easier to work with and handle.</p><p>The package provides documentation with sample runs for all functions - viewable through Juila’s REPL. These sample runs come with sample data, which makes it easier for users to get started on <code>MatrixNetworks</code>.</p><h2><a class="nav-anchor" id="Package-Installation:-1" href="#Package-Installation:-1">Package Installation:</a></h2><h5><a class="nav-anchor" id="To-install-package-1" href="#To-install-package-1">To install package</a></h5><pre><code class="language-none">using Pkg
Pkg.add(&quot;MatrixNetworks&quot;)
using MatrixNetworks</code></pre><h5><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h5><pre><code class="language-none">?bfs
?bipartite_matching</code></pre><h5><a class="nav-anchor" id="To-run-test-cases:-1" href="#To-run-test-cases:-1">To run test cases:</a></h5><pre><code class="language-none">Pkg.test(&quot;MatrixNetworks&quot;)</code></pre><h2><a class="nav-anchor" id="Data-available:-1" href="#Data-available:-1">Data available:</a></h2><h5><a class="nav-anchor" id="For-a-full-list-of-all-datasets:-1" href="#For-a-full-list-of-all-datasets:-1">For a full list of all datasets:</a></h5><pre><code class="language-none">matrix_network_datasets()</code></pre><h5><a class="nav-anchor" id="Loading-data-example:-1" href="#Loading-data-example:-1">Loading data example:</a></h5><pre><code class="language-none">load_matrix_network(&quot;clique-10&quot;)</code></pre><h2><a class="nav-anchor" id="Some-examples:-1" href="#Some-examples:-1">Some examples:</a></h2><h5><a class="nav-anchor" id="largest_component:-Return-the-largest-connected-component-of-a-graph-1" href="#largest_component:-Return-the-largest-connected-component-of-a-graph-1">largest_component: Return the largest connected component of a graph</a></h5><p>Acc is a sparse matrix containing the largest connected piece of a directed graph A p is a logical vector indicating which vertices in A were chosen</p><pre><code class="language-none">A = load_matrix_network(&quot;dfs_example&quot;)
Acc,p = largest_component(A)</code></pre><h5><a class="nav-anchor" id="clustercoeffs:-Compute-undirected-clustering-coefficients-for-a-graph-1" href="#clustercoeffs:-Compute-undirected-clustering-coefficients-for-a-graph-1">clustercoeffs: Compute undirected clustering coefficients for a graph</a></h5><p>cc is the clustering coefficients</p><pre><code class="language-none">A = load_matrix_network(&quot;clique-10&quot;)
cc = clustercoeffs(MatrixNetwork(A))</code></pre><h5><a class="nav-anchor" id="bfs:-Compute-breadth-first-search-distances-starting-from-a-node-in-a-graph-1" href="#bfs:-Compute-breadth-first-search-distances-starting-from-a-node-in-a-graph-1">bfs: Compute breadth first search distances starting from a node in a graph</a></h5><p>d is a vector containing the distances of all nodes from node u (1 in the example below) dt is a vector containing the discover times of all the nodes pred is a vector containing the predecessors of each of the nodes</p><pre><code class="language-none">A = load_matrix_network(&quot;bfs_example&quot;)
d,dt,pred = bfs(A,1)</code></pre><h5><a class="nav-anchor" id="scomponents:-Compute-the-strongly-connected-components-of-a-graph-1" href="#scomponents:-Compute-the-strongly-connected-components-of-a-graph-1">scomponents: Compute the strongly connected components of a graph</a></h5><pre><code class="language-none">A = load_matrix_network(&quot;cores_example&quot;)
sc = scomponents(A)
sc.number #number of connected componenets
sc.sizes #sizes of components
sc.map #the mapping of the graph nodes to their respective connected component
strong_components_map(A) # if you just want the map
sc_enrich = enrich(sc) # produce additional enriched output includes:
sc_enrich.reduction_matrix
sc_enrich.transitive_map
sc_enrich.transitive_order</code></pre><p>Can work on ei,ej:</p><pre><code class="language-none">ei = [1;2;3]
ej = [2;4;1]
scomponents(ei,ej)</code></pre><h5><a class="nav-anchor" id="bipartite_matching:-Return-a-maximum-weight-bipartite-matching-of-a-graph-1" href="#bipartite_matching:-Return-a-maximum-weight-bipartite-matching-of-a-graph-1">bipartite_matching: Return a maximum weight bipartite matching of a graph</a></h5><pre><code class="language-none">ei = [1;2;3]
ej = [3;2;4]
BM = bipartite_matching([10;12;13],ei,ej)
BM.weight
BM.cardinality
BM.match
create_sparse(BM) # get the sparse matrix
edge_list(BM)) # get the edgelist
edge_indicator(BM,ei,ej) # get edge indicators</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
