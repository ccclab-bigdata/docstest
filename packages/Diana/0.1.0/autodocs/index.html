<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Diana.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Diana.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Diana.Argument</code></pre><pre><code class="language-none">Diana.BooleanValue</code></pre><pre><code class="language-none">Diana.Client</code></pre><pre><code class="language-none">Diana.Diana</code></pre><pre><code class="language-none">Diana.Directive</code></pre><pre><code class="language-none">Diana.DirectiveDefinition</code></pre><pre><code class="language-none">Diana.Document</code></pre><pre><code class="language-none">Diana.EnumTypeDefinition</code></pre><pre><code class="language-none">Diana.EnumValue</code></pre><pre><code class="language-none">Diana.EnumValueDefinition</code></pre><pre><code class="language-none">Diana.ExecuteQuery</code></pre><pre><code class="language-none">Diana.Field</code></pre><pre><code class="language-none">Diana.FieldDefinition</code></pre><pre><code class="language-none">Diana.FloatValue</code></pre><pre><code class="language-none">Diana.FragmentCycles</code></pre><pre><code class="language-none">Diana.FragmentDefinition</code></pre><pre><code class="language-none">Diana.FragmentNames</code></pre><pre><code class="language-none">Diana.FragmentSpread</code></pre><pre><code class="language-none">Diana.FragmentSubscription</code></pre><pre><code class="language-none">Diana.FragmentUnknowNotUsed</code></pre><pre><code class="language-none">Diana.GraphQLClient</code></pre><pre><code class="language-none">Diana.GraphqlError</code></pre><pre><code class="language-none">Diana.InlineFragment</code></pre><pre><code class="language-none">Diana.InputObjectTypeDefinition</code></pre><pre><code class="language-none">Diana.InputValueDefinition</code></pre><pre><code class="language-none">Diana.IntValue</code></pre><pre><code class="language-none">Diana.InterfaceTypeDefinition</code></pre><pre><code class="language-none">Diana.Lexer</code></pre><pre><code class="language-none">Diana.Lexers</code></pre><pre><code class="language-none">Diana.ListType</code></pre><pre><code class="language-none">Diana.List_</code></pre><pre><code class="language-none">Diana.Name</code></pre><pre><code class="language-none">Diana.NamedType</code></pre><pre><code class="language-none">Diana.Node</code></pre><pre><code class="language-none">Diana.NonNullType</code></pre><pre><code class="language-none">Diana.NotExtensionOnOperation</code></pre><pre><code class="language-none">Diana.NotSchemaOnOperation</code></pre><pre><code class="language-none">Diana.NotTypeOnOperation</code></pre><pre><code class="language-none">Diana.NullValue</code></pre><pre><code class="language-none">Diana.ObjectTypeDefinition</code></pre><pre><code class="language-none">Diana.Object_</code></pre><pre><code class="language-none">Diana.Object_Field</code></pre><pre><code class="language-none">Diana.OperationAnonymous</code></pre><pre><code class="language-none">Diana.OperationDefinition</code></pre><pre><code class="language-none">Diana.OperationNames</code></pre><pre><code class="language-none">Diana.OperationTypeDefinition</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.Parse" href="#Diana.Parse"><code>Diana.Parse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a GraphQL source, parses it into a Document. Throws GraphQLError if a syntax error is encountered.</p></div></div></section><pre><code class="language-none">Diana.Queryclient</code></pre><pre><code class="language-none">Diana.Result</code></pre><pre><code class="language-none">Diana.ScalarTypeDefinition</code></pre><pre><code class="language-none">Diana.Schema</code></pre><pre><code class="language-none">Diana.SchemaDefinition</code></pre><pre><code class="language-none">Diana.SelectionSet</code></pre><pre><code class="language-none">Diana.StringValue</code></pre><pre><code class="language-none">Diana.SubscriptionFields</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.Lexers.Tokenize" href="#Diana.Lexers.Tokenize"><code>Diana.Lexers.Tokenize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Tokenize(x)</code></pre><p>Returns an <code>Iterable</code> containing the tokenized input. Can be reverted by e.g. <code>join(untokenize.(Tokenize(x)))</code>.</p></div></div></section><pre><code class="language-none">Diana.Tokens</code></pre><pre><code class="language-none">Diana.Tokensgraphql</code></pre><pre><code class="language-none">Diana.TypeExtensionDefinition</code></pre><pre><code class="language-none">Diana.UnionTypeDefinition</code></pre><pre><code class="language-none">Diana.Validatequery</code></pre><pre><code class="language-none">Diana.Variable</code></pre><pre><code class="language-none">Diana.VariableDefinition</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.an_y" href="#Diana.an_y"><code>Diana.an_y</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a possibly empty list of parse nodes, determined by   the parseFn. This list begins with a lex token of openKind   and ends with a lex token of closeKind. Advances the parser   to the next lex token after the closing token.</p></div></div></section><pre><code class="language-none">Diana.createLexer</code></pre><pre><code class="language-none">Diana.deepquery</code></pre><pre><code class="language-none">Diana.eval</code></pre><pre><code class="language-none">Diana.executor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.expect" href="#Diana.expect"><code>Diana.expect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If the next token is of the given kind, return that token after advancing   the lexer. Otherwise, do not change the parser state and throw an error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.expectKeyword" href="#Diana.expectKeyword"><code>Diana.expectKeyword</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If the next token is a keyword with the given value, return that token after   advancing the lexer. Otherwise, do not change the parser state and return   false.</p></div></div></section><pre><code class="language-none">Diana.getdeep</code></pre><pre><code class="language-none">Diana.getfield_types</code></pre><pre><code class="language-none">Diana.gettypes</code></pre><pre><code class="language-none">Diana.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.many" href="#Diana.many"><code>Diana.many</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a non-empty list of parse nodes, determined by   the parseFn. This list begins with a lex token of openKind   and ends with a lex token of closeKind. Advances the parser   to the next lex token after the closing token.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.next_token" href="#Diana.next_token"><code>Diana.next_token</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If the next token is of the given kind, return true after advancing   the lexer. Otherwise, do not change the parser state and return false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseArgument" href="#Diana.parseArgument"><code>Diana.parseArgument</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Argument : Name : Value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseArgumentDefs" href="#Diana.parseArgumentDefs"><code>Diana.parseArgumentDefs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ArgumentsDefinition : ( InputValueDefinition+ )</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseArguments" href="#Diana.parseArguments"><code>Diana.parseArguments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Arguments : ( Argument+ )</p></div></div></section><pre><code class="language-none">Diana.parseConstValue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDefinition" href="#Diana.parseDefinition"><code>Diana.parseDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Definition :     - OperationDefinition     - FragmentDefinition     - TypeSystemDefinition</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDirective" href="#Diana.parseDirective"><code>Diana.parseDirective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Directive : @ Name Arguments?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDirectiveDefinition" href="#Diana.parseDirectiveDefinition"><code>Diana.parseDirectiveDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>DirectiveDefinition :     - directive @ Name ArgumentsDefinition? on DirectiveLocations</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDirectiveLocations" href="#Diana.parseDirectiveLocations"><code>Diana.parseDirectiveLocations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>DirectiveLocations :     - <code>|</code>? Name     - DirectiveLocations | Name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDirectives" href="#Diana.parseDirectives"><code>Diana.parseDirectives</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Directives section.</p><p>Directives : Directive+</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseDocument" href="#Diana.parseDocument"><code>Diana.parseDocument</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">#if length(errors)&gt;0
#	println(&quot;Syntax Error GraphQL request (x:x) Unexpected character&quot;)
#	errors
	# {&quot;errors&quot;:[{&quot;locations&quot;:[{&quot;column&quot;:5,&quot;line&quot;:3}],&quot;message&quot;:&quot;Syntax Error GraphQL request (3:5) Unexpected character &quot;&quot;.</code></pre><p>2:   neomatrix{</p><pre><code class="language-none">	3:     nombre
   ^</code></pre><p>4:     linkedin &quot;}]}   Document : Definition+</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseEnumTypeDefinition" href="#Diana.parseEnumTypeDefinition"><code>Diana.parseEnumTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseEnumValueDefinition" href="#Diana.parseEnumValueDefinition"><code>Diana.parseEnumValueDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>EnumValueDefinition : EnumValue Directives?</p><p>EnumValue : Name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseField" href="#Diana.parseField"><code>Diana.parseField</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Field : Alias? Name Arguments? Directives? SelectionSet?</p><p>Alias : Name : NAME</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseFieldDefinition" href="#Diana.parseFieldDefinition"><code>Diana.parseFieldDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>FieldDefinition : Name ArgumentsDefinition? : Type Directives?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseFragment" href="#Diana.parseFragment"><code>Diana.parseFragment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Fragments section.</p><p>Corresponds to both FragmentSpread and InlineFragment in the spec.</p><p>FragmentSpread : ... FragmentName Directives?</p><p>InlineFragment : ... TypeCondition? Directives? SelectionSet</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseFragmentDefinition" href="#Diana.parseFragmentDefinition"><code>Diana.parseFragmentDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>FragmentDefinition :     - fragment FragmentName on TypeCondition Directives? SelectionSet</p><p>TypeCondition : NamedType</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseFragmentName" href="#Diana.parseFragmentName"><code>Diana.parseFragmentName</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>FragmentName : Name but not <code>on</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseImplementsInterfaces" href="#Diana.parseImplementsInterfaces"><code>Diana.parseImplementsInterfaces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ImplementsInterfaces : implements NamedType+</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseInputObjectTypeDefinition" href="#Diana.parseInputObjectTypeDefinition"><code>Diana.parseInputObjectTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseInputValueDef" href="#Diana.parseInputValueDef"><code>Diana.parseInputValueDef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>InputValueDefinition : Name : Type DefaultValue? Directives?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseInterfaceTypeDefinition" href="#Diana.parseInterfaceTypeDefinition"><code>Diana.parseInterfaceTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseList" href="#Diana.parseList"><code>Diana.parseList</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ListValue[Const] :     - [ ]     - [ Value[?Const]+ ]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseName" href="#Diana.parseName"><code>Diana.parseName</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Converts a name lex token into a name parse node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseNamedType" href="#Diana.parseNamedType"><code>Diana.parseNamedType</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>NamedType : Name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseObject" href="#Diana.parseObject"><code>Diana.parseObject</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ObjectValue[Const] :     - { }     - { ObjectField[?Const]+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseObjectField" href="#Diana.parseObjectField"><code>Diana.parseObjectField</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ObjectField[Const] : Name : Value[?Const]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseObjectTypeDefinition" href="#Diana.parseObjectTypeDefinition"><code>Diana.parseObjectTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ObjectTypeDefinition :     - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseOperationDefinition" href="#Diana.parseOperationDefinition"><code>Diana.parseOperationDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Implements the parsing rules in the Operations section.</code></pre><p>OperationDefinition :</p><ul><li>SelectionSet</li><li>OperationType Name? VariableDefinitions? Directives? SelectionSet</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseOperationType" href="#Diana.parseOperationType"><code>Diana.parseOperationType</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Document section.</p><p>OperationType : one of query mutation subscription</p></div></div></section><pre><code class="language-none">Diana.parseOperationTypeDefinition</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseScalarTypeDefinition" href="#Diana.parseScalarTypeDefinition"><code>Diana.parseScalarTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ScalarTypeDefinition : scalar Name Directives?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseSchemaDefinition" href="#Diana.parseSchemaDefinition"><code>Diana.parseSchemaDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>SchemaDefinition : schema Directives? { OperationTypeDefinition+ }</p><p>OperationTypeDefinition : OperationType : NamedType</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseSelection" href="#Diana.parseSelection"><code>Diana.parseSelection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Selection :     - Field     - FragmentSpread     - InlineFragment</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseSelectionSet" href="#Diana.parseSelectionSet"><code>Diana.parseSelectionSet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>SelectionSet : { Selection+ }</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseType" href="#Diana.parseType"><code>Diana.parseType</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a string containing a GraphQL Type (ex. <code>[Int!]</code>), parse the AST for   that type.   Throws GraphQLError if a syntax error is encountered.</p><p>This is useful within tools that operate upon GraphQL Types directly and   in isolation of complete GraphQL documents.</p><p>Consider providing the results to the utility function: typeFromAST().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseTypeExtensionDefinition" href="#Diana.parseTypeExtensionDefinition"><code>Diana.parseTypeExtensionDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>TypeExtensionDefinition : extend ObjectTypeDefinition</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseTypeReference" href="#Diana.parseTypeReference"><code>Diana.parseTypeReference</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Types section.</p><p>Type :     - NamedType     - ListType     - NonNullType</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseTypeSystemDefinition" href="#Diana.parseTypeSystemDefinition"><code>Diana.parseTypeSystemDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Type Definition section.</p><p>TypeSystemDefinition :     - SchemaDefinition     - TypeDefinition     - TypeExtensionDefinition     - DirectiveDefinition</p><p>TypeDefinition :     - ScalarTypeDefinition     - ObjectTypeDefinition     - InterfaceTypeDefinition     - UnionTypeDefinition     - EnumTypeDefinition     - InputObjectTypeDefinition</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseUnionMembers" href="#Diana.parseUnionMembers"><code>Diana.parseUnionMembers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">UnionMembers :
- `|`? NamedType
- UnionMembers | NamedType</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseUnionTypeDefinition" href="#Diana.parseUnionTypeDefinition"><code>Diana.parseUnionTypeDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>UnionTypeDefinition : union Name Directives? = UnionMembers</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseValue" href="#Diana.parseValue"><code>Diana.parseValue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a string containing a GraphQL value (ex. <code>[42]</code>), parse the AST for   that value.   Throws GraphQLError if a syntax error is encountered.</p><p>This is useful within tools that operate upon GraphQL Values directly and   in isolation of complete GraphQL documents.</p><p>Consider providing the results to the utility function: valueFromAST().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseValueLiteral" href="#Diana.parseValueLiteral"><code>Diana.parseValueLiteral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements the parsing rules in the Values section.</p><p>Value[Const] :     - [~Const] Variable     - IntValue     - FloatValue     - StringValue     - BooleanValue     - NullValue     - EnumValue     - ListValue[?Const]     - ObjectValue[?Const]</p><p>BooleanValue : one of <code>true</code> <code>false</code></p><p>NullValue : <code>null</code></p><p>EnumValue : Name but not <code>true</code>, <code>false</code> or <code>null</code></p></div></div></section><pre><code class="language-none">Diana.parseValueValue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseVariable" href="#Diana.parseVariable"><code>Diana.parseVariable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Variable : $ Name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseVariableDefinition" href="#Diana.parseVariableDefinition"><code>Diana.parseVariableDefinition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>VariableDefinition : Variable : Type DefaultValue?</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.parseVariableDefinitions" href="#Diana.parseVariableDefinitions"><code>Diana.parseVariableDefinitions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>VariableDefinitions : ( VariableDefinition+ )</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.peek" href="#Diana.peek"><code>Diana.peek</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Determines if the next token is of a given kind</p></div></div></section><pre><code class="language-none">Diana.resol</code></pre><pre><code class="language-none">Diana.schema</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Diana.unexpected" href="#Diana.unexpected"><code>Diana.unexpected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Helper function for creating an error when an unexpected lexed token   is encountered.</p></div></div></section><pre><code class="language-none">Diana.visitante</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
