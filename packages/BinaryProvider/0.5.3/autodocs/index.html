<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BinaryProvider.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BinaryProvider.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BinaryProvider.BinaryProvider</code></pre><pre><code class="language-none">BinaryProvider.CompilerABI</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.ExecutableProduct" href="#BinaryProvider.ExecutableProduct"><code>BinaryProvider.ExecutableProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>ExecutableProduct</code> is a <code>Product</code> that represents an executable file.</p><p>On all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.FileProduct" href="#BinaryProvider.FileProduct"><code>BinaryProvider.FileProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>FileProduct</code> represents a file that simply must exist to be satisfied.</p></div></div></section><pre><code class="language-none">BinaryProvider.FreeBSD</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.LibraryProduct" href="#BinaryProvider.LibraryProduct"><code>BinaryProvider.LibraryProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>LibraryProduct</code> is a special kind of <code>Product</code> that not only needs to exist, but needs to be <code>dlopen()</code>&#39;able.  You must know which directory the library will be installed to, and its name, e.g. to build a <code>LibraryProduct</code> that refers to <code>&quot;/lib/libnettle.so&quot;</code>, the &quot;directory&quot; would be &quot;/lib&quot;, and the &quot;libname&quot; would be &quot;libnettle&quot;.  Note that a <code>LibraryProduct</code> can support multiple libnames, as some software projects change the libname based on the build configuration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.LineStream" href="#BinaryProvider.LineStream"><code>BinaryProvider.LineStream</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LineStream(pipe::Pipe)</code></pre><p>Given a <code>Pipe</code> that has been initialized by <code>spawn()</code>, create an async Task to read in lines as they come in and annotate the time the line was captured for later replay/merging with other simultaneously captured streams.</p></div></div></section><pre><code class="language-none">BinaryProvider.Linux</code></pre><pre><code class="language-none">BinaryProvider.MacOS</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.OutputCollector" href="#BinaryProvider.OutputCollector"><code>BinaryProvider.OutputCollector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OutputCollector</code></pre><p>A <code>run()</code> wrapper class that captures subprocess <code>stdout</code> and <code>stderr</code> streams independently, resynthesizing and colorizing the streams appropriately.</p></div></div></section><pre><code class="language-none">BinaryProvider.Platform</code></pre><pre><code class="language-none">BinaryProvider.Prefix</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.Product" href="#BinaryProvider.Product"><code>BinaryProvider.Product</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Product</code> is an expected result after building or installation of a package.</p><p>Examples of <code>Product</code>s include <code>LibraryProduct</code>, <code>ExecutableProduct</code> and <code>FileProduct</code>.  All <code>Product</code> types must define the following minimum set of functionality:</p><ul><li><p><code>locate(::Product)</code>: given a <code>Product</code>, locate it within the wrapped <code>Prefix</code> returning its location as a string</p></li><li><p><code>satisfied(::Product)</code>: given a <code>Product</code>, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)</p></li><li><p><code>variable_name(::Product)</code>: return the variable name assigned to a <code>Product</code></p></li><li><p><code>repr(::Product)</code>: Return a representation of this <code>Product</code>, useful for auto-generating source code that constructs <code>Products</code>, if that&#39;s your thing.</p></li></ul></div></div></section><pre><code class="language-none">BinaryProvider.UnknownPlatform</code></pre><pre><code class="language-none">BinaryProvider.Windows</code></pre><pre><code class="language-none">BinaryProvider.__init__</code></pre><pre><code class="language-none">BinaryProvider._precompile_</code></pre><pre><code class="language-none">BinaryProvider.activate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.alive" href="#BinaryProvider.alive"><code>BinaryProvider.alive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">alive(s::LineStream)</code></pre><p>Returns <code>true</code><code>if the task owned by this</code>LineStream<code>is still processing output from an underlying</code>Pipe`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.arch" href="#BinaryProvider.arch"><code>BinaryProvider.arch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arch(p::Platform)</code></pre><p>Get the architecture for the given <code>Platform</code> object as a <code>Symbol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arch(Linux(:aarch64))
:aarch64

julia&gt; arch(MacOS())
:x86_64</code></pre></div></div></section><pre><code class="language-none">BinaryProvider.arch_str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.bindir" href="#BinaryProvider.bindir"><code>BinaryProvider.bindir</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bindir(prefix::Prefix)</code></pre><p>Returns the binary directory for the given <code>prefix</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.call_abi" href="#BinaryProvider.call_abi"><code>BinaryProvider.call_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>call_abi(p::Platform)</p><p>Get the calling ABI for the given <code>Platform</code> object as a <code>Symbol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; call_abi(Linux(:x86_64))
:blank_abi

julia&gt; call_abi(FreeBSD(:armv7l))
:eabihf</code></pre></div></div></section><pre><code class="language-none">BinaryProvider.call_abi_str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.choose_download" href="#BinaryProvider.choose_download"><code>BinaryProvider.choose_download</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">choose_download(download_info::Dict, platform::Platform = platform_key_abi())</code></pre><p>Given a <code>download_info</code> dictionary mapping platforms to some value, choose the value whose key best matches <code>platform</code>, returning <code>nothing</code> if no matches can be found.</p><p>Platform attributes such as architecture, libc, calling ABI, etc... must all match exactly, however attributes such as compiler ABI can have wildcards within them such as <code>:gcc_any</code> which matches any version of GCC.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.collect_stderr" href="#BinaryProvider.collect_stderr"><code>BinaryProvider.collect_stderr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect_stderr(collector::OutputCollector)</code></pre><p>Returns all stderr lines collected by this collector so far.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.collect_stdout" href="#BinaryProvider.collect_stdout"><code>BinaryProvider.collect_stdout</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect_stdout(collector::OutputCollector)</code></pre><p>Returns all stdout lines collected by this collector so far.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.compiler_abi" href="#BinaryProvider.compiler_abi"><code>BinaryProvider.compiler_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compiler_abi(p::Platform)</code></pre><p>Get the compiler ABI object for the given <code>Platform</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; compiler_abi(Linux(:x86_64))
CompilerABI(:gcc_any, :cxx_any)

julia&gt; compiler_abi(Linux(:x86_64; compiler_abi=CompilerABI(:gcc7)))
CompilerABI(:gcc7, :cxx_any)</code></pre></div></div></section><pre><code class="language-none">BinaryProvider.compiler_abi_str</code></pre><pre><code class="language-none">BinaryProvider.deactivate</code></pre><pre><code class="language-none">BinaryProvider.default_platkey</code></pre><pre><code class="language-none">BinaryProvider.detect_compiler_abi</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.detect_cxx11_string_abi" href="#BinaryProvider.detect_cxx11_string_abi"><code>BinaryProvider.detect_cxx11_string_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">detect_cxx11_string_abi()</code></pre><p>Introspects the currently running Julia process to see what version of the C++11 string ABI it was compiled with.  (In reality, it checks for symbols within LLVM, but that is close enough for our purposes, as you can&#39;t mix linkages between Julia and LLVM if they are not compiled in the same way).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.detect_libgfortran_abi" href="#BinaryProvider.detect_libgfortran_abi"><code>BinaryProvider.detect_libgfortran_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">detect_libgfortran_abi(libgfortran_name::AbstractString)</code></pre><p>Examines the given libgfortran SONAME to see what version of GCC corresponds to the given libgfortran version.</p></div></div><div><div><pre><code class="language-none">detect_libgfortran_abi()</code></pre><p>If no parameter is given, introspects the current Julia process to determine the version of GCC this Julia was built with.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.detect_libstdcxx_abi" href="#BinaryProvider.detect_libstdcxx_abi"><code>BinaryProvider.detect_libstdcxx_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">detect_libstdcxx_abi()</code></pre><p>Introspects the currently running Julia process to find out what version of libstdc++ it is linked to (if any), as a proxy for GCC version compatibility.  E.g. if we are linked against libstdc++.so.19, binary dependencies built by GCC 8.1.0 will have linker errors.  This method returns the maximum GCC abi that we can support.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.download" href="#BinaryProvider.download"><code>BinaryProvider.download</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">download(url::AbstractString, dest::AbstractString;
         verbose::Bool = false)</code></pre><p>Download file located at <code>url</code>, store it at <code>dest</code>, continuing if <code>dest</code> already exists and the server and download engine support it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.download_verify" href="#BinaryProvider.download_verify"><code>BinaryProvider.download_verify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">download_verify(url::AbstractString, hash::AbstractString,
                dest::AbstractString; verbose::Bool = false,
                force::Bool = false, quiet_download::Bool = false)</code></pre><p>Download file located at <code>url</code>, verify it matches the given <code>hash</code>, and throw an error if anything goes wrong.  If <code>dest</code> already exists, just verify it. If <code>force</code> is set to <code>true</code>, overwrite the given file if it exists but does not match the given <code>hash</code>.</p><p>This method returns <code>true</code> if the file was downloaded successfully, <code>false</code> if an existing file was removed due to the use of <code>force</code>, and throws an error if <code>force</code> is not set and the already-existent file fails verification, or if <code>force</code> is set, verification fails, and then verification fails again after redownloading the file.</p><p>If <code>quiet_download</code> is set to <code>false</code> (the default), this method will print to stdout when downloading a new file.  If it is set to <code>true</code> (and <code>verbose</code> is set to <code>false</code>) the downloading process will be completely silent.  If <code>verbose</code> is set to <code>true</code>, messages about integrity verification will be printed in addition to messages regarding downloading.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.download_verify_unpack" href="#BinaryProvider.download_verify_unpack"><code>BinaryProvider.download_verify_unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">download_verify_unpack(url::AbstractString, hash::AbstractString,
                       dest::AbstractString; tarball_path = nothing,
                       verbose::Bool = false, ignore_existence::Bool = false,
                       force::Bool = false)</code></pre><p>Helper method to download tarball located at <code>url</code>, verify it matches the given <code>hash</code>, then unpack it into folder <code>dest</code>.  In general, the method <code>install()</code> should be used to download and install tarballs into a <code>Prefix</code>; this method should only be used if the extra functionality of <code>install()</code> is undesired.</p><p>If <code>tarball_path</code> is specified, the given <code>url</code> will be downloaded to <code>tarball_path</code>, and it will not be removed after downloading and verification is complete.  If it is not specified, the tarball will be downloaded to a temporary location, and removed after verification is complete.</p><p>If <code>force</code> is specified, a verification failure will cause <code>tarball_path</code> to be deleted (if it exists), the <code>dest</code> folder to be removed (if it exists) and the tarball to be redownloaded and reverified.  If the verification check is failed a second time, an exception is raised.  If <code>force</code> is not specified, a verification failure will result in an immediate raised exception.</p><p>If <code>ignore_existence</code> is set, the tarball is unpacked even if the destination directory already exists.</p><p>Returns <code>true</code> if a tarball was actually unpacked, <code>false</code> if nothing was changed in the destination prefix.</p></div></div></section><pre><code class="language-none">BinaryProvider.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.extract_name_version_platform_key" href="#BinaryProvider.extract_name_version_platform_key"><code>BinaryProvider.extract_name_version_platform_key</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extract_name_version_platform_key(path::AbstractString)</code></pre><p>Given the path to a tarball, return the name, platform key and version of that tarball. If any of those things cannot be found, throw an error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.extract_platform_key" href="#BinaryProvider.extract_platform_key"><code>BinaryProvider.extract_platform_key</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extract_platform_key(path::AbstractString)</code></pre><p>Given the path to a tarball, return the platform key of that tarball. If none can be found, prints a warning and return the current platform suffix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.gen_download_cmd" href="#BinaryProvider.gen_download_cmd"><code>BinaryProvider.gen_download_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_download_cmd(url::AbstractString, out_path::AbstractString)</code></pre><p>Return a <code>Cmd</code> that will download resource located at <code>url</code> and store it at the location given by <code>out_path</code>.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.gen_list_tarball_cmd" href="#BinaryProvider.gen_list_tarball_cmd"><code>BinaryProvider.gen_list_tarball_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_list_tarball_cmd(tarball_path::AbstractString)</code></pre><p>Return a <code>Cmd</code> that will list the files contained within the tarball located at <code>tarball_path</code>.  The list will not include directories contained within the tarball.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.gen_package_cmd" href="#BinaryProvider.gen_package_cmd"><code>BinaryProvider.gen_package_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_package_cmd(in_path::AbstractString, tarball_path::AbstractString)</code></pre><p>Return a <code>Cmd</code> that will package up the given <code>in_path</code> directory into a tarball located at <code>tarball_path</code>.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.gen_sh_cmd" href="#BinaryProvider.gen_sh_cmd"><code>BinaryProvider.gen_sh_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_sh_cmd(cmd::Cmd)</code></pre><p>Runs a command using <code>sh</code>.  On Unices, this will default to the first <code>sh</code> found on the <code>PATH</code>, however on Windows if that is not found it will fall back to the <code>sh</code> provided by the <code>busybox.exe</code> shipped with Julia.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.gen_unpack_cmd" href="#BinaryProvider.gen_unpack_cmd"><code>BinaryProvider.gen_unpack_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_unpack_cmd(tarball_path::AbstractString, out_path::AbstractString)</code></pre><p>Return a <code>Cmd</code> that will unpack the given <code>tarball_path</code> into the given <code>out_path</code>.  If <code>out_path</code> is not already a directory, it will be created.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><pre><code class="language-none">BinaryProvider.global_prefix</code></pre><pre><code class="language-none">BinaryProvider.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.includedir" href="#BinaryProvider.includedir"><code>BinaryProvider.includedir</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">includedir(prefix::Prefix)</code></pre><p>Returns the include directory for the given <code>prefix</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.info_onchange" href="#BinaryProvider.info_onchange"><code>BinaryProvider.info_onchange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">info_onchange(msg, key, location)</code></pre><p>This macro is used to gate verbose messages within a function; within functions such as <code>verify()</code>, we want to print out that we successfully verified a file only once per session, so we keep track of which log message we printed within a particular method.  This is done by passing a <code>key</code> to <code>@info_onchange</code> as the second parameter, e.g. in the above scenario we might pass the string <code>&quot;verify_$(filepath)&quot;</code>.  Combined with this key is the file and line the message originates from, which is used to suppress duplicate messages; e.g. if a method with two branches that both log with the same key is called, if the execution path is branch A, A, B, A, B, B, B, A then what will be printed is message A, B, A, B, A.  In essence, this method calls <code>info()</code> only when the message generated by this particular method changes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.install" href="#BinaryProvider.install"><code>BinaryProvider.install</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">install(tarball_url::AbstractString,
        hash::AbstractString;
        prefix::Prefix = global_prefix,
        force::Bool = false,
        ignore_platform::Bool = false,
        verbose::Bool = false)</code></pre><p>Given a <code>prefix</code>, a <code>tarball_url</code> and a <code>hash</code>, download that tarball into the prefix, verify its integrity with the <code>hash</code>, and install it into the <code>prefix</code>. Also save a manifest of the files into the prefix for uninstallation later.</p><p>This will not overwrite any files within <code>prefix</code> unless <code>force=true</code> is set. If <code>force=true</code> is set, installation will overwrite files as needed, and it will also delete any files previously installed for <code>tarball_url</code> as listed in a pre-existing manifest (if any).</p><p>By default, this will not install a tarball that does not match the platform of the current host system, this can be overridden by setting <code>ignore_platform</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.isinstalled" href="#BinaryProvider.isinstalled"><code>BinaryProvider.isinstalled</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isinstalled(tarball_url::AbstractString,
            hash::AbstractString;
            prefix::Prefix = global_prefix)</code></pre><p>Given a <code>prefix</code>, a <code>tarball_url</code> and a <code>hash</code>, check whether the tarball with that hash has been installed into <code>prefix</code>.</p><p>In particular, it checks for the tarball, matching hash file, and manifest installed by <code>install</code>, and checks that the files listed in the manifest are installed and are not older than the tarball.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.libc" href="#BinaryProvider.libc"><code>BinaryProvider.libc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">libc(p::Platform)</code></pre><p>Get the libc for the given <code>Platform</code> object as a <code>Symbol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; libc(Linux(:aarch64))
:glibc

julia&gt; libc(FreeBSD(:x86_64))
:default_libc</code></pre></div></div></section><pre><code class="language-none">BinaryProvider.libc_str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.libdir" href="#BinaryProvider.libdir"><code>BinaryProvider.libdir</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">libdir(prefix::Prefix, platform = platform_key_abi())</code></pre><p>Returns the library directory for the given <code>prefix</code> (note that this differs between unix systems and windows systems).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.list_tarball_files" href="#BinaryProvider.list_tarball_files"><code>BinaryProvider.list_tarball_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">list_tarball_files(path::AbstractString; verbose::Bool = false)</code></pre><p>Given a <code>.tar.gz</code> filepath, list the compressed contents.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.locate" href="#BinaryProvider.locate"><code>BinaryProvider.locate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>locate(lp::LibraryProduct; verbose::Bool = false,         platform::Platform = platform<em>key</em>abi())</p><p>If the given library exists (under any reasonable name) and is <code>dlopen()</code>able, (assuming it was built for the current platform) return its location.  Note that the <code>dlopen()</code> test is only run if the current platform matches the given <code>platform</code> keyword argument, as cross-compiled libraries cannot be <code>dlopen()</code>ed on foreign platforms.</p></div></div><div><div><p><code>locate(fp::ExecutableProduct; platform::Platform = platform_key_abi(),                                verbose::Bool = false, isolate::Bool = false)</code></p><p>If the given executable file exists and is executable, return its path.</p><p>On all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div></div><div><div><p>locate(fp::FileProduct; platform::Platform = platform<em>key</em>abi(),                         verbose::Bool = false, isolate::Bool = false)</p><p>If the given file exists, return its path.  The platform argument is ignored here, but included for uniformity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.logdir" href="#BinaryProvider.logdir"><code>BinaryProvider.logdir</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logdir(prefix::Prefix)</code></pre><p>Returns the logs directory for the given <code>prefix</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.manifest_for_file" href="#BinaryProvider.manifest_for_file"><code>BinaryProvider.manifest_for_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">manifest_for_file(path::AbstractString; prefix::Prefix = global_prefix)</code></pre><p>Returns the manifest file containing the installation receipt for the given <code>path</code>, throws an error if it cannot find a matching manifest.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.manifest_from_url" href="#BinaryProvider.manifest_from_url"><code>BinaryProvider.manifest_from_url</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">manifest_from_url(url::AbstractString; prefix::Prefix = global_prefix())</code></pre><p>Returns the file path of the manifest file for the tarball located at <code>url</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">merge(collector::OutputCollector; colored::Bool = false)</code></pre><p>Merge the stdout and stderr streams of the <code>OutputCollector</code> on a per-line basis, returning a single string containing all collected lines, interleaved by capture time.  If <code>colored</code> is set to true, embeds terminal color codes to print <code>stderr</code> in red.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.package" href="#BinaryProvider.package"><code>BinaryProvider.package</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">package(src_dir::AbstractString, tarball_path::AbstractString;
        verbose::Bool = false)</code></pre><p>Compress <code>src_dir</code> into a tarball located at <code>tarball_path</code>.</p></div></div><div><div><pre><code class="language-none">package(prefix::Prefix, output_base::AbstractString,
        version::VersionNumber;
        platform::Platform = platform_key_abi(),
        verbose::Bool = false, force::Bool = false)</code></pre><p>Build a tarball of the <code>prefix</code>, storing the tarball at <code>output_base</code>, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Runs an <code>audit()</code> on the <code>prefix</code>, to ensure that libraries can be <code>dlopen()</code>&#39;ed, that all dependencies are located within the prefix, etc... See the <code>audit()</code> documentation for a full list of the audit steps.  Returns the full path to and hash of the generated tarball.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.parse_7z_list" href="#BinaryProvider.parse_7z_list"><code>BinaryProvider.parse_7z_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_7z_list(output::AbstractString)</code></pre><p>Given the output of <code>7z l</code>, parse out the listed filenames.  This funciton used by  <code>list_tarball_files</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.parse_dl_name_version" href="#BinaryProvider.parse_dl_name_version"><code>BinaryProvider.parse_dl_name_version</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_dl_name_version(path::AbstractString, platform::Platform)</code></pre><p>Given a path to a dynamic library, parse out what information we can from the filename.  E.g. given something like &quot;lib/libfoo.so.3.2&quot;, this function returns <code>&quot;libfoo&quot;, v&quot;3.2&quot;</code>.  If the path name is not a valid dynamic library, this method throws an error.  If no soversion can be extracted from the filename, as in &quot;libbar.so&quot; this method returns <code>&quot;libbar&quot;, nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.parse_tar_list" href="#BinaryProvider.parse_tar_list"><code>BinaryProvider.parse_tar_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_tar_list(output::AbstractString)</code></pre><p>Given the output of <code>tar -t</code>, parse out the listed filenames.  This funciton used by <code>list_tarball_files</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.parse_tarball_listing" href="#BinaryProvider.parse_tarball_listing"><code>BinaryProvider.parse_tarball_listing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_tarball_listing(output::AbstractString)</code></pre><p>Parses the result of <code>gen_list_tarball_cmd()</code> into something useful.</p><p>This method is initialized by <code>probe_platform_engines()</code>, which should be automatically called upon first import of <code>BinaryProvider</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.platform_dlext" href="#BinaryProvider.platform_dlext"><code>BinaryProvider.platform_dlext</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">platform_dlext(platform::Platform = platform_key_abi())</code></pre><p>Return the dynamic library extension for the given platform, defaulting to the currently running platform.  E.g. returns &quot;so&quot; for a Linux-based platform, &quot;dll&quot; for a Windows-based platform, etc...</p></div></div></section><pre><code class="language-none">BinaryProvider.platform_key</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.platform_key_abi" href="#BinaryProvider.platform_key_abi"><code>BinaryProvider.platform_key_abi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">platform_key_abi(machine::AbstractString)</code></pre><p>Returns the platform key for the current platform, or any other though the the use of the <code>machine</code> parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.platform_name" href="#BinaryProvider.platform_name"><code>BinaryProvider.platform_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">platform_name(p::Platform)</code></pre><p>Get the &quot;platform name&quot; of the given platform.  E.g. returns &quot;Linux&quot; for a <code>Linux</code> object, or &quot;Windows&quot; for a <code>Windows</code> object.</p></div></div></section><pre><code class="language-none">BinaryProvider.platforms_match</code></pre><pre><code class="language-none">BinaryProvider.print_cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.probe_cmd" href="#BinaryProvider.probe_cmd"><code>BinaryProvider.probe_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">probe_cmd(cmd::Cmd; verbose::Bool = false)</code></pre><p>Returns <code>true</code> if the given command executes successfully, <code>false</code> otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.probe_platform_engines!" href="#BinaryProvider.probe_platform_engines!"><code>BinaryProvider.probe_platform_engines!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">probe_platform_engines!(;verbose::Bool = false)</code></pre><p>Searches the environment for various tools needed to download, unpack, and package up binaries.  Searches for a download engine to be used by <code>gen_download_cmd()</code> and a compression engine to be used by <code>gen_unpack_cmd()</code>, <code>gen_package_cmd()</code>, <code>gen_list_tarball_cmd()</code> and <code>parse_tarball_listing()</code>, as well as a <code>sh</code> execution engine for <code>gen_sh_cmd()</code>.  Running this function will set the global functions to their appropriate implementations given the environment this package is running on.</p><p>This probing function will automatically search for download engines using a particular ordering; if you wish to override this ordering and use one over all others, set the <code>BINARYPROVIDER_DOWNLOAD_ENGINE</code> environment variable to its name, and it will be the only engine searched for. For example, put:</p><pre><code class="language-none">ENV[&quot;BINARYPROVIDER_DOWNLOAD_ENGINE&quot;] = &quot;fetch&quot;</code></pre><p>within your <code>~/.juliarc.jl</code> file to force <code>fetch</code> to be used over <code>curl</code>.  If the given override does not match any of the download engines known to this function, a warning will be printed and the typical ordering will be performed.</p><p>Similarly, if you wish to override the compression engine used, set the <code>BINARYPROVIDER_COMPRESSION_ENGINE</code> environment variable to its name (e.g. <code>7z</code> or <code>tar</code>) and it will be the only engine searched for.  If the given override does not match any of the compression engines known to this function, a warning will be printed and the typical searching will be performed.</p><p>If <code>verbose</code> is <code>true</code>, print out the various engines as they are searched.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.probe_symlink_creation" href="#BinaryProvider.probe_symlink_creation"><code>BinaryProvider.probe_symlink_creation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">probe_symlink_creation(dest::AbstractString)</code></pre><p>Probes whether we can create a symlink within the given destination directory, to determine whether a particular filesystem is &quot;symlink-unfriendly&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.readuntil_many" href="#BinaryProvider.readuntil_many"><code>BinaryProvider.readuntil_many</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readuntil_many(s::IO, delims)</code></pre><p>Given a collection of delimiter characters, read from <code>s</code> until one of those delimiters is reached, or we reach the end of <code>s</code>.</p></div></div></section><pre><code class="language-none">BinaryProvider.safe_isfile</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.satisfied" href="#BinaryProvider.satisfied"><code>BinaryProvider.satisfied</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">satisfied(p::Product; platform::Platform = platform_key_abi(),
          verbose::Bool = false, isolate::Bool = false)</code></pre><p>Given a <code>Product</code>, return <code>true</code> if that <code>Product</code> is satisfied, e.g. whether a file exists that matches all criteria setup for that <code>Product</code>.  If <code>isolate</code> is set to <code>true</code>, will isolate all checks from the main Julia process in the event that <code>dlopen()</code>&#39;ing a library might cause issues.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.tail" href="#BinaryProvider.tail"><code>BinaryProvider.tail</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tail(collector::OutputCollector; len::Int = 100, colored::Bool = false)</code></pre><p>Write out the last <code>len</code> lines, optionally writing colored lines.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.tee" href="#BinaryProvider.tee"><code>BinaryProvider.tee</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tee(c::OutputCollector; colored::Bool = false, stream::IO = stdout)</code></pre><p>Spawn a background task to incrementally output lines from <code>collector</code> to the standard output, optionally colored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.temp_prefix" href="#BinaryProvider.temp_prefix"><code>BinaryProvider.temp_prefix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">temp_prefix(func::Function)</code></pre><p>Create a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.</p><p>Usage example:</p><pre><code class="language-none">out_path = abspath(&quot;./libfoo&quot;)
temp_prefix() do p
    # &lt;insert build steps here&gt;

    # tarball up the built package
    tarball_path, tarball_hash = package(p, out_path)
end</code></pre></div></div></section><pre><code class="language-none">BinaryProvider.tempdir_symlink_creation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.triplet" href="#BinaryProvider.triplet"><code>BinaryProvider.triplet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">triplet(platform)</code></pre><p>Get the target triplet for the given <code>Platform</code> object as a <code>String</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; triplet(MacOS())
&quot;x86_64-apple-darwin14&quot;

julia&gt; triplet(Windows(:i686))
&quot;i686-w64-mingw32&quot;

julia&gt; triplet(Linux(:armv7l, :default_libc, :default_abi, CompilerABI(:gcc4))
&quot;arm-linux-gnueabihf-gcc4&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.uninstall" href="#BinaryProvider.uninstall"><code>BinaryProvider.uninstall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uninstall(manifest::AbstractString; verbose::Bool = false)</code></pre><p>Uninstall a package from a prefix by providing the <code>manifest_path</code> that was generated during <code>install()</code>.  To find the <code>manifest_file</code> for a particular installed file, use <code>manifest_for_file(file_path; prefix=prefix)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.unpack" href="#BinaryProvider.unpack"><code>BinaryProvider.unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unpack(tarball_path::AbstractString, dest::AbstractString;
       verbose::Bool = false)</code></pre><p>Unpack tarball located at file <code>tarball_path</code> into directory <code>dest</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.valid_dl_path" href="#BinaryProvider.valid_dl_path"><code>BinaryProvider.valid_dl_path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">valid_dl_path(path::AbstractString, platform::Platform)</code></pre><p>Return <code>true</code> if the given <code>path</code> ends in a valid dynamic library filename. E.g. returns <code>true</code> for a path like <code>&quot;usr/lib/libfoo.so.3.5&quot;</code>, but returns <code>false</code> for a path like <code>&quot;libbar.so.f.a&quot;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.variable_name" href="#BinaryProvider.variable_name"><code>BinaryProvider.variable_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">variable_name(p::Product)</code></pre><p>Return the variable name associated with this <code>Product</code> as a string</p></div></div></section><pre><code class="language-none">BinaryProvider.vendor_str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.verify" href="#BinaryProvider.verify"><code>BinaryProvider.verify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">verify(path::AbstractString, hash::AbstractString;
       verbose::Bool = false, report_cache_status::Bool = false)</code></pre><p>Given a file <code>path</code> and a <code>hash</code>, calculate the SHA256 of the file and compare it to <code>hash</code>.  If an error occurs, <code>verify()</code> will throw an error.  This method caches verification results in a <code>&quot;$(path).sha256&quot;</code> file to accelerate re- verification of files that have been previously verified.  If no <code>&quot;.sha256&quot;</code> file exists, a full verification will be done and the file will be created, with the calculated hash being stored within the <code>&quot;.sha256&quot;</code> file..  If a <code>&quot;.sha256&quot;</code> file does exist, its contents are checked to ensure that the hash contained within matches the given <code>hash</code> parameter, and its modification time shows that the file located at <code>path</code> has not been modified since the last verification.</p><p>If <code>report_cache_status</code> is set to <code>true</code>, then the return value will be a <code>Symbol</code> giving a granular status report on the state of the hash cache, in addition to the <code>true</code>/<code>false</code> signifying whether verification completed successfully.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.wordsize" href="#BinaryProvider.wordsize"><code>BinaryProvider.wordsize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wordsize(platform)</code></pre><p>Get the word size for the given <code>Platform</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; wordsize(Linux(:arm7vl))
32

julia&gt; wordsize(MacOS())
64</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryProvider.write_deps_file" href="#BinaryProvider.write_deps_file"><code>BinaryProvider.write_deps_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">write_deps_file(depsjl_path::AbstractString, products::Vector{Product};
                verbose::Bool = false)</code></pre><p>Generate a <code>deps.jl</code> file that contains the variables referred to by the products within <code>products</code>.  As an example, running the following code:</p><pre><code class="language-none">fooifier = ExecutableProduct(..., :foo_exe)
libbar = LibraryProduct(..., :libbar)
write_deps_file(joinpath(@__DIR__, &quot;deps.jl&quot;), [fooifier, libbar])</code></pre><p>Will generate a <code>deps.jl</code> file that contains definitions for the two variables <code>foo_exe</code> and <code>libbar</code>.  If any <code>Product</code> object cannot be satisfied (e.g. <code>LibraryProduct</code> objects must be <code>dlopen()</code>-able, <code>FileProduct</code> objects must exist on the filesystem, etc...) this method will error out.  Ensure that you have used <code>install()</code> to install the binaries you wish to write a <code>deps.jl</code> file for.</p><p>The result of this method is a <code>deps.jl</code> file containing variables named as defined within the <code>Product</code> objects passed in to it, holding the full path to the installed binaries.  Given the example above, it would contain code similar to:</p><pre><code class="language-none">global const foo_exe = &quot;&lt;pkg path&gt;/deps/usr/bin/fooifier&quot;
global const libbar = &quot;&lt;pkg path&gt;/deps/usr/lib/libbar.so&quot;</code></pre><p>This <code>deps.jl</code> file is intended to be <code>include()</code>&#39;ed from within the top-level source of your package.  Note that all files are checked for consistency on package load time, and if an error is discovered, package loading will fail, asking the user to re-run <code>Pkg.build(&quot;package_name&quot;)</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
