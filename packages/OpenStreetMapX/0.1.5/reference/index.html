<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · OpenStreetMapX</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OpenStreetMapX</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">OpenStreetMapX.jl</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Representing-map-data-1">Representing map data</a></li><li><a class="toctext" href="#Routing-operations-1">Routing operations</a></li><li><a class="toctext" href="#Google-API-routing-1">Google API routing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Representing-map-data-1" href="#Representing-map-data-1">Representing map data</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.MapData" href="#OpenStreetMapX.MapData"><code>OpenStreetMapX.MapData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>MapData</code> represents all data that have been processed from OpenStreetMap osm file This is the main data structure used fot map data analytics.</p><p><strong>Fields</strong></p><ul><li><code>bounds</code> :  bounds of the area map (stored as a OpenStreetMapX.Bounds object)</li><li><code>nodes</code> :  dictionary of nodes representing all the objects on the map (with coordinates in East, North, Up system)</li><li><code>roadways</code> :  unique roads stored as a OpenStreetMapX.Way objects</li><li><code>intersections</code> : roads intersections</li><li><code>g</code> : <code>LightGraphs</code> directed graph representing a road network</li><li><code>v</code> : vertices in the road network</li><li><code>e</code> : edges in the graph represented as a tuple (source,destination)</li><li><code>w</code> : edge weights, indexed by graph id</li><li><code>class</code> : road class of each edge</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.get_map_data-Tuple{String,Union{Nothing, String}}" href="#OpenStreetMapX.get_map_data-Tuple{String,Union{Nothing, String}}"><code>OpenStreetMapX.get_map_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_map_data(filepath::String,filename::Union{String,Nothing}=nothing;
             road_levels::Set{Int} = Set(1:length(OpenStreetMapX.ROAD_CLASSES)),
			 use_cache::Bool = true, only_intersections::Bool=true)::MapData</code></pre><p>High level function - parses .osm file and create the road network based on the map data.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code> : path with an .osm file (directory or path to a file)</li><li><code>filename</code> : name of the file (when the first argument is a directory)</li><li><code>road_levels</code> : a set with the road categories (see: OpenStreetMapX.ROAD_CLASSES for more informations)</li><li><code>use_cache</code> : a *.cache file will be crated with a serialized map image in the <code>datapath</code> folder</li><li><code>only_intersections</code> : include only road system data</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.LLA" href="#OpenStreetMapX.LLA"><code>OpenStreetMapX.LLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LLA</code></pre><p>Point in Latitude-Longitude-Altitude (LLA) coordinates Used to store node data in OpenStreetMapX XML files</p><p><strong>Constructors</strong></p><pre><code class="language-none">LLA(lat::Float64, lon::Float64)
LLA(lat::Float64, lon::Float64, alt::Float64)
LLA(xyz::XYZ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>lat</code> : lattitude</li><li><code>lon</code> : Longitude</li><li><code>alt</code> : altitude</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.ENU" href="#OpenStreetMapX.ENU"><code>OpenStreetMapX.ENU</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ENU</code></pre><p>Point in East-North-Up (ENU) coordinates.</p><p>Local cartesian coordinate system. Linearized about a reference point.</p><p><strong>Constructors</strong></p><pre><code class="language-none">ENU(east::Float64, north::Float64, up::Float64)
ENU(east::Float64, north::Float64)
ENU(xyz::XYZ)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.Bounds" href="#OpenStreetMapX.Bounds"><code>OpenStreetMapX.Bounds</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Bounds{T &lt;: Union{LLA, ENU}}</code></pre><p>Bounds for the <code>LLA</code> or <code>ENU</code>coordinates.</p></div></div></section><h2><a class="nav-anchor" id="Routing-operations-1" href="#Routing-operations-1">Routing operations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.generate_point_in_bounds-Tuple{MapData}" href="#OpenStreetMapX.generate_point_in_bounds-Tuple{MapData}"><code>OpenStreetMapX.generate_point_in_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">generate_point_in_bounds(m::MapData)</code></pre><p>Generates a random pair of Latitude-Longitude coordinates within boundaries of map <code>m</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.point_to_nodes-Tuple{Tuple{Float64,Float64},MapData}" href="#OpenStreetMapX.point_to_nodes-Tuple{Tuple{Float64,Float64},MapData}"><code>OpenStreetMapX.point_to_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">point_to_nodes(point::Tuple{Float64,Float64}, m::MapData)</code></pre><p>Converts a pair Latitude-Longitude of coordinates  <code>point</code> to a node on a map <code>m</code> The result is a node indentifier.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.point_to_nodes-Tuple{LLA,MapData}" href="#OpenStreetMapX.point_to_nodes-Tuple{LLA,MapData}"><code>OpenStreetMapX.point_to_nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">point_to_nodes(point::LLA, m::MapData)</code></pre><p>Converts a pair of coordinates LLA (Latitude-Longitude-Altitude) <code>point</code> to a node on a map <code>m</code> The result is a node indentifier.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.shortest_route-Tuple{MapData,Int64,Int64}" href="#OpenStreetMapX.shortest_route-Tuple{MapData,Int64,Int64}"><code>OpenStreetMapX.shortest_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shortest_route(m::MapData, node1::Int, node2::Int)</code></pre><p>Find Shortest route between <code>node1</code> and <code>node2</code> on map <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.shortest_route-Tuple{MapData,Int64,Int64,Int64}" href="#OpenStreetMapX.shortest_route-Tuple{MapData,Int64,Int64,Int64}"><code>OpenStreetMapX.shortest_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">shortest_route(m::MapData, node1::Int, node2::Int, node3::Int)</code></pre><p>Find Shortest route between <code>node1</code> and <code>node2</code> and <code>node3</code> on map <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.fastest_route-Tuple{MapData,Int64,Int64,Dict{Int64,Float64}}" href="#OpenStreetMapX.fastest_route-Tuple{MapData,Int64,Int64,Dict{Int64,Float64}}"><code>OpenStreetMapX.fastest_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fastest_route(m::MapData, node1::Int, node2::Int,
              speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)</code></pre><p>Find fastest route between <code>node1</code> and <code>node2</code>  on map <code>m</code> with assuming <code>speeds</code> for road classes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.fastest_route-Tuple{MapData,Int64,Int64,Int64,Dict{Int64,Float64}}" href="#OpenStreetMapX.fastest_route-Tuple{MapData,Int64,Int64,Int64,Dict{Int64,Float64}}"><code>OpenStreetMapX.fastest_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fastest_route(m::MapData, node1::Int, node2::Int, node3::Int,
              speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)</code></pre><p>Find fastest route between <code>node1</code> and <code>node2</code> and <code>node3</code>  on map <code>m</code> with assuming <code>speeds</code> for road classes.</p></div></div></section><h2><a class="nav-anchor" id="Google-API-routing-1" href="#Google-API-routing-1">Google API routing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.get_google_route-Tuple{Int64,Int64,MapData,String}" href="#OpenStreetMapX.get_google_route-Tuple{Int64,Int64,MapData,String}"><code>OpenStreetMapX.get_google_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_google_route(origin::Int, destination::Int,
                 map_data:MapData, googleapi_key::String;
                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)</code></pre><p>Get route from to based on Google Distances API with two points (<code>origin</code> and <code>destination</code>) on map <code>map_data</code> using Google API key <code>googleapi_key</code> with optional Google Distances API request parameters <code>googleapi_parameters</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.get_google_route-Tuple{Int64,Int64,Int64,MapData,String}" href="#OpenStreetMapX.get_google_route-Tuple{Int64,Int64,Int64,MapData,String}"><code>OpenStreetMapX.get_google_route</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_google_route(origin::Int, destination::Int, waypoint::Int,
                 map_data:MapData, googleapi_key::String;
                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)</code></pre><p>Get route from to based on Google Distances API with three points (<code>origin</code>, <code>destination</code> and <code>waypoint</code> between) on map <code>map_data</code> using Google API key <code>googleapi_key</code> with optional Google Distances API request parameters <code>googleapi_parameters</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.node_to_string-Tuple{Int64,MapData}" href="#OpenStreetMapX.node_to_string-Tuple{Int64,MapData}"><code>OpenStreetMapX.node_to_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">node_to_string(node_id::Int,map_data::MapData)</code></pre><p>Convert node coordinates (stored in ENU system in the <code>nodes</code> field of <code>map_data</code>) identified by <code>node_id</code> to string with LLA system coordinates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OpenStreetMapX.googleAPI_parameters" href="#OpenStreetMapX.googleAPI_parameters"><code>OpenStreetMapX.googleAPI_parameters</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Dictionary for Google Distances API requests:</p><p><strong>Keys</strong></p><ul><li><code>:url</code> : url for google API, only JSON files outputs are accepted</li><li><code>:mode</code> : transportation mode used in simulation, in the current library scope only driving is accepted</li><li><code>:avoid</code> : map features to avoid (to mantain compatibility with OSM routes ferries should be avoided)</li><li><code>:units</code> : unit system for displaing distances (changing to <em>imperial</em> needs deeper changes in both OSMsim and OpenStreetMapX modules)</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">OpenStreetMapX.jl</span></a></footer></article></body></html>
