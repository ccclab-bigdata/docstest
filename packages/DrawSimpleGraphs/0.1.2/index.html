<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· DrawSimpleGraphs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DrawSimpleGraphs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Embedding-Commands-1">Embedding Commands</a></li><li><a class="toctext" href="#Vertex-Labels-1">Vertex Labels</a></li><li><a class="toctext" href="#Example:-Knight&#39;s-Tour-1">Example: Knight&#39;s Tour</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DrawSimpleGraphs-1" href="#DrawSimpleGraphs-1">DrawSimpleGraphs</a></h1><p>Drawing functions for <code>SimpleGraphs</code>.</p><p><a href="https://travis-ci.org/scheinerman/DrawSimpleGraphs.jl"><img src="https://travis-ci.org/scheinerman/DrawSimpleGraphs.jl.svg?branch=master" alt="Build Status"/></a></p><p><a href="http://codecov.io/github/scheinerman/DrawSimpleGraphs.jl?branch=master"><img src="http://codecov.io/github/scheinerman/DrawSimpleGraphs.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>Given a <code>SimpleGraph</code>, the function <code>draw(G)</code> draws <code>G</code> in its current embedding. If the graph does not have an embedding, then it is given a circular embedding.</p><p>If further operations on the drawing are desired, then <code>Plots</code> or <code>SimpleDrawing</code> functions may be used.</p><pre><code class="language-julia">julia&gt; using SimpleGraphs, DrawSimpleGraphs, Plots

julia&gt; G = Cube(4)
Cube graph Q(4) (n=16, m=32)

julia&gt; embed(G,:combined)

julia&gt; draw(G)

julia&gt; savefig(&quot;four-cube.png&quot;)</code></pre><p><img src="four-cube.png" alt/></p><h2><a class="nav-anchor" id="Embedding-Commands-1" href="#Embedding-Commands-1">Embedding Commands</a></h2><p>The following functions reside in <code>SimpleGraphs</code>. They are used to create and manipulate embeddings associated with a graph.</p><h3><a class="nav-anchor" id="Create-an-embedding-1" href="#Create-an-embedding-1">Create an embedding</a></h3><p><code>embed(G,method)</code> creates a new embedding of <code>G</code>. The second argument method is a symbol associated with an embedding algorithm. The <code>method</code> can be one of the following:</p><ul><li><code>:circular</code> (default) arranges the vertices in a circle.</li><li><code>:random</code> arranges the vertices at random.</li><li><code>:spring</code> arranges the vertices by modeling edges as springs holding repelling vertices together.</li><li><code>:stress</code> arranges the vertices by attempting to put vertices geometric distance equal to their graph-theoretic distance.</li><li><code>:combined</code> is equivalent to first performing a <code>spring</code> embedding followed by a <code>stress</code> embedding. Often gives nice results.</li><li><code>:spectral</code> arranges the vertices based on the eigenvectors of the Laplacian matrix of the graph. Specifically, the <code>x</code>-coordinates come from the eigenvector</li></ul><p>associated with the second smallest eigenvalue, and the <code>y</code>-coordinates come from the eigenvector associated with the third smallest.</p><p>In addition, <code>embed(G,xy)</code> will give the graph an embedding specified in the dictionary <code>xy</code> where maps vertices to two-element vectors.</p><h3><a class="nav-anchor" id="Modify-an-embedding-1" href="#Modify-an-embedding-1">Modify an embedding</a></h3><ul><li><p><code>has_embedding(G)</code> checks to see if the graph has been provided with an embedding.</p></li><li><p><code>getxy(G)</code> retrieves a copy of the embedding. Modifying the output of <code>getxy</code> does <em>not</em> modify the embedding of the graph.</p></li><li><p><code>set_line_color(G,name)</code> assigns the color in the string <code>name</code> to the edges and boundaries of the vertices. Defaults to <code>&quot;black&quot;</code>.</p></li><li><p><code>get_line_color(G)</code> returns the line color.</p></li><li><p><code>set_fill_color(G,name)</code> assigns the color in the string <code>name</code> to be the fill color of the vertices. Defaults to <code>&quot;white&quot;</code>.</p></li><li><p><code>set_vertex_size(G,sz)</code> sets the size of the drawn vertices to</p></li></ul><p>the integer <code>sz</code>.</p><ul><li><p><code>get_vertex_size(G)</code> returns the size of the vertices.</p></li><li><p><code>transform(G,A,b)</code> applies an affine transformation to all coordinates in the graph&#39;s drawing. Here <code>A</code> is 2-by-2 matrix and <code>b</code> is a 2-vector. Each point <code>p</code> is mapped to <code>A*p+b</code>. Special</p></li></ul><p>versions of this command are provided by <code>scale</code>, <code>rotate</code>, <code>translate</code>, and <code>recenter</code>. (Note: Some of these function names cause collisions, so I may change them.)</p><ul><li><code>edge_length(G,uv)</code> returns the geometric length of the edge <code>uv</code>. Note this fails if <code>G</code> does not have an embedding.</li></ul><p><code>edge_length(G)</code> returns an array of the edge lengths.</p><h2><a class="nav-anchor" id="Vertex-Labels-1" href="#Vertex-Labels-1">Vertex Labels</a></h2><p>Use <code>draw_labels(G)</code> after <code>draw(G)</code> to insert vertex names into the drawing. Optionally, add a font size, <code>draw_labels(G,sz)</code>, to make the labels small enough to fit (or use <code>set_vertex_size</code> to make larger vertices).</p><pre><code class="language-julia">julia&gt; G = Cube(3)
Cube graph Q(3) (n=8, m=12)

julia&gt; embed(G,:combined)

julia&gt; set_vertex_size(G,20)

julia&gt; draw(G)

julia&gt; draw_labels(G)</code></pre><p><img src="cube.png" alt/></p><h2><a class="nav-anchor" id="Example:-Knight&#39;s-Tour-1" href="#Example:-Knight&#39;s-Tour-1">Example: Knight&#39;s Tour</a></h2><p>The function <code>KnightTourDrawing(r,c)</code> to solve the problem of finding a knight&#39;s tour on an <code>r</code>-by-<code>c</code> chess board and drawing the solution.</p><pre><code class="language-julia">julia&gt; KnightTourDrawing(8,8)
Searching for a Hamiltonian cycle in an 8-by-8 Knight&#39;s move graph
1374.144891 seconds (9.02 G allocations: 1002.489 GiB, 12.68% gc time)
Finished</code></pre><p><img src="knight.png" alt/></p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
