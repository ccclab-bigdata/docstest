var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#NetworkLayout.jl-1",
    "page": "Readme",
    "title": "NetworkLayout.jl",
    "category": "section",
    "text": "Layout algorithms for graphs and trees in pure Julia.(Image: Coverage Status)Linux, OSX : (Image: Build Status)Windows : (Image: Build status)"
},

{
    "location": "#Algorithms-1",
    "page": "Readme",
    "title": "Algorithms",
    "category": "section",
    "text": ""
},

{
    "location": "#Scalable-Force-Directed-Placement-1",
    "page": "Readme",
    "title": "Scalable Force Directed Placement",
    "category": "section",
    "text": "Spring-Electric Force Directed Placement algorithm as explained in Efficient and High Quality Force-Directed Graph Drawing by Yifan Hu.Module Name : SFDP"
},

{
    "location": "#Usage-1",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "layout(adjacency_matrix,dimension;startpostitions,tol,C,K,iterations)"
},

{
    "location": "#arguments-1",
    "page": "Readme",
    "title": "arguments",
    "category": "section",
    "text": "adjacency_matrix - sparse/full adjacency matrix that represents the graph\ndimension - dimension in which the layouting code has to be generated. dimension can be an integer specifying               the dimension or a Point type, eg. Point3f0 which denotes 3D.\nstartpositions - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\ntol - permitted distance between current and calculated co-ordinate. Lower the tolerance, more the number of iterations (kwarg)\nC, K - used to scale the layout (kwarg)\niterations - Number of iterations we apply the forces (kwarg)"
},

{
    "location": "#returns-1",
    "page": "Readme",
    "title": "returns",
    "category": "section",
    "text": "positions - co-ordinates of nodes in the layout"
},

{
    "location": "#iterator-1",
    "page": "Readme",
    "title": "iterator",
    "category": "section",
    "text": "A user can move between iterations using a Layout object."
},

{
    "location": "#Example-1",
    "page": "Readme",
    "title": "Example",
    "category": "section",
    "text": "using LightGraphs\nusing NetworkLayout:SFDP\ng = WheelGraph(10)\na = adjacency_matrix(g) # generates a sparse adjacency matrix\nnetwork = layout(a,Point2f0,tol=0.1,C=1,K=1,iterations=10) # generate 2D layoutUsing Iterator :g = WheelGraph(10)\na = adjacency_matrix(g)\ntol = 0.1\nC = 0.2\nK = 1\niterations = 100\nnetwork = Layout(a,locs,tol,C,K,iterations)\nstate = start(network)\nwhile !done(network,state)\n  network, state = next(network,state)\nend\nreturn network.positions(Image: sfdp)The image shows a LightGraphs.WheelGraph(10) object layout generated by SFDP Algorithm."
},

{
    "location": "#Buchheim-Tree-Drawing-1",
    "page": "Readme",
    "title": "Buchheim Tree Drawing",
    "category": "section",
    "text": "Buchheim Tree Drawing as explained in Improving Walker\'s Algorithm to Run in Linear Time by Christoph Buchheim, Michael Junger and Sebastian Leipert.Module Name : Buchheim"
},

{
    "location": "#Usage-2",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "layout(adjacency_list; nodesize)"
},

{
    "location": "#arguments-2",
    "page": "Readme",
    "title": "arguments",
    "category": "section",
    "text": "adjacency_list - adjacency list that represents the tree\nnodesize - sizes of nodes (used to position the nodes) (kwarg)"
},

{
    "location": "#returns-2",
    "page": "Readme",
    "title": "returns",
    "category": "section",
    "text": "positions - co-ordinates of the layout"
},

{
    "location": "#Example-2",
    "page": "Readme",
    "title": "Example",
    "category": "section",
    "text": "using NetworkLayout:Buchheim\nadj_list = Vector{Int}[   # adjacency list\n        [2,3,4],\n        [5,6],\n        [7],\n        [],\n        [],\n        [],\n        []\n      ]\n nodesize = [1,2.3,1.2,2,3,1.4,0.8]\n locs = layout(adj_list,nodesize=nodesize) # generating the layout for the tree\n ```\n ![tree](https://cloud.githubusercontent.com/assets/8404278/17638844/afd280a4-610a-11e6-8fea-5c99808bd740.png)\n\nThe image shows a `LightGraphs.BinaryTree(4)` object layout by Buchheim Algorithm.\n\n### Spring/Repulsion Model\n\nSpring/Repulsion model of Fruchterman and Reingold (1991). Original code taken from [GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)\n\nModule Name : `Spring`\n\n#### Usage\njulia layout(adjacency_matrix,dimension;startpositions,C,iterations,initialtemp)##### arguments\n * `adjacency_matrix` - sparse/full adjacency matrix that represents the graph\n * `dimension` - dimension in which the layouting code has to be generated. `dimension` can be an integer specifying\n                  the dimension or a `Point` type, eg. `Point3f0` which denotes 3D.\n * `startpositions` - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\n * `iterations` - Number of iterations we apply the forces (kwarg)\n * `C` - Constant to fiddle with density of resulting layout (kwarg)\n * `initialtemp` - Initial \"temperature\", controls movement per iteration (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n##### iterator\n\nA user can move between iterations using a `Layout` object.\n\n\n#### Example\njulia using LightGraphs using NetworkLayout:Spring g = WheelGraph(30) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,Point2f0,C=2.0,iterations=100,K=2.0) # generate 2D layoutUsing Iterator :\njulia g = WheelGraph(30) a = adjacency_matrix(g) iterations = 200 C = 2.0 initialtemp = 2.0 network = Layout(a,locs,C,iterations,initialtemp) state = start(network) while !done(network,state)  network, state = next(network,state) end return network.positions![spring](https://cloud.githubusercontent.com/assets/8404278/17638354/1c20cc56-6107-11e6-82ed-8873431d8d33.png)\n\nThe image shows a `LightGraphs.WheelGraph(10)` object layout generated by Spring Algorithm.\n\n### Stress Majorization\n\nBased on the algorithm explained in \"Graph Drawing by Stress Majorization\" by Emden R Gansner, Yehuda Koren and Stephen North. Original code taken from [GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)\n\nModule Name : `Stress`\n\n#### Usage\njulia layout(δ,dimension;startpositions,weights,iterations,abstols,reltols,abstolx)##### arguments\n * `δ` - Matrix of pairwise distances (Adjacency Matrix can be used)\n * `dimension` - dimension in which the layouting code has to be generated. `dimension` can be an integer specifying\n                  the dimension or a `Point` type, eg. `Point3f0` which denotes 3D.\n * `weights` - Matrix of weights (kwarg)\n * `startpositions` - co-ordinates of the layout to start with. By default, a random layout is used (kwarg)\n * `iterations` - Number of iterations we apply the forces (kwarg)\n * `abstols` - Absolute tolerance for convergence of stress (kwarg)\n * `reltols` - Relative tolerance for convergence of stress (kwarg)\n * `abstolx` - Absolute tolerance for convergence of layout (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n##### iterator\n\nA user can move between iterations using a `Layout` object.\n\n\n#### Example\njulia using LightGraphs using NetworkLayout:Stress g = CompleteGraph(10) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,2) # generate 2D layoutUsing Iterator :\njulia g = CompleteGraph(10) δ = adjacency_matrix(g) startpositions=rand(Point{3, Float64}, size(δ,1)) iter = Layout(δ, Point{3,Float64}; startpositions=startpositions) state = start(iter) while !done(iter, state)     iter, state = next(iter, state) end iter.positions\n![stress](https://cloud.githubusercontent.com/assets/8404278/17638554/5e65e26c-6108-11e6-9522-30e6fa044d26.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout using Stress Algorithm.\n\n### Spectral Layout Algorithm\n\nUses the technique of Spectral Graph Drawing, which is an under-appreciated method of graph layouts; easier, simpler, and faster than the more common spring-based methods. Original code taken from [PlotRecipes.jl](https://github.com/JuliaPlots/PlotRecipes.jl)\n\nModule Name : `Spectral`\n\n#### Usage\njulia layout(adjacencymatrix; nodeweights, kw...)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n * `node_weights` - weights for different nodes (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Spectral g = CompleteGraph(10) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a) # generate 3D layout![spectral](https://cloud.githubusercontent.com/assets/8404278/17638718/a0b451ca-6109-11e6-9a66-fd22332b8541.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout by Spectral Algorithm.\n\n### Circular Layout Algorithm\n\nPosition nodes on a circle. Original code taken from [GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)\n\nModule Name : `Circular`\n\n#### Usage\njulia layout(adjacency_matrix)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Circular g = CompleteGraph(30) a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a) # generate 2D layout\n![circular](https://cloud.githubusercontent.com/assets/8404278/17638609/d8eb4428-6108-11e6-934b-f326f07cf044.png)\n\nThe image shows a `LightGraphs.CompleteGraph(10)` object layout using Circular Algorithm.\n\n### Shell Layout Algorithm\n\nPosition nodes in concentric circles. Original code taken from [GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)\n\nModule Name : `Shell`\n\n#### Usage\njulia layout(adjacency_matrix;nlist)##### arguments\n * `adjacency_matrix` - Adjacency Matrix in dense/sparse format\n * `nlist` - Shell-wise separation of nodes (kwarg)\n\n##### returns\n `positions` - co-ordinates of nodes in the layout\n\n#### Example\njulia using LightGraphs using NetworkLayout:Shell g = CompleteGraph(30) n = Array(Vector{Int},2) n[1] = [1:15] n[2] = [16:30] a = adjacency_matrix(g) # generates a sparse adjacency matrix network = layout(a,nlist=n) # generate 2D layout ``` (Image: shell)This figure shows a LightGraphs.CompleteGraph(30) object in 2 shells."
},

{
    "location": "#Benchmarks-1",
    "page": "Readme",
    "title": "Benchmarks",
    "category": "section",
    "text": "The iterative algorithms have been benchmarked using 3 different graphs: LightGraphs.WheelGraph(10), LightGraphs.WheelGraph(100) and jagmesh1. The number of iterations is fixed on 100. The following graph is obtained which shows SFDP to be the fastest in a general scenario, but Stress Algorithm is faster when the number of edges per graph is comparatively less, as in jagmesh1.(Image: bench)NOTE : All screenshots are generated using NetworkViz.jl, ThreeJS.jl and Escher.jl. The plot used is generated using Gadfly.jl"
},

{
    "location": "autodocs/#NetworkLayout.Buchheim",
    "page": "Docstrings",
    "title": "NetworkLayout.Buchheim",
    "category": "module",
    "text": "Using the algorithm proposed in the paper, \"Improving Walker\'s Algorithm to Run in Linear Time\" by Christoph Buchheim, Michael Junger, Sebastian Leipert (http://dirk.jivas.de/papers/buchheim02improving.pdf)\n\nArguments tree    Adjacency List that represents the given tree\n\nReturns positions     co-ordinates of the layout\n\n\n\n\n\n"
},

{
    "location": "autodocs/#NetworkLayout.Circular",
    "page": "Docstrings",
    "title": "NetworkLayout.Circular",
    "category": "module",
    "text": "This function wrap from NetworkX Position nodes on a circle. Parameters adj_matrix a graph Returns locsx, locsy Locations of the nodes. Can be any units you want, but will be normalized and centered anyway Examples\n\njulia> g = simple_house_graph()\njulia> locs_x, locs_y = circular_layout(g)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#NetworkLayout.SFDP",
    "page": "Docstrings",
    "title": "NetworkLayout.SFDP",
    "category": "module",
    "text": "Using the Spring-Electric model suggested by Yifan Hu (http://yifanhu.net/PUB/graphdrawsmall.pdf) Forces are calculated as :         fattr(i,j) = ||xi - xj||^2 / K ,     i<->j         frepln(i,j) = -CK^2 / ||xi - xj|| ,  i!=j Arguments :   adj_matrix      Sparse/Full Adjacency matrix of the graph   tol             Tolerance distance - Minimum distance between 2 nodes   C, K            Constants that help scale the layout Output :   positions       Co-ordinates for the nodes\n\n\n\n\n\n"
},

{
    "location": "autodocs/#NetworkLayout.Shell",
    "page": "Docstrings",
    "title": "NetworkLayout.Shell",
    "category": "module",
    "text": "This function is copy from IainNZ\'s GraphLayout.jl Position nodes in concentric circles. Parameters adj_matrix a graph nlist Vector of Vector, Vector of node Vector for each shell. Examples\n\njulia> g = graphfamous(\"karate\")\njulia> nlist = Array(Vector{Int}, 2)\njulia> nlist[1] = [1:5]\njulia> nlist[2] = [6:num_vertiecs(g)]\njulia> locs_x, locs_y = shell_layout(g, nlist)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#NetworkLayout.Spring",
    "page": "Docstrings",
    "title": "NetworkLayout.Spring",
    "category": "module",
    "text": "Use the spring/repulsion model of Fruchterman and Reingold (1991):\n    Attractive force:  f_a(d) =  d^2 / k\n    Repulsive force:  f_r(d) = -k^2 / d\nwhere d is distance between two vertices and the optimal distance\nbetween vertices k is defined as C * sqrt( area / num_vertices )\nwhere C is a parameter we can adjust\n\nArguments:\nadj_matrix    Adjacency matrix of some type. Non-zero of the eltype\n              of the matrix is used to determine if a link exists,\n              but currently no sense of magnitude\nC             Constant to fiddle with density of resulting layout\niterations    Number of iterations we apply the forces\ninitialtemp   Initial \"temperature\", controls movement per iteration\n\n\n\n\n\n"
},

{
    "location": "autodocs/#NetworkLayout.Stress",
    "page": "Docstrings",
    "title": "NetworkLayout.Stress",
    "category": "module",
    "text": "Compute graph layout using stress majorization\n\nInputs:\n\nδ: Matrix of pairwise distances\np: Dimension of embedding (default: 2)\nweights: Matrix of weights. If not specified, defaults to\n       weights[i,j] = δ[i,j]^-2 if δ[i,j] is nonzero, or 0 otherwise\nX0: Initial guess for the layout. Coordinates are given in rows.\n    If not specified, default to random matrix of Gaussians\n\nAdditional optional keyword arguments control the convergence of the algorithm and the additional output as requested:\n\niterations:   Maximum number of iterations. Default: 400size(X0, 1)^2\nabstols:      Absolute tolerance for convergence of stress.\n              The iterations terminate if the difference between two\n              successive stresses is less than abstol.\n              Default: √(eps(eltype(X0))\nreltols:      Relative tolerance for convergence of stress.\n              The iterations terminate if the difference between two\n              successive stresses relative to the current stress is less than\n              reltol. Default: √(eps(eltype(X0))\nabstolx:      Absolute tolerance for convergence of layout.\n              The iterations terminate if the Frobenius norm of two successive\n              layouts is less than abstolx. Default: √(eps(eltype(X0))\n\nOutput:\n\nThe final layout positions.\n\nReference:\n\nThe main equation to solve is (8) of:\n\n@incollection{\n    author = {Emden R Gansner and Yehuda Koren and Stephen North},\n    title = {Graph Drawing by Stress Majorization}\n    year={2005},\n    isbn={978-3-540-24528-5},\n    booktitle={Graph Drawing},\n    seriesvolume={3383},\n    series={Lecture Notes in Computer Science},\n    editor={Pach, J\'anos},\n    doi={10.1007/978-3-540-31843-9_25},\n    publisher={Springer Berlin Heidelberg},\n    pages={239--250},\n}\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "NetworkLayout.BuchheimNetworkLayout.CircularNetworkLayout.NetworkLayoutNetworkLayout.SFDPNetworkLayout.ShellNetworkLayout.SpectralNetworkLayout.SpringNetworkLayout.StressNetworkLayout.evalNetworkLayout.include"
},

]}
