<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>17 Symbolic Mode · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../library/">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="../acknowledgement/">Acknowledgement</a></li><li><a class="toctext" href="../01-introduction/">1 Introductory Information</a></li><li><a class="toctext" href="../02-structure/">2 Structure of Programs</a></li><li><a class="toctext" href="../03-expressions/">3 Expressions</a></li><li><a class="toctext" href="../04-lists/">4 Lists</a></li><li><a class="toctext" href="../05-statements/">5 Statements</a></li><li><a class="toctext" href="../06-commands-declarations/">6 Commands and Declarations</a></li><li><a class="toctext" href="../07-prefix-ops/">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="../08-display/">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="../09-polynomials/">9 Polynomials and Rationals</a></li><li><a class="toctext" href="../10-properties/">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="../11-substitution/">11 Substitution Commands</a></li><li><a class="toctext" href="../12-file-io/">12 File Handling Commands</a></li><li><a class="toctext" href="../13-interactive/">13 Commands for Interactive Use</a></li><li><a class="toctext" href="../14-matrix/">14 Matrix Calculations</a></li><li><a class="toctext" href="../15-procedures/">15 Procedures</a></li><li><a class="toctext" href="../16-packages/">16 User Contributed Packages</a></li><li class="current"><a class="toctext" href>17 Symbolic Mode</a><ul class="internal"><li><a class="toctext" href="#.1-Symbolic-Infix-Operators-1">17.1 Symbolic Infix Operators</a></li><li><a class="toctext" href="#.2-Symbolic-Expressions-1">17.2 Symbolic Expressions</a></li><li><a class="toctext" href="#.3-Quoted-Expressions-1">17.3 Quoted Expressions</a></li><li><a class="toctext" href="#.4-Lambda-Expressions-1">17.4 Lambda Expressions</a></li><li><a class="toctext" href="#.5-Symbolic-Assignment-Statements-1">17.5 Symbolic Assignment Statements</a></li><li><a class="toctext" href="#.6-FOR-EACH-Statement-1">17.6 FOR EACH Statement</a></li><li><a class="toctext" href="#.7-Symbolic-Procedures-1">17.7 Symbolic Procedures</a></li><li><a class="toctext" href="#.8-Standard-Lisp-Equivalent-of-Reduce-Input-1">17.8 Standard Lisp Equivalent of Reduce Input</a></li><li><a class="toctext" href="#.9-Communicating-with-Algebraic-Mode-1">17.9 Communicating with Algebraic Mode</a></li><li><a class="toctext" href="#.10-Rlisp-’88-1">17.10 Rlisp ’88</a></li><li><a class="toctext" href="#.11-References-1">17.11 References</a></li></ul></li><li><a class="toctext" href="../18-physics/">18 Calculations in High Energy Physics</a></li><li><a class="toctext" href="../19-rlisp/">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="../20-maintaining/">20 Maintaining REDUCE</a></li><li><a class="toctext" href="../A-reserved/">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="../B-bibliography/">Appendix B: Bibliography</a></li><li><a class="toctext" href="../C-changelog/">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="../">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href>17 Symbolic Mode</a></li></ul></nav><hr/><div id="topbar"><span>17 Symbolic Mode</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Symbolic-Mode-1" href="#Symbolic-Mode-1">17 Symbolic Mode</a></h1><p>At the system level, REDUCE is based on a version of the programming language Lisp known as Standard Lisp which is described in J. Marti, Hearn, A. C., Griss, M. L. and Griss, C., “Standard LISP Report&quot; SIGPLAN Notices, ACM, New York, 14, No 10 (1979) 48-68. We shall assume in this section that the reader is familiar with the material in that paper. This also assumes implicitly that the reader has a reasonable knowledge about Lisp in general, say at the level of the LISP 1.5 Programmer’s Manual (McCarthy, J., Abrahams, P. W., Edwards, D. J., Hart, T. P. and Levin, M. I., “LISP 1.5 Programmer’s Manual”, M.I.T. Press, 1965) or any of the books mentioned at the end of this section. Persons unfamiliar with this material will have some difficulty understanding this section.</p><p>Although REDUCE is designed primarily for algebraic calculations, its source language is general enough to allow for a full range of Lisp-like symbolic calculations. To achieve this generality, however, it is necessary to provide the user with two modes of evaluation, namely an algebraic mode and a symbolic mode. To enter symbolic mode, the user types <code>symbolic;</code> (or <code>lisp;</code>) and to return to algebraic mode one types <code>algebraic;</code>. Evaluations proceed differently in each mode so the user is advised to check what mode he is in if a puzzling error arises. He can find his mode by typing</p><pre><code class="language-none">        eval_mode;</code></pre><p>The current mode will then be printed as <code>ALGEBRAIC</code> or <code>SYMBOLIC</code>.</p><p>Expression evaluation may proceed in either mode at any level of a calculation, provided the results are passed from mode to mode in a compatible manner. One simply prefixes the relevant expression by the appropriate mode. If the mode name prefixes an expression at the top level, it will then be handled as if the global system mode had been changed for the scope of that particular calculation.</p><p>For example, if the current mode is <code>algebraic</code>, then the commands</p><pre><code class="language-none">        symbolic car ’(a);  
        x+y;</code></pre><p>will cause the first expression to be evaluated and printed in symbolic mode and the second in algebraic mode. Only the second evaluation will thus affect the expression workspace. On the other hand, the statement</p><pre><code class="language-none">        x + symbolic car ’(12);</code></pre><p>will result in the algebraic value <code>x+12</code>.</p><p>The use of <code>symbolic</code> (and equivalently <code>algebraic</code>) in this manner is the same as any operator. That means that parentheses could be omitted in the above examples since the meaning is obvious. In other cases, parentheses must be used, as in</p><pre><code class="language-none">        symbolic(x := ’a);</code></pre><p>Omitting the parentheses, as in</p><pre><code class="language-none">        symbolic x := a;</code></pre><p>would be wrong, since it would parse as</p><pre><code class="language-none">        symbolic(x) := a;</code></pre><p>For convenience, it is assumed that any operator whose <em>first</em> argument is quoted is being evaluated in symbolic mode, regardless of the mode in effect at that time. Thus, the first example above could be equally well written:</p><pre><code class="language-none">        car ’(a);</code></pre><p>Except where explicit limitations have been made, most REDUCE algebraic constructions carry over into symbolic mode. However, there are some differences. First, expression evaluation now becomes Lisp evaluation. Secondly, assignment statements are handled differently, as we shall discuss shortly. Thirdly, local variables and array elements are initialized to <code>nil</code> rather than <code>0</code>. (In fact, any variables not explicitly declared <code>INTEGER</code> are also initialized to <code>nil</code> in algebraic mode, but the algebraic evaluator recognizes <code>nil</code> as <code>0</code>.) Finally, function definitions follow the conventions of Standard Lisp.</p><p>To begin with, we mention a few extensions to our basic syntax which are designed primarily if not exclusively for symbolic mode.</p><ul><li><a href="#Symbolic-Mode-1">17 Symbolic Mode</a></li><ul><li><a href="#.1-Symbolic-Infix-Operators-1">17.1 Symbolic Infix Operators</a></li><li><a href="#.2-Symbolic-Expressions-1">17.2 Symbolic Expressions</a></li><li><a href="#.3-Quoted-Expressions-1">17.3 Quoted Expressions</a></li><li><a href="#.4-Lambda-Expressions-1">17.4 Lambda Expressions</a></li><li><a href="#.5-Symbolic-Assignment-Statements-1">17.5 Symbolic Assignment Statements</a></li><li><a href="#.6-FOR-EACH-Statement-1">17.6 FOR EACH Statement</a></li><li><a href="#.7-Symbolic-Procedures-1">17.7 Symbolic Procedures</a></li><li><a href="#.8-Standard-Lisp-Equivalent-of-Reduce-Input-1">17.8 Standard Lisp Equivalent of Reduce Input</a></li><li><a href="#.9-Communicating-with-Algebraic-Mode-1">17.9 Communicating with Algebraic Mode</a></li><li><a href="#.10-Rlisp-’88-1">17.10 Rlisp ’88</a></li><li><a href="#.11-References-1">17.11 References</a></li></ul></ul><h2><a class="nav-anchor" id=".1-Symbolic-Infix-Operators-1" href="#.1-Symbolic-Infix-Operators-1">17.1 Symbolic Infix Operators</a></h2><p>There are three binary infix operators in REDUCE intended for use in symbolic mode, namely <code>.</code> (<code>cons</code>), <code>eq</code> and <code>memq</code>. The precedence of these operators was given in another section.</p><h2><a class="nav-anchor" id=".2-Symbolic-Expressions-1" href="#.2-Symbolic-Expressions-1">17.2 Symbolic Expressions</a></h2><p>These consist of scalar variables and operators and follow the normal rules of the Lisp meta language.</p><p><em>Examples:</em></p><pre><code class="language-none">        x  
        car u . reverse v  
        simp (u+v^2)</code></pre><h2><a class="nav-anchor" id=".3-Quoted-Expressions-1" href="#.3-Quoted-Expressions-1">17.3 Quoted Expressions</a></h2><p>Because symbolic evaluation requires that each variable or expression has a value, it is necessary to add to REDUCE the concept of a quoted expression by analogy with the Lisp <code>quote</code> function. This is provided by the single quote mark <code>’</code>. For example,</p><pre><code class="language-none">’a    		represents the Lisp S-expression	(quote a)
’(a b c)   	represents the Lisp S-expression	(quote (a b c))</code></pre><p>Note, however, that strings are constants and therefore evaluate to themselves in symbolic mode. Thus, to print the string <code>~A String~</code>, one would write</p><pre><code class="language-none">        prin2 ~A String~;</code></pre><p>Within a quoted expression, identifier syntax rules are those of REDUCE. Thus <code>(A !. B)</code> is the list consisting of the three elements <code>A</code>, <code>.</code>, and <code>B</code>, whereas <code>(A . B)</code> is the dotted pair of <code>A</code> and <code>B</code>.</p><h2><a class="nav-anchor" id=".4-Lambda-Expressions-1" href="#.4-Lambda-Expressions-1">17.4 Lambda Expressions</a></h2><p><code>lambda</code> expressions provide the means for constructing Lisp <code>lambda</code> expressions in symbolic mode. They may not be used in algebraic mode.</p><p>Syntax:</p><pre><code class="language-none">⟨LAMBDAexpression⟩ ::=  LAMBDA ⟨varlist⟩⟨terminator⟩⟨statement⟩</code></pre><p>where</p><pre><code class="language-none">⟨varlist⟩ ::= (⟨variable⟩,…,⟨variable⟩)</code></pre><p>e.g.,</p><pre><code class="language-none">        lambda (x,y); car x . cdr y;</code></pre><p>is equivalent to the Lisp <code>lambda</code> expression</p><pre><code class="language-none">        (lambda (x y) (cons (car x) (cdr y)))</code></pre><p>The parentheses may be omitted in specifying the variable list if desired.</p><p><code>lambda</code> expressions may be used in symbolic mode in place of prefix operators, or as an argument of the reserved word <code>function</code>.</p><p>In those cases where a <code>lambda</code> expression is used to introduce local variables to avoid recomputation, a <code>where</code> statement can also be used. For example, the expression</p><pre><code class="language-none">        (lambda (x,y); list(car x,cdr x,car y,cdr y))  
            (reverse u,reverse v)</code></pre><p>can also be written</p><pre><code class="language-none">      {car x,cdr x,car y,cdr y} where x=reverse u,y=reverse v</code></pre><p>Where possible, <code>where</code> syntax is preferred to <code>lambda</code> syntax, since it is more natural.</p><h2><a class="nav-anchor" id=".5-Symbolic-Assignment-Statements-1" href="#.5-Symbolic-Assignment-Statements-1">17.5 Symbolic Assignment Statements</a></h2><p>In symbolic mode, if the left side of an assignment statement is a variable, a <code>setq</code> of the right-hand side to that variable occurs. If the left-hand side is an expression, it must be of the form of an array element, otherwise an error will result. For example, <code>x:=y</code> translates into <code>(SETQ X Y)</code> whereas <code>a(3) := 3</code> will be valid if <code>a</code> has been previously declared a single dimensioned array of at least four elements.</p><h2><a class="nav-anchor" id=".6-FOR-EACH-Statement-1" href="#.6-FOR-EACH-Statement-1">17.6 FOR EACH Statement</a></h2><p>The <code>for each</code> form of the <code>for</code> statement, designed for iteration down a list, is more general in symbolic mode. Its syntax is:</p><pre><code class="language-none">        FOR EACH ID:identifier {IN|ON} LST:list  
            {DO|COLLECT|JOIN|PRODUCT|SUM} EXPRN:S-expr</code></pre><p>As in algebraic mode, if the keyword <code>in</code> is used, iteration is on each element of the list. With <code>on</code>, iteration is on the whole list remaining at each point in the iteration. As a result, we have the following equivalence between each form of <code>for each</code> and the various mapping functions in Lisp:</p><pre><code class="language-none">	DO	COLLECT	JOIN
IN	MAPC	MAPCAR	MAPCAN
ON	MAP	MAPLIST	MAPCON</code></pre><p><em>Example:</em> To list each element of the list <code>(a b c)</code>:</p><pre><code class="language-none">        for each x in ’(a b c) collect list x;</code></pre><h2><a class="nav-anchor" id=".7-Symbolic-Procedures-1" href="#.7-Symbolic-Procedures-1">17.7 Symbolic Procedures</a></h2><p>All the functions described in the Standard Lisp Report are available to users in symbolic mode. Additional functions may also be defined as symbolic procedures. For example, to define the Lisp function ASSOC, the following could be used:</p><pre><code class="language-none">        symbolic procedure assoc(u,v);  
           if null v then nil  
            else if u = caar v then car v  
            else assoc(u, cdr v);</code></pre><p>If the default mode were symbolic, then <code>symbolic</code> could be omitted in the above definition. <code>macro</code>s may be defined by prefixing the keyword <code>procedure</code> by the word 	<code>macro</code>. (In fact, ordinary functions may be defined with the keyword <code>expr</code> prefixing <code>procedure</code> as was used in the Standard Lisp Report.) For example, we could define a <code>macro conscons</code> by</p><pre><code class="language-none">        symbolic macro procedure conscons l;  
           expand(cdr l,’cons);</code></pre><p>Another form of macro, the <code>smacro</code> is also available. These are described in the Standard Lisp Report. The Report also defines a function type <code>fexpr</code>. However, its use is discouraged since it is hard to implement efficiently, and most uses can be replaced by macros. At the present time, there are no <code>fexpr</code>s in the core REDUCE system.</p><h2><a class="nav-anchor" id=".8-Standard-Lisp-Equivalent-of-Reduce-Input-1" href="#.8-Standard-Lisp-Equivalent-of-Reduce-Input-1">17.8 Standard Lisp Equivalent of Reduce Input</a></h2><p>A user can obtain the Standard Lisp equivalent of his REDUCE input by turning on the switch <code>defn</code> (for definition). The system then prints the Lisp translation of his input but does not evaluate it. Normal operation is resumed when <code>defn</code> is turned off.</p><h2><a class="nav-anchor" id=".9-Communicating-with-Algebraic-Mode-1" href="#.9-Communicating-with-Algebraic-Mode-1">17.9 Communicating with Algebraic Mode</a></h2><p>Not initially supported by Reduce.jl parser, see <a href="http://www.reduce-algebra.com/manual/manualse177.html">upstream docs</a> for more information.</p><h2><a class="nav-anchor" id=".10-Rlisp-’88-1" href="#.10-Rlisp-’88-1">17.10 Rlisp ’88</a></h2><p>Rlisp ’88 is a superset of the Rlisp that has been traditionally used for the support of REDUCE. It is fully documented in the book Marti, J.B., “RLISP ’88: An Evolutionary Approach to Program Design and Reuse”, World Scientific, Singapore (1993). Rlisp ’88 adds to the traditional Rlisp the following facilities:</p><ol><li>more general versions of the looping constructs <code>for</code>, <code>repeat</code> and <code>while</code>;</li><li>support for a backquote construct;</li><li>support for active comments;</li><li>support for vectors of the form name[index];</li><li>support for simple structures;</li><li>support for records.</li></ol><p>In addition, “<code>-</code>” is a letter in Rlisp ’88. In other words, <code>A-B</code> is an identifier, not the difference of the identifiers <code>A</code> and <code>B</code>. If the latter construct is required, it is necessary to put spaces around the - character. For compatibility between the two versions of Rlisp, we recommend this convention be used in all symbolic mode programs.</p><p>To use Rlisp ’88, type <code>on rlisp88;</code>. This switches to symbolic mode with the Rlisp ’88 syntax and extensions. While in this environment, it is impossible to switch to algebraic mode, or prefix expressions by “algebraic”. However, symbolic mode programs written in Rlisp ’88 may be run in algebraic mode provided the rlisp88 package has been loaded. We also expect that many of the extensions defined in Rlisp ’88 will migrate to the basic Rlisp over time. To return to traditional Rlisp or to switch to algebraic mode, say “<code>off rlisp88;</code>”.</p><h2><a class="nav-anchor" id=".11-References-1" href="#.11-References-1">17.11 References</a></h2><p>There are a number of useful books which can give you further information about LISP. Here is a selection:</p><p>Allen, J.R., “The Anatomy of LISP”, McGraw Hill, New York, 1978.</p><p>McCarthy J., P.W. Abrahams, J. Edwards, T.P. Hart and M.I. Levin, “LISP 1.5 Programmer’s Manual”, M.I.T. Press, 1965.</p><p>Touretzky, D.S, “LISP: A Gentle Introduction to Symbolic Computation”, Harper &amp; Row, New York, 1984.</p><p>Winston, P.H. and Horn, B.K.P., “LISP”, Addison-Wesley, 1981.</p><footer><hr/><a class="previous" href="../16-packages/"><span class="direction">Previous</span><span class="title">16 User Contributed Packages</span></a><a class="next" href="../18-physics/"><span class="direction">Next</span><span class="title">18 Calculations in High Energy Physics</span></a></footer></article></body></html>
