<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>15 Procedures · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../library/">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="../acknowledgement/">Acknowledgement</a></li><li><a class="toctext" href="../01-introduction/">1 Introductory Information</a></li><li><a class="toctext" href="../02-structure/">2 Structure of Programs</a></li><li><a class="toctext" href="../03-expressions/">3 Expressions</a></li><li><a class="toctext" href="../04-lists/">4 Lists</a></li><li><a class="toctext" href="../05-statements/">5 Statements</a></li><li><a class="toctext" href="../06-commands-declarations/">6 Commands and Declarations</a></li><li><a class="toctext" href="../07-prefix-ops/">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="../08-display/">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="../09-polynomials/">9 Polynomials and Rationals</a></li><li><a class="toctext" href="../10-properties/">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="../11-substitution/">11 Substitution Commands</a></li><li><a class="toctext" href="../12-file-io/">12 File Handling Commands</a></li><li><a class="toctext" href="../13-interactive/">13 Commands for Interactive Use</a></li><li><a class="toctext" href="../14-matrix/">14 Matrix Calculations</a></li><li class="current"><a class="toctext" href>15 Procedures</a><ul class="internal"><li><a class="toctext" href="#.1-Procedure-Heading-1">15.1 Procedure Heading</a></li><li><a class="toctext" href="#.2-Procedure-Body-1">15.2 Procedure Body</a></li><li><a class="toctext" href="#.3-Matrix-valued-Procedures-1">15.3 Matrix-valued Procedures</a></li><li><a class="toctext" href="#.4-Using-LET-Inside-Procedures-1">15.4 Using LET Inside Procedures</a></li><li><a class="toctext" href="#.5-LET-Rules-as-Procedures-1">15.5 LET Rules as Procedures</a></li><li><a class="toctext" href="#.6-REMEMBER-Statement-1">15.6 REMEMBER Statement</a></li></ul></li><li><a class="toctext" href="../16-packages/">16 User Contributed Packages</a></li><li><a class="toctext" href="../17-symbolic/">17 Symbolic Mode</a></li><li><a class="toctext" href="../18-physics/">18 Calculations in High Energy Physics</a></li><li><a class="toctext" href="../19-rlisp/">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="../20-maintaining/">20 Maintaining REDUCE</a></li><li><a class="toctext" href="../A-reserved/">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="../B-bibliography/">Appendix B: Bibliography</a></li><li><a class="toctext" href="../C-changelog/">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="../">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href>15 Procedures</a></li></ul></nav><hr/><div id="topbar"><span>15 Procedures</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Procedures-1" href="#Procedures-1">15 Procedures</a></h1><p>It is often useful to name a statement for repeated use in calculations with varying parameters, or to define a complete evaluation procedure for an operator. REDUCE offers a procedural declaration for this purpose. Its general syntax is:</p><pre><code class="language-none">[⟨procedural type⟩] PROCEDURE ⟨name⟩[⟨varlist⟩];⟨statement⟩;</code></pre><p>where</p><pre><code class="language-none">⟨varlist⟩ ::= (⟨variable⟩,…,⟨variable⟩)</code></pre><p>This will be explained more fully in the following sections.</p><p>In the algebraic mode of REDUCE the <code>⟨procedural type⟩</code> can be omitted, since the default is <code>ALGEBRAIC</code>. Procedures of type <code>INTEGER</code> or <code>REAL</code> may also be used. In the former case, the system checks that the value of the procedure is an integer. At present, such checking is not done for a real procedure, although this will change in the future when a more complete type checking mechanism is installed. Users should therefore only use these types when appropriate. An empty variable list may also be omitted.</p><p>All user-defined procedures are automatically declared to be operators.</p><p>In order to allow users relatively easy access to the whole REDUCE source program, system procedures are not protected against user redefinition. If a procedure is redefined, a message</p><pre><code class="language-none">        *** &lt;procedure name&gt; REDEFINED</code></pre><p>is printed. If this occurs, and the user is not redefining his own procedure, he is well advised to rename it, and possibly start over (because he has <em>already</em> redefined some internal procedure whose correct functioning may be required for his job!)</p><p>All required procedures should be defined at the top level, since they have global scope throughout a program. In particular, an attempt to define a procedure within a procedure will cause an error to occur.</p><ul><li><a href="#Procedures-1">15 Procedures</a></li><ul><li><a href="#.1-Procedure-Heading-1">15.1 Procedure Heading</a></li><li><a href="#.2-Procedure-Body-1">15.2 Procedure Body</a></li><li><a href="#.3-Matrix-valued-Procedures-1">15.3 Matrix-valued Procedures</a></li><li><a href="#.4-Using-LET-Inside-Procedures-1">15.4 Using LET Inside Procedures</a></li><li><a href="#.5-LET-Rules-as-Procedures-1">15.5 LET Rules as Procedures</a></li><li><a href="#.6-REMEMBER-Statement-1">15.6 REMEMBER Statement</a></li></ul></ul><h2><a class="nav-anchor" id=".1-Procedure-Heading-1" href="#.1-Procedure-Heading-1">15.1 Procedure Heading</a></h2><p>Each procedure has a heading consisting of the word <code>procedure</code> (optionally preceded by the word <code>ALGEBRAIC</code>), followed by the name of the procedure to be defined, and followed by its formal parameters – the symbols that will be used in the body of the definition to illustrate what is to be done. There are three cases:</p><ol><li>No parameters. Simply follow the procedure name with a terminator (semicolon or dollar sign).</li></ol><pre><code class="language-none">        procedure abc;</code></pre><p>When such a procedure is used in an expression or command, abc(), with empty parentheses, must be written.</p><ol><li>One parameter. Enclose it in parentheses or just leave at least one space, then follow with a terminator.</li></ol><pre><code class="language-none">        procedure abc(x);</code></pre><p>or</p><pre><code class="language-none">        procedure abc x;</code></pre><ol><li>More than one parameter. Enclose them in parentheses, separated by commas, then follow with a terminator.</li></ol><pre><code class="language-none">        procedure abc(x,y,z);</code></pre><p>Referring to the last example, if later in some expression being evaluated the symbols <code>abc(u,p*q,123)</code> appear, the operations of the procedure body will be carried out as if <code>x</code> had the same value as <code>u</code> does, <code>y</code> the same value as <code>p*q</code> does, and <code>z</code> the value <code>123</code>. The values of <code>x</code>, <code>y</code>, <code>z</code>, after the procedure body operations are completed are unchanged. So, normally, are the values of <code>u</code>, <code>p</code>, <code>q</code>, and (of course) <code>123</code>. (This is technically referred to as call by value.)</p><p>The reader will have noted the word <em>normally</em> a few lines earlier. The call by value protections can be bypassed if necessary, as described elsewhere.</p><h2><a class="nav-anchor" id=".2-Procedure-Body-1" href="#.2-Procedure-Body-1">15.2 Procedure Body</a></h2><p>Following the delimiter that ends the procedure heading must be a <em>single</em> statement defining the action to be performed or the value to be delivered. A terminator must follow the statement. If it is a semicolon, the name of the procedure just defined is printed. It is not printed if a dollar sign is used.</p><p>If the result wanted is given by a formula of some kind, the body is just that formula, using the variables in the procedure heading.</p><p><em>Simple Example:</em> If <code>f(x)</code> is to mean <code>(x+5)*(x+6)/(x+7)</code>, the entire procedure definition could read</p><pre><code class="language-none">        procedure f x; (x+5)*(x+6)/(x+7);</code></pre><p>Then <code>f(10)</code> would evaluate to <code>240/17</code>, <code>f(a-6)</code> to <code>a*(a-1)/(a+1)</code>, and so on.</p><p><em>More Complicated Example:</em> Suppose we need a function <code>p(n,x)</code> that, for any positive integer <code>n</code>, is the Legendre polynomial of order <code>n</code>. We can define this operator using the textbook formula defining these functions: <span>$p_n(x) = \frac{1}{n!} \frac{d^n}{dy^n} \frac{1}{(y^2-2xy+1)^{\frac{1}{2}}} \bigg|_{y=0}$</span> Put into words, the Legendre polynomial <span>$p_n(x)$</span> is the result of substituting <span>$y = 0$</span> in the <span>$n^{th}$</span> partial derivative with respect to <span>$y$</span> of a certain fraction involving <span>$x$</span> and <span>$y$</span>, then dividing that by <span>$n!$</span>. This verbal formula can easily be written in REDUCE:</p><pre><code class="language-none">        procedure p(n,x);  
           sub(y=0,df(1/(y^2-2*x*y+1)^(1/2),y,n))  
               /(for i:=1:n product i);</code></pre><p>Having input this definition, the expression evaluation</p><pre><code class="language-none">        2p(2,w);</code></pre><p>would result in the output</p><pre><code class="language-none">           2  
        3*W  - 1 .</code></pre><p>If the desired process is best described as a series of steps, then a group or compound statement can be used.</p><p><em>Example:</em> The above Legendre polynomial example can be rewritten as a series of steps instead of a single formula as follows:</p><pre><code class="language-none">        procedure p(n,x);  
          begin scalar seed,deriv,top,fact;  
               seed:=1/(y^2 - 2*x*y +1)^(1/2);  
               deriv:=df(seed,y,n);  
               top:=sub(y=0,deriv);  
               fact:=for i:=1:n product i;  
               return top/fact  
          end;</code></pre><p>Procedures may also be defined recursively. In other words, the procedure body can include references to the procedure name itself, or to other procedures that themselves reference the given procedure. As an example, we can define the Legendre polynomial through its standard recurrence relation:</p><pre><code class="language-none">        procedure p(n,x);  
           if n&lt;0 then rederr ~Invalid argument to P(N,X)~  
            else if n=0 then 1  
            else if n=1 then x  
            else ((2*n-1)*x*p(n-1,x)-(n-1)*p(n-2,x))/n;</code></pre><p>The operator <code>rederr</code> in the above example provides for a simple error exit from an algebraic procedure (and also a block). It can take a string as argument.</p><p>It should be noted however that all the above definitions of <code>p(n,x)</code> are quite inefficient if extensive use is to be made of such polynomials, since each call effectively recomputes all lower order polynomials. It would be better to store these expressions in an array, and then use say the recurrence relation to compute only those polynomials that have not already been derived. We leave it as an exercise for the reader to write such a definition.</p><h2><a class="nav-anchor" id=".3-Matrix-valued-Procedures-1" href="#.3-Matrix-valued-Procedures-1">15.3 Matrix-valued Procedures</a></h2><p>Normally, procedures can only return scalar values. In order for a procedure to return a matrix, it has to be declared of type <code>matrixproc</code>:</p><pre><code class="language-none">        matrixproc SkewSym1 (w);  
           mat((0,-w(3,1),w(2,1)),  
               (w(3,1),0,-w(1,1)),  
               (-w(2,1), w(1,1), 0));</code></pre><p>Following this declaration, the call to <code>SkewSym1</code> can be used as a matrix, e.g.</p><pre><code class="language-none">        X := SkewSym1(mat((qx),(qy),(qz)));  
 
 
             [  0     - qz   qy  ]  
             [                   ]  
        x := [ qz      0     - qx]  
             [                   ]  
             [ - qy   qx      0  ]  
 
        X * mat((rx),(ry),(rz));  
 
 
        [ qy*rz - qz*ry  ]  
        [                ]  
        [ - qx*rz + qz*rx]  
        [                ]  
        [ qx*ry - qy*rx  ]</code></pre><h2><a class="nav-anchor" id=".4-Using-LET-Inside-Procedures-1" href="#.4-Using-LET-Inside-Procedures-1">15.4 Using LET Inside Procedures</a></h2><p>By using <code>let</code> instead of an assignment in the procedure body it is possible to bypass the call-by-value protection. If <code>x</code> is a formal parameter or local variable of the procedure (i.e. is in the heading or in a local declaration), and <code>let</code> is used instead of <code>:=</code> to make an assignment to <code>x</code>, e.g.</p><pre><code class="language-none">        let x = 123;</code></pre><p>then it is the variable that is the value of <code>x</code> that is changed. This effect also occurs with local variables defined in a block. If the value of <code>x</code> is not a variable, but a more general expression, then it is that expression that is used on the left-hand side of the <code>let</code> statement. For example, if <code>x</code> had the value <code>p*q</code>, it is as if <code>let p*q = 123</code> had been executed.</p><h2><a class="nav-anchor" id=".5-LET-Rules-as-Procedures-1" href="#.5-LET-Rules-as-Procedures-1">15.5 LET Rules as Procedures</a></h2><p>The <code>let</code> statement offers an alternative syntax and semantics for procedure definition.</p><p>In place of</p><pre><code class="language-none">        procedure abc(x,y,z); &lt;procedure body&gt;;</code></pre><p>one can write</p><pre><code class="language-none">        for all x,y,z let abc(x,y,z) = &lt;procedure body&gt;;</code></pre><p>There are several differences to note.</p><p>If the procedure body contains an assignment to one of the formal parameters, e.g.</p><pre><code class="language-none">        x := 123;</code></pre><p>in the <code>procedure</code> case it is a variable holding a copy of the first actual argument that is changed. The actual argument is not changed.</p><p>In the <code>let</code> case, the actual argument is changed. Thus, if <code>abc</code> is defined using <code>let</code>, and <code>abc(u,v,w)</code> is evaluated, the value of <code>u</code> changes to <code>123</code>. That is, the <code>let</code> form of definition allows the user to bypass the protections that are enforced by the call by value conventions of standard <code>procedure</code> definitions.</p><p><em>Example:</em> We take our earlier <code>factorial</code> procedure and write it as a <code>let</code> statement.</p><pre><code class="language-none">        for all n let factorial n =  
                    begin scalar m,s;  
                    m:=1; s:=n;  
                l1: if s=0 then return m;  
                    m:=m*s;  
                    s:=s-1;  
                    go to l1  
                end;</code></pre><p>The reader will notice that we introduced a new local variable, <code>s</code>, and set it equal to <code>n</code>. The original form of the procedure contained the statement <code>n:=n-1;</code>. If the user asked for the value of <code>factorial(5)</code> then <code>n</code> would correspond to, not just have the value of, <code>5</code>, and REDUCE would object to trying to execute the statement <code>5 := 5 - 1</code>.</p><p>If <code>pqr</code> is a procedure with no parameters,</p><pre><code class="language-none">        procedure pqr;  
           &lt;procedure body&gt;;</code></pre><p>it can be written as a <code>let</code> statement quite simply:</p><pre><code class="language-none">        let pqr = &lt;procedure body&gt;;</code></pre><p>To call procedure <code>pqr</code>, if defined in the latter form, the empty parentheses would not be used: use <code>pqr</code> not <code>pqr()</code> where a call on the procedure is needed.</p><p>The two notations for a procedure with no arguments can be combined. <code>pqr</code> can be defined in the standard <code>procedure</code> form. Then a <code>let</code> statement</p><pre><code class="language-none">        let pqr = pqr();</code></pre><p>would allow a user to use <code>pqr</code> instead of <code>pqr()</code> in calling the procedure.</p><p>A feature available with <code>let</code>-defined procedures and not with procedures defined in the standard way is the possibility of defining partial functions.</p><pre><code class="language-none">    for all x such that numberp x let uvw(x)=&lt;procedure body&gt;;</code></pre><p>Now <code>uvw</code> of an integer would be calculated as prescribed by the procedure body, while <code>uvw</code> of a general argument, such as <code>z</code> or <code>p+q</code> (assuming these evaluate to themselves) would simply stay <code>uvw(z)</code> or <code>uvw(p+q)</code> as the case may be.</p><h2><a class="nav-anchor" id=".6-REMEMBER-Statement-1" href="#.6-REMEMBER-Statement-1">15.6 REMEMBER Statement</a></h2><p>Setting the remember option for an algebraic procedure by</p><pre><code class="language-none">     REMEMBER (PROCNAME:procedure);</code></pre><p>saves all intermediate results of such procedure evaluations, including recursive calls. Subsequent calls to the procedure can then be determined from the saved results, and thus the number of evaluations (or the complexity) can be reduced. This mode of evalation costs extra memory, of course. In addition, the procedure must be free of side–effects.</p><p>The following examples show the effect of the remember statement on two well–known examples.</p><pre><code class="language-none">procedure H(n);      % Hofstadter’s function  
 if numberp n then  
 &lt;&lt; cnn := cnn +1;   % counts the calls  
 if n &lt; 3 then 1 else H(n-H(n-1))+H(n-H(n-2))&gt;&gt;;  
 
remember h;  
 
&lt;&lt; cnn := 0; H(100); cnn&gt;&gt;;  
 
100  
 
% H has been called 100 times only.  
 
procedure A(m,n);    % Ackermann function  
 
 if m=0 then n+1 else  
  if n=0 then A(m-1,1) else  
  A(m-1,A(m,n-1));  
 
remember a;  
 
A(3,3);  </code></pre><footer><hr/><a class="previous" href="../14-matrix/"><span class="direction">Previous</span><span class="title">14 Matrix Calculations</span></a><a class="next" href="../16-packages/"><span class="direction">Next</span><span class="title">16 User Contributed Packages</span></a></footer></article></body></html>
