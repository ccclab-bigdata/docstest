<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · PowerModelsAnnex.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerModelsAnnex.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">PowerModelsAnnex.ACPPowerModel</code></pre><pre><code class="language-none">PowerModelsAnnex.APIACPPowerModel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.CostCurve" href="#PowerModelsAnnex.CostCurve"><code>PowerModelsAnnex.CostCurve</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type CostCurve end</code></pre><p>Abstract type for cost curves. We have two types, one being PolynomialCost, the other PWLCost. These types are introduced in order to deal with the possible formats in which cost curves can be specified and to enforce type (and unit) consistency.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.DCPPowerModel</code></pre><pre><code class="language-none">PowerModelsAnnex.LOGGER</code></pre><pre><code class="language-none">PowerModelsAnnex.NLACRForm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.NLACRPowerModel" href="#PowerModelsAnnex.NLACRPowerModel"><code>PowerModelsAnnex.NLACRPowerModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>default NLACRForm constructor</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.NLForms</code></pre><pre><code class="language-none">PowerModelsAnnex.NLSOCWROAForm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.NLSOCWRPowerModel" href="#PowerModelsAnnex.NLSOCWRPowerModel"><code>PowerModelsAnnex.NLSOCWRPowerModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>default NLSOCWROAForm constructor</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.Network" href="#PowerModelsAnnex.Network"><code>PowerModelsAnnex.Network</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Network</code></pre><p>Basic type for storing a network as a group of DataFrames plus a PowerModels network case.</p><ul><li><p>Constructors:</p><p>Network(; bus, gen, pi<em>load, ps</em>load, line, cost<em>gen, cost</em>load, pmc)</p></li></ul><p>Create a <code>Network</code> containing the specified dataframes. Specifying a PowerModel case <code>pmc</code> will solely store the case inside the <code>Network</code>, without using it to populate the dataframes. If that is desired, another constructor should be used.</p><pre><code class="language-none">Network(pmc::Dict{String, Any})</code></pre><p>Create a <code>Network</code> from a PowerModel network.</p><pre><code class="language-none">Network(path::AbstractString)</code></pre><p>Create a <code>Network</code> from a Matpower case file.</p><pre><code class="language-none">Network(case::Symbol)</code></pre><p>Create a <code>Network</code> from a case. All cases are stored inside the <code>case_library</code> folder. In order to list all valid case names, use <code>PowerModelsAPI.list_cases()</code>.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.PMs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.PWLCost" href="#PowerModelsAnnex.PWLCost"><code>PowerModelsAnnex.PWLCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PWLCost &lt;: CostCurve</code></pre><p>The cost function as a piecewise linear function of the MWhr.</p><p><strong>Fields</strong></p><ul><li><code>cost::AbstractVector</code>: the vector of the value of the cost function at the extrema</li></ul><p>of the segments</p><ul><li><code>mw::AbstractVector</code>: the vector of the extrema of the segments in which</li></ul><p>the range for power generation is split.</p><p><strong>Constructor</strong></p><p>For convenience, and to avoid errors due to the order, the default constructor uses kwargs:</p><pre><code class="language-none">    PWLCost(mw=mw, cost=cost)</code></pre><p><strong>NOTE:</strong></p><p>Units are explicitly given.</p><p><strong>TODO:</strong></p><p>Make the dimensions and units parameters of the type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.PolynomialCost" href="#PowerModelsAnnex.PolynomialCost"><code>PowerModelsAnnex.PolynomialCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>PolynomialCost{T&lt;:Number} &lt;: CostCurve</p><p><strong>Field</strong></p><ul><li><code>coefficients::AbstractVector{T}</code></li></ul><p>The <code>coefficients</code> field is a vector that contains the numerical values of the coefficients of the monomials of the polynomial cost function. If <code>n=length(coefficients)</code>, the cost is a polynomial of degree n - 1. The first element of the array is the coefficient of the monomial of degree n - 1, the last is the coefficient of the monomial of degree 0.</p><p><strong>NOTE:</strong></p><p>Dimensions are not enforced as the coefficients have all different dimension (the element i of a vector of length n has dimensions USD/(MWhr)^(n-i))</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.PowerModelsAnnex</code></pre><pre><code class="language-none">PowerModelsAnnex.QCWRPowerModel</code></pre><pre><code class="language-none">PowerModelsAnnex.QCWRTriNoLinkForm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.QCWRTriNoLinkPowerModel" href="#PowerModelsAnnex.QCWRTriNoLinkPowerModel"><code>PowerModelsAnnex.QCWRTriNoLinkPowerModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>default QC trilinear without linking constraint model constructor</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.SOCWROAForm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.SOCWROAPowerModel" href="#PowerModelsAnnex.SOCWROAPowerModel"><code>PowerModelsAnnex.SOCWROAPowerModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>default SOCWROA constructor</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.SOCWRPowerModel</code></pre><pre><code class="language-none">PowerModelsAnnex._stripunits!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_bus!" href="#PowerModelsAnnex.add_bus!"><code>PowerModelsAnnex.add_bus!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_bus!(
    net::Network;
    bus_type::Int=0,
    base_kv::Union{Missings.Missing,&lt;:Number}=missing,
    name::AbstractString=&quot;none&quot;,
    element_id::Int=-1,
    voltage::Union{Missings.Missing,&lt;:Number}=missing,
    volt_max::Union{Missings.Missing,&lt;:Number}=missing,
    volt_min::Union{Missings.Missing,&lt;:Number}=missing,
    coords::Union{Missings.Missing,Tuple{Float64,Float64}}=missing,
)</code></pre><p>Add a new bus to Network <code>net</code>. If <code>name</code> and <code>element_id</code> are not provided, reasonable values will be automatically chosen.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_cost_gen!" href="#PowerModelsAnnex.add_cost_gen!"><code>PowerModelsAnnex.add_cost_gen!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_cost_gen!(
    net::Network;
    coeffs::Vector{&lt;:Real}=Vector{Float64}(),
    gen_id::Union{Missings.Missing,Int}= missing,
    element_id::Int= -1,
    model::Int=2,
    ncost::Int=0,
)</code></pre><p>Add new generator cost to a Network <code>net</code>. If <code>element_id</code> is not specified, a reasonable value will be adopted. This method applies to polynomial costs.</p></div></div><div><div><pre><code class="language-none">add_cost_gen!(
    net::Network;
    pwl_cost::PWLCost;
    gen_id::Union{NAtype,Int}= NA,
    element_id::Int= -1
    model::Int=1,
    ncost::Int=0,
)</code></pre><p>Add new generator cost to a Network <code>net</code>. If <code>element_id</code> is not specified, a reasonable value will be adopted. This method applies to piecewise linear costs (1).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_cost_load!" href="#PowerModelsAnnex.add_cost_load!"><code>PowerModelsAnnex.add_cost_load!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_cost_load!(
    net::Network;
    coeffs::Vector{&lt;:Real}=Vector{Float64}(),
    load_id::Union{Missings.Missing,Int}= missing,
    element_id::Int= -1,
    model::Int=2,
    ncost::Int=0,
)</code></pre><p>Add new load cost to a Network <code>net</code>. If <code>element_id</code> is not specified, a reasonable value will be adopted. This method applies to polynomial costs.</p></div></div><div><div><pre><code class="language-none">add_cost_load!(
    net::Network;
    coeffs::Tuple{Vector}=([], []),
    load_id::Union{NAtype,Int}= NA,
    element_id::Int= -1,
    model::Int=1,
    ncost::Int=0,
)</code></pre><p>Add new load cost to a Network <code>net</code>. If <code>element_id</code> is not specified, a reasonable value will be adopted. This method applies to piecewise linear costs (1).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_gen!" href="#PowerModelsAnnex.add_gen!"><code>PowerModelsAnnex.add_gen!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_gen!(
    net::Network;
    element_id::Int=-1,
    bus::Union{Missings.Missing,Int}=missing,
    gen_p::Union{Missings.Missing,&lt;:Number}=missing,
    p_max::Union{Missings.Missing,&lt;:Number}=missing,
    p_min::Union{Missings.Missing,&lt;:Number}=missing,
    gen_q::Union{Missings.Missing,&lt;:Number}=missing,
    q_max::Union{Missings.Missing,&lt;:Number}=missing,
    q_min::Union{Missings.Missing,&lt;:Number}=missing,
    cost::Union{Missings.Missing,Int}=missing,
    startup_cost::Union{Missings.Missing,&lt;:Number}=missing,
    status::Int= 1,
    ramp::Union{Missings.Missing,&lt;:Number}=missing,
)</code></pre><p>Add a new generator to a Network <code>net</code>. In case <code>element_id</code> and <code>status</code> are not provided, a reasonable value will be chosen for <code>element_id</code>, while <code>status</code> wil be assumed as <code>1</code> (the element is active).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_line!" href="#PowerModelsAnnex.add_line!"><code>PowerModelsAnnex.add_line!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_line!(
    net::Network;
    rate_a::Union{Missings.Missing,&lt;:Number}= missing,
    rate_b::Union{Missings.Missing,&lt;:Number}= missing,
    rate_c::Union{Missings.Missing,&lt;:Number}= missing,
    transformer::Bool= false,
    from_bus::Union{Missings.Missing,Int}= missing,
    to_bus::Union{Missings.Missing,Int}= missing,
    status::Int=1,
    element_id::Int=-1,
    resistance::Union{Missings.Missing,&lt;:Number}= missing,
    reactance::Union{Missings.Missing,&lt;:Number}= missing,
    susceptance::Union{Missings.Missing,&lt;:Number}= missing,
    ang_min::Float64=-1.0,
    ang_max::Float64=1.0,
    p_to::Float64=0.0,
    p_from::Float64=0.0,
    q_to::Float64=0.0,
    q_from::Float64=0.0,
)</code></pre><p>Add a new line to a Network <code>net</code>. In case <code>element_id</code>, <code>transformer</code> and <code>status</code> are not provided, a reasonable value will be chosen for <code>element_id</code>, while <code>status</code> wil be assumed as <code>1</code> (the element is active) and <code>transformer</code> will be assumed as <code>false</code> (the line is not a transformer).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_load!" href="#PowerModelsAnnex.add_load!"><code>PowerModelsAnnex.add_load!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_load!(
    net::Network;
    element_id::Int=-1,
    bus::Union{Missings.Missing,Int}=missing,
    load_p::Union{Missings.Missing,&lt;:Number}=missing,
    load_q::Union{Missings.Missing,&lt;:Number}=missing,
    status::Int=1,
)</code></pre><p>Add a new price insensitive load to a Network <code>net</code>. In case <code>element_id</code> and <code>status</code> are not provided, a reasonable value will be chosen for <code>element_id</code>, while <code>status</code> wil be assumed as <code>1</code> (the element is active).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_load_demand_setpoint" href="#PowerModelsAnnex.add_load_demand_setpoint"><code>PowerModelsAnnex.add_load_demand_setpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_pi_load!" href="#PowerModelsAnnex.add_pi_load!"><code>PowerModelsAnnex.add_pi_load!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_pi_load!(
    net::Network;
    element_id::Int=-1,
    bus::Union{Missings.Missing,Int}=missing,
    load_p::Union{Missings.Missing,&lt;:Number}=missing,
    load_q::Union{Missings.Missing,&lt;:Number}=missing,
    status::Int=1,
)</code></pre><p>Add a new price insensitive load to a Network <code>net</code>. In case <code>element_id</code> and <code>status</code> are not provided, a reasonable value will be chosen for <code>element_id</code>, while <code>status</code> wil be assumed as <code>1</code> (the element is active).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.add_ps_load!" href="#PowerModelsAnnex.add_ps_load!"><code>PowerModelsAnnex.add_ps_load!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_ps_load!(
    net::Network;
    element_id::Int=-1,
    bus::Union{Missings.Missing,Int}=missing,
    load::Union{Missings.Missing,&lt;:Number}=missing,
    load_max::Union{Missings.Missing,&lt;:Number}=missing,
    cost::Union{Missings.Missing,Int}=missing,
    status::Int=1,
)</code></pre><p>Add a new price sensitive load to a Network <code>net</code>. In case <code>element_id</code> and <code>status</code> are not provided, a reasonable value will be chosen for <code>element_id</code>, while <code>status</code> wil be assumed as <code>1</code> (the element is active).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.applyunits!" href="#PowerModelsAnnex.applyunits!"><code>PowerModelsAnnex.applyunits!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">applyunits!(net::Network)</code></pre><p>This function annotates the Network structure with physical unit annotations. For example, for the load column, it is originally in Float64. This function will convert it to a type representing the units u&quot;MWh&quot;). See PowerSystemsUnits.jl for more information. We are assuming energy units as opposed to power units.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.bounds_tighten_voltage" href="#PowerModelsAnnex.bounds_tighten_voltage"><code>PowerModelsAnnex.bounds_tighten_voltage</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.build_df_from_pmc" href="#PowerModelsAnnex.build_df_from_pmc"><code>PowerModelsAnnex.build_df_from_pmc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_df_from_pmc(columns::Dict{Symbol, &lt;: Any}, block::Dict{String,Any})</code></pre><p>Return a DataFrame as built from a PowerModels case dictionary. <code>columns</code> specifies which quantites to grab and from where. <code>block</code> corresponds to a dictionary from a PowerModels case.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.build_pmc!" href="#PowerModelsAnnex.build_pmc!"><code>PowerModelsAnnex.build_pmc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_pmc!(net::Network)</code></pre><p>Read information contained in <code>net</code> and uses it to populate <code>net.pmc</code>. This will overwrite any information previously contained in there.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.bus</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.bus_columns" href="#PowerModelsAnnex.bus_columns"><code>PowerModelsAnnex.bus_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">bus_columns</code></pre><p>:element<em>id -&gt; id number of the bus :name -&gt;  name of the bus :voltage -&gt; bus operating voltage :volt</em>max -&gt; maximum bus voltage :volt<em>min -&gt; minimum bus voltage :bus</em>type -&gt; Bus type :base_kv -&gt; Base voltage :coords -&gt; Bus geocoordinates in latitude and longitude :zone -&gt; Bus zone :area -&gt; Bus Area</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.buses</code></pre><pre><code class="language-none">PowerModelsAnnex.coefficients</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.constraint_kcl_shunt_scaled" href="#PowerModelsAnnex.constraint_kcl_shunt_scaled"><code>PowerModelsAnnex.constraint_kcl_shunt_scaled</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.constraint_thermal_limit_from" href="#PowerModelsAnnex.constraint_thermal_limit_from"><code>PowerModelsAnnex.constraint_thermal_limit_from</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.constraint_thermal_limit_to" href="#PowerModelsAnnex.constraint_thermal_limit_to"><code>PowerModelsAnnex.constraint_thermal_limit_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.converged" href="#PowerModelsAnnex.converged"><code>PowerModelsAnnex.converged</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">converged(net::Network)</code></pre><p>Return <code>true</code> if an OPF was ran and successfully converged, <code>false</code> otherwise (inclunding if no OPF was ran).</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.cost</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.cost_columns" href="#PowerModelsAnnex.cost_columns"><code>PowerModelsAnnex.cost_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">cost_columns</code></pre><p>:element_id -&gt; ID number of the cost (defaults to -1) :coeffs -&gt; coefficients of the cost function (defaults to <code>:cost</code>) :model -&gt; Piecewise linear (1) or polynomial (2), defaults to polynomial (2) :ncost -&gt; Number of coefficients in the polynomial cost or number of pairs (MWh, USD) in piecewise linear costs.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.cost_gen</code></pre><pre><code class="language-none">PowerModelsAnnex.cost_load</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.costcurve2pmc" href="#PowerModelsAnnex.costcurve2pmc"><code>PowerModelsAnnex.costcurve2pmc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">costcurve2pmc(c)</code></pre><p>Convert the CostCurve types into PowerModels costs</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.costs</code></pre><pre><code class="language-none">PowerModelsAnnex.degree</code></pre><pre><code class="language-none">PowerModelsAnnex.eval</code></pre><pre><code class="language-none">PowerModelsAnnex.gen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.gen_columns" href="#PowerModelsAnnex.gen_columns"><code>PowerModelsAnnex.gen_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">gen_columns</code></pre><p>:element<em>id -&gt; generator ID number :bus -&gt; ID of the bus where the generator is placed :gen</em>p -&gt; active power generated :p<em>max -&gt; maximum active power :p</em>min -&gt; minimum active power :gen<em>q -&gt; reactive power generated :q</em>max -&gt; maximum reactive power :q<em>min -&gt; minimum reactive power :cost -&gt; ID number of the associated cost :startup</em>cost -&gt; startup cost :status -&gt; 0=IDLE, 1=ACTIVE :ramp -&gt; 10-minute ramping constraint</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.gen_cost</code></pre><pre><code class="language-none">PowerModelsAnnex.generator</code></pre><pre><code class="language-none">PowerModelsAnnex.generators</code></pre><pre><code class="language-none">PowerModelsAnnex.gens</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.get_api_solution" href="#PowerModelsAnnex.get_api_solution"><code>PowerModelsAnnex.get_api_solution</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><pre><code class="language-none">PowerModelsAnnex.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.infeasible" href="#PowerModelsAnnex.infeasible"><code>PowerModelsAnnex.infeasible</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">infeasible(net::Network)</code></pre><p>Check if the total demand can be satisfied by the generators. Returns <code>true</code> in case no solution is possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.is_convex" href="#PowerModelsAnnex.is_convex"><code>PowerModelsAnnex.is_convex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_convex(mw::AbstractVector{&lt;:Number}, cost::AbstractVector{&lt;:Number})</code></pre><p>Determines if the data used for a PWL curve are defining a convex curve.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.line</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.line_columns" href="#PowerModelsAnnex.line_columns"><code>PowerModelsAnnex.line_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">line_columns</code></pre><p>:element<em>id -&gt; ID number of the line :rate</em>a -&gt; maximum current under rate A :rate<em>b -&gt; maximum current under rate B :rate</em>c -&gt; maximum current under rate C :transformer -&gt; is transformer? :from<em>bus -&gt; first end-bus ID :to</em>bus -&gt; second end-bus ID :status -&gt; 0=IDLE, 1=ACTIVE :resistance -&gt; line electric resistance :reactance -&gt; line reactance :susceptance -&gt; line susceptance :ang<em>min -&gt; minimum voltage angle difference :ang</em>max -&gt; maximum voltage angle difference :g<em>to -&gt; line conductance (to-node) :g</em>fr -&gt; line conductance (from-node) :b<em>to -&gt; line charging susceptance (to-node) :b</em>fr -&gt; line charging susceptance (from-node)</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.lines</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.lmps" href="#PowerModelsAnnex.lmps"><code>PowerModelsAnnex.lmps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lmps(net::Network)</code></pre><p>Return a DataFrame with the LMPs for all buses after an OPF run. The prices are extracted from the Lagrange multipliers for the Kirchhoff&#39;s conservation law. Due to conventions in PowerModels.jl, the LMP are the negative of these Lagrange multipliers.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.load</code></pre><pre><code class="language-none">PowerModelsAnnex.load_cost</code></pre><pre><code class="language-none">PowerModelsAnnex.loads</code></pre><pre><code class="language-none">PowerModelsAnnex.matpower2pmc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.max_load_percent!" href="#PowerModelsAnnex.max_load_percent!"><code>PowerModelsAnnex.max_load_percent!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">max_load_percent!(net::Network, maxload::Real)</code></pre><p>Scale line ratings such that the maximum load is equal to <code>maxload</code>% of the original value.</p></div></div><div><div><pre><code class="language-none">max_load_percent!(pmc::Dict, maxload::Real)</code></pre><p>Scale line ratings such that the maximum load is equal to <code>maxload</code>% of the original value.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.mws</code></pre><pre><code class="language-none">PowerModelsAnnex.n_cost</code></pre><pre><code class="language-none">PowerModelsAnnex.n_segments</code></pre><pre><code class="language-none">PowerModelsAnnex.net2pmc_branch</code></pre><pre><code class="language-none">PowerModelsAnnex.net2pmc_bus</code></pre><pre><code class="language-none">PowerModelsAnnex.net2pmc_gen</code></pre><pre><code class="language-none">PowerModelsAnnex.net2pmc_load</code></pre><pre><code class="language-none">PowerModelsAnnex.net2pmc_ps_load</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.network2pmc" href="#PowerModelsAnnex.network2pmc"><code>PowerModelsAnnex.network2pmc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">network2pmc(net::Network)</code></pre><p>Return a PowerModels network model (dictionary) based on the information contained within a Network <code>net</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.objective_max_loading" href="#PowerModelsAnnex.objective_max_loading"><code>PowerModelsAnnex.objective_max_loading</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>objective: Max. load_factor</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.objective_max_loading_gen_output" href="#PowerModelsAnnex.objective_max_loading_gen_output"><code>PowerModelsAnnex.objective_max_loading_gen_output</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.objective_max_loading_voltage_norm" href="#PowerModelsAnnex.objective_max_loading_voltage_norm"><code>PowerModelsAnnex.objective_max_loading_voltage_norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><pre><code class="language-none">PowerModelsAnnex.pi_load</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.pi_load_columns" href="#PowerModelsAnnex.pi_load_columns"><code>PowerModelsAnnex.pi_load_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">pi_load_columns</code></pre><p>:element<em>id -&gt; ID number of the load :bus -&gt; ID number of the bus where the load is placed :load</em>p -&gt; active load value :load_q -&gt; reactive load value :status -&gt; 0=IDLE, 1=ACTIVE</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.pmc</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_ac_opf" href="#PowerModelsAnnex.post_ac_opf"><code>PowerModelsAnnex.post_ac_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an AC-OPF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_ac_pf" href="#PowerModelsAnnex.post_ac_pf"><code>PowerModelsAnnex.post_ac_pf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an AC-PF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_api_opf" href="#PowerModelsAnnex.post_api_opf"><code>PowerModelsAnnex.post_api_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_dc_opf" href="#PowerModelsAnnex.post_dc_opf"><code>PowerModelsAnnex.post_dc_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an DC-OPF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_dc_pf" href="#PowerModelsAnnex.post_dc_pf"><code>PowerModelsAnnex.post_dc_pf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an DC-PF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_qc_opf" href="#PowerModelsAnnex.post_qc_opf"><code>PowerModelsAnnex.post_qc_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an QC-OPF formulation of the given data and returns the JuMP model Implementation provided by @sidhant172</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_sad_opf" href="#PowerModelsAnnex.post_sad_opf"><code>PowerModelsAnnex.post_sad_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_soc_opf" href="#PowerModelsAnnex.post_soc_opf"><code>PowerModelsAnnex.post_soc_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an SOC-OPF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.post_soc_pf" href="#PowerModelsAnnex.post_soc_pf"><code>PowerModelsAnnex.post_soc_pf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a JuMP model and a PowerModels network data structure,  Builds an SOC-PF formulation of the given data and returns the JuMP model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.prices" href="#PowerModelsAnnex.prices"><code>PowerModelsAnnex.prices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prices(pwl_cost::PWLCost)</code></pre><p>This function returns the price for each block of the PWL curve, defined as the slopes of the linear function for each block.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.ps_load</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.ps_load_columns" href="#PowerModelsAnnex.ps_load_columns"><code>PowerModelsAnnex.ps_load_columns</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">ps_load_columns</code></pre><p>:element<em>id -&gt; ID number of the load :bus -&gt; ID number of the bus where the load is placed :load -&gt; active load value :load</em>max -&gt; maximum active load :cost -&gt; ID number of the associated cost :status -&gt; 0=IDLE, 1=ACTIVE</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.res_gen" href="#PowerModelsAnnex.res_gen"><code>PowerModelsAnnex.res_gen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">res_gen(net::Network)</code></pre><p>Return a DataFrame with the power supplied by each generator as a solution to an OPF.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.results</code></pre><pre><code class="language-none">PowerModelsAnnex.run_ac_opf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.run_api_opf" href="#PowerModelsAnnex.run_api_opf"><code>PowerModelsAnnex.run_api_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><pre><code class="language-none">PowerModelsAnnex.run_dc_opf</code></pre><pre><code class="language-none">PowerModelsAnnex.run_opf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.run_sad_opf" href="#PowerModelsAnnex.run_sad_opf"><code>PowerModelsAnnex.run_sad_opf</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.shadow_prices_lines" href="#PowerModelsAnnex.shadow_prices_lines"><code>PowerModelsAnnex.shadow_prices_lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shadow_prices_lines(net::Network)</code></pre><p>Return a DataFrame containing the shadow prices for all lines after an OPF run.</p></div></div></section><pre><code class="language-none">PowerModelsAnnex.stripunits!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.upperbound_negative_active_generation" href="#PowerModelsAnnex.upperbound_negative_active_generation"><code>PowerModelsAnnex.upperbound_negative_active_generation</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerModelsAnnex.variable_load_factor" href="#PowerModelsAnnex.variable_load_factor"><code>PowerModelsAnnex.variable_load_factor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>variable: load_factor &gt;= 1.0</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
