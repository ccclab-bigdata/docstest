var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#DASKR-1",
    "page": "Readme",
    "title": "DASKR",
    "category": "section",
    "text": "(Image: Join the chat at https://gitter.im/JuliaDiffEq/Lobby)(Image: Build Status) (Image: Coverage Status) (Image: codecov.io)(Image: DASKR) (Image: DASKR)A solver for differential algebraic equations (DAE). This wraps the original DASKR FORTRAN solver. DASKR is a derivative of the DASSL solver with root finding. An interface to the JuliaDiffEq common interface is also provided."
},

{
    "location": "#Common-Interface-Example-1",
    "page": "Readme",
    "title": "Common Interface Example",
    "category": "section",
    "text": "using DASKR\nu0 = [1.0, 0, 0]\ndu0 = [-0.04, 0.04, 0.0]\ntspan = (0.0,100000.0)\n\nfunction resrob(r,yp,y,p,tres)\n    r[1]  = -0.04*y[1] + 1.0e4*y[2]*y[3]\n    r[2]  = -r[1] - 3.0e7*y[2]*y[2] - yp[2]\n    r[1] -=  yp[1]\n    r[3]  =  y[1] + y[2] + y[3] - 1.0\nend\n\nprob = DAEProblem(resrob,u0,du0,tspan)    \nsol = solve(prob, daskr())The options for solve are documented at the common solver options page. For more details, see the ODE Tutorial and the DAE Tutorial pages from DifferentialEquations.jl."
},

{
    "location": "autodocs/#DASKR.common_jac_c",
    "page": "Docstrings",
    "title": "DASKR.common_jac_c",
    "category": "function",
    "text": "Return a C-style callback for the Jacobian function fun. Suitable for use with unsafe_solve. For a common interface passed function.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#DASKR.common_res_c",
    "page": "Docstrings",
    "title": "DASKR.common_res_c",
    "category": "function",
    "text": "Return a C-style callback for the residual function fun. Suitable for use with unsafe_solve.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#DASKR.jac_c",
    "page": "Docstrings",
    "title": "DASKR.jac_c",
    "category": "function",
    "text": "Return a C-style callback for the Jacobian function fun. Suitable for use with unsafe_solve.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#DASKR.res_c",
    "page": "Docstrings",
    "title": "DASKR.res_c",
    "category": "function",
    "text": "Return a C-style callback for the residual function fun. Suitable for use with unsafe_solve.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#DASKR.rt_c",
    "page": "Docstrings",
    "title": "DASKR.rt_c",
    "category": "function",
    "text": "Return a C-style callback for the event-handling function fun. Suitable for use with unsafe_solve.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#DASKR.unsafe_solve",
    "page": "Docstrings",
    "title": "DASKR.unsafe_solve",
    "category": "function",
    "text": "Direct, raw access to the DASKR solver.\n\n`unsafe_solve(callback, N, t, y, yp,\n              tout, info, rtol, atol,\n              idid, rwork, lrw, iwork,\n              liw, rpar, ipar, jac, psol,\n              rt, nrt, jroot)`\n\nThe following shows the detailed explanations from the comments in the FORTRAN source.\n\nC      IMPLICIT DOUBLE PRECISION(A-H,O-Z)\nC      INTEGER NEQ, INFO(N), IDID, LRW, LIW, IWORK(LIW), IPAR(*)\nC      DOUBLE PRECISION T, Y(*), YPRIME(*), TOUT, RTOL(*), ATOL(*),\nC         RWORK(LRW), RPAR(*)\nC      EXTERNAL RES, JAC, PSOL, RT\nC\nC      CALL DDASKR (RES, NEQ, T, Y, YPRIME, TOUT, INFO, RTOL, ATOL,\nC     *             IDID, RWORK, LRW, IWORK, LIW, RPAR, IPAR, JAC, PSOL,\nC     *             RT, NRT, JROOT)\nC\nC  Quantities which may be altered by the code are:\nC     T, Y(*), YPRIME(*), INFO(1), RTOL, ATOL, IDID, RWORK(*), IWORK(*)\nC\nC\nC *Arguments:\nC\nC  RES:EXT          This is the name of a subroutine which you\nC                   provide to define the residual function G(t,y,y\')\nC                   of the differential/algebraic system.\nC\nC  NEQ:IN           This is the number of equations in the system.\nC\nC  T:INOUT          This is the current value of the independent\nC                   variable.\nC\nC  Y(*):INOUT       This array contains the solution components at T.\nC\nC  YPRIME(*):INOUT  This array contains the derivatives of the solution\nC                   components at T.\nC\nC  TOUT:IN          This is a point at which a solution is desired.\nC\nC  INFO(N):IN       This is an integer array used to communicate details\nC                   of how the solution is to be carried out, such as\nC                   tolerance type, matrix structure, step size and\nC                   order limits, and choice of nonlinear system method.\nC                   N must be at least 20.\nC\nC  RTOL,ATOL:INOUT  These quantities represent absolute and relative\nC                   error tolerances (on local error) which you provide\nC                   to indicate how accurately you wish the solution to\nC                   be computed.  You may choose them to be both scalars\nC                   or else both arrays of length NEQ.\nC\nC  IDID:OUT         This integer scalar is an indicator reporting what\nC                   the code did.  You must monitor this variable to\nC                   decide what action to take next.\nC\nC  RWORK:WORK       A real work array of length LRW which provides the\nC                   code with needed storage space.\nC\nC  LRW:IN           The length of RWORK.\nC\nC  IWORK:WORK       An integer work array of length LIW which provides\nC                   the code with needed storage space.\nC\nC  LIW:IN           The length of IWORK.\nC\nC  RPAR,IPAR:IN     These are real and integer parameter arrays which\nC                   you can use for communication between your calling\nC                   program and the RES, JAC, and PSOL subroutines.\nC\nC  JAC:EXT          This is the name of a subroutine which you may\nC                   provide (optionally) for calculating Jacobian\nC                   (partial derivative) data involved in solving linear\nC                   systems within DDASKR.\nC\nC  PSOL:EXT         This is the name of a subroutine which you must\nC                   provide for solving linear systems if you selected\nC                   a Krylov method.  The purpose of PSOL is to solve\nC                   linear systems involving a left preconditioner P.\nC\nC  RT:EXT           This is the name of the subroutine for defining\nC                   constraint functions Ri(T,Y,Y\')) whose roots are\nC                   desired during the integration.  This name must be\nC                   declared external in the calling program.\nC\nC  NRT:IN           This is the number of constraint functions\nC                   Ri(T,Y,Y\').  If there are no constraints, set\nC                   NRT = 0, and pass a dummy name for RT.\nC\nC  JROOT:OUT        This is an integer array of length NRT for output\nC                   of root information.\nC\nC *Overview\nC\nC  The DDASKR solver uses the backward differentiation formulas of\nC  orders one through five to solve a system of the form G(t,y,y\') = 0\nC  for y = Y and y\' = YPRIME.  Values for Y and YPRIME at the initial\nC  time must be given as input.  These values should be consistent,\nC  that is, if T, Y, YPRIME are the given initial values, they should\nC  satisfy G(T,Y,YPRIME) = 0.  However, if consistent values are not\nC  known, in many cases you can have DDASKR solve for them -- see\nC  INFO(11). (This and other options are described in detail below.)\nC\nC  Normally, DDASKR solves the system from T to TOUT.  It is easy to\nC  continue the solution to get results at additional TOUT.  This is\nC  the interval mode of operation.  Intermediate results can also be\nC  obtained easily by specifying INFO(3).\nC\nC  On each step taken by DDASKR, a sequence of nonlinear algebraic\nC  systems arises.  These are solved by one of two types of\nC  methods:\nC    * a Newton iteration with a direct method for the linear\nC      systems involved (INFO(12) = 0), or\nC    * a Newton iteration with a preconditioned Krylov iterative\nC      method for the linear systems involved (INFO(12) = 1).\nC\nC  The direct method choices are dense and band matrix solvers,\nC  with either a user-supplied or an internal difference quotient\nC  Jacobian matrix, as specified by INFO(5) and INFO(6).\nC  In the band case, INFO(6) = 1, you must supply half-bandwidths\nC  in IWORK(1) and IWORK(2).\nC\nC  The Krylov method is the Generalized Minimum Residual (GMRES)\nC  method, in either complete or incomplete form, and with\nC  scaling and preconditioning.  The method is implemented\nC  in an algorithm called SPIGMR.  Certain options in the Krylov\nC  method case are specified by INFO(13) and INFO(15).\nC\nC  If the Krylov method is chosen, you may supply a pair of routines,\nC  JAC and PSOL, to apply preconditioning to the linear system.\nC  If the system is A*x = b, the matrix is A = dG/dY + CJ*dG/dYPRIME\nC  (of order NEQ).  This system can then be preconditioned in the form\nC  (P-inverse)*A*x = (P-inverse)*b, with left preconditioner P.\nC  (DDASKR does not allow right preconditioning.)\nC  Then the Krylov method is applied to this altered, but equivalent,\nC  linear system, hopefully with much better performance than without\nC  preconditioning.  (In addition, a diagonal scaling matrix based on\nC  the tolerances is also introduced into the altered system.)\nC\nC  The JAC routine evaluates any data needed for solving systems\nC  with coefficient matrix P, and PSOL carries out that solution.\nC  In any case, in order to improve convergence, you should try to\nC  make P approximate the matrix A as much as possible, while keeping\nC  the system P*x = b reasonably easy and inexpensive to solve for x,\nC  given a vector b.\nC\nC  While integrating the given DAE system, DDASKR also searches for\nC  roots of the given constraint functions Ri(T,Y,Y\') given by RT.\nC  If DDASKR detects a sign change in any Ri(T,Y,Y\'), it will return\nC  the intermediate value of T and Y for which Ri(T,Y,Y\') = 0.\nC  Caution: If some Ri has a root at or very near the initial time,\nC  DDASKR may fail to find it, or may find extraneous roots there,\nC  because it does not yet have a sufficient history of the solution.\nC\nC *Description\nC\nC------INPUT - WHAT TO DO ON THE FIRST CALL TO DDASKR-------------------\nC\nC\nC  The first call of the code is defined to be the start of each new\nC  problem.  Read through the descriptions of all the following items,\nC  provide sufficient storage space for designated arrays, set\nC  appropriate variables for the initialization of the problem, and\nC  give information about how you want the problem to be solved.\nC\nC\nC  RES -- Provide a subroutine of the form\nC\nC             SUBROUTINE RES (T, Y, YPRIME, CJ, DELTA, IRES, RPAR, IPAR)\nC\nC         to define the system of differential/algebraic\nC         equations which is to be solved. For the given values\nC         of T, Y and YPRIME, the subroutine should return\nC         the residual of the differential/algebraic system\nC             DELTA = G(T,Y,YPRIME)\nC         DELTA is a vector of length NEQ which is output from RES.\nC\nC         Subroutine RES must not alter T, Y, YPRIME, or CJ.\nC         You must declare the name RES in an EXTERNAL\nC         statement in your program that calls DDASKR.\nC         You must dimension Y, YPRIME, and DELTA in RES.\nC\nC         The input argument CJ can be ignored, or used to rescale\nC         constraint equations in the system (see Ref. 2, p. 145).\nC         Note: In this respect, DDASKR is not downward-compatible\nC         with DDASSL, which does not have the RES argument CJ.\nC\nC         IRES is an integer flag which is always equal to zero\nC         on input.  Subroutine RES should alter IRES only if it\nC         encounters an illegal value of Y or a stop condition.\nC         Set IRES = -1 if an input value is illegal, and DDASKR\nC         will try to solve the problem without getting IRES = -1.\nC         If IRES = -2, DDASKR will return control to the calling\nC         program with IDID = -11.\nC\nC         RPAR and IPAR are real and integer parameter arrays which\nC         you can use for communication between your calling program\nC         and subroutine RES. They are not altered by DDASKR. If you\nC         do not need RPAR or IPAR, ignore these parameters by treat-\nC         ing them as dummy arguments. If you do choose to use them,\nC         dimension them in your calling program and in RES as arrays\nC         of appropriate length.\nC\nC  NEQ -- Set it to the number of equations in the system (NEQ .GE. 1).\nC\nC  T -- Set it to the initial point of the integration. (T must be\nC       a variable.)\nC\nC  Y(*) -- Set this array to the initial values of the NEQ solution\nC          components at the initial point.  You must dimension Y of\nC          length at least NEQ in your calling program.\nC\nC  YPRIME(*) -- Set this array to the initial values of the NEQ first\nC               derivatives of the solution components at the initial\nC               point.  You must dimension YPRIME at least NEQ in your\nC               calling program.\nC\nC  TOUT - Set it to the first point at which a solution is desired.\nC         You cannot take TOUT = T.  Integration either forward in T\nC         (TOUT .GT. T) or backward in T (TOUT .LT. T) is permitted.\nC\nC         The code advances the solution from T to TOUT using step\nC         sizes which are automatically selected so as to achieve the\nC         desired accuracy.  If you wish, the code will return with the\nC         solution and its derivative at intermediate steps (the\nC         intermediate-output mode) so that you can monitor them,\nC         but you still must provide TOUT in accord with the basic\nC         aim of the code.\nC\nC         The first step taken by the code is a critical one because\nC         it must reflect how fast the solution changes near the\nC         initial point.  The code automatically selects an initial\nC         step size which is practically always suitable for the\nC         problem.  By using the fact that the code will not step past\nC         TOUT in the first step, you could, if necessary, restrict the\nC         length of the initial step.\nC\nC         For some problems it may not be permissible to integrate\nC         past a point TSTOP, because a discontinuity occurs there\nC         or the solution or its derivative is not defined beyond\nC         TSTOP.  When you have declared a TSTOP point (see INFO(4)\nC         and RWORK(1)), you have told the code not to integrate past\nC         TSTOP.  In this case any tout beyond TSTOP is invalid input.\nC\nC  INFO(*) - Use the INFO array to give the code more details about\nC            how you want your problem solved.  This array should be\nC            dimensioned of length 20, though DDASKR uses only the\nC            first 15 entries.  You must respond to all of the following\nC            items, which are arranged as questions.  The simplest use\nC            of DDASKR corresponds to setting all entries of INFO to 0.\nC\nC       INFO(1) - This parameter enables the code to initialize itself.\nC              You must set it to indicate the start of every new\nC              problem.\nC\nC          **** Is this the first call for this problem ...\nC                yes - set INFO(1) = 0\nC                 no - not applicable here.\nC                      See below for continuation calls.  ****\nC\nC       INFO(2) - How much accuracy you want of your solution\nC              is specified by the error tolerances RTOL and ATOL.\nC              The simplest use is to take them both to be scalars.\nC              To obtain more flexibility, they can both be arrays.\nC              The code must be told your choice.\nC\nC          **** Are both error tolerances RTOL, ATOL scalars ...\nC                yes - set INFO(2) = 0\nC                      and input scalars for both RTOL and ATOL\nC                 no - set INFO(2) = 1\nC                      and input arrays for both RTOL and ATOL ****\nC\nC       INFO(3) - The code integrates from T in the direction of TOUT\nC              by steps.  If you wish, it will return the computed\nC              solution and derivative at the next intermediate step\nC              (the intermediate-output mode) or TOUT, whichever comes\nC              first.  This is a good way to proceed if you want to\nC              see the behavior of the solution.  If you must have\nC              solutions at a great many specific TOUT points, this\nC              code will compute them efficiently.\nC\nC          **** Do you want the solution only at\nC               TOUT (and not at the next intermediate step) ...\nC                yes - set INFO(3) = 0 (interval-output mode)\nC                 no - set INFO(3) = 1 (intermediate-output mode) ****\nC\nC       INFO(4) - To handle solutions at a great many specific\nC              values TOUT efficiently, this code may integrate past\nC              TOUT and interpolate to obtain the result at TOUT.\nC              Sometimes it is not possible to integrate beyond some\nC              point TSTOP because the equation changes there or it is\nC              not defined past TSTOP.  Then you must tell the code\nC              this stop condition.\nC\nC           **** Can the integration be carried out without any\nC                restrictions on the independent variable T ...\nC                 yes - set INFO(4) = 0\nC                  no - set INFO(4) = 1\nC                       and define the stopping point TSTOP by\nC                       setting RWORK(1) = TSTOP ****\nC\nC       INFO(5) - used only when INFO(12) = 0 (direct methods).\nC              To solve differential/algebraic systems you may wish\nC              to use a matrix of partial derivatives of the\nC              system of differential equations.  If you do not\nC              provide a subroutine to evaluate it analytically (see\nC              description of the item JAC in the call list), it will\nC              be approximated by numerical differencing in this code.\nC              Although it is less trouble for you to have the code\nC              compute partial derivatives by numerical differencing,\nC              the solution will be more reliable if you provide the\nC              derivatives via JAC.  Usually numerical differencing is\nC              more costly than evaluating derivatives in JAC, but\nC              sometimes it is not - this depends on your problem.\nC\nC           **** Do you want the code to evaluate the partial deriv-\nC                atives automatically by numerical differences ...\nC                 yes - set INFO(5) = 0\nC                  no - set INFO(5) = 1\nC                       and provide subroutine JAC for evaluating the\nC                       matrix of partial derivatives ****\nC\nC       INFO(6) - used only when INFO(12) = 0 (direct methods).\nC              DDASKR will perform much better if the matrix of\nC              partial derivatives, dG/dY + CJ*dG/dYPRIME (here CJ is\nC              a scalar determined by DDASKR), is banded and the code\nC              is told this.  In this case, the storage needed will be\nC              greatly reduced, numerical differencing will be performed\nC              much cheaper, and a number of important algorithms will\nC              execute much faster.  The differential equation is said\nC              to have half-bandwidths ML (lower) and MU (upper) if\nC              equation i involves only unknowns Y(j) with\nC                             i-ML .le. j .le. i+MU .\nC              For all i=1,2,...,NEQ.  Thus, ML and MU are the widths\nC              of the lower and upper parts of the band, respectively,\nC              with the main diagonal being excluded.  If you do not\nC              indicate that the equation has a banded matrix of partial\nC              derivatives the code works with a full matrix of NEQ**2\nC              elements (stored in the conventional way).  Computations\nC              with banded matrices cost less time and storage than with\nC              full matrices if  2*ML+MU .lt. NEQ.  If you tell the\nC              code that the matrix of partial derivatives has a banded\nC              structure and you want to provide subroutine JAC to\nC              compute the partial derivatives, then you must be careful\nC              to store the elements of the matrix in the special form\nC              indicated in the description of JAC.\nC\nC          **** Do you want to solve the problem using a full (dense)\nC               matrix (and not a special banded structure) ...\nC                yes - set INFO(6) = 0\nC                 no - set INFO(6) = 1\nC                       and provide the lower (ML) and upper (MU)\nC                       bandwidths by setting\nC                       IWORK(1)=ML\nC                       IWORK(2)=MU ****\nC\nC       INFO(7) - You can specify a maximum (absolute value of)\nC              stepsize, so that the code will aNothing passing over very\nC              large regions.\nC\nC          ****  Do you want the code to decide on its own the maximum\nC                stepsize ...\nC                 yes - set INFO(7) = 0\nC                  no - set INFO(7) = 1\nC                       and define HMAX by setting\nC                       RWORK(2) = HMAX ****\nC\nC       INFO(8) -  Differential/algebraic problems may occasionally\nC              suffer from severe scaling difficulties on the first\nC              step.  If you know a great deal about the scaling of\nC              your problem, you can help to alleviate this problem\nC              by specifying an initial stepsize H0.\nC\nC          ****  Do you want the code to define its own initial\nC                stepsize ...\nC                 yes - set INFO(8) = 0\nC                  no - set INFO(8) = 1\nC                       and define H0 by setting\nC                       RWORK(3) = H0 ****\nC\nC       INFO(9) -  If storage is a severe problem, you can save some\nC              storage by restricting the maximum method order MAXORD.\nC              The default value is 5.  For each order decrease below 5,\nC              the code requires NEQ fewer locations, but it is likely\nC              to be slower.  In any case, you must have\nC              1 .le. MAXORD .le. 5.\nC          ****  Do you want the maximum order to default to 5 ...\nC                 yes - set INFO(9) = 0\nC                  no - set INFO(9) = 1\nC                       and define MAXORD by setting\nC                       IWORK(3) = MAXORD ****\nC\nC       INFO(10) - If you know that certain components of the\nC              solutions to your equations are always nonnegative\nC              (or nonpositive), it may help to set this\nC              parameter.  There are three options that are\nC              available:\nC              1.  To have constraint checking only in the initial\nC                  condition calculation.\nC              2.  To enforce nonnegativity in Y during the integration.\nC              3.  To enforce both options 1 and 2.\nC\nC              When selecting option 2 or 3, it is probably best to try\nC              the code without using this option first, and only use\nC              this option if that does not work very well.\nC\nC          ****  Do you want the code to solve the problem without\nC                invoking any special inequality constraints ...\nC                 yes - set INFO(10) = 0\nC                  no - set INFO(10) = 1 to have option 1 enforced\nC                  no - set INFO(10) = 2 to have option 2 enforced\nC                  no - set INFO(10) = 3 to have option 3 enforced ****\nC\nC                  If you have specified INFO(10) = 1 or 3, then you\nC                  will also need to identify how each component of Y\nC                  in the initial condition calculation is constrained.\nC                  You must set:\nC                  IWORK(40+I) = +1 if Y(I) must be .GE. 0,\nC                  IWORK(40+I) = +2 if Y(I) must be .GT. 0,\nC                  IWORK(40+I) = -1 if Y(I) must be .LE. 0, while\nC                  IWORK(40+I) = -2 if Y(I) must be .LT. 0, while\nC                  IWORK(40+I) =  0 if Y(I) is not constrained.\nC\nC       INFO(11) - DDASKR normally requires the initial T, Y, and\nC              YPRIME to be consistent.  That is, you must have\nC              G(T,Y,YPRIME) = 0 at the initial T.  If you do not know\nC              the initial conditions precisely, in some cases\nC              DDASKR may be able to compute it.\nC\nC              Denoting the differential variables in Y by Y_d\nC              and the algebraic variables by Y_a, DDASKR can solve\nC              one of two initialization problems:\nC              1.  Given Y_d, calculate Y_a and Y\'_d, or\nC              2.  Given Y\', calculate Y.\nC              In either case, initial values for the given\nC              components are input, and initial guesses for\nC              the unknown components must also be provided as input.\nC\nC          ****  Are the initial T, Y, YPRIME consistent ...\nC\nC                 yes - set INFO(11) = 0\nC                  no - set INFO(11) = 1 to calculate option 1 above,\nC                    or set INFO(11) = 2 to calculate option 2 ****\nC\nC                  If you have specified INFO(11) = 1, then you\nC                  will also need to identify  which are the\nC                  differential and which are the algebraic\nC                  components (algebraic components are components\nC                  whose derivatives do not appear explicitly\nC                  in the function G(T,Y,YPRIME)).  You must set:\nC                  IWORK(LID+I) = +1 if Y(I) is a differential variable\nC                  IWORK(LID+I) = -1 if Y(I) is an algebraic variable,\nC                  where LID = 40 if INFO(10) = 0 or 2 and LID = 40+NEQ\nC                  if INFO(10) = 1 or 3.\nC\nC       INFO(12) - Except for the addition of the RES argument CJ,\nC              DDASKR by default is downward-compatible with DDASSL,\nC              which uses only direct (dense or band) methods to solve\nC              the linear systems involved.  You must set INFO(12) to\nC              indicate whether you want the direct methods or the\nC              Krylov iterative method.\nC          ****   Do you want DDASKR to use standard direct methods\nC                 (dense or band) or the Krylov (iterative) method ...\nC                   direct methods - set INFO(12) = 0.\nC                   Krylov method  - set INFO(12) = 1,\nC                       and check the settings of INFO(13) and INFO(15).\nC\nC       INFO(13) - used when INFO(12) = 1 (Krylov methods).\nC              DDASKR uses scalars MAXL, KMP, NRMAX, and EPLI for the\nC              iterative solution of linear systems.  INFO(13) allows\nC              you to override the default values of these parameters.\nC              These parameters and their defaults are as follows:\nC              MAXL = maximum number of iterations in the SPIGMR\nC                 algorithm (MAXL .le. NEQ).  The default is\nC                 MAXL = MIN(5,NEQ).\nC              KMP = number of vectors on which orthogonalization is\nC                 done in the SPIGMR algorithm.  The default is\nC                 KMP = MAXL, which corresponds to complete GMRES\nC                 iteration, as opposed to the incomplete form.\nC              NRMAX = maximum number of restarts of the SPIGMR\nC                 algorithm per nonlinear iteration.  The default is\nC                 NRMAX = 5.\nC              EPLI = convergence test constant in SPIGMR algorithm.\nC                 The default is EPLI = 0.05.\nC              Note that the length of RWORK depends on both MAXL\nC              and KMP.  See the definition of LRW below.\nC          ****   Are MAXL, KMP, and EPLI to be given their\nC                 default values ...\nC                  yes - set INFO(13) = 0\nC                   no - set INFO(13) = 1,\nC                        and set all of the following:\nC                        IWORK(24) = MAXL (1 .le. MAXL .le. NEQ)\nC                        IWORK(25) = KMP  (1 .le. KMP .le. MAXL)\nC                        IWORK(26) = NRMAX  (NRMAX .ge. 0)\nC                        RWORK(10) = EPLI (0 .lt. EPLI .lt. 1.0) ****\nC\nC        INFO(14) - used with INFO(11) > 0 (initial condition\nC               calculation is requested).  In this case, you may\nC               request control to be returned to the calling program\nC               immediately after the initial condition calculation,\nC               before proceeding to the integration of the system\nC               (e.g. to examine the computed Y and YPRIME).\nC               If this is done, and if the initialization succeeded\nC               (IDID = 4), you should reset INFO(11) to 0 for the\nC               next call, to prevent the solver from repeating the\nC               initialization (and to aNothing an infinite loop).\nC          ****   Do you want to proceed to the integration after\nC                 the initial condition calculation is done ...\nC                 yes - set INFO(14) = 0\nC                  no - set INFO(14) = 1                        ****\nC\nC        INFO(15) - used when INFO(12) = 1 (Krylov methods).\nC               When using preconditioning in the Krylov method,\nC               you must supply a subroutine, PSOL, which solves the\nC               associated linear systems using P.\nC               The usage of DDASKR is simpler if PSOL can carry out\nC               the solution without any prior calculation of data.\nC               However, if some partial derivative data is to be\nC               calculated in advance and used repeatedly in PSOL,\nC               then you must supply a JAC routine to do this,\nC               and set INFO(15) to indicate that JAC is to be called\nC               for this purpose.  For example, P might be an\nC               approximation to a part of the matrix A which can be\nC               calculated and LU-factored for repeated solutions of\nC               the preconditioner system.  The arrays WP and IWP\nC               (described under JAC and PSOL) can be used to\nC               communicate data between JAC and PSOL.\nC          ****   Does PSOL operate with no prior preparation ...\nC                 yes - set INFO(15) = 0 (no JAC routine)\nC                  no - set INFO(15) = 1\nC                       and supply a JAC routine to evaluate and\nC                       preprocess any required Jacobian data.  ****\nC\nC         INFO(16) - option to exclude algebraic variables from\nC               the error test.\nC          ****   Do you wish to control errors locally on\nC                 all the variables...\nC                 yes - set INFO(16) = 0\nC                  no - set INFO(16) = 1\nC                       If you have specified INFO(16) = 1, then you\nC                       will also need to identify  which are the\nC                       differential and which are the algebraic\nC                       components (algebraic components are components\nC                       whose derivatives do not appear explicitly\nC                       in the function G(T,Y,YPRIME)).  You must set:\nC                       IWORK(LID+I) = +1 if Y(I) is a differential\nC                                      variable, and\nC                       IWORK(LID+I) = -1 if Y(I) is an algebraic\nC                                      variable,\nC                       where LID = 40 if INFO(10) = 0 or 2 and\nC                       LID = 40 + NEQ if INFO(10) = 1 or 3.\nC\nC       INFO(17) - used when INFO(11) > 0 (DDASKR is to do an\nC              initial condition calculation).\nC              DDASKR uses several heuristic control quantities in the\nC              initial condition calculation.  They have default values,\nC              but can  also be set by the user using INFO(17).\nC              These parameters and their defaults are as follows:\nC              MXNIT  = maximum number of Newton iterations\nC                 per Jacobian or preconditioner evaluation.\nC                 The default is:\nC                 MXNIT =  5 in the direct case (INFO(12) = 0), and\nC                 MXNIT = 15 in the Krylov case (INFO(12) = 1).\nC              MXNJ   = maximum number of Jacobian or preconditioner\nC                 evaluations.  The default is:\nC                 MXNJ = 6 in the direct case (INFO(12) = 0), and\nC                 MXNJ = 2 in the Krylov case (INFO(12) = 1).\nC              MXNH   = maximum number of values of the artificial\nC                 stepsize parameter H to be tried if INFO(11) = 1.\nC                 The default is MXNH = 5.\nC                 NOTE: the maximum number of Newton iterations\nC                 allowed in all is MXNIT*MXNJ*MXNH if INFO(11) = 1,\nC                 and MXNIT*MXNJ if INFO(11) = 2.\nC              LSOFF  = flag to turn off the linesearch algorithm\nC                 (LSOFF = 0 means linesearch is on, LSOFF = 1 means\nC                 it is turned off).  The default is LSOFF = 0.\nC              STPTOL = minimum scaled step in linesearch algorithm.\nC                 The default is STPTOL = (unit roundoff)**(2/3).\nC              EPINIT = swing factor in the Newton iteration convergence\nC                 test.  The test is applied to the residual vector,\nC                 premultiplied by the approximate Jacobian (in the\nC                 direct case) or the preconditioner (in the Krylov\nC                 case).  For convergence, the weighted RMS norm of\nC                 this vector (scaled by the error weights) must be\nC                 less than EPINIT*EPCON, where EPCON = .33 is the\nC                 analogous test constant used in the time steps.\nC                 The default is EPINIT = .01.\nC          ****   Are the initial condition heuristic controls to be\nC                 given their default values...\nC                  yes - set INFO(17) = 0\nC                   no - set INFO(17) = 1,\nC                        and set all of the following:\nC                        IWORK(32) = MXNIT (.GT. 0)\nC                        IWORK(33) = MXNJ (.GT. 0)\nC                        IWORK(34) = MXNH (.GT. 0)\nC                        IWORK(35) = LSOFF ( = 0 or 1)\nC                        RWORK(14) = STPTOL (.GT. 0.0)\nC                        RWORK(15) = EPINIT (.GT. 0.0)  ****\nC\nC         INFO(18) - option to get extra printing in initial condition\nC                calculation.\nC          ****   Do you wish to have extra printing...\nC                 no  - set INFO(18) = 0\nC                 yes - set INFO(18) = 1 for minimal printing, or\nC                       set INFO(18) = 2 for full printing.\nC                       If you have specified INFO(18) .ge. 1, data\nC                       will be printed with the error handler routines.\nC                       To print to a non-default unit number L, include\nC                       the line  CALL XSETUN(L)  in your program.  ****\nC\nC   RTOL, ATOL -- You must assign relative (RTOL) and absolute (ATOL)\nC               error tolerances to tell the code how accurately you\nC               want the solution to be computed.  They must be defined\nC               as variables because the code may change them.\nC               you have two choices --\nC                     Both RTOL and ATOL are scalars (INFO(2) = 0), or\nC                     both RTOL and ATOL are vectors (INFO(2) = 1).\nC               In either case all components must be non-negative.\nC\nC               The tolerances are used by the code in a local error\nC               test at each step which requires roughly that\nC                        abs(local error in Y(i)) .le. EWT(i) ,\nC               where EWT(i) = RTOL*abs(Y(i)) + ATOL is an error weight\nC               quantity, for each vector component.\nC               (More specifically, a root-mean-square norm is used to\nC               measure the size of vectors, and the error test uses the\nC               magnitude of the solution at the beginning of the step.)\nC\nC               The true (global) error is the difference between the\nC               true solution of the initial value problem and the\nC               computed approximation.  Practically all present day\nC               codes, including this one, control the local error at\nC               each step and do not even attempt to control the global\nC               error directly.\nC\nC               Usually, but not always, the true accuracy of\nC               the computed Y is comparable to the error tolerances.\nC               This code will usually, but not always, deliver a more\nC               accurate solution if you reduce the tolerances and\nC               integrate again.  By comparing two such solutions you\nC               can get a fairly reliable idea of the true error in the\nC               solution at the larger tolerances.\nC\nC               Setting ATOL = 0. results in a pure relative error test\nC               on that component.  Setting RTOL = 0. results in a pure\nC               absolute error test on that component.  A mixed test\nC               with non-zero RTOL and ATOL corresponds roughly to a\nC               relative error test when the solution component is\nC               much bigger than ATOL and to an absolute error test\nC               when the solution component is smaller than the\nC               threshold ATOL.\nC\nC               The code will not attempt to compute a solution at an\nC               accuracy unreasonable for the machine being used.  It\nC               will advise you if you ask for too much accuracy and\nC               inform you as to the maximum accuracy it believes\nC               possible.\nC\nC  RWORK(*) -- a real work array, which should be dimensioned in your\nC               calling program with a length equal to the value of\nC               LRW (or greater).\nC\nC  LRW -- Set it to the declared length of the RWORK array.  The\nC               minimum length depends on the options you have selected,\nC               given by a base value plus additional storage as\nC               described below.\nC\nC               If INFO(12) = 0 (standard direct method), the base value\nC               is BASE = 60 + max(MAXORD+4,7)*NEQ + 3*NRT.\nC               The default value is MAXORD = 5 (see INFO(9)).  With the\nC               default MAXORD, BASE = 60 + 9*NEQ + 3*NRT.\nC               Additional storage must be added to the base value for\nC               any or all of the following options:\nC                 If INFO(6) = 0 (dense matrix), add NEQ**2.\nC                 If INFO(6) = 1 (banded matrix), then:\nC                    if INFO(5) = 0, add (2*ML+MU+1)*NEQ\nC                                           + 2*[NEQ/(ML+MU+1) + 1], and\nC                    if INFO(5) = 1, add (2*ML+MU+1)*NEQ.\nC                 If INFO(16) = 1, add NEQ.\nC\nC               If INFO(12) = 1 (Krylov method), the base value is\nC               BASE = 60 + (MAXORD+5)*NEQ + 3*NRT\nC                         + [MAXL + 3 + min(1,MAXL-KMP)]*NEQ\nC                         + (MAXL+3)*MAXL + 1 + LENWP.\nC               See PSOL for description of LENWP.  The default values\nC               are: MAXORD = 5 (see INFO(9)), MAXL = min(5,NEQ) and\nC               KMP = MAXL  (see INFO(13)).  With these default values,\nC               BASE = 101 + 18*NEQ + 3*NRT + LENWP.\nC               Additional storage must be added to the base value for\nC               the following option:\nC                 If INFO(16) = 1, add NEQ.\nC\nC\nC  IWORK(*) -- an integer work array, which should be dimensioned in\nC              your calling program with a length equal to the value\nC              of LIW (or greater).\nC\nC  LIW -- Set it to the declared length of the IWORK array.  The\nC             minimum length depends on the options you have selected,\nC             given by a base value plus additions as described below.\nC\nC             If INFO(12) = 0 (standard direct method), the base value\nC             is BASE = 40 + NEQ.\nC             IF INFO(10) = 1 or 3, add NEQ to the base value.\nC             If INFO(11) = 1 or INFO(16) =1, add NEQ to the base value.\nC\nC             If INFO(12) = 1 (Krylov method), the base value is\nC             BASE = 40 + LENIWP.  See PSOL for description of LENIWP.\nC             If INFO(10) = 1 or 3, add NEQ to the base value.\nC             If INFO(11) = 1 or INFO(16) =1, add NEQ to the base value.\nC\nC\nC  RPAR, IPAR -- These are arrays of double precision and integer type,\nC             respectively, which are available for you to use\nC             for communication between your program that calls\nC             DDASKR and the RES subroutine (and the JAC and PSOL\nC             subroutines).  They are not altered by DDASKR.\nC             If you do not need RPAR or IPAR, ignore these\nC             parameters by treating them as dummy arguments.\nC             If you do choose to use them, dimension them in\nC             your calling program and in RES (and in JAC and PSOL)\nC             as arrays of appropriate length.\nC\nC  JAC -- This is the name of a routine that you may supply\nC         (optionally) that relates to the Jacobian matrix of the\nC         nonlinear system that the code must solve at each T step.\nC         The role of JAC (and its call sequence) depends on whether\nC         a direct (INFO(12) = 0) or Krylov (INFO(12) = 1) method\nC         is selected.\nC\nC         **** INFO(12) = 0 (direct methods):\nC           If you are letting the code generate partial derivatives\nC           numerically (INFO(5) = 0), then JAC can be absent\nC           (or perhaps a dummy routine to satisfy the loader).\nC           Otherwise you must supply a JAC routine to compute\nC           the matrix A = dG/dY + CJ*dG/dYPRIME.  It must have\nC           the form\nC\nC           SUBROUTINE JAC (T, Y, YPRIME, PD, CJ, RPAR, IPAR)\nC\nC           The JAC routine must dimension Y, YPRIME, and PD (and RPAR\nC           and IPAR if used).  CJ is a scalar which is input to JAC.\nC           For the given values of T, Y, and YPRIME, the JAC routine\nC           must evaluate the nonzero elements of the matrix A, and\nC           store these values in the array PD.  The elements of PD are\nC           set to zero before each call to JAC, so that only nonzero\nC           elements need to be defined.\nC           The way you store the elements into the PD array depends\nC           on the structure of the matrix indicated by INFO(6).\nC           *** INFO(6) = 0 (full or dense matrix) ***\nC               Give PD a first dimension of NEQ.  When you evaluate the\nC               nonzero partial derivatives of equation i (i.e. of G(i))\nC               with respect to component j (of Y and YPRIME), you must\nC               store the element in PD according to\nC                  PD(i,j) = dG(i)/dY(j) + CJ*dG(i)/dYPRIME(j).\nC           *** INFO(6) = 1 (banded matrix with half-bandwidths ML, MU\nC                            as described under INFO(6)) ***\nC               Give PD a first dimension of 2*ML+MU+1.  When you\nC               evaluate the nonzero partial derivatives of equation i\nC               (i.e. of G(i)) with respect to component j (of Y and\nC               YPRIME), you must store the element in PD according to\nC                  IROW = i - j + ML + MU + 1\nC                  PD(IROW,j) = dG(i)/dY(j) + CJ*dG(i)/dYPRIME(j).\nC\nC          **** INFO(12) = 1 (Krylov method):\nC            If you are not calculating Jacobian data in advance for use\nC            in PSOL (INFO(15) = 0), JAC can be absent (or perhaps a\nC            dummy routine to satisfy the loader).  Otherwise, you may\nC            supply a JAC routine to compute and preprocess any parts of\nC            of the Jacobian matrix  A = dG/dY + CJ*dG/dYPRIME that are\nC            involved in the preconditioner matrix P.\nC            It is to have the form\nC\nC            SUBROUTINE JAC (RES, IRES, NEQ, T, Y, YPRIME, REWT, SAVR,\nC                            WK, H, CJ, WP, IWP, IER, RPAR, IPAR)\nC\nC           The JAC routine must dimension Y, YPRIME, REWT, SAVR, WK,\nC           and (if used) WP, IWP, RPAR, and IPAR.\nC           The Y, YPRIME, and SAVR arrays contain the current values\nC           of Y, YPRIME, and the residual G, respectively.\nC           The array WK is work space of length NEQ.\nC           H is the step size.  CJ is a scalar, input to JAC, that is\nC           normally proportional to 1/H.  REWT is an array of\nC           reciprocal error weights, 1/EWT(i), where EWT(i) is\nC           RTOL*abs(Y(i)) + ATOL (unless you supplied routine DDAWTS\nC           instead), for use in JAC if needed.  For example, if JAC\nC           computes difference quotient approximations to partial\nC           derivatives, the REWT array may be useful in setting the\nC           increments used.  The JAC routine should do any\nC           factorization operations called for, in preparation for\nC           solving linear systems in PSOL.  The matrix P should\nC           be an approximation to the Jacobian,\nC           A = dG/dY + CJ*dG/dYPRIME.\nC\nC           WP and IWP are real and integer work arrays which you may\nC           use for communication between your JAC routine and your\nC           PSOL routine.  These may be used to store elements of the\nC           preconditioner P, or related matrix data (such as factored\nC           forms).  They are not altered by DDASKR.\nC           If you do not need WP or IWP, ignore these parameters by\nC           treating them as dummy arguments.  If you do use them,\nC           dimension them appropriately in your JAC and PSOL routines.\nC           See the PSOL description for instructions on setting\nC           the lengths of WP and IWP.\nC\nC           On return, JAC should set the error flag IER as follows..\nC             IER = 0    if JAC was successful,\nC             IER .ne. 0 if JAC was unsuccessful (e.g. if Y or YPRIME\nC                        was illegal, or a singular matrix is found).\nC           (If IER .ne. 0, a smaller stepsize will be tried.)\nC           IER = 0 on entry to JAC, so need be reset only on a failure.\nC           If RES is used within JAC, then a nonzero value of IRES will\nC           override any nonzero value of IER (see the RES description).\nC\nC         Regardless of the method type, subroutine JAC must not\nC         alter T, Y(*), YPRIME(*), H, CJ, or REWT(*).\nC         You must declare the name JAC in an EXTERNAL statement in\nC         your program that calls DDASKR.\nC\nC PSOL --  This is the name of a routine you must supply if you have\nC         selected a Krylov method (INFO(12) = 1) with preconditioning.\nC         In the direct case (INFO(12) = 0), PSOL can be absent\nC         (a dummy routine may have to be supplied to satisfy the\nC         loader).  Otherwise, you must provide a PSOL routine to\nC         solve linear systems arising from preconditioning.\nC         When supplied with INFO(12) = 1, the PSOL routine is to\nC         have the form\nC\nC         SUBROUTINE PSOL (NEQ, T, Y, YPRIME, SAVR, WK, CJ, WGHT,\nC                          WP, IWP, B, EPLIN, IER, RPAR, IPAR)\nC\nC         The PSOL routine must solve linear systems of the form\nC         P*x = b where P is the left preconditioner matrix.\nC\nC         The right-hand side vector b is in the B array on input, and\nC         PSOL must return the solution vector x in B.\nC         The Y, YPRIME, and SAVR arrays contain the current values\nC         of Y, YPRIME, and the residual G, respectively.\nC\nC         Work space required by JAC and/or PSOL, and space for data to\nC         be communicated from JAC to PSOL is made available in the form\nC         of arrays WP and IWP, which are parts of the RWORK and IWORK\nC         arrays, respectively.  The lengths of these real and integer\nC         work spaces WP and IWP must be supplied in LENWP and LENIWP,\nC         respectively, as follows..\nC           IWORK(27) = LENWP = length of real work space WP\nC           IWORK(28) = LENIWP = length of integer work space IWP.\nC\nC         WK is a work array of length NEQ for use by PSOL.\nC         CJ is a scalar, input to PSOL, that is normally proportional\nC         to 1/H (H = stepsize).  If the old value of CJ\nC         (at the time of the last JAC call) is needed, it must have\nC         been saved by JAC in WP.\nC\nC         WGHT is an array of weights, to be used if PSOL uses an\nC         iterative method and performs a convergence test.  (In terms\nC         of the argument REWT to JAC, WGHT is REWT/sqrt(NEQ).)\nC         If PSOL uses an iterative method, it should use EPLIN\nC         (a heuristic parameter) as the bound on the weighted norm of\nC         the residual for the computed solution.  Specifically, the\nC         residual vector R should satisfy\nC              SQRT (SUM ( (R(i)*WGHT(i))**2 ) ) .le. EPLIN\nC\nC         PSOL must not alter NEQ, T, Y, YPRIME, SAVR, CJ, WGHT, EPLIN.\nC\nC         On return, PSOL should set the error flag IER as follows..\nC           IER = 0 if PSOL was successful,\nC           IER .lt. 0 if an unrecoverable error occurred, meaning\nC                 control will be passed to the calling routine,\nC           IER .gt. 0 if a recoverable error occurred, meaning that\nC                 the step will be retried with the same step size\nC                 but with a call to JAC to update necessary data,\nC                 unless the Jacobian data is current, in which case\nC                 the step will be retried with a smaller step size.\nC           IER = 0 on entry to PSOL so need be reset only on a failure.\nC\nC         You must declare the name PSOL in an EXTERNAL statement in\nC         your program that calls DDASKR.\nC\nC RT --   This is the name of the subroutine for defining the vector\nC         R(T,Y,Y\') of constraint functions Ri(T,Y,Y\'), whose roots\nC         are desired during the integration.  It is to have the form\nC             SUBROUTINE RT(NEQ, T, Y, YP, NRT, RVAL, RPAR, IPAR)\nC             DIMENSION Y(NEQ), YP(NEQ), RVAL(NRT),\nC         where NEQ, T, Y and NRT are INPUT, and the array RVAL is\nC         output.  NEQ, T, Y, and YP have the same meaning as in the\nC         RES routine, and RVAL is an array of length NRT.\nC         For i = 1,...,NRT, this routine is to load into RVAL(i) the\nC         value at (T,Y,Y\') of the i-th constraint function Ri(T,Y,Y\').\nC         DDASKR will find roots of the Ri of odd multiplicity\nC         (that is, sign changes) as they occur during the integration.\nC         RT must be declared EXTERNAL in the calling program.\nC\nC         CAUTION.. Because of numerical errors in the functions Ri\nC         due to roundoff and integration error, DDASKR may return\nC         false roots, or return the same root at two or more nearly\nC         equal values of T.  If such false roots are suspected,\nC         the user should consider smaller error tolerances and/or\nC         higher precision in the evaluation of the Ri.\nC\nC         If a root of some Ri defines the end of the problem,\nC         the input to DDASKR should nevertheless allow\nC         integration to a point slightly past that root, so\nC         that DDASKR can locate the root by interpolation.\nC\nC NRT --  The number of constraint functions Ri(T,Y,Y\').  If there are\nC         no constraints, set NRT = 0 and pass a dummy name for RT.\nC\nC JROOT -- This is an integer array of length NRT, used only for output.\nC         On a return where one or more roots were found (IDID = 5),\nC         JROOT(i) = 1 or -1 if Ri(T,Y,Y\') has a root at T, and\nC         JROOT(i) = 0 if not.  If nonzero, JROOT(i) shows the direction\nC         of the sign change in Ri in the direction of integration:\nC         JROOT(i) = 1  means Ri changed from negative to positive.\nC         JROOT(i) = -1 means Ri changed from positive to negative.\nC\nC\nC  OPTIONALLY REPLACEABLE SUBROUTINE:\nC\nC  DDASKR uses a weighted root-mean-square norm to measure the\nC  size of various error vectors.  The weights used in this norm\nC  are set in the following subroutine:\nC\nC    SUBROUTINE DDAWTS (NEQ, IWT, RTOL, ATOL, Y, EWT, RPAR, IPAR)\nC    DIMENSION RTOL(*), ATOL(*), Y(*), EWT(*), RPAR(*), IPAR(*)\nC\nC  A DDAWTS routine has been included with DDASKR which sets the\nC  weights according to\nC    EWT(I) = RTOL*ABS(Y(I)) + ATOL\nC  in the case of scalar tolerances (IWT = 0) or\nC    EWT(I) = RTOL(I)*ABS(Y(I)) + ATOL(I)\nC  in the case of array tolerances (IWT = 1).  (IWT is INFO(2).)\nC  In some special cases, it may be appropriate for you to define\nC  your own error weights by writing a subroutine DDAWTS to be\nC  called instead of the version supplied.  However, this should\nC  be attempted only after careful thought and consideration.\nC  If you supply this routine, you may use the tolerances and Y\nC  as appropriate, but do not overwrite these variables.  You\nC  may also use RPAR and IPAR to communicate data as appropriate.\nC  ***Note: Aside from the values of the weights, the choice of\nC  norm used in DDASKR (weighted root-mean-square) is not subject\nC  to replacement by the user.  In this respect, DDASKR is not\nC  downward-compatible with the original DDASSL solver (in which\nC  the norm routine was optionally user-replaceable).\nC\nC\nC------OUTPUT - AFTER ANY RETURN FROM DDASKR----------------------------\nC\nC  The principal aim of the code is to return a computed solution at\nC  T = TOUT, although it is also possible to obtain intermediate\nC  results along the way.  To find out whether the code achieved its\nC  goal or if the integration process was interrupted before the task\nC  was completed, you must check the IDID parameter.\nC\nC\nC   T -- The output value of T is the point to which the solution\nC        was successfully advanced.\nC\nC   Y(*) -- contains the computed solution approximation at T.\nC\nC   YPRIME(*) -- contains the computed derivative approximation at T.\nC\nC   IDID -- reports what the code did, described as follows:\nC\nC                     *** TASK COMPLETED ***\nC                Reported by positive values of IDID\nC\nC           IDID = 1 -- A step was successfully taken in the\nC                   interval-output mode.  The code has not\nC                   yet reached TOUT.\nC\nC           IDID = 2 -- The integration to TSTOP was successfully\nC                   completed (T = TSTOP) by stepping exactly to TSTOP.\nC\nC           IDID = 3 -- The integration to TOUT was successfully\nC                   completed (T = TOUT) by stepping past TOUT.\nC                   Y(*) and YPRIME(*) are obtained by interpolation.\nC\nC           IDID = 4 -- The initial condition calculation, with\nC                   INFO(11) > 0, was successful, and INFO(14) = 1.\nC                   No integration steps were taken, and the solution\nC                   is not considered to have been started.\nC\nC           IDID = 5 -- The integration was successfully completed\nC                   by finding one or more roots of R(T,Y,Y\') at T.\nC\nC                    *** TASK INTERRUPTED ***\nC                Reported by negative values of IDID\nC\nC           IDID = -1 -- A large amount of work has been expended\nC                     (about 500 steps).\nC\nC           IDID = -2 -- The error tolerances are too stringent.\nC\nC           IDID = -3 -- The local error test cannot be satisfied\nC                     because you specified a zero component in ATOL\nC                     and the corresponding computed solution component\nC                     is zero.  Thus, a pure relative error test is\nC                     impossible for this component.\nC\nC           IDID = -5 -- There were repeated failures in the evaluation\nC                     or processing of the preconditioner (in JAC).\nC\nC           IDID = -6 -- DDASKR had repeated error test failures on the\nC                     last attempted step.\nC\nC           IDID = -7 -- The nonlinear system solver in the time\nC                     integration could not converge.\nC\nC           IDID = -8 -- The matrix of partial derivatives appears\nC                     to be singular (direct method).\nC\nC           IDID = -9 -- The nonlinear system solver in the integration\nC                     failed to achieve convergence, and there were\nC                     repeated  error test failures in this step.\nC\nC           IDID =-10 -- The nonlinear system solver in the integration\nC                     failed to achieve convergence because IRES was\nC                     equal  to -1.\nC\nC           IDID =-11 -- IRES = -2 was encountered and control is\nC                     being returned to the calling program.\nC\nC           IDID =-12 -- DDASKR failed to compute the initial Y, YPRIME.\nC\nC           IDID =-13 -- An unrecoverable error was encountered inside\nC                     the user\'s PSOL routine, and control is being\nC                     returned to the calling program.\nC\nC           IDID =-14 -- The Krylov linear system solver could not\nC                     achieve convergence.\nC\nC           IDID =-15,..,-32 -- Not applicable for this code.\nC\nC                    *** TASK TERMINATED ***\nC                reported by the value of IDID=-33\nC\nC           IDID = -33 -- The code has encountered trouble from which\nC                   it cannot recover.  A message is printed\nC                   explaining the trouble and control is returned\nC                   to the calling program.  For example, this occurs\nC                   when invalid input is detected.\nC\nC   RTOL, ATOL -- these quantities remain unchanged except when\nC               IDID = -2.  In this case, the error tolerances have been\nC               increased by the code to values which are estimated to\nC               be appropriate for continuing the integration.  However,\nC               the reported solution at T was obtained using the input\nC               values of RTOL and ATOL.\nC\nC   RWORK, IWORK -- contain information which is usually of no interest\nC               to the user but necessary for subsequent calls.\nC               However, you may be interested in the performance data\nC               listed below.  These quantities are accessed in RWORK\nC               and IWORK but have internal mnemonic names, as follows..\nC\nC               RWORK(3)--contains H, the step size h to be attempted\nC                        on the next step.\nC\nC               RWORK(4)--contains TN, the current value of the\nC                        independent variable, i.e. the farthest point\nC                        integration has reached.  This will differ\nC                        from T if interpolation has been performed\nC                        (IDID = 3).\nC\nC               RWORK(7)--contains HOLD, the stepsize used on the last\nC                        successful step.  If INFO(11) = INFO(14) = 1,\nC                        this contains the value of H used in the\nC                        initial condition calculation.\nC\nC               IWORK(7)--contains K, the order of the method to be\nC                        attempted on the next step.\nC\nC               IWORK(8)--contains KOLD, the order of the method used\nC                        on the last step.\nC\nC               IWORK(11)--contains NST, the number of steps (in T)\nC                        taken so far.\nC\nC               IWORK(12)--contains NRE, the number of calls to RES\nC                        so far.\nC\nC               IWORK(13)--contains NJE, the number of calls to JAC so\nC                        far (Jacobian or preconditioner evaluations).\nC\nC               IWORK(14)--contains NETF, the total number of error test\nC                        failures so far.\nC\nC               IWORK(15)--contains NCFN, the total number of nonlinear\nC                        convergence failures so far (includes counts\nC                        of singular iteration matrix or singular\nC                        preconditioners).\nC\nC               IWORK(16)--contains NCFL, the number of convergence\nC                        failures of the linear iteration so far.\nC\nC               IWORK(17)--contains LENIW, the length of IWORK actually\nC                        required.  This is defined on normal returns\nC                        and on an illegal input return for\nC                        insufficient storage.\nC\nC               IWORK(18)--contains LENRW, the length of RWORK actually\nC                        required.  This is defined on normal returns\nC                        and on an illegal input return for\nC                        insufficient storage.\nC\nC               IWORK(19)--contains NNI, the total number of nonlinear\nC                        iterations so far (each of which calls a\nC                        linear solver).\nC\nC               IWORK(20)--contains NLI, the total number of linear\nC                        (Krylov) iterations so far.\nC\nC               IWORK(21)--contains NPS, the number of PSOL calls so\nC                        far, for preconditioning solve operations or\nC                        for solutions with the user-supplied method.\nC\nC               IWORK(36)--contains the total number of calls to the\nC                        constraint function routine RT so far.\nC\nC               Note: The various counters in IWORK do not include\nC               counts during a prior call made with INFO(11) > 0 and\nC               INFO(14) = 1.\nC\nC\nC------INPUT - WHAT TO DO TO CONTINUE THE INTEGRATION  -----------------\nC              (CALLS AFTER THE FIRST)\nC\nC     This code is organized so that subsequent calls to continue the\nC     integration involve little (if any) additional effort on your\nC     part.  You must monitor the IDID parameter in order to determine\nC     what to do next.\nC\nC     Recalling that the principal task of the code is to integrate\nC     from T to TOUT (the interval mode), usually all you will need\nC     to do is specify a new TOUT upon reaching the current TOUT.\nC\nC     Do not alter any quantity not specifically permitted below.  In\nC     particular do not alter NEQ, T, Y(*), YPRIME(*), RWORK(*),\nC     IWORK(*), or the differential equation in subroutine RES.  Any\nC     such alteration constitutes a new problem and must be treated\nC     as such, i.e. you must start afresh.\nC\nC     You cannot change from array to scalar error control or vice\nC     versa (INFO(2)), but you can change the size of the entries of\nC     RTOL or ATOL.  Increasing a tolerance makes the equation easier\nC     to integrate.  Decreasing a tolerance will make the equation\nC     harder to integrate and should generally be aNothinged.\nC\nC     You can switch from the intermediate-output mode to the\nC     interval mode (INFO(3)) or vice versa at any time.\nC\nC     If it has been necessary to prevent the integration from going\nC     past a point TSTOP (INFO(4), RWORK(1)), keep in mind that the\nC     code will not integrate to any TOUT beyond the currently\nC     specified TSTOP.  Once TSTOP has been reached, you must change\nC     the value of TSTOP or set INFO(4) = 0.  You may change INFO(4)\nC     or TSTOP at any time but you must supply the value of TSTOP in\nC     RWORK(1) whenever you set INFO(4) = 1.\nC\nC     Do not change INFO(5), INFO(6), INFO(12-17) or their associated\nC     IWORK/RWORK locations unless you are going to restart the code.\nC\nC                    *** FOLLOWING A COMPLETED TASK ***\nC\nC     If..\nC     IDID = 1, call the code again to continue the integration\nC                  another step in the direction of TOUT.\nC\nC     IDID = 2 or 3, define a new TOUT and call the code again.\nC                  TOUT must be different from T.  You cannot change\nC                  the direction of integration without restarting.\nC\nC     IDID = 4, reset INFO(11) = 0 and call the code again to begin\nC                  the integration.  (If you leave INFO(11) > 0 and\nC                  INFO(14) = 1, you may generate an infinite loop.)\nC                  In this situation, the next call to DDASKR is\nC                  considered to be the first call for the problem,\nC                  in that all initializations are done.\nC\nC     IDID = 5, call the code again to continue the integration in the\nC                  direction of TOUT.  You may change the functions\nC                  Ri defined by RT after a return with IDID = 5, but\nC                  the number of constraint functions NRT must remain\nC                  the same.  If you wish to change the functions in\nC                  RES or in RT, then you must restart the code.\nC\nC                    *** FOLLOWING AN INTERRUPTED TASK ***\nC\nC     To show the code that you realize the task was interrupted and\nC     that you want to continue, you must take appropriate action and\nC     set INFO(1) = 1.\nC\nC     If..\nC     IDID = -1, the code has taken about 500 steps.  If you want to\nC                  continue, set INFO(1) = 1 and call the code again.\nC                  An additional 500 steps will be allowed.\nC\nC\nC     IDID = -2, the error tolerances RTOL, ATOL have been increased\nC                  to values the code estimates appropriate for\nC                  continuing.  You may want to change them yourself.\nC                  If you are sure you want to continue with relaxed\nC                  error tolerances, set INFO(1) = 1 and call the code\nC                  again.\nC\nC     IDID = -3, a solution component is zero and you set the\nC                  corresponding component of ATOL to zero.  If you\nC                  are sure you want to continue, you must first alter\nC                  the error criterion to use positive values of ATOL\nC                  for those components corresponding to zero solution\nC                  components, then set INFO(1) = 1 and call the code\nC                  again.\nC\nC     IDID = -4  --- cannot occur with this code.\nC\nC     IDID = -5, your JAC routine failed with the Krylov method.  Check\nC                  for errors in JAC and restart the integration.\nC\nC     IDID = -6, repeated error test failures occurred on the last\nC                  attempted step in DDASKR.  A singularity in the\nC                  solution may be present.  If you are absolutely\nC                  certain you want to continue, you should restart\nC                  the integration.  (Provide initial values of Y and\nC                  YPRIME which are consistent.)\nC\nC     IDID = -7, repeated convergence test failures occurred on the last\nC                  attempted step in DDASKR.  An inaccurate or ill-\nC                  conditioned Jacobian or preconditioner may be the\nC                  problem.  If you are absolutely certain you want\nC                  to continue, you should restart the integration.\nC\nC\nC     IDID = -8, the matrix of partial derivatives is singular, with\nC                  the use of direct methods.  Some of your equations\nC                  may be redundant.  DDASKR cannot solve the problem\nC                  as stated.  It is possible that the redundant\nC                  equations could be removed, and then DDASKR could\nC                  solve the problem.  It is also possible that a\nC                  solution to your problem either does not exist\nC                  or is not unique.\nC\nC     IDID = -9, DDASKR had multiple convergence test failures, preceded\nC                  by multiple error test failures, on the last\nC                  attempted step.  It is possible that your problem is\nC                  ill-posed and cannot be solved using this code.  Or,\nC                  there may be a discontinuity or a singularity in the\nC                  solution.  If you are absolutely certain you want to\nC                  continue, you should restart the integration.\nC\nC     IDID = -10, DDASKR had multiple convergence test failures\nC                  because IRES was equal to -1.  If you are\nC                  absolutely certain you want to continue, you\nC                  should restart the integration.\nC\nC     IDID = -11, there was an unrecoverable error (IRES = -2) from RES\nC                  inside the nonlinear system solver.  Determine the\nC                  cause before trying again.\nC\nC     IDID = -12, DDASKR failed to compute the initial Y and YPRIME\nC                  vectors.  This could happen because the initial\nC                  approximation to Y or YPRIME was not very good, or\nC                  because no consistent values of these vectors exist.\nC                  The problem could also be caused by an inaccurate or\nC                  singular iteration matrix, or a poor preconditioner.\nC\nC     IDID = -13, there was an unrecoverable error encountered inside\nC                  your PSOL routine.  Determine the cause before\nC                  trying again.\nC\nC     IDID = -14, the Krylov linear system solver failed to achieve\nC                  convergence.  This may be due to ill-conditioning\nC                  in the iteration matrix, or a singularity in the\nC                  preconditioner (if one is being used).\nC                  Another possibility is that there is a better\nC                  choice of Krylov parameters (see INFO(13)).\nC                  Possibly the failure is caused by redundant equations\nC                  in the system, or by inconsistent equations.\nC                  In that case, reformulate the system to make it\nC                  consistent and non-redundant.\nC\nC     IDID = -15,..,-32 --- Cannot occur with this code.\nC\nC                       *** FOLLOWING A TERMINATED TASK ***\nC\nC     If IDID = -33, you cannot continue the solution of this problem.\nC                  An attempt to do so will result in your run being\nC                  terminated.\nC\nC  ---------------------------------------------------------------------\nC\nC***REFERENCES\nC  1.  L. R. Petzold, A Description of DASSL: A Differential/Algebraic\nC      System Solver, in Scientific Computing, R. S. Stepleman et al.\nC      (Eds.), North-Holland, Amsterdam, 1983, pp. 65-68.\nC  2.  K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical\nC      Solution of Initial-Value Problems in Differential-Algebraic\nC      Equations, Elsevier, New York, 1989.\nC  3.  P. N. Brown and A. C. Hindmarsh, Reduced Storage Matrix Methods\nC      in Stiff ODE Systems, J. Applied Mathematics and Computation,\nC      31 (1989), pp. 40-91.\nC  4.  P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Using Krylov\nC      Methods in the Solution of Large-Scale Differential-Algebraic\nC      Systems, SIAM J. Sci. Comp., 15 (1994), pp. 1467-1488.\nC  5.  P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Consistent\nC      Initial Condition Calculation for Differential-Algebraic\nC      Systems, SIAM J. Sci. Comp. 19 (1998), pp. 1495-1512.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "DASKR.AbstractAnalyticalProblemDASKR.AffineDiffEqOperatorDASKR.AnalyticalProblemDASKR.BVProblemDASKR.CallbackSetDASKR.ContinuousCallbackDASKR.DAEFunctionDASKR.DAEProblemDASKR.DAESolutionDASKR.DASKRDASKR.DASKRDAEAlgorithmDASKR.DDEFunctionDASKR.DDEProblemDASKR.DEDataArrayDASKR.DEDataMatrixDASKR.DEDataVectorDASKR.DEFAULT_LINSOLVEDASKR.DESolutionDASKR.DiffEqBaseDASKR.DiscreteCallbackDASKR.DiscreteFunctionDASKR.DiscreteProblemDASKR.DynamicalODEFunctionDASKR.DynamicalODEProblemDASKR.LinSolveFactorizeDASKR.MonteCarloProblemDASKR.MonteCarloSolutionDASKR.MonteCarloSummaryDASKR.MonteCarloTestSolutionDASKR.NoiseProblemDASKR.ODEFunctionDASKR.ODEProblemDASKR.ODESolutionDASKR.RODEFunctionDASKR.RODEProblemDASKR.RODESolutionDASKR.SDEFunctionDASKR.SDEProblemDASKR.SecondOrderODEProblemDASKR.SplitFunctionDASKR.SplitODEProblemDASKR.SplitSDEFunctionDASKR.SplitSDEProblemDASKR.SteadyStateProblemDASKR.SteadyStateSolutionDASKR.TimeChoiceIteratorDASKR.TwoPointBVProblemDASKR.__init__DASKR.add_saveat!DASKR.add_tstop!DASKR.addat!DASKR.addat_non_user_cache!DASKR.addsteps!DASKR.auto_dt_reset!DASKR.change_t_via_interpolation!DASKR.check_errorDASKR.check_keywordsDASKR.common_jac_cDASKR.common_res_cDASKR.daskrDASKR.deleteat!DASKR.deleteat_non_user_cache!DASKR.dllnameDASKR.du_cacheDASKR.evalDASKR.full_cacheDASKR.get_dtDASKR.get_duDASKR.get_du!DASKR.get_proposed_dtDASKR.get_tmp_cacheDASKR.has_expDASKR.has_expmvDASKR.has_expmv!DASKR.has_ldivDASKR.has_ldiv!DASKR.has_mulDASKR.has_mul!DASKR.includeDASKR.initDASKR.initialize!DASKR.intervalsDASKR.is_constantDASKR.isdiscreteDASKR.isinplaceDASKR.jac_cDASKR.libDASKR.rand_cacheDASKR.ratenoise_cacheDASKR.reeval_internals_due_to_modification!DASKR.reinit!DASKR.remakeDASKR.res_cDASKR.resize!DASKR.resize_non_user_cache!DASKR.rt_cDASKR.savevalues!DASKR.set_abstol!DASKR.set_proposed_dt!DASKR.set_reltol!DASKR.set_t!DASKR.set_u!DASKR.solveDASKR.solve!DASKR.step!DASKR.terminate!DASKR.tuplesDASKR.u_cacheDASKR.u_modified!DASKR.unsafe_solveDASKR.update_coefficientsDASKR.update_coefficients!DASKR.user_cacheDASKR.warn_compatDASKR.warnkeywordsDASKR.warnlist"
},

]}
