var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#LBFGSB-1",
    "page": "Readme",
    "title": "LBFGSB",
    "category": "section",
    "text": "(Image: Project Status: Active – The project has reached a stable, usable state and is being actively developed.) (Image: Build Status) (Image: Build status) (Image: codecov)This is a Julia wrapper for L-BFGS-B Nonlinear Optimization Code. It will download and use pre-compiled binaries from L-BFGS-B-Builder."
},

{
    "location": "#Installation-1",
    "page": "Readme",
    "title": "Installation",
    "category": "section",
    "text": "pkg> add LBFGSB"
},

{
    "location": "#Usage-1",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "using LBFGSB\n\n# define a function that maps a vector to a scalar\n# let\'s define a multidimensional Rosenbrock function(https://en.wikipedia.org/wiki/Rosenbrock_function): \nfunction f(x)\n    y = 0.25 * (x[1] - 1)^2\n    for i = 2:length(x)\n        y += (x[i] - x[i-1]^2)^2\n    end\n    4y\nend\n\n# and its gradient function that maps a vector to a vector\nfunction g(x)\n    n = length(x)\n    z = zeros(n)\n    t₁ = x[2] - x[1]^2\n    z[1] = 2 * (x[1] - 1) - 1.6e1 * x[1] * t₁\n    for i = 2:n-1\n        t₂ = t₁\n        t₁ = x[i+1] - x[i]^2\n        z[i] = 8 * t₂ - 1.6e1 * x[i] * t₁\n    end\n    z[n] = 8 * t₁\n    z\nend\n\n# define a function that returns both f(scalar) and its gradient(vector)\nfunc(x) = f(x), g(x)\n\n# the first argument is the dimension of the largest problem to be solved\n# the second argument is the maximum number of limited memory corrections\noptimizer = L_BFGS_B(1024, 17)\nn = 25  # the dimension of the problem\nx = fill(Cdouble(3e0), n)  # the initial guess\n# set up bounds\nbounds = zeros(3, n)\nfor i = 1:n\n    bounds[1,i] = 2  # represents the type of bounds imposed on the variables:\n                     #  0->unbounded, 1->only lower bound, 2-> both lower and upper bounds, 3->only upper bound\n    bounds[2,i] = isodd(i) ? 1e0 : -1e2  #  the lower bound on x, of length n.\n    bounds[3,i] = 1e2  #  the upper bound on x, of length n.\nend\n# call the optimizer\n# - m: the maximum number of variable metric corrections used to define the limited memory matrix\n# - factr: the iteration will stop when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch,\n#     where epsmch is the machine precision, which is automatically generated by the code. Typical values for factr:\n#     1e12 for low accuracy, 1e7 for moderate accuracy, 1e1 for extremely high accuracy\n# - pgtol: the iteration will stop when max{|proj g_i | i = 1, ..., n} <= pgtol where pg_i is the ith component of the projected gradient\n# - iprint: controls the frequency of output. iprint < 0 means no output:\n#     iprint = 0 print only one line at the last iteration\n#     0 < iprint < 99 print also f and |proj g| every iprint iterations\n#     iprint = 99 print details of every iteration except n-vectors\n#     iprint = 100 print also the changes of active set and final x\n#     iprint > 100 print details of every iteration including x and g\n# - maxfun: the maximum number of function evaluations\n# - maxiter: the maximum number of iterations\njulia> fout, xout = optimizer(func, x, bounds, m=5, factr=1e7, pgtol=1e-5, iprint=-1, maxfun=15000, maxiter=15000)\n(1.0834900834300615e-9, [1.0, 1.0, 1.0, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00002, 1.00004  …  1.0026, 1.00521, 1.01045, 1.02101, 1.04246, 1.08672, 1.18097, 1.39469, 1.94516, 3.78366])\n\n# if your func needs extra arguments, a closure can be used to do the trick:\n# optimizer(λ->func(λ, extra_args...), x, bounds, m=5, factr=1e7, pgtol=1e-5, iprint=-1, maxfun=15000, maxiter=15000)The original examples/drivers in the L-BFGS-B library are translated in the test folder directly using low-level setulb."
},

{
    "location": "#License-1",
    "page": "Readme",
    "title": "License",
    "category": "section",
    "text": "Note that, only the wrapper code in this repo is licensed under MIT, those downloaded binaries are released under BSD-3-Clause license."
},

{
    "location": "autodocs/#LBFGSB.setulb",
    "page": "Docstrings",
    "title": "LBFGSB.setulb",
    "category": "function",
    "text": "setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task, iprint, csave, lsave, isave, dsave)\n\nThis function wraps L-BFGS-B\'s fortran subroutine setulb which partitions the working arrays wa and iwa, and then uses the limited memory BFGS method to solve the bound constrained optimization problem by calling mainlb.\n\nNote, nmax is the dimension of the largest problem to be solved, mmax is the maximum number of limited memory corrections.\n\nArguments\n\nn::Ref{Cint}: the dimension of the problem.\nm::Ref{Cint}: the maximum number of variable metric corrections used to define the limited memory matrix.\nx::Vector{Cdouble}: an approximation to the solution, of length n.\nl::Vector{Cdouble}: the lower bound on x, of length n.\nu::Vector{Cdouble}: the upper bound on x, of length n.\nnbd::Vector{Cint}: represents the type of bounds imposed on the variables, and must be specified as follows:\nnbd[i]=0 if x[i] is unbounded;\nnbd[i]=1 if x(i) has only a lower bound;\nnbd[i]=2 if x[i] has both lower and upper bounds;\nnbd[i]=3 if x[i] has only an upper bound.\nf::Ref{Cdouble}: the value of the function at x(on first entry f is unspecified).\ng::Vector{Cdouble}: the value of the gradient at x(on first entry g is unspecified).\nfactr::Ref{Cdouble}: the iteration will stop when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch,   where epsmch is the machine precision, which is automatically generated by the code. Typical values for factr:\n1.e12 for low accuracy;\n1.e7 for moderate accuracy;\n1.e1 for extremely high accuracy.\npgtol::Ref{Cdouble}: the iteration will stop when max{|proj gi | i = 1, ..., n} <= pgtol where pgi is the ith component of the projected gradient.\nwa::Vector{Cdouble}: the working array of length (2mmax + 5)nmax + 12mmax^2 + 12mmax.\niwa::Vector{Cint}: the integer working array of length 3nmax.\ntask::Vector{Cuchar}: a working string of characters of length 60 indicating the current job when entering and quitting this function.\niprint::Ref{Cint}: it controls the frequency and type of output generated:\niprint<0 no output is generated;\niprint=0 print only one line at the last iteration;\n0<iprint<99 print also f and |proj g| every iprint iterations;\niprint=99 print details of every iteration except n-vectors;\niprint=100 print also the changes of active set and final x;\niprint>100 print details of every iteration including x and g.\nwhen iprint > 0, the file iterate.dat will be created to summarize the iteration.\ncsave::Vector{Cuchar}: a working string of characters of length 60.\nlsave::Vector{Bool}: a logical working array of dimension 4. if task = NEW_X, the following information is available:\nif lsave[1] == true then the initial X has been replaced by its projection in the feasible set;\nif lsave[2] == true then the problem is constrained;\nif lsave[3] == true then each variable has upper and lower bounds.\nisave::Vector{Cint}: an integer working array of dimension 44. if task = NEW_X, the following information is available:\nisave[22] = the total number of intervals explored in the search of Cauchy points;\nisave[26] = the total number of skipped BFGS updates before the current iteration;\nisave[30] = the number of current iteration;\nisave[31] = the total number of BFGS updates prior the current iteration;\nisave[33] = the number of intervals explored in the search of Cauchy point in the current iteration;\nisave[34] = the total number of function and gradient evaluations;\nisave[36] = the number of function value or gradient evaluations in the current iteration;\nif isave[37] = 0  then the subspace argmin is within the box;\nif isave[37] = 1  then the subspace argmin is beyond the box;\nisave[38] = the number of free variables in the current iteration;\nisave[39] = the number of active constraints in the current iteration;\nn + 1 - isave[40] = the number of variables leaving the set of active constraints in the current iteration;\nisave[41] = the number of variables entering the set of active constraints in the current iteration.\ndsave::Vector{Cdouble}: a double precision working array of dimension 29. if task = NEW_X, the following information is available:\ndsave[1] = current \'theta\' in the BFGS matrix;\ndsave[2] = f(x) in the previous iteration;\ndsave[3] = factr*epsmch;\ndsave[4] = 2-norm of the line search direction vector;\ndsave[5] = the machine precision epsmch generated by the code;\ndsave[7] = the accumulated time spent on searching for Cauchy points;\ndsave[8] = the accumulated time spent on subspace minimization;\ndsave[9] = the accumulated time spent on line search;\ndsave[11] = the slope of the line search function at the current point of line search;\ndsave[12] = the maximum relative step length imposed in line search;\ndsave[13] = the infinity norm of the projected gradient;\ndsave[14] = the relative step length in the line search;\ndsave[15] = the slope of the line search function at the starting point of the line search;\ndsave[16] = the square of the 2-norm of the line search direction vector.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#LBFGSB.timer",
    "page": "Docstrings",
    "title": "LBFGSB.timer",
    "category": "function",
    "text": "timer(x)\n\nThe double precision cpu timing subroutine in the L-BFGS-B code.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "LBFGSB.LBFGSBLBFGSB.L_BFGS_BLBFGSB.__init__LBFGSB.check_depsLBFGSB.depsjl_pathLBFGSB.evalLBFGSB.includeLBFGSB.liblbfgsbLBFGSB.setulbLBFGSB.timer"
},

]}
