<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CoordinateTransformations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoordinateTransformations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">CoordinateTransformations.AbstractAffineMap</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.AbstractTransformation" href="#CoordinateTransformations.AbstractTransformation"><code>CoordinateTransformations.AbstractTransformation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>Transformation</code> supertype defines a simple interface for performing transformations. Subtypes should be able to apply a coordinate system transformation on the correct data types by overloading the call method, and usually would have the corresponding inverse transformation defined by <code>Base.inv()</code>. Efficient compositions can optionally be defined by <code>compose()</code> (equivalently <code>∘</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.AffineMap" href="#CoordinateTransformations.AffineMap"><code>CoordinateTransformations.AffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AffineMap &lt;: AbstractAffineMap</code></pre><p>A concrete affine transformation.  To construct the mapping <code>x -&gt; M*x + v</code>, use</p><pre><code class="language-none">AffineMap(M, v)</code></pre><p>where <code>M</code> is a matrix and <code>v</code> a vector.  An arbitrary <code>Transformation</code> may be converted into an affine approximation by linearizing about a point <code>x</code> using</p><pre><code class="language-none">AffineMap(trans, [x])</code></pre><p>For transformations which are already affine, <code>x</code> may be omitted.</p></div></div></section><pre><code class="language-none">CoordinateTransformations.AngleAxis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.CartesianFromCylindrical" href="#CoordinateTransformations.CartesianFromCylindrical"><code>CoordinateTransformations.CartesianFromCylindrical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CartesianFromCylindrical()</code> - transformation from <code>Cylindrical</code> type to <code>SVector{3}</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.CartesianFromPolar" href="#CoordinateTransformations.CartesianFromPolar"><code>CoordinateTransformations.CartesianFromPolar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CartesianFromPolar()</code> - transformation from <code>Polar</code> type to <code>SVector{2}</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.CartesianFromSpherical" href="#CoordinateTransformations.CartesianFromSpherical"><code>CoordinateTransformations.CartesianFromSpherical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CartesianFromSpherical()</code> - transformation from <code>Spherical</code> type to <code>SVector{3}</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.ComposedTransformation" href="#CoordinateTransformations.ComposedTransformation"><code>CoordinateTransformations.ComposedTransformation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ComposedTransformation</code> simply executes two transformations successively, and is the fallback output type of <code>compose()</code>.</p></div></div></section><pre><code class="language-none">CoordinateTransformations.CoordinateTransformations</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.Cylindrical" href="#CoordinateTransformations.Cylindrical"><code>CoordinateTransformations.Cylindrical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Cylindrical(r, θ, z) - 3D cylindrical coordinates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.CylindricalFromCartesian" href="#CoordinateTransformations.CylindricalFromCartesian"><code>CoordinateTransformations.CylindricalFromCartesian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CylindricalFromCartesian()</code> - transformation from 3D point to <code>Cylindrical</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.CylindricalFromSpherical" href="#CoordinateTransformations.CylindricalFromSpherical"><code>CoordinateTransformations.CylindricalFromSpherical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>CylindricalFromSpherical()</code> - transformation from <code>Spherical</code> type to <code>Cylindrical</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.IdentityTransformation" href="#CoordinateTransformations.IdentityTransformation"><code>CoordinateTransformations.IdentityTransformation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>IdentityTransformation</code> is a singleton <code>Transformation</code> that returns the input unchanged, similar to <code>identity</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.LinearMap" href="#CoordinateTransformations.LinearMap"><code>CoordinateTransformations.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinearMap &lt;: AbstractAffineMap
LinearMap(M)</code></pre><p>A general linear transformation, constructed using <code>LinearMap(M)</code> for any matrix-like object <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.PerspectiveMap" href="#CoordinateTransformations.PerspectiveMap"><code>CoordinateTransformations.PerspectiveMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PerspectiveMap()</code></pre><p>Construct a perspective transformation. The persepective transformation takes, e.g., a point in 3D space and &quot;projects&quot; it onto a 2D virtual screen of an ideal pinhole camera (at distance <code>1</code> away from the camera). The camera is oriented towards the positive-Z axis (or in general, along the final dimension) and the sign of the <code>x</code> and <code>y</code> components is preserved for objects in front of the camera (objects behind the camera are also projected and therefore inverted - it is up to the user to cull these as necessary).</p><p>This transformation is designed to be used in composition with other coordinate transformations, defining e.g. the position and orientation of the camera. For example:</p><pre><code class="language-none">cam_transform = PerspectiveMap() ∘ inv(AffineMap(cam_rotation, cam_position))
screen_points = map(cam_transform, points)</code></pre><p>(see also <code>cameramap</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.Polar" href="#CoordinateTransformations.Polar"><code>CoordinateTransformations.Polar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Polar{T}(r::T, θ::T)</code> - 2D polar coordinates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.PolarFromCartesian" href="#CoordinateTransformations.PolarFromCartesian"><code>CoordinateTransformations.PolarFromCartesian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PolarFromCartesian()</code> - transformation from <code>AbstractVector</code> of length 2 to <code>Polar</code> type</p></div></div></section><pre><code class="language-none">CoordinateTransformations.Quat</code></pre><pre><code class="language-none">CoordinateTransformations.RodriguesVec</code></pre><pre><code class="language-none">CoordinateTransformations.RotMatrix</code></pre><pre><code class="language-none">CoordinateTransformations.RotX</code></pre><pre><code class="language-none">CoordinateTransformations.RotXY</code></pre><pre><code class="language-none">CoordinateTransformations.RotXYX</code></pre><pre><code class="language-none">CoordinateTransformations.RotXYZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotXZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotXZX</code></pre><pre><code class="language-none">CoordinateTransformations.RotXZY</code></pre><pre><code class="language-none">CoordinateTransformations.RotY</code></pre><pre><code class="language-none">CoordinateTransformations.RotYX</code></pre><pre><code class="language-none">CoordinateTransformations.RotYXY</code></pre><pre><code class="language-none">CoordinateTransformations.RotYXZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotYZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotYZX</code></pre><pre><code class="language-none">CoordinateTransformations.RotYZY</code></pre><pre><code class="language-none">CoordinateTransformations.RotZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotZX</code></pre><pre><code class="language-none">CoordinateTransformations.RotZXY</code></pre><pre><code class="language-none">CoordinateTransformations.RotZXZ</code></pre><pre><code class="language-none">CoordinateTransformations.RotZY</code></pre><pre><code class="language-none">CoordinateTransformations.RotZYX</code></pre><pre><code class="language-none">CoordinateTransformations.RotZYZ</code></pre><pre><code class="language-none">CoordinateTransformations.SpQuat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.Spherical" href="#CoordinateTransformations.Spherical"><code>CoordinateTransformations.Spherical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Spherical(r, θ, ϕ) - 3D spherical coordinates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.SphericalFromCartesian" href="#CoordinateTransformations.SphericalFromCartesian"><code>CoordinateTransformations.SphericalFromCartesian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SphericalFromCartesian()</code> - transformation from 3D point to <code>Spherical</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.SphericalFromCylindrical" href="#CoordinateTransformations.SphericalFromCylindrical"><code>CoordinateTransformations.SphericalFromCylindrical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SphericalFromCylindrical()</code> - transformation from <code>Cylindrical</code> type to <code>Spherical</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.Transformation" href="#CoordinateTransformations.Transformation"><code>CoordinateTransformations.Transformation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>Transformation</code> supertype defines a simple interface for performing transformations. Subtypes should be able to apply a coordinate system transformation on the correct data types by overloading the call method, and usually would have the corresponding inverse transformation defined by <code>Base.inv()</code>. Efficient compositions can optionally be defined by <code>compose()</code> (equivalently <code>∘</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.Translation" href="#CoordinateTransformations.Translation"><code>CoordinateTransformations.Translation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Translation(v) &lt;: AbstractAffineMap
Translation(dx, dy)       (2D)
Translation(dx, dy, dz)   (3D)</code></pre><p>Construct the <code>Translation</code> transformation for translating Cartesian points by an offset <code>v = (dx, dy, ...)</code></p></div></div></section><pre><code class="language-none">CoordinateTransformations._dep_message_AbstractTransformation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.cameramap" href="#CoordinateTransformations.cameramap"><code>CoordinateTransformations.cameramap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cameramap()
cameramap(scale)
cameramap(scale, offset)</code></pre><p>Create a transformation that takes points in real space (e.g. 3D) and projects them through a perspective transformation onto the focal plane of an ideal (pinhole) camera with the given properties.</p><p>The <code>scale</code> sets the scale of the screen. For a standard digital camera, this would be <code>scale = focal_length / pixel_size</code>. Non-square pixels are supported by providing a pair of scales in a tuple, <code>scale = (scale_x, scale_y)</code>. Positive scales represent a camera looking in the +z axis with a virtual screen in front of the camera (the x,y coordinates are not inverted compared to 3D space). Note that points behind the camera (with negative z component) will be projected (and inverted) onto the image coordinates and it is up to the user to cull such points as necessary.</p><p>The <code>offset = (offset_x, offset_y)</code> is used to define the origin in the imaging plane. For instance, you may wish to have the point (0,0) represent the top-left corner of your imaging sensor. This measurement is in the units after applying <code>scale</code> (e.g. pixels).</p><p>(see also <code>PerspectiveMap</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.compose" href="#CoordinateTransformations.compose"><code>CoordinateTransformations.compose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compose(trans1, trans2)
trans1 ∘ trans2</code></pre><p>Take two transformations and create a new transformation that is equivalent to successively applying <code>trans2</code> to the coordinate, and then <code>trans1</code>. By default will create a <code>ComposedTransformation</code>, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).</p></div></div></section><pre><code class="language-none">CoordinateTransformations.eval</code></pre><pre><code class="language-none">CoordinateTransformations.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.recenter" href="#CoordinateTransformations.recenter"><code>CoordinateTransformations.recenter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recenter(trans::Union{AbstractMatrix,Transformation}, origin::AbstractVector) -&gt; ctrans</code></pre><p>Return a new transformation <code>ctrans</code> such that point <code>origin</code> serves as the origin-of-coordinates for <code>trans</code>. Translation by <code>±origin</code> occurs both before and after applying <code>trans</code>, so that if <code>trans</code> is linear we have</p><pre><code class="language-none">ctrans(origin) == origin</code></pre><p>As a consequence, <code>recenter</code> only makes sense if the output space of <code>trans</code> is isomorphic with the input space.</p><p>For example, if <code>trans</code> is a rotation matrix, then <code>ctrans</code> rotates space around <code>origin</code>.</p></div></div></section><pre><code class="language-none">CoordinateTransformations.transform</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.transform_deriv" href="#CoordinateTransformations.transform_deriv"><code>CoordinateTransformations.transform_deriv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transform_deriv(trans::Transformation, x)</code></pre><p>A matrix describing how differentials on the parameters of <code>x</code> flow through to the output of transformation <code>trans</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoordinateTransformations.transform_deriv_params" href="#CoordinateTransformations.transform_deriv_params"><code>CoordinateTransformations.transform_deriv_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transform_deriv_params(trans::AbstractTransformation, x)</code></pre><p>A matrix describing how differentials on the parameters of <code>trans</code> flow through to the output of transformation <code>trans</code> given input <code>x</code>.</p></div></div></section><pre><code class="language-none">CoordinateTransformations.∘</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
