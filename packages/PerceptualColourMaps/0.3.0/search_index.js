var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#PerceptualColourMaps-1",
    "page": "Readme",
    "title": "PerceptualColourMaps",
    "category": "section",
    "text": ""
},

{
    "location": "#(Perceptual-Color-Maps)-1",
    "page": "Readme",
    "title": "(Perceptual Color Maps)",
    "category": "section",
    "text": "(Image: Build Status)(Image: banner image)"
},

{
    "location": "#Installation-1",
    "page": "Readme",
    "title": "Installation",
    "category": "section",
    "text": "Install via the package manager.  Currently the package only runs under v0.6julia>  Pkg.add(\"PerceptualColourMaps\")If you are after the latest master use:julia>  Pkg.clone(\"https://github.com/peterkovesi/PerceptualColourMaps.jl\")"
},

{
    "location": "#Summary-1",
    "page": "Readme",
    "title": "Summary",
    "category": "section",
    "text": "The Perceptual Colour/Color Maps package provides functions for creating high quality colour maps that have consistent perceptual contrast over their full range.  It also provides functions for generating colour map test images, functions to assist with the correct rendering of data with colour maps, and functions for generating relief shaded images and perceptually uniform ternary images.Many colour maps provided by vendors have highly uneven perceptual contrast over their range. Colour maps may have points of locally high colour contrast leading to the perception of false anomalies in your data when there is none. Conversely colour maps may also have \'flat spots\' of low perceptual contrast that prevent you from seeing features in the data.To illustrate this the colour maps shown below are rendered on a test image consisting of a sine wave superimposed on a ramp function. The amplitude of the sine wave is modulated from its full value at the top of the image to 0 at the bottom.What we are hoping to see is the sine wave uniformly visible across the image from left to right. We also want the contrast level, the distance down the image at which the sine wave remains discernible, to be uniform across the image. At the very bottom of the image, where the sine wave amplitude is 0, we just have a linear ramp which simply reproduces the colour map. Given that the underlying data is a featureless ramp, we should not perceive any identifiable features across the bottom of the image.(Image: Vendor Colour Map Problem)At the top row of the test image, the sine wave amplitude from peak to trough is 10% of the total data range. It is not unusual for the sine wave pattern to completely disappear in parts of some vendor colour maps. On the other hand the perceptually uniform colour maps exhibit no false features and the sine wave pattern is uniformly visible across the full width of the test image.Previous work that has tried to use CIELAB space for the design of colour maps has had mixed results.  This is because CIELAB space is only perceptually uniform for large patches of colour presented at very low spatial frequencies.  The key observation is that at fine spatial frequencies perceptual contrast is dominated by lightness difference; chroma and hue are relatively unimportant.  The colour maps generated by cmap() are designed to have a lightness gradient of constant magnitude."
},

{
    "location": "#cmap()-1",
    "page": "Readme",
    "title": "cmap()",
    "category": "section",
    "text": "cmap() is the main function you will use.  It provides a library of perceptually uniform colour maps.  For a full description of all the functions in the package, see the Function reference.Usage:  1:  map = cmap(I, keyword_params ...)\n        2:  (map, name, desc) = cmap(I, keyword_params ..., returnname=true)\n        3:  cmap(searchStr)\n        4:  cmap()\n\nArguments for Usage 1 and 2:\n\n            I - A string label indicating the colour map to be generated or a\n                string specifying a colour map name or attribute to search\n                for.  Type \'cmap()\' with no arguments to get a full list of\n                possible colour maps and their corresponding labels.\n\n  labels:  \"L1\" - \"L15\"  for linear maps\n           \"D1\" - \"D12\"  for diverging maps\n           \"C1\" - \"C9\"   for cyclic maps\n           \"R1\" - \"R3\"   for rainbow maps\n           \"I1\" - \"I3\"   for isoluminant maps\n\n Some colour maps have alternate labels for convenience and readability.\n\n   map = cmap(\"L1\")  or map = cmap(\"grey\")  will produce a linear grey map.\n   cmap()  lists all colour maps and labels.\n\n Possible keyword parameter options:\n\n    chromaK::Real - The scaling to apply to the chroma values of the colour map,\n                    0 - 1.  The default is 1 giving a fully saturated colour map\n                    as designed. However, depending on your application you may\n                    want a colour map with reduced chroma/saturation values.\n                    You can use values greater than 1 however gamut clipping is\n                    likely to occur giving rise to artifacts in the colour map.\n           N::Int - Number of values in the colour map. Defaults to 256.\n      shift::Real - Fraction of the colour map length N that the colour map is\n                    to be cyclically rotated, may be negative.  (Should only be\n                    applied to cyclic colour maps!). Defaults to 0.\n    reverse::Bool - If true reverses the colour map. Defaults to false.\ndiagnostics::Bool - If true displays various diagnostic plots. Note the\n                    diagnostic plots will be for the map _before_ any cyclic\n                    shifting or reversing is applied. Defaults to false.\n returnname::Bool - If true the function returns a tuple of the colourmap, its\n                    name and its description  (colourmap, name, description)\n                    The default value is false, just the colourmap is returned.\n\nReturns:\n          map - Array of ColorTypes.RGBA{Float64,1} giving the rgb colour map.\n\n     If returnname=true the function additionally returns\n         name - A string giving a nominal name for the colour map\n         desc - A string giving a brief description of the colour mapUsage 3 and 4:  cmap(searchStr)Given the large number of colour maps that this function can create this usage option provides some help by listing the numbers of all the colour maps with names containing the string \'str\'.  Typically this is used to search for colour maps having a specified attribute: \"linear\", \"diverging\", \"rainbow\", \"cyclic\", or \"isoluminant\" etc.  If \'searchStr\' is omitted all colour maps are listed.     cmap()              # lists all colour maps\n   cmap(\"diverging\")   # lists all diverging colour mapsNote the listing of colour maps can be a bit slow because each colour map has to be created in order to determine its full name.Using the colour maps:PyPlot:> using PyPlot\n> sr = sineramp();    # Generate the sineramp() colour map test image.\n> imshow(sr);         # Display with matplotlib\'s default \'jet\' colour map.\n                      # Note the perceptual dead spots in the map.\n> imshow(sr, cmap = ColorMap(cmap(\"L3\"))); # Apply the cmap() heat colour map.Plots:> using Plots\n> y=rand(100);\n> Plots.scatter(y, zcolor=y, marker=ColorGradient(cmap(\"R3\")));Winston:> Using Winston\n> colormap(cmap(\"R1\"));    # Set Winston\'s colour map to the cmap() rainbow\n                           # colour map first.\n> imagesc(sr);             # Then display the imageYou can also apply a colour map to a single channel image to create a conventional RGB image. This is recommended if you are using a diverging or cyclic colour map because it allows you to ensure data values are honoured appropriately when you map them to colours.  Apply the L4 heat colour map to the test image\n> rgbimg = applycolourmap(sr, cmap(\"L4\")[1]);\n\n  Apply a diverging colour map to the test image using 127 as the\n  value that is associated with the centre point of the diverging\n  colour map\n> rgbimg = applydivergingcolourmap(sr, cmap(\"D1\")[1],127);\n\n  Apply a cyclic colour map to the circlesineramp() test image specifying\n  a data cyclelength of 2*pi.\n> (cr,) = circlesineramp();   # Generate a cyclic colour map test image.\n> rgbimg = applycycliccolourmap(cr, cmap(\"C1\")[1], cyclelength=2*pi);\n\n> ImageView.view(rgbimg)      # Display the image with ImageView\n> PyPlot.imshow(rgbimg)       # or with PyPlotWarning PyPlot and Tk do not seem to coexist very well (Julia can crash!).  ImageView and Winston use Tk which means that you may have to take care which image display functions you choose to use.These colour maps can also be passed to the Plots.ColorGradient constructor. Here\'s an example using the \'Rainbow 3\' diverging colour map for a scatter plot.> Using Plots\n> y=rand(100); scatter(y, zcolor=y, marker=ColorGradient(cmap(\"R3\")[1]))"
},

{
    "location": "#Organisation-of-the-Colour-Maps-1",
    "page": "Readme",
    "title": "Organisation of the Colour Maps",
    "category": "section",
    "text": "The colour maps are organised according to the attributes: Linear, Diverging, Rainbow, Cyclic, and Isoluminant.(Image: Linear Colour Map)Linear colour maps are intended for general use and have colour lightness values that increase or decrease linearly over the colour map\'s range.(Image: Diverging Colour Map)Diverging colour maps are suitable where the data being displayed has a well defined reference value and we are interested in differentiating values that lie above, or below, the reference value. The centre point of the colour map will be white, black or grey. cmap() provides diverging maps that have endpoints that are matched in both lightness and chroma.  It should be noted that, in general, diverging colour maps have a small perceptual flat spot at the centre. The exception being linear-diverging maps which avoid this problem, try cmap(\"D7\").(Image: Rainbow Colour Map)Rainbow colour maps are widely used but often misused. It is suggested that they be avoided because they have reversals in the lightness gradient at yellow and red which can upset a viewer\'s perceptual ordering of the colours in the colour map. However, they are attractive and perhaps can have a legitimate use where the main aim is to differentiate data values rather than communicate a data ordering. I believe the rainbow colour maps generated by cmap() (\"R1\" or \"R2\") have minimal badness though they do have localised perceptual flat spots at yellow and red. cmap(\"R3\") is a useful diverging rainbow colour map.(Image: Cyclic Colour Map)Cyclic colour maps have colours that are matched at each end. They are intended for the presentation of data that is cyclic such as orientation values or angular phase data. They require particular care in their design (the standard colour circle is not a good map). cmap() provides cyclic maps that partition the circle into four colours, suitable for visualising orientation data (try cmap(\"C1\")), and into two colours for visualising phase data (try cmap(\"C4\")).(Image: Isoluminant Colour Map)Isoluminant colour maps are constructed from colours of equal perceptual lightness. These colour maps are designed for use with relief shading. On their own these colour maps are not very useful because features in the data are very hard to discern. However, when used in conjunction with relief shading their constant lightness means that the colour map does not induce an independent shading pattern that can interfere with, or even hide, the structures induced by the relief shading. The relief shading provides the structural information and the colours provide the data classification information.(Image: Colour Blind Colour Map)Colour Blind colour maps. These are not designed to be merely \'colour blind safe\'. These maps have been constructed to lie within either the 2D model of protanopic/deuteranopic colour space, or the 2D model of tritanopic colour space.  Hopefully by working within these colour spaces people who are colour blind will be able to share a common perceptual interpretation of data with those who have normal colour vision.  It also ensures maximal use of the available colour spaces, and allows chroma and lightness to be properly used in the design of colour maps.  I would value any feedback on the usefulness, or otherwise, of these maps."
},

{
    "location": "#Links-1",
    "page": "Readme",
    "title": "Links",
    "category": "section",
    "text": "Function reference\nMATLAB codefrom which this Julia code was ported.A set of perceptually uniform colour map files prepared for use with a number of standard visualisation packages.\nReference: Peter Kovesi. Good Colour Maps: How to Design Them. arXiv:1509.03700 [cs.GR] 2015"
},

{
    "location": "autodocs/#PerceptualColourMaps.PerceptualColourMaps",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.PerceptualColourMaps",
    "category": "module",
    "text": "PerceptualColourMaps\n\nPerceptually Uniform Colour maps\n\nPeter Kovesi\n\npeterkovesi.com\n\nColour Map Generation and Application\n\ncmap - Library of perceptually uniform colour maps.\nequalisecolourmap - Equalise colour contrast over a colour map.\nlinearrgbmap - Linear rgb colourmap from black to a specified colour.\napplycolourmap - Applies colourmap to a single channel image to obtain an RGB result.\napplycycliccolourmap - Applies a cyclic colour map to an image of angular data.\napplydivergingcolourmap - Applies a diverging colour map to an image.\nternaryimage - Perceptualy uniform ternary image from 3 bands of data.\nrelief - Generates a relief shaded image.\nviewlabspace - Visualisation of Lab colour space.\n\nImages for testing colour maps\n\nsineramp - Generates sine on a ramp colour map test image.\ncirclesineramp - Generates a test image for evaluating cyclic colour maps.\n\nUtilities\n\nhisttruncate - Truncates ends of an image histogram.\nnormalise - Normalises image values to 0-1, or to desired mean and variance.\nsrgb2lab - Convert RGB colour map or RGB image to Lab.\nlab2srgb - Convert Lab colour map or Lab image to RGB.\n\nReference:\n\nGood Colour Maps: How to Design Them.  arXiv:1509.03700 [cs.GR] 2015.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.RGBA2UInt32",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.RGBA2UInt32",
    "category": "function",
    "text": "Convert an array of ColorTypes RGB values to an array of UInt32 values for use as a colour map in Winston\n\n Usage:  uint32rgb = RGBA2UInt32(rgbmap)\n\n Argument:   rgbmap - Vector of ColorTypes.RGBA values as\n                      returned by cmap().\n\n Returns: uint32rgb - An array of UInt32 values packed with the 8 bit RGB values.\n\nSee also: cmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applycolormap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applycolormap",
    "category": "function",
    "text": "applycolormap: Applies colourmap to a single channel image to obtain an RGB result\n\nUsage: rgbimg = applycolormap(img, cmap, rnge)\n\nArguments:  img - Single channel image to apply colourmap to.\n                  ::ImageMeta{T,2} or ::Array{Float64,2}\n           cmap - RGB colourmap as generated by cmap().\n                  ::Array{ColorTypes.RGBA{Float64},1}\n           rnge - Optional 2-vector specifying the min and max values in\n                  the image to be mapped across the colour map.  Values\n                  outside this range are mapped to the end points of the\n                  colour map.  If range is omitted the full range\n                  of image values are used.\n\nReturns: rgbimg - RGB image of floating point values in the range 0-1.\n                  NaN values in the input image are rendered as black.\n                  ::ImageMeta{Float64,3} or ::Array{Float64,3}\n\nFor full documentation see applycolourmap\n                                    ^\n\nSee also: cmap, applycycliccolourmap, applydivergingcolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applycolourmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applycolourmap",
    "category": "function",
    "text": "applycolourmap/applycolormap: Applies colourmap to a single channel image to obtain an RGB result\n\nUsage: rgbimg = applycolourmap(img, cmap, rnge)\n\nArguments:  img - Single channel image to apply colourmap to.\n                  ::ImageMeta{T,2} or ::Array{Float64,2}\n           cmap - RGB colourmap as generated by cmap().\n                  ::Array{ColorTypes.RGBA{Float64},1}\n           rnge - Optional 2-vector specifying the min and max values in\n                  the image to be mapped across the colour map.  Values\n                  outside this range are mapped to the end points of the\n                  colour map.  If range is omitted the full range\n                  of image values are used.\n\nReturns: rgbimg - RGB image of floating point values in the range 0-1.\n                  NaN values in the input image are mapped to black.\n                  ::ImageMeta{Float64,3} or ::Array{Float64,3}\n\nWhy use this function when you can simply set a colour map?\n\nWell, actually you probably want to use the functions applycycliccolourmap() and applydivergingcolourmap() which make use of this function.\n\nMany visualisation packages may automatically apply an offset and perform some scaling of your data to normalise it to a range of, say, 0-255 before applying a colour map and rendering it on your screen. In many cases this is useful. However, if you are wanting to render your data with a diverging or cyclic colour map then this behaviour is definitely not appropriate because these types of colour maps requires that data values are honoured in some way to make any sense.\n\nBy providing a \'range\' parameter this function allows you to apply a colour map in a way that respects your data values.\n\nSee also: cmap, applycycliccolourmap, applydivergingcolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applycycliccolormap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applycycliccolormap",
    "category": "function",
    "text": "applycycliccolormap:  Applies a cyclic colour map to an image of angular data\n\nFor full documentation see applycycliccolourmap\n                                          ^\n\nSee also: applycolourmap, applydivergingcolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applycycliccolourmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applycycliccolourmap",
    "category": "function",
    "text": "applycycliccolourmap/applycycliccolormap: Applies a cyclic colour map to an image of angular data\n\nFor angular data to be rendered correctly it is important that the data values are respected so that data values are correctly assigned to specific entries in a cyclic colour map.  The assignment of values to colours also depends on whether the data is cyclic over pi, or 2*pi.\n\nIn contrast, default display methods typically do not respect data values directly and can perform inappropriate offsetting and normalisation of the angular data before display and rendering with a colour map.\n\nThe rendering of the angular data with a specified colour map can be modulated as a function of an associated image amplitude.  This allows the colour map encoding of the angular information to be modulated to represent the amplitude/reliability/coherence of the angular data.\n\nUsage: rgbimg = applycycliccolourmap(ang, cmap)\n       rgbimg = applycycliccolourmap(ang, cmap, keyword args ...)\n\nArguments:\n           ang - Image of angular data to be rendered\n                 ::ImageMeta or ::Array{Float64,2}\n          cmap - Cyclic colour map to render the angular data with.\n\nKeyword arguments:\n\n           amp - Amplitude image used to modulate the mapped colours of the\n                 angular data.  If not supplied no modulation of colours is\n                 performed.\n                 ::ImageMeta or ::Array{Float64,2}\n   modtoblack  - Boolean flag/1 indicating whether the amplitude image is used to\n                 modulate the colour mapped image values towards black,\n                 or towards white.  The default is true, towards black.\n   cyclelength - The cycle length of the angular data.  Use a value of pi\n                 if the data represents orientations, or 2*pi if the data\n                 represents phase values.  If the input data is in degrees\n                 simply set cycle in degrees and the data will be\n                 rendered appropriately. Default is 2*pi.\n\nReturns: rgbim - The rendered image.\n                 ::ImageMeta{Float64,3} or ::Array{Float64,3}\n\nFor a list of all cyclic colour maps that can be generated by cmap() use:\n\n> cmap(\"cyclic\")\n\nSee also: cmap, scalogram, ridgeorient, applycolourmap, applydivergingcolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applydivergingcolormap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applydivergingcolormap",
    "category": "function",
    "text": "applydivergingcolormap - Applies a diverging colour map to an image\n\nFor full documentation see applydivergingcolourmap\n                                             ^\n\nSee also: applycolourmap, applycycliccolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.applydivergingcolourmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.applydivergingcolourmap",
    "category": "function",
    "text": "applydivergingcolourmap/applydivergingcolormap - Applies a diverging colour map to an image\n\nFor data to be displayed correctly with a diverging colour map it is important that the data values are respected so that the reference value in the data is correctly associated with the centre entry of a diverging colour map.\n\nIn contrast, default display methods typically do not respect data values directly and can perform inappropriate offsetting and normalisation of the data before display and rendering with a colour map.\n\nUsage:  rgbim = applydivergingcolourmap(img, map, refval)\n\nArguments:\n           img - Image to be rendered.  ::ImageMeta or ::Array{Float64,2}\n           map - Colour map to render the data with.\n        refval - Reference value to be associated with centre point of\n                 diverging colour map.  Defaults to 0.\nReturns:\n        rgbimg - The rendered image.\n                 ::ImageMeta{Float64,3} or ::Array{Float64,3}\n\nFor a list of all diverging colour maps that can be generated by cmap() use: > cmap(\"div\")\n\nSee also: applycolourmap, applycycliccolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.bbspline",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.bbspline",
    "category": "function",
    "text": "bbspline - Basic B-spline\n\nUsage:  S = bbspline(P, k, N)\n\nArguments:   P - [dim x Npts] array of control points\n             k - order of spline (>= 2).\n                 k = 2: Linear\n                 k = 3: Quadratic, etc\n             N - Optional number of points to evaluate along\n                 spline. Defaults to 100.\n\nReturns:     S - spline curve  [dim x N] spline points\n\nSee also: pbspline\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.cie76",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.cie76",
    "category": "function",
    "text": "deltaE: Compute weighted Delta E between successive entries in a colour map using the CIE76 formula + weighting\n\nUsage: deltaE = cie76(L::Array, a::Array, b::Array, W::Array)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.ciede2000",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.ciede2000",
    "category": "function",
    "text": "ciede2000: Compute weighted Delta E between successive entries in a colour map using the CIEDE2000 formula + weighting\n\nUsage: deltaE = ciede2000(L::Array, a::Array, b::Array, W::Array)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.circlesineramp",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.circlesineramp",
    "category": "function",
    "text": "circlesineramp - Generates a test image for evaluating cyclic colour maps\n\nUsage: (img, alpha) = circlesineramp(sze, amp, wavelen, p, hole)\n       (img, alpha) = circlesineramp()\n\nArguments:     sze - Size of test image.  Defaults to 512x512.\n               amp - Amplitude of sine wave. Defaults to pi/10\n           wavelen - Wavelength of sine wave at half radius of the\n                     circular test image. Defaults to 8 pixels.\n                 p - Power to which the linear attenuation of amplitude,\n                     from outside edge to centre, is raised.  For no\n                     attenuation use p = 0.  For linear attenuation use a\n                     value of 1.  The default value is 2, quadratic\n                     attenuation.\n              hole - Boolean flag indicating whether the test image should have\n                     a \'hole\' in its centre.  The default is true, to have a\n                     hole, this removes the distraction of the orientation\n                     singularlity at the centre.\nReturns:\n                im - The test image.\n             alpha - Alpha mask matching the regions outside of of the\n                     circular test image that are set to NaN.  Used if you\n                     want to write an image with these regions transparent.\n\nThe test image is a circular pattern consistsing of a sine wave superimposed on a spiral ramp function.  The spiral ramp starts at a value of 0 pointing right, increasing anti-clockwise to a value of 2pi as it completes the full circle. This gives a 2pi discontinuity on the right side of the image.  The amplitude of the superimposed sine wave is modulated from its full value at the outside of the circular pattern to 0 at the centre.  The default sine wave amplitude of pi/10 means that the overall size of the sine wave from peak to trough represents 2(pi/10)/(2pi) = 10% of the total spiral ramp of 2*pi.  If you are testing your colour map over a cycle of pi you should use amp = pi/20 to obtain an equivalent ratio of sine wave to circular ramp.\n\nThe image is designed for evaluating the effectiveness of cyclic colour maps. It is the cyclic companion to sineramp().  Ideally the sine wave pattern should be equally discernible over all angles around the test image.  In practice many colourmaps have uneven perceptual contrast over their range and often include \'flat spots\' of no perceptual contrast that can hide significant features.  Try a HSV colour map.\n\nIdeally the test image should be rendered with a cyclic colour map using showangularim() though, in this case, rendering the image with SHOW or IMAGESC will also be fine because all image values lie within, and use the full range of, 0-2*pi.  However, in general, default display methods typically do not respect data values directly and can perform inappropriate offsetting and normalisation of the angular data before display and rendering with a colour map.\n\nFor angular data to be rendered correctly it is important that the data values are respected so that data values are correctly assigned to specific entries in a cyclic colour map.  The assignment of values to colours also depends on whether the data is cyclic over pi, or 2*pi.  SHOWANGULARIM supports this.\n\nSee also: applycycliccolourmap, sineramp, chirplin, chirpexp, equalisecolourmap, cmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.cmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.cmap",
    "category": "function",
    "text": "cmap:  Library of perceptually uniform colour maps\n\nMost of these colour maps have been designed to have constant a magnitude of lightness gradient.  At fine spatial frequencies perceptual contrast is dominated by lightness difference, chroma and hue are relatively unimportant.\n\nUsage:  1:  map = cmap(I, keyword_params ...)\n        2:  (map, name, desc) = cmap(I, keyword_params ..., returnname=true)\n        3:  cmap(searchStr)\n        4:  cmap()\n\nArguments for Usage 1 and 2:\n\n            I - A string label indicating the colour map to be generated or a\n                string specifying a colour map name or attribute to search\n                for.  Type \'cmap()\' with no arguments to get a full list of\n                possible colour maps and their corresponding labels.\n\n  labels:  \"L1\" - \"L19\"  for linear maps\n           \"D1\" - \"D13\"  for diverging maps\n           \"C1\" - \"C9\"   for cyclic maps\n           \"R1\" - \"R3\"   for rainbow maps\n           \"I1\" - \"I3\"   for isoluminant maps\n\n  labels for generating maps for the colour blind:\n           \"CBL1\"  - \"CBL4\" Linear maps for protanopic and deuteranopic viewers.\n           \"CBD1\"  - \"CBD2\" Diverging maps for protanopic and deuteranopic viewers.\n           \"CBC1\"  - \"CBC2\" Cyclic maps for protanopic and deuteranopic viewers.\n           \"CBTL1\" - \"CBTL4\" Linear maps for tritanopic viewers.\n           \"CBTD1\" - Diverging map for tritanopic viewers.\n           \"CBTC1\" - \"CBTC2\" Cyclic maps for tritanopic viewers.\n\n\n Some colour maps have alternate labels for convenience and readability.\n\n   map = cmap(\"L1\")  or map = cmap(\"grey\")  will produce a linear grey map.\n   cmap()  lists all colour maps and labels.\n\n Possible keyword parameter options:\n\n    chromaK::Real - The scaling to apply to the chroma values of the colour map,\n                    0 - 1.  The default is 1 giving a fully saturated colour map\n                    as designed. However, depending on your application you may\n                    want a colour map with reduced chroma/saturation values.\n                    You can use values greater than 1 however gamut clipping is\n                    likely to occur giving rise to artifacts in the colour map.\n           N::Int - Number of values in the colour map. Defaults to 256.\n      shift::Real - Fraction of the colour map length N that the colour map is\n                    to be cyclically rotated, may be negative.  (Should only be\n                    applied to cyclic colour maps!). Defaults to 0.\n    reverse::Bool - If true reverses the colour map. Defaults to false.\ndiagnostics::Bool - If true displays various diagnostic plots. Note the\n                    diagnostic plots will be for the map _before_ any cyclic\n                    shifting or reversing is applied. Defaults to false.\n returnname::Bool - If true the function returns a tuple of the colourmap, its\n                    name and its description  (colourmap, name, description)\n                    The default value is false, just the colourmap is returned.\n\nReturns:\n          map - Array of ColorTypes.RGBA{Float64,1} giving the rgb colour map.\n\n     If returnname=true the function additionally returns\n         name - A string giving a nominal name for the colour map\n         desc - A string giving a brief description of the colour map\n\nUsage 3 and 4:  cmap(searchStr)\n\nGiven the large number of colour maps that this function can create this usage option provides some help by listing the numbers of all the colour maps with names containing the string \'str\'.  Typically this is used to search for colour maps having a specified attribute: \"linear\", \"diverging\", \"rainbow\", \"cyclic\", or \"isoluminant\" etc.  If \'searchStr\' is omitted all colour maps are listed.\n\n   cmap()              # lists all colour maps\n   cmap(\"diverging\")   # lists all diverging colour maps\n\nNote the listing of colour maps can be a bit slow because each colour map has to be created in order to determine its full name.\n\nUsing the colour maps:\n\nPyPlot:\n\n> using PyPlot\n> sr = sineramp();    # Generate the sineramp() colour map test image.\n> imshow(sr);         # Display with matplotlib\'s default \'jet\' colour map.\n                      # Note the perceptual dead spots in the map.\n> imshow(sr, cmap = ColorMap(cmap(\"L3\"))); # Apply the cmap() heat colour map.\n\nPlots:\n\n> using Plots\n> y=rand(100);\n> Plots.scatter(y, zcolor=y, marker=ColorGradient(cmap(\"R3\")));\n\nYou can also apply a colour map to a single channel image to create a conventional RGB image. This is recommended if you are using a diverging or cyclic colour map because it allows you to ensure data values are honoured appropriately when you map them to colours.\n\n  Apply the L4 heat colour map to the test image\n> rgbimg = applycolourmap(sr, cmap(\"L4\"));\n\n  Apply a diverging colour map to the test image using 127 as the\n  value that is associated with the centre point of the diverging\n  colour map\n> rgbimg = applydivergingcolourmap(sr, cmap(\"D1\"),127);\n\n  Apply a cyclic colour map to the circlesineramp() test image specifying\n  a data cyclelength of 2*pi.\n> (cr,) = circlesineramp();   # Generate a cyclic colour map test image.\n> rgbimg = applycycliccolourmap(cr, cmap(\"C1\"), cyclelength=2*pi);\n\n> ImageView.view(rgbimg)      # Display the image with ImageView\n> PyPlot.imshow(rgbimg)       # or with PyPlot\n\nWarning PyPlot and Tk do not seem to coexist very well (Julia can crash!).  ImageView and Winston use Tk which means that you may have to take care which image display functions you choose to use.\n\nColour Map naming convention:\n\n                    linear_kryw_5-100_c67_n256\n                      /      /    |    \\    \\\n  Colour Map attribute(s)   /     |     \\   Number of colour map entries\n                           /      |      \\\n     String indicating nominal    |      Mean chroma of colour map\n     hue sequence.                |\n                              Range of lightness values\n\nIn addition, the name of the colour map may have cyclic shift information appended to it, it may also have a flag indicating it is reversed.\n\n              cyclic_wrwbw_90-40_c42_n256_s25_r\n                                          /    \\\n                                         /   Indicates that the map is reversed.\n                                        /\n                  Percentage of colour map length\n                  that the map has been rotated by.\n\nAttributes may be: linear, diverging, cyclic, rainbow, or isoluminant.  A\n\ncolour map may have more than one attribute. For example, diverging-linear or cyclic-isoluminant.\n\nLightness values can range from 0 to 100. For linear colour maps the two\n\nlightness values indicate the first and last lightness values in the map. For diverging colour maps the second value indicates the lightness value of the centre point of the colour map (unless it is a diverging-linear colour map). For cyclic and rainbow colour maps the two values indicate the minimum and maximum lightness values. Isoluminant colour maps have only one lightness value.\n\nThe string of characters indicating the nominal hue sequence uses\n\nthe following code\n\n      r - red      g - green      b - blue\n      c - cyan     m - magenta    y - yellow\n      o - orange   v - violet\n      k - black    w - white      j - grey\n\n(\'j\' rhymes with grey). Thus a \'heat\' style colour map would be indicated by the string \'kryw\'. If the colour map is predominantly one colour then the full name of that colour may be used. Note these codes are mainly used to indicate the hues of the colour map independent of the lightness/darkness and saturation of the colours.\n\nMean chroma/saturation is an indication of vividness of the colour map. A\n\nvalue of 0 corresponds to a greyscale. A value of 50 or more will indicate a vivid colour map.\n\nAdding your own colour maps is straightforward. See comments within the code for instructions for doing this.\n\nReference: Peter Kovesi. Good Colour Maps: How to Design Them. arXiv:1509.03700 [cs.GR] 2015\n\nSee also: equalisecolourmap, viewlabspace, sineramp, circlesineramp, applycolourmap, applycycliccolourmap, applydivergingcolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.equalisecolourmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.equalisecolourmap",
    "category": "function",
    "text": "equalisecolourmap/equalizecolormap - Equalise colour contrast over a colour map\n\nThis function is used by cmap() and you would not normally call this function directly. However, you may want to try using this function to equalise the perceptual contrast of colour maps obtained from some other source.\n\nUsage: newrgbmap = equalisecolourmap(rgblab, map, formula, W, sigma, diagnostics)\n                   equalizecolormap(....\n\nArguments:     rgblab - String \"RGB\" or \"LAB\" indicating the type of data\n                        in map.\n                  map - A Nx3 RGB or CIELAB colour map\n                        or an array of ColorTypes.RGBA{Float64} values\n              formula - String \"CIE76\" or \"CIEDE2000\"\n                    W - A 3-vector of weights to be applied to the\n                        lightness, chroma and hue components of the\n                        difference equation. It is recommended that you\n                        use [1, 0, 0] to only take into account lightness.\n                        If desired use  [1, 1, 1] for the full formula.\n                        See note below.\n                sigma - Optional Gaussian smoothing parameter, see\n                        explanation below.\n               cyclic - Boolean flag indicating whether the colour map is\n                        cyclic. This affects how smoothing is applied at\n                        the end points.\n          diagnostics - Optional boolean flag indicating whether diagnostic\n                        plots should be displayed.  Defaults to false.\n\nReturns:    newrgbmap - RGB colour map adjusted so that the perceptual\n                        contrast of colours along the colour map is constant.\n                        This is a Nx3 Array of Float64 values.\n\nSuggested parameters:\n\nThe CIE76 and CIEDE2000 colour difference formulas were developed for much lower spatial frequencies than we are typically interested in. Neither is ideal for our application.  The main thing to note is that at fine spatial frequencies perceptual contrast is dominated by lightness difference, chroma and hue are relatively unimportant.\n\nFor colour maps with a significant range of lightness use:\n\n                       formula = \"CIE76\" or \"CIEDE2000\"\n                             W = [1, 0, 0]  (Only correct for lightness)\n                         sigma = 5 - 7\n\nFor isoluminant or low lightness gradient colour maps use:\n\n                       formula = \"CIE76\"\n                             W = [1, 1, 1]  (Correct for colour and lightness)\n                         sigma = 5 - 7\n\nIdeally, for a colour map to be effective the perceptual contrast along the colour map should be constant.  Many colour maps are very poor in this regard. Try testing your favourite colour map on the sineramp() test image.  The perceptual contrast is very much dominated by the contrast in colour lightness values along the map.  This function attempts to equalise the chosen perceptual contrast measure along a colour map by stretching and/or compressing sections of the colour map.\n\nThis function\'s primary use is for the correction of colour maps generated by cmap() however it can be applied to any colour map.  There are limitations to what this function can correct.  When applied to some of MATLAB\'s colour maps such as \'jet\', \'hsv\' and \'cool\' you get colour discontinuity artifacts because these colour maps have segments that are nearly constant in lightness. However, it does a nice job of fixing up MATLAB\'s \'hot\', \'winter\', \'spring\' and \'autumn\' colour maps.  If you do see colour discontinuities in the resulting colour map try changing W from [1, 0, 0] to [1, 1, 1], or some intermediate weighting of [1, 0.5, 0.5], say.\n\nDifference formula: Neither CIE76 or CIEDE2000 difference measures are ideal for the high spatial frequencies that we are interested in.  Empirically I find that CIEDE2000 seems to give slightly better results on colour maps where there is a significant lightness gradient (this applies to most colour maps). In this case you would be using a weighting vector W = [1, 0, 0].  For isoluminant, or low lightness gradient colour maps where one is using a weighting vector W = [1, 1, 1] CIE76 should be used as the CIEDE2000 chroma correction is inapropriate for the spatial frequencies we are interested in.\n\nWeighting vetor W: The CIEDE2000 colour difference formula incorporates the scaling parameters kL, kC, kH in the demonimator of the lightness, chroma, and hue difference components respectively.  The 3 components of W correspond to the reciprocal of these 3 parameters.  (I do not know why they chose to put kL, kC, kH in the denominator. If you wanted to ignore, say, the chroma component you would have to set kC to Inf, rather than setting W[2] to 0 which seems more sensible to me).  If you are using CIE76 then W[2] amd W[3] are applied to the differences in a and b.  In this case you should ensure W[2] = W[3].  In general, for the spatial frequencies of interest to us, lightness differences are overwhelmingly more important than chroma or hue and W shoud be set to [1, 0, 0]\n\nSmoothing parameter sigma: The output colour map will have lightness values of constant slope magnitude. However, it is possible that the sign of the slope may change, for example at the mid point of a bilateral colour map.  This slope discontinuity of lightness can induce a false apparent feature in the colour map.  A smaller effect is also occurs for slope discontinuities in a and b.  For such colour maps it can be useful to introduce a small amount of smoothing of the Lab values to soften the transition of sign in the slope to remove this apparent feature.  However in doing this one creates a small region of suppressed luminance contrast in the colour map which induces a \'blind spot\' that compromises the visibility of features should they fall in that data range.  Accordingly the smoothing should be kept to a minimum.  A value of sigma in the range 5 to 7 in a 256 element colour map seems about right.  As a guideline sigma should not be more than about 1/25 of the number of entries in the colour map, preferably less.\n\nReference: Peter Kovesi. Good Colour Maps: How to Design Them. arXiv:1509.03700 [cs.GR] 2015\n\nSee also: cmap, applycycliccolourmap, applydivergingcolourmap, sineramp, circlesineramp\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.equalizecolormap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.equalizecolormap",
    "category": "function",
    "text": "equalisecolourmap - Equalise colour contrast over a colourmap equalizecolormap\n\nUsage: newrgbmap = equalisecolourmap(rgblab, map, formula, W, sigma, diagnostics)\n                   equalizecolormap(....\n\nArguments:     rgblab - String \"RGB\" or \"LAB\" indicating the type of data\n                        in map.\n                  map - A Nx3 RGB or CIELAB colour map\n                        or an array of ColorTypes.RGB{Float64} values\n              formula - String \"CIE76\" or \"CIEDE2000\"\n                    W - A 3-vector of weights to be applied to the\n                        lightness, chroma and hue components of the\n                        difference equation. It is recommended that you\n                        use [1, 0, 0] to only take into account lightness.\n                        If desired used  [1, 1, 1] for the full formula.\n                sigma - Optional Gaussian smoothing parameter.\n               cyclic - Boolean flag indicating whether the colour map is\n                        cyclic. This affects how smoothing is applied at\n                        the end points.\n          diagnostics - Optional boolean flag indicating whether diagnostic\n                        plots should be displayed.  Defaults to false.\n\nReturns:    newrgbmap - RGB colour map adjusted so that the perceptual\n                        contrast of colours along the colour map is constant.\n                        This is a Nx3 Array of Float64 values.\n\nFor full documentation see equalisecolourmap()\n                                 ^     ^\n\nSee also: cmap, sineramp, circlesineramp\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.histtruncate",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.histtruncate",
    "category": "function",
    "text": "histtruncate - Truncates ends of an image histogram.\n\nFunction truncates a specified percentage of the lower and upper ends of an image histogram.\n\nThis operation allows grey levels to be distributed across the primary part of the histogram.  This solves the problem when one has, say, a few very bright values in the image which have the overall effect of darkening the rest of the image after rescaling.\n\nUsage:\n1)   newimg = histtruncate(img, lHistCut, uHistCut)\n2)   newimg = histtruncate(img, HistCut)\n\nArguments:\n Usage 1)\n   img         -  Image to be processed.\n   lHistCut    -  Percentage of the lower end of the histogram\n                  to saturate.\n   uHistCut    -  Percentage of the upper end of the histogram\n                  to saturate.  If omitted or empty defaults to the value\n                  for lHistCut.\n Usage 2)\n   HistCut     -  Percentage of upper and lower ends of the histogram to cut.\n\nReturns:\n   newimg      -  Image with values clipped at the specified histogram\n                  fraction values.  If the input image was colour the\n                  lightness values are clipped and stretched to the range\n                  0-1.  If the input image is greyscale no stretching is\n                  applied. You may want to use normalise() to achieve this.\n\nSee also: normalise\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.interp1",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.interp1",
    "category": "function",
    "text": "Simple 1D linear interpolation of an array of data\n\n Usage:  yi = interp1(x, y, xi)\n\nArguments:  x - Array of coordinates at which y is defined.\n            y - Array of values at coordinates x.\n           xi - Coordinate locations at which you wish to interpolate y values.\n\nReturns:   yi - Values linearly interpolated from y at xi.\n\n\nInterpolates y, defined at values x, at locations xi and returns the corresponding values as yi\n\nx is assumed increasing but not necessarily equi-spaced. xi values do not need to be sorted.\n\nIf any xi are outside the range of x then the corresponding value of yi is set to the appropriate end value of y.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.lab2srgb",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.lab2srgb",
    "category": "function",
    "text": "Convenience function for converting an Nx3 array of CIELAB values in a colour map to an Nx3 array of RGB values.  Function can also be used to convert a 3 channel CIELAB image to a 3 channel RGB image\n\nNote it appears that the Colors.convert() function uses a default white point of D65\n\n Usage:  rgb = srgb2lab(lab)\n\n Argument:   lab - A N x 3 array of CIELAB values of a 3 channel CIELAB image.\n Returns:    rgb - A N x 3 array of RGB values or a 3 channel RGB image.\n\nSee also: srgb2lab\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.linearrgbmap",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.linearrgbmap",
    "category": "function",
    "text": "linearrgbmap: Linear rgb colourmap from black to a specified colour\n\nUsage: cmap = linearrgbmap(C, N)\n\nArguments:  C - 3-vector specifying RGB colour\n            N - Number of colourmap elements, defaults to 256\n\nReturns: cmap - N element ColorTypes.RGBA colourmap ranging from [0 0 0]\n                to RGB colour C\n\nIt is suggested that you pass the resulting colour map to equalisecolourmap() to obtain a map with uniform steps in perceptual lightness\n\n> cmap = equalisecolourmap(\"rgb\", linearrgbmap(C, N))\n\nSee also: equalisecolourmap, ternarymaps\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.normalise",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.normalise",
    "category": "function",
    "text": "normalise/normalize - Normalises image values to 0-1, or to desired mean and variance\n\nUsage 1:      nimg = normalise(img)\n\nOffsets and rescales image so that the minimum value is 0 and the maximum value is 1.\n\nUsage 2:      nimg = normalise(img, reqmean, reqvar)\n\nArguments:  img     - A grey-level input image.\n            reqmean - The required mean value of the image.\n            reqvar  - The required variance of the image.\n\nOffsets and rescales image so that nimg has mean reqmean and variance reqvar.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.normalize",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.normalize",
    "category": "function",
    "text": "normalize - Normalizes image values to 0-1, or to desired mean and variance\n\nUsage 1:      nimg = normalize(img)\n\nOffsets and rescales image so that the minimum value is 0 and the maximum value is 1.\n\nUsage 2:      nimg = normalize(img, reqmean, reqvar)\n\nArguments:  img     - A grey-level input image.\n            reqmean - The required mean value of the image.\n            reqvar  - The required variance of the image.\n\nOffsets and rescales image so that nimg has mean reqmean and variance reqvar.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.pbspline",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.pbspline",
    "category": "function",
    "text": "pbspline - Basic Periodic B-spline\n\nUsage:  S = pbspline(P, k, N)\n\nArguments:   P - [dim x Npts] array of control points\n             k - order of spline (>= 2).\n                 k = 2: Linear\n                 k = 3: Quadratic, etc\n             N - Optional number of points to evaluate along\n                 spline. Defaults to 100.\n\nReturns:     S - spline curve  [dim x N] spline points\n\nNote that the spline points are rotated so that the first point is as close as possible to the first control point.  This is important for the formation of cyclic paths in colour space.\n\nSee also: bbspline\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.relief",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.relief",
    "category": "function",
    "text": "relief -  Generates relief shaded image\n\nUsage:  shadeimg = relief(img, azimuth, elevation, gradscale, rgbimg)\n\nArguments: img - Image/heightmap to be relief shaded. ::Array{T<:Real,2}\n       azimuth - Of light direction in degrees. Zero azimuth points\n                 upwards and increases clockwise. Defaults to 45.\n     elevation - Of light direction in degrees. Defaults to 45.\n     gradscale - Scaling to apply to the surface gradients.  If the shading\n                 is excessive decrease the scaling. Try successive doubling\n                 or halving to find a good value.\n        rgbimg - Optional RGB image to which the shading pattern derived\n                 from \'img\' is applied.   Alternatively, rgbimg can be a\n                 colour map of type ::Array{ColorTypes.RGBA{Float64},1}\n                 obtained from cmap().  This colour map is applied to the input\n                 image/heightmap in order to obtain a RGB image to which\n                 the shading pattern is applied.\n\nLambertian shading is used to form the relief image.  This obtained from the cosine of the angle between the surface normal and light direction.  Note that shadows are ignored.  Thus a small feature that might otherwise be in the shadow of a nearby large structure is rendered as if the large feature was not there.\n\nSee also: cmap, applycolourmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.sineramp",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.sineramp",
    "category": "function",
    "text": "sineramp  - Generates sine on a ramp colour map test image\n\nThe test image consists of a sine wave superimposed on a ramp function The amplitude of the sine wave is modulated from its full value at the top of the image to 0 at the bottom.\n\nThe image is useful for evaluating the effectiveness of different colour maps. Ideally the sine wave pattern should be equally discernible over the full range of the colour map.  In addition, across the bottom of the image, one should not see any identifiable features as the underlying signal is a smooth ramp.  In practice many colour maps have uneven perceptual contrast over their range and often include \'flat spots\' of no perceptual contrast that can hide significant features.\n\nUsage: img = sineramp(sze, amp, wavelen, p)\n       img = sineramp()\n\nArguments:     sze - (rows, cols) specifying size of test image.\n                     Defaults to (256 512)  Note the number of columns is\n                     nominal and will be ajusted so that there are an\n                     integer number of sine wave cycles across the image.\n               amp - Amplitude of sine wave. Defaults to 12.5\n           wavelen - Wavelength of sine wave in pixels. Defaults to 8.\n                 p - Power to which the linear attenuation of amplitude,\n                     from top to bottom, is raised.  For no attenuation use\n                     p = 0.  For linear attenuation use a value of 1.  For\n                     contrast sensitivity experiments use larger values of\n                     p.  The default value is 2.\n\nThe ramp function that the sine wave is superimposed on is adjusted slightly for each row so that each row of the image spans the full data range of 0 to\n\nThus using a large sine wave amplitude will result in the ramp at the\n\ntop of the test image being reduced relative to the slope of the ramp at the bottom of the image.\n\nTo start with try\n\n  > img = sineramp()\n\nThis is equivalent to\n\n  > img = sineramp((256 512), 12.5, 8, 2)\n\nView it under \'gray\' then try the \'jet\', \'hsv\', \'hot\' etc colour maps.  The results may cause you some concern!\n\nIf you are wishing to evaluate a cyclic colour map, say hsv, it is suggested that you use the test image generated by circlesineramp().\n\nSee source code comments for more details on the default wavelength and amplitude.\n\nSee also: circlesineramp, chirplin, chirpexp, equalisecolourmap, cmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.srgb2lab",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.srgb2lab",
    "category": "function",
    "text": "Convenience function for converting an Nx3 array of RGB values in a colour map to an Nx3 array of CIELAB values.  Function can also be used to convert a 3 channel RGB image to a 3 channel CIELAB image\n\nNote it appears that the Colors.convert() function uses a default white point of D65\n\n Usage:  lab = srgb2lab(rgb)\n\n Argument:    rgb - A N x 3 array of RGB values or a 3 channel RGB image.\n Returns:     lab - A N x 3 array of Lab values of a 3 channel CIELAB image.\n\n\nSee also: lab2srgb\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.ternaryimage",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.ternaryimage",
    "category": "function",
    "text": "ternaryimage:  Perceptualy uniform ternary image from 3 bands of data\n\nThis function generates a ternary image using 3 basis colours that are closely matched in lightness, as are their secondary colours.  The colours are not as vivid as the RGB primaries but they produce ternary images with consistent feature salience no matter what permutation of channel-colour assignement is used.  This is in contrast to ternary images constructed with the RGB primaries where the channel that happens to get encoded in green dominates the perceptual result.\n\nUseful for Landsat imagery or radiometric images.\n\nUsage: rgbimg = ternaryimage(img; bands, histcut, RGB)\n\nArgument:\n            img - Multiband image with at least 3 bands.\n                  ::ImageMeta{T,3} or ::Array{T<:Real,3}\n\nKeyword Arguments:\n          bands - Array of 3 values indicating the bands, to be assigned to\n                  the red, green and blue basis colour maps.  If omitted\n                  bands defaults to [1, 2, 3].\n        histcut - Percentage of image band histograms to clip.  It can be\n                  useful to clip 1-2%. If you see lots of white in your\n                  ternary image you have clipped too much. Defaults to 0.\n            RGB - Boolean flag, if set to true the classical RGB primaries\n                  are used to construct the ternary image rather than the\n                  lightness matched primaries. Defaults to false.\n\nReturns:\n          rgbimg - RGB ternary image\n                  ::ImageMeta{T,3} or ::Array{T<:Real,3}\n\nFor the derivation of the three primary colours see: Peter Kovesi. Good Colour Maps: How to Design Them. arXiv:1509.03700 [cs.GR] 2015.\n\nSee also: applycolourmap, linearrgbmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#PerceptualColourMaps.viewlabspace",
    "page": "Docstrings",
    "title": "PerceptualColourMaps.viewlabspace",
    "category": "function",
    "text": "viewlabspace:  Visualisation of Lab* space\n\nUsage:    viewlabspace(L = 50, figNo = 1)\n\nArguments:     L - Lightness level in which to display slice of L*a*b* space\n           figNo - PyPlot figure to use\n\nFunction allows interactive viewing of a sequence of images corresponding to different slices of lightness in Lab* space.  Lightness varies from 0 to\n\nInitially a slice at a lightness of 50 is displayed.\n\nPressing \'l\' or arrow up/right will increase the lightness by dL. Pressing \'d\' or arrow down/left will darken by dL. Press \'x\' to exit.\n\nTo Do: The CIELAB colour coordinates of the cursor position within the slice images should be updated continuously.  This is useful for determining suitable control points for the definition of colourmap paths through CIELAB space in cmap().\n\nSee also: colourmappath, cmap\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "PerceptualColourMaps.FloatArray2RGBPerceptualColourMaps.FloatArray2RGBAPerceptualColourMaps.PerceptualColourMapsPerceptualColourMaps.RGB2FloatArrayPerceptualColourMaps.RGBA2FloatArrayPerceptualColourMaps.RGBA2UInt32PerceptualColourMaps.applycolormapPerceptualColourMaps.applycolourmapPerceptualColourMaps.applycycliccolormapPerceptualColourMaps.applycycliccolourmapPerceptualColourMaps.applydivergingcolormapPerceptualColourMaps.applydivergingcolourmapPerceptualColourMaps.bbsplinePerceptualColourMaps.cataloguePerceptualColourMaps.ch2abPerceptualColourMaps.cie76PerceptualColourMaps.ciede2000PerceptualColourMaps.circlesinerampPerceptualColourMaps.cmapPerceptualColourMaps.colourmapdefPerceptualColourMaps.equalisecolourmapPerceptualColourMaps.equalizecolormapPerceptualColourMaps.evalPerceptualColourMaps.gaussfilt1dPerceptualColourMaps.histtruncatePerceptualColourMaps.includePerceptualColourMaps.interp1PerceptualColourMaps.lab2srgbPerceptualColourMaps.linearrgbmapPerceptualColourMaps.matprintPerceptualColourMaps.newcolourmapdefPerceptualColourMaps.normalisePerceptualColourMaps.normalizePerceptualColourMaps.pbsplinePerceptualColourMaps.reliefPerceptualColourMaps.renderlabslicePerceptualColourMaps.sinerampPerceptualColourMaps.smoothPerceptualColourMaps.srgb2labPerceptualColourMaps.surfacenormalsPerceptualColourMaps.ternaryimagePerceptualColourMaps.viewlabspace"
},

]}
