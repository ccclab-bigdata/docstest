<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Einsum.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Einsum.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Einsum.jl-1" href="#Einsum.jl-1">Einsum.jl</a></h1><table><tr><th><strong>Package Build</strong></th><th><strong>Package Status</strong></th></tr><tr><td><a href="https://travis-ci.org/ahwillia/Einsum.jl"><img src="https://travis-ci.org/ahwillia/Einsum.jl.svg?branch=master" alt="Build Status"/></a></td><td><a href="LICENSE.md"><img src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" alt="License"/></a></td></tr><tr><td><a href="http://pkg.julialang.org/?pkg=Einsum"><img src="http://pkg.julialang.org/badges/Einsum_0.6.svg" alt="Einsum"/></a></td><td><a href="http://www.repostatus.org/#inactive"><img src="http://www.repostatus.org/badges/latest/inactive.svg" alt="Project Status: Inactive - The project has reached a stable, usable state but is no longer being actively developed; support/maintenance will be provided as time allows."/></a> - help wanted!</td></tr></table><p>This package exports a single macro <code>@einsum</code>, which implements <em>similar</em> notation to the <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein summation convention</a> to flexibly specify operations on Julia <code>Array</code>s, similar to numpy&#39;s <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html"><code>einsum</code></a> function (but more flexible!).</p><p>For example, basic matrix multiplication can be implemented as:</p><pre><code class="language-julia">@einsum A[i, j] := B[i, k] * C[k, j]</code></pre><p>To install: <code>Pkg.add(&quot;Einsum&quot;)</code>, or else <code>pkg&gt; add Einsum</code> after pressing <code>]</code> on Julia 0.7 and later.</p><h2><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h2><h3><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h3><p>If the destination array is preallocated, then use <code>=</code>:</p><pre><code class="language-julia">A = ones(5, 6, 7) # preallocated space
X = randn(5, 2)
Y = randn(6, 2)
Z = randn(7, 2)

# Store the result in A, overwriting as necessary:
@einsum A[i, j, k] = X[i, r] * Y[j, r] * Z[k, r]</code></pre><p>If destination is not preallocated, then use <code>:=</code> to automatically create a new array for the result:</p><pre><code class="language-julia">X = randn(5, 2)
Y = randn(6, 2)
Z = randn(7, 2)

# Create new array B with appropriate dimensions:
@einsum B[i, j, k] := X[i, r] * Y[j, r] * Z[k, r]</code></pre><h3><a class="nav-anchor" id="What-happens-under-the-hood-1" href="#What-happens-under-the-hood-1">What happens under the hood</a></h3><p>To execute an expression, <code>@einsum</code> uses <a href="http://docs.julialang.org/en/stable/manual/metaprogramming/">Julia&#39;s metaprogramming capabilities</a> to generate and execute a series of nested for loops.  To see exactly what is generated, use <a href="https://docs.julialang.org/en/stable/stdlib/base/#Base.@macroexpand"><code>@macroexpand</code></a> (or <code>@expand</code> from <a href="https://github.com/MikeInnes/MacroTools.jl">MacroTools.jl</a>):</p><pre><code class="language-julia">@macroexpand @einsum A[i, j] := B[i, k] * C[k, j]</code></pre><p>The output will look much like the following (note that we &quot;sum out&quot; over the index <code>k</code>, since it only occurs multiple times on the right hand side of the equation):</p><pre><code class="language-julia"># determine type
T = promote_type(eltype(B), eltype(C))

# allocate new array
A = Array{T}(undef, size(B))

# check dimensions
@assert size(B, 2) == size(C, 2)

# main loop
@inbounds begin # skip bounds-checking for speed
    for i = 1:size(B, 1), j = 1:size(C, 2)
        s = zero(T)
        for k = 1:size(B,2)
            s += B[i, k] * C[k, j]
        end
        A[i, j] = s
    end
end</code></pre><p>The actual generated code is a bit more verbose (and not neatly commented/formatted), and will take care to use the right types and keep hygienic.</p><p>You can also use updating assignment operators for preallocated arrays.  E.g., <code>@einsum A[i, j, k] *= X[i, r] * Y[j, r] * Z[k, r]</code> will produce something like</p><pre><code class="language-julia">for k = 1:size(A, 3)
    for j = 1:size(A, 2)
        for i = 1:size(A, 1)
            s = 0.0
            for r = 1:size(X, 2)
                s += X[i, r] * Y[j, r] * Z[k, r]
            end
            # Difference: here, the updating form is used:
            A[i, j, k] *= s
        end
    end
end</code></pre><h3><a class="nav-anchor" id="Rules-for-indexing-variables-1" href="#Rules-for-indexing-variables-1">Rules for indexing variables</a></h3><ul><li>Indices that show up on the right-hand-side but not the left-hand-side are summed over</li><li>Arrays which share an index must be of the same size, in those dimensions</li></ul><p><code>@einsum</code> iterates over the extent of the right-hand-side indices. For example, the following code allocates an array <code>A</code> that is the same size as <code>B</code> and copies its data into <code>A</code>:</p><pre><code class="language-julia">@einsum A[i,  j] := B[i, j]  # same as A = copy(B)</code></pre><p>If an index appears on the right-hand-side, but does not appear on the left-hand-side, then this variable is summed over. For example, the following code allocates <code>A</code> to be <code>size(B, 1)</code> and sums over the rows of <code>B</code>:</p><pre><code class="language-julia">@einsum A[i] := B[i, j]  # same as A = dropdims(sum(B, dims=2), dims=2)</code></pre><p>If an index variable appears multiple times on the right-hand-side, then it is asserted that the sizes of these dimensions match. For example,</p><pre><code class="language-julia">@einsum A[i] := B[i, j] * C[j]</code></pre><p>will check that the second dimension of <code>B</code> matches the first dimension of <code>C</code> in length. In particular it is equivalent to the following code:</p><pre><code class="language-julia">A = zeros(size(B, 1))
@assert size(B, 2) == size(C, 1)

for i = 1:size(B, 1), j = 1:size(B, 2)
    A[i] += B[i, j] * C[j]
end</code></pre><p>So an error will be thrown if the specified dimensions of <code>B</code> and <code>C</code> don&#39;t match.</p><h4><a class="nav-anchor" id="Offset-indexing-1" href="#Offset-indexing-1">Offset indexing</a></h4><p><code>@einsum</code> also allows offsets on the right-hand-side, the range over which <code>i</code> is summed is then restricted:</p><pre><code class="language-julia">@einsum A[i] = B[i - 5]</code></pre><h3><a class="nav-anchor" id="@vielsum-1" href="#@vielsum-1"><code>@vielsum</code></a></h3><p>This variant of <code>@einsum</code> will run multi-threaded on the outermost loop. For this to be fast, the code must not introduce temporaries like <code>s = 0</code> in the example above. Thus for example <code>@expand @vielsum A[i,j,k] = X[i,r]*Y[j,r]*Z[k,r]</code> results in something equivalent to <code>@expand</code>-ing the following:</p><pre><code class="language-julia">Threads.@threads for k = 1:size(A,3)
    for j = 1:size(A,2)
        for i = 1:size(A,1)
            A[i,j,k] = 0.0
            for r = 1:size(X,2)
                A[i,j,k] += X[i,r] * Y[j,r] * Z[k,r]
            end
        end
    end
end</code></pre><p>For this to be useful, you will need to set an environment variable before starting Julia, such as <code>export JULIA_NUM_THREADS=4</code>. See <a href="https://docs.julialang.org/en/latest/manual/parallel-computing/#Multi-Threading-(Experimental)-1">the manual</a> for details, and note that this is somewhat experimental. This will not always be faster, especially for small arrays, as there is some overhead to dividing up the work.</p><p>At present you cannot use updating assignment operators like <code>+=</code> with this macro (only <code>=</code> or <code>:=</code>) and you cannot assign to a scalar left-hand-side (only an array). These limitations prevent different threads from writing to the same memory at the same time.</p><h3><a class="nav-anchor" id="@einsimd-1" href="#@einsimd-1"><code>@einsimd</code></a></h3><p>This is a variant of <code>@einsum</code> which will put <code>@simd</code> in front of the innermost loop, encouraging Julia&#39;s compiler vectorize this loop (although it may do so already). For example <code>@einsimd A[i,j,k] = X[i,r]*Y[j,r]*Z[k,r]</code> will result in approximately</p><pre><code class="language-julia">@inbounds for k = 1:size(A,3)
    for j = 1:size(A,2)
        for i = 1:size(A,1)
            s = 0.0
            @simd for r = 1:size(X,2)
                s += X[i,r] * Y[j,r] * Z[k,r]
            end
            A[i,j,k] = s
        end
    end
end</code></pre><p>Whether this is a good idea or not you have to decide and benchmark for yourself in every specific case.  <code>@simd</code> makes sense for certain kinds of operations; make yourself familiar with <a href="https://docs.julialang.org/en/latest/base/base/#Base.SimdLoop.@simd">its documentation</a> and the inner workings of it <a href="https://software.intel.com/en-us/articles/vectorization-in-julia">in general</a>.</p><h3><a class="nav-anchor" id="Other-functionality-1" href="#Other-functionality-1">Other functionality</a></h3><p>The <code>@einsum</code> macro can implement function calls within the nested for loop structure. For example, consider transposing a block matrix:</p><pre><code class="language-julia">z = Any[rand(2,2) for i=1:2, j=1:2]
@einsum t[i,j] := transpose(z[j,i])</code></pre><p>This produces a for loop structure with a <code>transpose</code> function call in the middle. Approximately:</p><pre><code class="language-julia">for j = 1:size(z,1)
    for i = 1:size(z,2)
        t[i,j] = transpose(z[j,i])
    end
end</code></pre><p>This will work as long the function calls are outside the array names. Again, you can use <a href="https://docs.julialang.org/en/stable/stdlib/base/#Base.@macroexpand"><code>@macroexpand</code></a> to see the exact code that is generated.</p><p>The output need not be an array. But note that on Julia 0.7 and 1.0, the rules for evaluating in global scope (for example at the REPL prompt) are a little different â see <a href="https://github.com/stevengj/SoftGlobalScope.jl">this package</a> for instance (which is loaded in <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> notebooks). To get the same behavior as you would have inside a function, you use a <code>let</code> block:  </p><pre><code class="language-julia">p = rand(5); p .= p ./ sum(p)
let
    global S
    @einsum S := - p[i] * log(p[i])
end</code></pre><p>Or perhaps clearer, explicitly define a function:</p><pre><code class="language-julia">m(pq, p, q) = @einsum I := pq[i,j] * log(pq[i,j] / p[i] / q[j])

m(rand(5,10), rand(5), rand(10))</code></pre><h3><a class="nav-anchor" id="Related-Packages:-1" href="#Related-Packages:-1">Related Packages:</a></h3><ul><li><p><a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a> has less flexible syntax (only allowing strict Einstein convention contractions), but can produce much more efficient code.  Instead of generating ânaiveâ loops, it transforms the expressions into optimized contraction functions and takes care to use a good (cache-friendly) order for the looping.</p></li><li><p><a href="https://github.com/shashi/ArrayMeta.jl">ArrayMeta.jl</a> aims to produce cache-friendly operations for more general loops (but is Julia 0.6 only).</p></li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
