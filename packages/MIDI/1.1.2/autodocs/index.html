<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MIDI.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIDI.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">MIDI.AbstractNote</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.BPM" href="#MIDI.BPM"><code>MIDI.BPM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">BPM(midi)</code></pre><p>Return the BPM where the given <code>MIDIFile</code> was exported at.</p></div></div></section><pre><code class="language-none">MIDI.CHANNELPRESSURE</code></pre><pre><code class="language-none">MIDI.CONTROLCHANGE</code></pre><pre><code class="language-none">MIDI.EVENTTYPETOLENGTH</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.GM" href="#MIDI.GM"><code>MIDI.GM</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A dictionary that maps an instrument name (type <code>String</code>) to their hex value (type <code>UInt8</code>).</p></div></div></section><pre><code class="language-none">MIDI.LYRICEV</code></pre><pre><code class="language-none">MIDI.MARKEREV</code></pre><pre><code class="language-none">MIDI.META</code></pre><pre><code class="language-none">MIDI.METASETTEMPO</code></pre><pre><code class="language-none">MIDI.METATRACKEND</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.MIDI" href="#MIDI.MIDI"><code>MIDI.MIDI</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A Julia library for reading and writing MIDI files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.MIDIEvent" href="#MIDI.MIDIEvent"><code>MIDI.MIDIEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MIDIEvent &lt;: TrackEvent</code></pre><p>See <a href="#MIDI.TrackEvent"><code>TrackEvent</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.MIDIFile" href="#MIDI.MIDIFile"><code>MIDI.MIDIFile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MIDIFile &lt;: Any</code></pre><p>Type representing a file of MIDI data.</p><p><strong>Fields</strong></p><ul><li><code>format::UInt16</code> : The format of the file. Can be 0, 1 or 2.</li><li><code>tpq::Int16</code> : The time division of the track, ticks-per-quarter-note.</li><li><code>tracks::Array{MIDITrack, 1}</code> : The array of contained tracks.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.MIDITrack" href="#MIDI.MIDITrack"><code>MIDI.MIDITrack</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MIDITrack &lt;: Any</code></pre><p><code>MIDITrack</code> is simply a container for <code>TrackEvents</code>, since its only field is <code>events::Vector{TrackEvent}</code>.</p><p>Track chunks begin with four bytes spelling out &quot;MTrk&quot;, followed by the length (in bytes) of the track (see <a href="#MIDI.readvariablelength"><code>readvariablelength</code></a>), followed by a sequence of events.</p></div></div></section><pre><code class="language-none">MIDI.MTHD</code></pre><pre><code class="language-none">MIDI.MTRK</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.MetaEvent" href="#MIDI.MetaEvent"><code>MIDI.MetaEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MetaEvent &lt;: TrackEvent</code></pre><p>See <a href="#MIDI.TrackEvent"><code>TrackEvent</code></a>.</p></div></div></section><pre><code class="language-none">MIDI.NAME_TO_PITCH</code></pre><pre><code class="language-none">MIDI.NOTEOFF</code></pre><pre><code class="language-none">MIDI.NOTEON</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.Note" href="#MIDI.Note"><code>MIDI.Note</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Note &lt;: AbstractNote</code></pre><p>Data structure describing a &quot;music note&quot;.</p><p><strong>Fields:</strong></p><ul><li><code>pitch::UInt8</code> : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).</li><li><code>velocity::UInt8</code> : Dynamic intensity. Cannot be higher than 127 (0x7F).</li><li><code>position::UInt</code> : Position in absolute time (since beginning of track), in ticks.</li><li><code>duration::UInt</code> : Duration in ticks.</li><li><code>channel::UInt8 = 0</code> : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).</li></ul><p>If the <code>channel</code> of the note is <code>0</code> (default) it is not printed with <code>show</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.Notes" href="#MIDI.Notes"><code>MIDI.Notes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Notes{N&lt;:AbstractNote}</code></pre><p>Data structure describing a collection of &quot;music notes&quot;, bundled with a ticks per quarter note measure.</p><p><strong>Fields:</strong></p><ul><li><code>notes::Vector{N}</code></li><li><code>tpq::Int16</code> : Ticks per quarter note. Defines the fundamental unit of measurement  of a note&#39;s position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.</li></ul><p><code>Notes</code> is iterated and accessed as if iterating or accessing its field <code>notes</code>.</p></div></div></section><pre><code class="language-none">MIDI.PITCHWHEELCHANGE</code></pre><pre><code class="language-none">MIDI.PITCH_TO_NAME</code></pre><pre><code class="language-none">MIDI.POLYPHONICKEYPRESSURE</code></pre><pre><code class="language-none">MIDI.PROGRAMCHANGE</code></pre><pre><code class="language-none">MIDI.SYSEX</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.SysexEvent" href="#MIDI.SysexEvent"><code>MIDI.SysexEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SysexEvent &lt;: TrackEvent</code></pre><p>See <a href="#MIDI.TrackEvent"><code>TrackEvent</code></a>.</p></div></div></section><pre><code class="language-none">MIDI.TEXTEV</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.TrackEvent" href="#MIDI.TrackEvent"><code>MIDI.TrackEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TrackEvent &lt;: Any</code></pre><p>Abstract supertype for all MIDI events.</p><p>All track events begin with a variable length time value (see <a href="#MIDI.readvariablelength"><code>readvariablelength</code></a>) and have a field named <code>dT</code> which contains it. This number notes after how many ticks since the last event does the current even takes place.</p><p><code>MIDIEvent</code>s then resume with a MIDI channel message defined in <code>constants.jl</code>. They&#39;re followed by 1 or 2 bytes, depending on the channel message (see <code>MIDI.EVENTTYPETOLENGTH</code>). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.</p><p><code>MetaEvent</code>s and <code>SysexEvent</code>s both resume with a specific byte (see <code>constants.jl</code>).</p></div></div></section><pre><code class="language-none">MIDI._notevectorprint</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addevent!" href="#MIDI.addevent!"><code>MIDI.addevent!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addevent!(track::MIDITrack, time::Int, event::TrackEvent)</code></pre><p>Add an event to the <code>track</code> at given <code>time</code>. The <code>time</code> is in absolute time, not relative.</p><p>If you want to add multiple events in one go, you should use the <a href="#MIDI.addevents!"><code>addevents!</code></a> function instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addevent_hint!" href="#MIDI.addevent_hint!"><code>MIDI.addevent_hint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addevent_hint!(track::MIDITrack, time::Int, event::TrackEvent,
                eventindex::UInt, eventtime::UInt)</code></pre><p>Add an event to the <code>track</code> at given <code>time</code>. The <code>time</code> is in absolute time, not relative. <code>eventindex</code> and <code>eventtime</code> have to be the index and the absolute time of a known event in <code>track</code> which lays BEFORE the position where <code>event</code> shall be added. This shortens the search for the correct position for <code>event</code> by skipping all <code>TrackEvents</code> before the specified one.</p><p>Returns the index and absolute time of the added event.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addevents!" href="#MIDI.addevents!"><code>MIDI.addevents!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addevents!(track::MIDITrack, times, events)</code></pre><p>Add given <code>events</code> to given <code>track</code> at given <code>times</code>, internally doing all translations from absolute time to relative time.</p><p>Using this function is more efficient than a loop over single <a href="#MIDI.addevent!"><code>addevent!</code></a> calls.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addnote!" href="#MIDI.addnote!"><code>MIDI.addnote!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addnote!(track::MIDITrack, note::AbstractNote)</code></pre><p>Add given <code>note</code> to given <code>track</code>, internally doing the translation from absolute time to relative time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addnotes!" href="#MIDI.addnotes!"><code>MIDI.addnotes!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addnotes!(track::MIDITrack, notes)</code></pre><p>Add given <code>notes</code> to given <code>track</code>, internally doing all translations from absolute time to relative time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.addtrackname!" href="#MIDI.addtrackname!"><code>MIDI.addtrackname!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addtrackname!(track::MIDI.MIDITrack, name::String)</code></pre><p>Add a name to the given <code>track</code> by attaching the &quot;track name&quot; <code>MetaEvent</code> to the start of the <code>track</code>.</p></div></div></section><pre><code class="language-none">MIDI.channelnumber</code></pre><pre><code class="language-none">MIDI.dochannelsconflict</code></pre><pre><code class="language-none">MIDI.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.findtextevents" href="#MIDI.findtextevents"><code>MIDI.findtextevents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findtextevents(eventtype, track)</code></pre><p>Find all &quot;text&quot; events specifield by <code>eventtype</code> in the <code>track</code>. The <code>eventtype</code> can be <code>:text, :lyric, :marker</code>, which will find the appropriate <code>MetaEvent</code>s.</p><p>For convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the <code>track</code> and the third is the absolute position of the events (since start of <code>track</code>).</p><p><em>Notice</em> - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.</p></div></div></section><pre><code class="language-none">MIDI.findtrackname</code></pre><pre><code class="language-none">MIDI.fromabsolutetime!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.get_abs_pos" href="#MIDI.get_abs_pos"><code>MIDI.get_abs_pos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_abs_pos(track::MIDITrack, idxs)</code></pre><p>Return the absolute positions (since track start) of the events given by the indices <code>idxs</code> of <code>track.events</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.getnotes" href="#MIDI.getnotes"><code>MIDI.getnotes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getnotes(midi::MIDIFile, trackno = 2)</code></pre><p>Find all NOTEON and NOTEOFF midi events in the <code>trackno</code> track of a <code>midi</code>, that correspond to the same note value (pitch) and convert them into the <code>Note</code> datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity. <code>getnotes</code> takes care of this.</p><p>Notice that the first track of a <code>midi</code> typically doesn&#39;t have any notes, which is why the function defaults to track 2.</p><pre><code class="language-none">getnotes(track::MIDITrack, tpq = 960)</code></pre><p>Find the notes from <code>track</code> directly, passing also the ticks per quarter note.</p><p>Returns: <code>Notes{Note}</code>, setting the ticks per quarter note as <code>tpq</code>. You can find the originally exported ticks per quarter note from the original <code>MIDIFile</code> through <code>midi.tpq</code>.</p></div></div></section><pre><code class="language-none">MIDI.getprogramchangeevents</code></pre><pre><code class="language-none">MIDI.include</code></pre><pre><code class="language-none">MIDI.insertsorted!</code></pre><pre><code class="language-none">MIDI.isMIDIevent</code></pre><pre><code class="language-none">MIDI.isdatabyte</code></pre><pre><code class="language-none">MIDI.ismetaevent</code></pre><pre><code class="language-none">MIDI.isstatusbyte</code></pre><pre><code class="language-none">MIDI.issysexevent</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.ms_per_tick" href="#MIDI.ms_per_tick"><code>MIDI.ms_per_tick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ms_per_tick(tpq, bpm)
ms_per_tick(midi::MIDIFile)</code></pre><p>Return how many miliseconds is one tick, based on the beats per minute <code>bpm</code> and ticks per quarter note <code>tpq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.name_to_pitch" href="#MIDI.name_to_pitch"><code>MIDI.name_to_pitch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name_to_pitch(p::String) -&gt; Int</code></pre><p>Return the pitch value of the given note name <code>p</code>, which can be of the form <code>capital_letter*sharp*octave</code> where:</p><ul><li><code>capital_letter</code> : from <code>&quot;A&quot;</code> to <code>&quot;G&quot;</code>.</li><li><code>sharp</code> : one of <code>&quot;#&quot;</code> <code>&quot;♯&quot;</code> or <code>&quot;&quot;</code>.</li><li><code>octave</code> : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed <code>&quot;5&quot;</code>.</li></ul><p>We define E.g. <code>name_to_pitch(&quot;C4&quot;) === 60</code> (i.e. string <code>&quot;C4&quot;</code>, representing the middle-C, corresponds to be pitch <code>60</code>).</p><p>See http://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/C<em>(musical</em>note) .</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.pitch_to_name" href="#MIDI.pitch_to_name"><code>MIDI.pitch_to_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pitch_to_name(pitch) -&gt; string</code></pre><p>Return the name of the pitch, e.g. <code>F5</code>, <code>A♯3</code> etc. in modern notation given the value in integer.</p><p>Reminder: middle C has pitch <code>60</code> and is displayed as <code>C4</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.programchange" href="#MIDI.programchange"><code>MIDI.programchange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">programchange(track::MIDITrack, time::Integer, channel::UInt8, program::UInt8)</code></pre><p>Change the program (instrument) on the given channel. Time is absolute, not relative to the last event.</p><p>The <code>program</code> must be specified in the range 1-128, <strong>not</strong> in 0-127!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.readMIDIFile" href="#MIDI.readMIDIFile"><code>MIDI.readMIDIFile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readMIDIFile(filename::AbstractString)</code></pre><p>Read a file into a <code>MIDIFile</code> data type.</p></div></div></section><pre><code class="language-none">MIDI.readMIDIFileastype0</code></pre><pre><code class="language-none">MIDI.readMIDIevent</code></pre><pre><code class="language-none">MIDI.readMIDIfile</code></pre><pre><code class="language-none">MIDI.readmetaevent</code></pre><pre><code class="language-none">MIDI.readsysexevent</code></pre><pre><code class="language-none">MIDI.readtrack</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.readvariablelength" href="#MIDI.readvariablelength"><code>MIDI.readvariablelength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readvariablelength(f::IO)</code></pre><p>Variable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we&#39;re looking at the last byte in the sequence. The remaining 7 bits indicate the number.</p></div></div></section><pre><code class="language-none">MIDI.s_to_text</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.testmidi" href="#MIDI.testmidi"><code>MIDI.testmidi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">testmidi()</code></pre><p>Return the path to a test MIDI file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.textevent" href="#MIDI.textevent"><code>MIDI.textevent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">textevent(eventtype, text)</code></pre><p>Create an event using the string <code>text</code>. The <code>eventtype</code> can be <code>:text, :lyric, :marker</code>, which will create the appropriate type of <code>MetaEvent</code>.</p><p>The returned event can be added to a <a href="#MIDI.MIDITrack"><code>MIDITrack</code></a> via either <a href="#MIDI.addevent!"><code>addevent!</code></a> or <a href="#MIDI.addevents!"><code>addevents!</code></a> for multiple events.</p><p><em>Notice</em> - Cubase can read the marker events and MuseScore can read the lyrics events. We haven&#39;t seen any editor that can read the text events, so far.</p></div></div></section><pre><code class="language-none">MIDI.toabsolutetime!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.trackname" href="#MIDI.trackname"><code>MIDI.trackname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trackname(track::MIDI.MIDITrack)</code></pre><p>Return the name of the given <code>track</code> as a string, by finding the &quot;track name&quot; <code>MetaEvent</code>.</p></div></div></section><pre><code class="language-none">MIDI.type0totype1</code></pre><pre><code class="language-none">MIDI.type0totype1!</code></pre><pre><code class="language-none">MIDI.type1totype0</code></pre><pre><code class="language-none">MIDI.type1totype0!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.writeMIDIFile" href="#MIDI.writeMIDIFile"><code>MIDI.writeMIDIFile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writeMIDIFile(filename::AbstractString, data::MIDIFile)</code></pre><p>Write a <code>MIDIFile</code> as a &quot;.mid&quot; file to the given filename.</p><pre><code class="language-none">writeMIDIFile(filename::AbstractString, notes::Notes)</code></pre><p>Create a <code>MIDIFile</code> directly from <code>notes</code>, using format 1.</p></div></div></section><pre><code class="language-none">MIDI.writeMIDIfile</code></pre><pre><code class="language-none">MIDI.writeevent</code></pre><pre><code class="language-none">MIDI.writetrack</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIDI.writevariablelength" href="#MIDI.writevariablelength"><code>MIDI.writevariablelength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writevariablelength(f::IO, number::Int)</code></pre><p>Write on <code>f</code> the given <code>number</code>, firstly converting it to the &quot;variable length&quot; format. See the documentation for more.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
