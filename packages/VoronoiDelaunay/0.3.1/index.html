<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· VoronoiDelaunay.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>VoronoiDelaunay.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#How-does-it-work?-1">How does it work?</a></li><li><a class="toctext" href="#Current-limitations-1">Current limitations</a></li><li><a class="toctext" href="#How-to-use?-1">How to use?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="VoronoiDelaunay.jl-1" href="#VoronoiDelaunay.jl-1">VoronoiDelaunay.jl</a></h1><p><a href="https://travis-ci.org/JuliaGeometry/VoronoiDelaunay.jl"><img src="https://travis-ci.org/JuliaGeometry/VoronoiDelaunay.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://pkg.julialang.org/detail/VoronoiDelaunay"><img src="http://pkg.julialang.org/badges/VoronoiDelaunay_0.6.svg" alt="VoronoiDelaunay"/></a> <a href="https://coveralls.io/github/JuliaGeometry/VoronoiDelaunay.jl?branch=master"><img src="https://coveralls.io/repos/github/JuliaGeometry/VoronoiDelaunay.jl/badge.svg?branch=master" alt="Coverage Status"/></a><img src="http://i.imgur.com/lh8VLZ5.png5 &quot;VoronoiDelaunay.jl&quot;" alt="Alt VoronoiDelaunay.jl"/></p><p>Fast, robust construction of 2D Delaunay and Voronoi tessellations on generic point types. Implementation follows algorithms described in the <a href="http://arxiv.org/abs/0901.4107">Arepo paper</a> and used (for e.g.) in the <a href="http://www.illustris-project.org/">Illustris Simulation</a>. License: MIT. Bug reports welcome!</p><h2><a class="nav-anchor" id="How-does-it-work?-1" href="#How-does-it-work?-1">How does it work?</a></h2><p>Incrementally insert points to a valid Delaunay tessallation, while restoring Delaunayhood by flipping triangles. Point location (i.e. which triangle should it divide into three) is accelerated by spatial sorting. Spatial sorting allows to add points which are close in space thus walking the tesselation is fast. Initial tessalletion includes two triangles built by 4 points which are outside of the allowed region for users. These &quot;external&quot; triangles are skipped when iterating over Delaunay/Voronoy edges. Fast and robust predicates are provided by the <a href="https://github.com/skariel/GeometricalPredicates.jl">GeometricalPredicates</a> package. Benchmarks suggest this package is a bit faster than CGAL, see <a href="https://gist.github.com/skariel/3d2018f9341a058e00fc">here</a> benchmark of an older version which is also a bit slower than current.</p><h2><a class="nav-anchor" id="Current-limitations-1" href="#Current-limitations-1">Current limitations</a></h2><ul><li>Due to numerical restrictions the point coordinates must be within <code>min_coord &lt;= x &lt;= max_coord</code> where <code>min_coord=1.0+eps(Float64)</code> and <code>max_coord=2.0-2eps(Float64)</code>. Note this is a bit different than what is required by the  <code>GeometricalPredicates</code> package.</li><li>The following features are not implemented, but are in the TODO list; In order of priority: centroid tessellations (Lloy&#39;s method), Weighted generators (both power and sum), bounding, maybe restricting. Hierarchal tessellations for fast random locatings; Distributed tessellation construction. 3D. Order of priority may change of course :)</li></ul><h2><a class="nav-anchor" id="How-to-use?-1" href="#How-to-use?-1">How to use?</a></h2><h3><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h3><pre><code class="language-Julia">]add VoronoiDelaunay</code></pre><p>For Julia 0.6 and below, type</p><pre><code class="language-Julia">Pkg.add(&quot;VoronoiDelaunay&quot;)</code></pre><h3><a class="nav-anchor" id="Building-a-tessellation-1" href="#Building-a-tessellation-1">Building a tessellation</a></h3><p>Define and push individual points like this:</p><pre><code class="language-Julia">using  VoronoiDelaunay
tess = DelaunayTessellation()
push!(tess, Point(1.5, 1.5))</code></pre><p>creation of points is explained in the <a href="https://github.com/skariel/GeometricalPredicates.jl">GeometricalPredicates</a> package documentation.</p><p>Pushing arrays of points is more efficient:</p><pre><code class="language-Julia">width = max_coord - min_coord
a= Point2D[Point(min_coord+rand()*width, min_coord+rand()*width) for i in 1:100]
push!(tess, a)</code></pre><p>notice care taken for correct range of coordinates. <code>min_coord</code> and <code>max_coord</code> are defined in the package. We can further optimize by giving a <code>sizehint</code> at time of construction:</p><pre><code class="language-Julia">tess = DelaunayTessellation(100)</code></pre><p>or at any later point:</p><pre><code class="language-Julia">sizehint(tess, 100)</code></pre><h3><a class="nav-anchor" id="Iterating-1" href="#Iterating-1">Iterating</a></h3><p>Delaunay tesselations need at least 3 points to be well defined. Voronoi need 4. Remember this when iterating or plotting. Iterating over Delaunay edges is done like this:</p><pre><code class="language-Julia">i = 0
for edge in delaunayedges(tess)
    i += 1
    # or, do something more useful :)
end</code></pre><p>a <code>DelaunayEdge</code> contains two points a and b, they can be accesse with <code>geta(edge)</code> and <code>getb(edge)</code>. Iterating over Voronoi edges is similar:</p><pre><code class="language-Julia">i = 0
for edge in voronoiedges(tess)
    i += 1
    # or, do something more useful :)
end</code></pre><p>a <code>VoronoiEdge</code> is a bit different than a <code>DelaunayEdge</code>: here <code>a</code> and <code>b</code> are <code>Point2D</code> and not the generators, as they have different coordinates. To get the generators use <code>getgena(edge)</code> and <code>getgenb(edge)</code> these give the relevant <code>AbstractPoint2D</code> which were used to create the edge.</p><p>If the generators are not needed when iterating over the Voronoi edges (e.g. when plotting) then a more efficient way to iterate is:</p><pre><code class="language-Julia">i = 0
e=Nothing
for edge in voronoiedgeswithoutgenerators(tess)
    i += 1
    # do something more useful here :)
end</code></pre><p>here <code>edge</code> is a <code>VoronoiEdgeWithoutGenerators</code>, the points <code>a</code> and <code>b</code> can be accessed as usual.</p><p>Iterating over Delaunay triangles:</p><pre><code class="language-Julia">i = 0
for delaunaytriangle in tess
    i += 1
    # or, do something more useful :)
end</code></pre><p><code>delaunaytriangle</code> here is of type <code>DelaunayTriagle</code> which is s subtype of <code>AbstractNegativelyOrientedTriangle</code>. To get the generators of this triangle use the <code>geta</code>, <code>getb</code>, and <code>getc</code> methods. You can do all other operations and predicate tests on this triangle as explained in <a href="https://github.com/skariel/GeometricalPredicates.jl">GeometricalPredicates</a></p><h3><a class="nav-anchor" id="Navigating-1" href="#Navigating-1">Navigating</a></h3><p>Locating a point, i.e. finding the triangle it is inside:</p><pre><code class="language-Julia">t = locate(tess, Point(1.2, 1.3))</code></pre><p>if the point is outside of the tessellation then <code>isexternal(t) == true</code> holds. This is good for type stability, at least better than returning a <code>Nothing</code>. It is assumed that the point we want to locate is actually in the allowed points region. Performance is best when locating points close to each other (this is also why spatial sorting is used). Future versions may implement a hierarchal approach for fast random locations.</p><p>Navigating from a triangle to its neighbours is done like this:</p><pre><code class="language-Julia">t = movea(tess, t)  # move to the direction infront of generator a
t = moveb(tess, t)  # move to the direction infront of generator b
t = movec(tess, t)  # move to the direction infront of generator c</code></pre><h3><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h3><p>The following retrieves a couple of vectors ready to plot Voronoi edges:</p><pre><code class="language-Julia">x, y = getplotxy(voronoiedges(tess))</code></pre><p>and for Delaunay edges:</p><pre><code class="language-Julia">x, y = getplotxy(delaunayedges(tess))</code></pre><p>Now plotting can be done with your favorite plotting package, for e.g.:</p><pre><code class="language-Julia">using Gadfly
plot(x=x, y=y, Geom.path)</code></pre><p>To make a nice looking plot remember to limit the axes and aspect ratio. For e.g.:</p><pre><code class="language-Julia">set_default_plot_size(15cm, 15cm)
plot(x=x, y=y, Geom.path, Scale.x_continuous(minvalue=1.0, maxvalue=2.0), Scale.y_continuous(minvalue=1.0, maxvalue=2.0))</code></pre><h3><a class="nav-anchor" id="From-an-image-1" href="#From-an-image-1">From an image</a></h3><p>You can create a tesselation from an image, just like the tesselation of the julia logo at the top of this README. This was created from a png with <code>from_file</code> (see <code>examples/img_to_vorono.jl</code>):</p><pre><code class="language-Julia">import Images: imread
img = imread(&quot;julia.png&quot;)
tess = from_image(img, 25000)</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
