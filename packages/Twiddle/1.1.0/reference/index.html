<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference Manual · Twiddle.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Twiddle.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../bitcounting/">Counting bits</a></li><li class="current"><a class="toctext" href>Reference Manual</a><ul class="internal"></ul></li><li><a class="toctext" href="../nibbles/">Working with Nibbles</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Reference Manual</a></li></ul></nav><hr/><div id="topbar"><span>Reference Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-Manual-1" href="#Reference-Manual-1">Reference Manual</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_0000_nibbles-Tuple{Unsigned}" href="#Twiddle.count_0000_nibbles-Tuple{Unsigned}"><code>Twiddle.count_0000_nibbles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_0000_nibbles(x::Unsigned)</code></pre><p>Counts the number of nibbles (aligned 4 bit segments) in an unsigned integer <code>x</code> that have all their bits unset i.e. nibbles of 0000.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_00_bitpairs-Tuple{Unsigned}" href="#Twiddle.count_00_bitpairs-Tuple{Unsigned}"><code>Twiddle.count_00_bitpairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_00_bitpairs(x::Unsigned)</code></pre><p>Count the number of bit pairs in an unsigned integer <code>x</code> which have no bits set.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 13.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_01_bitpairs-Tuple{Unsigned}" href="#Twiddle.count_01_bitpairs-Tuple{Unsigned}"><code>Twiddle.count_01_bitpairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_01_bitpairs(x::Unsigned)</code></pre><p>Count the number of bit pairs in an unsigned integer <code>x</code> which have just their LSB set.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 11.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_10_bitpairs-Tuple{Unsigned}" href="#Twiddle.count_10_bitpairs-Tuple{Unsigned}"><code>Twiddle.count_10_bitpairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_10_bitpairs(x::Unsigned)</code></pre><p>Count the number of bit pairs in an unsigned integer <code>x</code> which have just their MSB set.</p><p>E.g. An input of:</p><p>0x8F11F111F11A11F1</p><p>Would give the answer: 3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_1111_nibbles-Tuple{Unsigned}" href="#Twiddle.count_1111_nibbles-Tuple{Unsigned}"><code>Twiddle.count_1111_nibbles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_1111_nibbles(x::Unsigned)</code></pre><p>Counts the number of nibbles (aligned 4 bit segments) in an unsigned integer <code>x</code> that have all their bits set i.e. counts all nibbles of 1111 in an integer.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_11_bitpairs-Tuple{Unsigned}" href="#Twiddle.count_11_bitpairs-Tuple{Unsigned}"><code>Twiddle.count_11_bitpairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_11_bitpairs(x::Unsigned)</code></pre><p>Count the number of bit pairs in an unsigned integer <code>x</code> which have both bits set.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 8.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_nonzero_bitpairs-Tuple{Unsigned}" href="#Twiddle.count_nonzero_bitpairs-Tuple{Unsigned}"><code>Twiddle.count_nonzero_bitpairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_nonzero_bitpairs(x::Unsigned)</code></pre><p>Count the number of bit pairs in an unsigned integer <code>x</code> which have at least one bit set.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 19.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.count_nonzero_nibbles-Tuple{Unsigned}" href="#Twiddle.count_nonzero_nibbles-Tuple{Unsigned}"><code>Twiddle.count_nonzero_nibbles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_nonzero_nibbles(x::Unsigned)</code></pre><p>Count the number of nibbles (aligned 4 bit segments) in an unsigned integer <code>x</code> which have at least one bit set.</p><p>E.g. An input of:</p><p>0x0F11F111F11111F1</p><p>Would give the answer: 15.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.enumerate_nibbles-Union{Tuple{T}, Tuple{T}} where T&lt;:Unsigned" href="#Twiddle.enumerate_nibbles-Union{Tuple{T}, Tuple{T}} where T&lt;:Unsigned"><code>Twiddle.enumerate_nibbles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">enumerate_nibbles{T&lt;:Unsigned}(x::T)</code></pre><p>Count the number of set bits in each nibble (aligned 4 bit segments) of an unsigned integer <code>x</code>.</p><p>E.g. An input of:</p><p>0100 0010 0001 0110 1100 1110 1101 1111</p><p>Would result in:</p><p>0001 0001 0001 0010 0010 0011 0011 0100</p><p>This is used to identify different occurances of certain bit patterns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.mask-Union{Tuple{T}, Tuple{Type{T},Integer}} where T&lt;:Unsigned" href="#Twiddle.mask-Union{Tuple{T}, Tuple{Type{T},Integer}} where T&lt;:Unsigned"><code>Twiddle.mask</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mask{T&lt;:Unsigned}(::Type{T}, n::Integer)</code></pre><p>Creates a bit mask for given number of bits <code>n</code>.</p><p>The mask starts from the least significant bit, and end at bit <code>n</code>.</p><p>e.g:</p><pre><code class="language-julia-repl">julia&gt; Twiddle.mask(UInt64, 8)
0x00000000000000ff</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.nibble_capacity-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned" href="#Twiddle.nibble_capacity-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><code>Twiddle.nibble_capacity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nibble_capacity{T&lt;:Unsigned}(::Type{T})</code></pre><p>Returns the number of nibbles that an unsigned integer of type <code>T</code> holds. This is essentially twice the size of the type (in bytes).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.nibble_mask-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Unsigned" href="#Twiddle.nibble_mask-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Unsigned"><code>Twiddle.nibble_mask</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nibble_mask{T&lt;:Unsigned}(value::T, x::T)</code></pre><p>Create a mask for the nibbles (aligned 4 bit segments) in an unsigned integer <code>x</code> that filter nibbles matching the corresponding nibble in <code>value</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.repeatpattern-Union{Tuple{T}, Tuple{Type{T},Unsigned}} where T&lt;:Unsigned" href="#Twiddle.repeatpattern-Union{Tuple{T}, Tuple{Type{T},Unsigned}} where T&lt;:Unsigned"><code>Twiddle.repeatpattern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">repeatpattern{T&lt;:Unsigned}(::Type{T}, pattern::Unsigned)</code></pre><p>Repeats the bitpattern of the <code>pattern</code> integer throughout the an Unsigned integer of type <code>T</code>. Note that this assumed the size of T (in bits) is larger than that of the <code>pattern</code> integer.</p><p>This is useful for bit-twiddling code that is to work on any word size.</p><p>Let&#39;s use a very simple example to show why this is useful. Let&#39;s say you have a function in which a byte is masked with a bitmask 0x33.</p><pre><code class="language-julia">f(x::UInt8) = x &amp; 0x33</code></pre><p>Suppose you wanted this to work for any word size, so 8 bit, 16 bit, 32 bit, 64 bit, and 128 bit words? One way is to write <code>f</code> as a set of seperate methods:</p><pre><code class="language-julia">f(x::UInt8) = x &amp; 0x33
f(x::UInt16) = x &amp; 0x3333
f(x::UInt32) = x &amp; 0x33333333
f(x::UInt64) = x &amp; 0x3333333333333333
f(x::UInt128) = x &amp; 0x33333333333333333333333333333333</code></pre><p>This is clearly not ideal, you would be writing out the same method multiplet times, but with a differently sized literal for the mask each time.</p><p>Alternatively, you could write one parametric function with repeatbyte:</p><pre><code class="language-julia">f2(x::T) where {T&lt;:Unsigned} = x &amp; Twiddle.repeatpattern(T, 0x33)
# Or a non-parametric version using `typeof`.
f3(x::Unsigned) = x &amp; Twiddle.repeatpattern(typeof(x), 0x33)</code></pre><p>You might expect this to be less efficient - <code>repeatpattern</code> uses several operations to generate the values 0x33, 0x3333 and so on, whereas in the seperate methods, those literal values are hard coded. However, thanks to constant folding during compilation, those operations are done once at compilation time and so the native instructions generated are identical. You can check this with <code>@code_llvm</code> or <code>@code_native</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Twiddle.swapbits-Union{Tuple{T}, Tuple{T,Integer,Integer}} where T&lt;:Unsigned" href="#Twiddle.swapbits-Union{Tuple{T}, Tuple{T,Integer,Integer}} where T&lt;:Unsigned"><code>Twiddle.swapbits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">swapbits{T&lt;:Unsigned}(x::T, i::Integer, j::Integer)</code></pre><p>Swap the i&#39;th and j&#39;th bits in an unsigned integer. Note this uses zero based indexes for <code>i</code> and <code>j</code>.</p><p>E.g. to swap the LSB and MSB of a byte: 1001 1000 (0x98) -&gt; 0001 1001 (0x19)</p><pre><code class="language-">swapbits(0x98, 0, 7)</code></pre></div></div></section><footer><hr/><a class="previous" href="../bitcounting/"><span class="direction">Previous</span><span class="title">Counting bits</span></a><a class="next" href="../nibbles/"><span class="direction">Next</span><span class="title">Working with Nibbles</span></a></footer></article></body></html>
