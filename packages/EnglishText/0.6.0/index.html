<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EnglishText.jl Documentation · EnglishText.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-68884109-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>EnglishText.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>EnglishText.jl Documentation</a><ul class="internal"><li><a class="toctext" href="#Indefinite-Article-Selection-1">Indefinite Article Selection</a></li><li><a class="toctext" href="#Word-Representation-of-Numbers-1">Word Representation of Numbers</a></li><li><a class="toctext" href="#Quantities-and-Pluralization-1">Quantities and Pluralization</a></li><li><a class="toctext" href="#Lists-of-Nouns-and-Adjectives-1">Lists of Nouns and Adjectives</a></li><li><a class="toctext" href="#Parsing-Sentences-1">Parsing Sentences</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li><li><a class="toctext" href="#Citations-1">Citations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>EnglishText.jl Documentation</a></li></ul></nav><hr/><div id="topbar"><span>EnglishText.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="EnglishText.jl-Documentation-1" href="#EnglishText.jl-Documentation-1">EnglishText.jl Documentation</a></h1><p>Many applications display information to readers in prose format instead of tabular format. It is often important to generate human-readable, grammatically correct prose. However, taking care of grammatical special cases is tedious.</p><p>EnglishText.jl solves this problem by providing a variety of convenient utility functions. It uses established algorithms where available. The precise methods used are documented in the modules themselves.</p><p>EnglishText.jl uses a modular approach. Applications not requiring all the exports may use a submodule, such as <code>EnglishText.ItemLists</code>, instead of the entire package.</p><p>EnglishText.jl aims to</p><ul><li>provide a convenient, universally useful approach to abstracting away grammatical special cases</li><li>be self-documenting where possible, but well-documented nevertheless</li><li>not have unnecessary performance bottlenecks</li></ul><p>Note that this is not a natural language processing package and does not aim to include an English parser.</p><ul><li><a href="#EnglishText.jl-Documentation-1">EnglishText.jl Documentation</a></li><ul><li><a href="#Indefinite-Article-Selection-1">Indefinite Article Selection</a></li><li><a href="#Word-Representation-of-Numbers-1">Word Representation of Numbers</a></li><li><a href="#Quantities-and-Pluralization-1">Quantities and Pluralization</a></li><li><a href="#Lists-of-Nouns-and-Adjectives-1">Lists of Nouns and Adjectives</a></li><li><a href="#Parsing-Sentences-1">Parsing Sentences</a></li><li><a href="#Internals-1">Internals</a></li><li><a href="#Citations-1">Citations</a></li></ul></ul><h2><a class="nav-anchor" id="Indefinite-Article-Selection-1" href="#Indefinite-Article-Selection-1">Indefinite Article Selection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Articulate.indefinite" href="#EnglishText.Articulate.indefinite"><code>EnglishText.Articulate.indefinite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">indefinite(word)</code></pre><p>Determine the correct indefinite article, from “a” or “an”, for the given noun.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; indefinite(&quot;hour&quot;)
&quot;an&quot;

julia&gt; indefinite(&quot;hand&quot;)
&quot;a&quot;</code></pre></div></div></section><h2><a class="nav-anchor" id="Word-Representation-of-Numbers-1" href="#Word-Representation-of-Numbers-1">Word Representation of Numbers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Numeric.english" href="#EnglishText.Numeric.english"><code>EnglishText.Numeric.english</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">english(n::Integer)</code></pre><p>Convert <span>$n$</span> to English, given that <span>$0 \le n &lt; 10^{66}$</span>.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; english(16)
&quot;sixteen&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Numeric.unenglish" href="#EnglishText.Numeric.unenglish"><code>EnglishText.Numeric.unenglish</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unenglish(T &lt;: Integer, data::AbstractString) → T</code></pre><p>Convert <code>data</code> to an integral type. This function has the guarantee that <code>unenglish(Int, english(x)) == x</code>, modulo any type differences. It is not guaranteed to work well or throw exceptions on other inputs.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; unenglish(Int, &quot;sixteen&quot;)
16</code></pre></div></div></section><h2><a class="nav-anchor" id="Quantities-and-Pluralization-1" href="#Quantities-and-Pluralization-1">Quantities and Pluralization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Quantities.ItemQuantity" href="#EnglishText.Quantities.ItemQuantity"><code>EnglishText.Quantities.ItemQuantity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ItemQuantity(n::Integer, item::AbstractString)</code></pre><p>Represents a quantity of <code>n</code> occurrences of <code>item</code>. Although this is not a collection, for ease of use, it implements some of the standard collection methods <code>length</code> (for number of items) and <code>isempty</code> (for whether there are no items).</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; ItemQuantity(2, &quot;apple&quot;)
2 apples

julia&gt; ItemQuantity(1, &quot;standard canine&quot;)
1 standard canine</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ItemQuantity}" href="#Base.isempty-Tuple{ItemQuantity}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(quantity::ItemQuantity)</code></pre><p>Return <code>true</code> if the given <code>ItemQuantity</code> represents no items.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; isempty(ItemQuantity(0, &quot;orange&quot;))
true

julia&gt; isempty(ItemQuantity(4, &quot;person&quot;))
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{ItemQuantity}" href="#Base.length-Tuple{ItemQuantity}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(quantity::ItemQuantity)</code></pre><p>Return the number of items represented by this quantity.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; length(ItemQuantity(7, &quot;desk&quot;))
7</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Pluralize.pluralize" href="#EnglishText.Pluralize.pluralize"><code>EnglishText.Pluralize.pluralize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pluralize(word; classical=true)</code></pre><p>Pluralize a singular noun <code>word</code> (given in canonical capitalization) using heuristics and lists of exceptions. If <code>word</code> is not a singular noun, this function may give strange results.</p><p>If <code>classical</code> is set to <code>true</code>, then the classical (i.e. inherited from Latin or Greek) pluralization is chosen instead of the anglicized pluralization. As an example, the classical plural of <code>&quot;vertex&quot;</code> is <code>&quot;vertices&quot;</code>, but the anglicized plural is <code>&quot;vertexes&quot;</code>. By default, the classical pluralization is used.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; pluralize(&quot;fox&quot;)
&quot;foxes&quot;

julia&gt; pluralize(&quot;radius&quot;)
&quot;radii&quot;

julia&gt; pluralize(&quot;radius&quot;, classical=false)
&quot;radiuses&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Pluralize.singularize" href="#EnglishText.Pluralize.singularize"><code>EnglishText.Pluralize.singularize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">singularize(word)</code></pre><p>Unpluralize a plural noun (given in canonical capitalization) using heuristics and lists of exceptions. If the given <code>word</code> is not a plural noun, the result may be unpredictable.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; singularize(&quot;foxes&quot;)
&quot;fox&quot;

julia&gt; singularize(&quot;data&quot;)
&quot;datum&quot;</code></pre></div></div></section><h2><a class="nav-anchor" id="Lists-of-Nouns-and-Adjectives-1" href="#Lists-of-Nouns-and-Adjectives-1">Lists of Nouns and Adjectives</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.ItemLists.ItemList" href="#EnglishText.ItemLists.ItemList"><code>EnglishText.ItemLists.ItemList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ItemList(objects, connective=Sum())</code></pre><p>A list of items or adjectives, which supports printing in standard English format. The first argument <code>objects</code> should be an iterator over some number of strings or other objects, including <a href="#EnglishText.Quantities.ItemQuantity"><code>EnglishText.ItemQuantity</code></a> objects.</p><p>The second argument <code>connective</code> should be one of:</p><ul><li><code>Sum()</code>, which represents a list of nouns in a collection of things</li><li><code>Disjunction()</code>, which represents a list of traits (typically adjectives or adverbs, but possibly also verbs or nouns) for which at least one should be satisfied</li><li><code>Conjunction()</code>, which represents a list of traits that should all be satisfied</li></ul><p>If omitted, <code>connective</code> is set to <code>Sum()</code>.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; ItemList([&quot;apples&quot;, &quot;oranges&quot;])
apples and oranges

julia&gt; ItemList([ItemQuantity(2, &quot;pencil&quot;), ItemQuantity(1, &quot;pen&quot;)])
2 pencils and 1 pen

julia&gt; ItemList([&quot;animal&quot;, &quot;plant&quot;], Disjunction())
animal or plant

julia&gt; ItemList([&quot;red&quot;, &quot;blue&quot;, &quot;white&quot;], Conjunction())
red, blue, and white

julia&gt; &quot;Help us use and test this software.&quot;
&quot;Help us use and test this software.&quot;</code></pre></div></div></section><h2><a class="nav-anchor" id="Parsing-Sentences-1" href="#Parsing-Sentences-1">Parsing Sentences</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Text.sentences" href="#EnglishText.Text.sentences"><code>EnglishText.Text.sentences</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sentences(text::AbstractString)</code></pre><p>Return an iterable over the <code>Sentence</code>s contained within <code>text</code>. Sentences are identified naïvely; that is, every full stop, exclamation mark, or question mark is considered to delimit a sentence. This is of course prone to error, as some full stops are used for abbreviations and not for delimiting sentences.</p><pre><code class="language-julia-repl">julia&gt; using EnglishText

julia&gt; for s in sentences(&quot;Hi! Iterate over sentences. OK?&quot;)
           println(s)
       end
Hi!
Iterate over sentences.
OK?</code></pre></div></div></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnglishText.Semantics.SemanticText" href="#EnglishText.Semantics.SemanticText"><code>EnglishText.Semantics.SemanticText</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An object representing a string of text but with additional semantic information. These objects convert to <code>String</code>s through the <code>string</code> function, but also typically support other operations.</p></div></div></section><h2><a class="nav-anchor" id="Citations-1" href="#Citations-1">Citations</a></h2><ul><li>Conway, D. M. (1998, August). An algorithmic approach to english pluralization. In Proceedings of the Second Annual Perl Conference.</li></ul><footer><hr/></footer></article></body></html>
