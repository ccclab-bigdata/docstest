<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heuristics · Traveling Salesman Heuristics</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Traveling Salesman Heuristics</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Heuristics</a><ul class="internal"><li><a class="toctext" href="#Path-generation-heuristics-1">Path generation heuristics</a></li><li><a class="toctext" href="#Path-refinement-heuristics-1">Path refinement heuristics</a></li><li><a class="toctext" href="#Repetitive-heuristics-1">Repetitive heuristics</a></li><li><a class="toctext" href="#Lower-bounds-1">Lower bounds</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Heuristics</a></li></ul></nav><hr/><div id="topbar"><span>Heuristics</span><a class="fa fa-bars" href="#"></a></div></header><p>This page describes the heuristics currently implemented by this package. The heuristics are split into <em>path generation</em> heuristics, which create an initial path from a problem instance (specified by a distance matrix) and <em>path refinement</em> heuristics which take an input path and attempt to improve it.</p><h2><a class="nav-anchor" id="Path-generation-heuristics-1" href="#Path-generation-heuristics-1">Path generation heuristics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.nearest_neighbor" href="#TravelingSalesmanHeuristics.nearest_neighbor"><code>TravelingSalesmanHeuristics.nearest_neighbor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nearest_neighbor(distmat)</code></pre><p>Approximately solve a TSP using the nearest neighbor heuristic. <code>distmat</code> is a square real matrix  where distmat[i,j] represents the distance from city <code>i</code> to city <code>j</code>. The matrix needn&#39;t be symmetric and can contain negative values. Return a tuple <code>(path, pathcost)</code>.</p><p><strong>Optional keyword arguments:</strong></p><ul><li><code>firstcity::Union{Int, Nothing}</code>: specifies the city to begin the path on. Passing <code>nothing</code> or   not specifying a value corresponds to random selection. </li><li><code>closepath::Bool = true</code>: whether to include the arc from the last city visited back to the   first city in cost calculations. If true, the first city appears first and last in the path.</li><li><code>do2opt::Bool = true</code>: whether to refine the path found by 2-opt switches (corresponds to    removing path crossings in the planar Euclidean case).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.farthest_insertion" href="#TravelingSalesmanHeuristics.farthest_insertion"><code>TravelingSalesmanHeuristics.farthest_insertion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">farthest_insertion(distmat; ...)</code></pre><p>Generate a TSP path using the farthest insertion strategy. <code>distmat</code> must be a square real matrix. Return a tuple <code>(path, cost)</code>.</p><p><strong>Optional arguments:</strong></p><ul><li><code>firstCity::Int</code>: specifies the city to begin the path on. Not specifying a value corresponds   to random selection.</li><li><code>do2opt::Bool = true</code>: whether to improve the path by 2-opt swaps.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.cheapest_insertion" href="#TravelingSalesmanHeuristics.cheapest_insertion"><code>TravelingSalesmanHeuristics.cheapest_insertion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cheapest_insertion(distmat::Matrix, initpath::AbstractArray{Int})</code></pre><p>Given a distance matrix and an initial path, complete the tour by repeatedly doing the cheapest  insertion. Return a tuple <code>(path, cost)</code>. The initial path must have length at least 2, but can be simply <code>[i, i]</code> for some city index <code>i</code> which corresponds to starting with a loop at city <code>i</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Insertions are always in the interior of the current path so this heuristic can also be used for non-closed TSP paths.</p></div></div><p>Currently the implementation is a naive <span>$n^3$</span> algorithm.</p></div></div><div><div><pre><code class="language-none">cheapest_insertion(distmat; ...)</code></pre><p>Complete a tour using cheapest insertion with a single-city loop as the initial path. Return a tuple <code>(path, cost)</code>.</p><p><strong>Optional keyword arguments:</strong></p><ul><li><code>firstCity::Union{Int, Nothing}</code>: specifies the city to begin the path on. Passing <code>nothing</code> or   not specifying a value corresponds to random selection.</li><li><code>do2opt::Bool = true</code>: whether to improve the path found by 2-opt swaps.</li></ul></div></div></section><h2><a class="nav-anchor" id="Path-refinement-heuristics-1" href="#Path-refinement-heuristics-1">Path refinement heuristics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.two_opt" href="#TravelingSalesmanHeuristics.two_opt"><code>TravelingSalesmanHeuristics.two_opt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">two_opt(distmat, path)</code></pre><p>Improve <code>path</code> by doing 2-opt switches (i.e. reversing part of the path) until doing so no longer reduces the cost. Return a tuple <code>(improved_path, improved_cost)</code>.</p><p>On large problem instances this heuristic can be slow, but it is highly recommended on small and medium problem instances.</p><p>See also <code>simulated_annealing</code> for another path generation heuristic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.simulated_annealing" href="#TravelingSalesmanHeuristics.simulated_annealing"><code>TravelingSalesmanHeuristics.simulated_annealing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>simulated_annealing(distmat; ...)</p><p>Use a simulated annealing strategy to return a closed tour. The temperature decays exponentially from <code>init_temp</code> to <code>final_temp</code>. Return a tuple <code>(path, cost)</code>.</p><p><strong>Optional keyword arguments:</strong></p><ul><li><code>steps::Int = 50n^2</code>: number of steps to take; defaults to 50n^2 where n is number of cities</li><li><code>num_starts::Int = 1</code>: number of times to run the simulated annealing algorithm, each time   starting with a random path, or <code>init_path</code> if non-null. Defaults to 1.</li><li><code>init_temp::Real = exp(8)</code>: initial temperature which controls initial chance of accepting an   inferior tour.</li><li><code>final_temp::Real = exp(-6.5)</code> final temperature which controls final chance of accepting an   inferior tour; lower values roughly correspond to a longer period of 2-opt.</li><li><code>init_path::Union{Vector{Int}, Nothing} = nothing</code>: path to start the annealing from.   Either a <code>Vector{Int}</code> or <code>nothing</code>. If a <code>Vector{Int}</code> is given, it will be used as the initial path;   otherwise a random initial path is used.</li></ul></div></div></section><h2><a class="nav-anchor" id="Repetitive-heuristics-1" href="#Repetitive-heuristics-1">Repetitive heuristics</a></h2><p>Many of the heuristics in this package require some starting state. For example, the nearest neighbor heuristic begins at a first city and then iteratively continues to whichever unvisited city is closest to the current city. Therefore, running the heuristic with different choices for the first city may produce different final paths. At the cost of increased computation time, a better path can often be found by starting the heuristic method at each city. The convenience method <code>repetitive_heuristic</code> is provided to help with this use case:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.repetitive_heuristic" href="#TravelingSalesmanHeuristics.repetitive_heuristic"><code>TravelingSalesmanHeuristics.repetitive_heuristic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repetitive_heuristic(distmat::Matrix, heuristic::Function, repetitive_kw::Symbol; keywords...)</code></pre><p>For each <code>i</code> in <code>1:n</code>, run <code>heuristic</code> with keyword <code>repetitive_kw</code> set to <code>i</code>. Return the tuple <code>(bestpath, bestcost)</code>. By default, <code>repetitive_kw</code> is <code>:firstcity</code>, which is appropriate for the <code>farthest_insertion</code>, <code>cheapest_insertion</code>, and <code>nearest_neighbor</code> heuristics. </p><p>Any keywords passed to <code>repetitive_heuristic</code> are passed along to each call of <code>heuristic</code>. For example, <code>repetitive_heuristic(dm, nearest_neighbor; do2opt = true)</code> will perform 2-opt for each of the <code>n</code> nearest neighbor paths.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The repetitive heuristic calls are parallelized with threads. For optimum speed make sure Julia is running with multiple threads.</p></div></div></div></div></section><h2><a class="nav-anchor" id="Lower-bounds-1" href="#Lower-bounds-1">Lower bounds</a></h2><p>A simple lower bound on the cost of the optimal tour is provided. This bound uses no problem-specific structure; if you know some details of your problem instance, you can probably find a tighter bound.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TravelingSalesmanHeuristics.lowerbound" href="#TravelingSalesmanHeuristics.lowerbound"><code>TravelingSalesmanHeuristics.lowerbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowerbound(distmat)</code></pre><p>Lower bound the cost of the optimal TSP tour. At present, the bounds considered are a simple bound based on the minimum cost of entering and exiting each city and a slightly better bound inspired by the Held-Karp bounds; note that the implementation here is simpler and less tight than proper HK bounds.</p><p>The Held-Karp-inspired bound requires computing many spanning trees. For a faster but typically looser bound, use <code>TravelingSalesmanHeuristics.vertwise_bound(distmat)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The spanning tree bounds are only correct on symmetric problem instances and will not be used if the passed <code>distmat</code> is not symmetric. If you wish to use these bounds anyway, (e.g. for near-symmetric instances), use <code>TravelingSalesmanHeuristics.hkinspired_bound</code>.</p></div></div></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
