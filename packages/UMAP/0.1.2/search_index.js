var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#UMAP.jl-1",
    "page": "Readme",
    "title": "UMAP.jl",
    "category": "section",
    "text": "(Image: Build Status)(Image: Build status) (Image: Coverage Status) (Image: codecov)A pure Julia implementation of the Uniform Manifold Approximation and Projection dimension reduction algorithmMcInnes, L, Healy, J, Melville, J, UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. ArXiV 1802.03426, 2018"
},

{
    "location": "#Usage-1",
    "page": "Readme",
    "title": "Usage",
    "category": "section",
    "text": "embedding = umap(X, n_components; n_neighbors, metric, min_dist, ...)The umap function takes two arguments, X (a matrix of shape (nfeatures, nsamples)), n_components (the number of dimensions in the output embedding), and various keyword arguments. Several important ones are:n_neighbors::Int=15: This controls how many neighbors around each point are considered to be part of its local neighborhood. Larger values will result in embeddings that capture more global structure, while smaller values will preserve more local structures.\nmetric::SemiMetric=Euclidean(): The (semi)metric to use when calculating distances between points. This can be any subtype of the SemiMetric type from the Distances.jl package, including user-defined types.\nmin_dist::Float=0.1: This controls the minimum spacing of points in the embedding. Larger values will cause points to be more evenly distributed, while smaller values will preserve more local structure.The returned embedding will be a matrix of shape (ncomponents, nsamples)."
},

{
    "location": "#Implementation-Details-1",
    "page": "Readme",
    "title": "Implementation Details",
    "category": "section",
    "text": "There are two main steps involved in UMAP: building a weighted graph with edges connecting points to their nearest neighbors, and optimizing the low-dimensional embedding of that graph. The first step is accomplished either by an exact kNN search (for datasets with < 4096 points) or by the approximate kNN search algorithm, NNDescent. This step is also usually the most costly.The low-dimensional embedding is initialized (by default) with the eigenvectors of the normalized Laplacian of the kNN graph. These are found using ARPACK (via Arpack.jl)."
},

{
    "location": "#Current-Limitations-1",
    "page": "Readme",
    "title": "Current Limitations",
    "category": "section",
    "text": "No transform: Only one-time embeddings are possible at the moment. That is to say, it isn\'t possible to \"fit\" UMAP to a dataset and then use it to \"transform\" new data\nInput data types: Only data points that are represented by vectors of numbers (passed in as a matrix) are valid inputs. This is mostly due to a lack of support for other formats in NNDescent. Support for e.g. string datasets is possible in the future\nSequential: This implementation does not take advantage of any parallelism"
},

{
    "location": "#External-Resources-1",
    "page": "Readme",
    "title": "External Resources",
    "category": "section",
    "text": "For a great description of how UMAP works, see this page from the Python UMAP documentation\nIf you\'re familiar with t-SNE, then this page describes UMAP with similar vocabulary to that dimension reduction algorithm"
},

{
    "location": "#Examples-1",
    "page": "Readme",
    "title": "Examples",
    "category": "section",
    "text": "The full MNIST and FMNIST datasets are plotted below using both this implementation and the Python implementation for comparison. These were generated by this notebook.Note that the memory allocation for the Python UMAP is unreliable, as Julia\'s benchmarking doesn\'t count memory allocated within Python itself."
},

{
    "location": "#MNIST-1",
    "page": "Readme",
    "title": "MNIST",
    "category": "section",
    "text": "(Image: Julia MNIST) (Image: Python MNIST)"
},

{
    "location": "#FMNIST-1",
    "page": "Readme",
    "title": "FMNIST",
    "category": "section",
    "text": "(Image: Julia FMNIST) (Image: Python FMNIST)"
},

{
    "location": "#Disclaimer-1",
    "page": "Readme",
    "title": "Disclaimer",
    "category": "section",
    "text": "This implementation is a work-in-progress. If you encounter any issues, please create an issue or make a pull request."
},

{
    "location": "autodocs/#UMAP.compute_membership_strengths",
    "page": "Docstrings",
    "title": "UMAP.compute_membership_strengths",
    "category": "function",
    "text": "compute_membership_strengths(knns, dists, σs, ρs) -> rows, cols, vals\n\nCompute the membership strengths for the 1-skeleton of each fuzzy simplicial set.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.fit_ϕ",
    "page": "Docstrings",
    "title": "UMAP.fit_ϕ",
    "category": "function",
    "text": "fit_ϕ(min_dist, spread) -> a, b\n\nFind a smooth approximation to the membership function of points embedded in ℜᵈ. This fits a smooth curve that approximates an exponential decay offset by min_dist.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.fuzzy_simplicial_set",
    "page": "Docstrings",
    "title": "UMAP.fuzzy_simplicial_set",
    "category": "function",
    "text": "fuzzy_simplicial_set(X, n_neighbors, metric, local_connectivity, set_op_ratio) -> graph::SparseMatrixCSC\n\nConstruct the local fuzzy simplicial sets of each point in X by finding the approximate nearest n_neighbors, normalizing the distances on the manifolds, and converting the metric space to a simplicial set.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.knn_search",
    "page": "Docstrings",
    "title": "UMAP.knn_search",
    "category": "function",
    "text": "knn_search(X, k, metric) -> knns, dists\n\nFind the k nearest neighbors of each point in X by metric.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.optimize_embedding",
    "page": "Docstrings",
    "title": "UMAP.optimize_embedding",
    "category": "function",
    "text": "optimize_embedding(graph, embedding, n_epochs, initial_alpha, min_dist, spread, gamma, neg_sample_rate) -> embedding\n\nOptimize an embedding by minimizing the fuzzy set cross entropy between the high and low dimensional simplicial sets using stochastic gradient descent.\n\nArguments\n\ngraph: a sparse matrix of shape (nsamples, nsamples)\nembedding: a dense matrix of shape (ncomponents, nsamples)\nn_epochs: the number of training epochs for optimization\ninitial_alpha: the initial learning rate\ngamma: the repulsive strength of negative samples \nneg_sample_rate::Integer: the number of negative samples per positive sample\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.smooth_knn_dists",
    "page": "Docstrings",
    "title": "UMAP.smooth_knn_dists",
    "category": "function",
    "text": "smooth_knn_dists(dists, k, local_connectivity; <kwargs>) -> knn_dists, nn_dists\n\nCompute the distances to the nearest neighbors for a continuous value k. Returns the approximated distances to the kth nearest neighbor (knn_dists) and the nearest neighbor (nn_dists) from each point.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.spectral_layout",
    "page": "Docstrings",
    "title": "UMAP.spectral_layout",
    "category": "function",
    "text": "spectral_layout(graph, embed_dim) -> embedding\n\nInitialize the graph layout with spectral embedding.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#UMAP.umap",
    "page": "Docstrings",
    "title": "UMAP.umap",
    "category": "function",
    "text": "umap(X::AbstractMatrix[, n_components=2]; <kwargs>) -> embedding\n\nEmbed the data X into a n_components-dimensional space. n_neighbors controls how many neighbors to consider as locally connected.\n\nKeyword Arguments\n\nn_neighbors::Integer = 15: the number of neighbors to consider as locally connected. Larger values capture more global structure in the data, while small values capture more local structure.\nmetric::SemiMetric = Euclidean(): the metric to calculate distance in the input space\nn_epochs::Integer = 300: the number of training epochs for embedding optimization\nlearning_rate::AbstractFloat = 1.: the initial learning rate during optimization\ninit::Symbol = :spectral: how to initialize the output embedding; valid options are :spectral and :random\nmin_dist::AbstractFloat = 0.1: the minimum spacing of points in the output embedding\nspread::AbstractFloat = 1.0: the effective scale of embedded points. Determines how clustered embedded points are in combination with min_dist.\nset_operation_ratio::AbstractFloat = 1.0: interpolates between fuzzy set union and fuzzy set intersection when constructing the UMAP graph (global fuzzy simplicial set). The value of this parameter should be between 1.0 and 0.0: 1.0 indicates pure fuzzy union, while 0.0 indicates pure fuzzy intersection.\nlocal_connectivity::Integer = 1: the number of nearest neighbors that should be assumed to be locally connected. The higher this value, the more connected the manifold becomes. This should not be set higher than the intrinsic dimension of the manifold.\nrepulsion_strength::AbstractFloat = 1.0: the weighting of negative samples during the optimization process.\nneg_sample_rate::Integer = 5: the number of negative samples to select for each positive sample. Higher values will increase computational cost but result in slightly more accuracy.\na::AbstractFloat = nothing: this controls the embedding. By default, this is determined automatically by min_dist and spread.\nb::AbstractFloat = nothing: this controls the embedding. By default, this is determined automatically by min_dist and spread.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "UMAP.SMOOTH_K_TOLERANCEUMAP.UMAPUMAP.UMAP_UMAP.combine_fuzzy_setsUMAP.compute_membership_strengthsUMAP.evalUMAP.fit_ϕUMAP.fuzzy_set_intersectionUMAP.fuzzy_set_unionUMAP.fuzzy_simplicial_setUMAP.includeUMAP.initialize_embeddingUMAP.knn_searchUMAP.optimize_embeddingUMAP.smooth_knn_distUMAP.smooth_knn_distsUMAP.spectral_layoutUMAP.umap"
},

]}
