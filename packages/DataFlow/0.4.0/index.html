<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· DataFlow.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataFlow.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Basics-1">Basics</a></li><li><a class="toctext" href="#Walking-1">Walking</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DataFlow.jl-1" href="#DataFlow.jl-1">DataFlow.jl</a></h1><p><a href="https://travis-ci.org/MikeInnes/DataFlow.jl"><img src="https://travis-ci.org/MikeInnes/DataFlow.jl.svg?branch=master" alt="Build Status"/></a></p><p>DataFlow.jl is a code intermediate representation (IR) format. It can be thought of as antithetical to SSA form; where SSA allows only statements, DataFlow allows only expressions. Closures are represented explicitly, allowing full programs to be easily represented and manipulated and complex whole-program transformations to be applied. Moreover, programs can be kept in a high-level form that&#39;s very human-readable.</p><p>A data flow graph is a bit like an expression tree without variables; functions always refer to their inputs directly. Underneath it&#39;s a directed graph linking the output of one function call to the input of another. DataFlow.jl provides functions like <code>prewalk</code> and <code>postwalk</code> which allow you to do crazy graph-restructuring operations with minimal code, <em>even on cyclic graphs</em>. Think algorithms like common subexpression elimination implemented in <a href="https://github.com/MikeInnes/DataFlow.jl/blob/d5899a47ed052190e655afdf1510e021ad95d09d/src/operations.jl#L2">one line</a> rather than hundreds.</p><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><pre><code class="language-julia">julia&gt; using DataFlow: vertex, constant, Call</code></pre><p>DataFlow.jl provides the <code>IVertex</code> data type, which behaves a lot like Julia&#39;s <code>Expr</code> type. We can construct vertices, and use them as inputs to other vertices, to build expressions. <code>constant</code> is a shortcut for vertices representing constant values.</p><pre><code class="language-julia">julia&gt; using DataFlow: vertex, constant, Call, Constant

julia&gt; a, b = constant(1), constant(2)
(IVertex(1), IVertex(2))

julia&gt; c = vertex(Call(), constant(+), a, b)
IVertex((+)(1, 2))</code></pre><p>The <code>Call()</code> object is analagous to the &quot;head&quot; in Julia&#39;s <code>Expr</code>s, so this is like <code>Expr(:call, f, x...)</code>.</p><p>A key difference from <code>Expr</code> is that the <code>IVertex</code> is a graph, not a tree, and reuse is explicitly represented. Consider multiplying the expression <code>c</code> by itself:</p><pre><code class="language-julia">julia&gt; d = vertex(Call(), constant(*), c, c)
IVertex(
bison = (+)(1, 2)
(*)(bison, bison))</code></pre><p>In order to represent the structure of the graph in text, DataFlow.jl prints an expression tree with a made-up variable binding (<code>bison</code>). This variable is <em>not</em> present in the graph itself, but just used for presentation.</p><p>Graphs can also be dumped to Julia expressions using <code>DataFlow.syntax</code>, which will similarly create variable bindings where needed.</p><pre><code class="language-julia">julia&gt; DataFlow.syntax(d)
quote
    ##edge#668 = (+)(1, 2)
    (*)(##edge#668, ##edge#668)
end

julia&gt; eval(ans)
9</code></pre><p>Graphs are also allowed to be cyclic. We can introduce cycles using <code>thread!</code>, which pushes a new argument into an existing vertex.</p><pre><code class="language-julia">julia&gt; DataFlow.thread!(c, c)
IVertex(bison = (+)(1, 2, bison))</code></pre><p>Notice that the cycle is represented by the circular dependency of <code>bison</code> on itself.</p><h2><a class="nav-anchor" id="Walking-1" href="#Walking-1">Walking</a></h2><p>Transformations are carried out via <code>prewalk</code> and <code>postwalk</code> functions very similar to those in <a href="https://github.com/MikeInnes/MacroTools.jl">MacroTools</a> (see there for more explanation).</p><pre><code class="language-julia">julia&gt; DataFlow.prewalk(d) do v
         v.value isa Call &amp;&amp; v[1].value == Constant(+) ? vertex(constant(-), v[2:end]...) : v
       end
IVertex(
bison = (IVertex(-))(1, 2)
(*)(bison, bison))</code></pre><p>There are also in-place variants of prewalk and postwalk, which can be used for more advanced transformations.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
