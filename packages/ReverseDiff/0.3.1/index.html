<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ReverseDiff.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ReverseDiff.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Why-use-ReverseDiff?-1">Why use ReverseDiff?</a></li><li><a class="toctext" href="#Should-I-use-ReverseDiff-or-ForwardDiff?-1">Should I use ReverseDiff or ForwardDiff?</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ReverseDiff-1" href="#ReverseDiff-1">ReverseDiff</a></h1><p><a href="https://travis-ci.org/JuliaDiff/ReverseDiff.jl"><img src="https://travis-ci.org/JuliaDiff/ReverseDiff.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://coveralls.io/github/JuliaDiff/ReverseDiff.jl?branch=master"><img src="https://coveralls.io/repos/github/JuliaDiff/ReverseDiff.jl/badge.svg?branch=master" alt="Coverage Status"/></a></p><p><a href="http://www.juliadiff.org/ReverseDiff.jl/"><strong>Go To ReverseDiff&#39;s Documentation</strong></a></p><p><a href="https://github.com/JuliaDiff/ReverseDiff.jl/tree/master/examples"><strong>See ReverseDiff Usage Examples</strong></a></p><p><strong>Note: While ReverseDiff technically supports Julia v0.7/v1.0 and is somewhat maintained, it is currently not actively developed. Instead, ForwardDiff/ReverseDiff&#39;s maintainers are focused on the development of a new AD package built on top of <a href="https://github.com/jrevels/Cassette.jl">Cassette</a>. In the meantime, it might be worth checking out other reverse-mode AD implementations in Nabla.jl, AutoGrad.jl, Flux.jl, or XGrad.jl.</strong></p><p>ReverseDiff implements methods to take <strong>gradients</strong>, <strong>Jacobians</strong>, <strong>Hessians</strong>, and higher-order derivatives of native Julia functions (or any callable object, really) using <strong>reverse mode automatic differentiation (AD)</strong>.</p><p>While performance can vary depending on the functions you evaluate, the algorithms implemented by ReverseDiff <strong>generally outperform non-AD algorithms in both speed and accuracy.</strong></p><p><a href="https://en.wikipedia.org/wiki/Automatic_differentiation">Wikipedia&#39;s entry on automatic differentiation</a> is a useful resource for learning about the advantages of AD techniques over other common differentiation methods (such as <a href="https://en.wikipedia.org/wiki/Numerical_differentiation">finite differencing</a>).</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>To install ReverseDiff, simply use Julia&#39;s package manager:</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;ReverseDiff&quot;)</code></pre><p>The current version of ReverseDiff supports Julia v0.5 (and intends to support Julia v0.6 once it is released).</p><h2><a class="nav-anchor" id="Why-use-ReverseDiff?-1" href="#Why-use-ReverseDiff?-1">Why use ReverseDiff?</a></h2><p>Other Julia packages may provide some of these features, but only ReverseDiff provides all of them (as far as I know at the time of this writing):</p><ul><li>supports a large subset of the Julia language, including loops, recursion, and control flow</li><li>user-friendly API for reusing and compiling tapes</li><li>user-friendly performance annotations such as <code>@forward</code> and <code>@skip</code> (with more to come!)</li><li>compatible with ForwardDiff, enabling mixed-mode AD</li><li>built-in definitions leverage the benefits of ForwardDiff&#39;s <code>Dual</code> numbers (e.g. SIMD, zero-overhead arithmetic)</li><li>a familiar differentiation API for ForwardDiff users</li><li>non-allocating linear algebra optimizations</li><li>nested differentiation</li><li>suitable as an execution backend for graphical machine learning libraries</li><li>ReverseDiff doesn&#39;t need to record scalar indexing operations (a huge cost for many similar libraries)</li><li>higher-order <code>map</code> and <code>broadcast</code> optimizations</li><li>it&#39;s well tested</li></ul><p>...and, simply put, it&#39;s fast (for gradients, at least). Using the code from <code>examples/gradient.jl</code>:</p><pre><code class="language-julia">julia&gt; using BenchmarkTools

# this script defines f and ∇f!
julia&gt; include(joinpath(Pkg.dir(&quot;ReverseDiff&quot;), &quot;examples/gradient.jl&quot;));

julia&gt; a, b = rand(100, 100), rand(100, 100);

julia&gt; inputs = (a, b);

julia&gt; results = (similar(a), similar(b));

# Benchmark the original objective function, sum(a&#39; * b + a * b&#39;)
julia&gt; @benchmark f($a, $b)
BenchmarkTools.Trial:
  memory estimate:  234.61 kb
  allocs estimate:  6
  --------------
  minimum time:     110.000 μs (0.00% GC)
  median time:      137.416 μs (0.00% GC)
  mean time:        173.085 μs (11.63% GC)
  maximum time:     3.613 ms (91.47% GC)

# Benchmark ∇f! at the same inputs (this is executing the function,
# getting the gradient w.r.t. `a`, and getting the gradient w.r.t
# to `b` simultaneously). Notice that the whole thing is
# non-allocating.
julia&gt; @benchmark ∇f!($results, $inputs)
BenchmarkTools.Trial:
  memory estimate:  0.00 bytes
  allocs estimate:  0
  --------------
  minimum time:     429.650 μs (0.00% GC)
  median time:      431.460 μs (0.00% GC)
  mean time:        469.916 μs (0.00% GC)
  maximum time:     937.512 μs (0.00% GC)</code></pre><p>I&#39;ve used this benchmark (and others) to pit ReverseDiff against every other native Julia reverse-mode AD package that I know of (including source-to-source packages), and have found ReverseDiff to be faster and use less memory in most cases.</p><h2><a class="nav-anchor" id="Should-I-use-ReverseDiff-or-ForwardDiff?-1" href="#Should-I-use-ReverseDiff-or-ForwardDiff?-1">Should I use ReverseDiff or ForwardDiff?</a></h2><p>ForwardDiff is algorithmically more efficient for differentiating functions where the input dimension is less than the output dimension, while ReverseDiff is algorithmically more efficient for differentiating functions where the output dimension is less than the input dimension.</p><p>Thus, ReverseDiff is generally a better choice for gradients, but Jacobians and Hessians are trickier to determine. For example, optimized methods for computing nested derivatives might use a combination of forward-mode and reverse-mode AD.</p><p>ForwardDiff is often faster than ReverseDiff for lower dimensional gradients (<code>length(input) &lt; 100</code>), or gradients of functions where the number of input parameters is small compared to the number of operations performed on them. ReverseDiff is often faster if your code is expressed as a series of array operations, e.g. a composition of Julia&#39;s Base linear algebra methods.</p><p>In general, your choice of algorithms will depend on the function being differentiated, and you should benchmark different methods to see how they fare.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
