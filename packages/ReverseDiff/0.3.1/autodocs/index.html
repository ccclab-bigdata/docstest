<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ReverseDiff.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ReverseDiff.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.@forward" href="#ReverseDiff.@forward"><code>ReverseDiff.@forward</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">ReverseDiff.@forward(f)(args::Real...)
ReverseDiff.@forward f(args::Real...) = ...
ReverseDiff.@forward f = (args::Real...) -&gt; ...</code></pre><p>Declare that the given function should be differentiated using forward mode automatic differentiation. Note that the macro can be used at either the definition site or at the call site of <code>f</code>. Currently, only <code>length(args) &lt;= 2</code> is supported. <strong>Note that, if <code>f</code> is defined within another function <code>g</code>, <code>f</code> should not close over any differentiable input of <code>g</code>.</strong> By using this macro, you are providing a guarantee that this property holds true.</p><p>This macro can be very beneficial for performance when intermediate functions in your computation are low dimensional scalar functions, because it minimizes the number of instructions that must be recorded to the tape. For example, take the function <code>sigmoid(n) = 1. / (1. + exp(-n))</code>. Normally, using ReverseDiff to differentiate this function would require recording 4 instructions (<code>-</code>, <code>exp</code>, <code>+</code>, and <code>/</code>). However, if we apply the <code>@forward</code> macro, only one instruction will be recorded (<code>sigmoid</code>). The <code>sigmoid</code> function will then be differentiated using ForwardDiff&#39;s <code>Dual</code> number type.</p><p>This is also beneficial for higher-order elementwise function application. ReverseDiff overloads <code>map</code>/<code>broadcast</code> to dispatch on <code>@forward</code>-applied functions. For example, <code>map(@forward(f), x)</code> will usually be more performant than <code>map(f, x)</code>.</p><p>ReverseDiff overloads many Base scalar functions to behave as <code>@forward</code> functions by default. A full list is given by <code>DiffRules.diffrules()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.@skip" href="#ReverseDiff.@skip"><code>ReverseDiff.@skip</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">ReverseDiff.@skip(f)(args::Real...)
ReverseDiff.@skip f(args::Real...) = ...
ReverseDiff.@skip f = (args::Real...) -&gt; ...</code></pre><p>Declare that the given function should be skipped during the instruction-recording phase of differentiation. Note that the macro can be used at either the definition site or at the call site of <code>f</code>. <strong>Note that, if <code>f</code> is defined within another function <code>g</code>, <code>f</code> should not close over any differentiable input of <code>g</code>.</strong> By using this macro, you are providing a guarantee that this property holds true.</p><p>ReverseDiff overloads many Base scalar functions to behave as <code>@skip</code> functions by default. A full list is given by <code>ReverseDiff.SKIPPED_UNARY_SCALAR_FUNCS</code> and <code>ReverseDiff.SKIPPED_BINARY_SCALAR_FUNCS</code>.</p></div></div></section><pre><code class="language-none">ReverseDiff.ARRAY_TYPES</code></pre><pre><code class="language-none">ReverseDiff.AbstractConfig</code></pre><pre><code class="language-none">ReverseDiff.AbstractInstruction</code></pre><pre><code class="language-none">ReverseDiff.AbstractTape</code></pre><pre><code class="language-none">ReverseDiff.CompiledGradient</code></pre><pre><code class="language-none">ReverseDiff.CompiledHessian</code></pre><pre><code class="language-none">ReverseDiff.CompiledJacobian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.CompiledTape" href="#ReverseDiff.CompiledTape"><code>ReverseDiff.CompiledTape</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">(::Type{CompiledTape}){T&lt;:AbstractTape}(t::T)</code></pre><p>Construct a compiled type by wrapping the <code>forward_exec!</code> and <code>reverse_exec!</code> methods on each instruction in the tape.</p></div></div></section><pre><code class="language-none">ReverseDiff.DiffResults</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.ForwardExecutor" href="#ReverseDiff.ForwardExecutor"><code>ReverseDiff.ForwardExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ForwardExecutor{I &lt;: AbstractInstruction}</code></pre><p>The ForwardExecutor type captures a single Instruction in order to allow fast evaluation of <code>forward_exec!(instruction)</code> via call overloading during the forward pass of differentiation. This is useful because an <code>InstructionTape</code> is stored as a vector of non-concrete AbstractInstruction elements, so calling <code>forward_exec!(instruction)</code> on each instruction would incur some run-time dispatch. Instead, we can create a ForwardExecutor and a FunctionWrapper for each instruction and store those in a concretely-typed Vector.</p></div></div></section><pre><code class="language-none">ReverseDiff.ForwardOptimize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.GradientConfig" href="#ReverseDiff.GradientConfig"><code>ReverseDiff.GradientConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.GradientConfig(input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>GradientConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.gradient</code>/<code>ReverseDiff.gradient!</code> methods.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p><p>See <code>ReverseDiff.gradient</code> for a description of acceptable types for <code>input</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.GradientConfig(input, ::Type{D}, tp::InstructionTape = InstructionTape())</code></pre><p>Like <code>GradientConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.GradientTape" href="#ReverseDiff.GradientTape"><code>ReverseDiff.GradientTape</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.GradientTape(f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>Return a <code>GradientTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>GradientTape</code> can then be passed to <code>ReverseDiff.gradient!</code> to take gradients of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.gradient</code> for a description of acceptable types for <code>input</code>.</p></div></div></section><pre><code class="language-none">ReverseDiff.HESS_MULTI_ARG_ERR_MSG</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.HessianConfig" href="#ReverseDiff.HessianConfig"><code>ReverseDiff.HessianConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.HessianConfig(input::AbstractArray, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>HessianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.hessian</code>/<code>ReverseDiff.hessian!</code> methods. <code>gtp</code> is the tape used for the inner gradient calculation, while <code>jtp</code> is used for outer Jacobian calculation.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.HessianConfig(input::AbstractArray, ::Type{D}, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Like <code>HessianConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.HessianConfig(result::DiffResults.DiffResult, input::AbstractArray, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Like <code>HessianConfig(input, tp)</code>, but utilize <code>result</code> along with <code>input</code> to construct work buffers.</p><p>Note that <code>result</code> and <code>input</code> are only used for type and shape information; they are not stored or modified in any way.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.HessianTape" href="#ReverseDiff.HessianTape"><code>ReverseDiff.HessianTape</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.HessianTape(f, input, cfg::HessianConfig = HessianConfig(input))</code></pre><p>Return a <code>HessianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>HessianTape</code> can then be passed to <code>ReverseDiff.hessian!</code> to take Hessians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.hessian</code> for a description of acceptable types for <code>input</code>.</p></div></div></section><pre><code class="language-none">ReverseDiff.InstructionTape</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.JacobianConfig" href="#ReverseDiff.JacobianConfig"><code>ReverseDiff.JacobianConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.JacobianConfig(input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>JacobianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.jacobian</code>/<code>ReverseDiff.jacobian!</code> methods.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p><pre><code class="language-none">ReverseDiff.JacobianConfig(input, ::Type{D}, tp::InstructionTape = InstructionTape())</code></pre><p>Like <code>JacobianConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.JacobianConfig(output::AbstractArray, input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>JacobianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.jacobian</code>/<code>ReverseDiff.jacobian!</code> methods. This method assumes the target function has the form <code>f!(output, input)</code></p><p>Note that <code>input</code> and <code>output</code> are only used for type and shape information; they are not stored or modified in any way.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.JacobianConfig(result::DiffResults.DiffResult, input, tp::InstructionTape = InstructionTape())</code></pre><p>A convenience method for <code>JacobianConfig(DiffResults.value(result), input, tp)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.JacobianTape" href="#ReverseDiff.JacobianTape"><code>ReverseDiff.JacobianTape</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseDiff.JacobianTape(f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>Return a <code>JacobianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>JacobianTape</code> can then be passed to <code>ReverseDiff.jacobian!</code> to take Jacobians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.JacobianTape(f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Return a <code>JacobianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>output</code> and <code>input</code>.</p><p>This <code>JacobianTape</code> can then be passed to <code>ReverseDiff.jacobian!</code> to take Jacobians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div></div></section><pre><code class="language-none">ReverseDiff.NULL_INDEX</code></pre><pre><code class="language-none">ReverseDiff.NULL_TAPE</code></pre><pre><code class="language-none">ReverseDiff.REAL_TYPES</code></pre><pre><code class="language-none">ReverseDiff.ReverseDiff</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.ReverseExecutor" href="#ReverseDiff.ReverseExecutor"><code>ReverseDiff.ReverseExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReverseExecutor{I &lt;: AbstractInstruction}</code></pre><p>The ReverseExecutor type captures a single Instruction in order to allow fast evaluation of <code>reverse_exec!(instruction)</code> via call overloading during the forward pass of differentiation. This is useful because an <code>InstructionTape</code> is stored as a vector of non-concrete AbstractInstruction elements, so calling <code>reverse_exec!(instruction)</code> on each instruction would incur some run-time dispatch. Instead, we can create a ReverseExecutor and a FunctionWrapper for each instruction and store those in a concretely-typed Vector.</p></div></div></section><pre><code class="language-none">ReverseDiff.SKIPPED_BINARY_SCALAR_FUNCS</code></pre><pre><code class="language-none">ReverseDiff.SKIPPED_UNARY_SCALAR_FUNCS</code></pre><pre><code class="language-none">ReverseDiff.ScalarInstruction</code></pre><pre><code class="language-none">ReverseDiff.SkipOptimize</code></pre><pre><code class="language-none">ReverseDiff.SpecialInstruction</code></pre><pre><code class="language-none">ReverseDiff.TrackedArray</code></pre><pre><code class="language-none">ReverseDiff.TrackedMatrix</code></pre><pre><code class="language-none">ReverseDiff.TrackedReal</code></pre><pre><code class="language-none">ReverseDiff.TrackedType</code></pre><pre><code class="language-none">ReverseDiff.TrackedVector</code></pre><pre><code class="language-none">ReverseDiff._GradientConfig</code></pre><pre><code class="language-none">ReverseDiff._GradientTape</code></pre><pre><code class="language-none">ReverseDiff._HessianTape</code></pre><pre><code class="language-none">ReverseDiff._JacobianConfig</code></pre><pre><code class="language-none">ReverseDiff._JacobianTape</code></pre><pre><code class="language-none">ReverseDiff._ScalarInstruction</code></pre><pre><code class="language-none">ReverseDiff._SpecialInstruction</code></pre><pre><code class="language-none">ReverseDiff.annotate_func_expr</code></pre><pre><code class="language-none">ReverseDiff.base_partials</code></pre><pre><code class="language-none">ReverseDiff.base_partials!</code></pre><pre><code class="language-none">ReverseDiff.base_partials_kernel</code></pre><pre><code class="language-none">ReverseDiff.binary_scalar_forward_exec!</code></pre><pre><code class="language-none">ReverseDiff.broadcast_decrement_deriv!</code></pre><pre><code class="language-none">ReverseDiff.broadcast_increment_deriv!</code></pre><pre><code class="language-none">ReverseDiff.broadcast_ldiv</code></pre><pre><code class="language-none">ReverseDiff.broadcast_minus</code></pre><pre><code class="language-none">ReverseDiff.broadcast_mul</code></pre><pre><code class="language-none">ReverseDiff.broadcast_plus</code></pre><pre><code class="language-none">ReverseDiff.broadcast_pow</code></pre><pre><code class="language-none">ReverseDiff.broadcast_rdiv</code></pre><pre><code class="language-none">ReverseDiff.capture</code></pre><pre><code class="language-none">ReverseDiff.colon2range</code></pre><pre><code class="language-none">ReverseDiff.compactrepr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.compile" href="#ReverseDiff.compile"><code>ReverseDiff.compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.compile(t::AbstractTape)</code></pre><p>Return a fully compiled representation of <code>t</code> of type <code>CompiledTape</code>. This object can be passed to any API methods that accept <code>t</code> (e.g. <code>gradient!(result, t, input)</code>).</p><p>In many cases, compiling <code>t</code> can significantly speed up execution time. Note that the longer the tape, the more time compilation may take. Very long tapes (i.e. when <code>length(t)</code> is on the order of 10000 elements) can take a very long time to compile.</p></div></div></section><pre><code class="language-none">ReverseDiff.compile_gradient</code></pre><pre><code class="language-none">ReverseDiff.compile_hessian</code></pre><pre><code class="language-none">ReverseDiff.compile_jacobian</code></pre><pre><code class="language-none">ReverseDiff.construct_result</code></pre><pre><code class="language-none">ReverseDiff.decrement_deriv!</code></pre><pre><code class="language-none">ReverseDiff.denom_partials</code></pre><pre><code class="language-none">ReverseDiff.denom_partials!</code></pre><pre><code class="language-none">ReverseDiff.denom_partials_kernel</code></pre><pre><code class="language-none">ReverseDiff.deriv</code></pre><pre><code class="language-none">ReverseDiff.deriv!</code></pre><pre><code class="language-none">ReverseDiff.derivtype</code></pre><pre><code class="language-none">ReverseDiff.diffresult_increment_deriv!</code></pre><pre><code class="language-none">ReverseDiff.eval</code></pre><pre><code class="language-none">ReverseDiff.exp_partials</code></pre><pre><code class="language-none">ReverseDiff.exp_partials!</code></pre><pre><code class="language-none">ReverseDiff.exp_partials_kernel</code></pre><pre><code class="language-none">ReverseDiff.extract_result!</code></pre><pre><code class="language-none">ReverseDiff.extract_result_value!</code></pre><pre><code class="language-none">ReverseDiff.fill_zeros!</code></pre><pre><code class="language-none">ReverseDiff.forward_exec!</code></pre><pre><code class="language-none">ReverseDiff.forward_pass!</code></pre><pre><code class="language-none">ReverseDiff.func_hook</code></pre><pre><code class="language-none">ReverseDiff.getpartial</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.gradient" href="#ReverseDiff.gradient"><code>ReverseDiff.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.gradient(f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real})::Real</code> and return <code>∇f(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real}...)::Real</code> (such that it can be called as <code>f(input...)</code>) and return a <code>Tuple</code> where the <code>i</code>th element is the gradient of <code>f</code> w.r.t. <code>input[i].</code></p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.GradientTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.gradient!" href="#ReverseDiff.gradient!"><code>ReverseDiff.gradient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.gradient!(result, f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.gradient(f, input, cfg)</code>, except it stores the resulting gradient(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.gradient!(tape::Union{GradientTape,CompiledGradient}, input)</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray)::Real</code> and return <code>∇f(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray...)::Real</code> and return a <code>Tuple</code> where the <code>i</code>th element is the gradient of <code>f</code> w.r.t. <code>input[i].</code></p></div></div><div><div><pre><code class="language-none">ReverseDiff.gradient!(result, tape::Union{GradientTape,CompiledGradient}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.gradient!(tape, input)</code>, except it stores the resulting gradient(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div></div></section><pre><code class="language-none">ReverseDiff.hasorigin</code></pre><pre><code class="language-none">ReverseDiff.hastape</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.hessian" href="#ReverseDiff.hessian"><code>ReverseDiff.hessian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.hessian(f, input::AbstractArray, cfg::HessianConfig = HessianConfig(input))</code></pre><p>Given <code>f(input::AbstractArray{&lt;:Real})::Real</code>, return <code>f</code>s Hessian w.r.t. to the given <code>input</code>.</p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.HessianTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.hessian!" href="#ReverseDiff.hessian!"><code>ReverseDiff.hessian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.hessian!(result::AbstractArray, f, input::AbstractArray, cfg::HessianConfig = HessianConfig(input))

ReverseDiff.hessian!(result::DiffResult, f, input::AbstractArray, cfg::HessianConfig = HessianConfig(result, input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.hessian(f, input, cfg)</code>, except it stores the resulting Hessian in <code>result</code> rather than allocating new memory.</p><p>If <code>result</code> is a <code>DiffResults.DiffResult</code>, the primal value <code>f(input)</code> and the gradient <code>∇f(input)</code> will be stored in it along with the Hessian <code>H(f)(input)</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.hessian!(tape::Union{HessianTape,CompiledHessian}, input)</code></pre><p>Assuming <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real})::Real</code>, return the Hessian <code>H(f)(input)</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.hessian!(result::AbstractArray, tape::Union{HessianTape,CompiledHessian}, input)

ReverseDiff.hessian!(result::DiffResult, tape::Union{HessianTape,CompiledHessian}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.hessian!(tape, input)</code>, except it stores the resulting Hessian in <code>result</code> rather than allocating new memory.</p><p>If <code>result</code> is a <code>DiffResults.DiffResult</code>, the primal value <code>f(input)</code> and the gradient <code>∇f(input)</code> will be stored in it along with the Hessian <code>H(f)(input)</code>.</p></div></div></section><pre><code class="language-none">ReverseDiff.idstr</code></pre><pre><code class="language-none">ReverseDiff.include</code></pre><pre><code class="language-none">ReverseDiff.increment_deriv!</code></pre><pre><code class="language-none">ReverseDiff.index_bound</code></pre><pre><code class="language-none">ReverseDiff.index_iterable</code></pre><pre><code class="language-none">ReverseDiff.input_hook</code></pre><pre><code class="language-none">ReverseDiff.istracked</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.jacobian" href="#ReverseDiff.jacobian"><code>ReverseDiff.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.jacobian(f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real})::AbstractArray{&lt;:Real}</code> and return <code>J(f)(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code> (such that it can be called as <code>f(input...)</code>) and return a <code>Tuple</code> where the <code>i</code>th element is the  Jacobian of <code>f</code> w.r.t. <code>input[i].</code></p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.JacobianTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.jacobian(f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Exactly like <code>ReverseDiff.jacobian(f, input, cfg)</code>, except the target function has the form <code>f!(output::AbstractArray{&lt;:Real}, input::AbstractArray{&lt;:Real}...)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReverseDiff.jacobian!" href="#ReverseDiff.jacobian!"><code>ReverseDiff.jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ReverseDiff.jacobian!(result, f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.jacobian(f, input, cfg)</code>, except it stores the resulting Jacobian(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.jacobian!(result, f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Exactly like <code>ReverseDiff.jacobian!(result, f, input, cfg)</code>, except the target function has the form <code>f!(output::AbstractArray{&lt;:Real}, input::AbstractArray{&lt;:Real}...)</code>.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.jacobian!(tape::Union{JacobianTape,CompiledJacobian}, input)</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real})::AbstractArray{&lt;:Real}</code> or <code>f!(::AbstractArray{&lt;:Real}, ::AbstractArray{&lt;:Real})</code> and return <code>tape</code>&#39;s Jacobian w.r.t. <code>input</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code> or <code>f!(::AbstractArray{&lt;:Real}, ::AbstractArray{&lt;:Real}...)</code> and return a <code>Tuple</code> where the <code>i</code>th element is <code>tape</code>&#39;s Jacobian w.r.t. <code>input[i].</code></p><p>Note that if <code>tape</code> represents a function of the form <code>f!(output, input...)</code>, you can only execute <code>tape</code> with new <code>input</code> values. There is no way to re-run <code>tape</code>&#39;s tape with new <code>output</code> values; since <code>f!</code> can mutate <code>output</code>, there exists no stable &quot;hook&quot; for loading new <code>output</code> values into the tape.</p></div></div><div><div><pre><code class="language-none">ReverseDiff.jacobian!(result, tape::Union{JacobianTape,CompiledJacobian}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.jacobian!(tape, input)</code>, except it stores the resulting Jacobian(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value of the target function will be stored in it as well.</p></div></div></section><pre><code class="language-none">ReverseDiff.minus!</code></pre><pre><code class="language-none">ReverseDiff.mulargpullvalue!</code></pre><pre><code class="language-none">ReverseDiff.mulargvalue</code></pre><pre><code class="language-none">ReverseDiff.numer_partials</code></pre><pre><code class="language-none">ReverseDiff.numer_partials!</code></pre><pre><code class="language-none">ReverseDiff.origintype</code></pre><pre><code class="language-none">ReverseDiff.output_hook</code></pre><pre><code class="language-none">ReverseDiff.plus!</code></pre><pre><code class="language-none">ReverseDiff.pow_cache</code></pre><pre><code class="language-none">ReverseDiff.pull_deriv!</code></pre><pre><code class="language-none">ReverseDiff.pull_value!</code></pre><pre><code class="language-none">ReverseDiff.push_deriv!</code></pre><pre><code class="language-none">ReverseDiff.rdiv_cache</code></pre><pre><code class="language-none">ReverseDiff.record!</code></pre><pre><code class="language-none">ReverseDiff.record_dot</code></pre><pre><code class="language-none">ReverseDiff.record_minus</code></pre><pre><code class="language-none">ReverseDiff.record_minus!</code></pre><pre><code class="language-none">ReverseDiff.record_mul</code></pre><pre><code class="language-none">ReverseDiff.record_mul!</code></pre><pre><code class="language-none">ReverseDiff.record_plus</code></pre><pre><code class="language-none">ReverseDiff.record_plus!</code></pre><pre><code class="language-none">ReverseDiff.record_sum!</code></pre><pre><code class="language-none">ReverseDiff.reduction_increment_deriv!</code></pre><pre><code class="language-none">ReverseDiff.reshape_body</code></pre><pre><code class="language-none">ReverseDiff.reverse_exec!</code></pre><pre><code class="language-none">ReverseDiff.reverse_mul!</code></pre><pre><code class="language-none">ReverseDiff.reverse_pass!</code></pre><pre><code class="language-none">ReverseDiff.scalar_forward_exec!</code></pre><pre><code class="language-none">ReverseDiff.scalar_reverse_exec!</code></pre><pre><code class="language-none">ReverseDiff.seed!</code></pre><pre><code class="language-none">ReverseDiff.seeded_forward_pass!</code></pre><pre><code class="language-none">ReverseDiff.seeded_reverse_pass!</code></pre><pre><code class="language-none">ReverseDiff.special_forward_exec!</code></pre><pre><code class="language-none">ReverseDiff.special_reverse_exec!</code></pre><pre><code class="language-none">ReverseDiff.tape</code></pre><pre><code class="language-none">ReverseDiff.track</code></pre><pre><code class="language-none">ReverseDiff.track!</code></pre><pre><code class="language-none">ReverseDiff.unary_scalar_forward_exec!</code></pre><pre><code class="language-none">ReverseDiff.unseed!</code></pre><pre><code class="language-none">ReverseDiff.valtype</code></pre><pre><code class="language-none">ReverseDiff.value</code></pre><pre><code class="language-none">ReverseDiff.value!</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
