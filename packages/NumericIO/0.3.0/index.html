<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · NumericIO.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NumericIO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Description-1">Description</a></li><li><a class="toctext" href="#Basic-Usage-1">Basic Usage</a></li><li><a class="toctext" href="#Advanced-Usage-1">Advanced Usage</a></li><li><a class="toctext" href="#Sample-Applications-1">Sample Applications</a></li><li><a class="toctext" href="#Known-Limitations-1">Known Limitations</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NumericIO.jl-1" href="#NumericIO.jl-1">NumericIO.jl</a></h1><p><a href="https://travis-ci.org/ma-laforge/NumericIO.jl"><img src="https://travis-ci.org/ma-laforge/NumericIO.jl.svg?branch=master" alt="Build Status"/></a></p><h2><a class="nav-anchor" id="Description-1" href="#Description-1">Description</a></h2><p>Improved support for formatting numeric data.</p><ul><li>Includes facilities to display values using SI prefixes (<code>Y</code>, <code>Z</code>, <code>E</code>, <code>P</code>, <code>T</code>, <code>G</code>, <code>M</code>, <code>k</code>, <code>m</code>, &amp;mu;, <code>n</code>, <code>p</code>, <code>f</code>, <code>a</code>, <code>z</code>, <code>y</code>)</li><li>Makes it easy to control the number of significant digits to display.</li></ul><h2><a class="nav-anchor" id="Basic-Usage-1" href="#Basic-Usage-1">Basic Usage</a></h2><p>NumericIO.jl tries to provide the convenience of c++ <code>ios_base</code> configurability (ex: setting <code>ios_base::precision</code>) <em>without</em> modifying the output format of the base streaming object. Instead, NumericIO.jl uses the <code>FormattedIO</code> wrapper object to print data with the desired output format.  This appears to be somewhat similar (but not as flexible) as the <code>Base.IOContext</code> object used in core Julia.</p><p>To obtain a string representation of a <code>Real</code> value using SI prefixes, one can use the <code>formatted</code> function:</p><pre><code class="language-none">formatted(3.14159e-8, :SI, ndigits=3) # =&gt; &quot;31.14n&quot;</code></pre><p>Similarly, one can generate a string using scientific notation with the following:</p><pre><code class="language-none">formatted(3.14159e-8, :SCI, ndigits=3) # =&gt; &quot;3.14×10⁻⁸&quot;</code></pre><p>Or using engineering notation (limiting to powers divisible by 3) with:</p><pre><code class="language-none">formatted(3.14159e-8, :ENG, ndigits=3) # =&gt; &quot;31.4×10⁻⁹&quot;</code></pre><p>To limit results to <code>ASCII</code> output, specify the <code>charset</code> keyword:</p><pre><code class="language-none">formatted(3.14159e-8, :ENG, ndigits=3, charset=:ASCII) # =&gt; &quot;31.4E-9&quot;</code></pre><p>One might also prefer to create a convenience formatting function:</p><pre><code class="language-none">SI(x) = formatted(x, :SI, ndigits=4)
SI(3.14159e-9) # =&gt; &quot;3.142n&quot;
SI(2.71828e12) # =&gt; &quot;2.718T&quot;</code></pre><p>To print out multiple values, it is preferable (more efficient) to directly create a FormattedIO wrapper object:</p><pre><code class="language-none">fio = formatted(STDOUT, :SI, ndigits=4) # =&gt; FormattedIO
println(fio, 3.14159e-9) # =&gt; 3.142n
println(fio, 2.71828e12) # =&gt; 2.718T
...</code></pre><h2><a class="nav-anchor" id="Advanced-Usage-1" href="#Advanced-Usage-1">Advanced Usage</a></h2><p>Lower-level structures of NumericIO can be used to fine-tune numeric output even further, if desired.  The following shows an example that approximates engineering notation using the <code>ASCII</code> characterset only:</p><pre><code class="language-none">asciiexponentfmt = NumericIO.IOFormattingExpNum(
	&quot;x10^&quot;, false, &#39;+&#39;, &#39;-&#39;, NumericIO.ASCII_SUPERSCRIPT_NUMERALS
)
fmt = NumericIO.IOFormattingReal(asciiexponentfmt,
	ndigits=4, decpos=0, decfloating=true, eng=true, minus=&#39;-&#39;, inf=&quot;Inf&quot;
)
fio = formatted(STDOUT, fmt) # =&gt; FormattedIO
println(fio, 3.14159e-8) # =&gt; 31.42x10^-9</code></pre><p>It is also possible to generate the mantissa &amp; exponent portions of a number separately.  This could be useful when displaying a plot&#39;s tick labels when using a common axis multiplier.  See implementation of <code>NumericIO.print_formatted(..., showexp=false)</code> and <code>NumericIO.print_formatted_exp(...)</code> for details.</p><p>&lt;a name=&quot;Sample_Applications&quot;&gt;&lt;/a&gt;</p><h2><a class="nav-anchor" id="Sample-Applications-1" href="#Sample-Applications-1">Sample Applications</a></h2><h3><a class="nav-anchor" id="Improved-REPL-output-(Julia-console)-1" href="#Improved-REPL-output-(Julia-console)-1">Improved REPL output (Julia console)</a></h3><p>Users can make REPL outputs easier to read, simply by adding a few lines to their <code>~/.juliarc.jl</code> file:</p><pre><code class="language-none">using NumericIO
Base.display(r::Base.REPL.REPLDisplay, v::Union{Float32,Float64}) = print(formatted(Base.REPL.outstream(r.repl), :SI, ndigits=4), v)</code></pre><p>This solution should be fairly safe: few programmers writing to REPL displays would later read back values from said display (failing the subsequent read operation).  The most likely issue with this application is that programmers expecting carefully formatted output would now have suboptimal-looking output.</p><h4><a class="nav-anchor" id="RE:-Array-outputs.-1" href="#RE:-Array-outputs.-1">RE: Array outputs.</a></h4><p>Note that defining the above <code>display</code> method does not alter how <code>Array{Float}</code> arrays are displayed.  In order to change this particular output, one would have to define something like:</p><pre><code class="language-none">Base.show{T&lt;:Base.AbstractIOBuffer}(ctx::IOContext{T}, v::Union{Float32,Float64}) = print(formatted(ctx.io, :SI, ndigits=4), v)</code></pre><p>... because currently (Julia v0.5.0) arrays generate their outputs by writing to temporary <code>IOBuffer</code>s.</p><p><strong>This solution is not recommended</strong>: it involves altering the behaviour of relatively low-level functions.  It is likely to cause issues.</p><h4><a class="nav-anchor" id="RE:-Coordinating-with-SIUnits.-1" href="#RE:-Coordinating-with-SIUnits.-1">RE: Coordinating with SIUnits.</a></h4><p>Again, the <code>display</code> function described above does not work in conjuction with SIUnits.jl - because the displayed object is of type <code>SIQuantity</code> (not <code>Float32/64</code>).  One could, instead define the following function:</p><pre><code class="language-none">Base.show(io::IOContext{Base.Terminals.TTYTerminal}, v::Union{Float32,Float64}) = print(formatted(io, :SI, ndigits=4), v)</code></pre><p>Which would work for formatting outputs of <code>SIQuantity</code> values, in addition to many (but not all) other values written to terminal.</p><p>Note however, that <code>show()</code> is a lower level function, and this definition is more likely to cause undesired behaviours.</p><h2><a class="nav-anchor" id="Known-Limitations-1" href="#Known-Limitations-1">Known Limitations</a></h2><ul><li>Support for SI notation is limited between <code>y (1e-24)</code> and <code>Y (1e24)</code>.  Values beyond this range default to scientific notation.</li><li>SI notation displays <code>{1e9, 10e9, 100e9}</code> as <code>{1G, 10G, 100G}</code>.  It would be possible to reconfigure NumericIO to arbitrarily display <code>{1G, 10G, 0.1T}</code>, or <code>{1G, 0.01T, 0.1G}</code>, or ...</li><li>Algorithms are likely be a bit more complicated than absolutely necessary.  It would be nice to simplify/optimize the code as much as possible.</li><li>Does not support arbitrary bases (ex: <code>1x2^8</code>).</li></ul><h3><a class="nav-anchor" id="Compatibility-1" href="#Compatibility-1">Compatibility</a></h3><p>Extensive compatibility testing of NumericIO.jl has not been performed.  The module has been tested using the following environment(s):</p><ul><li>Windows / Linux / Julia-0.7.0</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
