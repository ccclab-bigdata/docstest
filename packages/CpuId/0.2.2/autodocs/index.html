<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CpuId.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CpuId.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">CpuId.ACPI</code></pre><pre><code class="language-none">CpuId.ADX</code></pre><pre><code class="language-none">CpuId.AES</code></pre><pre><code class="language-none">CpuId.AHF64</code></pre><pre><code class="language-none">CpuId.AMD3DNOW</code></pre><pre><code class="language-none">CpuId.AMD3DNOWEXT</code></pre><pre><code class="language-none">CpuId.APIC</code></pre><pre><code class="language-none">CpuId.APIC_</code></pre><pre><code class="language-none">CpuId.AVX</code></pre><pre><code class="language-none">CpuId.AVX2</code></pre><pre><code class="language-none">CpuId.AVX512BW</code></pre><pre><code class="language-none">CpuId.AVX512CD</code></pre><pre><code class="language-none">CpuId.AVX512DQ</code></pre><pre><code class="language-none">CpuId.AVX512ER</code></pre><pre><code class="language-none">CpuId.AVX512F</code></pre><pre><code class="language-none">CpuId.AVX512FMAPS</code></pre><pre><code class="language-none">CpuId.AVX512IFMA</code></pre><pre><code class="language-none">CpuId.AVX512PF</code></pre><pre><code class="language-none">CpuId.AVX512VBMI</code></pre><pre><code class="language-none">CpuId.AVX512VL</code></pre><pre><code class="language-none">CpuId.AVX512VNNIW</code></pre><pre><code class="language-none">CpuId.BMI1</code></pre><pre><code class="language-none">CpuId.BMI2</code></pre><pre><code class="language-none">CpuId.CLFLUSH</code></pre><pre><code class="language-none">CpuId.CLFSH</code></pre><pre><code class="language-none">CpuId.CLWB</code></pre><pre><code class="language-none">CpuId.CMOV</code></pre><pre><code class="language-none">CpuId.CMOV_</code></pre><pre><code class="language-none">CpuId.CMPLEG</code></pre><pre><code class="language-none">CpuId.CNXT</code></pre><pre><code class="language-none">CpuId.CPB</code></pre><pre><code class="language-none">CpuId.CR8D</code></pre><pre><code class="language-none">CpuId.CX16</code></pre><pre><code class="language-none">CpuId.CX8</code></pre><pre><code class="language-none">CpuId.CX8_</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.CpuFeature" href="#CpuId.CpuFeature"><code>CpuId.CpuFeature</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tuple of cpuid leaf in eax, result register and bit, and a descriptive string.</p><p>This table is an edited combination of sources from <a href="https://en.wikipedia.org/wiki/CPUID">Wikipedia page on <code>cpuid</code></a>, <a href="www.sandpile.org/x86/cpuid.htm">sandpile.org</a>, and of course Intel&#39;s 4670 page combined <a href=" http:/www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html">Architectures Software Devleoper Manual</a>.</p><p>Expect this table to be incomplete and improvable.</p></div></div></section><pre><code class="language-none">CpuId.CpuFeatureDescription</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.CpuId" href="#CpuId.CpuId"><code>CpuId.CpuId</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>Module CpuId</strong></p><p>Query information about and directly from your CPU.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.CpuInstructions" href="#CpuId.CpuInstructions"><code>CpuId.CpuInstructions</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>Module &#39;CpuInstructions&#39;</strong></p><p>The module &#39;CpuInstructions&#39; is part of the package &#39;CpuId&#39;, and provides a selection of wrapped low-level assembly functions to diagnose potential computational efficiency issues.</p><p>Though primarily intended as a helper module to &#39;CpuId&#39;, the functions may be used directly in other code e.g. for benchmarking purposes.  Just include the file directly, or copy &amp; paste.</p></div></div></section><pre><code class="language-none">CpuId.DBX</code></pre><pre><code class="language-none">CpuId.DCA</code></pre><pre><code class="language-none">CpuId.DE</code></pre><pre><code class="language-none">CpuId.DE_</code></pre><pre><code class="language-none">CpuId.DS</code></pre><pre><code class="language-none">CpuId.DSCPL</code></pre><pre><code class="language-none">CpuId.DTES64</code></pre><pre><code class="language-none">CpuId.EFRO</code></pre><pre><code class="language-none">CpuId.ERMS</code></pre><pre><code class="language-none">CpuId.EST</code></pre><pre><code class="language-none">CpuId.EXTAPIC</code></pre><pre><code class="language-none">CpuId.F16C</code></pre><pre><code class="language-none">CpuId.FFXSR</code></pre><pre><code class="language-none">CpuId.FID</code></pre><pre><code class="language-none">CpuId.FMA3</code></pre><pre><code class="language-none">CpuId.FMA4</code></pre><pre><code class="language-none">CpuId.FP128</code></pre><pre><code class="language-none">CpuId.FP256</code></pre><pre><code class="language-none">CpuId.FPDPR</code></pre><pre><code class="language-none">CpuId.FPU</code></pre><pre><code class="language-none">CpuId.FPU_</code></pre><pre><code class="language-none">CpuId.FSGS</code></pre><pre><code class="language-none">CpuId.FXSR</code></pre><pre><code class="language-none">CpuId.FXSR_</code></pre><pre><code class="language-none">CpuId.HLE</code></pre><pre><code class="language-none">CpuId.HTT</code></pre><pre><code class="language-none">CpuId.HWPS</code></pre><pre><code class="language-none">CpuId.HYPVS</code></pre><pre><code class="language-none">CpuId.IA64</code></pre><pre><code class="language-none">CpuId.IBS</code></pre><pre><code class="language-none">CpuId.INVPCID</code></pre><pre><code class="language-none">CpuId.IPT</code></pre><pre><code class="language-none">CpuId.LM</code></pre><pre><code class="language-none">CpuId.LWP</code></pre><pre><code class="language-none">CpuId.LZCNT</code></pre><pre><code class="language-none">CpuId.MCA</code></pre><pre><code class="language-none">CpuId.MCA_</code></pre><pre><code class="language-none">CpuId.MCE</code></pre><pre><code class="language-none">CpuId.MCE_</code></pre><pre><code class="language-none">CpuId.MMX</code></pre><pre><code class="language-none">CpuId.MMXEXT_</code></pre><pre><code class="language-none">CpuId.MMX_</code></pre><pre><code class="language-none">CpuId.MON</code></pre><pre><code class="language-none">CpuId.MONX</code></pre><pre><code class="language-none">CpuId.MOVBE</code></pre><pre><code class="language-none">CpuId.MOVU</code></pre><pre><code class="language-none">CpuId.MP</code></pre><pre><code class="language-none">CpuId.MPX</code></pre><pre><code class="language-none">CpuId.MSR</code></pre><pre><code class="language-none">CpuId.MSR_</code></pre><pre><code class="language-none">CpuId.MTRR</code></pre><pre><code class="language-none">CpuId.MTRR_</code></pre><pre><code class="language-none">CpuId.MUL100</code></pre><pre><code class="language-none">CpuId.MarkdownString</code></pre><pre><code class="language-none">CpuId.MarkdownTable</code></pre><pre><code class="language-none">CpuId.NODEID</code></pre><pre><code class="language-none">CpuId.NX</code></pre><pre><code class="language-none">CpuId.OSPKE</code></pre><pre><code class="language-none">CpuId.OSVW</code></pre><pre><code class="language-none">CpuId.OSXSV</code></pre><pre><code class="language-none">CpuId.PA</code></pre><pre><code class="language-none">CpuId.PAE</code></pre><pre><code class="language-none">CpuId.PAE_</code></pre><pre><code class="language-none">CpuId.PAT</code></pre><pre><code class="language-none">CpuId.PAT_</code></pre><pre><code class="language-none">CpuId.PBE</code></pre><pre><code class="language-none">CpuId.PCID</code></pre><pre><code class="language-none">CpuId.PCLMUL</code></pre><pre><code class="language-none">CpuId.PCOMMIT</code></pre><pre><code class="language-none">CpuId.PCXCORE</code></pre><pre><code class="language-none">CpuId.PCXL2I</code></pre><pre><code class="language-none">CpuId.PCXNB</code></pre><pre><code class="language-none">CpuId.PDCM</code></pre><pre><code class="language-none">CpuId.PERFTSC</code></pre><pre><code class="language-none">CpuId.PFI</code></pre><pre><code class="language-none">CpuId.PG1G</code></pre><pre><code class="language-none">CpuId.PGE</code></pre><pre><code class="language-none">CpuId.PGE_</code></pre><pre><code class="language-none">CpuId.PKU</code></pre><pre><code class="language-none">CpuId.POPCNT</code></pre><pre><code class="language-none">CpuId.PQE</code></pre><pre><code class="language-none">CpuId.PQM</code></pre><pre><code class="language-none">CpuId.PREFETCHW</code></pre><pre><code class="language-none">CpuId.PREFTCHWT1</code></pre><pre><code class="language-none">CpuId.PSE</code></pre><pre><code class="language-none">CpuId.PSE36</code></pre><pre><code class="language-none">CpuId.PSE36_</code></pre><pre><code class="language-none">CpuId.PSE_</code></pre><pre><code class="language-none">CpuId.PSN</code></pre><pre><code class="language-none">CpuId.RDPID</code></pre><pre><code class="language-none">CpuId.RDRND</code></pre><pre><code class="language-none">CpuId.RDSEED</code></pre><pre><code class="language-none">CpuId.RDTSCP</code></pre><pre><code class="language-none">CpuId.RTM</code></pre><pre><code class="language-none">CpuId.SDBG</code></pre><pre><code class="language-none">CpuId.SEP</code></pre><pre><code class="language-none">CpuId.SGX</code></pre><pre><code class="language-none">CpuId.SGXLC</code></pre><pre><code class="language-none">CpuId.SHA</code></pre><pre><code class="language-none">CpuId.SKINIT</code></pre><pre><code class="language-none">CpuId.SMAP</code></pre><pre><code class="language-none">CpuId.SMEP</code></pre><pre><code class="language-none">CpuId.SMX</code></pre><pre><code class="language-none">CpuId.SS</code></pre><pre><code class="language-none">CpuId.SSE</code></pre><pre><code class="language-none">CpuId.SSE2</code></pre><pre><code class="language-none">CpuId.SSE3</code></pre><pre><code class="language-none">CpuId.SSE41</code></pre><pre><code class="language-none">CpuId.SSE42</code></pre><pre><code class="language-none">CpuId.SSE4A</code></pre><pre><code class="language-none">CpuId.SSEMISALIGN</code></pre><pre><code class="language-none">CpuId.SSSE3</code></pre><pre><code class="language-none">CpuId.STC</code></pre><pre><code class="language-none">CpuId.SVM</code></pre><pre><code class="language-none">CpuId.SYSCALL</code></pre><pre><code class="language-none">CpuId.TBM</code></pre><pre><code class="language-none">CpuId.TCE</code></pre><pre><code class="language-none">CpuId.TM</code></pre><pre><code class="language-none">CpuId.TM2</code></pre><pre><code class="language-none">CpuId.TM_</code></pre><pre><code class="language-none">CpuId.TOPX</code></pre><pre><code class="language-none">CpuId.TS</code></pre><pre><code class="language-none">CpuId.TSC</code></pre><pre><code class="language-none">CpuId.TSCADJ</code></pre><pre><code class="language-none">CpuId.TSCDL</code></pre><pre><code class="language-none">CpuId.TSCINV</code></pre><pre><code class="language-none">CpuId.TSC_</code></pre><pre><code class="language-none">CpuId.TTP</code></pre><pre><code class="language-none">CpuId.UMIP</code></pre><pre><code class="language-none">CpuId.VID</code></pre><pre><code class="language-none">CpuId.VME</code></pre><pre><code class="language-none">CpuId.VME_</code></pre><pre><code class="language-none">CpuId.VMX</code></pre><pre><code class="language-none">CpuId.WDT</code></pre><pre><code class="language-none">CpuId.X2APIC</code></pre><pre><code class="language-none">CpuId.XOP</code></pre><pre><code class="language-none">CpuId.XSAVE</code></pre><pre><code class="language-none">CpuId.XTPR</code></pre><pre><code class="language-none">CpuId.__EAX</code></pre><pre><code class="language-none">CpuId.__EBX</code></pre><pre><code class="language-none">CpuId.__ECX</code></pre><pre><code class="language-none">CpuId.__EDX</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.__datacachesize" href="#CpuId.__datacachesize"><code>CpuId.__datacachesize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Helper function that performs the actual computation of the cache size with register values retrieved from <code>cpuid</code> on leaf 0x04.</p><blockquote><p>Cache size information on leaf 0x04 is computed with     size in bytes = (ways+1) * (partitions+1) * (linesize+1) * (sets+1) where     ways = ebx[22:31], partitions = ebx[12:21], linesize = ebx[0:11]     sets = ecx[:]</p></blockquote></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId._cpuid_vendor_id" href="#CpuId._cpuid_vendor_id"><code>CpuId._cpuid_vendor_id</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Map vendor string of type &#39;char[12]&#39; provided by <code>cpuid, eax=0x0</code> to a Julia symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId._throw_unsupported_leaf" href="#CpuId._throw_unsupported_leaf"><code>CpuId._throw_unsupported_leaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Helper function, tagged noinline to not have detrimental effect on performance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.address_size" href="#CpuId.address_size"><code>CpuId.address_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">address_size()</code></pre><p>Determine the maximum virtual address size supported by this CPU as reported by the <code>cpuid</code> instructions.</p><p>This information may be used to determine the number of high bits that can be used in a pointer for tagging;  viz. <code>sizeof(Int) - address_size() ÷ 8</code>, which gives on most 64 bit Intel machines 2 bytes = 16 bit for other purposes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cachelinesize" href="#CpuId.cachelinesize"><code>CpuId.cachelinesize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cachelinesize()</code></pre><p>Query the CPU about the L1 data cache line size in bytes.  This is typically 64 byte.  Returns zero if cache line size information is not available from the CPU.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cachesize" href="#CpuId.cachesize"><code>CpuId.cachesize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cachesize()
cachesize(lvl::Integer)</code></pre><p>Obtain information on the CPU&#39;s <em>data</em> cache sizes.</p><p>Determine the data cache size for each cache level as reported by the CPU using a set of calls to the <code>cpuid</code> instruction.  Returns a tuple with the tuple indices matching the cache levels; sizes are given in bytes.</p><p>If given an integer, then the data cache size of the respective cache level will be returned.  This is significantly faster than the tuple version above.</p><p>Note that these are total cache sizes, where some cache levels are typically shared by multiple cpu cores, the higher cache levels may include lower levels. To print the cache levels in kbyte, use e.g. <code>CpuId.cachesize() .÷ 1024</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpu_base_frequency" href="#CpuId.cpu_base_frequency"><code>CpuId.cpu_base_frequency</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpu_base_frequency()</code></pre><p>Determine the CPU nominal base frequency in MHz as reported directly from the CPU through a <code>cpuid</code> instruction call.  Returns zero if the CPU doesn&#39;t provide base frequency information.</p><p>The actual cpu frequency might be lower due to throttling, or higher due to frequency boosting (see <code>cpu_max_frequency</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpu_bus_frequency" href="#CpuId.cpu_bus_frequency"><code>CpuId.cpu_bus_frequency</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpu_bus_frequency()</code></pre><p>Determine the bus CPU frequency in MHz as reported directly from the CPU through a <code>cpuid</code> instrauction call.  Returns zero if the CPU doesn&#39;t provide bus frequency information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpu_max_frequency" href="#CpuId.cpu_max_frequency"><code>CpuId.cpu_max_frequency</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpu_max_frequency()</code></pre><p>Determine the maximum CPU frequency in MHz as reported directly from the CPU through a <code>cpuid</code> instrauction call.  The maximum frequency typically refers to the CPU&#39;s boost frequency.  Returns zero if the CPU doesn&#39;t provide maximum frequency information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpuarchitecture" href="#CpuId.cpuarchitecture"><code>CpuId.cpuarchitecture</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpuarchitecture()</code></pre><p>This function tries to infer the CPU microarchitecture with a call to the <code>cpuid</code> instruction.  For now, only Intel CPUs are suppored according to the following table.  Others are identified as <code>:Unknown</code>.</p><p>Table C-1 of Intel&#39;s Optimization Reference Manual:</p><table><tr><th>Family_Model</th><th>Microarchitecture</th></tr><tr><td>06<em>4EH, 06</em>5EH</td><td>Skylake</td></tr><tr><td>06<em>3DH, 06</em>47H, 06_56H</td><td>Broadwell</td></tr><tr><td>06<em>3CH, 06</em>45H, 06<em>46H, 06</em>3FH</td><td>Haswell</td></tr><tr><td>06<em>3AH, 06</em>3EH</td><td>Ivy Bridge</td></tr><tr><td>06<em>2AH, 06</em>2DH</td><td>Sandy Bridge</td></tr><tr><td>06<em>25H, 06</em>2CH, 06_2FH</td><td>Westmere</td></tr><tr><td>06<em>1AH, 06</em>1EH, 06<em>1FH, 06</em>2EH</td><td>Nehalem</td></tr><tr><td>06<em>17H, 06</em>1DH</td><td>Enhanced Intel Core</td></tr><tr><td>06_0FH</td><td>Intel Core</td></tr></table></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpubrand" href="#CpuId.cpubrand"><code>CpuId.cpubrand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpubrand()</code></pre><p>Determine the cpu brand as a string as provided by the CPU through executing the <code>cpuid</code> instruction.  This function throws if no CPU brand information is available form the CPU, which should never be the case on recent hardware.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpucores" href="#CpuId.cpucores"><code>CpuId.cpucores</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpucores()</code></pre><p>Determine the number of physical cores on the current executing CPU by invoking a <code>cpuid</code> instruction.  On systems with multiple CPUs, this only gives information on the single CPU that is executing the code. Returns zero if querying this feature is not supported, which may also be due to a running hypervisor (as observed on hvvendor() == :Microsoft).</p><p>Also, this function does not take logical cores (aka hyperthreading) into account, but determines the true number of physical cores, which typically also share L3 caches and main memory bandwidth.</p><p>See also the Julia global variable <code>Base.Sys.CPU_CORES</code>, which gives the total count of all cores on the machine.</p></div></div></section><pre><code class="language-none">CpuId.cpucores_total</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpucycle" href="#CpuId.cpucycle"><code>CpuId.cpucycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpucycle()</code></pre><p>Read the CPU&#39;s <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter, TSC</a>, directly with a <code>rdtsc</code> instruction.  This counter is increased for every CPU cycle, until reset.  This function has, when inlined, practically no overhead and is, thus, probably the fasted method to count how many cycles the CPU has spent working since last read.</p><p>Note, the TSC runs at a constant rate if <code>hasfeature(:TSCINV)==true</code>; otherwise, it is tied to the current CPU clock frequency.</p><p>Hint: This function is extremely efficient when inlined into your own code.       Convince yourself by typing <code>@code_native CpuId.cpucycle()</code>.       To use this for benchmarking, simply subtract the results of two calls.       The result is the actual CPU clock cycles spent, independent of the       current (and possible non-constant) CPU clock frequency.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpucycle_id" href="#CpuId.cpucycle_id"><code>CpuId.cpucycle_id</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpucycle_id()</code></pre><p>Read the CPU&#39;s <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter, TSC</a>, and executing CPU id directly with a <code>rdtscp</code> instruction.  This function is similar to the <code>cpucycle()</code>, but uses an instruction that also allows to detect if the code has been moved to a different executing CPU.  See also the comments for <code>cpucycle()</code> which equally apply.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpufeature" href="#CpuId.cpufeature"><code>CpuId.cpufeature</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpufeature( feature::Symbol ) ::Bool
cpufeature( feature::CpuFeature ) ::Bool</code></pre><p>Query the CPU whether it supports the given feature.  For fast checking provide directly the <code>CpuFeature</code> defined as a global const in <code>CpuId</code>. Explicitly typed <code>CpuFeature</code>s got by the same name as the corresponding symbols.  Valid symbols are available from <code>keys(CpuId.CpuFeatureDescription)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpufeaturedesc" href="#CpuId.cpufeaturedesc"><code>CpuId.cpufeaturedesc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpufeaturedesc( feature::Symbol ) ::String</code></pre><p>Get the textual description of a CPU feature flag given as a <em>symbol</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpufeatures" href="#CpuId.cpufeatures"><code>CpuId.cpufeatures</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpufeatures() ::Vector{Symbol}</code></pre><p>Get a list of symbols of all cpu supported features.  Might be extensive and not exactly useful other than for testing purposes.  Also, this implementation is not efficient since each feature is queried independently.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpufeaturetable" href="#CpuId.cpufeaturetable"><code>CpuId.cpufeaturetable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpufeaturetable() ::MarkdownString</code></pre><p>Generate a markdown table of all the detected/available/supported CPU features along with some textural description.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpuinfo" href="#CpuId.cpuinfo"><code>CpuId.cpuinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpuinfo()</code></pre><p>Generate a markdown table with the results of all of the CPU querying functions provided by the module <code>CpuId</code>.  Intended to give a quick overview for diagnostic purposes e.g. in log files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpumodel" href="#CpuId.cpumodel"><code>CpuId.cpumodel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpumodel()</code></pre><p>Obtain the CPU model information as a Dict of pairs of <code>:Family</code>, <code>:Model</code>, <code>:Stepping</code>, and <code>:CpuType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpunodes" href="#CpuId.cpunodes"><code>CpuId.cpunodes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpunodes() -&gt; Int</code></pre><p>Determine the number of core complexes, aka nodes, on this processor. This notion is introduced by AMD, where L3 caches are shared among the cores of a comples</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cputhreads" href="#CpuId.cputhreads"><code>CpuId.cputhreads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cputhreads()</code></pre><p>Determine the number of logical cores on the current executing CPU by invoking a <code>cpuid</code> instruction.  On systems with multiple CPUs, this only gives information on the single CPU that is executing the code. Returns zero if querying this feature is not supported, which may also be due to a running hypervisor (as observed on hvvendor() == :Microsoft).</p><p>In contrast to <code>cpucores()</code>, this function also takes logical cores aka hyperthreading into account.  For practical purposes, only I/O intensive code should make use of these total number of cores; memory or computation bound code will not benefit, but rather experience a detrimental effect.</p><p>See also Julia&#39;s global variable <code>Base.Sys.CPU_CORES</code>, which gives the total count of all cores on the machine.  Thus, <code>Base.Sys.CPU_CORES ÷ CpuId.cputhreads()</code> gives you the number of CPUs (packages) in your system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cputhreads_per_core" href="#CpuId.cputhreads_per_core"><code>CpuId.cputhreads_per_core</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cputhreads_per_core() -&gt; Int</code></pre><p>Determine the of threads per hardware core on the currently executing CPU. A value larger than one indicates simulatenous multithreading being enabled, aka SMT, aka Hyperthreading.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpuvendor" href="#CpuId.cpuvendor"><code>CpuId.cpuvendor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpuvendor()</code></pre><p>Determine the cpu vendor as a Julia symbol.  In case the CPU vendor identification is unknown <code>:Unknown</code> is returned (then also consider raising an issue on Github).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.cpuvendorstring" href="#CpuId.cpuvendorstring"><code>CpuId.cpuvendorstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cpuvendorstring()</code></pre><p>Determine the cpu vendor string as provided by the cpu by executing a <code>cpuid</code> instruction.  Note, this string has a fixed length of 12 characters. Use <code>cpuvendor()</code> if you prefer getting a parsed Julia symbol.</p></div></div></section><pre><code class="language-none">CpuId.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.has_cpu_frequencies" href="#CpuId.has_cpu_frequencies"><code>CpuId.has_cpu_frequencies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_cpu_frequencies()</code></pre><p>Determine whether the CPU provides clock frequency information.  If true, then <code>cpu_base_frequency()</code>, <code>cpu_max_frequency()</code> and <code>cpu_bus_frequency()</code> should be expected to return sensible information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hasleaf" href="#CpuId.hasleaf"><code>CpuId.hasleaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hasleaf(leaf::UInt32) ::Bool</code></pre><p>Helper function (not exported) to test whether the CPU claims to provide the given leaf in a <code>cpuid</code> instruction call.</p><p>Note: It appears LLVM really know its gear: If this function is inlined, and       just-in-time compiled, then this test is eliminated completly if the       executing machine does support this feature. Yeah!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hvinfo" href="#CpuId.hvinfo"><code>CpuId.hvinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hvinfo() ::MarkdownString</code></pre><p>Generate a markdown table of all the detected/available/supported tags of a running hypervisor.  If there is no hosting hypervisor, an empty markdown string is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hvvendor" href="#CpuId.hvvendor"><code>CpuId.hvvendor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hvvendor()</code></pre><p>Determine the hypervisor vendor as a Julia symbol or <code>:NoHypervisor</code> if not running a hypervisor. In case the hypervisor vendor identification is unknown <code>:Unknown</code> is returned (then also consider raising an issue on Github).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hvvendorstring" href="#CpuId.hvvendorstring"><code>CpuId.hvvendorstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hvvendorstring()</code></pre><p>Determine the hypervisor vendor string as provided by the cpu by executing a <code>cpuid</code> instruction.  Note, this string has a fixed length of 12 characters. Use <code>hvvendor()</code> if you prefer getting a parsed Julia symbol.  If the CPU is not running a hypervisor, a string of undefined content will be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hvversion" href="#CpuId.hvversion"><code>CpuId.hvversion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hvversion()</code></pre><p>Get a dictionary with additional information of the running hypervisor. The dictionary is empty if no hypervisor is detected, and only tags that are provided by the hypervisor are included.</p><p>Note, the data available is hypervisor vendor dependent.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.hypervised" href="#CpuId.hypervised"><code>CpuId.hypervised</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypervised()</code></pre><p>Check whether the CPU reports to run a hypervisor context, that is, whether the current process runs in a virtual machine.</p><p>A positive answer may indicate that other information reported by the CPU is fake, such as number of physical and logical cores.  This is because the hypervisor is free to decide which information to pass.</p></div></div></section><pre><code class="language-none">CpuId.include</code></pre><pre><code class="language-none">CpuId.parse_markdown</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.perf_fix_bits" href="#CpuId.perf_fix_bits"><code>CpuId.perf_fix_bits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perf_fix_bits()</code></pre><p>Determine the number of bits fixed-function counters performance counters on the executing CPU.</p><p>This information is only available if <code>cpufeature(PDCM) == true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.perf_fix_counters" href="#CpuId.perf_fix_counters"><code>CpuId.perf_fix_counters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perf_fix_counters()</code></pre><p>Determine the number of fixed-function performance counters on the executing machine.</p><p>This information is only available if <code>cpufeature(PDCM) == true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.perf_gen_bits" href="#CpuId.perf_gen_bits"><code>CpuId.perf_gen_bits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perf_gen_bits()</code></pre><p>Determine the number of bits general purpose counters performance counters on the executing CPU.</p><p>This information is only available if <code>cpufeature(PDCM) == true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.perf_gen_counters" href="#CpuId.perf_gen_counters"><code>CpuId.perf_gen_counters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perf_gen_counters()</code></pre><p>Determine the number of general purpose counters performance counters on the executing CPU.  Number of counters is given as per logical processor.</p><p>This information is only available if <code>cpufeature(PDCM) == true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.perf_revision" href="#CpuId.perf_revision"><code>CpuId.perf_revision</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perf_revision()</code></pre><p>Determine the revision number of the performance monitoring unit.</p><p>This information is only available if <code>cpufeature(PDCM) == true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.physical_address_size" href="#CpuId.physical_address_size"><code>CpuId.physical_address_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">physical_address_size()</code></pre><p>Determine the maximum phyiscal addresses size supported by this CPU as reported by the <code>cpuid</code> instructions.  Prefer to make use of <code>address_size</code> for practical purposes; use this only for diagnostic issues, such as determining the theoretical maximum memory size.  Also note that this address size is manipulated by a running hypervisor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.simdbits" href="#CpuId.simdbits"><code>CpuId.simdbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simdbits()</code></pre><p>Query the CPU on the maximum supported SIMD vector size in bits, or <code>sizeof(Int)</code> in bits if no SIMD capability is reported by the invoked <code>cpuid</code> instruction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CpuId.simdbytes" href="#CpuId.simdbytes"><code>CpuId.simdbytes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simdbytes()</code></pre><p>Query the CPU on the maximum supported SIMD vector size in bytes, or <code>sizeof(Int)</code> if no SIMD capability is reported by the invoked <code>cpuid</code> instruction.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
