<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · PolyChaos.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/myfont.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><h1>PolyChaos.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../type_hierarchy/">Type Hierarchy</a></li><li><span class="toctext">Usage</span><ul><li><a class="toctext" href="../numerical_integration/">Numerical Integration</a></li><li><a class="toctext" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="toctext" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="toctext" href="../scalar_products/">Computation of Scalar Products</a></li><li><span class="toctext">Polynomial Chaos</span><ul><li><a class="toctext" href="../pce_tutorial/">Basic Usage</a></li><li><a class="toctext" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="toctext" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="toctext" href="../random_ode/">Random ODE</a></li></ul></li></ul></li><li><a class="toctext" href="../math/">Mathematical Background</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1">Recurrence Coefficients for Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="#Scalar-Products-1">Scalar Products</a></li><li><a class="toctext" href="#Evaluating-Orthogonal-Polynomials-1">Evaluating Orthogonal Polynomials</a></li><li><a class="toctext" href="#Quadrature-Rules-1">Quadrature Rules</a></li><li><a class="toctext" href="#Polynomial-Chaos-1">Polynomial Chaos</a></li><li><a class="toctext" href="#Auxiliary-Functions-1">Auxiliary Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Functions</a></li></ul></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><p>List of all functions in <code>PolyChaos</code>.</p><ul><li><a href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a></li><li><a href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a></li><li><a href="#PolyChaos.clenshaw_curtis"><code>PolyChaos.clenshaw_curtis</code></a></li><li><a href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a></li><li><a href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a></li><li><a href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a></li><li><a href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a></li><li><a href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a></li><li><a href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a></li><li><a href="#PolyChaos.fejer"><code>PolyChaos.fejer</code></a></li><li><a href="#PolyChaos.fejer2"><code>PolyChaos.fejer2</code></a></li><li><a href="#PolyChaos.gauss"><code>PolyChaos.gauss</code></a></li><li><a href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a></li><li><a href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a></li><li><a href="#PolyChaos.lobatto"><code>PolyChaos.lobatto</code></a></li><li><a href="#PolyChaos.lobatto_jacobi"><code>PolyChaos.lobatto_jacobi</code></a></li><li><a href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a></li><li><a href="#PolyChaos.nw"><code>PolyChaos.nw</code></a></li><li><a href="#PolyChaos.quadgp"><code>PolyChaos.quadgp</code></a></li><li><a href="#PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}"><code>PolyChaos.r_scale</code></a></li><li><a href="#PolyChaos.radau"><code>PolyChaos.radau</code></a></li><li><a href="#PolyChaos.radau_jacobi"><code>PolyChaos.radau_jacobi</code></a></li><li><a href="#PolyChaos.radau_laguerre"><code>PolyChaos.radau_laguerre</code></a></li><li><a href="#PolyChaos.rm_compute-Tuple{Function,Float64,Float64}"><code>PolyChaos.rm_compute</code></a></li><li><a href="#PolyChaos.rm_hermite-Tuple{Int64,Float64}"><code>PolyChaos.rm_hermite</code></a></li><li><a href="#PolyChaos.rm_hermite_prob-Tuple{Int64}"><code>PolyChaos.rm_hermite_prob</code></a></li><li><a href="#PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi</code></a></li><li><a href="#PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi01</code></a></li><li><a href="#PolyChaos.rm_laguerre-Tuple{Int64,Float64}"><code>PolyChaos.rm_laguerre</code></a></li><li><a href="#PolyChaos.rm_legendre-Tuple{Int64}"><code>PolyChaos.rm_legendre</code></a></li><li><a href="#PolyChaos.rm_legendre01-Tuple{Int64}"><code>PolyChaos.rm_legendre01</code></a></li><li><a href="#PolyChaos.rm_logistic-Tuple{Int64}"><code>PolyChaos.rm_logistic</code></a></li><li><a href="#PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_meixner_pollaczek</code></a></li><li><a href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a></li><li><a href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a></li><li><a href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a></li><li><a href="#Statistics.mean"><code>Statistics.mean</code></a></li><li><a href="#Statistics.std"><code>Statistics.std</code></a></li><li><a href="#Statistics.var"><code>Statistics.var</code></a></li></ul><h2><a class="nav-anchor" id="Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1">Recurrence Coefficients for Monic Orthogonal Polynomials</a></h2><p>The functions below provide analytic expressions for the recurrence coefficients of common orthogonal polynomials. All of these provide <em>monic orthogonal polynomials</em> relative to the weights.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The number <code>N</code> of recurrence coefficients has to be positive for all functions below.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}" href="#PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}"><code>PolyChaos.r_scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">r_scale(c::Float64,β::Vector{Float64},α::Vector{Float64})</code></pre><p>Given the recursion coefficients <code>(α,β)</code> for a system of orthogonal polynomials that are orthogonal with respect to some positive weight <span>$m(t)$</span>, this function returns the recursion coefficients <code>(α_,β_)</code> for the scaled measure <span>$c m(t)$</span> for some positive <span>$c$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_compute-Tuple{Function,Float64,Float64}" href="#PolyChaos.rm_compute-Tuple{Function,Float64,Float64}"><code>PolyChaos.rm_compute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_compute(weight::Function,lb::Float64,ub::Float64;Npoly::Int64=4,Nquad::Int64=10,quadrature::Function=clenshaw_curtis)</code></pre><p>Given a positive <code>weight</code> function with domain <code>(lb,ub)</code>, i.e. a function <span>$w: [lb, ub ] \rightarrow \mathbb{R}_{\geq 0}$</span>, this function creates <code>Npoly</code> recursion coefficients <code>(α,β)</code>.</p><p>The keyword <code>quadrature</code> specifies what quadrature rule is being used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_logistic-Tuple{Int64}" href="#PolyChaos.rm_logistic-Tuple{Int64}"><code>PolyChaos.rm_logistic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_logistic(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \frac{\mathrm{e}^{-t}}{(1 - \mathrm{e}^{-t})^2}$</span></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_hermite-Tuple{Int64,Float64}" href="#PolyChaos.rm_hermite-Tuple{Int64,Float64}"><code>PolyChaos.rm_hermite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_hermite(N::Int,mu::Float64)
rm_hermite(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = |t|^{2 \mu} \mathrm{e}^{-t^2}$</span></p><p>The call <code>rm_hermite(N)</code> is the same as <code>rm_hermite(N,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_hermite_prob-Tuple{Int64}" href="#PolyChaos.rm_hermite_prob-Tuple{Int64}"><code>PolyChaos.rm_hermite_prob</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_hermite_prob(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic probabilists&#39; Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \mathrm{e}^{-0.5t^2}$</span></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_laguerre-Tuple{Int64,Float64}" href="#PolyChaos.rm_laguerre-Tuple{Int64,Float64}"><code>PolyChaos.rm_laguerre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_laguerre(N::Int,a::Float64)
rm_laguerre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Laguerre polynomials that are orthogonal on <span>$(0,\infty)$</span> relative to <span>$w(t) = t^a \mathrm{e}^{-t}$</span>.</p><p>The call <code>rm_laguerre(N)</code> is the same as <code>rm_laguerre(N,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_legendre-Tuple{Int64}" href="#PolyChaos.rm_legendre-Tuple{Int64}"><code>PolyChaos.rm_legendre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_legendre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_legendre01-Tuple{Int64}" href="#PolyChaos.rm_legendre01-Tuple{Int64}"><code>PolyChaos.rm_legendre01</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_legendre01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_jacobi(N::Int,a::Float64,b::Float64)
rm_jacobi(N::Int,a::Float64)
rm_jacobi(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = (1-t)^a (1+t)^b$</span>.</p><p>The call <code>rm_jacobi(N,a)</code> is the same as <code>rm_jacobi(N,a,a)</code> and <code>rm_jacobi(N)</code> the same as <code>rm_jacobi(N,0,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi01</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_jacobi01(N::Int,a::Float64,b::Float64)
rm_jacobi01(N::Int,a::Float64)
rm_jacobi01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = (1-t)^a t^b$</span>.</p><p>The call <code>rm_jacobi01(N,a)</code> is the same as <code>rm_jacobi01(N,a,a)</code> and <code>rm_jacobi01(N)</code> the same as <code>rm_jacobi01(N,0,0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_meixner_pollaczek</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_meixner_pollaczek(N::Int,lambda::Float64,phi::Float64)
rm_meixner_pollaczek(N::Int,lambda::Float64)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic  Meixner-Pollaczek polynomials with parameters λ and ϕ. These are orthogonal on  <span>$[-\infty,\infty]$</span> relative to the weight function <span>$w(t)=(2 \pi)^{-1} \exp{(2 \phi-\pi)t} |\Gamma(\lambda+ i t)|^2$</span>.</p><p>The call <code>rm_meixner_pollaczek(n,lambda)</code> is the same as <code>rm_meixner_pollaczek(n,lambda,pi/2)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.stieltjes" href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stieltjes(N::Int64,nodes_::Vector{Float64},weights_::Vector{Float64};removezeroweights::Bool=true)</code></pre><p>Stieltjes procedure–-Given the nodes and weights the function generates the first<code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.lanczos" href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos(N::Int64,nodes_::Vector{Float64},weights_::Vector{Float64};removezeroweights::Bool=true)</code></pre><p>Lanczos procedure–-given the nodes and weights the function generates the first <code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p><p>The script is adapted from the routine RKPW in W.B. Gragg and W.J. Harrod, <em>The numerically stable reconstruction of Jacobi matrices from spectral data</em>, Numer. Math. 44 (1984), 317-335.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.mcdiscretization" href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mcdiscretization(N::Int64,quads::Vector{},discretemeasure::Matrix{Float64}=zeros(0,2);discretization::Function=stieltjes,Nmax::Integer=300,ε::Float64=1e-8,gaussquad::Bool=false)</code></pre><p>This routine returns <span>$N$</span> recurrence coefficients of the polynomials that are orthogonal relative to a weight function <span>$w$</span> that is decomposed as a sum of <span>$m$</span> weights <span>$w_i$</span> with domains <span>$[a_i,b_i]$</span> for <span>$i=1,\dots,m$</span>,</p><div>\[w(t) = \sum_{i}^{m} w_i(t) \quad \text{with } \operatorname{dom}(w_i) = [a_i, b_i].\]</div><p>For each weight <span>$w_i$</span> and its domain <span>$[a_i, b_i]$</span> the function <code>mcdiscretization()</code> expects a quadrature rule of the form     nodes::Vector{Float64}, weights::Vector{Float64} = my<em>quad</em>i(N::Int64) all of which are stacked in the parameter <code>quad</code>     quad = [ my<em>quad</em>1, ..., my<em>quad</em>m ] If the weight function has a discrete part (specified by <code>discretemeasure</code>) it is added on to the discretized continuous weight function.</p><p>The function <code>mcdiscretization()</code> performs a sequence of discretizations of the given weight <span>$w(t)$</span>, each discretization being followed by an application of the Stieltjes or Lanczos procedure (keyword <code>discretization in [stieltjes, lanczos]</code>) to produce approximations to the desired recurrence coefficients. The function applies to each subinterval <span>$i$</span> an <code>N</code>-point quadrature rule (the <span>$i$</span>th entry of <code>quad</code>) to discretize the weight function <span>$w_i$</span> on that subinterval. If the procedure converges to within a prescribed accuracy <code>ε</code> before <code>N</code> reaches its maximum allowed value <code>Nmax</code>. If the function does not converge, the function prompts an error message.</p><p>The keyword <code>gaussquad</code> should be set to <code>true</code> if Gauss quadrature rules are available <em>for all</em> <span>$m$</span> weights <span>$w_i(t)$</span> with <span>$i = 1, \dots, m$</span>.</p><p>For further information, please see W. Gautschi &quot;Orthogonal Polynomials: Approximation and Computation&quot;, Section 2.2.4.</p></div></div></section><h2><a class="nav-anchor" id="Scalar-Products-1" href="#Scalar-Products-1">Scalar Products</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.computeSP2" href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">computeSP2(n::Int64,β::Vector{Float64})
computeSP2(n::Int64,op::OrthoPoly) = computeSP2(n,op.β)
computeSP2(op::OrthoPoly) = computeSP2(op.deg,op.β)
computeSP2(opq::OrthoPolyQ) = computeSP2(opq.op)</code></pre><p>Computes the <code>n</code> <em>regular</em> scalar products aka 2-norms of the orthogonal polynomials, namely</p><div>\[\|ϕ_i\|^2 = \langle \phi_i,\phi_i\rangle \quad \forall i \in \{ 0,\dots,n \}.\]</div><p>Notice that only the values of <code>β</code> of the recurrence coefficients <code>(α,β)</code> are required. The computation is based on equation (1.3.7) from Gautschi, W. &quot;Orthogonal Polynomials: Computation and Approximation&quot;. Whenever there exists an analytic expressions for <code>β</code>, this function should be used.</p><p>The function is multiply dispatched to facilitate its use with the composite types <code>OrthoPoly</code> and <code>OrthoPolyQ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.computeSP" href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">computeSP(a::Vector{Int64},α::Vector{Float64},β::Vector{Float64},nodes::Vector{Float64},weights::Vector{Float64};issymmetric::Bool=false)
computeSP(a::Vector{Int64},op::OrthoPoly,q::Quad;issymmetric=issymmetric(op))
computeSP(a::Vector{Int64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">computeSP( a::Vector{Int64},
           α::Vector{Vector{Float64}},β::Vector{Vector{Float64}},
           nodes::Vector{Vector{Float64}},weights::Vector{Vector{Float64}},
           ind::Matrix{Int64};
           issymmetric::BitArray=falses(length(α)))
computeSP(a::Vector{Int64},op::Vector{OrthoPoly},q::Vector{Quad},ind::Matrix{Int64})
computeSP(a::Vector{Int64},mOP::MultiOrthoPoly)</code></pre><p>Computes the scalar product</p><div>\[\langle \phi_{a_1},\phi_{a_2},\cdots,\phi_{a_n} \rangle,\]</div><p>where <code>n = length(a)</code>. This requires to provide the recurrence coefficients <code>(α,β)</code> and the quadrature rule <code>(nodes,weights)</code>, as well as the multi-index <code>ind</code>. If provided via the keyword <code>issymmetric</code>, symmetry of the weight function is exploited. All computations of the multivariate scalar products resort back to efficient computations of the univariate scalar products. Mathematically, this follows from Fubini&#39;s theorem.</p><p>The function is multiply dispatched to facilitate its use with <code>OrthoPolyQ</code> or a suitable combination of <code>OrthoPoly</code> and its quadrature rule <code>Quad</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li>Zero entries of <span>$a$</span> are removed automatically to simplify computations, which follows from</li></ul><div>\[\langle \phi_i, \phi_j, \phi_0,\cdots,\phi_0 \rangle = \langle \phi_i, \phi_j \rangle,\]</div><p>because <code>\phi_0 = 1</code>.</p><ul><li>It is checked whether enough quadrature points are supplied to solve the integral exactly.</li></ul></div></div></div></div></section><h2><a class="nav-anchor" id="Evaluating-Orthogonal-Polynomials-1" href="#Evaluating-Orthogonal-Polynomials-1">Evaluating Orthogonal Polynomials</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.evaluate" href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">evaluate(n::Int64,x::Array{Float64},a::Vector{Float64},b::Vector{Float64})
evaluate(n::Int64,x::Float64,a::Vector{Float64},b::Vector{Float64})
evaluate(n::Int64,x::Vector{Float64},op::OrthoPoly)
evaluate(n::Int64,x::Float64,op::OrthoPoly)
evaluate(n::Int64,x::Vector{Float64},opq::OrthoPolyQ) = evaluate(n,x,opq.op)
evaluate(n::Int64,x::Float64,opq::OrthoPolyQ) = evaluate(n,[x],opq.op)</code></pre><p>Evaluate the <code>n</code>-th univariate basis polynomial at point(s) <code>x</code> The function is multiply dispatched to facilitate its use with the composite type <code>OrthoPoly</code></p><p>If several basis polynomials (stored in <code>ns</code>) are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(ns::Vector{Int64},x::Vector{Float64},op::OrthoPoly) = evaluate(ns,x,op.α,op.β)
evaluate(ns::Vector{Int64},x::Float64,op::OrthoPoly) = evaluate(ns,[x],op)
evaluate(ns::Vector{Int64},x::Vector{Float64},opq::OrthoPolyQ) = evaluate(ns,x,opq.op)
evaluate(ns::Vector{Int64},x::Float64,opq::OrthoPolyQ) = evaluate(ns,[x],opq.op)</code></pre><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(x::Vector{Float64},op::OrthoPoly) = evaluate(collect(0:op.deg),x,op)
evaluate(x::Float64,op::OrthoPoly) = evaluate([x],op)
evaluate(x::Vector{Float64},opq::OrthoPolyQ) = evaluate(x,opq.op)
evaluate(x::Float64,opq::OrthoPolyQ) = evaluate([x],opq)</code></pre><p>which returns an Array of dimensions <code>(length(x),op.deg+1)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li><code>n</code> is the degree of the univariate basis polynomial</li><li><code>length(x) = N</code>, where <code>N</code> is the number of points</li><li><code>(a,b)</code> are the recursion coefficients</li></ul></div></div><p><strong>Multivariate</strong></p><pre><code class="language-none">evaluate(n::Vector{Int64},x::Matrix{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(n::Vector{Int64},x::Vector{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(n::Vector{Int64},x::Matrix{Float64},op::MultiOrthoPoly)
evaluate(n::Vector{Int64},x::Vector{Float64},op::MultiOrthoPoly)</code></pre><p>Evaluate the n-th p-variate basis polynomial at point(s) x The function is multiply dispatched to facilitate its use with the composite type <code>MultiOrthoPoly</code></p><p>If several basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(ind::Matrix{Int64},x::Matrix{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(ind::Matrix{Int64},x::Matrix{Float64},op::MultiOrthoPoly)</code></pre><p>where <code>ind</code> is a matrix of multi-indices.</p><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(x::Matrix{Float64},mop::MultiOrthoPoly) = evaluate(mop.ind,x,mop)</code></pre><p>which returns an array of dimensions <code>(mop.dim,size(x,1))</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li>`n is a multi-index</li><li><code>length(n) == p</code>, i.e. a p-variate basis polynomial</li><li><code>size(x) = (N,p)</code>, where <code>N</code> is the number of points</li><li><code>size(a)==size(b)=p</code>.</li></ul></div></div></div></div></section><h2><a class="nav-anchor" id="Quadrature-Rules-1" href="#Quadrature-Rules-1">Quadrature Rules</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.fejer" href="#PolyChaos.fejer"><code>PolyChaos.fejer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fejer(N::Int64)</code></pre><p>Fejer&#39;s first quadrature rule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.fejer2" href="#PolyChaos.fejer2"><code>PolyChaos.fejer2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fejer2(n::Int64)</code></pre><p>Fejer&#39;s second quadrature rule according to <a href="https://doi.org/10.1007/s10543-006-0045-4">Waldvogel, J. Bit Numer Math (2006) 46: 195</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.clenshaw_curtis" href="#PolyChaos.clenshaw_curtis"><code>PolyChaos.clenshaw_curtis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clenshaw_curtis(n::Int64)</code></pre><p>Clenshaw-Curtis quadrature according to <a href="https://doi.org/10.1007/s10543-006-0045-4">Waldvogel, J. Bit Numer Math (2006) 46: 195</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.quadgp" href="#PolyChaos.quadgp"><code>PolyChaos.quadgp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quadgp(weight::Function,a::Float64,b::Float64,N::Int64=10;quadrature::Function=clenshaw_curti</code></pre><p>general purpose quadrature based on Gautschi, &quot;Orthogonal Polynomials: Computation and Approximation&quot;, Section 2.2.2, pp. 93-95</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.gauss" href="#PolyChaos.gauss"><code>PolyChaos.gauss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gauss(N::Int64,α::Vector{Float64},β::Vector{Float64})
gauss(α::Vector{Float64},β::Vector{Float64})
gauss(N::Int64,op::OrthoPoly)
gauss(op::OrthoPoly)</code></pre><p>Gauss quadrature rule, also known as Golub-Welsch algorithm</p><p><code>gauss()</code> generates the <code>N</code> Gauss quadrature nodes and weights for a given weight function. The weight function is represented by the <code>N</code> recurrence coefficients for the monic polynomials orthogonal with respect to the weight function.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If no <code>N</code> is provided, then <code>N = length(α)</code>.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.radau" href="#PolyChaos.radau"><code>PolyChaos.radau</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radau(N::Int64,α::Vector{Float64},β::Vector{Float64},end0::Float64)
radau(α::Vector{Float64},β::Vector{Float64},end0::Float64)
radau(N::Int64,op::OrthoPoly,end0::Float64)
radau(op::OrthoPoly,end0::Float64)</code></pre><p>Gauss-Radau quadrature rule. Given a weight function encoded by the recurrence coefficients <code>(α,β)</code>for the associated orthogonal polynomials, the function generates the nodes and weights <code>(n+1)</code>-point Gauss-Radau quadrature rule for the weight function having a prescribed node <code>end0</code> (typically at one of the end points of the support interval of w, or outside thereof).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If no <code>N</code> is specified, then <code>N = length(α)-1</code>.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Reference: OPQ: A MATLAB SUITE OF PROGRAMS FOR GENERATING ORTHOGONAL POLYNOMIALS AND RELATED QUADRATURE RULES by Walter Gautschi</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.radau_jacobi" href="#PolyChaos.radau_jacobi"><code>PolyChaos.radau_jacobi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radau_jacobi(N::Int64,a::Float64,b::Float64;endpoint::String=&quot;left&quot;)
endpoint in [&quot;left&quot;, &quot;right&quot;]
radau_jacobi(N::Int64,a::Float64;endpoint::String=&quot;left&quot;) = radau_jacobi(N,a,a;endpoint=endpoint)
radau_jacobi(N::Int64;endpoint::String=&quot;left&quot;) = radau_jacobi(N,0.;endpoint=endpoint)</code></pre><p>Gauss-Radau quadrature rule for Jacobi weight function, which generates the <code>(n+1)</code>-point Gauss-Radau rule for the Jacobi weight function on <code>[-1,1]</code> with parameters <code>a</code> and <code>b</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>REFERENCE: W. Gautschi, ``Gauss-Radau formulae for Jacobi and Laguerre weight functions&#39;&#39;, Math. Comput. Simulation 54 (2000), 403-412.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.radau_laguerre" href="#PolyChaos.radau_laguerre"><code>PolyChaos.radau_laguerre</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radau_laguerre(N::Int64,a::Float64)
radau_laguerre(N::Int64) = radau_laguerre(N,0.)</code></pre><p>Gauss-Radau quadrature rule for Laguerre weight function, which generates the <code>(n+1)</code>-point Gauss-Radau rule for the Laguerre weight function on <span>$[0,\infty]$</span> with parameter <code>a</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>REFERENCE: W. Gautschi, ``Gauss-Radau formulae for Jacobi and Laguerre weight functions&#39;&#39;, Math. Comput. Simulation 54 (2000), 403-412.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.lobatto" href="#PolyChaos.lobatto"><code>PolyChaos.lobatto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lobatto(N::Int64,α::Vector{Float64},β::Vector{Float64},endl::Float64,endr::Float64)
lobatto(α::Vector{Float64},β::Vector{Float64},endl::Float64,endr::Float64)
lobatto(N::Int64,op::OrthoPoly,endl::Float64,endr::Float64)
lobatto(op::OrthoPoly,endl::Float64,endr::Float64)</code></pre><p>Gauss-Lobatto quadrature rule. Given a weight function encoded by the recurrence coefficients for the associated orthogonal polynomials, the function generates the nodes and weights of the <code>(N+2)</code>-point Gauss-Lobatto quadrature rule for the weight function, having two prescribed nodes <code>endl</code>, <code>endr</code> (typically the left and right end points of the support interval, or points to the left resp. to the right therof).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If no <code>N</code> is specified, then <code>N = length(α)-2</code>.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Reference: OPQ: A MATLAB SUITE OF PROGRAMS FOR GENERATING ORTHOGONAL POLYNOMIALS AND RELATED QUADRATURE RULES by Walter Gautschi</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.lobatto_jacobi" href="#PolyChaos.lobatto_jacobi"><code>PolyChaos.lobatto_jacobi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lobatto_jacobi(N::Int64,a::Float64,b::Float64)
lobatto_jacobi(N::Int64,a::Float64) = lobatto_jacobi(N,a,a)
lobatto_jacobi(N::Int64) = lobatto_jacobi(N,0.)</code></pre><p>Gauss-Lobatto quadrature rule for Jacobi weight function, which generates the <code>(n+2)</code>-point Gauss- Lobatto rule for the Jacobi weight function on <span>$[-1,1]$</span> with parameters <code>a</code> and <code>b</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>REFERENCE: W. Gautschi,``High-order Gauss-Lobatto formulae&#39;&#39;, Numer. Algorithms 25 (2000), 213-222.</p></div></div></div></div></section><h2><a class="nav-anchor" id="Polynomial-Chaos-1" href="#Polynomial-Chaos-1">Polynomial Chaos</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">mean(x::Vector{Float64},op::OrthoPoly)
mean(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">mean(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute mean of random variable with PCE <code>x</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.var" href="#Statistics.var"><code>Statistics.var</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">var(x::Vector{Float64},op::OrthoPoly)
var(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">var(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute variance of random variable with PCE <code>x</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.std" href="#Statistics.std"><code>Statistics.std</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">std(x::Vector{Float64},op::OrthoPoly)
std(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">std(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute standard deviation of random variable with PCE <code>x</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.sampleMeasure" href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">sampleMeasure(n::Int64,name::String,w::Function,dom::Tuple{Float64,Float64},symm::Bool,d::Dict;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,m::Measure;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,op::OrthoPoly;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,opq::OrthoPolyQ;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Draw <code>n</code> samples from the measure <code>m</code> described by its</p><ul><li><code>name</code></li><li>weight function <code>w</code>,</li><li>domain <code>dom</code>,</li><li>symmetry property <code>symm</code>,</li><li>and, if applicable, parameters stored in the dictionary <code>d</code>.</li></ul><p>By default an adaptive rejection sampling method is used (from <a href="https://github.com/mauriciogtec/AdaptiveRejectionSampling.jl">AdaptiveRejectionSampling.jl</a>), unless it is a common random variable for which <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> is used.</p><p>The function is multiply dispatched to accept <code>OrthoPoly</code> or <code>OrthoPolyQ</code>.</p><p><strong>Multivariate</strong></p><pre><code class="language-none">sampleMeasure(n::Int64,m::MultiMeasure;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(m.name)])
sampleMeasure(n::Int64,mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre><p>Multivariate extension which provides array of samples with <code>n</code> rows and as many columns as the multimeasure has univariate measures.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.evaluatePCE" href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluatePCE(x::Vector{Float64},ξ::Vector{Float64},α::Vector{Float64},β::Vector{Float64})</code></pre><p>Evaluation of polynomial chaos expansion</p><div>\[\mathsf{x} = \sum_{i=0}^{L} x_i \phi_i{\xi_j},\]</div><p>where <code>L+1 = length(x)</code> and <span>$x_j$</span> is the <span>$j$</span>th sample where <span>$j=1,\dots,m$</span> with <code>m = length(ξ)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.samplePCE" href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">samplePCE(n::Int64,x::Vector{Float64},op::OrthoPoly;method::String=&quot;adaptiverejection&quot;)
samplePCE(n::Int64,x::Vector{Float64},opq::OrthoPolyQ;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Combines <a href="#PolyChaos.sampleMeasure"><code>sampleMeasure</code></a> and <a href="#PolyChaos.evaluatePCE"><code>evaluatePCE</code></a>, i.e. it first draws <code>n</code> samples from the measure, then evaluates the PCE for those samples.</p><p><strong>Multivariate</strong></p><pre><code class="language-none">samplePCE(n::Int64,x::Vector{Float64},mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.calculateAffinePCE" href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">calculateAffinePCE(α::Vector{Float64})::Vector{Float64}</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from recurrence coefficients <span>$lpha$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.convert2affinePCE" href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert2affinePCE(a::Vector{Float64},α0::Float64)
convert2affinePCE(name::String,p1::Float64,p2::Float64,d::Dict=Dict();kind::Symbol=:lbub)</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from</p><div>\[X = a_1 + a_2 \Xi = x_0 + x_1 \phi_1(\Xi),\]</div><p>where <span>$\phi_1(t) = t-\alpha_0$</span> is the first-order monic basis polynomial.</p><p>For classical polynomials the <code>name</code> can be given directly. The keyword <code>kind in [:lbub, :μσ]</code> specifies whether <code>p1</code> and <code>p2</code> have the meaning of lower/upper bounds or mean/standard deviation.</p></div></div></section><h2><a class="nav-anchor" id="Auxiliary-Functions-1" href="#Auxiliary-Functions-1">Auxiliary Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.nw" href="#PolyChaos.nw"><code>PolyChaos.nw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nw(q::Quad)
nw(opq::OrthoPolyQ)
nw(opq::Vector{OrthoPolyQ})
nw(mOP::MultiOrthoPoly)</code></pre><p>returns nodes and weights in matrix form</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.coeffs" href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coeffs(op::OrthoPoly)
coeffs(opq::OrthoPolyQ)
coeffs(op::Vector{OrthoPoly})
coeffs(opq::Vector{OrthoPolyQ})
coeffs(mop::MultiOrthoPoly)</code></pre><p>returns recurrence coefficients of in matrix form</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.integrate" href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrate(f::Function,nodes::Vector{Float64},weights::Vector{Float64})
integrate(f::Function,q::Quad)
integrate(f::Function,opq::OrthogonalPolyQ)</code></pre><p>integrate function <code>f</code> using quadrature rule specified via <code>nodes</code>, <code>weights</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><ul><li>function <span>$f$</span> is assumed to return a scalar</li><li>interval of integration is &quot;hidden&quot; in <span>$nodes$</span></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issymmetric" href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issymmetric(m::Measure)::Bool
issymmetric(op::OrthoPoly)::Bool
issymmetric(q::Quad)::Bool
issymmetric(opq::OrthoPolyQ)::Bool</code></pre><p>is measure symmetric (around any point in the domain)?</p></div></div></section><footer><hr/><a class="previous" href="../math/"><span class="direction">Previous</span><span class="title">Mathematical Background</span></a></footer></article></body></html>
