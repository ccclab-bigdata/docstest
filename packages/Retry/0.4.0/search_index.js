var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#Retry-1",
    "page": "Readme",
    "title": "Retry",
    "category": "section",
    "text": "Macros for simplified exception handling.@repeat try, @retry, @delay_retry, @protected try, @ignore.(Image: Build Status)"
},

{
    "location": "#Exception-Handling-In-Julia-1",
    "page": "Readme",
    "title": "Exception Handling In Julia",
    "category": "section",
    "text": "Julia\'s try/catch statement catches all exceptions regardless of type or error code.The examples in the Julia manual involve mathematical errors that occur in the immediate context of the try block. The examples assume that there is no possibility of unexpected exceptions and hence no need to rethrow(). For many technical computing tasks this is probably reasonable.However, typical systems-programming tasks must deal with with multi-layered distributed service stacks, interfaces to external systems and resource contention. These problems demand fine-grained exception filtering, simple expression of retry loops and confidence that unexpected exceptions are not unintentionally caught and ignored.Julia\'s catch block can include conditional logic to take appropriate action according to error type/code; and to rethrow exceptions that are not handled. However, this approach can seem cumbersome in comparison to the richer exception handling mechanisms provided in some systems programming languages. A simple careless omission of retrhow() at the end of a catch block causes all exceptions to be ignored resulting in behaviour that can be very hard to debug."
},

{
    "location": "#@protected-try-1",
    "page": "Readme",
    "title": "@protected try",
    "category": "section",
    "text": "The @protected try macro extends try/catch to:automatically insert rethow() at the end of the catch block, and\nprovide an unambiguous syntax for handling specific errors.Consider the following call to Create an authentication profile for an AWS EC2 virtual machine.try \n\n    iam(aws, Action = \"CreateInstanceProfile\", InstanceProfileName = name)\n\ncatch e\n    if !(typeof(e) == AWSException && e.code == \"EntityAlreadyExists\")\n        rethrow(e)\n    end\nend@protected try allows this to be simplified to:@protected try \n\n    iam(aws, Action = \"CreateInstanceProfile\", InstanceProfileName = name)\n\ncatch e\n    @ignore if e.code == \"EntityAlreadyExists\" end\nendNote that the @ignore if statement does not check typeof(e) before accessing e.code. The @ignore if condition is wrapped in an inner try/catch block such that any exceptions thrown by the condition are treated the same as the condition being false. The code generated by @protected try is:try\n\n    iam(aws, Action = \"CreateInstanceProfile\", InstanceProfileName = name)\n\ncatch e\n    try\n        if e.code == \"EntityAlreadyExists\"\n            e = nothing\n        end\n    end\n    e == nothing || rethrow(e)\nend"
},

{
    "location": "#@repeat-n-try-1",
    "page": "Readme",
    "title": "@repeat n try",
    "category": "section",
    "text": "The @repeat n try macro retains the automatic rethrow() and @ignore if features of @protected try and adds support for automatic retry.The following example tries four times to download an object from S3. If the object was only recently created, the storage replica serving the  GET request may not yet have a copy of it, so it is sometimes necessary to retry the request. The @delay_retry if statement implements an exponential backoff algorithm with randomised jitter to provide timely retries while avoiding un-due load on the server.@repeat 4 try\n\n   return s3(aws, \"GET\", bucket, path)\n\ncatch e\n    @delay_retry if e.code in [\"NoSuchBucket\", \"NoSuchKey\"] end\nend\nIf an exception is still raised on the fourth attempt rethrow() is called so the exception can be dealt with by a different stack frame.The code generated by the example above is:begin\n\n    delay = 0.05\n    result = false\n\n    for i = 1:4\n\n        result = try\n\n            return s3(aws,\"GET\",bucket,path)\n\n        catch e\n\n            try\n                if e.code in [\"NoSuchBucket\",\"NoSuchKey\"]\n                    if (i < 4)\n                        sleep(delay * (0.8 + (0.4 * rand())))\n                        delay *= 10\n                        continue\n                    end\n                end\n            catch\n            end\n\n            e == nothing || rethrow(e)\n        end\n        break\n    end\n\n    result\nendThe next example deals with two different temporary network/server exceptions that warrant a delayed retry; and another that can be re-tried immediately by re-directing to a different server.@repeat 4 try \n\n    return http_attempt(request)\n\ncatch e\n\n    @delay_retry if typeof(e) == UVError end\n\n    @delay_retry if http_status(e) < 200 &&\n                    http_status(e) >= 500 end\n\n    @retry if http_status(e) in [301, 302, 307]\n        request.uri = URI(headers(e)[\"Location\"])\n    end\n\nend\nThe final example deals with creating an SQS queue. If the queue already exists it must be deleted before creation is re-tried.@repeat 4 try\n\n    r = sqs(aws, Action = \"CreateQueue\", QueueName = name)\n    return = XML(r)[:QueueUrl]\n\ncatch e\n\n    @retry if e.code == \"QueueAlreadyExists\"\n        sqs_delete_queue(aws, name)\n    end\n\n    @retry if e.code == \"AWS.SimpleQueueService.QueueDeletedRecently\"\n        println(\"\"\"Waiting 1 minute to re-create Queue \"$name\"...\"\"\")\n        sleep(60)\n    end\nend\nThe examples above are taken from OCAWS.jl"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Retry.@protectedRetry.@repeatRetry.RetryRetry.check_macro_ifRetry.check_try_catchRetry.ecodeRetry.efieldRetry.esc_args!Retry.evalRetry.include"
},

]}
