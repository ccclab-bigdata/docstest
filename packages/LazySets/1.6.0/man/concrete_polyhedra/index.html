<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concrete Polyhedra Â· LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li class="current"><a class="toctext" href>Concrete Polyhedra</a><ul class="internal"><li><a class="toctext" href="#Creating-polyhedra-1">Creating polyhedra</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Projections-1">Projections</a></li></ul></li><li><a class="toctext" href="../parallel_approximations/">Parallel Approximations</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../lib/interfaces/">Set Interfaces</a></li><li><a class="toctext" href="../../lib/representations/">Common Set Representations</a></li><li><a class="toctext" href="../../lib/operations/">Common Set Operations</a></li><li><a class="toctext" href="../../lib/comparisons/">Comparisons</a></li><li><a class="toctext" href="../../lib/conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../../lib/binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../../lib/approximations/">Approximations</a></li><li><a class="toctext" href="../../lib/utils/">Utility Functions</a></li><li><a class="toctext" href="../../lib/parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Concrete Polyhedra</a></li></ul></nav><hr/><div id="topbar"><span>Concrete Polyhedra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Concrete-Polyhedra-1" href="#Concrete-Polyhedra-1">Concrete Polyhedra</a></h1><p>The focus of <code>LazySets.jl</code> is to wrap set representations and operations into specialized types, delaying the evaluation of the result of an expression until it is necessary. However, sometimes it is necessary to do an explicit computation. For concrete operations with polyhedra we rely on the polyhedra manipulation library <a href="https://github.com/JuliaPolyhedra/Polyhedra.jl">Polyhedra.jl</a>.</p><p>Actually, <code>Polyhedra.jl</code> provides a unified interface to well-known implementations of polyhedral computations, such as CDD or LRS (see the complete list in <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">the documentation of <code>Polyhedra.jl</code></a>). This is a great advantage because we can easily use a library that supports floating point arithmetic, rational arithmetic, multiple precision, etc. The libraries also include projection and elimination of variables through Fourier-Motzkin.</p><p>Below we give examples of operations that are actually done via <code>Polyhedra.jl</code>.</p><ul><li><a href="#Concrete-Polyhedra-1">Concrete Polyhedra</a></li><ul><li><a href="#Creating-polyhedra-1">Creating polyhedra</a></li><li><a href="#Methods-1">Methods</a></li><li><a href="#Projections-1">Projections</a></li></ul></ul><h2><a class="nav-anchor" id="Creating-polyhedra-1" href="#Creating-polyhedra-1">Creating polyhedra</a></h2><p>To use the <code>Polyhedra.jl</code> interface, you need to load the package with <code>using Polyhedra</code>. Let&#39;s create an H-representation object:</p><pre><code class="language-">using Plots, LazySets, Polyhedra, Compat.LinearAlgebra

A = [1. 1;1 -1;-1 0]
b = [1.,0,0]
H = Polyhedra.hrep(A, b)</code></pre><p>It is used to instantiate a new polyhedron:</p><pre><code class="language-">p = polyhedron(H)</code></pre><p>Now, <code>p</code> is of the generic type <code>Polyhedra.SimplePolyhedron{2,Float64, ...}</code>, where <code>2</code> states for its ambient dimension, and <code>Float64</code> the numeric field. The remaining fields specify the type of representation:</p><pre><code class="language-">typeof(p)</code></pre><p>Observe that we can use a particular backend, such as the <code>CDD</code> library:</p><pre><code class="language-">using CDDLib

p = polyhedron(H, CDDLib.Library())</code></pre><p>On the other hand, a <code>LazySets.HPolytope</code> object can be constructed from <code>p</code>:</p><pre><code class="language-">x = HPolytope(p)
x.constraints</code></pre><p>Conversely, from a <code>HPolytope</code> we can build a polyhedron:</p><pre><code class="language-">y = polyhedron(x)
typeof(y)</code></pre><p>Moreover, you can specify the backend with an extra argument. For instance, we can use an exact representation through the <code>Library(:exact)</code>:</p><pre><code class="language-">A, b = Rational{Int}[1 1;1 -1;-1 0], Rational{Int}[1,0,0]
p = HPolytope(A, b)

polyhedron(p; backend=CDDLib.Library(:exact))</code></pre><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><p>The utility methods available are convex hull, intersection and cartesian product. The dual representation as a list of vertices can be obtained with the <code>vertices_list</code> function.</p><div><pre><code class="language-julia">p = HPolytope([LinearConstraint([1.0, 0.0], 1.0),
               LinearConstraint([0.0, 1.0], 1.0),
               LinearConstraint([-1.0, 0.0], 1.0),
               LinearConstraint([0.0, -1.0], 1.0)])

constraints_list(p)</code></pre><pre><code class="language-none">4-element Array{LazySets.HalfSpace{Float64},1}:
 LazySets.HalfSpace{Float64}([1.0, 0.0], 1.0)
 LazySets.HalfSpace{Float64}([0.0, 1.0], 1.0)
 LazySets.HalfSpace{Float64}([-1.0, 0.0], 1.0)
 LazySets.HalfSpace{Float64}([0.0, -1.0], 1.0)</code></pre></div><div><pre><code class="language-julia">vertices_list(p)</code></pre><pre><code class="language-none">4-element Array{Array{Float64,1},1}:
 [1.0, 1.0]
 [-1.0, 1.0]
 [1.0, -1.0]
 [-1.0, -1.0]</code></pre></div><p>For example, the concrete intersection of two polytopes is performed with the <code>intersection</code> method.</p><pre><code class="language-">E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))
B = Ball1([2.5, 1.5], .8)

import LazySets.Approximations.overapproximate
polyoverapprox(x) = HPolytope(overapproximate(x, 1e-3).constraints)

Epoly = polyoverapprox(E)
Bpoly = polyoverapprox(B)
X = intersection(Epoly, Bpoly)

plot(E, 1e-3, aspectratio=1, alpha=0.4)
plot!(B, 1e-3, alpha=0.4)
plot!(X, 1e-3, alpha=0.4, color=&quot;black&quot;)</code></pre><h2><a class="nav-anchor" id="Projections-1" href="#Projections-1">Projections</a></h2><p>Projection of high-dimensional polyhedra and elimination of variables can be performed with the <code>eliminate</code> function, which supports three types of methods: <code>:FourierMotzkin</code>, <code>:BlockElimination</code> and <code>:ProjectGenerators</code>.</p><p>For further details, see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/polyhedron.html#Projecting-a-polyhedron-1">the documentation of Polyhedra.jl</a>.</p><footer><hr/><a class="previous" href="../reach_zonotopes_hybrid/"><span class="direction">Previous</span><span class="title">A Hybrid Reachability Algorithm</span></a><a class="next" href="../parallel_approximations/"><span class="direction">Next</span><span class="title">Parallel Approximations</span></a></footer></article></body></html>
