<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SpatialJackknife.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SpatialJackknife.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">SpatialJackknife.SpatialJackknife</code></pre><pre><code class="language-none">SpatialJackknife.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialJackknife.get_dims" href="#SpatialJackknife.get_dims"><code>SpatialJackknife.get_dims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function gets dimensions of a given data array and returns an error if they are not appropriate or consistent with the dimension of optional randoms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialJackknife.get_subvols" href="#SpatialJackknife.get_subvols"><code>SpatialJackknife.get_subvols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function takes a dataset and returns an array of subvolume indices for each datapoint. In this case, it takes a set of random mask points for dividing arbitrary volumes. It computes the quantiles of the mask and then finds the closest mask point to each data point to determine the subvolume the data point belongs in.</p><p>The function expects a data array with shape (ndat, ndims) for Ndat samples in ndims dimensions. The mask array should have shape (nmask, ndims) and then there is an integere side<em>divs which specifies the number of times each dimension is divided up to make side</em>divs^ndims subvolumes.</p></div></div><div><div><p>As with the other method for get_subvols, this function computes the subvolume indices for given samples. It assumes a constant density throughout the volume. The method computes the subvolumes based on a set of extrema for sample values in each dimension and a number of volumes to divide the sample on per side. If a single set of extrema are given, the assumption is that they are the same in each dimension. Alternatively, it can take a set of volume edges in each dimension.</p></div></div></section><pre><code class="language-none">SpatialJackknife.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialJackknife.jackknife" href="#SpatialJackknife.jackknife"><code>SpatialJackknife.jackknife</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function computes the jackknife mean and variance over the observations computed from the data with obsfunc. They are computed by repeatedly applying obsfunc to the data with one of the subvolumes removed. It therefore assumes that obsfunc has normalised the observable for that remaining volume. The function obsfunc must be callable with the form</p><p>obsfunc(data::Array{Float64, 2}, args...)</p><p>for optional args tuple and the value returned by obsfunc must be in the form of an array of floats. If any of the returned values are NaNs, an error will be raised. By default, the covariance matrix is computed for observables in more than one dimension, but setting covar to false will result in only the diagonal variances being returned.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
