<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· BigCombinatorics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BigCombinatorics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Rationale-1">Rationale</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BigCombinatorics-1" href="#BigCombinatorics-1">BigCombinatorics</a></h1><p><a href="https://travis-ci.org/scheinerman/BigCombinatorics.jl"><img src="https://travis-ci.org/scheinerman/BigCombinatorics.jl.svg?branch=master" alt="Build Status"/></a></p><p><a href="http://codecov.io/github/scheinerman/BigCombinatorics.jl?branch=master"><img src="http://codecov.io/github/scheinerman/BigCombinatorics.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>This is an implementation of various combinatorial functions. These functions <em>always</em> return <code>BigInt</code> values. This convention is signaled by the fact that these functions&#39; names begin with a capital letter.</p><h2><a class="nav-anchor" id="Rationale-1" href="#Rationale-1">Rationale</a></h2><p>If we want to calculate 20!, it&#39;s easy enough to do this:</p><pre><code class="language-julia">julia&gt; factorial(20)
2432902008176640000</code></pre><p>However, for 100!, we see this:</p><pre><code class="language-julia">julia&gt; factorial(100)
ERROR: OverflowError: 100 is too large to look up in the table
Stacktrace:
 [1] factorial_lookup(::Int64, ::Array{Int64,1}, ::Int64) at ./combinatorics.jl:19
 [2] factorial(::Int64) at ./combinatorics.jl:27
 [3] top-level scope at none:0</code></pre><p>The problem is that 100! is too big to fit in an <code>Int</code> answer. Of course, we could resolve this problem this way:</p><pre><code class="language-julia">julia&gt; factorial(big(100))
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</code></pre><p>We take a different approach. We shouldn&#39;t have to worry about how large our arguments may be before a combinatorial function overflows. Instead, let&#39;s assume the result is <em>always</em> of type <code>BigInt</code> so the calculation will not be hampered by this problem.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><ul><li><code>Fibonacci(n)</code> returns the <code>n</code>-th Fibonacci number with <code>Fibonacci(0)==0</code></li></ul><p>and <code>Fibonacci(1)==1</code>.</p><ul><li><code>Factorial(n)</code> returns <code>n!</code> and <code>Factorial(n,k)</code> returns <code>n!/k!</code>.</li><li><code>FallingFactorial(n,k)</code> returns <code>n*(n-1)*(n-2)*...*(n-k+1)</code>.</li><li><code>RisingFactorial(n,k)</code> returns <code>n*(n+1)*(n+2)*...*(n+k-1)</code>.</li><li><code>DoubleFactorial(n)</code> returns <code>n!!</code>.</li><li><code>Catalan(n)</code> returns the <code>n</code>-th Catalan number.</li><li><code>Derangements(n)</code> returns the number of derangements of</li></ul><p>an <code>n</code>-element set.</p><ul><li><code>Binomial(n,k)</code> returns the number of <code>k</code>-element subsets</li></ul><p>of an <code>n</code>-element set.</p><ul><li><code>MultiChoose(n,k)</code> returns the number of <code>k</code>-element</li></ul><p><em>multisets</em> that can be formed using the elements of an <code>n</code>-element set. <strong>Warning</strong>: This is not the same as <code>Multinomial</code>.</p><ul><li><code>Multnomial(vals)</code> returns the multinomial coefficient where</li></ul><p>the top index is the sum of <code>vals</code>. Here, <code>vals</code> may either be a vector of integers or a comma separated list of arguments. In other words, both <code>Multinomial([3,3,3])</code> and <code>Multinomial(3,3,3)</code> return the multinomial coefficient with top index <code>9</code> and bottom indices <code>3,3,3</code>. The result is <code>1680</code>. <strong>Warning</strong>: This is not the same as <code>MultiChoose</code>.</p><ul><li><code>Bell(n)</code> returns the <code>n</code>-th Bell number, i.e., the number</li></ul><p>of partitions of an <code>n</code>-element set.</p><ul><li><code>Stirling1(n,k)</code> returns the <em>signed</em> Stirling number of the</li></ul><p>first kind.</p><ul><li><code>Stirling2(n,k)</code> returns the Stirling number of the second</li></ul><p>kind, i.e., the number of partitions of an <code>n</code>-element set into <code>k</code>-parts (nonempty).</p><ul><li><code>Fibonacci(n)</code> returns the <code>n</code>-th Fibonacci number</li></ul><p>with <code>Fibonacci(0)==0</code> and <code>Fibonacci(1)==1</code>.</p><ul><li><code>IntPartitions(n)</code> returns the number of partitions of the integer <code>n</code></li></ul><p>and <code>IntPartitions(n,k)</code> returns the number of partitions of the integer <code>n</code> with exactly <code>k</code> parts.</p><ul><li><code>IntPartitionsDistinct(n)</code> returns the number of partitions of <code>n</code> into</li></ul><p><em>distinct</em> parts and <code>IntPartitionsDistinct(n,k)</code> returns the number of partitions of <code>n</code> into <code>k</code> <em>distinct</em> parts.</p><ul><li><code>Euler(n)</code> returns the <code>n</code>-th Euler number.</li><li><code>Eulerian(n,k)</code> returns the number of permutations of <code>1:n</code> with <code>k</code></li></ul><p>ascents.</p><ul><li><code>PowerSum(n,k)</code> returns the sum <code>1^k + 2^k + ... + n^k</code>.</li></ul><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>These function have nice recursive properties that we exploit to make the code as simple as possible. In many (but not all) of these functions we cache the result of the calculation to avoid combinatorial explosion in the recursion. In those cases, we don&#39;t compute the same result twice.</p><p>The following functions can be used to manage the saved values.</p><ul><li><code>BigCombinatorics.cache_report()</code> prints out the number of values</li></ul><p>stored in the cache for each function.</p><ul><li><code>BigCombinatorics.cache_clear(func)</code> clears all values stored for</li></ul><p>a specific function.</p><ul><li><code>BigCombinatorics.cache_clear()</code> clears all values in the cache.</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
