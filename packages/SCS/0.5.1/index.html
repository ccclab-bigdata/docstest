<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· SCS.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SCS.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Custom-Installation-1">Custom Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SCS-1" href="#SCS-1">SCS</a></h1><p><a href="https://travis-ci.org/JuliaOpt/SCS.jl"><img src="https://travis-ci.org/JuliaOpt/SCS.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/mlubin/scs-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/yb4yfg4oryw7yten/branch/master?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/r/JuliaOpt/SCS.jl?branch=master"><img src="https://coveralls.io/repos/JuliaOpt/SCS.jl/badge.svg?branch=master" alt="Coverage Status"/></a></p><p><a href="http://pkg.julialang.org/?pkg=SCS&amp;ver=0.5"><img src="http://pkg.julialang.org/badges/SCS_0.5.svg" alt="SCS"/></a> <a href="http://pkg.julialang.org/?pkg=SCS&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/SCS_0.6.svg" alt="SCS"/></a></p><p>Julia wrapper for the <a href="https://github.com/cvxgrp/scs">SCS</a> splitting cone solver. SCS can solve linear programs, second-order cone programs, semidefinite programs, exponential cone programs, and power cone programs.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>You can install SCS.jl through the Julia package manager:</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;SCS&quot;)</code></pre><p>SCS.jl will use <a href="https://github.com/JuliaPackaging/BinaryProvider.jl">BinaryProvider.jl</a> to automatically install the SCS binaries. Note that if you are not using the official Julia binaries from <code>https://julialang.org/downloads/</code> you may need a custom install of the SCS binaries.</p><h2><a class="nav-anchor" id="Custom-Installation-1" href="#Custom-Installation-1">Custom Installation</a></h2><p>To install custom built SCS binaries set the environmental variable <code>JULIA_SCS_LIBRARY_PATH</code> and call <code>Pkg.build(&quot;SCS&quot;)</code>. For instance, if the libraries are installed in <code>/opt/lib</code> just call</p><pre><code class="language-julia">ENV[&quot;JULIA_SCS_LIBRARY_PATH&quot;]=&quot;/opt/lib&quot;
Pkg.build(&quot;SCS&quot;)</code></pre><p>Note that your custom build binaries need to be compiled with the option <code>DLONG=1</code>. For instance, a minimal compilation script would be</p><pre><code class="language-bash">$ cd &lt;scs_dir&gt;
$ make DLONG=1
$ julia
julia&gt; ENV[&quot;JULIA_SCS_LIBRARY_PATH&quot;]=&quot;&lt;scs_dir&gt;/out&quot;
] build SCS</code></pre><p>where <code>&lt;scs_dir&gt;</code> is SCS&#39;s source directory.</p><p>If you do not want BinaryProvider to download the default binaries on install set  <code>JULIA_SCS_LIBRARY_PATH</code>  before calling <code>Pkg.add(&quot;SCS&quot;)</code>.</p><p>To switch back to the default binaries clear <code>JULIA_SCS_LIBRARY_PATH</code> and call <code>Pkg.build(&quot;SCS&quot;)</code>.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><h3><a class="nav-anchor" id="MathProgBase-wrapper-1" href="#MathProgBase-wrapper-1">MathProgBase wrapper</a></h3><p>SCS implements the solver-independent <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a> interface, and so can be used within modeling software like <a href="https://github.com/JuliaOpt/Convex.jl">Convex</a> and <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>. The solver object is called <code>SCSSolver</code>.</p><h3><a class="nav-anchor" id="Options-1" href="#Options-1">Options</a></h3><p>All SCS solver options can be set through the direct interface(documented below) and through MathProgBase. The list of options is defined the <a href="https://github.com/cvxgrp/scs/blob/58e9af926fabc6674a9f488d4e9761a4f0fc451c/include/scs.h#L43"><code>scs.h</code> header</a>. To use these settings you can either pass them as keyword arguments to <code>SCS_solve</code> (high level interface) or as arguments to the <code>SCSSolver</code> constructor (MathProgBase interface), e.g.</p><pre><code class="language-julia"># Direct
solution = SCS_solve(m, n, A, ..., psize; max_iters=10, verbose=0);
# MathProgBase (with Convex)
m = solve!(problem, SCSSolver(max_iters=10, verbose=0))</code></pre><p>Moreover, You may select one of the linear solvers to be used by <code>SCSSolver</code> via <code>linear_solver</code> keyword. The options available are <code>SCS.Indirect</code> (the default) and <code>SCS.Direct</code>.</p><h3><a class="nav-anchor" id="High-level-wrapper-1" href="#High-level-wrapper-1">High level wrapper</a></h3><p>The file <a href="https://github.com/JuliaOpt/SCS.jl/blob/master/src/high_level_wrapper.jl"><code>high_level_wrapper.jl</code></a> is thoroughly commented. Here is the basic usage</p><p>We assume we are solving a problem of the form</p><pre><code class="language-none">minimize        c&#39; * x
subject to      A * x + s = b
                s in K</code></pre><p>where K is a product cone of</p><ul><li>zero cones,</li><li>linear cones <code>{ x | x &gt;= 0 }</code>,</li><li>second-order cones <code>{ (t,x) | ||x||_2 &lt;= t }</code>,</li><li>semi-definite cones <code>{ X | X psd }</code>,</li><li>exponential cones <code>{(x,y,z) | y e^(x/y) &lt;= z, y&gt;0 }</code>, and</li><li>power cone <code>{(x,y,z) | x^a * y^(1-a) &gt;= |z|, x&gt;=0, y&gt;=0}</code>.</li></ul><p>The problem data are</p><ul><li><code>A</code> is the matrix with m rows and n cols</li><li><code>b</code> is of length m x 1</li><li><code>c</code> is of length n x 1</li><li><code>f</code> is the number of primal zero / dual free cones, i.e. primal equality constraints</li><li><code>l</code> is the number of linear cones</li><li><code>q</code> is the array of SOCs sizes</li><li><code>s</code> is the array of SDCs sizes</li><li><code>ep</code> is the number of primal exponential cones</li><li><code>ed</code> is the number of dual exponential cones</li><li><code>p</code> is the array of power cone parameters</li><li><code>options</code> is a dictionary of options (see above).</li></ul><p>The function is</p><pre><code class="language-julia">function SCS_solve(m::Int, n::Int, A::SCSVecOrMatOrSparse, b::Array{Float64,},
    c::Array{Float64,}, f::Int, l::Int, q::Array{Int,}, qsize::Int, s::Array{Int,},
    ssize::Int, ep::Int, ed::Int, p::Array{Float64,}, psize::Int; options...)</code></pre><p>and it returns an object of type Solution, which contains the following fields</p><pre><code class="language-julia">type Solution
  x::Array{Float64, 1}
  y::Array{Float64, 1}
  s::Array{Float64, 1}
  status::ASCIIString
  ret_val::Int
  ...</code></pre><p>Where <code>x</code> stores the optimal value of the primal variable, <code>y</code> stores the optimal value of the dual variable, <code>s</code> is the slack variable, <code>status</code> gives information such as <code>solved</code>, <code>primal infeasible</code>, etc.</p><h3><a class="nav-anchor" id="Low-level-wrapper-1" href="#Low-level-wrapper-1">Low level wrapper</a></h3><p>The low level wrapper directly calls SCS and is also thoroughly documented in <a href="https://github.com/JuliaOpt/SCS.jl/blob/master/src/low_level_wrapper.jl">low<em>level</em>wrapper.jl</a>. The low level wrapper performs the pointer manipulation necessary for the direct C call.</p><h3><a class="nav-anchor" id="Convex-and-JuMP-examples-1" href="#Convex-and-JuMP-examples-1">Convex and JuMP examples</a></h3><p>This example shows how we can model a simple knapsack problem with Convex and use SCS to solve it.</p><pre><code class="language-julia">using Convex, SCS
items  = [:Gold, :Silver, :Bronze]
values = [5.0, 3.0, 1.0]
weights = [2.0, 1.5, 0.3]

# Define a variable of size 3, each index representing an item
x = Variable(3)
p = maximize(x&#39; * values, 0 &lt;= x, x &lt;= 1, x&#39; * weights &lt;= 3)
solve!(p, SCSSolver())
println([items x.value])

# [:Gold 0.9999971880377178
#  :Silver 0.46667637765641057
#  :Bronze 0.9999998036351865]</code></pre><p>This example shows how we can model a simple knapsack problem with JuMP and use SCS to solve it.</p><pre><code class="language-julia">using JuMP, SCS
items  = [:Gold, :Silver, :Bronze]
values = Dict(:Gold =&gt; 5.0,  :Silver =&gt; 3.0,  :Bronze =&gt; 1.0)
weight = Dict(:Gold =&gt; 2.0,  :Silver =&gt; 1.5,  :Bronze =&gt; 0.3)

m = Model(solver=SCSSolver())
@variable(m, 0 &lt;= take[items] &lt;= 1)  # Define a variable for each item
@objective(m, Max, sum( values[item] * take[item] for item in items))
@constraint(m, sum( weight[item] * take[item] for item in items) &lt;= 3)
solve(m)
println(getvalue(take))
# [Bronze] = 0.9999999496295456
# [  Gold] = 0.99999492720597
# [Silver] = 0.4666851698368782</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
