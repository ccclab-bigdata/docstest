<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· RecursiveArrayTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RecursiveArrayTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="RecursiveArrayTools.jl-1" href="#RecursiveArrayTools.jl-1">RecursiveArrayTools.jl</a></h1><p><a href="https://travis-ci.org/JuliaDiffEq/RecursiveArrayTools.jl"><img src="https://travis-ci.org/JuliaDiffEq/RecursiveArrayTools.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/ChrisRackauckas/recursivearraytools-jl-r8tdv"><img src="https://ci.appveyor.com/api/projects/status/i1lp4skr4n6o76b5?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/github/ChrisRackauckas/RecursiveArrayTools.jl?branch=master"><img src="https://coveralls.io/repos/ChrisRackauckas/RecursiveArrayTools.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a> <a href="http://codecov.io/github/ChrisRackauckas/RecursiveArrayTools.jl?branch=master"><img src="http://codecov.io/github/ChrisRackauckas/RecursiveArrayTools.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>RecursiveArrayTools.jl is a set of tools for dealing with recursive arrays like arrays of arrays. The current functionality includes:</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><h4><a class="nav-anchor" id="VectorOfArray-1" href="#VectorOfArray-1">VectorOfArray</a></h4><pre><code class="language-julia">VectorOfArray(u::AbstractVector)</code></pre><p>A <code>VectorOfArray</code> is an array which has the underlying data structure <code>Vector{AbstractArray{T}}</code> (but hopefully concretely typed!). This wrapper over such data structures allows one to lazily act like it&#39;s a higher dimensional vector, and easily convert to different forms. The indexing structure is:</p><pre><code class="language-julia">A[i] # Returns the ith array in the vector of arrays
A[j,i] # Returns the jth component in the ith array
A[j1,...,jN,i] # Returns the (j1,...,jN) component of the ith array</code></pre><p>which presents itself as a column-major matrix with the columns being the arrays from the vector. The <code>AbstractArray</code> interface is implemented, giving access to <code>copy</code>, <code>push</code>, <code>append!</code>, etc. function which act appropriate. Points to note are:</p><ul><li>The length is the number of vectors, or <code>length(A.u)</code> where <code>u</code> is the vector of arrays.</li><li>Iteration follows the linear index and goes over the vectors</li></ul><p>Additionally, the <code>convert(Array,VA::AbstractVectorOfArray)</code> function is provided which transforms the <code>VectorOfArray</code> into a matrix/tensor. Also, <code>vecarr_to_vectors(VA::AbstractVectorOfArray)</code> returns a vector of the series for each component, that is <code>A[i,:]</code> for each <code>i</code>. A plot recipe is provided which plots the <code>A[i,:]</code> series.</p><h4><a class="nav-anchor" id="DiffEqArray-1" href="#DiffEqArray-1">DiffEqArray</a></h4><p>Related to the <code>VectorOfArray</code> is the <code>DiffEqArray</code></p><pre><code class="language-julia">DiffEqArray(u::AbstractVector,t::AbstractVector)</code></pre><p>This is a <code>VectorOfArray</code> which stores <code>A.t</code> which matches <code>A.u</code>. This will plot <code>(A.t[i],A[i,:])</code>. The function <code>tuples(diffeq_arr)</code> returns tuples of <code>(t,u)</code>.</p><h4><a class="nav-anchor" id="ArrayPartition-1" href="#ArrayPartition-1">ArrayPartition</a></h4><pre><code class="language-julia">ArrayPartition(x::AbstractArray...)</code></pre><p>An <code>ArrayPartition</code> <code>A</code> is an array which is made up of different arrays <code>A.x</code>. These index like a single array, but each subarray may have a different type. However, broadcast is overloaded to loop in an efficient manner, meaning that <code>A .+= 2.+B</code> is type-stable in its computations, even if <code>A.x[i]</code> and <code>A.x[j]</code> do not match types. A full array interface is included for completeness, which allows this array type to be used in place of a standard array in places where such a type stable broadcast may be needed. One example is in heterogeneous differential equations for <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>An <code>ArrayPartition</code> acts like a single array. <code>A[i]</code> indexes through the first array, then the second, etc. all linearly. But <code>A.x</code> is where the arrays are stored. Thus for</p><pre><code class="language-julia">using RecursiveArrayTools
A = ArrayPartition(y,z)</code></pre><p>We would have <code>A.x[1]==y</code> and <code>A.x[2]==z</code>. Broadcasting like <code>f.(A)</code> is efficient.</p><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><pre><code class="language-julia">recursivecopy!(b::Array{T,N},a::Array{T,N})</code></pre><p>A recursive <code>copy!</code> function. Acts like a <code>deepcopy!</code> on arrays of arrays, but like <code>copy!</code> on arrays of scalars.</p><pre><code class="language-julia">convert(Array,vecvec)</code></pre><p>Technically just a Base fallback that works well. Takes in a vector of arrays, returns an array of dimension one greater than the original elements. Works on <code>AbstractVectorOfArray</code>. If the <code>vecvec</code> is ragged, i.e. not all of the elements are the same, then it uses the size of the first element to determine the conversion.</p><pre><code class="language-julia">vecvecapply(f::Base.Callable,v)</code></pre><p>Calls <code>f</code> on each element of a vecvec <code>v</code>.</p><pre><code class="language-julia">copyat_or_push!{T}(a::AbstractVector{T},i::Int,x)</code></pre><p>If <code>i&lt;length(x)</code>, it&#39;s simply a <code>recursivecopy!</code> to the <code>i</code>th element. Otherwise it will <code>push!</code> a <code>deepcopy</code>.</p><pre><code class="language-julia">recursive_one(a)</code></pre><p>Calls <code>one</code> on the bottom container to get the &quot;true element one type&quot;</p><pre><code class="language-julia">mean{T&lt;:AbstractArray}(vecvec::Vector{T})
mean{T&lt;:AbstractArray}(matarr::Matrix{T},region=0)</code></pre><p>Generalized mean functions for vectors of arrays and matrix of arrays.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
