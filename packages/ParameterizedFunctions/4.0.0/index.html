<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· ParameterizedFunctions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParameterizedFunctions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#The-Basic-Idea-1">The Basic Idea</a></li><li><a class="toctext" href="#Basic-Usage-1">Basic Usage</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ParameterizedFunctions.jl-1" href="#ParameterizedFunctions.jl-1">ParameterizedFunctions.jl</a></h1><p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby"/></a> <a href="https://travis-ci.org/JuliaDiffEq/ParameterizedFunctions.jl"><img src="https://travis-ci.org/JuliaDiffEq/ParameterizedFunctions.jl.svg?branch=master" alt="Travis"/></a> <a href="https://ci.appveyor.com/project/ChrisRackauckas/parameterizedfunctions-jl"><img src="https://ci.appveyor.com/api/projects/status/k6b7d86ddbas1ajk?svg=true" alt="AppVeyor"/></a> <a href="https://codecov.io/gh/JuliaDiffEq/ParameterizedFunctions.jl"><img src="https://codecov.io/gh/JuliaDiffEq/ParameterizedFunctions.jl/branch/master/graph/badge.svg" alt="codecov"/></a> <a href="http://pkg.julialang.org/?pkg=ParameterizedFunctions"><img src="http://pkg.julialang.org/badges/ParameterizedFunctions_0.5.svg" alt="ParameterizedFunctions"/></a> <a href="http://pkg.julialang.org/?pkg=ParameterizedFunctions"><img src="http://pkg.julialang.org/badges/ParameterizedFunctions_0.6.svg" alt="ParameterizedFunctions"/></a></p><p>ParameterizedFunctions.jl is a component of the JuliaDiffEq ecosystem which allows for parameters to be explicitly present within functions. The interface which ParameterizedFunctions describes allows for functionality which requires parameters, such as parameter sensitivity analysis and parameter estimation, to be added to the differential equation solvers of <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>. While the interface itself is of importance to ecosystem developers, ParameterizedFunctions.jl provides user-facing macros which make a <code>ParameterizedFunction</code> easy to define, and automatically include optimizations like explicit Jacobian functions and explicit inverse Jacobian functions for the differential equation solvers to take advantage of. The result is an easy to use API which allows for more functionality and more performance optimizations than could traditionally be offered.</p><p>test</p><h2><a class="nav-anchor" id="The-Basic-Idea-1" href="#The-Basic-Idea-1">The Basic Idea</a></h2><p><code>ParameterizedFunction</code> is a type which can be used in various JuliaDiffEq solvers where the parameters must be accessible by the solver function. These use call overloading generate a type which acts like a function <code>f(t,u,du)</code> but has access to many more features. For example, a <code>ParameterizedFunction</code> can contain a function for the Jacobian or Inverse Jacobian. If such functions exist, the solvers can use them to increase the speed of computations. If they don&#39;t exist, the solvers will ignore them. Since <code>ParameterizedFunction</code> is a subtype of <code>Function</code>, these can be used anywhere that a function can be used, just with the extra functionality ignored.</p><h2><a class="nav-anchor" id="Basic-Usage-1" href="#Basic-Usage-1">Basic Usage</a></h2><h3><a class="nav-anchor" id="ODE-Macros-1" href="#ODE-Macros-1">ODE Macros</a></h3><p>A helper macro is provided to make it easier to define a <code>ParameterizedFunction</code>, and it will symbolically compute a bunch of extra functions to make the differential equation solvers run faster. For example, to define the previous <code>LotkaVolterra</code>, you can use the following command:</p><pre><code class="language-julia">f = @ode_def LotkaVolterra begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d</code></pre><p>or you can define it anonymously:</p><pre><code class="language-julia">f = @ode_def begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d</code></pre><p>The macro also defines the Jacobian <code>f&#39;</code>. This is defined as an in-place Jacobian <code>f(Val{:jac},t,u,J)</code>. This is calculated using SymEngine.jl automatically, so it&#39;s no effort on your part. The symbolic inverse of the Jacobian is also computed, and an in-place function for this is available as well as <code>f(Val{:invjac},t,u,iJ)</code>. If the Jacobians cannot be computed, a warning is thrown and only the function itself is usable. The functions <code>jac_exists(f)</code> and <code>invjac_exists(f)</code> can be used to see whether the Jacobian and the function for its inverse exist.</p><h4><a class="nav-anchor" id="Extra-Options-1" href="#Extra-Options-1">Extra Options</a></h4><p>In most cases the <code>@ode_def</code> macro should be sufficient. This is because by default the macro will simply calculate each function symbolically, and if it can&#39;t it will simply throw a warning and move on. However, in extreme cases the symbolic calculations may take a long time, in which case it is necessary to turn them off. To do this, use the <code>ode_def_opts</code> function. The <code>@ode_def</code> macro simply defines the specifiable options:</p><pre><code class="language-julia">opts = Dict{Symbol,Bool}(
      :build_tgrad =&gt; true,
      :build_jac =&gt; true,
      :build_expjac =&gt; false,
      :build_invjac =&gt; true,
      :build_invW =&gt; true,
      :build_invW_t =&gt; true,
      :build_hes =&gt; false,
      :build_invhes =&gt; false,
      :build_dpfuncs =&gt; true)</code></pre><p>and calls the function <code>ode_def_opts(name::Symbol,opts,ex::Expr,params)</code>. Note that params is an iterator holding expressions for the parameters.</p><p>In addition, one can also use their own function inside of the macro. For example:</p><pre><code class="language-julia">f(x,y,d) = erf(x*y/d)
NJ = @ode_def FuncTest begin
  dx = a*x - b*x*y
  dy = -c*y + f(x,y,d)
end a b c d</code></pre><p>will do fine. The symbolic derivatives will not work unless you define a derivative for <code>f</code>.</p><h4><a class="nav-anchor" id="Extra-Macros-1" href="#Extra-Macros-1">Extra Macros</a></h4><p>Instead of using <code>ode_def_opts</code> directly, one can use one of the following macros to be more specific about what to not calculate. In increasing order of calculations:</p><pre><code class="language-julia">@ode_def_bare
@ode_def
@ode_def_all</code></pre><h3><a class="nav-anchor" id="Extra-Functions-1" href="#Extra-Functions-1">Extra Functions</a></h3><h4><a class="nav-anchor" id="Jacobian-Function-1" href="#Jacobian-Function-1">Jacobian Function</a></h4><p>The Jacobian overload is provided by overloading in the following manner:</p><pre><code class="language-julia">function (p::LotkaVolterra)(::Type{Val{:jac}},t,u,J)
  J[1,1] = p.a - p.b * u[2]
  J[1,2] = -(p.b) * u[1]
  J[2,1] = 1 * u[2]
  J[2,2] = -3 + u[1]
  nothing
end</code></pre><h4><a class="nav-anchor" id="Inverse-Jacobian-1" href="#Inverse-Jacobian-1">Inverse Jacobian</a></h4><p>The Inverse Jacobian overload is provided by overloading in the following manner:</p><pre><code class="language-julia">function (p::LotkaVolterra)(::Type{Val{:invjac}},t,u,J)
  J[1,1] = (1 - (p.b * u[1] * u[2]) / ((p.a - p.b * u[2]) * (-3 + u[1] + (p.b * u[1] * u[2]) / (p.a - p.b * u[2])))) / (p.a - p.b * u[2])
  J[1,2] = (p.b * u[1]) / ((p.a - p.b * u[2]) * (-3 + u[1] + (p.b * u[1] * u[2]) / (p.a - p.b * u[2])))
  J[2,1] = -(u[2]) / ((p.a - p.b * u[2]) * (-3 + u[1] + (p.b * u[1] * u[2]) / (p.a - p.b * u[2])))
  J[2,2] = (-3 + u[1] + (p.b * u[1] * u[2]) / (p.a - p.b * u[2])) ^ -1
  nothing
end</code></pre><h4><a class="nav-anchor" id="Parameter-Jacobian-1" href="#Parameter-Jacobian-1">Parameter Jacobian</a></h4><p>For solvers which need parameters derivatives, specifying the functions can increase performance. For our example, we allow the solvers to use the explicit derivatives in the parameters by:</p><pre><code class="language-julia">function (p::LotkaVolterra)(::Type{Val{:paramjac}},J,u,p,t)
    J[1, 1] = u[1] * 1
    J[1, 2] = -(u[1]) * u[2]
    J[1, 3] = 0 * 1
    J[1, 4] = 0 * 1
    J[2, 1] = 0 * 1
    J[2, 2] = 0 * 1
    J[2, 3] = -(u[2])
    J[2, 4] = u[1] * u[2]
    nothing
end</code></pre><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
