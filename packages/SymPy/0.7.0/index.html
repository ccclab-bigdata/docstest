<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· SymPy.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SymPy.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#The-PyCall-interface-to-SymPy-1">The <code>PyCall</code> interface to <code>SymPy</code></a></li><li><a class="toctext" href="#Notes-1">Notes</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="http://pkg.julialang.org/?pkg=SymPy&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/SymPy_0.6.svg" alt="SymPy"/></a> </p><p>Linux: <a href="https://travis-ci.org/JuliaPy/SymPy.jl"><img src="https://travis-ci.org/JuliaPy/SymPy.jl.svg?branch=master" alt="Build Status"/></a> &amp;nbsp; Windows: <a href="https://ci.appveyor.com/project/jverzani/sympy-jl"><img src="https://ci.appveyor.com/api/projects/status/github/JuliaPy/SymPy.jl?branch=master&amp;svg=true" alt="Build Status"/></a></p><h1><a class="nav-anchor" id="SymPy-Package-to-bring-Python&#39;s-Sympy-functionality-into-Julia-via-PyCall-1" href="#SymPy-Package-to-bring-Python&#39;s-Sympy-functionality-into-Julia-via-PyCall-1">SymPy Package to bring Python&#39;s <code>Sympy</code> functionality into <code>Julia</code> via <code>PyCall</code></a></h1><p>The <code>SymPy</code> package  (<code>http://sympy.org/</code>)  is a Python library for symbolic mathematics. </p><p>With the excellent <code>PyCall</code> package of <code>julia</code>, one has access to the many features of <code>SymPy</code> from within a <code>Julia</code> session.</p><p>This <code>SymPy</code> package provides a light interface for <em>some</em> of the features of <code>SymPy</code> that makes working with <code>SymPy</code> objects a bit easier.</p><p>The <a href="examples/tutorial.md">tutorial</a> provides an overview. It is viewable as an <code>IJulia</code> notebook <a href="http://nbviewer.ipython.org/github/jverzani/SymPy.jl/blob/master/examples/tutorial.ipynb">here</a>.</p><h3><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h3><p>To use this package, both <code>Python</code> and its <code>SymPy</code> library must be installed on your system. If <code>PyCall</code> is installed using <code>Conda</code> (which is the default if no system <code>python</code> is found), then the underlying <code>SymPy</code> library will be installed via <code>Conda</code> when the package is first loaded. Otherwise, installing both <code>Python</code> and <code>SymPy</code> (which also requires <code>mpmath</code>) can be done by other means. In this case, the <code>Anaconda</code> distribution is suggested, as it provides a single installation of <code>Python</code> that includes <code>SymPy</code> and many other scientifice libraries that can be profitably accessed within <code>Julia</code> via <code>PyCall</code>. (Otherwise, install <code>Python</code> then download the <code>sympy</code> library from https://github.com/sympy/sympy/releases and install.)</p><h2><a class="nav-anchor" id="The-PyCall-interface-to-SymPy-1" href="#The-PyCall-interface-to-SymPy-1">The <code>PyCall</code> interface to <code>SymPy</code></a></h2><p>The only point to this package is that using <code>PyCall</code> to access <code>SymPy</code> is somewhat cumbersome. The following is how one would define a symbolic value <code>x</code>, take its sine, then evaluate at <code>pi</code>, say:</p><pre><code class="language-none">using PyCall			
@pyimport sympy
x = sympy.Symbol(&quot;x&quot;)
y = sympy.sin(x)
y[:subs](x, sympy.pi) |&gt; float</code></pre><p>The <code>Symbol</code> and <code>sin</code> function of <code>SymPy</code> are found within the imported <code>sympy</code> object. They may be referenced with <code>Python</code>&#39;s dot notation. However, the <code>subs</code> method of the <code>y</code> object is accessed differently, using indexing notation with a symbol. The call above substitutes a value of <code>sympy.pi</code> for <code>x</code>. This leaves the object as a <code>PyObject</code> storing a number which can be brought back into <code>julia</code> through conversion, in this case with the <code>float</code> function.</p><p>The above isn&#39;t so awkward, but even more cumbersome is the similarly simple task of finding <code>sin(pi*x)</code>.  As this multiplication is done at the python level and is not a method of <code>sympy</code> or the <code>x</code> object, we need to evaluate python code. Here is one solution:</p><pre><code class="language-none">x = sympy.Symbol(&quot;x&quot;)
y = pycall(sympy.Mul, PyAny, sympy.pi, x)
z = sympy.sin(y)		
z[:subs](x, 1) |&gt; float</code></pre><p>This gets replaced by a more <code>julia</code>n syntax:</p><pre><code class="language-none">using SymPy                    
x = symbols(&quot;x&quot;)		       # or   @vars x, Sym(&quot;x&quot;), or  Sym(:x)
y = sin(pi*x)
y(1)                           # Does subs(y, x, 1). Use y(x=&gt;1) to be specific as to which symbol to substitute</code></pre><p>The object <code>x</code> we create is of type <code>Sym</code>, a simple proxy for the underlying <code>PyObject</code>. We then overload the familiar math functions so that working with symbolic expressions can use natural <code>julia</code> idioms. The final result  here is a symbolic value of <code>0</code>, which prints as <code>0</code> and not <code>PyObject 0</code>. To convert it into a numeric value within <code>Julia</code>, the <code>N</code> function may be used, which acts like the <code>float</code> call, only there is an attempt to preserve the variable type.</p><p>(There is a subtlety, the value of <code>pi</code> here (an <code>Irrational</code> in <code>Julia</code>) is converted to the symbolic <code>PI</code>, but in general won&#39;t be if the math constant is coerced to a floating point value before it encounters a symbolic object. It is better to just use the symbolic value <code>PI</code>, an alias for <code>sympy.pi</code> used above. A similar comment applies for <code>e</code>, where <code>E</code> should be used.)</p><p>However, for some tasks the <code>PyCall</code> interface is still needed, as only a portion of the <code>SymPy</code> interface is exposed. To call an underlying SymPy method, the <code>getindex</code> method is overloaded for <code>symbol</code> indices so that <code>ex[:meth_name](...)</code> dispatches to either to SymPy&#39;s <code>ex.meth_name(...)</code> or <code>meth_name(ex, ...)</code>, as possible.</p><p>There is a <code>sympy</code> string macro to simplify this a bit, with the call looking like: <code>sympy&quot;meth_name&quot;(...)</code>, for example <code>sympy&quot;harmonic&quot;(10)</code>. For example, the above could also be done through:</p><pre><code class="language-none">@vars x
y = sympy&quot;sin&quot;(pi * x)
y(1)</code></pre><p>As calling the underlying SymPy function is not difficult, the interface exposed through overloading <code>Julia</code>&#39;s methods attempts to keep similar functionality to the familiar <code>Julia</code> method when there is a discrepancy between conventions.</p><h2><a class="nav-anchor" id="Notes-1" href="#Notes-1">Notes</a></h2><p>Some aspects of <code>SymPy</code> require more modern versions of <code>sympy</code> to be installed. For example, the matrix functions rely on features of <code>sympy</code> that are not exposed in the <code>sympy</code> installed with Ubuntu LTS 12.04.</p><p>In that particular instance, calls such as</p><pre><code class="language-none">x = symbols(&quot;x&quot;)
a = [x 1; 1 x]
det(a)</code></pre><p>Can be replaced with</p><pre><code class="language-none">sympy&quot;det&quot;(a)</code></pre><p>Similarly for <code>trace</code>, <code>eigenvects</code>, ... . Note these are <code>sympy</code> methods, not <code>Julia</code> methods that have been ported. (Hence, <code>eigenvects</code> and not <code>eigvecs</code>.)</p><footer><hr/></footer></article></body></html>
