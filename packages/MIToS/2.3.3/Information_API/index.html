<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIToS</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Example/">Example</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../MSA/">MSA</a></li><li><a class="toctext" href="../Information/">Information</a></li><li><a class="toctext" href="../SIFTS/">SIFTS</a></li><li><a class="toctext" href="../PDB/">PDB</a></li><li><a class="toctext" href="../Pfam/">Pfam</a></li></ul></li><li><a class="toctext" href="../Scripts/">Scripts</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../MSA_API/">MSA</a></li><li class="current"><a class="toctext" href>Information</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Constants-1">Constants</a></li><li><a class="toctext" href="#Macros-1">Macros</a></li><li><a class="toctext" href="#Methods-and-functions-1">Methods and functions</a></li></ul></li><li><a class="toctext" href="../SIFTS_API/">SIFTS</a></li><li><a class="toctext" href="../PDB_API/">PDB</a></li><li><a class="toctext" href="../Pfam_API/">Pfam</a></li><li><a class="toctext" href="../Utils_API/">Utils</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Information</a></li></ul></nav><hr/><div id="topbar"><span>Information</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Information-1" href="#Information-1">Information</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information" href="#MIToS.Information"><code>MIToS.Information</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The <code>Information</code> module of MIToS defines types and functions useful to calculate information measures (e.g. <em>Mutual Information</em> (MI) and <em>Entropy</em>) over a Multiple Sequence Alignment (MSA). This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from this counts. Also, includes methods for applying corrections to that tables, e.g. pseudocounts and pseudo frequencies. Finally, <code>Information</code> allows to use this probabilities and counts to estimate information measures and other frequency based values.</p><p><strong>Features</strong></p><ul><li>Estimate multi dimensional frequencies and probabilities tables from sequences, MSAs, etc...</li><li>Correction for small number of observations</li><li>Correction for data redundancy on a MSA</li><li>Estimate information measures</li><li>Calculate corrected mutual information between residues</li></ul><pre><code class="language-julia">using MIToS.Information</code></pre></div></div></section><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Information-1">Information</a></li><ul><li><a href="#Contents-1">Contents</a></li><li><a href="#Types-1">Types</a></li><li><a href="#Constants-1">Constants</a></li><li><a href="#Macros-1">Macros</a></li><li><a href="#Methods-and-functions-1">Methods and functions</a></li></ul></ul><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.AdditiveSmoothing" href="#MIToS.Information.AdditiveSmoothing"><code>MIToS.Information.AdditiveSmoothing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Additive Smoothing</strong> or fixed pseudocount <code>λ</code> for <code>ResidueCount</code> (in order to estimate probabilities when the number of samples is low).</p><p>Common values of <code>λ</code> are:</p><ul><li><code>0</code> : No cell frequency prior, gives you the maximum likelihood estimator.</li><li><code>0.05</code> is the optimum value for <code>λ</code> found in Buslje et. al. 2009, similar results was obtained for <code>λ</code> in the range [0.025, 0.075].</li><li><code>1 / p</code> : Perks prior (Perks, 1947) where <code>p</code> the number of parameters (i.e. residues, pairs of residues) to estimate. If <code>p</code> is the number of residues (<code>20</code> without counting gaps), this gives you <code>0.05</code>.</li><li><code>sqrt(n) / p</code> : Minimax prior (Trybula, 1958) where <code>n</code> is the number of samples and <code>p</code> the number of parameters to estimate. If the number of samples <code>n</code> is 400 (minimum number of sequence clusters for achieve good performance in Buslje et. al. 2009) for estimating 400 parameters (pairs of residues without counting gaps) this gives you <code>0.05</code>.</li><li><code>0.5</code> : Jeffreys prior (Jeffreys, 1946).</li><li><code>1</code> : Bayes-Laplace uniform prior, aka. Laplace smoothing.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLOSUM_Pseudofrequencies" href="#MIToS.Information.BLOSUM_Pseudofrequencies"><code>MIToS.Information.BLOSUM_Pseudofrequencies</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>BLOSUM_Pseudofrequencies</code> type. It takes to arguments/fields:</p><ul><li><code>α</code> : Usually the number of sequences or sequence clusters in the MSA.</li><li><code>β</code> : The weight of the pseudofrequencies, a value close to 8.512 when <code>α</code> is the number of sequence clusters.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.ContingencyTable" href="#MIToS.Information.ContingencyTable"><code>MIToS.Information.ContingencyTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ContingencyTable</code> is a multidimensional array. It stores the contingency matrix, its marginal values and total. The type also has an internal and private temporal array and an alphabet object. It&#39;s a parametric type, taking three ordered parameters:</p><ul><li><code>T</code> : The element type of the multidimensional array.</li><li><code>N</code> : It&#39;s the dimension of the array and should be an <code>Int</code>.</li><li><code>A</code> : This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>,</li></ul><p><code>GappedAlphabet</code> or <code>ReducedAlphabet</code>.</p><p>A <code>ContingencyTable</code> can be created from an alphabet if all the parameters are given. Otherwise, you need to give a type, a number (<code>Val</code>) and an alphabet. You can also create a <code>ContingencyTable</code> using a matrix and a alphabet. For example:</p><pre><code class="language-julia">ContingencyTable{Float64, 2, UngappedAlphabet}(UngappedAlphabet())
ContingencyTable(Float64, Val{2}, UngappedAlphabet())
ContingencyTable(zeros(Float64,20,20), UngappedAlphabet())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.Counts" href="#MIToS.Information.Counts"><code>MIToS.Information.Counts</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Counts</code> object wraps a <code>ContingencyTable</code> storing counts/frequencies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.NoPseudocount" href="#MIToS.Information.NoPseudocount"><code>MIToS.Information.NoPseudocount</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>You can use <code>NoPseudocount()</code> to avoid pseudocount corrections where a <code>Pseudocount</code> type is needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.NoPseudofrequencies" href="#MIToS.Information.NoPseudofrequencies"><code>MIToS.Information.NoPseudofrequencies</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>You can use <code>NoPseudofrequencies()</code> to avoid pseudocount corrections where a <code>Pseudofrequencies</code> type is needed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.Probabilities" href="#MIToS.Information.Probabilities"><code>MIToS.Information.Probabilities</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Probabilities</code> object wraps a <code>ContingencyTable</code> storing probabilities. It doesn&#39;t perform any check. If the total isn&#39;t one, you must use <code>normalize</code> or <code>normalize!</code>on the <code>ContingencyTable</code> before wrapping it to make the sum of the probabilities equal to one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.Pseudocount" href="#MIToS.Information.Pseudocount"><code>MIToS.Information.Pseudocount</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parametric abstract type to define pseudocount types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.Pseudofrequencies" href="#MIToS.Information.Pseudofrequencies"><code>MIToS.Information.Pseudofrequencies</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parametric abstract type to define pseudofrequencies types</p></div></div></section><h2><a class="nav-anchor" id="Constants-1" href="#Constants-1">Constants</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLOSUM62_Pi" href="#MIToS.Information.BLOSUM62_Pi"><code>MIToS.Information.BLOSUM62_Pi</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>BLOSUM62 probabilities <em>P(aa)</em> for each residue on the <code>UngappedAlphabet</code>. SUM:  0.9987</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLOSUM62_Pij" href="#MIToS.Information.BLOSUM62_Pij"><code>MIToS.Information.BLOSUM62_Pij</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Table with conditional probabilities of residues based on BLOSUM62. The normalization is done row based. The firts row contains the <em>P(aa|A)</em> and so one.</p></div></div></section><h2><a class="nav-anchor" id="Macros-1" href="#Macros-1">Macros</a></h2><h2><a class="nav-anchor" id="Methods-and-functions-1" href="#Methods-and-functions-1">Methods and functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.count-Union{Tuple{Vararg{AbstractArray{Residue,1},N}}, Tuple{N}} where N" href="#Base.count-Union{Tuple{Vararg{AbstractArray{Residue,1},N}}, Tuple{N}} where N"><code>Base.count</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It returns a <code>ContingencyTable</code> wrapped in a <code>Counts</code> type with the frequencies of residues in the sequences that takes as arguments. The dimension of the table is equal to the number of sequences. You can use the keyword arguments <code>alphabet</code>, <code>weights</code> and <code>pseudocounts</code> to indicate the alphabet of the table (default to <code>UngappedAlphabet()</code>), a clustering result (default to <code>NoClustering()</code>) and the pseudocounts (default to <code>NoPseudocount()</code>) to be used during the estimation of the frequencies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize!-Union{Tuple{ContingencyTable{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T" href="#LinearAlgebra.normalize!-Union{Tuple{ContingencyTable{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>normalize!</code> makes the sum of the frequencies to be one, in place.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize-Union{Tuple{ContingencyTable{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T" href="#LinearAlgebra.normalize-Union{Tuple{ContingencyTable{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>normalize</code> returns another table where the sum of the frequencies is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.APC!-Union{Tuple{Array{T,2}}, Tuple{T}} where T" href="#MIToS.Information.APC!-Union{Tuple{Array{T,2}}, Tuple{T}} where T"><code>MIToS.Information.APC!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>APC (Dunn et. al. 2008)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLMI-Tuple{AbstractArray{MIToS.MSA.Residue,2}}" href="#MIToS.Information.BLMI-Tuple{AbstractArray{MIToS.MSA.Residue,2}}"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>BLMI</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.apply_pseudocount!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},T}} where A where N where T" href="#MIToS.Information.apply_pseudocount!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},T}} where A where N where T"><code>MIToS.Information.apply_pseudocount!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It adds the <code>pseudocount</code> value to the table cells.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.apply_pseudofrequencies!-Union{Tuple{T}, Tuple{ContingencyTable{T,2,UngappedAlphabet},BLOSUM_Pseudofrequencies}} where T" href="#MIToS.Information.apply_pseudofrequencies!-Union{Tuple{T}, Tuple{ContingencyTable{T,2,UngappedAlphabet},BLOSUM_Pseudofrequencies}} where T"><code>MIToS.Information.apply_pseudofrequencies!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>apply_pseudofrequencies!{T}(Pab::ContingencyTable{T,2,UngappedAlphabet}, pseudofrequencies::BLOSUM_Pseudofrequencies)</code></p><p>When a <code>BLOSUM_Pseudofrequencies(α,β)</code> is used, this function applies pseudofrequencies <code>Gab</code> over <code>Pab</code>, as a weighted mean of both. It uses the conditional probability matrix <code>BLOSUM62_Pij</code> and the real frequencies/probabilities <code>Pab</code> to estimate the pseudofrequencies <code>Gab</code>. α is the weight of the real frequencies <code>Pab</code> and β the weight of the pseudofrequencies.</p><p><code>Gab = Σcd  Pcd ⋅ BLOSUM62( a | c ) ⋅ BLOSUM62( b | d )</code> <code>Pab = (α ⋅ Pab + β ⋅ Gab )/(α + β)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.buslje09-Tuple{AbstractArray{MIToS.MSA.Residue,2}}" href="#MIToS.Information.buslje09-Tuple{AbstractArray{MIToS.MSA.Residue,2}}"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>buslje09</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score
  - MI or MIp</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.count!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Any,Pseudocount,Vararg{AbstractArray{Residue,1},N}}} where A where N where T" href="#MIToS.Information.count!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Any,Pseudocount,Vararg{AbstractArray{Residue,1},N}}} where A where N where T"><code>MIToS.Information.count!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It populates a <code>ContingencyTable</code> (first argument) using the frequencies in the sequences (last positional arguments). The dimension of the table must match the number of sequences and all the sequences must have the same length. You must indicate the used weights and pseudocounts as second and third positional arguments respectively. You can use <code>NoPseudofrequencies()</code> and <code>NoClustering()</code> to avoid the use of sequence weighting and pseudocounts, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.cumulative-Union{Tuple{VT}, Tuple{D}, Tuple{T}, Tuple{PairwiseListMatrix{T,D,VT},T}} where VT where D where T" href="#MIToS.Information.cumulative-Union{Tuple{VT}, Tuple{D}, Tuple{T}, Tuple{PairwiseListMatrix{T,D,VT},T}} where VT where D where T"><code>MIToS.Information.cumulative</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>cumulative</code> allows to calculate cumulative scores (i.e. cMI) as defined in Buslje et. al. 2010</p><p><em>&quot;We calculated a cumulative mutual information score (cMI) for each residue as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network.&quot;</em> Buslje, Cristina Marino, Elin Teppa, Tomas Di Doménico, José María Delfino, and Morten Nielsen. <em>Networks of high mutual information define the structural proximity of catalytic sites: implications for catalytic residue identification.</em> PLoS Comput Biol 6, no. 11 (2010): e1000978.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.delete_dimensions!-Union{Tuple{A}, Tuple{S}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,S,A},ContingencyTable{T,N,A},Vararg{Int64,N} where N}} where A where S where N where T" href="#MIToS.Information.delete_dimensions!-Union{Tuple{A}, Tuple{S}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,S,A},ContingencyTable{T,N,A},Vararg{Int64,N} where N}} where A where S where N where T"><code>MIToS.Information.delete_dimensions!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>delete_dimensions!(out::ContingencyTable, in::ContingencyTable, dimensions::Int...)</code></p><p>This function fills a ContingencyTable with the counts/probabilities on <code>in</code> after the deletion of <code>dimensions</code>. i.e. This is useful for getting Pxy from Pxyz.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.delete_dimensions-Union{Tuple{I}, Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Vararg{Int64,I}}} where I where A where N where T" href="#MIToS.Information.delete_dimensions-Union{Tuple{I}, Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Vararg{Int64,I}}} where I where A where N where T"><code>MIToS.Information.delete_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>delete_dimensions(in::ContingencyTable, dimensions::Int...)</code></p><p>This function creates a ContingencyTable with the counts/probabilities on <code>in</code> after the deletion of <code>dimensions</code>. i.e. This is useful for getting Pxy from Pxyz.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gap_intersection_percentage-Union{Tuple{Counts{T,2,GappedAlphabet}}, Tuple{T}} where T" href="#MIToS.Information.gap_intersection_percentage-Union{Tuple{Counts{T,2,GappedAlphabet}}, Tuple{T}} where T"><code>MIToS.Information.gap_intersection_percentage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates the gap intersection as percentage from a table of <code>Counts</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gap_union_percentage-Union{Tuple{Counts{T,2,GappedAlphabet}}, Tuple{T}} where T" href="#MIToS.Information.gap_union_percentage-Union{Tuple{Counts{T,2,GappedAlphabet}}, Tuple{T}} where T"><code>MIToS.Information.gap_union_percentage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates the gap union as percentage from a table of <code>Counts</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gaussdca-Tuple{Any}" href="#MIToS.Information.gaussdca-Tuple{Any}"><code>MIToS.Information.gaussdca</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Wrapper function to <code>GaussDCA.gDCA</code>. You need to install GaussDCA:</p><pre><code class="language-julia">using Pkg
Pkg.add(PackageSpec(url=&quot;https://github.com/carlobaldassi/GaussDCA.jl&quot;))</code></pre><p>Look into <a href="https://github.com/carlobaldassi/GaussDCA.jl">GaussDCA.jl README</a> for further information. If you use this wrapper, <strong>please cite the GaussDCA publication and the package&#39;s doi</strong>.</p><p>It&#39;s possible to indicate the path to the julia binary where GaussDCA is installed. However, it&#39;s recommended to use the same version where MIToS is installed. That is because this function use <code>serialize</code>/<code>deserialize</code> to transfer data between the processes.</p><p><strong>GaussDCA Publication:</strong> Baldassi, Carlo, Marco Zamparo, Christoph Feinauer, Andrea Procaccini, Riccardo Zecchina, Martin Weigt, and Andrea Pagnani. &quot;Fast and accurate multivariate Gaussian modeling of protein families: predicting residue contacts and protein-interaction partners.&quot; PloS one 9, no. 3 (2014): e92721.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.getalphabet-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.getalphabet-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.getalphabet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>getalphabet</code> allows to access the stored alphabet object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.getcontingencytable-Union{Tuple{Probabilities{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T" href="#MIToS.Information.getcontingencytable-Union{Tuple{Probabilities{T,N,A}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T"><code>MIToS.Information.getcontingencytable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>getcontingencytable</code> allows to access the wrapped <code>ContingencyTable</code> in a <code>Probabilities</code> or <code>Counts</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.getmarginals-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.getmarginals-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.getmarginals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>getmarginals</code> allows to access the array with the marginal values (<code>NamedArray</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.getmarginalsarray-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.getmarginalsarray-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.getmarginalsarray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>getmarginalsarray</code> allows to access the array with the marginal values (<code>Array</code> without names).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gettable-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.gettable-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.gettable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>gettable</code> allows to access the table (<code>NamedArray</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gettablearray-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.gettablearray-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.gettablearray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>gettablearray</code> allows to access the table (<code>Array</code> without names).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.gettotal-Tuple{MIToS.Information.ContingencyTable}" href="#MIToS.Information.gettotal-Tuple{MIToS.Information.ContingencyTable}"><code>MIToS.Information.gettotal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>gettotal</code> allows to access the stored total value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.kullback_leibler-Union{Tuple{A}, Tuple{T}, Tuple{Probabilities{T,1,A},Any,Real}} where A where T" href="#MIToS.Information.kullback_leibler-Union{Tuple{A}, Tuple{T}, Tuple{Probabilities{T,1,A},Any,Real}} where A where T"><code>MIToS.Information.kullback_leibler</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates the Kullback-Leibler (KL) divergence from a table of <code>Probabilities</code>. The second positional argument is a <code>Probabilities</code> or <code>ContingencyTable</code> with the background distribution. It&#39;s optional, the default is the <code>BLOSUM62_Pi</code> table. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.mapcolfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,1,A}, Probabilities{T,1,A}}}} where A where T" href="#MIToS.Information.mapcolfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,1,A}, Probabilities{T,1,A}}}} where A where T"><code>MIToS.Information.mapcolfreq!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It efficiently map a function (first argument) that takes a table of <code>Counts</code> or <code>Probabilities</code> (third argument). The table is filled in place with the counts or probabilities of each column from the <code>msa</code> (second argument).</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>): Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>): <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>): <code>Pseudofrequencies</code> to be applied to the normalized (probabilities) table.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.mapcolpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}}}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}},Type{Val{D}}}} where D where A where T" href="#MIToS.Information.mapcolpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}}}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}},Type{Val{D}}}} where D where A where T"><code>MIToS.Information.mapcolpairfreq!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It efficiently map a function (first argument) that takes a table of <code>Counts</code> or <code>Probabilities</code> (third argument). The table is filled in place with the counts or probabilities of each pair of columns from the <code>msa</code> (second argument). The fourth positional argument <code>usediagonal</code> indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>).</p><ul><li><p><code>weights</code> (default: <code>NoClustering()</code>): Weights to be used for table counting.</p></li><li><p><code>pseudocounts</code> (default: <code>NoPseudocount()</code>): <code>Pseudocount</code> object to be applied to table.</p></li><li><p><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>): <code>Pseudofrequencies</code> to be applied to the normalized (probabilities) table.</p></li><li><p><code>diagonalvalue</code> (default: <code>0</code>): Value to fill diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.mapseqfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,1,A}, Probabilities{T,1,A}}}} where A where T" href="#MIToS.Information.mapseqfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,1,A}, Probabilities{T,1,A}}}} where A where T"><code>MIToS.Information.mapseqfreq!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It efficiently map a function (first argument) that takes a table of <code>Counts</code> or <code>Probabilities</code> (third argument). The table is filled in place with the counts or probabilities of each sequence from the <code>msa</code> (second argument).</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>): Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>): <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>): <code>Pseudofrequencies</code> to be applied to the normalized (probabilities) table.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.mapseqpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}}}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}},Type{Val{D}}}} where D where A where T" href="#MIToS.Information.mapseqpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}}}, Tuple{Function,AbstractArray{Residue,2},Union{Counts{T,2,A}, Probabilities{T,2,A}},Type{Val{D}}}} where D where A where T"><code>MIToS.Information.mapseqpairfreq!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It efficiently map a function (first argument) that takes a table of <code>Counts</code> or <code>Probabilities</code> (third argument). The table is filled in place with the counts or probabilities of each pair of sequences from the <code>msa</code> (second argument). The fourth positional argument <code>usediagonal</code> indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>).</p><ul><li><p><code>weights</code> (default: <code>NoClustering()</code>): Weights to be used for table counting.</p></li><li><p><code>pseudocounts</code> (default: <code>NoPseudocount()</code>): <code>Pseudocount</code> object to be applied to table.</p></li><li><p><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>): <code>Pseudofrequencies</code> to be applied to the normalized (probabilities) table.</p></li><li><p><code>diagonalvalue</code> (default: <code>0</code>): Value to fill diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.marginal_entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Int64,Real}} where A where N where T" href="#MIToS.Information.marginal_entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Int64,Real}} where A where N where T"><code>MIToS.Information.marginal_entropy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates marginal entropy (H) from a table of <code>Counts</code> or <code>Probabilities</code>. The second positional argument is used to indicate the magin used to calculate the entropy, e.g. it estimates the entropy H(X) if marginal is 1, H(Y) for 2, etc. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.mutual_information-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Real}} where A where N where T" href="#MIToS.Information.mutual_information-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Real}} where A where N where T"><code>MIToS.Information.mutual_information</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates Mutual Information (MI) from a table of <code>Counts</code> or <code>Probabilities</code>. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits. Calculation of MI from <code>Counts</code> is faster than from <code>Probabilities</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.normalized_mutual_information-Union{Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T" href="#MIToS.Information.normalized_mutual_information-Union{Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}}}, Tuple{A}, Tuple{N}, Tuple{T}} where A where N where T"><code>MIToS.Information.normalized_mutual_information</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates a Normalized Mutual Information (nMI) by Entropy from a table of <code>Counts</code> or <code>Probabilities</code>.</p><p><code>nMI(X, Y) = MI(X, Y) / H(X, Y)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.pairwisegapfraction-Tuple{AbstractArray{MIToS.MSA.Residue,2}}" href="#MIToS.Information.pairwisegapfraction-Tuple{AbstractArray{MIToS.MSA.Residue,2}}"><code>MIToS.Information.pairwisegapfraction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates the percentage of gaps on columns pairs (union and intersection) using sequence clustering (Hobohm I).</p><p>Argument, type, default value and descriptions:</p><pre><code class="language-none">    - clustering  Bool      true    Sequence clustering (Hobohm I)
    - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)</code></pre><p>This function returns:</p><pre><code class="language-none">    - pairwise gap union as percentage
    - pairwise gap intersection as percentage</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.probabilities!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Any,Pseudocount,Pseudofrequencies,Vararg{AbstractArray{Residue,1},N}}} where A where N where T" href="#MIToS.Information.probabilities!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{ContingencyTable{T,N,A},Any,Pseudocount,Pseudofrequencies,Vararg{AbstractArray{Residue,1},N}}} where A where N where T"><code>MIToS.Information.probabilities!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It populates a <code>ContingencyTable</code> (first argument) using the probabilities in the sequences (last positional arguments). The dimension of the table must match the number of sequences and all the sequences must have the same length. You must indicate the used weights, pseudocounts and pseudofrequencies as second, third and fourth positional arguments respectively. You can use <code>NoClustering()</code>, <code>NoPseudocount()</code> and <code>NoPseudofrequencies()</code> to avoid the use of sequence weighting, pseudocounts and pseudofrequencies, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.probabilities-Union{Tuple{Vararg{AbstractArray{Residue,1},N}}, Tuple{N}} where N" href="#MIToS.Information.probabilities-Union{Tuple{Vararg{AbstractArray{Residue,1},N}}, Tuple{N}} where N"><code>MIToS.Information.probabilities</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It returns a <code>ContingencyTable</code> wrapped in a <code>Probabilities</code> type with the frequencies of residues in the sequences that takes as arguments. The dimension of the table is equal to the number of sequences. You can use the keyword arguments <code>alphabet</code>, <code>weights</code>, <code>pseudocounts</code> and <code>pseudofrequencies</code> to indicate the alphabet of the table (default to <code>UngappedAlphabet()</code>), a clustering result (default to <code>NoClustering()</code>),  the pseudocounts (default to <code>NoPseudocount()</code>) and the pseudofrequencies (default to <code>NoPseudofrequencies()</code>) to be used during the estimation of the probabilities.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Real}} where A where N where T" href="#StatsBase.entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{Counts{T,N,A}, Probabilities{T,N,A}},Real}} where A where N where T"><code>StatsBase.entropy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>It calculates the Shannon entropy (H) from a table of <code>Counts</code> or <code>Probabilities</code>. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.</p></div></div></section><footer><hr/><a class="previous" href="../MSA_API/"><span class="direction">Previous</span><span class="title">MSA</span></a><a class="next" href="../SIFTS_API/"><span class="direction">Next</span><span class="title">SIFTS</span></a></footer></article></body></html>
