<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· IteratorInterfaceExtensions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IteratorInterfaceExtensions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="IteratorInterfaceExtensions-1" href="#IteratorInterfaceExtensions-1">IteratorInterfaceExtensions</a></h1><p><a href="http://www.repostatus.org/#active"><img src="http://www.repostatus.org/badges/latest/active.svg" alt="Project Status: Active - The project has reached a stable, usable state and is being actively developed."/></a> <a href="https://travis-ci.org/queryverse/IteratorInterfaceExtensions.jl"><img src="https://travis-ci.org/queryverse/IteratorInterfaceExtensions.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/queryverse/iteratorinterfaceextensions-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/4rq8seb3j1wd7wpp/branch/master?svg=true" alt="Build status"/></a> <a href="http://pkg.julialang.org/?pkg=IteratorInterfaceExtensions"><img src="http://pkg.julialang.org/badges/IteratorInterfaceExtensions_0.6.svg" alt="IteratorInterfaceExtensions"/></a> <a href="http://codecov.io/github/queryverse/IteratorInterfaceExtensions.jl?branch=master"><img src="http://codecov.io/github/queryverse/IteratorInterfaceExtensions.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>IteratorInterfaceExtensions defines a small number of extensions to the iterator interface.</p><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>This package adds a couple of extensions to the standard [iterator interface] https://docs.julialang.org/en/latest/manual/interfaces/#man-interface-iteration-1) in julia.</p><h3><a class="nav-anchor" id="isiterable-and-getiterator-1" href="#isiterable-and-getiterator-1"><span>$isiterable$</span> and <span>$getiterator$</span></a></h3><p>The first extension is comprised of the functions <span>$isiterable$</span> and <span>$getiterator$</span>. <span>$isiterable(x)$</span> will return <span>$true$</span> or <span>$false$</span>, indicating whether <span>$x$</span> can be iterated. It is important to note that a <span>$true$</span> return value does <em>not</em> indicate that one can call the <span>$iterate$</span> method on <span>$x$</span>, instead a consumer <em>must</em> call <span>$getiterator(x)$</span> if <span>$isiterable(x)$</span> returned <span>$true$</span>, and can then call <span>$iterate$</span> on the instance that is returned by <span>$getiterator$</span>. The proper pattern for consumer code therefore looks like this:</p><pre><code class="language-julia">if isiterable(x)
    it = getiterator(x)
    for i in it
        # Custom code
    end
end</code></pre><p>This consumer pattern will work with iterators that don&#39;t opt into the extensions in this package and with iterators that have opted into the extended interface defined in this package.</p><p>There are two scenarios when a source might participate in this extended iterator interface.</p><p>The first scenario is one where a source could not implement a type-stable version of <span>$iterate$</span> because the primary source type lacks the necessary type information. Such a source can add a method to <span>$getiterator$</span> that returns an instance of a different type with enough type information for a type stable implementation of the core iterator interface that iterates the elements of the original source.</p><p>Second, sometimes such a source might not want to implement the <span>$iterate$</span> method at all for its core type. If that is the case, this source can add a method to <span>$isiterable$</span> that returns <span>$true$</span>, even though the source does not have a <span>$iterate$</span> method. As long as this source still implements the <span>$getiterator$</span> function, it still complies with the extended iterator contract defined in this package.</p><h3><a class="nav-anchor" id="IteratorSize2-1" href="#IteratorSize2-1"><span>$IteratorSize2$</span></a></h3><p><span>$IteratorSize2$</span> extends <span>$Base.IteratorSize$</span> with an additional return value, namely <span>$HasLengthAfterStart()$</span>. An iterator consumer that can provide an optimized implementation for iterators that know their length after the first call to the <span>$iterate$</span> method has, can call <span>$IteratorSize2$</span> instead of <span>$Base.IteratorSize$</span>. The return value will either be one of the possible return values of <span>$Base.IteratorSize$</span>, or <span>$HasLengthAfterStart()$</span>. If the return value is <span>$HasLengthAfterStart()$</span>, the consumer can call <span>$length(x, state)$</span> to obtain the number of elements the iterator will return. Here <span>$x$</span> is the same value that <span>$iterate$</span> was called on, and <span>$state$</span> is the value returned by <span>$iterate(x)$</span>.</p><p>An iterator that implements <span>$IteratorSize2(x::MyType) = HasLengthAfterStart()$</span> must also implement <span>$Base.IteratorSize(x::MyType) = Base.SizeUnknown()$</span>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
