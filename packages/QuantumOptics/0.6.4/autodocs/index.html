<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · QuantumOptics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>QuantumOptics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.@samebases" href="#QuantumOptics.bases.@samebases"><code>QuantumOptics.bases.@samebases</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@samebases</code></pre><p>Macro to skip checks for same bases. Useful for <code>*</code>, <code>expect</code> and similar functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.timeevolution.@skiptimechecks" href="#QuantumOptics.timeevolution.@skiptimechecks"><code>QuantumOptics.timeevolution.@skiptimechecks</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@skiptimechecks</code></pre><p>Macro to skip checks during time-dependent problems. Useful for <code>timeevolution.master_dynamic</code> and similar functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.AbstractOperator" href="#QuantumOptics.operators.AbstractOperator"><code>QuantumOptics.operators.AbstractOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base class for all operators.</p><p>All deriving operator classes have to define the fields <code>basis_l</code> and <code>basis_r</code> defining the left and right side bases.</p><p>For fast time evolution also at least the function <code>gemv!(alpha, op::AbstractOperator, x::Ket, beta, result::Ket)</code> should be implemented. Many other generic multiplication functions can be defined in terms of this function and are provided automatically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.Basis" href="#QuantumOptics.bases.Basis"><code>QuantumOptics.bases.Basis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base class for all specialized bases.</p><p>The Basis class is meant to specify a basis of the Hilbert space of the studied system. Besides basis specific information all subclasses must implement a shape variable which indicates the dimension of the used Hilbert space. For a spin-1/2 Hilbert space this would be the vector <code>Int[2]</code>. A system composed of two spins would then have a shape vector <code>Int[2 2]</code>.</p><p>Composite systems can be defined with help of the <a href="#QuantumOptics.bases.CompositeBasis"><code>CompositeBasis</code></a> class.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.states.Bra" href="#QuantumOptics.states.Bra"><code>QuantumOptics.states.Bra</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Bra(b::Basis[, data])</code></pre><p>Bra state defined by coefficients in respect to the basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.CompositeBasis" href="#QuantumOptics.bases.CompositeBasis"><code>QuantumOptics.bases.CompositeBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CompositeBasis(b1, b2...)</code></pre><p>Basis for composite Hilbert spaces.</p><p>Stores the subbases in a vector and creates the shape vector directly from the shape vectors of these subbases. Instead of creating a CompositeBasis directly <code>tensor(b1, b2...)</code> or <code>b1 ⊗ b2 ⊗ …</code> can be used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.DataOperator" href="#QuantumOptics.operators.DataOperator"><code>QuantumOptics.operators.DataOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for operators with a data field.</p><p>This is an abstract type for operators that have a direct matrix representation stored in their <code>.data</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_dense.DenseOperator" href="#QuantumOptics.operators_dense.DenseOperator"><code>QuantumOptics.operators_dense.DenseOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseOperator(b1[, b2, data])</code></pre><p>Dense array implementation of Operator.</p><p>The matrix consisting of complex floats is stored in the <code>data</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.DenseSuperOperator" href="#QuantumOptics.superoperators.DenseSuperOperator"><code>QuantumOptics.superoperators.DenseSuperOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseSuperOperator(b1[, b2, data])</code></pre><p>SuperOperator stored as dense matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.FockBasis" href="#QuantumOptics.fock.FockBasis"><code>QuantumOptics.fock.FockBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FockBasis(N)</code></pre><p>Basis for a Fock space where <code>N</code> specifies a cutoff, i.e. what the highest included fock state is. Note that the dimension of this basis then is N+1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.GenericBasis" href="#QuantumOptics.bases.GenericBasis"><code>QuantumOptics.bases.GenericBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GenericBasis(N)</code></pre><p>A general purpose basis of dimension N.</p><p>Should only be used rarely since it defeats the purpose of checking that the bases of state vectors and operators are correct for algebraic operations. The preferred way is to specify special bases for different systems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.states.Ket" href="#QuantumOptics.states.Ket"><code>QuantumOptics.states.Ket</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Ket(b::Basis[, data])</code></pre><p>Ket state defined by coefficients in respect to the given basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_lazyproduct.LazyProduct" href="#QuantumOptics.operators_lazyproduct.LazyProduct"><code>QuantumOptics.operators_lazyproduct.LazyProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazyProduct(operators[, factor=1])
LazyProduct(op1, op2...)</code></pre><p>Lazy evaluation of products of operators.</p><p>The factors of the product are stored in the <code>operators</code> field. Additionally a complex factor is stored in the <code>factor</code> field which allows for fast multiplication with numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_lazysum.LazySum" href="#QuantumOptics.operators_lazysum.LazySum"><code>QuantumOptics.operators_lazysum.LazySum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazySum([factors,] operators)</code></pre><p>Lazy evaluation of sums of operators.</p><p>All operators have to be given in respect to the same bases. The field <code>factors</code> accounts for an additional multiplicative factor for each operator stored in the <code>operators</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_lazytensor.LazyTensor" href="#QuantumOptics.operators_lazytensor.LazyTensor"><code>QuantumOptics.operators_lazytensor.LazyTensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazyTensor(b1[, b2], indices, operators[, factor=1])</code></pre><p>Lazy implementation of a tensor product of operators.</p><p>The suboperators are stored in the <code>operators</code> field. The <code>indices</code> field specifies in which subsystem the corresponding operator lives. Additionally, a complex factor is stored in the <code>factor</code> field which allows for fast multiplication with numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.manybody.ManyBodyBasis" href="#QuantumOptics.manybody.ManyBodyBasis"><code>QuantumOptics.manybody.ManyBodyBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ManyBodyBasis(b, occupations)</code></pre><p>Basis for a many body system.</p><p>The basis has to know the associated one-body basis <code>b</code> and which occupation states should be included. The occupations_hash is used to speed up checking if two many-body bases are equal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.MomentumBasis" href="#QuantumOptics.particle.MomentumBasis"><code>QuantumOptics.particle.MomentumBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MomentumBasis(pmin, pmax, Npoints)
MomentumBasis(b::PositionBasis)</code></pre><p>Basis for a particle in momentum space.</p><p>For simplicity periodic boundaries are assumed which means that <code>pmax</code> is not included in the basis but is defined to be the same as <code>pmin</code>.</p><p>When a <a href="#QuantumOptics.particle.PositionBasis"><code>PositionBasis</code></a> is given as argument the exact values of <span>$p_{min}$</span> and <span>$p_{max}$</span> are due to the periodic boundary conditions more or less arbitrary and are chosen to be <span>$-\pi/dx$</span> and <span>$\pi/dx$</span> with <span>$dx=(x_{max}-x_{min})/N$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.nlevel.NLevelBasis" href="#QuantumOptics.nlevel.NLevelBasis"><code>QuantumOptics.nlevel.NLevelBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NLevelBasis(N)</code></pre><p>Basis for a system consisting of N states.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.PPT" href="#QuantumOptics.metrics.PPT"><code>QuantumOptics.metrics.PPT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">PPT(rho, index)</code></pre><p>Peres-Horodecki criterion of partial transpose.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.PositionBasis" href="#QuantumOptics.particle.PositionBasis"><code>QuantumOptics.particle.PositionBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PositionBasis(xmin, xmax, Npoints)
PositionBasis(b::MomentumBasis)</code></pre><p>Basis for a particle in real space.</p><p>For simplicity periodic boundaries are assumed which means that the rightmost point defined by <code>xmax</code> is not included in the basis but is defined to be the same as <code>xmin</code>.</p><p>When a <a href="#QuantumOptics.particle.MomentumBasis"><code>MomentumBasis</code></a> is given as argument the exact values of <span>$x_{min}$</span> and <span>$x_{max}$</span> are due to the periodic boundary conditions more or less arbitrary and are chosen to be <span>$-\pi/dp$</span> and <span>$\pi/dp$</span> with <span>$dp=(p_{max}-p_{min})/N$</span>.</p></div></div></section><pre><code class="language-none">QuantumOptics.QuantumOptics</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_sparse.SparseOperator" href="#QuantumOptics.operators_sparse.SparseOperator"><code>QuantumOptics.operators_sparse.SparseOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SparseOperator(b1[, b2, data])</code></pre><p>Sparse array implementation of Operator.</p><p>The matrix is stored as the julia built-in type <code>SparseMatrixCSC</code> in the <code>data</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.SparseSuperOperator" href="#QuantumOptics.superoperators.SparseSuperOperator"><code>QuantumOptics.superoperators.SparseSuperOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SparseSuperOperator(b1[, b2, data])</code></pre><p>SuperOperator stored as sparse matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.SpinBasis" href="#QuantumOptics.spin.SpinBasis"><code>QuantumOptics.spin.SpinBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SpinBasis(n)</code></pre><p>Basis for spin-n particles.</p><p>The basis can be created for arbitrary spinnumbers by using a rational number, e.g. <code>SpinBasis(3//2)</code>. The Pauli operators are defined for all possible spin numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.states.StateVector" href="#QuantumOptics.states.StateVector"><code>QuantumOptics.states.StateVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base class for <a href="#QuantumOptics.states.Bra"><code>Bra</code></a> and <a href="#QuantumOptics.states.Ket"><code>Ket</code></a> states.</p><p>The state vector class stores the coefficients of an abstract state in respect to a certain basis. These coefficients are stored in the <code>data</code> field and the basis is defined in the <code>basis</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.subspace.SubspaceBasis" href="#QuantumOptics.subspace.SubspaceBasis"><code>QuantumOptics.subspace.SubspaceBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SubspaceBasis(basisstates)</code></pre><p>A basis describing a subspace embedded a higher dimensional Hilbert space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.SuperOperator" href="#QuantumOptics.superoperators.SuperOperator"><code>QuantumOptics.superoperators.SuperOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for all super operator classes.</p><p>Super operators are bijective mappings from operators given in one specific basis to operators, possibly given in respect to another, different basis. To embed super operators in an algebraic framework they are defined with a left hand basis <code>basis_l</code> and a right hand basis <code>basis_r</code> where each of them again consists of a left and right hand basis.</p><div>\[A_{bl_1,bl_2} = S_{(bl_1,bl_2) ↔ (br_1,br_2)} B_{br_1,br_2}
\\
A_{br_1,br_2} = B_{bl_1,bl_2} S_{(bl_1,bl_2) ↔ (br_1,br_2)}\]</div></div></div></section><pre><code class="language-none">QuantumOptics.bases</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.basis" href="#QuantumOptics.bases.basis"><code>QuantumOptics.bases.basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis(a)</code></pre><p>Return the basis of an object.</p><p>If it&#39;s ambiguous, e.g. if an operator has a different left and right basis, an <a href="@ref"><code>IncompatibleBases</code></a> error is thrown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.states.basisstate" href="#QuantumOptics.states.basisstate"><code>QuantumOptics.states.basisstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basisstate(b, index)</code></pre><p>Basis vector specified by <code>index</code> as ket state.</p><p>For a composite system <code>index</code> can be a vector which then creates a tensor product state <span>$|i_1⟩⊗|i_2⟩⊗…⊗|i_n⟩$</span> of the corresponding basis states.</p></div></div><div><div><pre><code class="language-none">basisstate(b::ManyBodyBasis, occupation::Vector{Int})</code></pre><p>Return a ket state where the system is in the state specified by the given occupation numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.manybody.bosonstates" href="#QuantumOptics.manybody.bosonstates"><code>QuantumOptics.manybody.bosonstates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bosonstates(Nmodes, Nparticles)
bosonstates(b, Nparticles)</code></pre><p>Generate all bosonic occupation states for N-particles in M-modes. <code>Nparticles</code> can be a vector to define a Hilbert space with variable particle number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.coherentspinstate" href="#QuantumOptics.phasespace.coherentspinstate"><code>QuantumOptics.phasespace.coherentspinstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coherentspinstate(b::SpinBasis, θ::Real, ϕ::Real)</code></pre><p>A coherent spin state |θ,ϕ⟩ is analogous to the coherent state of the linear harmonic oscillator. Coherent spin states represent a collection of identical two-level systems and can be described by two angles θ and ϕ (although this parametrization is not unique), similarly to a qubit on the Bloch sphere.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.coherentstate" href="#QuantumOptics.fock.coherentstate"><code>QuantumOptics.fock.coherentstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coherentstate(b::FockBasis, alpha)</code></pre><p>Coherent state <span>$|α⟩$</span> for the specified Fock space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.coherentthermalstate" href="#QuantumOptics.state_definitions.coherentthermalstate"><code>QuantumOptics.state_definitions.coherentthermalstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coherentthermalstate(basis::FockBasis,H,T,alpha)</code></pre><p>Coherent thermal state <span>$D(α)exp(-H/T)/Tr[exp(-H/T)]D^†(α)$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.create" href="#QuantumOptics.fock.create"><code>QuantumOptics.fock.create</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">create(b::FockBasis)</code></pre><p>Creation operator for the specified Fock space.</p></div></div><div><div><pre><code class="language-none">create(b::ManyBodyBasis, index)</code></pre><p>Creation operator for the i-th mode of the many-body basis <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.states.dagger" href="#QuantumOptics.states.dagger"><code>QuantumOptics.states.dagger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dagger(x)</code></pre><p>Hermitian conjugate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.dense" href="#QuantumOptics.operators.dense"><code>QuantumOptics.operators.dense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dense(op::AbstractOperator)</code></pre><p>Convert an arbitrary Operator into a <a href="#QuantumOptics.operators_dense.DenseOperator"><code>DenseOperator</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.destroy" href="#QuantumOptics.fock.destroy"><code>QuantumOptics.fock.destroy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">destroy(b::FockBasis)</code></pre><p>Annihilation operator for the specified Fock space.</p></div></div><div><div><pre><code class="language-none">destroy(b::ManyBodyBasis, index)</code></pre><p>Annihilation operator for the i-th mode of the many-body basis <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.timeevolution.timeevolution_mcwf.diagonaljumps" href="#QuantumOptics.timeevolution.timeevolution_mcwf.diagonaljumps"><code>QuantumOptics.timeevolution.timeevolution_mcwf.diagonaljumps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diagonaljumps(rates, J)</code></pre><p>Diagonalize jump operators.</p><p>The given matrix <code>rates</code> of decay rates is diagonalized and the corresponding set of jump operators is calculated.</p><p><strong>Arguments</strong></p><ul><li><code>rates</code>: Matrix of decay rates.</li><li><code>J</code>: Vector of jump operators.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_sparse.diagonaloperator" href="#QuantumOptics.operators_sparse.diagonaloperator"><code>QuantumOptics.operators_sparse.diagonaloperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diagonaloperator(b::Basis)</code></pre><p>Create a diagonal operator of type <a href="#QuantumOptics.operators_sparse.SparseOperator"><code>SparseOperator</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.displace" href="#QuantumOptics.fock.displace"><code>QuantumOptics.fock.displace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">displace(b::FockBasis, alpha)</code></pre><p>Displacement operator <span>$D(α)$</span> for the specified Fock space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_dense.dm" href="#QuantumOptics.operators_dense.dm"><code>QuantumOptics.operators_dense.dm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dm(a::StateVector)</code></pre><p>Create density matrix <span>$|a⟩⟨a|$</span>. Same as <code>projector(a)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spectralanalysis.eigenenergies" href="#QuantumOptics.spectralanalysis.eigenenergies"><code>QuantumOptics.spectralanalysis.eigenenergies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigenenergies(op::AbstractOperator[, n::Int; warning=true])</code></pre><p>Calculate the lowest n eigenvalues.</p><p>This is just a thin wrapper around julia&#39;s <code>eigvals</code>. If more control about the way the calculation is done is needed, use the function directly. More details can be found at [http://docs.julialang.org/en/stable/stdlib/linalg/].</p><p>If the given operator is non-hermitian a warning is given. This behavior can be turned off using the keyword <code>warning=false</code>.</p></div></div><div><div><p>For sparse operators by default it only returns the 6 lowest eigenvalues.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spectralanalysis.eigenstates" href="#QuantumOptics.spectralanalysis.eigenstates"><code>QuantumOptics.spectralanalysis.eigenstates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigenstates(op::AbstractOperator[, n::Int; warning=true])</code></pre><p>Calculate the lowest n eigenvalues and their corresponding eigenstates.</p><p>This is just a thin wrapper around julia&#39;s <code>eigen</code> and <code>eigs</code> functions. Which of them is used depends on the type of the given operator. If more control about the way the calculation is done is needed, use the functions directly. More details can be found at [http://docs.julialang.org/en/stable/stdlib/linalg/].</p><p>NOTE: Especially for small systems full diagonalization with Julia&#39;s <code>eigen</code> function is often more desirable. You can convert a sparse operator <code>A</code> to a dense one using <code>dense(A)</code>.</p><p>If the given operator is non-hermitian a warning is given. This behavior can be turned off using the keyword <code>warning=false</code>.</p></div></div><div><div><p>For sparse operators by default it only returns the 6 lowest eigenvalues.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.embed" href="#QuantumOptics.operators.embed"><code>QuantumOptics.operators.embed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">embed(basis1[, basis2], indices::Vector, operators::Vector)</code></pre><p>Tensor product of operators where missing indices are filled up with identity operators.</p></div></div><div><div><pre><code class="language-none">embed(basis1[, basis2], operators::Dict)</code></pre><p><code>operators</code> is a dictionary <code>Dict{Vector{Int}, AbstractOperator}</code>. The integer vector specifies in which subsystems the corresponding operator is defined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.entropy_vn" href="#QuantumOptics.metrics.entropy_vn"><code>QuantumOptics.metrics.entropy_vn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">entropy_vn(rho)</code></pre><p>Von Neumann entropy of a density matrix.</p><p>The Von Neumann entropy of a density operator is defined as</p><div>\[S(ρ) = -Tr(ρ \log(ρ)) = -\sum_n λ_n\log(λ_n)\]</div><p>where <span>$λ_n$</span> are the eigenvalues of the density matrix <span>$ρ$</span>, <span>$\log$</span> is the natural logarithm and <span>$0\log(0) ≡ 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rho</code>: Density operator of which to calculate Von Neumann entropy.</li><li><code>tol=1e-15</code>: Tolerance for rounding errors in the computed eigenvalues.</li></ul></div></div></section><pre><code class="language-none">QuantumOptics.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.expect" href="#QuantumOptics.operators.expect"><code>QuantumOptics.operators.expect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expect(op, state)</code></pre><p>Expectation value of the given operator <code>op</code> for the specified <code>state</code>.</p><p><code>state</code> can either be a (density) operator or a ket.</p></div></div><div><div><pre><code class="language-none">expect(index, op, state)</code></pre><p>If an <code>index</code> is given, it assumes that <code>op</code> is defined in the subsystem specified by this number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.manybody.fermionstates" href="#QuantumOptics.manybody.fermionstates"><code>QuantumOptics.manybody.fermionstates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fermionstates(Nmodes, Nparticles)
fermionstates(b, Nparticles)</code></pre><p>Generate all fermionic occupation states for N-particles in M-modes. <code>Nparticles</code> can be a vector to define a Hilbert space with variable particle number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.fidelity" href="#QuantumOptics.metrics.fidelity"><code>QuantumOptics.metrics.fidelity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fidelity(rho, sigma)</code></pre><p>Fidelity of two density operators.</p><p>The fidelity of two density operators <span>$ρ$</span> and <span>$σ$</span> is defined by</p><div>\[F(ρ, σ) = Tr\left(\sqrt{\sqrt{ρ}σ\sqrt{ρ}}\right),\]</div><p>where <span>$\sqrt{ρ}=\sum_n\sqrt{λ_n}|ψ⟩⟨ψ|$</span>.</p></div></div></section><pre><code class="language-none">QuantumOptics.fock</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.fockstate" href="#QuantumOptics.fock.fockstate"><code>QuantumOptics.fock.fockstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fockstate(b::FockBasis, n)</code></pre><p>Fock state <span>$|n⟩$</span> for the specified Fock space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.gaussianstate" href="#QuantumOptics.particle.gaussianstate"><code>QuantumOptics.particle.gaussianstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gaussianstate(b::PositionBasis, x0, p0, sigma)
gaussianstate(b::MomentumBasis, x0, p0, sigma)</code></pre><p>Create a Gaussian state around <code>x0</code> and<code>p0</code> with width <code>sigma</code>.</p><p>In real space the gaussian state is defined as</p><div>\[\Psi(x) = \frac{\sqrt{\Delta x}}{\pi^{1/4}\sqrt{\sigma}}
            e^{i p_0 (x-\frac{x_0}{2}) - \frac{(x-x_0)^2}{2 \sigma^2}}\]</div><p>and is connected to the momentum space definition</p><div>\[\Psi(p) = \frac{\sqrt{\sigma} \sqrt{\Delta x}}{\pi^{1/4}}
            e^{-i x_0 (p-\frac{p_0}{2}) - \frac{1}{2}(p-p_0)^2 \sigma^2}\]</div><p>via a Fourier-transformation</p><div>\[\Psi(p) = \frac{1}{\sqrt{2\pi}}
            \int_{-\infty}^{\infty} e^{-ipx}\Psi(x) \mathrm{d}x\]</div><p>The state has the properties</p><ul><li><span>$⟨p⟩ = p_0$</span></li><li><span>$⟨x⟩ = x_0$</span></li><li><span>$\mathrm{Var}(x) = \frac{σ^2}{2}$</span></li><li><span>$\mathrm{Var}(p) = \frac{1}{2 σ^2}$</span></li></ul><p>Due to the numerically necessary discretization additional scaling factora <span>$\sqrt{Δx}$</span> and <span>$\sqrt{Δp}$</span> are used so that <span>$Ψx_i = \sqrt{Δ x} Ψ(x_i)$</span> and <span>$Ψp_i = \sqrt{Δ x} Ψ(p_i)$</span> so that the resulting Ket state is normalized.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.identityoperator" href="#QuantumOptics.operators.identityoperator"><code>QuantumOptics.operators.identityoperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">identityoperator(a::Basis[, b::Basis])</code></pre><p>Return an identityoperator in the given bases.</p></div></div></section><pre><code class="language-none">QuantumOptics.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.liouvillian" href="#QuantumOptics.superoperators.liouvillian"><code>QuantumOptics.superoperators.liouvillian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">liouvillian(H, J; rates, Jdagger)</code></pre><p>Create a super-operator equivalent to the master equation so that <span>$\dot ρ = S ρ$</span>.</p><p>The super-operator <span>$S$</span> is defined by</p><div>\[S ρ = -\frac{i}{ħ} [H, ρ] + \sum_i J_i ρ J_i^† - \frac{1}{2} J_i^† J_i ρ - \frac{1}{2} ρ J_i^† J_i\]</div><p><strong>Arguments</strong></p><ul><li><code>H</code>: Hamiltonian.</li><li><code>J</code>: Vector containing the jump operators.</li><li><code>rates</code>: Vector or matrix specifying the coefficients for the jump operators.</li><li><code>Jdagger</code>: Vector containing the hermitian conjugates of the jump operators. If they            are not given they are calculated automatically.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.logarithmic_negativity" href="#QuantumOptics.metrics.logarithmic_negativity"><code>QuantumOptics.metrics.logarithmic_negativity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logarithmic_negativity(rho, index)</code></pre><p>The logarithmic negativity of a density matrix ρ is defined as</p><div>\[N(ρ) = \log₂\|ρᵀ\|,\]</div><p>where <code>ρᵀ</code> is the partial transpose.</p></div></div></section><pre><code class="language-none">QuantumOptics.manybody</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.manybody.manybodyoperator" href="#QuantumOptics.manybody.manybodyoperator"><code>QuantumOptics.manybody.manybodyoperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">manybodyoperator(b::ManyBodyBasis, op)</code></pre><p>Create the many-body operator from the given one-body operator <code>op</code>.</p><p>The given operator can either be a one-body operator or a two-body interaction. Higher order interactions are at the moment not implemented.</p><p>The mathematical formalism for the one-body case is described by</p><div>\[X = \sum_{ij} a_i^† a_j ⟨u_i| x | u_j⟩\]</div><p>and for the interaction case by</p><div>\[X = \sum_{ijkl} a_i^† a_j^† a_k a_l ⟨u_i|⟨u_j| x |u_k⟩|u_l⟩\]</div><p>where <span>$X$</span> is the N-particle operator, <span>$x$</span> is the one-body operator and <span>$|u⟩$</span> are the one-body states associated to the different modes of the N-particle basis.</p></div></div></section><pre><code class="language-none">QuantumOptics.metrics</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.momentum" href="#QuantumOptics.particle.momentum"><code>QuantumOptics.particle.momentum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">momentum(b:MomentumBasis)</code></pre><p>Momentum operator in momentum space.</p></div></div><div><div><pre><code class="language-none">momentum(b::PositionBasis)</code></pre><p>Momentum operator in real space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.negativity" href="#QuantumOptics.metrics.negativity"><code>QuantumOptics.metrics.negativity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">negativity(rho, index)</code></pre><p>Negativity of rho with respect to subsystem index.</p><p>The negativity of a density matrix ρ is defined as</p><div>\[N(ρ) = \|ρᵀ\|,\]</div><p>where <code>ρᵀ</code> is the partial transpose.</p></div></div></section><pre><code class="language-none">QuantumOptics.nlevel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.nlevel.nlevelstate" href="#QuantumOptics.nlevel.nlevelstate"><code>QuantumOptics.nlevel.nlevelstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nlevelstate(b::NLevelBasis, n::Int)</code></pre><p>State where the system is completely in the n-th level.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">norm(x::StateVector)</code></pre><p>Norm of the given bra or ket state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize(op)</code></pre><p>Return the normalized operator so that its <code>tr(op)</code> is one.</p></div></div><div><div><pre><code class="language-none">normalize(x::StateVector)</code></pre><p>Return the normalized state so that <code>norm(x)</code> is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize!(op)</code></pre><p>In-place normalization of the given operator so that its <code>tr(x)</code> is one.</p></div></div><div><div><pre><code class="language-none">normalize!(x::StateVector)</code></pre><p>In-place normalization of the given bra or ket so that <code>norm(x)</code> is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.fock.number" href="#QuantumOptics.fock.number"><code>QuantumOptics.fock.number</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">number(b::FockBasis)</code></pre><p>Number operator for the specified Fock space.</p></div></div><div><div><pre><code class="language-none">number(b::ManyBodyBasis, index)</code></pre><p>Particle number operator for the i-th mode of the many-body basis <code>b</code>.</p></div></div><div><div><pre><code class="language-none">number(b::ManyBodyBasis)</code></pre><p>Total particle number operator.</p></div></div></section><pre><code class="language-none">QuantumOptics.occupation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.manybody.onebodyexpect" href="#QuantumOptics.manybody.onebodyexpect"><code>QuantumOptics.manybody.onebodyexpect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">onebodyexpect(op, state)</code></pre><p>Expectation value of the one-body operator <code>op</code> in respect to the many-body <code>state</code>.</p></div></div></section><pre><code class="language-none">QuantumOptics.operators</code></pre><pre><code class="language-none">QuantumOptics.operators_dense</code></pre><pre><code class="language-none">QuantumOptics.operators_lazyproduct</code></pre><pre><code class="language-none">QuantumOptics.operators_lazysum</code></pre><pre><code class="language-none">QuantumOptics.operators_lazytensor</code></pre><pre><code class="language-none">QuantumOptics.operators_sparse</code></pre><pre><code class="language-none">QuantumOptics.particle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.passive_state" href="#QuantumOptics.state_definitions.passive_state"><code>QuantumOptics.state_definitions.passive_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">passive_state(rho,IncreasingEigenenergies::Bool=true)</code></pre><p>Passive state <span>$π$</span> of <span>$ρ$</span>. IncreasingEigenenergies=true means that higher indices correspond to higher energies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.permutesystems" href="#QuantumOptics.bases.permutesystems"><code>QuantumOptics.bases.permutesystems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutesystems(a, perm)</code></pre><p>Change the ordering of the subsystems of the given object.</p><p>For a permutation vector <code>[2,1,3]</code> and a given object with basis <code>[b1, b2, b3]</code> this function results in <code>[b2, b1, b3]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.phase_average" href="#QuantumOptics.state_definitions.phase_average"><code>QuantumOptics.state_definitions.phase_average</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phase_average(rho)</code></pre><p>Returns the phase-average of <span>$ρ$</span> containing only the diagonal elements.</p></div></div></section><pre><code class="language-none">QuantumOptics.phasespace</code></pre><pre><code class="language-none">QuantumOptics.polynomials</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.position" href="#Base.position"><code>Base.position</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">position(b::PositionBasis)</code></pre><p>Position operator in real space.</p></div></div><div><div><pre><code class="language-none">position(b:MomentumBasis)</code></pre><p>Position operator in momentum space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.potentialoperator" href="#QuantumOptics.particle.potentialoperator"><code>QuantumOptics.particle.potentialoperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">potentialoperator(b::PositionBasis, V(x))</code></pre><p>Operator representing a potential <span>$V(x)$</span> in real space.</p></div></div><div><div><pre><code class="language-none">potentialoperator(b::MomentumBasis, V(x))</code></pre><p>Operator representing a potential <span>$V(x)$</span> in momentum space.</p></div></div><div><div><pre><code class="language-none">potentialoperator(b::CompositeBasis, V(x, y, z, ...))</code></pre><p>Operator representing a potential <span>$V$</span> in more than one dimension.</p><p><strong>Arguments</strong></p><ul><li><code>b</code>: Composite basis consisting purely either of <code>PositionBasis</code> or   <code>MomentumBasis</code>. Note, that calling this with a composite basis in   momentum space might consume a large amount of memory.</li><li><code>V</code>: Function describing the potential. ATTENTION: The number of arguments   accepted by <code>V</code> must match the spatial dimension. Furthermore, the order   of the arguments has to match that of the order of the tensor product of   bases (e.g. if <code>b=bx⊗by⊗bz</code>, then <code>V(x,y,z)</code>).</li></ul></div></div></section><pre><code class="language-none">QuantumOptics.printing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators_dense.projector" href="#QuantumOptics.operators_dense.projector"><code>QuantumOptics.operators_dense.projector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">projector(b1, b2)</code></pre><p>Projection operator between subspaces and superspaces or between two subspaces.</p></div></div><div><div><pre><code class="language-none">projector(a::Ket, b::Bra)</code></pre><p>Projection operator <span>$|a⟩⟨b|$</span>.</p></div></div><div><div><pre><code class="language-none">projector(a::Ket)</code></pre><p>Projection operator <span>$|a⟩⟨a|$</span>.</p></div></div><div><div><pre><code class="language-none">projector(a::Bra)</code></pre><p>Projection operator <span>$|a⟩⟨a|$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.ptrace" href="#QuantumOptics.bases.ptrace"><code>QuantumOptics.bases.ptrace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ptrace(a, indices)</code></pre><p>Partial trace of the given basis, state or operator.</p><p>The <code>indices</code> argument, which can be a single integer or a vector of integers, specifies which subsystems are traced out. The number of indices has to be smaller than the number of subsystems, i.e. it is not allowed to perform a full trace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.ptranspose" href="#QuantumOptics.metrics.ptranspose"><code>QuantumOptics.metrics.ptranspose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ptranspose(rho, index)</code></pre><p>Partial transpose of rho with respect to subspace specified by index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.qfunc" href="#QuantumOptics.phasespace.qfunc"><code>QuantumOptics.phasespace.qfunc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qfunc(a, α)
qfunc(a, x, y)
qfunc(a, xvec, yvec)</code></pre><p>Husimi Q representation <span>$⟨α|ρ|α⟩/π$</span> for the given state or operator <code>a</code>. The function can either be evaluated on one point α or on a grid specified by the vectors <code>xvec</code> and <code>yvec</code>. Note that conversion from <code>x</code> and <code>y</code> to <code>α</code> is done via the relation <span>$α = \frac{1}{\sqrt{2}}(x + i y)$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.qfuncsu2" href="#QuantumOptics.phasespace.qfuncsu2"><code>QuantumOptics.phasespace.qfuncsu2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qfuncsu2(ket,Ntheta;Nphi=2Ntheta)
qfuncsu2(rho,Ntheta;Nphi=2Ntheta)</code></pre><p>Husimi Q SU(2) representation <span>$⟨θ,ϕ|ρ|θ,ϕ⟩/π$</span> for the given state.</p><p>The function calculates the SU(2) Husimi representation of a state on the generalised bloch sphere (0 &lt; θ &lt; π and 0 &lt; ϕ &lt; 2 π) with a given resolution <code>(Ntheta, Nphi)</code>.</p><pre><code class="language-none">qfuncsu2(rho,θ,ϕ)
qfuncsu2(ket,θ,ϕ)</code></pre><p>This version calculates the Husimi Q SU(2) function at a position given by θ and ϕ.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.randoperator" href="#QuantumOptics.state_definitions.randoperator"><code>QuantumOptics.state_definitions.randoperator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randoperator(b1[, b2])</code></pre><p>Calculate a random unnormalized dense operator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.randstate" href="#QuantumOptics.state_definitions.randstate"><code>QuantumOptics.state_definitions.randstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randstate(basis)</code></pre><p>Calculate a random normalized ket state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.samplepoints" href="#QuantumOptics.particle.samplepoints"><code>QuantumOptics.particle.samplepoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">samplepoints(b::PositionBasis)</code></pre><p>x values of the real space basis.</p></div></div><div><div><pre><code class="language-none">samplepoints(b::MomentumBasis)</code></pre><p>p values of the momentum basis.</p></div></div></section><pre><code class="language-none">QuantumOptics.semiclassical</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.sigmam" href="#QuantumOptics.spin.sigmam"><code>QuantumOptics.spin.sigmam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmam(b::SpinBasis)</code></pre><p>Lowering operator <span>$σ_-$</span> for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.sigmap" href="#QuantumOptics.spin.sigmap"><code>QuantumOptics.spin.sigmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmap(b::SpinBasis)</code></pre><p>Raising operator <span>$σ_+$</span> for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.sigmax" href="#QuantumOptics.spin.sigmax"><code>QuantumOptics.spin.sigmax</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmax(b::SpinBasis)</code></pre><p>Pauli <span>$σ_x$</span> operator for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.sigmay" href="#QuantumOptics.spin.sigmay"><code>QuantumOptics.spin.sigmay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmay(b::SpinBasis)</code></pre><p>Pauli <span>$σ_y$</span> operator for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.sigmaz" href="#QuantumOptics.spin.sigmaz"><code>QuantumOptics.spin.sigmaz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sigmaz(b::SpinBasis)</code></pre><p>Pauli <span>$σ_z$</span> operator for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spectralanalysis.simdiag" href="#QuantumOptics.spectralanalysis.simdiag"><code>QuantumOptics.spectralanalysis.simdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simdiag(ops; atol, rtol)</code></pre><p>Simultaneously diagonalize commuting Hermitian operators specified in <code>ops</code>.</p><p>This is done by diagonalizing the sum of the operators. The eigenvalues are computed by <span>$a = ⟨ψ|A|ψ⟩$</span> and it is checked whether the eigenvectors fulfill the equation <span>$A|ψ⟩ = a|ψ⟩$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ops</code>: Vector of sparse or dense operators.</li><li><code>atol=1e-14</code>: kwarg of Base.isapprox specifying the tolerance of the       approximate check</li><li><code>rtol=1e-14</code>: kwarg of Base.isapprox specifying the tolerance of the       approximate check</li></ul><p><strong>Returns</strong></p><ul><li><code>evals_sorted</code>: Vector containing all vectors of the eigenvalues sorted       by the eigenvalues of the first operator.</li><li><code>v</code>: Common eigenvectors.</li></ul></div></div></section><pre><code class="language-none">QuantumOptics.sortedindices</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sparse(op::AbstractOperator)</code></pre><p>Convert an arbitrary operator into a <a href="#QuantumOptics.operators_sparse.SparseOperator"><code>SparseOperator</code></a>.</p></div></div></section><pre><code class="language-none">QuantumOptics.sparsematrix</code></pre><pre><code class="language-none">QuantumOptics.spectralanalysis</code></pre><pre><code class="language-none">QuantumOptics.spin</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.spindown" href="#QuantumOptics.spin.spindown"><code>QuantumOptics.spin.spindown</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spindown(b::SpinBasis)</code></pre><p>Spin down state for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.spin.spinup" href="#QuantumOptics.spin.spinup"><code>QuantumOptics.spin.spinup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spinup(b::SpinBasis)</code></pre><p>Spin up state for the given Spin basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.spost" href="#QuantumOptics.superoperators.spost"><code>QuantumOptics.superoperators.spost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Create a super-operator equivalent for left side operator multiplication.</p><p>For operators <span>$A$</span>, <span>$B$</span> the relation</p><div>\[    \mathrm{spost}(A) B = B A\]</div><p>holds. <code>op</code> can be a dense or a sparse operator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.superoperators.spre" href="#QuantumOptics.superoperators.spre"><code>QuantumOptics.superoperators.spre</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spre(op)</code></pre><p>Create a super-operator equivalent for right side operator multiplication.</p><p>For operators <span>$A$</span>, <span>$B$</span> the relation</p><div>\[    \mathrm{spre}(A) B = A B\]</div><p>holds. <code>op</code> can be a dense or a sparse operator.</p></div></div></section><pre><code class="language-none">QuantumOptics.state_definitions</code></pre><pre><code class="language-none">QuantumOptics.states</code></pre><pre><code class="language-none">QuantumOptics.steadystate</code></pre><pre><code class="language-none">QuantumOptics.stochastic</code></pre><pre><code class="language-none">QuantumOptics.subspace</code></pre><pre><code class="language-none">QuantumOptics.superoperators</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.bases.tensor" href="#QuantumOptics.bases.tensor"><code>QuantumOptics.bases.tensor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tensor(x::AbstractOperator, y::AbstractOperator, z::AbstractOperator...)</code></pre><p>Tensor product <span>$\hat{x}⊗\hat{y}⊗\hat{z}⊗…$</span> of the given operators.</p></div></div><div><div><pre><code class="language-none">tensor(x::Ket, y::Ket, z::Ket...)</code></pre><p>Tensor product <span>$|x⟩⊗|y⟩⊗|z⟩⊗…$</span> of the given states.</p></div></div><div><div><pre><code class="language-none">tensor(x, y, z...)</code></pre><p>Tensor product of the given objects. Alternatively, the unicode symbol ⊗ (\otimes) can be used.</p></div></div><div><div><pre><code class="language-none">tensor(x::Basis, y::Basis, z::Basis...)</code></pre><p>Create a <a href="#QuantumOptics.bases.CompositeBasis"><code>CompositeBasis</code></a> from the given bases.</p><p>Any given CompositeBasis is expanded so that the resulting CompositeBasis never contains another CompositeBasis.</p></div></div><div><div><pre><code class="language-none">tensor(x::Ket, y::Bra)</code></pre><p>Outer product <span>$|x⟩⟨y|$</span> of the given states.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.state_definitions.thermalstate" href="#QuantumOptics.state_definitions.thermalstate"><code>QuantumOptics.state_definitions.thermalstate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">thermalstate(H,T)</code></pre><p>Thermal state <span>$exp(-H/T)/Tr[exp(-H/T)]$</span>.</p></div></div></section><pre><code class="language-none">QuantumOptics.timecorrelations</code></pre><pre><code class="language-none">QuantumOptics.timeevolution</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tr(x::AbstractOperator)</code></pre><p>Trace of the given operator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracedistance" href="#QuantumOptics.metrics.tracedistance"><code>QuantumOptics.metrics.tracedistance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracedistance(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>It is defined as</p><div>\[T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\}.\]</div><p>It calls <a href="#QuantumOptics.metrics.tracenorm"><code>tracenorm</code></a> which in turn either uses <a href="#QuantumOptics.metrics.tracenorm_h"><code>tracenorm_h</code></a> or <a href="#QuantumOptics.metrics.tracenorm_nh"><code>tracenorm_nh</code></a> depending if <span>$ρ-σ$</span> is hermitian or not.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracedistance_h" href="#QuantumOptics.metrics.tracedistance_h"><code>QuantumOptics.metrics.tracedistance_h</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracedistance_h(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>It uses the identity</p><div>\[T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\} = \frac{1}{2} \sum_i |λ_i|\]</div><p>where <span>$λ_i$</span> are the eigenvalues of <code>rho</code> - <code>sigma</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracedistance_nh" href="#QuantumOptics.metrics.tracedistance_nh"><code>QuantumOptics.metrics.tracedistance_nh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracedistance_nh(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>Note that in this case <code>rho</code> and <code>sigma</code> don&#39;t have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases).</p><p>It uses the identity</p><div>\[    T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\}
         = \frac{1}{2} \sum_i σ_i\]</div><p>where <span>$σ_i$</span> are the singular values of <code>rho</code> - <code>sigma</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracenorm" href="#QuantumOptics.metrics.tracenorm"><code>QuantumOptics.metrics.tracenorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracenorm(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>It is defined as</p><div>\[T(ρ) = Tr\{\sqrt{ρ^† ρ}\}.\]</div><p>Depending if <code>rho</code> is hermitian either <a href="#QuantumOptics.metrics.tracenorm_h"><code>tracenorm_h</code></a> or <a href="#QuantumOptics.metrics.tracenorm_nh"><code>tracenorm_nh</code></a> is called.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracenorm_h" href="#QuantumOptics.metrics.tracenorm_h"><code>QuantumOptics.metrics.tracenorm_h</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracenorm_h(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>It uses the identity</p><div>\[T(ρ) = Tr\{\sqrt{ρ^† ρ}\} = \sum_i |λ_i|\]</div><p>where <span>$λ_i$</span> are the eigenvalues of <code>rho</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.metrics.tracenorm_nh" href="#QuantumOptics.metrics.tracenorm_nh"><code>QuantumOptics.metrics.tracenorm_nh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracenorm_nh(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>Note that in this case <code>rho</code> doesn&#39;t have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases).</p><p>It uses the identity</p><div>\[    T(ρ) = Tr\{\sqrt{ρ^† ρ}\} = \sum_i σ_i\]</div><p>where <span>$σ_i$</span> are the singular values of <code>rho</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.particle.transform" href="#QuantumOptics.particle.transform"><code>QuantumOptics.particle.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transform(b1::PositionBasis, b2::FockBasis; x0=1)
transform(b1::FockBasis, b2::PositionBasis; x0=1)</code></pre><p>Transformation operator between position basis and fock basis.</p><p>The coefficients are connected via the relation</p><div>\[ψ(x_i) = \sum_{n=0}^N ⟨x_i|n⟩ ψ_n\]</div><p>where <span>$⟨x_i|n⟩$</span> is the value of the n-th eigenstate of a particle in a harmonic trap potential at position <span>$x$</span>, i.e.:</p><div>\[⟨x_i|n⟩ = π^{-\frac{1}{4}} \frac{e^{-\frac{1}{2}\left(\frac{x}{x_0}\right)^2}}{\sqrt{x_0}}
            \frac{1}{\sqrt{2^n n!}} H_n\left(\frac{x}{x_0}\right)\]</div></div></div><div><div><pre><code class="language-none">transform(b1::MomentumBasis, b2::PositionBasis)
transform(b1::PositionBasis, b2::MomentumBasis)</code></pre><p>Transformation operator between position basis and momentum basis.</p></div></div><div><div><pre><code class="language-none">transform(b1::CompositeBasis, b2::CompositeBasis)</code></pre><p>Transformation operator between two composite bases. Each of the bases has to contain bases of type PositionBasis and the other one a corresponding MomentumBasis.</p></div></div></section><pre><code class="language-none">QuantumOptics.transformations</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.nlevel.transition" href="#QuantumOptics.nlevel.transition"><code>QuantumOptics.nlevel.transition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transition(b::ManyBodyBasis, to::Int, from::Int)</code></pre><p>Operator <span>$|\mathrm{to}⟩⟨\mathrm{from}|$</span> transferring particles between modes.</p></div></div><div><div><pre><code class="language-none">transition(b::NLevelBasis, to::Int, from::Int)</code></pre><p>Transition operator <span>$|\mathrm{to}⟩⟨\mathrm{from}|$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.operators.variance" href="#QuantumOptics.operators.variance"><code>QuantumOptics.operators.variance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">variance(op, state)</code></pre><p>Variance of the given operator <code>op</code> for the specified <code>state</code>.</p><p><code>state</code> can either be a (density) operator or a ket.</p></div></div><div><div><pre><code class="language-none">variance(index, op, state)</code></pre><p>If an <code>index</code> is given, it assumes that <code>op</code> is defined in the subsystem specified by this number</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.wigner" href="#QuantumOptics.phasespace.wigner"><code>QuantumOptics.phasespace.wigner</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wigner(a, α)
wigner(a, x, y)
wigner(a, xvec, yvec)</code></pre><p>Wigner function for the given state or operator <code>a</code>. The function can either be evaluated on one point α or on a grid specified by the vectors <code>xvec</code> and <code>yvec</code>. Note that conversion from <code>x</code> and <code>y</code> to <code>α</code> is done via the relation <span>$α = \frac{1}{\sqrt{2}}(x + i y)$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.wignersu2" href="#QuantumOptics.phasespace.wignersu2"><code>QuantumOptics.phasespace.wignersu2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wignersu2(ket,Ntheta;Nphi=2Ntheta)
wignersu2(rho,Ntheta;Nphi=2Ntheta)</code></pre><p>Wigner SU(2) representation for the given state with a resolution <code>(Ntheta, Nphi)</code>.</p><p>The function calculates the SU(2) Wigner representation of a state on the generalised bloch sphere (0 &lt; θ &lt; π and 0 &lt; ϕ &lt; 2 π) with a given resolution by decomposing the state into the basis of spherical harmonics.</p><pre><code class="language-none">wignersu2(rho,θ,ϕ)
wignersu2(ket,θ,ϕ)</code></pre><p>This version calculates the Wigner SU(2) function at a position given by θ and ϕ</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumOptics.phasespace.ylm" href="#QuantumOptics.phasespace.ylm"><code>QuantumOptics.phasespace.ylm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ylm(l::Integer,m::Integer,theta::Real,phi::Real)</code></pre><p>Spherical harmonics Y(l,m)(θ,ϕ) where l ∈ N,  m = -l,-l+1,...,l-1,l, θ ∈ [0,π], and ϕ ∈ [0,2π).</p><p>This function calculates the value of Y(l,m) spherical harmonic at position θ and ϕ.</p></div></div></section><pre><code class="language-none">QuantumOptics.⊗</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
