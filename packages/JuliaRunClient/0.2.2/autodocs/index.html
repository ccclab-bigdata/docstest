<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · JuliaRunClient.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaRunClient.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">JuliaRunClient.@result</code></pre><pre><code class="language-none">JuliaRunClient.ApiException</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.Context" href="#JuliaRunClient.Context"><code>JuliaRunClient.Context</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A JuliaRun client context.</p><p>Consists of:</p><ul><li>URL of the JuliaRun remote server</li><li>an authentication token</li><li>namespace to operate in</li></ul><p>Default values of all parameters are set to match those inside a JuliaRun cluster.</p><ul><li>connects to a service endpoint at &quot;juliarunremote-svc.juliarun&quot;</li><li>reads the namespace from the default secret</li><li>presents the namespace service token (also read from the default secret) for authentication</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.Generic" href="#JuliaRunClient.Generic"><code>JuliaRunClient.Generic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Generic job to run any command in any docker image.</p><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>image: image to run</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>command: command in the docker to execute (Docker entrypoint by default)</li><li>args: arguments to the command as Vector{String} (none by default)</li><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>cpu: CPU share to allocate (default: 0.1 core, burstable to 1 core)</li><li>memory: RAM to allocate (default: 512Mi to 1Gi)</li><li>envvars: additional environment variables to set</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: none)</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>nworkers: number of containers to start</li></ul></div></div></section><pre><code class="language-none">JuliaRunClient.JOBTYPE</code></pre><pre><code class="language-none">JuliaRunClient.JOBTYPE_LABELS</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.JRunClientJob" href="#JuliaRunClient.JRunClientJob"><code>JuliaRunClient.JRunClientJob</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Types of Jobs:</p><ul><li>JuliaParBatch</li><li>JuliaParBatchWorkers</li><li>Notebook</li><li>JuliaBatch</li><li>PkgBuilder</li><li>Webserver</li><li>MessageQ</li><li>Generic</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.JuliaBatch" href="#JuliaRunClient.JuliaBatch"><code>JuliaRunClient.JuliaBatch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Julia Batch Job.</p><p>Runs in a single allocation/container restricted to the specified amount of CPUs and memory. The Julia process started in the batch job is allowed to start other worker processes or threads, all within the specified limits. The upper bound of CPUs/memory is determined by the largest cluster node.</p><p>Scenarios:</p><ul><li>non-parallel</li><li>multi-threaded parallelism</li><li>multi-process shared memory parallelism</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>start_script: a Julia script to start the master node with</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>pkg<em>bundle: a package bundle to set at LOAD</em>PATH (none by default)</li><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: nothing)</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>image: the docker image to run (default: julia)</li><li>cpu: CPU share to allocate (default: minimum 0.1 of a core, burstable to 1 core)</li><li>gpu: GPUs to allocate (default: 0)</li><li>memory: RAM to allocate (default: 512 MiB to 1Gi)</li><li>shell: the script to use for startup shell (default: master.sh)</li><li>envvars: additional environment variables to set</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.JuliaParBatch" href="#JuliaRunClient.JuliaParBatch"><code>JuliaRunClient.JuliaParBatch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Julia Master-Slave Parallel Batch Job.</p><p>A designated master process and an array of worker processes, each of which  runs in a separate allocation/container. All worker processes have a uniform resource allocation. The master process can have a different allocation.</p><p>The job as a whole can use all available CPU/memory in a cluster (within practical limitations imposed networking and such). The upper bound for each master/worker process is determined by the largest node in the cluster.</p><p>The master and worker processes are initialized for Julia parallel constructs. The number of workers can be checked and manipulated with the <code>scale</code>/<code>scale!</code> APIs. The number of worker processes actually running depends on the available cluster resources and may be different from the requested scale. The job is  deemed running when the master process starts, and JuliaRun attempts to match number of worker processes to the requested scale continuously. The master process may check the number of actual workers with the <code>nworkers</code> API and wait for a minimum number of workers if needed by it.</p><p>Scenario:</p><ul><li>multi-process distributed memory parallelism</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>start_script: a Julia script to start the master node with</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>pkg<em>bundle: a package bundle to set at LOAD</em>PATH (none by default)</li><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>ports: network ports to expose from the master process as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: nothing)</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>image: the docker image to run (default: julia)</li><li>cpu: CPU share to allocate to master process (default: 0.1 of a core, burstable to 1 core)</li><li>gpu: GPUs to allocate (default: 0)</li><li>memory: RAM to allocate to master process (default: 512 Mi to 1 Gi)</li><li>shell: the script to use for master shell (default: master.sh)</li><li>envvars: additional environment variables to set for the master</li><li>nworkers: number of worker processes to start (0 by default, can be scaled later)</li><li>worker_cpu: CPU share to allocate to a worker process (default: 0.1 of a core, burstable to 1 core)</li><li>worker_gpu: GPUs to allocate to a worker process(default: 0)</li><li>worker_memory: RAM to allocate to a worker process (default: 512 Mi to 1 Gi)</li><li>worker_shell: the script to use for a worker shell (default: master.sh)</li><li>worker_envvars: additional environment variables to set for the worker</li><li>worker<em>start</em>script: a Julia script to start the worker node with (default: worker.sh)</li><li>restart: should workers be restarted (RestartAlways by default, can also be RestartOnFailure or Never)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.JuliaParBatchWorkers" href="#JuliaRunClient.JuliaParBatchWorkers"><code>JuliaRunClient.JuliaParBatchWorkers</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Julia Embarrassingly Parallel Batch Job.</p><p>An array of batch jobs that can be scaled as a single unit. Each unit in the job array can be likened to a JuliaBatch job. Since there is no interlinking between the units, this can be scaled faster and to much higher levels.</p><p>As a whole, the job can use all available CPU/memory in the cluster, but the upper bound for each worker process is determined by the largest node in the cluster.</p><p>Scenarios:</p><ul><li>work queues</li><li>distributed memory parallelism</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>start_script: a Julia script to start each node with</li><li>run_volume: a persistent volume to use as the work volume</li></ul><p>Optional parameters:</p><ul><li>pkg<em>bundle: a package bundle to set at LOAD</em>PATH (none by default)</li><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: nothing)</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>image: the docker image to run (default: julia)</li><li>cpu: CPU share to allocate to each process (default: 0.1 of a core, burstable to 1 core)</li><li>gpu: GPUs to allocate to each process (default: 0)</li><li>memory: RAM to allocate to each process (default: 512 Mi to 1Gi)</li><li>shell: the script to use for process shell (default: worker.sh)</li><li>envvars: additional environment variables to set</li><li>nworkers: number of worker processes to start (0 by default, can be scaled later)</li><li>restart: should workers be restarted (RestartAlways by default, can also be RestartOnFailure or Never)</li></ul></div></div></section><pre><code class="language-none">JuliaRunClient.JuliaRunClient</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.MessageQ" href="#JuliaRunClient.MessageQ"><code>JuliaRunClient.MessageQ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Message Queue that can be used for communication between processes within or across jobs. Enables complex routing/broadcast of messages. Uses RabbitMQ as the message queue provider.</p><p>Scenarios:</p><ul><li>inter process communication within / across jobs</li><li>task queue, used by job arrays</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>cfg_file: configuration file to start message queue with</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>image: the docker image to run (default: rabbitmq)</li><li>cpu: CPU share to allocate (default: 1 core, burstable to 2 cores)</li><li>memory: RAM to allocate (default: 4Gi)</li><li>envvars: additional environment variables to set</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: Dict(&quot;amqptls&quot;=&gt;(5671,5671), &quot;amqp&quot;=&gt;(5672,5672), &quot;mgmttls&quot;=&gt;(15672,15671), &quot;mgmt&quot;=&gt;(15672,15672)))</li><li>external: whether network ports should be exposed to external network (default: false)</li></ul><p>Logging: Use RabbitMQ logging configuration environment variables to configure logging characteristics.</p><ul><li>by default logs are written on to stdout / stderr</li><li>log to <code>/mnt/juliarun/mq/rabbit.log</code>: set environment variable <code>RABBITMQ_LOGS</code> to the file for the job</li><li>log SASL activity to <code>/mnt/juliarun/mq/rabbit_sasl.log</code>: set environment variable <code>RABBITMQ_SASL_LOGS</code> to the file for the job</li></ul><p>Ensure the target volume for log files is specified in <code>additional_volumes</code> parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.Notebook" href="#JuliaRunClient.Notebook"><code>JuliaRunClient.Notebook</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Julia Interactive Notebook.</p><p>The notebook is accessible outside the cluster and can be protected by a password (or an external portal/proxy). The master container runs the Jupyter notebook process and the Julia kernels.</p><p>The Julia process running as the kernel is similar to a JuliaBatch. Workers can be provisioned (optionally) as:</p><ul><li>slaves to a master Julia process (a Jupyter kernel), similar to JuliaParBatch</li><li>a job array, similar to JuliaParBatchWorkers</li></ul><p>Scenarios:</p><ul><li>interactive/exploratory tasks</li><li>shell access (through Jupyter shell)</li><li>file transfer (through Jupyter file manager)</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>pkg<em>bundle: a package bundle to set at LOAD</em>PATH (none by default)</li><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>image: the docker image to run (default: julia)</li><li>cpu: CPU share to allocate to master process (default: 0.1 of a core, burstable to 1 core)</li><li>gpu: GPUs to allocate to master process (default: 0)</li><li>memory: RAM to allocate to master process (default: 512 Mi to 1 Gi)</li><li>shell: the script to use for master shell (default: notebook.sh)</li><li>envvars: additional environment variables to set for the master</li><li>worker_cpu: CPU share to allocate to a worker process (default: 0.1 of a core, burstable to 1 core)</li><li>worker_gpu: GPUs to allocate to a worker process (default: 0)</li><li>worker_memory: RAM to allocate to a worker process (default: 512 Mi to 1 Gi)</li><li>worker_shell: the script to use for a worker shell (default: master.sh)</li><li>worker_envvars: additional environment variables to set for the worker</li><li>worker<em>start</em>script: a Julia script to start the worker node with (default: worker.sh)</li><li>passwd: password to protect the notebook with (default: no password)</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: Dict(&quot;nb&quot;=&gt;(8888,8888)))</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>restart: should workers be restarted (RestartAlways by default, can also be RestartOnFailure or Never)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.PkgBuilder" href="#JuliaRunClient.PkgBuilder"><code>JuliaRunClient.PkgBuilder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Build / update a Julia package bundle.</p><p>It mounts the volume representing the package folder of the bundle in read-write mode, and launches a script to build them. It is similar to a JuilaBatch job.</p><p>Package bundles are a way of making Julia packages accessible to JuliaRun jobs. They are just folders with Julia packages, pre-compiled and along with all their dependencies. Package bundles can be built and tested separately and attached to multiple images, providing a way to dissociate their maintenance.</p><p>Attaching a package bundle to a JuliaRun job sets the appropriate environment variables (<code>LOAD_PATH</code> and such) so that Julia code can start using them seamlessly.</p><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>builder_script: a Julia script that builds packages</li><li>run_volume: a persistent volume to use as the master volume</li><li>pkg_bundle: the package bundle to build</li></ul><p>Optional parameters:</p><ul><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>image: the docker image to run (default: julia)</li><li>cpu: CPU share to allocate (default: 1 core, burstable to 2 cores)</li><li>gpu: GPUs to allocate (default: 0)</li><li>memory: RAM to allocate (default: 4Gi to 8 Gi)</li><li>shell: the script to use for startup shell (default: master.sh)</li><li>envvars: additional environment variables to set for the master</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.Webserver" href="#JuliaRunClient.Webserver"><code>JuliaRunClient.Webserver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Webserver that can be used to serve API/UI/files for jobs. Nginx is used as the underlying service.</p><p>Scenarios:</p><ul><li>accept inputs (file uploads, API calls, ...)</li><li>serve output/log files created by jobs</li><li>simple user interfaces</li></ul><p>Required parameters:</p><ul><li>name: name of the job (must be unique in the system, can be random)</li><li>cfg_file: configuration file to start webserver with</li><li>run_volume: a persistent volume to use as the master volume</li></ul><p>Optional parameters:</p><ul><li>additional_volumes: more persistent volumes to attach at /mnt/&lt;volume name&gt; (none by default)</li><li>image: the docker image to run (default: nginx)</li><li>cpu: CPU share to allocate (default: 0.1 core, burstable to 1 core)</li><li>memory: RAM to allocate (default: 512Mi to 1Gi)</li><li>envvars: additional environment variables to set</li><li>ports: network ports to expose as a Dict{String,Tuple{Int,Int}} of name to container port and service port map (default: Dict(&quot;http&quot;=&gt;(80,80), &quot;https&quot;=&gt;(443,443)))</li><li>external: whether network ports should be exposed to external network (default: false)</li><li>nworkers: number of webserver containers to start</li></ul><p>Logging: Use Nginx logging configuration to configure logging characteristics. For example:</p><ul><li>log to <code>/mnt/juliarun/webserver/error.log</code>: <code>error_log /mnt/juliarun/webserver/error.log warn;</code></li><li>log to stderr (and set level to debug): <code>error_log stderr debug;</code></li><li>send access logs to <code>/mnt/juliarun/webserver/access.log</code>: <code>access_log /mnt/juliarun/webserver/access.log;</code></li></ul><p>Ensure the target volume for log files is specified in <code>additional_volumes</code> parameter.</p></div></div></section><pre><code class="language-none">JuliaRunClient._JuliaClusterManager</code></pre><pre><code class="language-none">JuliaRunClient._http_opts</code></pre><pre><code class="language-none">JuliaRunClient._isfile</code></pre><pre><code class="language-none">JuliaRunClient._jobtype</code></pre><pre><code class="language-none">JuliaRunClient._simple_query</code></pre><pre><code class="language-none">JuliaRunClient._type_name_query</code></pre><pre><code class="language-none">JuliaRunClient.as_label</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.deleteJob" href="#JuliaRunClient.deleteJob"><code>JuliaRunClient.deleteJob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Removes the job entry from the queue.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li><li>force: whether to remove an incomplete job (optional, default: false)</li></ul><p>Returns:</p><ul><li>boolean: true/false indicating success/failure</li></ul></div></div></section><pre><code class="language-none">JuliaRunClient.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getAllJobInfo" href="#JuliaRunClient.getAllJobInfo"><code>JuliaRunClient.getAllJobInfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>List all submitted jobs.</p><p>Returns:</p><ul><li>dictionary: of the form <code>{&quot;jobname&quot;: { &quot;type&quot;: &quot;JuliaBatch&quot;, &quot;status&quot;: [], &quot;scale&quot;: [], &quot;endpoint&quot;: [] }...}</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getEncodedURL" href="#JuliaRunClient.getEncodedURL"><code>JuliaRunClient.getEncodedURL</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get encoded URL to job port when using router.</p><p>Returns:</p><ul><li>The encoded URL as a String</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getJobEndpoint" href="#JuliaRunClient.getJobEndpoint"><code>JuliaRunClient.getJobEndpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the endpoint exposed by the job/service.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li></ul><p>Returns tuple/array of endpoints as URLs or IP and ports</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getJobScale" href="#JuliaRunClient.getJobScale"><code>JuliaRunClient.getJobScale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the current scale of a job.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li></ul><p>Returns tuple/array with:</p><ul><li>integer: number of workers running</li><li>integer: number of workers requested</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getJobStatus" href="#JuliaRunClient.getJobStatus"><code>JuliaRunClient.getJobStatus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Fetch current status of a Job.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li></ul><p>Returns tuple/array with:</p><ul><li>boolean: whether the job completed</li><li>integer: for a parallel job, number of workers that completed successfully</li><li>integer: for a parallel job, number of workers started</li><li>boolean: whether the job has been created (vs. scheduled)</li><li>boolean: whether this is a notebook (legacy, likely to be removed in future)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.getSystemStatus" href="#JuliaRunClient.getSystemStatus"><code>JuliaRunClient.getSystemStatus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Verifies if JuliaRun is running and is connected to a compute cluster.</p><p>Returns:</p><ul><li>boolean: true/false indicating success/failure</li></ul></div></div></section><pre><code class="language-none">JuliaRunClient.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.initParallel" href="#JuliaRunClient.initParallel"><code>JuliaRunClient.initParallel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialize the cluster manager for parallel mode.</p></div></div></section><pre><code class="language-none">JuliaRunClient.initializeCluster</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.listJobs" href="#JuliaRunClient.listJobs"><code>JuliaRunClient.listJobs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>List all submitted jobs.</p><p>Returns:</p><ul><li>dictionary: of the form <code>{&quot;jobname&quot;: { &quot;type&quot;: &quot;JuliaBatch&quot; }...}</code></li></ul></div></div></section><pre><code class="language-none">JuliaRunClient.make_query</code></pre><pre><code class="language-none">JuliaRunClient.parse_resp</code></pre><pre><code class="language-none">JuliaRunClient.releaseCluster</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.self" href="#JuliaRunClient.self"><code>JuliaRunClient.self</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns a reference to the current job.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.setJobScale" href="#JuliaRunClient.setJobScale"><code>JuliaRunClient.setJobScale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Request to scale the job up or down to the level of parallelism requested.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li><li>parallelism: number of workers to scale to</li></ul><p>Returns:</p><ul><li>boolean: true/false indicating success/failure</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.submitJob" href="#JuliaRunClient.submitJob"><code>JuliaRunClient.submitJob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Submit a job definition to execute on the cluster.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li><li>job specific parameters, with names as documented for the JobType constructor</li></ul><p>Returns nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.tailJob" href="#JuliaRunClient.tailJob"><code>JuliaRunClient.tailJob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Tail logs from the job.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li><li>stream: the stream to read from (&quot;stdout&quot;/&quot;stdin&quot;), all streams are read if not specified.</li><li>count: number of log entries to return (50 by default)</li></ul><p>Returns a string of log entries separated by new line.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.updateJob" href="#JuliaRunClient.updateJob"><code>JuliaRunClient.updateJob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Update a job definition to execute on the cluster.</p><p>Parameters:</p><ul><li>job: A JRunClientJob of appropriate type</li><li>job specific parameters, with names as documented for the JobType constructor</li></ul><p>Returns nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaRunClient.waitForWorkers" href="#JuliaRunClient.waitForWorkers"><code>JuliaRunClient.waitForWorkers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Wait for a certain number of workers to join.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
