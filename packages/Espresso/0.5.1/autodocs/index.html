<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Espresso.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Espresso.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@get" href="#Espresso.@get"><code>Espresso.@get</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Same as <code>get</code> function, but evaluates default_expr only if needed</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@get_array" href="#Espresso.@get_array"><code>Espresso.@get_array</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Get array of size <code>sz</code> from a <code>dict</code> by <code>key</code>. If element doesn&#39;t exist or its size is not equal to <code>sz</code>, create and return new array using <code>default_expr</code>. If element exists, but is not an error, throw ArgumentError.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@get_or_create" href="#Espresso.@get_or_create"><code>Espresso.@get_or_create</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Same as <code>@get</code>, but creates new object from <code>default_expr</code> if it didn&#39;t exist before</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@get_or_return" href="#Espresso.@get_or_return"><code>Espresso.@get_or_return</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Same as <code>@get</code>, but immediately exits function and return <code>default_expr</code> if key doesn&#39;t exist.</p></div></div></section><pre><code class="language-none">Espresso.@inplacerule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@simple_rule" href="#Espresso.@simple_rule"><code>Espresso.@simple_rule</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Macro to add simplification rules. Example:</p><pre><code class="language-none">@simple_rule (-x * -y) (x * y)</code></pre><p>where <code>(-x * -y)</code> is a pattern to match expression and <code>(x * y)</code> is what it should be transformed to (see <code>rewrite()</code> to understand expression rewriting). Symbols Set(Symbol[:a, :b, :y, :x]) may be used as placeholders when defining new rules, all other symbols will be taken literally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.@tracked" href="#Espresso.@tracked"><code>Espresso.@tracked</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>Define a function or broadcasting rule for the specified signature which computes the result as for ordinary (not tracked) data and writes it to the graph.</p><p>Note: this function expects at least 1 parameter of TrackedReal or TrackedArray type with name <code>x</code>.</p></div></div></section><pre><code class="language-none">Espresso.AbstractExGraph</code></pre><pre><code class="language-none">Espresso.BufCodeGen</code></pre><pre><code class="language-none">Espresso.CONST_OPS</code></pre><pre><code class="language-none">Espresso.CUDA_NATIVE_RULES</code></pre><pre><code class="language-none">Espresso.CuCodeGen</code></pre><pre><code class="language-none">Espresso.CuVecCodeGen</code></pre><pre><code class="language-none">Espresso.DEFAULT_GRAPH</code></pre><pre><code class="language-none">Espresso.DEFAULT_PHS</code></pre><pre><code class="language-none">Espresso.DOT_OPS</code></pre><pre><code class="language-none">Espresso.Espresso</code></pre><pre><code class="language-none">Espresso.ExGraph</code></pre><pre><code class="language-none">Espresso.ExH</code></pre><pre><code class="language-none">Espresso.ExNode</code></pre><pre><code class="language-none">Espresso.FT</code></pre><pre><code class="language-none">Espresso.GPUCodeGen</code></pre><pre><code class="language-none">Espresso.INPLACE_PHS</code></pre><pre><code class="language-none">Espresso.INPLACE_RULES</code></pre><pre><code class="language-none">Espresso.KNOWN_MODULES</code></pre><pre><code class="language-none">Espresso.Mat</code></pre><pre><code class="language-none">Espresso.Num</code></pre><pre><code class="language-none">Espresso.Numeric</code></pre><pre><code class="language-none">Espresso.OLD_BCAST_OPS</code></pre><pre><code class="language-none">Espresso.OPT_PHS</code></pre><pre><code class="language-none">Espresso.OPT_VEC_RULES</code></pre><pre><code class="language-none">Espresso.OpName</code></pre><pre><code class="language-none">Espresso.PREPROCESS_RULES</code></pre><pre><code class="language-none">Espresso.RECOVER_LOWERED_RULES</code></pre><pre><code class="language-none">Espresso.SIMPLE_PHS</code></pre><pre><code class="language-none">Espresso.SIMPLE_RULES</code></pre><pre><code class="language-none">Espresso.SIMPLE_TO_DOT</code></pre><pre><code class="language-none">Espresso.Symbolic</code></pre><pre><code class="language-none">Espresso.TrackedArray</code></pre><pre><code class="language-none">Espresso.TrackedReal</code></pre><pre><code class="language-none">Espresso.Vec</code></pre><pre><code class="language-none">Espresso.VectorCodeGen</code></pre><pre><code class="language-none">Espresso.__construct</code></pre><pre><code class="language-none">Espresso.__construct_immutable</code></pre><pre><code class="language-none">Espresso._simplify</code></pre><pre><code class="language-none">Espresso.add_inplace_rule</code></pre><pre><code class="language-none">Espresso.add_renaming!</code></pre><pre><code class="language-none">Espresso.arg_names</code></pre><pre><code class="language-none">Espresso.arg_types</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.assign_chain" href="#Espresso.assign_chain"><code>Espresso.assign_chain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Collect all replacable variables from a chain of assignments in a graph. Variables <code>y</code> and <code>x</code> are considered replacable if there&#39;s a node <code>y = x</code> and both variables have the same set of guards. Note that this allows nodes to have different sets of indices.</p></div></div></section><pre><code class="language-none">Espresso.assign_chain!</code></pre><pre><code class="language-none">Espresso.assign_chain_index_replacements</code></pre><pre><code class="language-none">Espresso.autoselect_codegen</code></pre><pre><code class="language-none">Espresso.buffer_expr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.canonical" href="#Espresso.canonical"><code>Espresso.canonical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return canonical representation of a function name, e.g.:</p><pre><code class="language-none">Base.+  ==&gt; +
Main.+  ==&gt; + (resolved to Base.+)
Base.LinAlg.exp ==&gt; exp
Mod.foo ==&gt; Mod.foo</code></pre></div></div></section><pre><code class="language-none">Espresso.canonical_calls</code></pre><pre><code class="language-none">Espresso.cat</code></pre><pre><code class="language-none">Espresso.collect_deps</code></pre><pre><code class="language-none">Espresso.collect_deps!</code></pre><pre><code class="language-none">Espresso.concretise_types</code></pre><pre><code class="language-none">Espresso.convert_call</code></pre><pre><code class="language-none">Espresso.cos</code></pre><pre><code class="language-none">Espresso.cuda_buffer_expr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.dependencies" href="#Espresso.dependencies"><code>Espresso.dependencies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get names of dependenices of this node</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.dependents" href="#Espresso.dependents"><code>Espresso.dependents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For each variable in graph, calculate all variables that depend on it. This is essentially the opposite of <code>dependencies(nd::ExNode)</code>, but operates on variable names rather than nodes.</p></div></div></section><pre><code class="language-none">Espresso.depwarn_eingraph</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.destruct" href="#Espresso.destruct"><code>Espresso.destruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Replace all struct arguments by a list of their plain analogues. Example:</p><pre><code class="language-none">args = [:m, :x, :y]
types = (Linear, Matrix{Float64}, Matrix{Float64})
ex = :(sum((m.W * x .+ m.b) - y))

destruct(args, types, ex)
# ==&gt;
# ([:m_W, :m_b, :x, :y],
#  :(sum((m_W * x .+ m_b) - y)),
#  Dict(:(m.W) =&gt; :m_W, :(m.b) =&gt; :m_b))</code></pre></div></div></section><pre><code class="language-none">Espresso.destruct_inputs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.dot_expr" href="#Espresso.dot_expr"><code>Espresso.dot_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a list of symbols such as <code>[:x, :y, :z]</code> constructs expression <code>x.y.z</code>. This is useful for building expressions of qualified names such as <code>Base.LinAlg.exp</code>.</p></div></div></section><pre><code class="language-none">Espresso.eliminate_common</code></pre><pre><code class="language-none">Espresso.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.eval_codegen" href="#Espresso.eval_codegen"><code>Espresso.eval_codegen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For buffered codegens, return unbuffered version that can be used in evaluate!()</p></div></div></section><pre><code class="language-none">Espresso.eval_tracked!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.evaluate!" href="#Espresso.evaluate!"><code>Espresso.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Evaluate node, i.e. fill its <code>val</code> by evaluating node&#39;s expression using values of its dependencies.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.expand_const" href="#Espresso.expand_const"><code>Espresso.expand_const</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Expand all constant vars in a given expression</p></div></div></section><pre><code class="language-none">Espresso.expand_deps</code></pre><pre><code class="language-none">Espresso.expand_deps!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.expand_fixed_sequences" href="#Espresso.expand_fixed_sequences"><code>Espresso.expand_fixed_sequences</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Look at each node&#39;s dependencies and, if there are known pattern sequences, rewrite them in a more optimal way.</p></div></div></section><pre><code class="language-none">Espresso.expr_like</code></pre><pre><code class="language-none">Espresso.external_vars</code></pre><pre><code class="language-none">Espresso.field_values</code></pre><pre><code class="language-none">Espresso.find_indices</code></pre><pre><code class="language-none">Espresso.find_key</code></pre><pre><code class="language-none">Espresso.find_var_names</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.find_vars" href="#Espresso.find_vars"><code>Espresso.find_vars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>find_vars(ex; rec=true)</p><p>Same as <code>get_vars()</code>, but recursive by default</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.findex" href="#Espresso.findex"><code>Espresso.findex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find sub-expressions matching a pattern. Example:</p><pre><code class="language-none">ex = :(a * f(x) + b * f(y))
pat = :(f(_))
findex(pat, ex)   # ==&gt; [:(f(x)), :(f(y))]</code></pre></div></div></section><pre><code class="language-none">Espresso.findex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.flatten" href="#Espresso.flatten"><code>Espresso.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flattenx vector of vectors</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.flatten!" href="#Espresso.flatten!"><code>Espresso.flatten!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flatten vector of vectors in-place</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.flatten1" href="#Espresso.flatten1"><code>Espresso.flatten1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flatten one level of nested vectors</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.flatten_dots" href="#Espresso.flatten_dots"><code>Espresso.flatten_dots</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a list of expression arguments, flatten the dotted ones. Example:</p><pre><code class="language-none">args = [:foo, :([a, b, c]...)]
flatten_dots(args)
# ==&gt; [:foo, :a, :b, :c]</code></pre></div></div></section><pre><code class="language-none">Espresso.flip</code></pre><pre><code class="language-none">Espresso.forall_indices</code></pre><pre><code class="language-none">Espresso.forall_sum_indices</code></pre><pre><code class="language-none">Espresso.force_bitness</code></pre><pre><code class="language-none">Espresso.func_expr</code></pre><pre><code class="language-none">Espresso.func_mod</code></pre><pre><code class="language-none">Espresso.func_name</code></pre><pre><code class="language-none">Espresso.funexpr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.fuse_assigned" href="#Espresso.fuse_assigned"><code>Espresso.fuse_assigned</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Collapse unnecessary assignment nodes, rewriting all affected nodes. Example:</p><pre><code class="language-none">tmp1 = x * y
z = tmp1</code></pre><p>will be rewritten to</p><pre><code class="language-none">z = x * y</code></pre></div></div></section><pre><code class="language-none">Espresso.fuse_broadcasting</code></pre><pre><code class="language-none">Espresso.fuse_broadcasting_node</code></pre><pre><code class="language-none">Espresso.generate_code</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.genname" href="#Espresso.genname"><code>Espresso.genname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate a new unique name for intermediate variable in graph</p></div></div></section><pre><code class="language-none">Espresso.gennames</code></pre><pre><code class="language-none">Espresso.get_arg_names</code></pre><pre><code class="language-none">Espresso.get_arg_types</code></pre><pre><code class="language-none">Espresso.get_caller_module</code></pre><pre><code class="language-none">Espresso.get_default_graph</code></pre><pre><code class="language-none">Espresso.get_indices</code></pre><pre><code class="language-none">Espresso.get_method</code></pre><pre><code class="language-none">Espresso.get_or_generate_argnames</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.get_source_at" href="#Espresso.get_source_at"><code>Espresso.get_source_at</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Looks up the source of <code>method</code> in the file path found in <code>method</code>. Returns the AST and source string, might throw an LoadError if file not found.</p></div></div></section><pre><code class="language-none">Espresso.get_source_file</code></pre><pre><code class="language-none">Espresso.get_var_names</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.get_vars" href="#Espresso.get_vars"><code>Espresso.get_vars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get variables (<code>Symbol</code> or <code>Expr(:ref)</code>) involved in exprssion</p></div></div></section><pre><code class="language-none">Espresso.get_vars!</code></pre><pre><code class="language-none">Espresso.getcategory</code></pre><pre><code class="language-none">Espresso.getexpr</code></pre><pre><code class="language-none">Espresso.getexpr_kw</code></pre><pre><code class="language-none">Espresso.getguards</code></pre><pre><code class="language-none">Espresso.getsize</code></pre><pre><code class="language-none">Espresso.getvalue</code></pre><pre><code class="language-none">Espresso.getvar</code></pre><pre><code class="language-none">Espresso.gpu_buffer_expr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.graph_hash" href="#Espresso.graph_hash"><code>Espresso.graph_hash</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A single number to represent a graph. Insensitive to variable names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.inc_var_name" href="#Espresso.inc_var_name"><code>Espresso.inc_var_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a symbolic name, either adds <code>2</code> to the end or increment existing number. Example:</p><pre><code class="language-none">inc_var_name(:x)   # ==&gt; x2
inc_var_name(:x2)  # ==&gt; x3</code></pre></div></div></section><pre><code class="language-none">Espresso.include</code></pre><pre><code class="language-none">Espresso.indexof</code></pre><pre><code class="language-none">Espresso.inline_nodes</code></pre><pre><code class="language-none">Espresso.inline_subgraphs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.is_bcast" href="#Espresso.is_bcast"><code>Espresso.is_bcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if all operations in this expression are broadcasting</p></div></div></section><pre><code class="language-none">Espresso.is_bcast_vec</code></pre><pre><code class="language-none">Espresso.is_calculable</code></pre><pre><code class="language-none">Espresso.iscall</code></pre><pre><code class="language-none">Espresso.isconv</code></pre><pre><code class="language-none">Espresso.isindexed</code></pre><pre><code class="language-none">Espresso.isparameters</code></pre><pre><code class="language-none">Espresso.isplaceholder</code></pre><pre><code class="language-none">Espresso.isref</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.isstruct" href="#Espresso.isstruct"><code>Espresso.isstruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if an object is of a struct type, i.e. not a number or array</p></div></div></section><pre><code class="language-none">Espresso.istemp</code></pre><pre><code class="language-none">Espresso.istracked</code></pre><pre><code class="language-none">Espresso.jlhome</code></pre><pre><code class="language-none">Espresso.juliabasepath</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.make_call_expr" href="#Espresso.make_call_expr"><code>Espresso.make_call_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Make call expression from function name, ordinary and keyword arguments.</p><p>The reverse of this operation is parse<em>call</em>expr()</p></div></div></section><pre><code class="language-none">Espresso.make_elementwise</code></pre><pre><code class="language-none">Espresso.make_func_expr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.make_indexed" href="#Espresso.make_indexed"><code>Espresso.make_indexed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Make indexed variable. Examples:</p><pre><code class="language-none">make_indexed(:x, [])       ==&gt; :x
make_indexed(:x, [:i,:j])  ==&gt; :(x[i,j])</code></pre><p>See also: split_indexed</p></div></div></section><pre><code class="language-none">Espresso.make_kw_params</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.make_subgraph" href="#Espresso.make_subgraph"><code>Espresso.make_subgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Find definition of a called function and build its subgraph ready for inlining</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.matchex" href="#Espresso.matchex"><code>Espresso.matchex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Match expression <code>ex</code> to a pattern <code>pat</code>, return nullable dictionary of matched symbols or rpatpressions. Example:</p><pre><code class="language-none">ex = :(u ^ v)
pat = :(_x ^ _n)
matchex(pat, ex)
# ==&gt; Union{ Dict{Symbol,Any}(:_n=&gt;:v,:_x=&gt;:u), Void }</code></pre><p>NOTE: two symbols match if they are equal or symbol in pattern is a placeholder. Placeholder is any symbol that starts with &#39;<em>&#39;. It&#39;s also possible to pass list of placeholder names (not necessarily starting wiht &#39;</em>&#39;) via <code>phs</code> parameter:</p><pre><code class="language-none">ex = :(u ^ v)
pat = :(x ^ n)
matchex(pat, ex; phs=Set([:x, :n]))
# ==&gt; Union{ Dict{Symbol,Any}(:n=&gt;:v,:x=&gt;:u), Void } </code></pre><p>Several elements may be matched using <code>...</code> expression, e.g.:</p><pre><code class="language-none">ex = :(A[i, j, k])
pat = :(x[I...])
matchex(pat, ex; phs=Set([:x, :I]))
# ==&gt; Union{ Dict(:x=&gt;:A, :I=&gt;[:i,:j,:k]), Void }</code></pre><p>Optional parameters:</p><ul><li><p>phs::Set{Symbol} = DEFAULT_PHS[1]     A set of placeholder symbols</p></li><li><p>allow_ex::Boolean = true     Allow matchinng of symbol pattern to an expression. Example:</p><pre><code class="language-none">    matchex(:(_x + 1), :(a*b + 1); allow_ex=true)  # ==&gt; matches
    matchex(:(_x + 1), :(a*b + 1); allow_ex=false)  # ==&gt; doesn&#39;t match</code></pre></li><li><p>exact::Boolean = false     Allow matching of the same expression to different keys</p><pre><code class="language-none">    matchex(:(_x + _y), :(a + a); exact=false) # ==&gt; matches
    matchex(:(_x = _y), :(a + a); exact=true)  # ==&gt; doesn&#39;t match</code></pre></li></ul></div></div></section><pre><code class="language-none">Espresso.matchex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.matchingex" href="#Espresso.matchingex"><code>Espresso.matchingex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Check if expression matches pattern. See <code>matchex()</code> for details.</p></div></div></section><pre><code class="language-none">Espresso.mergeex</code></pre><pre><code class="language-none">Espresso.mk_eval_expr</code></pre><pre><code class="language-none">Espresso.mul!</code></pre><pre><code class="language-none">Espresso.named_field_values</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.parse!" href="#Espresso.parse!"><code>Espresso.parse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Parse Julia expression and build ExGraph in-place. Return the the output variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.parse_call_args" href="#Espresso.parse_call_args"><code>Espresso.parse_call_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a call expression, parse regular and keyword arguments</p><p>See also: split_params</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.parse_call_expr" href="#Espresso.parse_call_expr"><code>Espresso.parse_call_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Parse call expression into function name, ordinary and keyword arguments. :kw and :parameters arguments are treated the same way.</p><p>The reverse of this operation is make<em>call</em>expr()</p></div></div></section><pre><code class="language-none">Espresso.preprocess</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.prop_subs" href="#Espresso.prop_subs"><code>Espresso.prop_subs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Propagate substitution rules. Example:</p><pre><code class="language-none">Dict(
    :x =&gt; y,
    :y =&gt; z
)</code></pre><p>is transformed into:</p><pre><code class="language-none">Dict(
    :x =&gt; z,
    :y =&gt; z
)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.recover_lowered" href="#Espresso.recover_lowered"><code>Espresso.recover_lowered</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Try to recover an expression from a lowered form. Example:</p><pre><code class="language-none">ex = (Main.sum)((Base.literal_pow)(Main.^, (Base.broadcast)(Main.-, (Main.predict)(W, b, x), y), (Core.apply_type)(Base.Val, 2)))</code></pre></div></div></section><pre><code class="language-none">Espresso.recover_lowered_rec</code></pre><pre><code class="language-none">Espresso.reindex_from_beginning</code></pre><pre><code class="language-none">Espresso.remember_size!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.remove_unused" href="#Espresso.remove_unused"><code>Espresso.remove_unused</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Removes unused variables from multiline expressions, e.g. in:</p><pre><code class="language-none">x = u * v
y = x + 1
z = 2x</code></pre><p><code>y</code> isn&#39;t used to compute output variable <code>z</code>, so it&#39;s removed:</p><pre><code class="language-none">x = u * v
z = 2x</code></pre></div></div></section><pre><code class="language-none">Espresso.rename</code></pre><pre><code class="language-none">Espresso.rename!</code></pre><pre><code class="language-none">Espresso.rename_from_beginning</code></pre><pre><code class="language-none">Espresso.rename_repeated</code></pre><pre><code class="language-none">Espresso.reparse</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.replace_inner_constr" href="#Espresso.replace_inner_constr"><code>Espresso.replace_inner_constr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Replace all calls to an inner constructor with the corresponding outer constructor</p></div></div></section><pre><code class="language-none">Espresso.replace_slots</code></pre><pre><code class="language-none">Espresso.reset_default_graph!</code></pre><pre><code class="language-none">Espresso.reset_tape</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.rewrite" href="#Espresso.rewrite"><code>Espresso.rewrite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rewrite(ex, pat, rpat)</p><p>Rewrite expression <code>ex</code> according to a transform from pattern <code>pat</code> to a substituting expression <code>rpat</code>. Example (derivative of x^n):</p><pre><code class="language-none">ex = :(u ^ v)
pat = :(_x ^ _n)
rpat = :(_n * _x ^ (_n - 1))
rewrite(ex, pat, rpat) # ==&gt; :(v * u ^ (v - 1))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.rewrite_all" href="#Espresso.rewrite_all"><code>Espresso.rewrite_all</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rewrite_all(ex, rules)</p><p>Recursively rewrite an expression according to a list of rules like [pat =&gt; rpat] Example:</p><pre><code class="language-none">ex = :(foo(bar(foo(A))))
rules = [:(foo(x)) =&gt; :(quux(x)),
         :(bar(x)) =&gt; :(baz(x))]
rewrite_all(ex, rules; phs=[:x])
# ==&gt; :(quux(baz(quux(A))))</code></pre></div></div><div><div><p>rewrite_all(ex, pat, rpat)</p><p>Recursively rewrite all occurrences of a pattern in an expression. Example:</p><pre><code class="language-none">ex = :(foo(bar(foo(A))))
pat = :(foo(x))
rpat = :(quux(x))
rewrite_all(ex, pat, rpat; phs=[:x])
# ==&gt; :(quux(bar(quux(A))))</code></pre></div></div></section><pre><code class="language-none">Espresso.sanitize</code></pre><pre><code class="language-none">Espresso.set_default_graph</code></pre><pre><code class="language-none">Espresso.set_default_placeholders</code></pre><pre><code class="language-none">Espresso.setexpr!</code></pre><pre><code class="language-none">Espresso.setexpr_kw!</code></pre><pre><code class="language-none">Espresso.setguards!</code></pre><pre><code class="language-none">Espresso.setvalue!</code></pre><pre><code class="language-none">Espresso.setvar!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.simplify" href="#Espresso.simplify"><code>Espresso.simplify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Simplify expression <code>x</code> by applying a set of rules. Common examples of simplification include calculation of fully numeric subexpressions, removing needless multiplication by 1, etc.</p><p>Use macro <code>@simple_rule</code> to add new simplification rules.</p></div></div></section><pre><code class="language-none">Espresso.sin</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.split_indexed" href="#Espresso.split_indexed"><code>Espresso.split_indexed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split possibly indexed variable into a name and indices. Examples:</p><pre><code class="language-none">split_indexed(:x)         ==&gt; (:x, [])
split_indexed(:(x[i,j]))  ==&gt; (:x, [:i,:j])</code></pre><p>See also: make_indexed</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.split_params" href="#Espresso.split_params"><code>Espresso.split_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split parameters of a function signature, returning a list of (param name, param type) tuples and a list of keyword parameters.</p><p>See also: parse<em>call</em>args</p></div></div></section><pre><code class="language-none">Espresso.squeeze_sum</code></pre><pre><code class="language-none">Espresso.squeeze_sum_1</code></pre><pre><code class="language-none">Espresso.squeeze_sum_2</code></pre><pre><code class="language-none">Espresso.struct_like</code></pre><pre><code class="language-none">Espresso.subgraph_interm_subs_table</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.subs" href="#Espresso.subs"><code>Espresso.subs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Substitute symbols in <code>ex</code> according to substitute table <code>st</code>. Example:</p><pre><code class="language-none">ex = :(x ^ n)
subs(ex, x=2)            # ==&gt; :(2 ^ n)</code></pre><p>alternatively:</p><pre><code class="language-none">subs(ex, Dict(:x =&gt; 2))  # ==&gt; :(2 ^ n)</code></pre><p>If <code>ex</code> contains a :(xs...) argument and <code>st</code> contains an array-valued sabstitute for it, the substitute will be flattened:</p><pre><code class="language-none">ex = :(foo(xs...))
subs(ex, Dict(:xs =&gt; [:a, :b, :c]))
# ==&gt; :(foo(a, b, c))</code></pre></div></div></section><pre><code class="language-none">Espresso.subs_bcast_with_dot</code></pre><pre><code class="language-none">Espresso.sum_1</code></pre><pre><code class="language-none">Espresso.sum_2</code></pre><pre><code class="language-none">Espresso.sum_indices</code></pre><pre><code class="language-none">Espresso.swap_default_graph!</code></pre><pre><code class="language-none">Espresso.to_block</code></pre><pre><code class="language-none">Espresso.to_buffered</code></pre><pre><code class="language-none">Espresso.to_context</code></pre><pre><code class="language-none">Espresso.to_dict</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.to_einsum_expr" href="#Espresso.to_einsum_expr"><code>Espresso.to_einsum_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert ExNode to a fortmat compatible with Einsum.jl</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.to_expr" href="#Espresso.to_expr"><code>Espresso.to_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert ExNode to a full expression, e.g. for vectorized notation:</p><pre><code class="language-none">z = x + y</code></pre><p>or for indexed notation:</p><pre><code class="language-none">z[i] = x[i] + y[i]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.to_expr_kw" href="#Espresso.to_expr_kw"><code>Espresso.to_expr_kw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Same as to_expr(ExNode), but includes keyword arguments if any</p></div></div></section><pre><code class="language-none">Espresso.to_inplace</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.topsort" href="#Espresso.topsort"><code>Espresso.topsort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Sort graph topologically</p></div></div></section><pre><code class="language-none">Espresso.topsort_visit!</code></pre><pre><code class="language-none">Espresso.track_bcast</code></pre><pre><code class="language-none">Espresso.track_call</code></pre><pre><code class="language-none">Espresso.tracked</code></pre><pre><code class="language-none">Espresso.tracked_exgraph</code></pre><pre><code class="language-none">Espresso.tracked_val</code></pre><pre><code class="language-none">Espresso.tryeval</code></pre><pre><code class="language-none">Espresso.tryoptimize</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.tryrewrite" href="#Espresso.tryrewrite"><code>Espresso.tryrewrite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Same as rewrite, but returns Union{Expr, Void} and doesn&#39;t throw an error when expression doesn&#39;t match pattern</p></div></div></section><pre><code class="language-none">Espresso.unzip</code></pre><pre><code class="language-none">Espresso.value</code></pre><pre><code class="language-none">Espresso.varidxs</code></pre><pre><code class="language-none">Espresso.varname</code></pre><pre><code class="language-none">Espresso.with_guards</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.with_indices" href="#Espresso.with_indices"><code>Espresso.with_indices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate index names and make an indexed variable using them</p></div></div></section><pre><code class="language-none">Espresso.with_keywords</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.without" href="#Espresso.without"><code>Espresso.without</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove rpatpression conforming to a pattern. Example:</p><pre><code class="language-none">ex = :(x * (m == n))
pat = :(_i == _j)
ex = without(ex, pat)  # ==&gt; :x</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Espresso.without_keywords" href="#Espresso.without_keywords"><code>Espresso.without_keywords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Remove all :kw and :parameters nodes from a call expression</p></div></div></section><pre><code class="language-none">Espresso.without_types</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
