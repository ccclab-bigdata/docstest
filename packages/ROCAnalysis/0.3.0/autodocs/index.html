<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ROCAnalysis.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ROCAnalysis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.AUC" href="#ROCAnalysis.AUC"><code>ROCAnalysis.AUC</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>AUC(::roc; pfa=1.0, pmiss=1.0, normalize=true)</code> computes the traditional Area Under the Curve with a sense <code>AUC → 1</code> indicating better performance.</p><p>Optional parameters <code>pfa</code> or <code>pmiss</code> limit integration over only part of the ROC curve. <code>normalize</code> indicates comparing the partial ROC to the trivial ROC.</p><p>You can also call this function as <code>AUC(targets::Vector, nontargets::Vector; kwargs...)</code></p></div></div></section><pre><code class="language-none">ROCAnalysis.ArrayOrReal</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.DCF" href="#ROCAnalysis.DCF"><code>ROCAnalysis.DCF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DCF</code> is a type that holds one or more cost functions with which the performance of a two-class classifier can be assessed.  Any of the fields can be either a scalar or an array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.DataFrame" href="#DataFrames.DataFrame"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Dataframe(::Roc)</code> converts a <code>Roc</code> object in a datframe with columns:</p><ul><li><p><code>pfa</code> the false alarm rate</p></li><li><p><code>pmiss</code> the miss rate</p></li><li><p><code>thres</code> the thereshold, separating this line&#39;s pfa and pmiss from the next</p></li><li><p><code>chull</code> indicating if this point is on the convex hull of the ROC curve</p></li><li><p><code>llr</code> the optimal log-likelihood-ratio score for all data points contributing to the ROC line segment from this line to the next</p></li></ul></div></div></section><pre><code class="language-none">ROCAnalysis.ROCAnalysis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.Roc" href="#ROCAnalysis.Roc"><code>ROCAnalysis.Roc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Roc</code> is a type that stores the essential performance information that can be extracted from a set of supervised trials, i.e., target and non-target scores from a two-class classifier.  Apart from the (minimalized) arrays for probabilities of false-alarm and miss–-the coordinates of the ROC curve–-, they are the threshold for these, a boolean whether-or-not this point lies on the convex hull, and the associated optimal log-likelihood-ratio associated to the line segment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.TNT" href="#ROCAnalysis.TNT"><code>ROCAnalysis.TNT</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>TNT(tar, non</code>) is a type that holds target and non-target scores in a test for a two-class classifier.</p></div></div></section><pre><code class="language-none">ROCAnalysis.apeplot</code></pre><pre><code class="language-none">ROCAnalysis.applyfactor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.auc" href="#ROCAnalysis.auc"><code>ROCAnalysis.auc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>AUC(::roc; pfa=1.0, pmiss=1.0, normalize=true)</code> computes the Area Under the Curve with a sense <code>auc → 0</code> indicating better performance.</p><p>Optional parameters <code>pfa</code> or <code>pmiss</code> limit integration over only part of the ROC curve. <code>normalize</code> indicates comparing the partial ROC to the trivial ROC.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.ber" href="#ROCAnalysis.ber"><code>ROCAnalysis.ber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ber()</code>, the Bayes Error Rate.  This computes the expected error rate given a set of supervised trials, the log-likelihood-ratio scores <code>tar</code> and <code>non</code>, and a threshold based on a given a cost function specified by its prior log-odds (see <code>plo()</code>).</p><p>If the scores <code>tar</code> and <code>non</code> are well-calibrated log-likelihood-ratios, the optimum decision threshold that minimizes the decision cost function <code>dcf</code> is surprisingly simple,</p><pre><code class="language-none">θ = -plo(dcf).</code></pre><p>This function computes the actual cost for such decisions, given the test scores.</p><p>Arguments:</p><ul><li><code>tar::Vector</code>, <code>non::Vector</code>, <code>plo</code>: target and non-target llr</li></ul><p>scores, and prior log odds.  Here, <code>plo</code> may be a vector, resulting in multiple Bayes error rates.</p><ul><li><code>r::Roc</code>, <code>plo</code>: a <code>Roc</code> structure computed with <code>roc(;collapse=false)</code>.</li></ul><p>It is mandatory that the Roc object is not collapsed, because the actual cost may occur for a threshold between two &quot;corner&quot; points of the ROC curve.  A <code>Roc</code> structure is useful for computing the minimum Bayes Error Rate for multiple cost functions–-in this case the <code>Roc</code> may be <code>collapse</code>d.</p><ul><li><code>; thres</code>: an optional threshold, overriding the theoretical</li></ul><p>optimum described above.  This can be used if the scores are not correctly calibrated.</p></div></div></section><pre><code class="language-none">ROCAnalysis.ber_famiss</code></pre><pre><code class="language-none">ROCAnalysis.binscores</code></pre><pre><code class="language-none">ROCAnalysis.binsearch</code></pre><pre><code class="language-none">ROCAnalysis.changepoints</code></pre><pre><code class="language-none">ROCAnalysis.chllr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.cllr" href="#ROCAnalysis.cllr"><code>ROCAnalysis.cllr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>cllr(tar, non)</code> computes the cost of the log-likelihood-ratio, for log-likelihood-ratio (llr) scores <code>tar</code> and <code>non</code> (target scores and non-target scores).  Target an non-target llr&#39;s are those for which  the numerator <code>H1</code> and denominator <code>H2</code> hypothesis are actually true in the log-likelihood-ratio </p><pre><code class="language-none">llr(x) = p(x|H1) / p(x|H2)</code></pre><p>where <code>x</code> is the test data for a system trying to disciminate between <code>H1</code> and <code>H2</code> given <code>x</code>.  </p><p>The Cllr of a perfect system, assigning a llr of <code>+Inf</code> t otarget scores and <code>-Inf</code> to non-target scores is 0, for a system that is indifferent, producing a <code>llr=0</code> for every input <code>x</code> the <code>Cllr=1</code>.   Please note that, for badly calibrated systems, <code>Cllr&gt;1</code>.  The units of Cllr are measured in <em>bits</em>,  and cllr can be seen as the average amount of information per trial that is <em>not</em> extracted from the  data. </p><p>Cllr measures the <em>calibration</em> as well as <em>discrimination</em> ability of a system.  Discrimination  entails the ability to produces target scores that are, typically, much higher than non-target scores.   Calibration entails that for every individual <code>x</code> an optimal Bayes decision can be made if a  cost function is known.  </p></div></div></section><pre><code class="language-none">ROCAnalysis.costfactor</code></pre><pre><code class="language-none">ROCAnalysis.crossing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.dcf" href="#ROCAnalysis.dcf"><code>ROCAnalysis.dcf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dcf()</code>.  Compute the classical decision cost function:</p><pre><code class="language-none">dcf = ptar Cmiss pmiss + (1-ptar) Cfa pfa.</code></pre><p>The <em>relative</em> value of the cost function is only determined by the ratio</p><pre><code class="language-none">oeff = (ptar/(1-ptar) (Cmiss/Cfa).</code></pre><p>Therefore, this function is computed using <code>ber()</code> and scaling accordingly.  Arguments:</p><ul><li><p><code>tar</code>, <code>non</code>: target and non-target scores</p></li><li><p><code>tnt::TNT</code>: a <code>TNT</code> object containing target and non-target scores.</p></li><li><p><code>r::Roc</code>: a <code>Roc</code> object, the result of <code>roc()</code></p></li><li><p><code>; d::DCF</code>: a decision cost function, default <code>getdcf()</code>.  This can be a vector or DCFs.</p></li><li><p><code>; thres</code>: the threshold used to make decisions, default <code>-plo(d)</code></p></li><li><p><code>; norm</code>: are the costs normalized to a trivial system deciding using the prior only, default: <code>false</code></p></li></ul></div></div></section><pre><code class="language-none">ROCAnalysis.detplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.eer" href="#ROCAnalysis.eer"><code>ROCAnalysis.eer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>eer(tar, non)</code> computes a simple approximation to the Equal Error Rate, the intersection of the ROC with the line <code>y=x</code>, i.e., the error rate at which the false positive rate and the false negative rate are approximately equal.</p><p>For a more consistent interpretation and implementation of the EER, please consider <code>eerch()</code>, the Equal Error Rate - Convex Hull computation.</p></div></div></section><pre><code class="language-none">ROCAnalysis.eer_experimental</code></pre><pre><code class="language-none">ROCAnalysis.eer_so</code></pre><pre><code class="language-none">ROCAnalysis.eer_sorted</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.eerch" href="#ROCAnalysis.eerch"><code>ROCAnalysis.eerch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>eerch()</code> computes the Equal Error Rate using the Convex Hull interpretation.  This computes the error rate at which the convex hull of the ROC curve crosses the <code>y=x</code> diagonal in the ROC.</p><p>This value is less sensitive to trial sampling at low number of trials, and has the interpretation of `the maximum while vary prior of the minimum decision costs&#39;–-a useful quantity in decision cost function analysis of a two class classification system.</p><p>Arguments:</p><ul><li><p><code>r::Roc</code>: an object of type <code>Roc</code>, the result of <code>roc()</code></p></li><li><p><code>tar, non</code>: Vectors of target and non-target scores</p></li><li><p><code>pfa, pmiss, ch</code>: Vectors of the false positive and false negative rate, and an array indicating</p></li></ul><p>the membership of the <code>(pfa, pmiss)</code> point on the convex hull.  These points are found by <code>roc()</code>.</p></div></div></section><pre><code class="language-none">ROCAnalysis.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.getdcf" href="#ROCAnalysis.getdcf"><code>ROCAnalysis.getdcf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>getdcf()</code> retrieves the current valua of the DCF parameters.</p></div></div></section><pre><code class="language-none">ROCAnalysis.global_dcf</code></pre><pre><code class="language-none">ROCAnalysis.include</code></pre><pre><code class="language-none">ROCAnalysis.isleft</code></pre><pre><code class="language-none">ROCAnalysis.llrplot</code></pre><pre><code class="language-none">ROCAnalysis.logit</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.minber" href="#ROCAnalysis.minber"><code>ROCAnalysis.minber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>minber()</code>: The minimum Byes Error Rate for a set of socres, found after an optimal score-to-llr (log-likelihood-ratio) transformation. The optimal transformation corresponds to the convex hull of the ROC, where the optimal llr values correspont to the negative log of the slope of the appropriate line segment spanning the ROC.  This is equivalent to running the pool-adjacent-violators algorithm on the test data.</p><p>In order to compute <code>minber()</code> for multiple cost functions, as in a Normalized Bayes Error Rate plot, it is advantageous to compute a <code>Roc</code> object once.</p><p>Arguments: see <code>ber()</code>.</p></div></div></section><pre><code class="language-none">ROCAnalysis.minber_famiss</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.mincllr" href="#ROCAnalysis.mincllr"><code>ROCAnalysis.mincllr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>mincllr(tar, non)</code> computes the <code>cllr</code> of target and non-target scores after an optimal transformation of the data.  This allows for measuring the disrimination performance of a system in the units of <code>cllr</code>, which are bits. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.mindcf" href="#ROCAnalysis.mindcf"><code>ROCAnalysis.mindcf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>mindcf()</code> computes the minimum costs of the classical decision cost function (see <code>dcf()</code>) that can be obtained by varying the threshold. Arguments are the same as for <code>dcf()</code>, except that there is no threshold.</p><p>This function uses <code>minber()</code> and scales accordingly.</p></div></div></section><pre><code class="language-none">ROCAnalysis.missing</code></pre><pre><code class="language-none">ROCAnalysis.nbeplot</code></pre><pre><code class="language-none">ROCAnalysis.normfactor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.oeff" href="#ROCAnalysis.oeff"><code>ROCAnalysis.oeff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>oeff()</code>, the effective prior odds given cost function parameters.  Arguments are either:</p><ul><li><p><code>ptar, cfa, cmiss</code>: Scalars or Vectors of the prior of a target, the cost of a false positive and the cost of a false negative</p></li><li><p><code>dcf::DCF</code>: a <code>DCF</code> object containing <code>ptar</code>, <code>cfa</code> and <code>cmiss</code>.</p></li></ul></div></div></section><pre><code class="language-none">ROCAnalysis.optllr</code></pre><pre><code class="language-none">ROCAnalysis.pav</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.peff" href="#ROCAnalysis.peff"><code>ROCAnalysis.peff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>peff()</code>, the effective prior given cost function parameters. Arguments are either:</p><ul><li><p><code>ptar, cfa, cmiss</code>: Scalars or Vectors of the prior of a target, the cost of a false positive and the cost of a false negative</p></li><li><p><code>dcf::DCF</code>: a <code>DCF</code> object containing <code>ptar</code>, <code>cfa</code> and <code>cmiss</code>.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.plo" href="#ROCAnalysis.plo"><code>ROCAnalysis.plo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>plo()</code>, the prior log-odds given cost function parameters. Arguments are either:</p><ul><li><p><code>ptar, cfa, cmiss</code>: Scalars or Vectors of the prior of a target, the cost of a false positive and the cost of a false negative</p></li><li><p><code>dcf::DCF</code>: a <code>DCF</code> object containing <code>ptar</code>, <code>cfa</code> and <code>cmiss</code>.</p></li></ul></div></div></section><pre><code class="language-none">ROCAnalysis.plot</code></pre><pre><code class="language-none">ROCAnalysis.pnorm</code></pre><pre><code class="language-none">ROCAnalysis.qnorm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.roc" href="#ROCAnalysis.roc"><code>ROCAnalysis.roc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>roc(tar, non; laplace, collapse)</code> computes the essential statistics for evaluation of the performance of a two-class classifier.  The true class of the scores is encoded in the array in which they appear, i.e., <code>tar</code>get or <code>non</code>-target scores.</p><p>The results are given in a type <code>Roc</code>, containing the receiver-operating-characteristics (ROC) data for this test.</p><p>Optional arguments:</p><ul><li><code>collapse=true</code>, indicating whether the resulting araays for the probability of</li></ul><p>false positives (alarms) and negatives (misses) should be collapsed, i.e., consecutive points on the ROC that have the same false positive or false negatove rate are removed, retaining only the `corner&#39; points of the ROC.</p><ul><li><code>laplace=false</code>, indicating whether two additional data points at either end of the score scale</li></ul><p>should be added to the target an dnon-target scores.  This corresponds to the Laplace prior, and has a result of limiting the magnitude of the optimal log-likelihood-ratio associated with the line segments of the convex hull of the ROC.</p></div></div></section><pre><code class="language-none">ROCAnalysis.rochull</code></pre><pre><code class="language-none">ROCAnalysis.rocplot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ROCAnalysis.setdcf" href="#ROCAnalysis.setdcf"><code>ROCAnalysis.setdcf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>setdcf()</code> allows a global decision cost function to be set.  This DCF can be used in <code>dcf()</code> and <code>mindcf()</code>.   The decision cost function is defined as</p><pre><code class="language-none">dcf = ptar Cmiss pmiss + (1-ptar) Cfa pfa.</code></pre><p>and is defined by the parameters <code>ptar</code> (the target prior), <code>Cfa</code> (the cost of a false positive) and <code>Cmiss</code> (the cost of a false negative.  Arguments:</p><ul><li><p><code>ptar</code>. The target prior, default <code>0.5</code>.</p></li><li><p><code>cfa</code>.  The cost of a false positive (false alarm), default <code>1</code></p></li><li><p><code>cmiss</code>.  The cost of a false negative (miss), default <code>1</code>.</p></li></ul><p>Multiple simultaneous cost functions can be set by specifying any, or a combination, of these parameters as Vectors.</p><p>The current values of the parameters of the DCF can be found using <code>getdcf()</code>.</p></div></div></section><pre><code class="language-none">ROCAnalysis.sigmoid</code></pre><pre><code class="language-none">ROCAnalysis.softplus</code></pre><pre><code class="language-none">ROCAnalysis.sortscores</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
