<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ROCAnalysis.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ROCAnalysis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Install-1">Install</a></li><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Synopsis-1">Synopsis</a></li><li><a class="toctext" href="#Receiver-Operating-Characteristic-1">Receiver Operating Characteristic</a></li><li><a class="toctext" href="#Error-rates-1">Error rates</a></li><li><a class="toctext" href="#DET-plot-1">DET plot</a></li><li><a class="toctext" href="#Single-numbered-metrics-1">Single-numbered metrics</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Notes-1">Notes</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ROCAnalysis.jl-1" href="#ROCAnalysis.jl-1">ROCAnalysis.jl</a></h1><p><a href="https://travis-ci.org/davidavdav/ROCAnalysis.jl"><img src="https://travis-ci.org/davidavdav/ROCAnalysis.jl.svg?branch=master" alt="Build Status"/></a></p><h2><a class="nav-anchor" id="Install-1" href="#Install-1">Install</a></h2><pre><code class="language-julia">Pkg.add(&quot;ROCAnalysis&quot;)</code></pre><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Receiver Operating Characteristic Analysis functions for evaluation probabilistic binary classifiers.   Allows efficient plotting of ROC curves, and many more things. </p><p>Please note there is an alternative implementation under <a href="https://github.com/diegozea/ROC.jl">a similar name</a>, and support for ROC analysis also exists in <a href="https://github.com/lindahua/MLBase.jl">MLBase</a>. </p><p>Our implementation is more geared towards:</p><ul><li>large amounts of data, with efficient ROC statistics calculation</li><li>Decision Cost Function analysis</li><li>Detection Error Trade-off (DET) analysis</li><li>ROC convex hull computation, analysis and EER-interpretation</li><li>Optimal Likelihood Ratio computation</li></ul><p>The development roadmap is largely based on the functionality in a similar R package <a href="https://github.com/davidavdav/ROC">ROC</a>. </p><h2><a class="nav-anchor" id="Synopsis-1" href="#Synopsis-1">Synopsis</a></h2><p>An <a href="ROCAnalysis.ipynb">annotated jupyter notebook</a> of the code below can be found <a href="http://nbviewer.jupyter.org/github/davidavdav/ROCAnalysis.jl/blob/master/ROCAnalysis.ipynb">here</a>.</p><pre><code class="language-julia">using ROCAnalysis
## Produce some well-calibrated log-likelihood-ratio scores for target and non-target class:
tar =  2 + 2randn(1000)
non = -2 + 2randn(100000)
## quick estimate of equal error rate, should be close to pnorm(-1) = 0.5 + 0.5erf(-1/√2)
eer(tar, non) 
## compute full ROC statistics
r = roc(tar, non)
## accurate computation of the equal error rate, using the convex hull
eerch(r)
## roc plot, we plot errors (false negatives against false positives) rather than hits vs. false alarms.
using Winston ## or perhaps another plotting package
plot(r)
## The &quot;Detection Error Tradeoff&quot; plot, this should give a more/less straight line
detplot(r)
## compute the Area Under the ROC, should be close to 0.078
auc(r)
## define a decision cost function by its parameter p_tar=0.01, Cfa=1, Cmiss=10 (NIST SRE 2008 setting)
d = DCF(0.01, 1, 10)
## `actual costs&#39; using a threshold of scores at -plo(d) (minus prior log odds)
plo(d)
dcf(tar, non, d=d)
## Or use a different threshold, e.g., zero
dcf(tar, non, d=d, thres=0)
## `minimal costs&#39; using an optimal threshold
mindcf(r, d=d)
## define an array of DCFs, and compute the decision costs for these, using a threshold at -plo
d = DCF([0.001, 0.01, 0.1, 0.5, 0.9, 0.99, 0.999], 1, 1)
dcf(tar, non, d=d)
## same, but normalized to costs of decisions based on the prior alone
dcf(tar, non, d=d, norm=true)
## prior log odds, thre crucial combination of cost parameters, log(p_tar / (1-p_tar) Cmiss / Cfa)
plo(d)
## now scan the Bayes error rate (similar to the dcf above) for a range of prior log odds, and plot
## This is known as the Applied Probability of Error plot
apeplot(r)
## The area under the red curve (actual error rates), the cost of the log-likelihood ratio
cllr(tar, non)
## The area under the green curve (minimum errors), the cost of the optimal log-likelihood-ratio
minclrr(tar, non)
## Similar to APE, but normalized---a Normalized Bayes Error plot
nbeplot(r)
## Make an `LLR&#39; plot: score-to-optimal-LLR mapping, r.θ, vs. r.llr
llrplot(r)</code></pre><h2><a class="nav-anchor" id="Receiver-Operating-Characteristic-1" href="#Receiver-Operating-Characteristic-1">Receiver Operating Characteristic</a></h2><p>A binary classifier maps an input <code>x</code> to one of two classes, <code>A</code> and <code>B</code>.  Internally, every classifier ends up producing some form of a scalar metric <code>s</code>, which can be thresholded to produce a decision.</p><p>There are two possible &quot;senses&quot; of this internal scalar:</p><ul><li>higher values of <code>s</code> indicate higher probability of <code>A</code></li><li>higher values of <code>s</code> indicate higher probability of <code>B</code></li></ul><p>There are of course also many different interpretations of the classes <code>A</code> and <code>B</code>.  For instance, in biometrics <code>B</code> could mean &quot;same individual&quot; and <code>A</code> &quot;different individual&quot;.  The corresponding senses of <code>s</code> then have an interpretation</p><ul><li>score-like: a higher value means a better match</li><li>distance-like: a higher value means a larger difference.</li></ul><p>Because we want to focus in this package on a probabilistic interpretation of the scalar <code>s</code>, we take the &quot;score-like&quot; interpretation of <code>s</code>, i.e., higher values of <code>s</code> correspond to a higher likelihood of the class-of-interest to be associated to the input of the classifier.  If your classifier is, in fact, a distance metric <code>d</code>, you could work with <code>s=-d</code> or <code>s=1/d</code> or any other strictly decreasing function.  Alternatively, you can swap around the label of the class of interest. </p><p>As the name suggests, a classifier is supposed to make decisions.  Decisions can be thesholded against a fixed <code>θ</code> such that:</p><ul><li>if <code>s&gt;θ</code>, decide class <code>B</code></li><li>if <code>s&lt;θ</code>, decide class <code>A</code></li></ul><p>For evaluating the classifier, we need a set of supervised trials, i.e., for each scalar score <code>s</code> we need a label indicating the true class of the trial that led to score <code>s</code>.  Because there are two classes, two types of errors can be made:</p><ul><li>false positives: <code>s&gt;θ</code> while in fact the true label is <code>A</code></li><li>false negatives: <code>s&lt;θ</code> while in fact the true label is <code>B</code>.</li></ul><p>The <em>Receiver Operating Characteristic</em> (ROC) is a graph that shows how the fractions of the false positives and false negatives change with varying <code>θ</code>, for a fixed set of scores <code>s</code>.  The structure of type <code>Roc</code> captures the essential information in a pre-processed way such that other quantities can be derived efficiently. </p><p>Because we come from automatic speaker recognition, we tend to use the following terminology for the classes</p><ul><li><em>target</em>, the higher scores, a.k.a. same source, true client, ...</li><li><em>non-target</em>, the lower scores, a.k.a. different source, impostor, ...</li></ul><h2><a class="nav-anchor" id="Error-rates-1" href="#Error-rates-1">Error rates</a></h2><p>In this package, we focus at analysing everything in terms of <em>error rates</em>.  Traditionally, researchers have used ROC curves where one of the axes is used to describe the complement of an error rate.  Specifically, one often sees a &quot;true positive rate&quot; versus a &quot;false positive rate&quot;, where the true positive rate is the complement of the false negative rate.  There is no real objective way to judge whether one analysis is any better than the other, usually the choice is largely dependent on traditions in the area of the research you are in.</p><p>There are many different names of the error rates in different scientific disciplines.  Because I come from the area of automatic speaker recognition, the current terminology is</p><ul><li><em>Probability of False Alarm</em>: a.k.a. false alarm rate, false positive rate, false accept rate, false match rate, Type II error, 1 - true negative rate, 1- specificity</li><li><em>Probability of Miss:</em>: a.k.a. miss rate, false negative rate, false reject rate, false non-match rate, Type I error, 1 - true positive rate, 1 - sensitivity, 1 - recall, 1 - verification rate, 1 - hit rate, 1 - genuine acceptance rate</li></ul><p>We foresee that the naming of things becomes a bit more flexible in future releases of this package. </p><h2><a class="nav-anchor" id="DET-plot-1" href="#DET-plot-1">DET plot</a></h2><p>A <em>detection error trade-off</em> plot (Martin, 1997) is exactly the same as a ROC plot in the error domain (i.e., miss rate vs false alarm rate), but the axes have been warped according to <code>Φ⁻¹(x)</code>, the inverse of the cumulative normal distribution.  In R, this function is known as <code>qnorm(x)</code>, in Julia base this is <code>√2 * erfinv(2x-1)</code>.  This type of plot has interesting properties</p><ul><li>If the distributions of target and non-target scores are both Normal, then the DET-curve is a straight line.  In practice, many detection problems give rise to more-or-less straight DET curves, and this suggests that there exists a strictly increasing warping function that can make the score distributions (more) Normal. </li><li>Towards better performance (lower error rates), the resolution of the graph is higher.  This makes it more easy to have multiple systems / performance characteristics over a smaller or wider range of performance in the same graph, and still be able to tell these apart.</li><li>Conventionally, the ranges of the axes are chosen 0.1%–50%.  This makes it possible to immediately assess the overall performance based on the absolute position of the line in the graph if you have seen more DET plots in your life.</li><li>The slope of the (straight) line corresponds to the ratio of the <code>σ</code> parameters of the underlying Normal score distributions, namely that of the non-target scores divided by that of the target scores.  Often, highly discriminative classifiers show very <em>flat</em> curves, indicating that that target scores have a much larger variance than the non-target scores.  </li><li>The origin of this type of plot lies in psychophysics, where graph paper with lines according to this warping was referred to as <em>double probability paper</em>.  The diagonal <code>y=x</code> in a DET plot corresponds linearly to a quantity known as <code>d&#39;</code> (d-prime) from psychophysics, ranging from 0 at 50% error to about 6 at 0.1% error. </li></ul><h3><a class="nav-anchor" id="Discrete-and-continuous-scores-1" href="#Discrete-and-continuous-scores-1">Discrete and continuous scores</a></h3><p>There is an essential difference between discrete score (classes) and continuous scores.  For the former, trials with the same scores must be grouped before the probabilities of false alarm and miss are computed.  This results in ROC and DET plots that can have line elements that are not solely horizontal or vertical.  This is contrary to the latter case if we assume that no two scores are (coincidentally)  the same, which leads to only horizontal and vertical line segments.  This <code>ROCAnalysis</code> package makes sure that the occurrence of identical scores is treated correctly by sorting target scores before identical non-target scores, and by treating trials with scores <em>at</em> the threshold always as errors. </p><h3><a class="nav-anchor" id="Plot-optimisation-1" href="#Plot-optimisation-1">Plot optimisation</a></h3><p>For larget trial sets, it is very likely that in the extrems of the score distributions there is very little overlap.  This wil results in many consecutive horizontal or vertical line segments in the plot.   This <code>ROCAnalysis</code> package integrates these consecutive line segments and replaces them by a single segment, which leads to a strong reduction in complexity in further calculations and plotting.  </p><h2><a class="nav-anchor" id="Single-numbered-metrics-1" href="#Single-numbered-metrics-1">Single-numbered metrics</a></h2><p>The ROC and DET plots shows the discrimination capability of the detector as a graph.  Often one wants to summarize the plot in a single metric.  There are many ways to do this, we list some here</p><ul><li><em>Equal Error Rate</em>.  This is the point in the DET or ROC where the curve crosses the <code>y=x</code> line, i.e., where the error rates are the same.  A lower EER means a better discriminating classifier.  It samples the ROC on only a single operating point, and moreover, this is an &quot;after-the-fact&quot; point.  This metric is insensitive to calibration, i.e., any strictly increasing function can be applied to the scores and an identical EER will be computed.  For small number of trials it makes a different how to comput the EER, often in literature this is not specified.  In this package there are the functions:<ul><li><code>eer()</code>: take the points where the difference between miss and false alarm rates changes sign, and interpolate to find the crossing with the <code>y=x</code> diagonal.</li><li><code>eerch()</code>: compute the convex hull of the ROC, and compute the point where this crosses the <code>y=x</code>line.  This has the interpretation of <em>the maximum over priors of the minimum cost</em>, and is useful for cost function analysis.  It tends to be more stable than <code>eer()</code>.</li></ul></li><li><em>Area Under the Curve</em>. <code>auc()</code> integrates the <em>Area Under the Curve</em> of the ROC.  Contrary to the EER, this metric is sensitive to the entire range of operating points, but, like the EER, it is insensitive to calibration.  It can be interpreted as the probability that a random non-target score is higher than a random target score, and lower AUC indicates better discrimination.  Please note that the complement (area under the hit-rate-vs-false-alarm-rate curve) is known under the same name in other disciplines.  We believe in errors, and minimizing them.</li><li><em>Dectection Cost Function</em>. <code>dcf()</code>  A Detection cost function is a weighted sum of false alarms and misses.  The weights consists of separate costs for false alarms and misses, and a prior for non-targets and targets.</li><li><em>Minimum Detection Cost</em>. <code>mindcf()</code>  This is the minimum detection cost <code>dcf()</code> that can be obtained by varying the threshold.  It is similar to the EER in the sense that it requires setting a threshold &quot;after the fact&quot;.  The minimum DCF is related to the points on the convex hull of the ROC curve.  </li><li><em>Cost of the Log-Likelihood-Ratio</em>. <code>cllr()</code> computes a normalized form of the cross-entropy between the &quot;true posterior&quot; (<code>1</code> for target trials and <code>0</code> for non-target trials) and the posterior resulting from the classifier score when interpreted as a likelihood ratio, and using a prior for the classes of 0.5.  This measure is <em>calibration sensitive</em>, i.e., it penalizes under- or over-confident likelihood ratios.  The minimum value is determined by the discriminative properties of the classifier, and this minimum approaches 0 for a classifier that completely separates the two classes.  A value of 1 indicates that the classifier gives no information, i.e., decisions can just as well be made based on the prior only.  A value larger than 1 indicates that making Bayes&#39;s decisions based on the classifiers score gives a higher expected cost than basing decisions on the prior alone.</li><li>*Minimum Cllr&quot;, <code>mincllr()</code> computes the minimum attainable Cllr by warping the scores to log-likelihood-ratios while maintaining the order of the scores.  This is equivalent to determining a minimum cost for all cost functions that can be written as a linear combination of actual miss- and false-alarm-rates, and integrating these costs over cost function parameters.</li></ul><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>We have defined the following types:</p><ul><li><code>TNT(tar, non)</code>,  A container for arrays of target and non-target scores.   Anywhere it says <code>tar, non</code> you should be able to substitute a variable of type <code>TNT</code>.</li><li><code>DCF(ptar,cfa,cmiss)</code>.  A container for scalars or arrays of the cost function parameters <code>ptar</code> (the prior probability of a target), <code>cfa</code> (the cost of a false alarm) and <code>cmiss</code> (the cost of a miss).  In any of the parameters are arrays, they must be of compatible size.</li><li><code>Roc(pfa, pmiss, θ, chull, llr)</code>.  The basic structure for storing ROC results. It contains the x- and y-coordiantes of the (error-based) ROC, together with the threshold.  Many of the &quot;minimum&quot; performance measures can be computed from this.  The fields in <code>Roc</code> have the following interpretation:</li><li><code>pfa</code>.  The probability of a false alarm, the fraction of non-target scores <em>above</em> (or equal to) the threshold <code>θ</code>.  This quantity is also known as false alarm/accept/positive/match rate or type II error, and <code>1-pfa</code> is known as the true negative/reject rate or specificity.</li><li><code>pmiss</code>.  The probability of a miss, the fraction of target scores <em>below</em> (or equal to) the threshold <code>θ</code>.  This quantity is also known, a.o. miss rate, false negative/reject/non-match rate, type I error, and <code>1-pmiss</code> is also known as true positive rate, sensitivity, recall, verification/hit rate, genuine acceptance rate.</li><li><code>θ</code>. The threshold associated with the elements in <code>pfa</code> and <code>pmiss</code>.  It can be seen as lying between <em>this</em> <code>pfa/miss</code> and <em>the next</em>.  Hence, there is one value less than in the <code>pmiss</code> and <code>pfa</code> arrays.</li><li><code>chull</code>.  A boolean indicating whether or not the point <code>(pfa,pmiss))</code> lies on the <em>convex hull</em>.</li><li><code>llr</code>.  The optimal log-likelihood-ratio associated with scores at <code>θ</code>.  </li></ul><h2><a class="nav-anchor" id="Notes-1" href="#Notes-1">Notes</a></h2><p>This is very much work in progress.  If you stumble upon this, please drop me a line. </p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
