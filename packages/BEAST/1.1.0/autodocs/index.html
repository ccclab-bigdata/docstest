<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BEAST.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BEAST.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.@discretise" href="#BEAST.@discretise"><code>BEAST.@discretise</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">discr(eq, pairs...)</code></pre><p>This macro provides syntactical sugar for the definition of a discretisation of a varational formulation. Given a variational equation EQ: Find j ∈ X such that for all k ∈ Y a(k,j) = f(k) can be discretised by stating:</p><pre><code class="language-none">eq = @discretise EQ j∈X k∈Y</code></pre></div></div></section><pre><code class="language-none">BEAST.@hilbertspace</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.Variational.@varform" href="#BEAST.Variational.@varform"><code>BEAST.Variational.@varform</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@varform &lt;form-definition&gt;</code></pre><p>The Julia form compiler uses the Julia parser and meta-programming based traversal of the AST to create a structure containing all information required for the description of a variational formulation from an Expr that follows closely widespread mathematical convention.</p><p>E.g:</p><pre><code class="language-none">EFIE = @varform T[k,j] = e[k]
MFIE = @varform 0.5*I[k,j] + K[k,j] = h[k]
PMCH = @varform M[k,j] - η*T[k,m] + 1/η*T[l,j] + M[l,m] = e[k] + h[l]</code></pre></div></div></section><pre><code class="language-none">BEAST.ADIterator</code></pre><pre><code class="language-none">BEAST.AbstractOperator</code></pre><pre><code class="language-none">BEAST.AbstractSpace</code></pre><pre><code class="language-none">BEAST.AbstractTimeBasisFunction</code></pre><pre><code class="language-none">BEAST.AssemblyData</code></pre><pre><code class="language-none">BEAST.AssemblyDataEl</code></pre><pre><code class="language-none">BEAST.BDMBasis</code></pre><pre><code class="language-none">BEAST.BDMRefSpace</code></pre><pre><code class="language-none">BEAST.BEAST</code></pre><pre><code class="language-none">BEAST.Bernstein</code></pre><pre><code class="language-none">BEAST.Continuity</code></pre><pre><code class="language-none">BEAST.CrossTraceMW</code></pre><pre><code class="language-none">BEAST.CurlSingleLayerDP3D</code></pre><pre><code class="language-none">BEAST.DiagonalizedMatrix</code></pre><pre><code class="language-none">BEAST.DiracBoundary</code></pre><pre><code class="language-none">BEAST.DirectProductSpace</code></pre><pre><code class="language-none">BEAST.DiscreteEquation</code></pre><pre><code class="language-none">BEAST.DoubleLayer</code></pre><pre><code class="language-none">BEAST.DoubleLayerRotatedMW3D</code></pre><pre><code class="language-none">BEAST.DoubleLayerTransposed</code></pre><pre><code class="language-none">BEAST.DoubleQuadStrategy</code></pre><pre><code class="language-none">BEAST.EmptyRP</code></pre><pre><code class="language-none">BEAST.ErrorFunction</code></pre><pre><code class="language-none">BEAST.Functional</code></pre><pre><code class="language-none">BEAST.GMRESSolver</code></pre><pre><code class="language-none">BEAST.Gaussian</code></pre><pre><code class="language-none">BEAST.HH3DDoubleLayer</code></pre><pre><code class="language-none">BEAST.HH3DDoubleLayerTDBIO</code></pre><pre><code class="language-none">BEAST.HH3DDoubleLayerTransposed</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.HH3DHyperSingularFDBIO" href="#BEAST.HH3DHyperSingularFDBIO"><code>BEAST.HH3DHyperSingularFDBIO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">∫_Γ dx ∫_Γ dy \left(α G g(x) n_x ⋅ n_y f(y) + β G \mbox{curl} g(x) ⋅ \mbox{curl} f(y) \right)</code></pre><p>with <span>$G(x,y) = \frac{e^{-γ |x-y|}}{4 π |x-y|}$</span></p></div></div></section><pre><code class="language-none">BEAST.HH3DPlaneWave</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.HH3DSingleLayerFDBIO" href="#BEAST.HH3DSingleLayerFDBIO"><code>BEAST.HH3DSingleLayerFDBIO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div>\[a(u,v) = α ∬_{Γ×Γ} u(x) G_{γ}(|x-y|) v(y)\]</div><p>with <span>$G_{γ}(r) = \frac{e^{-γr}}{4πr}$</span>.</p></div></div></section><pre><code class="language-none">BEAST.HH3DSingleLayerReg</code></pre><pre><code class="language-none">BEAST.HH3DSingleLayerSng</code></pre><pre><code class="language-none">BEAST.HH3DSingleLayerTDBIO</code></pre><pre><code class="language-none">BEAST.Helmholtz3D</code></pre><pre><code class="language-none">BEAST.Helmholtz3DOp</code></pre><pre><code class="language-none">BEAST.Helmholtz3DOpReg</code></pre><pre><code class="language-none">BEAST.HelmholtzOperator2D</code></pre><pre><code class="language-none">BEAST.HyperSingular</code></pre><pre><code class="language-none">BEAST.Identity</code></pre><pre><code class="language-none">BEAST.IntegralOperator</code></pre><pre><code class="language-none">BEAST.KernelValsHelmholtz2D</code></pre><pre><code class="language-none">BEAST.KernelValsMaxwell3D</code></pre><pre><code class="language-none">BEAST.LagrangeBasis</code></pre><pre><code class="language-none">BEAST.LagrangeRefSpace</code></pre><pre><code class="language-none">BEAST.LinearCombinationOfOperators</code></pre><pre><code class="language-none">BEAST.LinearSpace</code></pre><pre><code class="language-none">BEAST.LocalOperator</code></pre><pre><code class="language-none">BEAST.MWDL3DGen</code></pre><pre><code class="language-none">BEAST.MWDL3DIntegrand</code></pre><pre><code class="language-none">BEAST.MWDL3DIntegrand2</code></pre><pre><code class="language-none">BEAST.MWDoubleLayer3D</code></pre><pre><code class="language-none">BEAST.MWDoubleLayer3DReg</code></pre><pre><code class="language-none">BEAST.MWDoubleLayer3DSng</code></pre><pre><code class="language-none">BEAST.MWDoubleLayerTDIO</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.MWFarField3D" href="#BEAST.MWFarField3D"><code>BEAST.MWFarField3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Operator to compute the far field of a current distribution. In particular, given the current distribution <span>$j$</span> this operator allows for the computation of</p><div>\[A j = n × ∫_Γ e^{γ ̂x ⋅ y} dy\]</div><p>where <span>$̂x$</span> is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.MWFarField3DTD" href="#BEAST.MWFarField3DTD"><code>BEAST.MWFarField3DTD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Operator to compute the far field of a current distribution in the time domain. In particular, given the current distribution <span>$j$</span> this operator allows for the computation of</p><div>\[R =  ̂x ⋅ y
ffd = n × ∫_Γ j(r&#39;, t - R/c} dy\]</div><p>where <span>$̂x$</span> is the unit vector in the direction of observation. Note that the assembly routing expects the observation directions to be normalised by the caller.</p></div></div></section><pre><code class="language-none">BEAST.MWHyperSingular</code></pre><pre><code class="language-none">BEAST.MWOperator3D</code></pre><pre><code class="language-none">BEAST.MWSL3DGen</code></pre><pre><code class="language-none">BEAST.MWSL3DIntegrand</code></pre><pre><code class="language-none">BEAST.MWSL3DIntegrand2</code></pre><pre><code class="language-none">BEAST.MWSingleLayer3D</code></pre><pre><code class="language-none">BEAST.MWSingleLayer3DReg</code></pre><pre><code class="language-none">BEAST.MWSingleLayer3DSng</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.MWSingleLayerField3D" href="#BEAST.MWSingleLayerField3D"><code>BEAST.MWSingleLayerField3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MWSingleLayerField3D(wavenumber = error())</code></pre><p>Create the single layer near field operator, for use with <code>potential</code>.</p></div></div></section><pre><code class="language-none">BEAST.MWSingleLayerPotential3D</code></pre><pre><code class="language-none">BEAST.MWSingleLayerTDIO</code></pre><pre><code class="language-none">BEAST.MWWeaklySingular</code></pre><pre><code class="language-none">BEAST.MatrixConvolution</code></pre><pre><code class="language-none">BEAST.Maxwell3D</code></pre><pre><code class="language-none">BEAST.MaxwellOperator3D</code></pre><pre><code class="language-none">BEAST.MaxwellOperator3DReg</code></pre><pre><code class="language-none">BEAST.MonomialBasis</code></pre><pre><code class="language-none">BEAST.MultiQuadStrategy</code></pre><pre><code class="language-none">BEAST.NCross</code></pre><pre><code class="language-none">BEAST.NDBasis</code></pre><pre><code class="language-none">BEAST.NDRefSpace</code></pre><pre><code class="language-none">BEAST.NDotTrace</code></pre><pre><code class="language-none">BEAST.NitscheHH3</code></pre><pre><code class="language-none">BEAST.NormalDerivative</code></pre><pre><code class="language-none">BEAST.NormalVector</code></pre><pre><code class="language-none">BEAST.NumQuadStrategy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.Operator" href="#BEAST.Operator"><code>BEAST.Operator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><em>Atomic operator</em>: one that assemblechunk can deal with</p></div></div></section><pre><code class="language-none">BEAST.PieceWisePolynomial</code></pre><pre><code class="language-none">BEAST.PlaneWaveDirichlet</code></pre><pre><code class="language-none">BEAST.PlaneWaveHH3DTD</code></pre><pre><code class="language-none">BEAST.PlaneWaveMW</code></pre><pre><code class="language-none">BEAST.PlaneWaveMWTD</code></pre><pre><code class="language-none">BEAST.PlaneWaveNeumann</code></pre><pre><code class="language-none">BEAST.Polynomial</code></pre><pre><code class="language-none">BEAST.RTBasis</code></pre><pre><code class="language-none">BEAST.RTRefSpace</code></pre><pre><code class="language-none">BEAST.RefSpace</code></pre><pre><code class="language-none">BEAST.RetardedPotential</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.RungeKuttaConvolutionQuadrature" href="#BEAST.RungeKuttaConvolutionQuadrature"><code>BEAST.RungeKuttaConvolutionQuadrature</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RungeKuttaConvolutionQuadrature{T,N,NN}</code></pre><p>T: the value type of the basis function. N: the number of stages. NN: N*N.</p><p>Performs a convolution quadrature on a laplaceKernel to represent an operator in time domain using an implicit Runge-Kutta method.</p><p>laplaceKernel: function of the Laplace variable s that returns an IntegralOperator. A, b: Coefficient matrix and vectors from the Butcher tableau. Δt: time step. zTransformedTermCount: Number of terms in the inverse Z-transform. contourRadius: radius of circle used as integration contour for the inverse Z-transform.</p></div></div></section><pre><code class="language-none">BEAST.ScalarTrace</code></pre><pre><code class="language-none">BEAST.Shape</code></pre><pre><code class="language-none">BEAST.SingleLayer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.SingleLayerTrace" href="#BEAST.SingleLayerTrace"><code>BEAST.SingleLayerTrace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Describe a single layer operator from the surface to a line.</p><div>\[&lt;v, Su&gt; = ∫_γ dx v(x) ∫_Γ dy rac{e^{-ikR}}{4πR} u(y)\]</div></div></div></section><pre><code class="language-none">BEAST.SingleQuadStrategy</code></pre><pre><code class="language-none">BEAST.SingleQuadStrategy2</code></pre><pre><code class="language-none">BEAST.SingularityExtractionStrategy</code></pre><pre><code class="language-none">BEAST.Space</code></pre><pre><code class="language-none">BEAST.SpaceTimeBasis</code></pre><pre><code class="language-none">BEAST.SparseND</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.StagedTimeStep" href="#BEAST.StagedTimeStep"><code>BEAST.StagedTimeStep</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StagedTimeStep{T,N}</code></pre><p>T: the value type of the basis function. N: the number of stages. It corresponds to a time-space basis function where each time step has intermediary stages given by the vertor c in a Butcher tableau (A,b,c)</p></div></div></section><pre><code class="language-none">BEAST.TDFunctional</code></pre><pre><code class="language-none">BEAST.TangTraceMW</code></pre><pre><code class="language-none">BEAST.TemporalDifferentiation</code></pre><pre><code class="language-none">BEAST.TensorOperator</code></pre><pre><code class="language-none">BEAST.TimeBasisDelta</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.TimeBasisDeltaShifted" href="#BEAST.TimeBasisDeltaShifted"><code>BEAST.TimeBasisDeltaShifted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TimeBasisDeltaShifted{T}</code></pre><p>Represents a TimeBasisDelta{T} retarded by a fraction of the time step.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.TimeBasisFunction" href="#BEAST.TimeBasisFunction"><code>BEAST.TimeBasisFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TimeBasisFunction{N,D}</code></pre><p>T: the value type of the time basis function N: the number of intervals in the support (this included the semi infinite interval     stretching to +∞) D1: the degree of the TBF restricted to each of the intervals <strong>plus one</strong></p></div></div></section><pre><code class="language-none">BEAST.TransposedOperator</code></pre><pre><code class="language-none">BEAST.ValDiv</code></pre><pre><code class="language-none">BEAST.Variational</code></pre><pre><code class="language-none">BEAST.WiltonInts84Strat</code></pre><pre><code class="language-none">BEAST.WiltonSEStrategy</code></pre><pre><code class="language-none">BEAST._legendre</code></pre><pre><code class="language-none">BEAST.add!</code></pre><pre><code class="language-none">BEAST.allocatestorage</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.assemble" href="#BEAST.assemble"><code>BEAST.assemble</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assemble(fn, tfs)</code></pre><p>Assemble the vector of test coefficients corresponding to functional <code>fn</code> and test functions <code>tfs</code>.</p></div></div></section><pre><code class="language-none">BEAST.assemble!</code></pre><pre><code class="language-none">BEAST.assemble_local_matched!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.assemble_local_mixed!" href="#BEAST.assemble_local_mixed!"><code>BEAST.assemble_local_mixed!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assemble_local_mixed(biop::LocalOperator, tfs, bfs)</code></pre><p>For use when basis and test functions are defined on different meshes</p></div></div></section><pre><code class="language-none">BEAST.assemble_st!</code></pre><pre><code class="language-none">BEAST.assembleblock</code></pre><pre><code class="language-none">BEAST.assembleblock!</code></pre><pre><code class="language-none">BEAST.assembleblock_body!</code></pre><pre><code class="language-none">BEAST.assembleblock_primer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.assemblechunk!" href="#BEAST.assemblechunk!"><code>BEAST.assemblechunk!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assemblechunk!(biop::IntegralOperator, tfs, bfs, store)</code></pre><p>Computes the matrix of operator biop wrt the finite element spaces tfs and bfs</p></div></div></section><pre><code class="language-none">BEAST.assemblechunk_body!</code></pre><pre><code class="language-none">BEAST.assemblechunk_body_nested_meshes!</code></pre><pre><code class="language-none">BEAST.assemblecol</code></pre><pre><code class="language-none">BEAST.assemblecol!</code></pre><pre><code class="language-none">BEAST.assemblecol_body!</code></pre><pre><code class="language-none">BEAST.assemblerow</code></pre><pre><code class="language-none">BEAST.assemblerow!</code></pre><pre><code class="language-none">BEAST.assemblerow_body!</code></pre><pre><code class="language-none">BEAST.assembly</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.assemblydata" href="#BEAST.assemblydata"><code>BEAST.assemblydata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">charts, admap = assemblydata(basis)</code></pre><p>Given a Basis this function returns a data structure containing the information required for matrix assemble. More precise the following expressions are valid for the returned object <code>ad</code>:</p><pre><code class="language-none">ad[c,r,i].globalindex
ad[c,r,i].coefficient</code></pre><p>Here, <code>c</code> and <code>r</code> are indices in the iterable set of geometric elements and the set of local shape functions on each element. <code>i</code> ranges from 1 to the maximum number of basis functions local shape function <code>r</code> on element <code>r</code> contributes to.</p><p>For a triplet <code>(c,r,i)</code>, <code>globalindex</code> is the index in the Basis of the <code>i</code>-th basis function that has a contribution from local shape function <code>r</code> on element <code>r</code>. <code>coefficient</code> is the coefficient of that contribution in the linear combination defining that basis function in terms of local shape function.</p><p><em>Note</em>: the indices <code>c</code> correspond to the position of the corresponding element whilst iterating over <code>geometry(basis)</code>.</p></div></div></section><pre><code class="language-none">BEAST.basisfunction</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.blockassembler" href="#BEAST.blockassembler"><code>BEAST.blockassembler</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">blockassembler(operator, test_space, trial_space) -&gt; assembler</code></pre><p>Return a callable object for the creation of blocks within a BEM matrix.</p><p>This function performs all tasks common to the assembly of several blocks within a single boundary element matrix. The return value can be used to generate blocks by calling it as follows:</p><pre><code class="language-none">assembler(I,J,storefn)</code></pre><p>where <code>I</code> and <code>J</code> are arrays of indices in <code>test_space</code> and <code>trial_space</code>, respectively, corresponding to the rows and columns of the desired block.</p><p>Note that the block will be constructed in compressed form, i.e. the rows and columns of the store that are written into are the positions within <code>I</code> and <code>J</code> (as opposed to the positions within <code>1:numfunctions(test_space)</code> and <code>1:numfunctions(trial_space)</code>). In particular the size of the constructed block will be <code>(length(I), length(J))</code>.</p><p>This last property allows the assembly of permutations of the BEM matrix by supplying for <code>I</code> and <code>J</code> permutations of <code>1:numfunctions(test_space)</code> and <code>1:numfunctions(trial_space)</code>.</p></div></div></section><pre><code class="language-none">BEAST.brezzidouglasmarini</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.buffachristiansen" href="#BEAST.buffachristiansen"><code>BEAST.buffachristiansen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">buffachristiansen(Γ, γ)</code></pre><p>Construct the set of Buffa-Christiansen functions subject to mesh Γ and only enforcing zero normal components on ∂Γ ∖ γ.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.buildhalfbc" href="#BEAST.buildhalfbc"><code>BEAST.buildhalfbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">buildhalfbc(fine, supp::Array{SVector{3,Int},1}, v, p)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.butcher_tableau_radau_2stages" href="#BEAST.butcher_tableau_radau_2stages"><code>BEAST.butcher_tableau_radau_2stages</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">butcher_tableau_radau_2stages()</code></pre><p>Returns (A,b,c) corresponding to the Butcher tableau for the 2 stage Radau IIA scheme.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.butcher_tableau_radau_3stages" href="#BEAST.butcher_tableau_radau_3stages"><code>BEAST.butcher_tableau_radau_3stages</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">butcher_tableau_radau_3stages()</code></pre><p>Returns (A,b,c) corresponding to the Butcher tableau for the 3 stage Radau IIA scheme.</p></div></div></section><pre><code class="language-none">BEAST.cellcellinteractions!</code></pre><pre><code class="language-none">BEAST.cellinteractions</code></pre><pre><code class="language-none">BEAST.celltestvalues</code></pre><pre><code class="language-none">BEAST.collapse_shapes</code></pre><pre><code class="language-none">BEAST.companion</code></pre><pre><code class="language-none">BEAST.convolve</code></pre><pre><code class="language-none">BEAST.coordtype</code></pre><pre><code class="language-none">BEAST.creategaussian</code></pre><pre><code class="language-none">BEAST.cross</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.curl" href="#BEAST.curl"><code>BEAST.curl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">curl(X)</code></pre><p>Compute the curl of a finite element basis. The resulting set of functions might be linearly dependent because of the kernel of the curl operator.</p></div></div></section><pre><code class="language-none">BEAST.degree</code></pre><pre><code class="language-none">BEAST.derive</code></pre><pre><code class="language-none">BEAST.diagonalizedmatrix</code></pre><pre><code class="language-none">BEAST.discretise</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.divergence" href="#BEAST.divergence"><code>BEAST.divergence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">divergence(x)</code></pre><p>Compute the divergence of a finite element space.</p></div></div></section><pre><code class="language-none">BEAST.dot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.duallagrangec0d1" href="#BEAST.duallagrangec0d1"><code>BEAST.duallagrangec0d1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">duallagrangec0d1(originalmesh, refinedmesh)</code></pre><p>It is the user responsibility to provide two meshes representing the same object. The second mesh needs to be obtained using &quot;barycentric_refinement(originalmesh)&quot;. This basis function creats the dual Lagrange basis function and return an object that contains array of shapes [fns] It also return a gemoetry containing the refined mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.duallagrangecxd0" href="#BEAST.duallagrangecxd0"><code>BEAST.duallagrangecxd0</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">duallagrangecxd0(mesh, jct) -&gt; basis</code></pre><p>Build dual Lagrange piecewise constant elements. Boundary nodes are only considered if they are in the interior of <code>jct</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.elements" href="#BEAST.elements"><code>BEAST.elements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>elements(geo)</p><p>Create an iterable collection of the elements stored in <code>geo</code>. The order in which this collection produces the elements determines the index used for lookup in the data structures returned by <code>assemblydata</code> and <code>quaddata</code>.</p></div></div></section><pre><code class="language-none">BEAST.elementstree</code></pre><pre><code class="language-none">BEAST.eval</code></pre><pre><code class="language-none">BEAST.evaluate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.facecurrents" href="#BEAST.facecurrents"><code>BEAST.facecurrents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fcr, geo = facecurrents(coeffs, basis)</code></pre><p>Compute the value of the function with the given collection of coeffient in the provided basis in all the centroids of the mesh underlying the basis. The mesh is returned together with the currents.</p></div></div></section><pre><code class="language-none">BEAST.faces</code></pre><pre><code class="language-none">BEAST.farfieldlocal!</code></pre><pre><code class="language-none">BEAST.fouriertransform</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.geometry" href="#BEAST.geometry"><code>BEAST.geometry</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geometry(basis)</code></pre><p>Returns an iterable collection of geometric elements on which the functions in <code>basis</code> are defined. The order the elements are encountered needs correspond to the element indices used in the data structure returned by <code>assemblydata</code>.</p></div></div></section><pre><code class="language-none">BEAST.get_scatter_parameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.getcommonedge" href="#BEAST.getcommonedge"><code>BEAST.getcommonedge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getcommonedge(cell1, cell2) -&gt; e1, e2, edge</code></pre><p>Returns in edge the common vertices of cell1 and cell2. e1 contains the index of the vertex of cell1 opposite to this common edge, and with a plus or minus sign depending on whether the orientation of the common edge is along or against the internal orientation of cell1. Similar for e2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.getindex_rtg" href="#BEAST.getindex_rtg"><code>BEAST.getindex_rtg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getindex_rtg(RT::RTBasis)</code></pre><p>Returns the indices of the global half RWGs present in <code>RT</code>. <code>RT</code> is typically gotten from <code>rt_ports</code></p></div></div></section><pre><code class="language-none">BEAST.gmres</code></pre><pre><code class="language-none">BEAST.include</code></pre><pre><code class="language-none">BEAST.index_actives</code></pre><pre><code class="language-none">BEAST.innerintegrals!</code></pre><pre><code class="language-none">BEAST.instantiate_charts</code></pre><pre><code class="language-none">BEAST.integrand</code></pre><pre><code class="language-none">BEAST.integrate</code></pre><pre><code class="language-none">BEAST.interior_and_junction_vertices</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.inverse_z_transform" href="#BEAST.inverse_z_transform"><code>BEAST.inverse_z_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inverse_z_transform(k, rho, N, X)</code></pre><p>Returns the k-th term of the inverse z-transform. X is an array of the z-transform evaluated in the points z=rho<em>exp(2</em>im<em>pi</em>n/N) for n in 0:(N-1).</p></div></div></section><pre><code class="language-none">BEAST.isclosed</code></pre><pre><code class="language-none">BEAST.kernel_in_bary</code></pre><pre><code class="language-none">BEAST.kernelvals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.lagdimension" href="#BEAST.lagdimension"><code>BEAST.lagdimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The dimension of the space of Lagrange shape functions of degree d over a simplex of dimension n is binom(n+d,d) == binom(n+d,n)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.lagrangec0d1" href="#BEAST.lagrangec0d1"><code>BEAST.lagrangec0d1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lagrangec0d1(mesh; dirichlet=[true|false]) -&gt; basis</code></pre><p>Build lagrangec0d1 elements, including (dirichlet=false) or excluding (dirichlet=true) those attached to boundary vertices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.lagrangec0d1_dirichlet" href="#BEAST.lagrangec0d1_dirichlet"><code>BEAST.lagrangec0d1_dirichlet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lagrangec0d1(mesh[, bnd])</code></pre><p>Construct the basis of continuous, piecewise linear basis functions subordinate to mesh <code>mesh</code>. Basis functions are constructed at vertices in the interionr of the mesh and on the closure of &#39;bnd&#39;. In particular, leaving out the second argument creates a finite element space subject to homogeneous Dirichlet boundary conditions.</p></div></div></section><pre><code class="language-none">BEAST.lagrangecxd0</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.laplace_to_z" href="#BEAST.laplace_to_z"><code>BEAST.laplace_to_z</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">laplace_to_z(rho, n, N, dt, A, b)</code></pre><p>Returns the complex matrix valued Laplace variable s that correspond to the variable z = rho<em>exp(2</em>im<em>pi</em>n/N) for a given Butcher tableau (A,b,c) and a time step dt.</p></div></div></section><pre><code class="language-none">BEAST.localoperator</code></pre><pre><code class="language-none">BEAST.localoperator2</code></pre><pre><code class="language-none">BEAST.make_celltonum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.marchonintime" href="#BEAST.marchonintime"><code>BEAST.marchonintime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">marchonintime(W0,Z,B,I)</code></pre><p>Solve by marching-on-in-time the causal convolution problem defined by <code>(W0,Z,B)</code> up to timestep <code>I</code>. Here, <code>Z</code> is an array of order 3 that contains a discretisation of a time translation invariant retarded potential operator. <code>W0</code> is the inverse of the slice <code>Z[:,:,1]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.momintegrals!" href="#BEAST.momintegrals!"><code>BEAST.momintegrals!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularcellcellinteractions!(biop, tshs, bshs, tcell, bcell, interactions, strat)</code></pre><p>Function for the computation of moment integrals using simple double quadrature.</p></div></div></section><pre><code class="language-none">BEAST.momintegrals_nested!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.move_after!" href="#BEAST.move_after!"><code>BEAST.move_after!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Move the s-th element right after the d-th</p></div></div></section><pre><code class="language-none">BEAST.move_before!</code></pre><pre><code class="language-none">BEAST.n</code></pre><pre><code class="language-none">BEAST.nedelec</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.ntrace" href="#BEAST.ntrace"><code>BEAST.ntrace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ntrace(X::Space, γ::Mesh)</code></pre><p>Compute the normal trace of basis X on mesh γ. γ is assumed to be part of the boundary of geometry(X).</p></div></div><div><div><pre><code class="language-none">ntrace(refspace, element, localindex, face)</code></pre><p>Compute the normal trace of all local shape functions on <code>elements</code> belonging to <code>refspace</code> on <code>face</code>. This function returns a matrix expressing the traces of local shape functions in <code>refspace</code> as linear combinations of functions in the local trace space. Cf. <code>restrict</code>. <code>localindex</code> is the index of <code>face</code> in the enumeration of faces of <code>elements</code>. In many special cases knowing this index allows for highly optimised implementations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.numfunctions" href="#BEAST.numfunctions"><code>BEAST.numfunctions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numfunctions(r)</code></pre><p>Return the number of functions in a <code>Space</code> or <code>RefSpace</code>.</p></div></div></section><pre><code class="language-none">BEAST.numintervals</code></pre><pre><code class="language-none">BEAST.operator</code></pre><pre><code class="language-none">BEAST.planewave</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.planewavemw3d" href="#BEAST.planewavemw3d"><code>BEAST.planewavemw3d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">planewavemw3d(;direction, polarization, wavenumber[, amplitude=1])</code></pre><p>Create a plane wave solution to Maxwell&#39;s equations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.portcells" href="#BEAST.portcells"><code>BEAST.portcells</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">portcells(Γ::Mesh, γ::Mesh)</code></pre><p>returns an array containing cell pairs of mesh Γ around a boundary edge that overlaps with mesh γ</p></div></div></section><pre><code class="language-none">BEAST.positions</code></pre><pre><code class="language-none">BEAST.potential</code></pre><pre><code class="language-none">BEAST.potential!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.qh" href="#BEAST.qh"><code>BEAST.qh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Q = qd(T,dh,::Val{N})</code></pre><p>Q[k] is the factor in front resulting from differentiating t^(k-1) dh times.</p></div></div></section><pre><code class="language-none">BEAST.qrdf</code></pre><pre><code class="language-none">BEAST.qrib</code></pre><pre><code class="language-none">BEAST.qrss</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.quaddata" href="#BEAST.quaddata"><code>BEAST.quaddata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quaddata(operator, test_refspace, trial_refspace, test_elements, trial_elements)</code></pre><p>Returns an object cashing data required for the computation of boundary element interactions. It is up to the client programmer to decide what (if any) data is cached. For double numberical quadrature, storing the integration points for example can significantly speed up matrix assembly.</p><ul><li><code>operator</code> is an integration kernel.</li><li><code>test_refspace</code> and <code>trial_refspace</code> are reference space objects. <code>quadata</code></li></ul><p>is typically overloaded on the type of these local spaces of shape functions. (See the implementation in <code>maxwell.jl</code> for an example).</p><ul><li><code>test_elements</code> and <code>trial_elements</code> are iterable collections of the geometric</li></ul><p>elements on which the finite element space are defined. These are provided to allow computation of the actual integrations points - as opposed to only their coordinates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.quadrule" href="#BEAST.quadrule"><code>BEAST.quadrule</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quadrule(operator,test_refspace,trial_refspace,p,test_element,q_trial_element, qd)</code></pre><p>Returns an object that contains all the dynamic (runtime) information that defines the integration strategy that will be used by <code>momintegrals!</code> to compute the interactions between the local test/trial functions defined on the specified geometric elements. The indices <code>p</code> and <code>q</code> refer to the position of the test and trial elements as encountered during iteration over the output of <code>geometry</code>.</p><p>The last argument <code>qd</code> provides access to all precomputed data required for quadrature. For example it might be desirable to precompute all the quadrature points for all possible numerical quadrature schemes that can potentially be required during matrix assembly. This makes sense, since the number of point is order N (where N is the number of faces) but these points will appear in N^2 computations. Precomputation requires some extra memory but can save a lot on computation time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.raowiltonglisson" href="#BEAST.raowiltonglisson"><code>BEAST.raowiltonglisson</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">raviartthomas(mesh, cellpairs::Array{Int,2})</code></pre><p>Constructs the RT basis on the input <code>mesh</code>. The i-th RT basis function will     represent a current distribution flowing from cell <code>cellpairs[1,i]</code> to     <code>cellpairs[2,i]</code> on the mesh.</p><p>Returns an object of type <code>RTBasis</code>, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.</p></div></div><div><div><pre><code class="language-none">raviartthomas(mesh)</code></pre><p>Conducts pre-processing on the input <code>mesh</code> by extracting the cell edges, cell pairs     and indices required to construct the RT basis on the <code>mesh</code>.</p><p>Calls raviartthomas(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT basis on the <code>mesh</code>, using the cell pairs identified.</p><p>Returns the RT basis object.</p></div></div><div><div><pre><code class="language-none">raviartthomas(Γ, γ)</code></pre><p>Constructs the RT space relative to boundary <code>γ</code> of an open surface, only     selecting cell pairs whose common edge does not lie on <code>γ</code> . (This prevents     the calculation of physically-impossible surface currents, such as those     flowing &#39;off the edge&#39; of a surface.)</p><p>Calls raviartthomas(Γ, duals) which constructs     the RT basis on the <code>mesh</code>, using the cell pairs identified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.raviartthomas" href="#BEAST.raviartthomas"><code>BEAST.raviartthomas</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">raviartthomas(mesh, cellpairs::Array{Int,2})</code></pre><p>Constructs the RT basis on the input <code>mesh</code>. The i-th RT basis function will     represent a current distribution flowing from cell <code>cellpairs[1,i]</code> to     <code>cellpairs[2,i]</code> on the mesh.</p><p>Returns an object of type <code>RTBasis</code>, which comprises both the mesh and pairs of     Shape objects which corresponds to the cell pairs, containing the necsessary     coefficients and indices to compute the exact basis functions when required     by the solver.</p></div></div><div><div><pre><code class="language-none">raviartthomas(mesh)</code></pre><p>Conducts pre-processing on the input <code>mesh</code> by extracting the cell edges, cell pairs     and indices required to construct the RT basis on the <code>mesh</code>.</p><p>Calls raviartthomas(mesh::Mesh, cellpairs::Array{Int,2}), which constructs     the RT basis on the <code>mesh</code>, using the cell pairs identified.</p><p>Returns the RT basis object.</p></div></div><div><div><pre><code class="language-none">raviartthomas(Γ, γ)</code></pre><p>Constructs the RT space relative to boundary <code>γ</code> of an open surface, only     selecting cell pairs whose common edge does not lie on <code>γ</code> . (This prevents     the calculation of physically-impossible surface currents, such as those     flowing &#39;off the edge&#39; of a surface.)</p><p>Calls raviartthomas(Γ, duals) which constructs     the RT basis on the <code>mesh</code>, using the cell pairs identified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.real_inverse_z_transform" href="#BEAST.real_inverse_z_transform"><code>BEAST.real_inverse_z_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">real_inverse_z_transform(k, rho, N, X)</code></pre><p>Returns the k-th term of the inverse z-transform. It is assumed that X[n+1] = conj(X[N-n]) for each n in 1:(N-1) so that Nmax = N/2+1 or (N+1)/2 (resp. if N%2==0 or N%2==1) terms are used in X X is an array of the z-transform evaluated in the points z=rho<em>exp(2</em>im<em>pi</em>n/N) for n in 0:(Nmax-1).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.refspace" href="#BEAST.refspace"><code>BEAST.refspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">refspace(basis)</code></pre><p>Returns the ReferenceSpace of local shape functions on which the basis is built.</p></div></div></section><pre><code class="language-none">BEAST.regularpart</code></pre><pre><code class="language-none">BEAST.regularpart_quadrule</code></pre><pre><code class="language-none">BEAST.relorientation</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.restrict" href="#BEAST.restrict"><code>BEAST.restrict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">restrict(refspace, element1, element2)</code></pre><p>Computes the restriction of a set of local shape functions on <code>element1</code> as linear combinations of the set of local shape functions on <code>element2</code>. More precisely <code>restrict</code> returns an <code>NxM</code> matrix <code>P</code> such that the <code>i</code>-th local shape <span>$g_i$</span> function on element2 can be written as:</p><p><span>$g_i = sum_{j=1}^{M} P_{ij} f_j$</span></p></div></div></section><pre><code class="language-none">BEAST.rhs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.rt_cedge" href="#BEAST.rt_cedge"><code>BEAST.rt_cedge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_cedge(cps::Array{Int,2}, weight)</code></pre><p>Computes single basis function with equally distributed constant current leaving or entering port defined by cellpairs cps.  weight defines the total current over the port and its direction (+ve = out, -ve = in)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.rt_ports" href="#BEAST.rt_ports"><code>BEAST.rt_ports</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_ports(Γ::Mesh, γ::Mesh ...)</code></pre><p>Constructs the RT space on <code>Γ</code>, relative to boundary pairs in <code>γ</code>. <code>γ</code> expects any number of pairs-of-ports as arguments and accepts tuples, arrays, vectors etc. e.g <code>rt_ports(Γ, a, b ...);</code> where a = [γ₁ γ₂], b = (γ₃,γ₄) etc. <code>rt_ports</code> with no pair of ports supplied i.e <code>rt_ports(Γ)</code> reduces to the <code>raviartthomas(Γ)</code> function. The RT space ensures current continuity in each pair of ports. i.e. current leaving mesh Γ through γ₁ is accounted for in γ₂.</p><p>Returns the RT basis object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.rt_vedge" href="#BEAST.rt_vedge"><code>BEAST.rt_vedge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rt_vedge(cps::Array{Int,2}, weight)</code></pre><p>Computes n-1 basis function with oscillating current in(leaving and entering) pairs of half triangles defined over port specified by cellpairs cps. weight defines the magnitude of individual current in and out the half triangles, and it&#39;s polarity simply defines whether to start with in or out</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.scalartype" href="#BEAST.scalartype"><code>BEAST.scalartype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scalartype(x)</code></pre><p>The scalar field over which the values of a global or local basis function, or an operator are defined. This should always be a scalar type, even if the basis or operator takes on values in a vector or tensor space. This data type is used to determine the <code>eltype</code> of assembled discrete operators.</p></div></div></section><pre><code class="language-none">BEAST.shapevals</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.singleduallagd0" href="#BEAST.singleduallagd0"><code>BEAST.singleduallagd0</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">singleduallagd0(fine, F, v)</code></pre><p>Build a single dual constant Lagrange element a mesh <code>fine</code>. <code>F</code> contains the indices to cells in the support and v is the index in the vertex list of the defining vertex.</p></div></div></section><pre><code class="language-none">BEAST.singularpart</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.solve" href="#BEAST.solve"><code>BEAST.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Solves a variational equation by simply creating the full system matrix and calling a traditional lu decomposition.</p></div></div></section><pre><code class="language-none">BEAST.sortneighbors</code></pre><pre><code class="language-none">BEAST.spatialbasis</code></pre><pre><code class="language-none">BEAST.strace</code></pre><pre><code class="language-none">BEAST.subReferenceSpace</code></pre><pre><code class="language-none">BEAST.subdBasis</code></pre><pre><code class="language-none">BEAST.subdsurface</code></pre><pre><code class="language-none">BEAST.subset</code></pre><pre><code class="language-none">BEAST.substitute</code></pre><pre><code class="language-none">BEAST.sysmatrix</code></pre><pre><code class="language-none">BEAST.td_solve</code></pre><pre><code class="language-none">BEAST.temporalassemblydata</code></pre><pre><code class="language-none">BEAST.temporalbasis</code></pre><pre><code class="language-none">BEAST.testfunc1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.timebasisc0d1" href="#BEAST.timebasisc0d1"><code>BEAST.timebasisc0d1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timebasisc0d1(type, timestep, numfunctions)</code></pre><p>Build the space of continuous, piecewise linear time basis functions. The DoFs are the time steps. <code>numfunctions</code> basis functions will be built in total.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.timebasiscxd0" href="#BEAST.timebasiscxd0"><code>BEAST.timebasiscxd0</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timebasiscxd0(timestep, numfunctions, T::Type=Float64)</code></pre><p>Create a temporal basis based on shifted copies of the nodal continuous, piecewise linear interpolant.</p></div></div></section><pre><code class="language-none">BEAST.timebasisdelta</code></pre><pre><code class="language-none">BEAST.timebasisshiftedlagrange</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEAST.timebasisspline2" href="#BEAST.timebasisspline2"><code>BEAST.timebasisspline2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">timebasisspline2(timestep, numfunctions, T::Type=Float64)</code></pre><p>Create a temporal basis based on shifted copies of the quadratic spline. The spline is the convolution of a cxd0 and a c0d1 basis function.</p></div></div></section><pre><code class="language-none">BEAST.timeintegrals!</code></pre><pre><code class="language-none">BEAST.timequadrule</code></pre><pre><code class="language-none">BEAST.timestep</code></pre><pre><code class="language-none">BEAST.tmRoR</code></pre><pre><code class="language-none">BEAST.tmRoRf</code></pre><pre><code class="language-none">BEAST.valuetype</code></pre><pre><code class="language-none">BEAST.x̂</code></pre><pre><code class="language-none">BEAST.×</code></pre><pre><code class="language-none">BEAST.ŷ</code></pre><pre><code class="language-none">BEAST.ẑ</code></pre><pre><code class="language-none">BEAST.∂n</code></pre><pre><code class="language-none">BEAST.⊗</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
