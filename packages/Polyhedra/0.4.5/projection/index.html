<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Projection/Elimination · Polyhedra</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Polyhedra</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../representation/">Representation</a></li><li><a class="toctext" href="../polyhedron/">Polyhedron</a></li><li><a class="toctext" href="../redundancy/">Containment/Redundancy</a></li><li class="current"><a class="toctext" href>Projection/Elimination</a><ul class="internal"><li><a class="toctext" href="#Projection/Elimination-1">Projection/Elimination</a></li></ul></li><li><a class="toctext" href="../optimization/">Optimization</a></li><li><a class="toctext" href="../utilities/">Utilities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Projection/Elimination</a></li></ul></nav><hr/><div id="topbar"><span>Projection/Elimination</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Projection/Elimination-1" href="#Projection/Elimination-1">Projection/Elimination</a></h2><p>Consider the polyhedron created in the beginning of this section. As a reminder, it represents the following H-representation:</p><div>\[\begin{align*}
  x_1 + x_2 &amp;\leq 1 \\
  x_1 - x_2 &amp;\leq 0 \\
  x_1 &amp; \geq 0.
\end{align*}\]</div><p>One can verify that for any <span>$0 \leq x_2 \leq 1$</span>, there exists a value <span>$x_1$</span> such that <span>$(x_1, x_2)$</span> is in this polyhedron. This means that the H-representation obtained by eliminating <span>$x_1$</span> is:</p><div>\[\begin{align*}
  x_1 &amp; \leq 1 \\
  x_1 &amp; \geq 0.
\end{align*}\]</div><p>where <span>$x_1$</span> in the H-representation above represents <span>$x_2$</span> in the previous one. This can be obtained as follows</p><pre><code class="language-julia">julia&gt; poly_x2 = eliminate(poly, [1])
julia&gt; hrep(poly_x2)
H-representation
begin
 2 2 rational
 1//1 -1//1
 0//1 1//1
end</code></pre><p>There is two methods of computing the elimination implemented in CDDLib: Fourier-Motzkin elimination and block elimination. As written by K. Fukuda in CDD&#39;s documentation, &quot;[Block elimination] might be a faster way to eliminate variables than the repeated [Fourier-Motzkin elimination] when the number of variables to eliminate is large&quot;. You can specify the method to use as a third argument, e.g. <code>eliminate(poly, [1], FourierMotzkin())</code>, <code>eliminate(poly, [1], BlockElimination())</code>. A third method can be chosen: <code>ProjectGenerators</code>. It computes the V-representation and then project each of its elements. This is the method of choice when the V-representation is already computed.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.FourierMotzkin" href="#Polyhedra.FourierMotzkin"><code>Polyhedra.FourierMotzkin</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FourierMotzkin</code></pre><p>Computation of the projection by computing the H-representation and applying the Fourier-Motzkin elimination algorithm to it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.BlockElimination" href="#Polyhedra.BlockElimination"><code>Polyhedra.BlockElimination</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BlockElimination</code></pre><p>Computation of the projection by computing the H-representation and applying the block elimination algorithm to it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.ProjectGenerators" href="#Polyhedra.ProjectGenerators"><code>Polyhedra.ProjectGenerators</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ProjectGenerators</code></pre><p>Computation of the projection by computing the V-representation and projecting them.</p></div></div></section><p>If nothing is specified as in the block of code above, the behavior depends on the polyhedral library. If neither Fourier-Motzkin nor block elimination is implemented or if the V-representation is already computed then <code>:ProjectGenerators</code> is chosen. Otherwise, Polyhedra lets the library decide. In CDDLib, <code>:FourierMotzkin</code> is chosen when only the last dimension needs to be eliminated and <code>:BlockElimination</code> is chosen otherwise. Note that CDDLib only supports projecting the last trailing dimensions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.eliminate" href="#Polyhedra.eliminate"><code>Polyhedra.eliminate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eliminate(p::Polyhedron, delset, algo::EliminationAlgorithm)</code></pre><p>Eliminate the dimensions in <code>delset</code> by projecting the polyhedron onto the remaining dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.project" href="#Polyhedra.project"><code>Polyhedra.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">project(p::Polyhedron, pset, algo)

Equivalent to `eliminate(p, setdiff(1:fulldim(p), pset), algo).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.fixandeliminate" href="#Polyhedra.fixandeliminate"><code>Polyhedra.fixandeliminate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fixandeliminate(p::HRep{T}, I, v)</code></pre><p>Fix the variables with indices in <code>I</code> to the corresponding value in <code>v</code>. This is equivalent to doing the following:</p><pre><code class="language-julia">function ei(i)
    a = zeros(T, fulldim(p))
    a[i] = one(T)
    a
end
eliminate(p ∩ HyperPlane(ei(I[1], v[1]) ∩ ... ∩ HyperPlane(ei(I[1], v[1]))</code></pre><p>but it is much more efficient. The code above does a polyhedral projection while this function simply replace each halfspace <code>⟨a, x⟩ ≤ β</code> (resp. each hyperplane <code>⟨a, x⟩ = β</code>) by the halfspace <code>⟨a_J, x⟩ ≤ β - ⟨a_I, v⟩</code> (resp. the hyperplane <code>⟨a_J, x⟩ = β - ⟨a_I, v⟩</code>) where <code>J = setdiff(1:fulldim(p), I)</code>.</p></div></div></section><footer><hr/><a class="previous" href="../redundancy/"><span class="direction">Previous</span><span class="title">Containment/Redundancy</span></a><a class="next" href="../optimization/"><span class="direction">Next</span><span class="title">Optimization</span></a></footer></article></body></html>
