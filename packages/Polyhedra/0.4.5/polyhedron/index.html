<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polyhedron · Polyhedra</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Polyhedra</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../representation/">Representation</a></li><li class="current"><a class="toctext" href>Polyhedron</a><ul class="internal"><li><a class="toctext" href="#Retrieving-a-representation-1">Retrieving a representation</a></li><li><a class="toctext" href="#Checking-if-a-representation-has-been-computed-1">Checking if a representation has been computed</a></li><li><a class="toctext" href="#Incidence-1">Incidence</a></li><li><a class="toctext" href="#Default-libraries-1">Default libraries</a></li></ul></li><li><a class="toctext" href="../redundancy/">Containment/Redundancy</a></li><li><a class="toctext" href="../projection/">Projection/Elimination</a></li><li><a class="toctext" href="../optimization/">Optimization</a></li><li><a class="toctext" href="../utilities/">Utilities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Polyhedron</a></li></ul></nav><hr/><div id="topbar"><span>Polyhedron</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Polyhedron-1" href="#Polyhedron-1">Polyhedron</a></h1><p>As seen in the previous section, a polyhedron can be described in 2 ways: either using the H-representation (intersection of halfspaces) or the V-representation (convex hull of points and rays). The problem of computing the H-representation from the V-representation (or vice versa) is called the <em>representation conversion problem</em>. It can be solved by the Double-Description method</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.doubledescription" href="#Polyhedra.doubledescription"><code>Polyhedra.doubledescription</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">doubledescription(h::HRepresentation)</code></pre><p>Computes the V-representation of the polyhedron represented by <code>h</code> using the Double-Description algorithm [1, 2].</p><pre><code class="language-none">doubledescription(V::VRepresentation)</code></pre><p>Computes the H-representation of the polyhedron represented by <code>v</code> using the Double-Description algorithm [1, 2].</p><p>[1] Motzkin, T. S., Raiffa, H., Thompson, G. L. and Thrall, R. M. The double description method <em>Contribution to the Theory of Games</em>, <em>Princeton University Press</em>, <strong>1953</strong></p><p>[2] Fukuda, K. and Prodon, A. Double description method revisited <em>Combinatorics and computer science</em>, <em>Springer</em>, <strong>1996</strong>, 91-111</p></div></div></section><p>However, other methods exist such as the reverse search implemented by <a href="https://github.com/JuliaPolyhedra/LRSLib.jl">LRS</a> and the quick hull algorithm implemented by <a href="https://github.com/JuliaPolyhedra/QHull.jl">qhull</a>.</p><p>This motivates the creation of a type representing polyhedra, transparently handling the conversion from H-representation to V-representation when needed for some operation. Just like the abstract type <code>AbstractArray{N,T}</code> represents an <code>N</code>-dimensional array with elements of type <code>T</code>, the abstract type <code>Polyhedron{N,T}</code> represents an <code>N</code>-dimensional polyhedron with elements of coefficient type <code>T</code>.</p><p>There is typically one concrete subtype of <code>Polyhedron</code> by library. For instance, the CDD library defines <code>CDDLib.Polyhedron</code> and the LRS library defines <code>LRSLib.Polyhedron</code>. It must be said that the type <code>T</code> is not necessarily how the elements are stored internally by the library but the polyhedron will behave just like it is stored that way. For instance, when retreiving an H-(or V-)representation, the representation will be of type <code>T</code>. Therefore using <code>Int</code> for <code>T</code> may result in <code>InexactError</code>. For this reason, by default, the type <code>T</code> chosen is not a subtype of <code>Integer</code>.</p><p>A polyhedron can be created from a representation and a library using the <code>polyhedron</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.polyhedron" href="#Polyhedra.polyhedron"><code>Polyhedra.polyhedron</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">polyhedron(rep::Representation{T})</code></pre><p>Creates a polyhedron from the representation <code>rep</code> using the default library including in the Polyhedra package.</p></div></div></section><p>To illustrate the usage of the <code>polyhedron</code> function, consider the following representations:</p><pre><code class="language-julia">hr = HalfSpace([1, 1], 1) ∩ HalfSpace([1, -1], 0) ∩ HalfSpace([-1, 0], 0)
vre = convexhull([0, 0], [0, 1], [1//2, 1//2])
vrf = convexhull([0, 0], [0, 1], [1/2, 1/2])</code></pre><p>One can use the CDD library, to create an instance of a concrete subtype of <code>Polyhedron</code> as follows:</p><pre><code class="language-julia">julia&gt; using CDDLib
julia&gt; polyf = polyhedron(hr, CDDLib.Library())
julia&gt; typeof(polyhf)
CDDLib.CDDLib.Polyhedron{2,Float64}</code></pre><p>We see that the library has choosen to deal with floating point arithmetic. This decision does not depend on the type of <code>hr</code> but only on the instance of <code>CDDLib.Library</code> given. <code>CDDLib.Library</code> creates <code>CDDLib.Polyhedron</code> of type either <code>Float64</code> or <code>Rational{BigInt}</code>. One can choose the first one using <code>CDDLib.Library(:float)</code> and the second one using <code>CDDLib.Library(:exact)</code>, by default it is <code>:float</code>.</p><pre><code class="language-julia">julia&gt; poly = polyhedron(hr, CDDLib.Library(:exact))
julia&gt; typeof(poly)
CDDLib.Polyhedron{2,Rational{BigInt}}</code></pre><p>The first polyhedron <code>polyf</code> can also be created from its V-representation using either of the 4 following lines:</p><pre><code class="language-julia">julia&gt; polyf = polyhedron(vrf, CDDLib.Library(:float))
julia&gt; polyf = polyhedron(vrf, CDDLib.Library())
julia&gt; polyf = polyhedron(vre,  CDDLib.Library(:float))
julia&gt; polyf = polyhedron(vre,  CDDLib.Library())</code></pre><p>and <code>poly</code> using either of those lines:</p><pre><code class="language-julia">julia&gt; poly = polyhedron(vrf, CDDLib.Library(:exact))
julia&gt; poly = polyhedron(vre, CDDLib.Library(:exact))</code></pre><p>Of course, creating a representation in floating points with exact arithmetic works here because we have <code>0.5</code> which is <code>0.1</code> in binary but in general, is not a good idea.</p><pre><code class="language-julia">julia&gt; Rational{BigInt}(1/2)
1//2
julia&gt; Rational{BigInt}(1/3)
6004799503160661//18014398509481984
julia&gt; Rational{BigInt}(1/5)
3602879701896397//18014398509481984</code></pre><h2><a class="nav-anchor" id="Retrieving-a-representation-1" href="#Retrieving-a-representation-1">Retrieving a representation</a></h2><p>One can retrieve an H-representation (resp. V-representation) from a polyhedron using <code>hrep</code> (resp. <code>vrep</code>). The concrete subtype of <code>HRepresentation</code> (resp. <code>VRepresentation</code>) returned is not necessarily the same that the one used to create the polyhedron. As a rule of thumb, it is the representation the closest to the internal representation used by the library.</p><pre><code class="language-julia">julia&gt; hr = hrep(poly)
julia&gt; typeof(hr)
Polyhedra.LiftedHRepresentation{2,Rational{BigInt}}
julia&gt; hr = MixedMatHRep(hr)
julia&gt; typeof(hr)
Polyhedra.MixedMatHRep{2,Rational{BigInt}}
julia&gt; hr.A
3x2 Array{Rational{BigInt},2}:
  1//1   1//1
  1//1  -1//1
 -1//1   0//1
julia&gt; hr.b
3-element Array{Rational{BigInt},1}:
 1//1
 0//1
 0//1
julia&gt; vr = vrep(poly)
julia&gt; typeof(vr)
Polyhedra.LiftedVRepresentation{2,Rational{BigInt}}
julia&gt; vr = MixedMatVRep(vrep)
julia&gt; typeof(vr)
Polyhedra.MixedMatVRep{2,Rational{BigInt}}
julia&gt; vr.V
3x2 Array{Rational{BigInt},2}:
 1//2  1//2
 0//1  1//1
 0//1  0//1

julia&gt; vr.R
0x2 Array{Rational{BigInt},2}</code></pre><h2><a class="nav-anchor" id="Checking-if-a-representation-has-been-computed-1" href="#Checking-if-a-representation-has-been-computed-1">Checking if a representation has been computed</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.hrepiscomputed" href="#Polyhedra.hrepiscomputed"><code>Polyhedra.hrepiscomputed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hrepiscomputed(p::Polyhedron)</code></pre><p>Returns whether the H-representation of this polyhedron has been computed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.vrepiscomputed" href="#Polyhedra.vrepiscomputed"><code>Polyhedra.vrepiscomputed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vrepiscomputed(p::Polyhedron)</code></pre><p>Returns whether the V-representation of this polyhedron has been computed.</p></div></div></section><h2><a class="nav-anchor" id="Incidence-1" href="#Incidence-1">Incidence</a></h2><p>Elements can be accessed in a representation or polyhedron using indices and <code>Base.get</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.Index" href="#Polyhedra.Index"><code>Polyhedra.Index</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Index{T, ElemT}</code></pre><p>Index of an element of type <code>ElemT</code> in a <code>Rep{T}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.Indices" href="#Polyhedra.Indices"><code>Polyhedra.Indices</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Indices{T, ElemT, RepT&lt;:Rep{T}}</code></pre><p>Iterator over the indices of the elements of type <code>ElemT</code> of the field <code>rep</code>.</p></div></div></section><p>The list of indices can be obtained using, e.g., <code>eachindex(points(rep))</code>. For instance, the following prints all points using indices</p><pre><code class="language-julia">for pi in eachindex(points(rep))
    @show get(rep, pi)
end</code></pre><p>A point <span>$p$</span> (resp. ray <span>$r$</span>) is incident to an halfspace <span>$\langle a, x \rangle \le \beta$</span> if <span>$\langle a, p \rangle = \beta$</span> (resp. <span>$\langle a, r \rangle = \beta$</span>).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidenthalfspaces" href="#Polyhedra.incidenthalfspaces"><code>Polyhedra.incidenthalfspaces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidenthalfspaces(p::Polyhedron, idx)</code></pre><p>Returns the list of halfspaces incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidenthalfspaceindices" href="#Polyhedra.incidenthalfspaceindices"><code>Polyhedra.incidenthalfspaceindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidenthalfspaceindices(p::Polyhedron, idx)</code></pre><p>Returns the list of the indices of halfspaces incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentpoints" href="#Polyhedra.incidentpoints"><code>Polyhedra.incidentpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentpoints(p::Polyhedron, idx)</code></pre><p>Returns the list of points incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentpointindices" href="#Polyhedra.incidentpointindices"><code>Polyhedra.incidentpointindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentpointindices(p::Polyhedron, idx)</code></pre><p>Returns the list of the indices of points incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentrays" href="#Polyhedra.incidentrays"><code>Polyhedra.incidentrays</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentrays(p::Polyhedron, idx)</code></pre><p>Returns the list of rays incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentrayindices" href="#Polyhedra.incidentrayindices"><code>Polyhedra.incidentrayindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentrayindices(p::Polyhedron, idx)</code></pre><p>Returns the list of the indices of rays incident to idx for the polyhedron <code>p</code>.</p></div></div></section><p>In a polyhedron, all points and rays are incident to all hyperplanes and all halfspaces are incident to all lines. The following methods are therefore redundant, e.g. <code>incidenthyperplanes(p, idx)</code> is equivalent to <code>hyperplanes(p)</code> and <code>incidenthyperplaneindices(p, idx)</code> is equivalent to <code>eachindex(hyperplanes(p))</code>. The methods are hence only defined for consistency.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidenthyperplanes" href="#Polyhedra.incidenthyperplanes"><code>Polyhedra.incidenthyperplanes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidenthyperplanes(p::Polyhedron, idx)</code></pre><p>Returns the list of hyperplanes incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidenthyperplaneindices" href="#Polyhedra.incidenthyperplaneindices"><code>Polyhedra.incidenthyperplaneindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidenthyperplaneindices(p::Polyhedron, idx)</code></pre><p>Returns the list of the indices of hyperplanes incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentlines" href="#Polyhedra.incidentlines"><code>Polyhedra.incidentlines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentlines(p::Polyhedron, idx)</code></pre><p>Returns the list of lines incident to idx for the polyhedron <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.incidentlineindices" href="#Polyhedra.incidentlineindices"><code>Polyhedra.incidentlineindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">incidentlineindices(p::Polyhedron, idx)</code></pre><p>Returns the list of the indices of lines incident to idx for the polyhedron <code>p</code>.</p></div></div></section><h2><a class="nav-anchor" id="Default-libraries-1" href="#Default-libraries-1">Default libraries</a></h2><p>The following functions allows to select a default library:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.default_library" href="#Polyhedra.default_library"><code>Polyhedra.default_library</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">default_library(d::FullDim, ::Type{T}) where {T}</code></pre><p>Returns the default polyhedral library for <code>d</code>-dimensional polyhedron of coefficient type <code>T</code>.</p><p><strong>Examples</strong></p><p>To obtain the default library for 2-dimensional polyhedra of eltype <code>Float64</code>, do <code>default_library(2, Float64)</code>.</p><p>Given an <code>StaticArrays.SVector</code> <code>v</code>, to obtain a default library for points of the type of <code>v</code> in a type stable way, do <code>default_library(Polyhedra.FullDim(v), eltype(v))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.similar_library" href="#Polyhedra.similar_library"><code>Polyhedra.similar_library</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">similar_library(lib::Library, d::FullDim, T::Type)</code></pre><p>Returns a library that supports polyhedra of full dimension <code>T</code> with coefficient type <code>T</code>. If <code>lib</code> does not support it, this commonly calls <code>default_library(d, T)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.library" href="#Polyhedra.library"><code>Polyhedra.library</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">library(p::Polyhedron)</code></pre><p>Returns the library used by <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.default_type" href="#Polyhedra.default_type"><code>Polyhedra.default_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">default_type(d::FullDim, ::Type{T}) where {T}</code></pre><p>Returns the default polyhedron type for <code>d</code>-dimensional polyhedron of coefficient type <code>T</code>.</p></div></div></section><p>The following libraries serves as fallback:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.DefaultLibrary" href="#Polyhedra.DefaultLibrary"><code>Polyhedra.DefaultLibrary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultLibrary{T}</code></pre><p>Default library for polyhedra of dimension larger than 1 (<a href="#Polyhedra.IntervalLibrary"><code>IntervalLibrary</code></a> is the default for polyhedra of dimension 1). The library implements the bare minimum and uses the fallback implementation for all operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.IntervalLibrary" href="#Polyhedra.IntervalLibrary"><code>Polyhedra.IntervalLibrary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IntervalLibrary{T}</code></pre><p>Default library for polyhedra of dimension 1. Many aspect of polyhedral computation become trivial in one dimension. This library exploits this fact. The library is also used as a fallback for libraries that do not support 1-dimensional polyhedra (e.g. qhull). That is projecting a polyhedron using such library produces a polyhedron using <code>IntervalLibrary</code>.</p></div></div></section><p>The type and library of the polyhedron obtained after applying an operation of several polyhedra (of possibly different type and/or library) is determined by the <code>similar</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">similar(p::Tuple{Vararg{Polyhedra.Rep}}, d::Polyhedra.FullDim, ::Type{T}, it::Polyhedra.It{T}...)</code></pre><p>Creates a representation with a type similar to <code>p</code> of a polyhedron of full dimension <code>d</code>, element type <code>T</code> and initialize it with the iterators <code>it</code>. The type of the result will be chosen closer to the type of <code>p[1]</code>.</p></div></div></section><footer><hr/><a class="previous" href="../representation/"><span class="direction">Previous</span><span class="title">Representation</span></a><a class="next" href="../redundancy/"><span class="direction">Next</span><span class="title">Containment/Redundancy</span></a></footer></article></body></html>
