<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type Conversions · LibPQ.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LibPQ.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li class="current"><a class="toctext" href="type-conversions.html">Type Conversions</a><ul class="internal"><li><a class="toctext" href="#From-Julia-to-PostgreSQL-1">From Julia to PostgreSQL</a></li><li><a class="toctext" href="#From-PostgreSQL-to-Julia-1">From PostgreSQL to Julia</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li><li><a class="toctext" href="faq.html">FAQ</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="type-conversions.html">Type Conversions</a></li></ul></nav><hr/><div id="topbar"><span>Type Conversions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="typeconv-1" href="#typeconv-1">Type Conversions</a></h1><p>The implementation of type conversions across the LibPQ.jl interface is sufficiently complicated that it warrants its own section in the documentation. Luckily, it should be easy to <em>use</em> for whichever case you need.</p><h2><a class="nav-anchor" id="From-Julia-to-PostgreSQL-1" href="#From-Julia-to-PostgreSQL-1">From Julia to PostgreSQL</a></h2><p>Currently all types are printed to strings and given to LibPQ as such, with no special treatment. Expect this to change in a future release. For now, you can convert the data to strings yourself before passing to <a href="api.html#LibPQ.execute"><code>execute</code></a>. This should only be necessary for data types whose Julia string representation is not valid in PostgreSQL, such as arrays.</p><pre><code class="language-julia-repl">julia&gt; A = collect(12:15);

julia&gt; nt = fetch!(NamedTuple, execute(conn, &quot;SELECT \$1 = ANY(\$2) AS result&quot;, Any[13, string(&quot;{&quot;, join(A, &quot;,&quot;), &quot;}&quot;)]));

julia&gt; nt[:result][1]
true</code></pre><h2><a class="nav-anchor" id="From-PostgreSQL-to-Julia-1" href="#From-PostgreSQL-to-Julia-1">From PostgreSQL to Julia</a></h2><p>The default type conversions applied when fetching PostgreSQL data should be sufficient in many cases.</p><pre><code class="language-julia">julia&gt; df = fetch!(DataFrame, execute(conn, &quot;SELECT 1::int4, &#39;foo&#39;::varchar, &#39;{1.0, 2.1, 3.3}&#39;::float8[], false, TIMESTAMP &#39;2004-10-19 10:23:54&#39;&quot;))
1×5 DataFrames.DataFrame
│ Row │ int4 │ varchar │ float8          │ bool  │ timestamp           │
├─────┼──────┼─────────┼─────────────────┼───────┼─────────────────────┤
│ 1   │ 1    │ foo     │ [1.0, 2.1, 3.3] │ false │ 2004-10-19T10:23:54 │</code></pre><p>The column types in Julia for the above DataFrame are <code>Int32</code>, <code>String</code>, <code>Vector{Float64}</code>, <code>Bool</code>, and <code>DateTime</code>.</p><p>Any unknown or unsupported types are parsed as <code>String</code>s by default.</p><h3><a class="nav-anchor" id="NULL-1" href="#NULL-1"><code>NULL</code></a></h3><p>The PostgreSQL <code>NULL</code> is handled with <code>missing</code>. By default, data streamed using DataStreams is <code>Union{T, Missing}</code>, and columns are <code>Vector{Union{T, Missing}}</code>. While <code>libpq</code> does not provide an interface for checking whether a result column contains <code>NULL</code>, it&#39;s possible to assert that columns do not contain <code>NULL</code> using the <code>not_null</code> keyword argument to <a href="api.html#LibPQ.execute"><code>execute</code></a>. This will result in data retrieved as <code>T</code>/<code>Vector{T}</code> instead. <code>not_null</code> accepts a list of column names or column positions, or a <code>Bool</code> asserting that all columns do or do not have the possiblity of <code>NULL</code>.</p><p>The type-related interfaces described below only deal with the <code>T</code> part of the <code>Union{T, Missing}</code>, and there is currently no way to use an alternate <code>NULL</code> representation.</p><h3><a class="nav-anchor" id="Overrides-1" href="#Overrides-1">Overrides</a></h3><p>It&#39;s possible to override the default type conversion behaviour in several places. Refer to the <a href="type-conversions.html#Implementation-1">Implementation</a> section for more detailed information.</p><h4><a class="nav-anchor" id="Query-level-1" href="#Query-level-1">Query-level</a></h4><p>There are three arguments to <a href="api.html#LibPQ.execute"><code>execute</code></a> for this:</p><ul><li><code>column_types</code> argument to set the desired types for given columns. This is accepted as a dictionary mapping column names (as <code>Symbol</code>s or <code>String</code>s) and/or positions (as <code>Integer</code>s) to Julia types.</li><li><code>type_map</code> argument to set the mapping from PostgreSQL types to Julia types. This is accepted as a dictionary mapping PostgreSQL oids (as <code>Integer</code>s) or <a href="type-conversions.html#canon-1">canonical</a> type names (as <code>Symbol</code>s or <code>String</code>s) to Julia types.</li><li><code>conversions</code> argument to set the <em>function</em> used to convert from a given PostgreSQL type to a given Julia type. This is accepted as a dictionary mapping 2-tuples of PostgreSQL oids or type names (as above) and Julia types to callables (functions or type constructors).</li></ul><h4><a class="nav-anchor" id="Connection-level-1" href="#Connection-level-1">Connection-level</a></h4><p><a href="api.html#LibPQ.Connection"><code>LibPQ.Connection</code></a> supports <code>type_map</code> and <code>conversions</code> arguments as well, which will apply to all queries run with the created connection. Query-level overrides will override connection-level overrides.</p><h4><a class="nav-anchor" id="Global-1" href="#Global-1">Global</a></h4><p>To override behaviour for every query everywhere, add mappings to the global constants <a href="api.html#LibPQ.LIBPQ_TYPE_MAP"><code>LibPQ.LIBPQ_TYPE_MAP</code></a> and <a href="api.html#LibPQ.LIBPQ_CONVERSIONS"><code>LibPQ.LIBPQ_CONVERSIONS</code></a>. Connection-level overrides will override these global overrides.</p><h3><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h3><h4><a class="nav-anchor" id="Flow-1" href="#Flow-1">Flow</a></h4><p>When a <a href="api.html#LibPQ.Result"><code>LibPQ.Result</code></a> is created (as the result of running a query), the Julia types and conversion functions for each column are precalculated and stored within the <code>Result</code>. The types are chosen using these sources, in decreasing priority:</p><ul><li><code>column_types</code> overrides at <code>Result</code> level</li><li><code>type_map</code> overrides at <code>Result</code> level</li><li><code>type_map</code> overrides at <code>Connection</code> level</li><li><a href="api.html#LibPQ.LIBPQ_TYPE_MAP"><code>LibPQ.LIBPQ_TYPE_MAP</code></a></li><li><a href="api.html#LibPQ._DEFAULT_TYPE_MAP"><code>LibPQ._DEFAULT_TYPE_MAP</code></a></li><li>fallback to <code>String</code></li></ul><p>Using those types, the function for converting from PostgreSQL data to Julia data is selected, using these sources, in decreasing priority:</p><ul><li><code>conversions</code> overrides at <code>Result</code> level</li><li><code>conversions</code> overrides at <code>Connection</code> level</li><li><a href="api.html#LibPQ.LIBPQ_CONVERSIONS"><code>LibPQ.LIBPQ_CONVERSIONS</code></a></li><li><a href="api.html#LibPQ._DEFAULT_CONVERSIONS"><code>LibPQ._DEFAULT_CONVERSIONS</code></a>,</li><li>fallback to <code>parse</code></li></ul><p>When fetching a particular value from a <code>Result</code>, that function is used to turn data wrapped by a <code>PQValue</code> to a Julia type. This operation always copies or parses data and never provides a view into the original <code>Result</code>.</p><h4><a class="nav-anchor" id="canon-1" href="#canon-1">Canonical PostgreSQL Type Names</a></h4><p>While PostgreSQL allows many aliases for its types (e.g., <code>double precision</code> for <code>float8</code> and <code>character varying</code> for <code>varchar</code>), there is one &quot;canonical&quot; name for the type stored in the <code>pg_type</code> table from PostgreSQL&#39;s catalog. You can find a list of these for all of PostgreSQL&#39;s default types in the keys of <a href="api.html#LibPQ.PQ_SYSTEM_TYPES"><code>LibPQ.PQ_SYSTEM_TYPES</code></a>.</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
