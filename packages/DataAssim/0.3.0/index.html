<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DataAssim.jl · DataAssim</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataAssim</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>DataAssim.jl</a><ul class="internal"><li><a class="toctext" href="#Simulation-driver-1">Simulation driver</a></li><li><a class="toctext" href="#Ensemble-methods-1">Ensemble methods</a></li><li><a class="toctext" href="#Models-1">Models</a></li><li><a class="toctext" href="#Utility-functions-1">Utility functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DataAssim.jl</a></li></ul></nav><hr/><div id="topbar"><span>DataAssim.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DataAssim.jl-1" href="#DataAssim.jl-1">DataAssim.jl</a></h1><p>Documentation for <a href="https://github.com/Alexander-Barth/DataAssim.jl">DataAssim.jl</a></p><h2><a class="nav-anchor" id="Simulation-driver-1" href="#Simulation-driver-1">Simulation driver</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.FreeRun" href="#DataAssim.FreeRun"><code>DataAssim.FreeRun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x,Hx = FreeRun(ℳ,xi,Q,H,nmax,no)</code></pre><p>Performs a free-run with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code>. Observations at the time steps given in <code>no</code> are  extracted with the observation operator <code>H</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.KalmanFilter" href="#DataAssim.KalmanFilter"><code>DataAssim.KalmanFilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x,P = KalmanFilter(xi,Pi,ℳ,Q,yo,R,H,nmax,no)</code></pre><p>Kalman Filter with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code> and error covariance <code>Pi</code>. Observations <code>yo</code> (and error covariance <code>R</code>) at the time steps given in <code>no</code> are assimilated with the observation operator <code>H</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.fourDVar" href="#DataAssim.fourDVar"><code>DataAssim.fourDVar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x,J = fourDVar(
        xi,Pi,ℳ,yo,R,H,nmax,no;
        innerloops = 10,
        outerloops = 2,
        tol = 1e-5)</code></pre><p>Incremental 4D-Var with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code> and error covariance <code>Pi</code>. Observations <code>yo</code> (and error covariance <code>R</code>) at the time steps given in <code>no</code> are assimilated with the observation operator <code>H</code>.</p></div></div></section><h2><a class="nav-anchor" id="Ensemble-methods-1" href="#Ensemble-methods-1">Ensemble methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.ETKF" href="#DataAssim.ETKF"><code>DataAssim.ETKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.ETKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.ETKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.EnKF" href="#DataAssim.EnKF"><code>DataAssim.EnKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.EnKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.EnKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.EnSRF" href="#DataAssim.EnSRF"><code>DataAssim.EnSRF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.EnSRF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.EnSRF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.EAKF" href="#DataAssim.EAKF"><code>DataAssim.EAKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.EAKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.EAKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.SEIK" href="#DataAssim.SEIK"><code>DataAssim.SEIK</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.SEIK(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.SEIK ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.ESTKF" href="#DataAssim.ESTKF"><code>DataAssim.ESTKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.ESTKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.ESTKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.serialEnSRF" href="#DataAssim.serialEnSRF"><code>DataAssim.serialEnSRF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.serialEnSRF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the DataAssim.serialEnSRF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_ETKF" href="#DataAssim.local_ETKF"><code>DataAssim.local_ETKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_ETKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.ETKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_EnKF" href="#DataAssim.local_EnKF"><code>DataAssim.local_EnKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_EnKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.EnKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_EnSRF" href="#DataAssim.local_EnSRF"><code>DataAssim.local_EnSRF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_EnSRF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.EnSRF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_EAKF" href="#DataAssim.local_EAKF"><code>DataAssim.local_EAKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_EAKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.EAKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_SEIK" href="#DataAssim.local_SEIK"><code>DataAssim.local_SEIK</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_SEIK(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.SEIK.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.local_ESTKF" href="#DataAssim.local_ESTKF"><code>DataAssim.local_ESTKF</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Xa,xa = DataAssim.local_ESTKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local DataAssim.ESTKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="language-none">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="language-none">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div></div></section><h2><a class="nav-anchor" id="Models-1" href="#Models-1">Models</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.AbstractModel" href="#DataAssim.AbstractModel"><code>DataAssim.AbstractModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base-class of models. A model should implement forecast step, tangent-linear and adjoint step</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.ModelMatrix" href="#DataAssim.ModelMatrix"><code>DataAssim.ModelMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ℳ = ModelMatrix(M)</code></pre><p>Linear model defined by the matrix <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.ModelFun" href="#DataAssim.ModelFun"><code>DataAssim.ModelFun</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ℳ = ModelFun(nonlinear_forecast,tangent_linear_model,adjoint_model)</code></pre><p>Model defined by the functions <code>nonlinear_forecast</code>,<code>tangent_linear_model</code> and  <code>adjoint_model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.LinShallowWater1DModel" href="#DataAssim.LinShallowWater1DModel"><code>DataAssim.LinShallowWater1DModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ℳ = LinShallowWater1DModel(dt,g,h,L,imax)</code></pre><p>Linear 1D shallow water model.</p><p><strong>Example</strong></p><pre><code class="language-julia">dt = 1.
g = 9.81
h = 100
imax = 101
L = 10000
LinShallowWater1DModel(dt,g,h,L,imax)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.Lorenz63Model" href="#DataAssim.Lorenz63Model"><code>DataAssim.Lorenz63Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ℳ = Lorenz63Model(dt,σ=10.,β = 8/3.,ρ = 28.)</code></pre><p>Lorenz, 1963 model[1] integrated with a 2nd order Runge-Kutta scheme.</p><p>[1] https://doi.org/10.1175/1520-0469(1963)020%3C0130:DNF%3E2.0.CO;2</p></div></div></section><h2><a class="nav-anchor" id="Utility-functions-1" href="#Utility-functions-1">Utility functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAssim.compact_locfun" href="#DataAssim.compact_locfun"><code>DataAssim.compact_locfun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> fun = compact_locfun(r)</code></pre><p>Smooth compact localization function at the (scaled) distance <code>r</code>. <code>fun</code> is zero if <code>r</code> &gt; 2 and one if <code>r</code> is 0. (Gaspari et al. (1999), equation 4.10, [1])</p><p>[1] http://dx.doi.org/10.1002/qj.49712555417</p></div></div></section><footer><hr/></footer></article></body></html>
