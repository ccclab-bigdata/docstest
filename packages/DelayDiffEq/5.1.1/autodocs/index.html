<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · DelayDiffEq.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DelayDiffEq.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">DelayDiffEq.AB3</code></pre><pre><code class="language-none">DelayDiffEq.AB4</code></pre><pre><code class="language-none">DelayDiffEq.AB5</code></pre><pre><code class="language-none">DelayDiffEq.ABDF2</code></pre><pre><code class="language-none">DelayDiffEq.ABM32</code></pre><pre><code class="language-none">DelayDiffEq.ABM43</code></pre><pre><code class="language-none">DelayDiffEq.ABM54</code></pre><pre><code class="language-none">DelayDiffEq.AN5</code></pre><pre><code class="language-none">DelayDiffEq.AbstractAnalyticalProblem</code></pre><pre><code class="language-none">DelayDiffEq.AbstractMethodOfStepsAlgorithm</code></pre><pre><code class="language-none">DelayDiffEq.AffineDiffEqOperator</code></pre><pre><code class="language-none">DelayDiffEq.AnalyticalProblem</code></pre><pre><code class="language-none">DelayDiffEq.Anas5</code></pre><pre><code class="language-none">DelayDiffEq.AutoDP5</code></pre><pre><code class="language-none">DelayDiffEq.AutoSwitch</code></pre><pre><code class="language-none">DelayDiffEq.AutoTsit5</code></pre><pre><code class="language-none">DelayDiffEq.AutoVern6</code></pre><pre><code class="language-none">DelayDiffEq.AutoVern7</code></pre><pre><code class="language-none">DelayDiffEq.AutoVern8</code></pre><pre><code class="language-none">DelayDiffEq.AutoVern9</code></pre><pre><code class="language-none">DelayDiffEq.BS3</code></pre><pre><code class="language-none">DelayDiffEq.BS5</code></pre><pre><code class="language-none">DelayDiffEq.BVProblem</code></pre><pre><code class="language-none">DelayDiffEq.CFRLDDRK64</code></pre><pre><code class="language-none">DelayDiffEq.CNAB2</code></pre><pre><code class="language-none">DelayDiffEq.CNLF2</code></pre><pre><code class="language-none">DelayDiffEq.CallbackSet</code></pre><pre><code class="language-none">DelayDiffEq.CalvoSanz4</code></pre><pre><code class="language-none">DelayDiffEq.CandyRoz4</code></pre><pre><code class="language-none">DelayDiffEq.CarpenterKennedy2N54</code></pre><pre><code class="language-none">DelayDiffEq.Cash4</code></pre><pre><code class="language-none">DelayDiffEq.CompositeAlgorithm</code></pre><pre><code class="language-none">DelayDiffEq.ContinuousCallback</code></pre><pre><code class="language-none">DelayDiffEq.DAEFunction</code></pre><pre><code class="language-none">DelayDiffEq.DAEProblem</code></pre><pre><code class="language-none">DelayDiffEq.DAESolution</code></pre><pre><code class="language-none">DelayDiffEq.DDEFunction</code></pre><pre><code class="language-none">DelayDiffEq.DDEIntegrator</code></pre><pre><code class="language-none">DelayDiffEq.DDEProblem</code></pre><pre><code class="language-none">DelayDiffEq.DEDataArray</code></pre><pre><code class="language-none">DelayDiffEq.DEDataMatrix</code></pre><pre><code class="language-none">DelayDiffEq.DEDataVector</code></pre><pre><code class="language-none">DelayDiffEq.DEFAULT_LINSOLVE</code></pre><pre><code class="language-none">DelayDiffEq.DESolution</code></pre><pre><code class="language-none">DelayDiffEq.DGLDDRK73_C</code></pre><pre><code class="language-none">DelayDiffEq.DGLDDRK84_C</code></pre><pre><code class="language-none">DelayDiffEq.DGLDDRK84_F</code></pre><pre><code class="language-none">DelayDiffEq.DP5</code></pre><pre><code class="language-none">DelayDiffEq.DP5Threaded</code></pre><pre><code class="language-none">DelayDiffEq.DP8</code></pre><pre><code class="language-none">DelayDiffEq.DPRKN12</code></pre><pre><code class="language-none">DelayDiffEq.DPRKN6</code></pre><pre><code class="language-none">DelayDiffEq.DPRKN8</code></pre><pre><code class="language-none">DelayDiffEq.DelayDiffEq</code></pre><pre><code class="language-none">DelayDiffEq.DelayDiffEqAlgorithm</code></pre><pre><code class="language-none">DelayDiffEq.DiffEqBase</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.Discontinuity" href="#DelayDiffEq.Discontinuity"><code>DelayDiffEq.Discontinuity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Discontinuity(t, order::Int)</code></pre><p>Object of discontinuity of order <code>order</code> at time <code>t</code>, i.e. discontinuity of <code>order</code>th derivative at time <code>t</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.DiscontinuityCallback" href="#DelayDiffEq.DiscontinuityCallback"><code>DelayDiffEq.DiscontinuityCallback</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DiscontinuityCallback(lags, discontinuities::Vector{&lt;:Discontinuity};
                      [interp_points::Int=10, abstol=1e-12, reltol=0])</code></pre><p>Callback that tracks <code>discontinuities</code> that are propagated by dependent <code>lags</code> of the form <code>(u,p,t) -&gt; lag(u,p,t)</code>.</p><p>Hereby a number <code>interp_points</code> of interpolation points are used to first check for different signs of functions <span>$f(t) = T + lag(u(t),p,t) - t$</span>, where <span>$T$</span> is time point of a previous discontinuity and <span>$t$</span> is contained in the current time interval. This shows that the current time interval contains propagated discontinuities of which the exact time point is then determined by a root finding algorithm. The sign at the lower bound of the time interval, i.e. at <code>tprev</code>, is set to 0 with absolute tolerance <code>abstol</code> and relative tolerance <code>reltol</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.DiscreteCallback</code></pre><pre><code class="language-none">DelayDiffEq.DiscreteFunction</code></pre><pre><code class="language-none">DelayDiffEq.DiscreteProblem</code></pre><pre><code class="language-none">DelayDiffEq.DynamicalODEFunction</code></pre><pre><code class="language-none">DelayDiffEq.DynamicalODEProblem</code></pre><pre><code class="language-none">DelayDiffEq.EPIRK4s3A</code></pre><pre><code class="language-none">DelayDiffEq.EPIRK4s3B</code></pre><pre><code class="language-none">DelayDiffEq.EPIRK5P1</code></pre><pre><code class="language-none">DelayDiffEq.EPIRK5P2</code></pre><pre><code class="language-none">DelayDiffEq.EPIRK5s3</code></pre><pre><code class="language-none">DelayDiffEq.ERKN4</code></pre><pre><code class="language-none">DelayDiffEq.ERKN5</code></pre><pre><code class="language-none">DelayDiffEq.ETD1</code></pre><pre><code class="language-none">DelayDiffEq.ETD2</code></pre><pre><code class="language-none">DelayDiffEq.ETDRK2</code></pre><pre><code class="language-none">DelayDiffEq.ETDRK3</code></pre><pre><code class="language-none">DelayDiffEq.ETDRK4</code></pre><pre><code class="language-none">DelayDiffEq.EXPRB53s3</code></pre><pre><code class="language-none">DelayDiffEq.Euler</code></pre><pre><code class="language-none">DelayDiffEq.Exp4</code></pre><pre><code class="language-none">DelayDiffEq.ExplicitRK</code></pre><pre><code class="language-none">DelayDiffEq.Exprb32</code></pre><pre><code class="language-none">DelayDiffEq.Exprb43</code></pre><pre><code class="language-none">DelayDiffEq.Feagin10</code></pre><pre><code class="language-none">DelayDiffEq.Feagin12</code></pre><pre><code class="language-none">DelayDiffEq.Feagin14</code></pre><pre><code class="language-none">DelayDiffEq.FunctionMap</code></pre><pre><code class="language-none">DelayDiffEq.GRK4A</code></pre><pre><code class="language-none">DelayDiffEq.GRK4T</code></pre><pre><code class="language-none">DelayDiffEq.GenericIIF1</code></pre><pre><code class="language-none">DelayDiffEq.GenericIIF2</code></pre><pre><code class="language-none">DelayDiffEq.GenericImplicitEuler</code></pre><pre><code class="language-none">DelayDiffEq.GenericTrapezoid</code></pre><pre><code class="language-none">DelayDiffEq.HSLDDRK64</code></pre><pre><code class="language-none">DelayDiffEq.Hairer4</code></pre><pre><code class="language-none">DelayDiffEq.Hairer42</code></pre><pre><code class="language-none">DelayDiffEq.Heun</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.HistoryFunction" href="#DelayDiffEq.HistoryFunction"><code>DelayDiffEq.HistoryFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HistoryFunction(h, sol, integrator)</code></pre><p>Wrap history function <code>h</code>, solution <code>sol</code>, and integrator <code>integrator</code> to create a common interface for retrieving values at any time point with varying accuracy.</p><p>Before the initial time point of solution <code>sol</code> values are calculated by history function <code>h</code>, for time points in the time span of <code>sol</code> interpolated values of <code>sol</code> are returned, and after the final time point of <code>sol</code> an inter- or extrapolation of the current state of integrator <code>integrator</code> is retrieved.</p></div></div></section><pre><code class="language-none">DelayDiffEq.HochOst4</code></pre><pre><code class="language-none">DelayDiffEq.IMEXEuler</code></pre><pre><code class="language-none">DelayDiffEq.IRKN3</code></pre><pre><code class="language-none">DelayDiffEq.IRKN4</code></pre><pre><code class="language-none">DelayDiffEq.ImplicitEuler</code></pre><pre><code class="language-none">DelayDiffEq.ImplicitMidpoint</code></pre><pre><code class="language-none">DelayDiffEq.JVODE</code></pre><pre><code class="language-none">DelayDiffEq.JVODE_Adams</code></pre><pre><code class="language-none">DelayDiffEq.JVODE_BDF</code></pre><pre><code class="language-none">DelayDiffEq.KahanLi6</code></pre><pre><code class="language-none">DelayDiffEq.KahanLi8</code></pre><pre><code class="language-none">DelayDiffEq.KenCarp3</code></pre><pre><code class="language-none">DelayDiffEq.KenCarp4</code></pre><pre><code class="language-none">DelayDiffEq.KenCarp5</code></pre><pre><code class="language-none">DelayDiffEq.Kvaerno3</code></pre><pre><code class="language-none">DelayDiffEq.Kvaerno4</code></pre><pre><code class="language-none">DelayDiffEq.Kvaerno5</code></pre><pre><code class="language-none">DelayDiffEq.LawsonEuler</code></pre><pre><code class="language-none">DelayDiffEq.LinSolveFactorize</code></pre><pre><code class="language-none">DelayDiffEq.LinearExponential</code></pre><pre><code class="language-none">DelayDiffEq.MEBDF2</code></pre><pre><code class="language-none">DelayDiffEq.McAte2</code></pre><pre><code class="language-none">DelayDiffEq.McAte3</code></pre><pre><code class="language-none">DelayDiffEq.McAte4</code></pre><pre><code class="language-none">DelayDiffEq.McAte42</code></pre><pre><code class="language-none">DelayDiffEq.McAte5</code></pre><pre><code class="language-none">DelayDiffEq.McAte8</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.MethodOfSteps" href="#DelayDiffEq.MethodOfSteps"><code>DelayDiffEq.MethodOfSteps</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MethodOfSteps(alg; constrained::Bool=false, fixedpoint_abstol=nothing,
              fixedpoint_reltol=nothing, fixedpoint_norm=nothing,
              max_fixedpoint_iters::Int=10)</code></pre><p>Construct an algorithm that solves delay differential equations by the method of steps, where <code>alg</code> is an ODE algorithm from OrdinaryDiffEq.jl without lazy interpolation upon which the calculation of steps is based.</p><p>If the algorithm is <code>constrained</code> only steps of size at most the minimal delay will be taken. If it is unconstrained, fixed-point iteration is applied for step sizes that exceed the minimal delay.</p><p>The absolute and relative tolerance of the fixed-point iterations can be set by <code>fixedpoint_abstol</code> and <code>fixedpoint_reltol</code>, respectively, either as scalars or vectors. Based on these tolerances error estimates are calculated during the fixed-point iterations with a norm that may be specified as <code>fixedpoint_norm</code>. Fixed-point iterations are stopped if the error estimate is less than 1 or after the maximal number <code>max_fixedpoint_iters</code> of iteration steps.</p></div></div></section><pre><code class="language-none">DelayDiffEq.Midpoint</code></pre><pre><code class="language-none">DelayDiffEq.MidpointSplitting</code></pre><pre><code class="language-none">DelayDiffEq.MonteCarloProblem</code></pre><pre><code class="language-none">DelayDiffEq.MonteCarloSolution</code></pre><pre><code class="language-none">DelayDiffEq.MonteCarloSummary</code></pre><pre><code class="language-none">DelayDiffEq.MonteCarloTestSolution</code></pre><pre><code class="language-none">DelayDiffEq.NDBLSRK124</code></pre><pre><code class="language-none">DelayDiffEq.NDBLSRK134</code></pre><pre><code class="language-none">DelayDiffEq.NDBLSRK144</code></pre><pre><code class="language-none">DelayDiffEq.NLAnderson</code></pre><pre><code class="language-none">DelayDiffEq.NLFunctional</code></pre><pre><code class="language-none">DelayDiffEq.NLNewton</code></pre><pre><code class="language-none">DelayDiffEq.NoiseProblem</code></pre><pre><code class="language-none">DelayDiffEq.NorsettEuler</code></pre><pre><code class="language-none">DelayDiffEq.Nystrom4</code></pre><pre><code class="language-none">DelayDiffEq.Nystrom4VelocityIndependent</code></pre><pre><code class="language-none">DelayDiffEq.Nystrom5VelocityIndependent</code></pre><pre><code class="language-none">DelayDiffEq.ODEFunction</code></pre><pre><code class="language-none">DelayDiffEq.ODEProblem</code></pre><pre><code class="language-none">DelayDiffEq.ODESolution</code></pre><pre><code class="language-none">DelayDiffEq.ORK256</code></pre><pre><code class="language-none">DelayDiffEq.OrdinaryDiffEq</code></pre><pre><code class="language-none">DelayDiffEq.OrdinaryDiffEqAlgorithm</code></pre><pre><code class="language-none">DelayDiffEq.OwrenZen3</code></pre><pre><code class="language-none">DelayDiffEq.OwrenZen4</code></pre><pre><code class="language-none">DelayDiffEq.OwrenZen5</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S105</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S173</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S184</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S205</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S32</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S53</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S82</code></pre><pre><code class="language-none">DelayDiffEq.ParsaniKetchesonDeconinck3S94</code></pre><pre><code class="language-none">DelayDiffEq.PseudoVerletLeapfrog</code></pre><pre><code class="language-none">DelayDiffEq.QBDF</code></pre><pre><code class="language-none">DelayDiffEq.QBDF1</code></pre><pre><code class="language-none">DelayDiffEq.QBDF2</code></pre><pre><code class="language-none">DelayDiffEq.QNDF</code></pre><pre><code class="language-none">DelayDiffEq.QNDF1</code></pre><pre><code class="language-none">DelayDiffEq.QNDF2</code></pre><pre><code class="language-none">DelayDiffEq.RK4</code></pre><pre><code class="language-none">DelayDiffEq.RK46NL</code></pre><pre><code class="language-none">DelayDiffEq.RKC</code></pre><pre><code class="language-none">DelayDiffEq.ROCK2</code></pre><pre><code class="language-none">DelayDiffEq.ROCK4</code></pre><pre><code class="language-none">DelayDiffEq.RODEFunction</code></pre><pre><code class="language-none">DelayDiffEq.RODEProblem</code></pre><pre><code class="language-none">DelayDiffEq.RODESolution</code></pre><pre><code class="language-none">DelayDiffEq.ROS3P</code></pre><pre><code class="language-none">DelayDiffEq.RadauIIA5</code></pre><pre><code class="language-none">DelayDiffEq.Ralston</code></pre><pre><code class="language-none">DelayDiffEq.RichardsonEuler</code></pre><pre><code class="language-none">DelayDiffEq.Rodas3</code></pre><pre><code class="language-none">DelayDiffEq.Rodas4</code></pre><pre><code class="language-none">DelayDiffEq.Rodas42</code></pre><pre><code class="language-none">DelayDiffEq.Rodas4P</code></pre><pre><code class="language-none">DelayDiffEq.Rodas5</code></pre><pre><code class="language-none">DelayDiffEq.Ros4LStab</code></pre><pre><code class="language-none">DelayDiffEq.RosShamp4</code></pre><pre><code class="language-none">DelayDiffEq.Rosenbrock23</code></pre><pre><code class="language-none">DelayDiffEq.Rosenbrock32</code></pre><pre><code class="language-none">DelayDiffEq.Ruth3</code></pre><pre><code class="language-none">DelayDiffEq.SBDF2</code></pre><pre><code class="language-none">DelayDiffEq.SBDF3</code></pre><pre><code class="language-none">DelayDiffEq.SBDF4</code></pre><pre><code class="language-none">DelayDiffEq.SDEFunction</code></pre><pre><code class="language-none">DelayDiffEq.SDEProblem</code></pre><pre><code class="language-none">DelayDiffEq.SDIRK2</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK104</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK22</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK33</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK432</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK53</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK53_2N1</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK53_2N2</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK54</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK63</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK73</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK83</code></pre><pre><code class="language-none">DelayDiffEq.SSPRK932</code></pre><pre><code class="language-none">DelayDiffEq.SSPRKMSVS32</code></pre><pre><code class="language-none">DelayDiffEq.SSPRKMSVS43</code></pre><pre><code class="language-none">DelayDiffEq.SSPSDIRK2</code></pre><pre><code class="language-none">DelayDiffEq.SecondOrderODEProblem</code></pre><pre><code class="language-none">DelayDiffEq.SofSpa10</code></pre><pre><code class="language-none">DelayDiffEq.SplitEuler</code></pre><pre><code class="language-none">DelayDiffEq.SplitFunction</code></pre><pre><code class="language-none">DelayDiffEq.SplitODEProblem</code></pre><pre><code class="language-none">DelayDiffEq.SplitSDEFunction</code></pre><pre><code class="language-none">DelayDiffEq.SplitSDEProblem</code></pre><pre><code class="language-none">DelayDiffEq.SteadyStateProblem</code></pre><pre><code class="language-none">DelayDiffEq.SteadyStateSolution</code></pre><pre><code class="language-none">DelayDiffEq.SymplecticEuler</code></pre><pre><code class="language-none">DelayDiffEq.TRBDF2</code></pre><pre><code class="language-none">DelayDiffEq.TSLDDRK74</code></pre><pre><code class="language-none">DelayDiffEq.TanYam7</code></pre><pre><code class="language-none">DelayDiffEq.TimeChoiceIterator</code></pre><pre><code class="language-none">DelayDiffEq.Trapezoid</code></pre><pre><code class="language-none">DelayDiffEq.Tsit5</code></pre><pre><code class="language-none">DelayDiffEq.TsitPap8</code></pre><pre><code class="language-none">DelayDiffEq.TwoPointBVProblem</code></pre><pre><code class="language-none">DelayDiffEq.VCAB3</code></pre><pre><code class="language-none">DelayDiffEq.VCAB4</code></pre><pre><code class="language-none">DelayDiffEq.VCAB5</code></pre><pre><code class="language-none">DelayDiffEq.VCABM</code></pre><pre><code class="language-none">DelayDiffEq.VCABM3</code></pre><pre><code class="language-none">DelayDiffEq.VCABM4</code></pre><pre><code class="language-none">DelayDiffEq.VCABM5</code></pre><pre><code class="language-none">DelayDiffEq.Veldd4</code></pre><pre><code class="language-none">DelayDiffEq.Velds4</code></pre><pre><code class="language-none">DelayDiffEq.VelocityVerlet</code></pre><pre><code class="language-none">DelayDiffEq.VerletLeapfrog</code></pre><pre><code class="language-none">DelayDiffEq.Vern6</code></pre><pre><code class="language-none">DelayDiffEq.Vern7</code></pre><pre><code class="language-none">DelayDiffEq.Vern8</code></pre><pre><code class="language-none">DelayDiffEq.Vern9</code></pre><pre><code class="language-none">DelayDiffEq.Yoshida6</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.add_next_discontinuities!" href="#DelayDiffEq.add_next_discontinuities!"><code>DelayDiffEq.add_next_discontinuities!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_next_discontinuities!(integrator::DDEIntegrator, order[, t=integrator.t])</code></pre><p>Add discontinuities of next order that are propagated from discontinuity of order <code>order</code> at time <code>t</code> in <code>integrator</code>, but only if <code>order</code> is less or equal than the order of the applied method or the problem is neutral.</p><p>Discontinuities caused by constant delays are immediately calculated, and discontinuities caused by dependent delays are tracked by a callback.</p></div></div></section><pre><code class="language-none">DelayDiffEq.add_saveat!</code></pre><pre><code class="language-none">DelayDiffEq.add_tstop!</code></pre><pre><code class="language-none">DelayDiffEq.addat!</code></pre><pre><code class="language-none">DelayDiffEq.addat_non_user_cache!</code></pre><pre><code class="language-none">DelayDiffEq.addsteps!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.advance_ode_integrator!" href="#DelayDiffEq.advance_ode_integrator!"><code>DelayDiffEq.advance_ode_integrator!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">advance_ode_integrator!(integrator::DDEIntegrator)</code></pre><p>Advance ODE integrator of <code>integrator</code> to next time interval, values and complete interpolation data of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.agrees" href="#DelayDiffEq.agrees"><code>DelayDiffEq.agrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">agrees(h, u, p, t)</code></pre><p>Determine whether history function evaluates to <code>u</code> at time point <code>t</code> for parameters <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.assign_expr" href="#DelayDiffEq.assign_expr"><code>DelayDiffEq.assign_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assign_expr(::Val{name}, ::Type{T}, ::Type{cache})</code></pre><p>Create expression that extracts field <code>name</code> of type <code>T</code> from cache of type <code>cache</code> to variable <code>name</code>.</p><p>Hereby u, uprev, uprev2, and function f are updated, if required.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.auto_dt_reset!" href="#DiffEqBase.auto_dt_reset!"><code>DiffEqBase.auto_dt_reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">auto_dt_reset!(dde_int::DDEIntegrator)</code></pre><p>Automatically determine initial time step of <code>dde_int</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_linked_cache" href="#DelayDiffEq.build_linked_cache"><code>DelayDiffEq.build_linked_cache</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_linked_cache(cache, alg, u, uprev, uprev2, f, t, dt)</code></pre><p>Create cache for algorithm <code>alg</code> from existing cache <code>cache</code> with updated <code>u</code>, <code>uprev</code>, <code>uprev2</code>, <code>f</code>, <code>t</code>, and <code>dt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_solution_array" href="#DelayDiffEq.build_solution_array"><code>DelayDiffEq.build_solution_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_solution_array(integrator::DDEIntegrator)</code></pre><p>Create a <code>DiffEqArray</code> of the time points and values that form the solution of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_solution_interpolation" href="#DelayDiffEq.build_solution_interpolation"><code>DelayDiffEq.build_solution_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_solution_interpolation(integrator::DDEIntegrator, sol::DiffEqArray)</code></pre><p>Create interpolation data to solution of <code>integrator</code>, which is formed by time points and values in <code>sol</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.change_t_via_interpolation!</code></pre><pre><code class="language-none">DelayDiffEq.check_error</code></pre><pre><code class="language-none">DelayDiffEq.check_keywords</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.constant_extrapolant" href="#DelayDiffEq.constant_extrapolant"><code>DelayDiffEq.constant_extrapolant</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">constant_extrapolant(t, integrator::DEIntegrator, idxs, deriv)</code></pre><p>Calculate constant extrapolation of derivative <code>deriv</code> at time <code>t</code> and indices <code>idxs</code> for <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.constant_extrapolant!" href="#DelayDiffEq.constant_extrapolant!"><code>DelayDiffEq.constant_extrapolant!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">constant_extrapolant!(val, t, integrator::DEIntegrator, idxs, deriv)</code></pre><p>Calculate constant extrapolation of derivative <code>deriv</code> at time <code>t</code> and indices <code>idxs</code> for <code>integrator</code>, and save result in <code>val</code> if <code>val</code> is not <code>nothing</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.constructDormandPrince</code></pre><pre><code class="language-none">DelayDiffEq.copyat_or_push!</code></pre><pre><code class="language-none">DelayDiffEq.deleteat!</code></pre><pre><code class="language-none">DelayDiffEq.deleteat_non_user_cache!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.determine_discontinuity_existence" href="#DelayDiffEq.determine_discontinuity_existence"><code>DelayDiffEq.determine_discontinuity_existence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">determine_discontinuity_existence(prev_sign::Int, next_sign::Int, Θs, f)</code></pre><p>Determine whether function <code>f</code> has a root in the interval [0, 1] by checking signs of <code>f</code> at 0 and 1 (<code>prev_sign</code> and <code>next_sign</code>, respectively) and at interpolation points in <code>Θs</code>.</p><p>This corresponds to the existence of a propagated discontinuity.</p></div></div></section><pre><code class="language-none">DelayDiffEq.du_cache</code></pre><pre><code class="language-none">DelayDiffEq.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.find_discontinuity_time" href="#DelayDiffEq.find_discontinuity_time"><code>DelayDiffEq.find_discontinuity_time</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_discontinuity_time(integrator::DDEIntegrator, callback::DiscontinuityCallback,
                        prev_sign::Int, next_sign::Int, Θs, f)</code></pre><p>Find time of propagated discontinuity for a certain dependent delay and previous discontinuity, which is root of the function <code>f</code>, in the current time interval of <code>integrator</code> with interpolation points <code>Θs</code>. Hereby <code>f</code> shows signs <code>prev_sign</code> and <code>next_sign</code> at both ends of the time interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.fsal_typeof" href="#DelayDiffEq.fsal_typeof"><code>DelayDiffEq.fsal_typeof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fsal_typeof(integrator::ODEIntegrator)</code></pre><p>Return type of FSAL of <code>integrator</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.full_cache</code></pre><pre><code class="language-none">DelayDiffEq.get_dt</code></pre><pre><code class="language-none">DelayDiffEq.get_du</code></pre><pre><code class="language-none">DelayDiffEq.get_du!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.get_proposed_dt" href="#DiffEqBase.get_proposed_dt"><code>DiffEqBase.get_proposed_dt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_proposed_dt(integrator::DDEIntegrator)</code></pre><p>Get the time step that <code>integrator</code> will take after the current step.</p></div></div></section><pre><code class="language-none">DelayDiffEq.get_tmp_cache</code></pre><pre><code class="language-none">DelayDiffEq.has_exp</code></pre><pre><code class="language-none">DelayDiffEq.has_expmv</code></pre><pre><code class="language-none">DelayDiffEq.has_expmv!</code></pre><pre><code class="language-none">DelayDiffEq.has_ldiv</code></pre><pre><code class="language-none">DelayDiffEq.has_ldiv!</code></pre><pre><code class="language-none">DelayDiffEq.has_mul</code></pre><pre><code class="language-none">DelayDiffEq.has_mul!</code></pre><pre><code class="language-none">DelayDiffEq.include</code></pre><pre><code class="language-none">DelayDiffEq.init</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.initialize!" href="#DiffEqBase.initialize!"><code>DiffEqBase.initialize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize!(integrator::DDEIntegrator)</code></pre><p>Set initial values of <code>integrator</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.intervals</code></pre><pre><code class="language-none">DelayDiffEq.is_constant</code></pre><pre><code class="language-none">DelayDiffEq.isconstrained</code></pre><pre><code class="language-none">DelayDiffEq.isdiscrete</code></pre><pre><code class="language-none">DelayDiffEq.isfsal</code></pre><pre><code class="language-none">DelayDiffEq.isinplace</code></pre><pre><code class="language-none">DelayDiffEq.ode_addsteps!</code></pre><pre><code class="language-none">DelayDiffEq.ode_interpolant</code></pre><pre><code class="language-none">DelayDiffEq.rand_cache</code></pre><pre><code class="language-none">DelayDiffEq.ratenoise_cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.reduce_solution!" href="#DelayDiffEq.reduce_solution!"><code>DelayDiffEq.reduce_solution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reduce_solution!(integrator::DDEIntegrator, tmax)</code></pre><p>Remove time points of ODE solution of <code>integrator</code> up to time <code>tmax</code> that are not required for calculation of DDE solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.reeval_internals_due_to_modification!" href="#DiffEqBase.reeval_internals_due_to_modification!"><code>DiffEqBase.reeval_internals_due_to_modification!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reeval_internals_due_to_modification!(integrator::DDEIntegrator)</code></pre><p>Recalculate interpolation data and update ODE integrator after changes by callbacks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.reinit!" href="#DiffEqBase.reinit!"><code>DiffEqBase.reinit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reinit!(integrator::DDEIntegrator[, u0 = integrator.sol.prob.u0;
        t0 = integrator.sol.prob.tspan[1],
        tf = integrator.sol.prob.tspan[2],
        erase_sol = true,
        kwargs...])</code></pre><p>Reinitialize <code>integrator</code> with (optionally) different initial state <code>u0</code>, different integration interval from <code>t0</code> to <code>tf</code>, and erased solution if <code>erase_sol = true</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.remake</code></pre><pre><code class="language-none">DelayDiffEq.resize!</code></pre><pre><code class="language-none">DelayDiffEq.resize_non_user_cache!</code></pre><pre><code class="language-none">DelayDiffEq.savevalues!</code></pre><pre><code class="language-none">DelayDiffEq.set_abstol!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.set_proposed_dt!" href="#DiffEqBase.set_proposed_dt!"><code>DiffEqBase.set_proposed_dt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_proposed_dt!(integrator::DDEIntegrator, dt)</code></pre><p>Set the time step that <code>integrator</code> will take after the current step to <code>dt</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.set_reltol!</code></pre><pre><code class="language-none">DelayDiffEq.set_t!</code></pre><pre><code class="language-none">DelayDiffEq.set_u!</code></pre><pre><code class="language-none">DelayDiffEq.solve</code></pre><pre><code class="language-none">DelayDiffEq.solve!</code></pre><pre><code class="language-none">DelayDiffEq.step!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.terminate!" href="#DiffEqBase.terminate!"><code>DiffEqBase.terminate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">terminate!(integrator::DDEIntegrator)</code></pre><p>Stop further calculations of <code>integrator</code>.</p></div></div></section><pre><code class="language-none">DelayDiffEq.tuples</code></pre><pre><code class="language-none">DelayDiffEq.u_cache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.u_modified!" href="#DiffEqBase.u_modified!"><code>DiffEqBase.u_modified!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">u_modified!(integrator::DDEIntegrator, bool::Bool)</code></pre><p>Signal <code>integrator</code> whether state vector <code>u</code> was modified by a callback.</p><p>A modified <code>u</code> will lead to recalculations in order to prevent discontinuities.</p></div></div></section><pre><code class="language-none">DelayDiffEq.update_coefficients</code></pre><pre><code class="language-none">DelayDiffEq.update_coefficients!</code></pre><pre><code class="language-none">DelayDiffEq.user_cache</code></pre><pre><code class="language-none">DelayDiffEq.warn_compat</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
