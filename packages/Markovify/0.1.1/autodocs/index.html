<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Markovify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Markovify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Markovify.Markovify</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.Model" href="#Markovify.Model"><code>Markovify.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The datastructure of the Markov chain. Encodes all the different states and the probabilities of going from one to another as a dictionary. The keys are the states, the values are the respective <a href="#Markovify.TokenOccurences"><code>TokenOccurences</code></a> dictionaries. Those are dictionaries which say how many times was a token found <em>immediately</em> after the state.</p><p><strong>Fields</strong></p><ul><li><code>order</code> is the number of tokens in a <a href="#Markovify.State"><code>State</code></a></li><li><code>nodes</code> is a dictionary pairing <a href="#Markovify.State"><code>State</code></a> and its respective</li></ul><p><a href="#Markovify.TokenOccurences"><code>TokenOccurences</code></a> dictionary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.State" href="#Markovify.State"><code>Markovify.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">State{T} = Vector{Token{T}}</code></pre><p>A state is described by a succession of tokens.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.Token" href="#Markovify.Token"><code>Markovify.Token</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Token{T} = Union{Symbol, T}</code></pre><p>Tokens can be of any type. They can also include symbols <code>:begin</code> and <code>:end</code> which are used to denote the beginning and end of a suptoken.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.TokenOccurences" href="#Markovify.TokenOccurences"><code>Markovify.TokenOccurences</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TokenOccurences{T} = Dict{Token{T}, Int}</code></pre><p>A dictionary pairing tokens (or special symbols <code>:begin</code> and <code>:end</code>) with the number of their respective occurences.</p></div></div></section><pre><code class="language-none">Markovify.Tokenizer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.append_token" href="#Markovify.append_token"><code>Markovify.append_token</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">append_token(state, token)</code></pre><p>Drop the first element in <code>state</code> and append the <code>token</code> at the end of the <code>state</code> array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.begseq" href="#Markovify.begseq"><code>Markovify.begseq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">begseq(n)</code></pre><p>Return the symbol <code>:begin</code> repeated <code>n</code> times. This array is then used as a starting sequence for all suptokens.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.combine" href="#Markovify.combine"><code>Markovify.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine(chain, others)</code></pre><p>Return a Model which is a combination of all of the models provided. All of the arguments should have the same <code>order</code>. The nodes of all the Models are merged using the function <code>merge</code>.</p></div></div></section><pre><code class="language-none">Markovify.eval</code></pre><pre><code class="language-none">Markovify.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.indexin" href="#Markovify.indexin"><code>Markovify.indexin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">indexin(array)</code></pre><p>Given a sorted <code>array</code>, return the index on which <code>n</code> would be inserted in should the insertion preserve the sorting.</p></div></div></section><pre><code class="language-none">Markovify.makefromdict</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.next_token" href="#Markovify.next_token"><code>Markovify.next_token</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next_token(model, state)</code></pre><p>Return a token which will come after the current state, at random. The probabilities of individual tokens getting choosed are skewed by their individual values in the <code>TokenOccurences</code> dictionary of the current <code>state</code>, that is obtained from the <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.randkey" href="#Markovify.randkey"><code>Markovify.randkey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randkey(dict)</code></pre><p>Return a random key from <code>dict</code>. The probabilities of individual keys getting chosen are skewed by their respective values.</p></div></div></section><pre><code class="language-none">Markovify.state_with_beginning</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.state_with_prefix" href="#Markovify.state_with_prefix"><code>Markovify.state_with_prefix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">state_with_prefix(model, prefix; strict=false)</code></pre><p>Attempts to return a random valid state of <code>model</code> that begins with <code>tokens</code>. If <code>strict</code> is <code>false</code> and the <code>model</code> doesn&#39;t have any state that begins with <code>tokens</code>, the function shortens the tokens (cuts the last token) to lower the requirements and tries to find some valid state again.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.states_with_suffix" href="#Markovify.states_with_suffix"><code>Markovify.states_with_suffix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">states_with_suffix(model, init_suffix)</code></pre><p>Return all of the states of <code>model</code> that end with <code>init_suffix</code>. If the number of such states is 1 (or 0), the function shortens the suffix (cuts the first token) in order to lower the requirements, and makes another try.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.stdweight" href="#Markovify.stdweight"><code>Markovify.stdweight</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stdweight(state, token)</code></pre><p>A constant <code>1</code>. Used as a placeholder function in <a href="#Markovify.Model"><code>Model</code></a> to represent unbiased weight function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.walk" href="#Markovify.walk"><code>Markovify.walk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">walk(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#Markovify.walk2"><code>walk2</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.walk2" href="#Markovify.walk2"><code>Markovify.walk2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">walk2(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. When there is only one state following the current one (i.e. there is 100% chance that the state will become the next one), the function shortens the current <code>State</code> as to lower the requirements and obtain more randomness. The <code>State</code> gets shortened until a state with at least two possible successors is found (or until <code>State</code> is only one token long).</p><p>The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#Markovify.walk"><code>walk</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Markovify.walker" href="#Markovify.walker"><code>Markovify.walker</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">walker(model, init_state, init_accum, newstate=append_token)</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> and ends once a special token <code>:end</code> is reached. A function <code>newstate</code> of general type <code>func(::State{T}, ::Token{T})::State{T} where T</code> can be supplied to be used to generate a new state given the old state and the following token.</p><p>This is a general function which is used by all the <code>walk</code> functions.</p><p>See also: <a href="#Markovify.walk"><code>walk</code></a>, <a href="#Markovify.walk2"><code>walk2</code></a>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
