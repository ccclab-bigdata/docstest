<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · SpatialIndexing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SpatialIndexing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.AbstractPool" href="#SpatialIndexing.AbstractPool"><code>SpatialIndexing.AbstractPool</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for implementating the pool of <code>T</code> objects. The pool allows to reduce the stress on GC by collecting the unneeded objects (<code>release!(pool, obj)</code>) and reusing them later (<code>acquire!(pool)</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Branch" href="#SpatialIndexing.Branch"><code>SpatialIndexing.Branch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>R-Tree node for levels above 1 (non-<code>Leaf</code>).</p></div></div></section><pre><code class="language-none">SpatialIndexing.BranchPool</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.HasID" href="#SpatialIndexing.HasID"><code>SpatialIndexing.HasID</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type trait for checking <code>id()</code> method support. If type <code>V</code> has this trait (<code>idtype(V)</code> returns <code>HasID{K}</code>), then <code>id(v::V)</code> should return a unique identifier for <code>v</code> of type <code>K</code>. If <code>V</code> doesn&#39;t have this trait, <code>idtype(V)</code> returns <code>HasNoID</code>.</p><p>If available, <code>SpatialIndex{T,N,V}</code> uses unique identifiers of <code>V</code> alongside spatial indexing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.HasMBR" href="#SpatialIndexing.HasMBR"><code>SpatialIndexing.HasMBR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type trait for checking <code>mbr()</code> method support. If type <code>V</code> has this trait (<code>mbrtype(V)</code> returns <code>HasMBR{Rect{T,N}}</code>), then <code>mbr(v::V)</code> should return a minimal bounding rectangle (MBR) <code>Rect{T,N}</code> that contains <code>v</code>. If <code>V</code> doesn&#39;t have this trait, <code>mbrtype(V)</code> returns <code>HasNoMBR</code>.</p><p><code>SpatialIndex{T,N,V}</code> <em>requires</em> that <code>V</code> provides <code>mbr()</code> method that returns <code>Rect{T,N}</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.HasNoID</code></pre><pre><code class="language-none">SpatialIndexing.HasNoMBR</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Leaf" href="#SpatialIndexing.Leaf"><code>SpatialIndexing.Leaf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>R-Tree leaf (level 1 node). Its children are data elements of type <code>V</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.LeafPool</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Node" href="#SpatialIndexing.Node"><code>SpatialIndexing.Node</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base class for <code>RTree</code> node (<code>Branch</code> or <code>Leaf</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.NodePool" href="#SpatialIndexing.NodePool"><code>SpatialIndexing.NodePool</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Pool of the <code>T1</code> R-tree nodes (<code>Leaf</code> or <code>Branch</code>) with <code>T2</code> children (<code>Branch</code>, <code>Leaf</code> or <code>Elem</code>). It allows reusing the deleted nodes and reduce the stress on GC.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Point" href="#SpatialIndexing.Point"><code>SpatialIndexing.Point</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>N</code>-dimensional point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Pool" href="#SpatialIndexing.Pool"><code>SpatialIndexing.Pool</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The default <code>AbstarctPool</code> implementation.</p></div></div></section><pre><code class="language-none">SpatialIndexing.QueryContainedIn</code></pre><pre><code class="language-none">SpatialIndexing.QueryIntersectsWith</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.QueryKind" href="#SpatialIndexing.QueryKind"><code>SpatialIndexing.QueryKind</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Specifies the kind of spatial data query.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.QueryMatch" href="#SpatialIndexing.QueryMatch"><code>SpatialIndexing.QueryMatch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Specifies the result of spatial data query.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L2">source</a></section><pre><code class="language-none">SpatialIndexing.QueryMatchComplete</code></pre><pre><code class="language-none">SpatialIndexing.QueryMatchPartial</code></pre><pre><code class="language-none">SpatialIndexing.QueryNoMatch</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.RTree" href="#SpatialIndexing.RTree"><code>SpatialIndexing.RTree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>R-Tree: <code>N</code>-dimensional spatial data index [guttman84].</p><p>R-tree groups data elements (<code>V</code>) into leaves (<code>Leaf</code>) and leaves into branches (<code>Branch</code>). It uses various heuristics to ensure that the minimal bounding rectangles (MBRs) of the nodes (<code>Rect{T,N}</code> rectangles that encompass the data elements attached to these nodes) stay compact and that the MBRs of the nodes that are on the same level of R-tree hierarchy have minimal overlap with each other. This property makes R-trees efficient for spatial queries.</p><p>To facilitate spatial indexing, the <code>V</code> data elements need to support <code>HasMBR</code> trait (i.e. define <code>mbrtype(V)</code> and <code>mbr(v::V)</code> methods) and, optionally, <code>HasID</code> trait (via <code>idtype(V)</code> and <code>id(v::V)</code> methods). <code>mbr(v::V)</code> should return minimal bounding rectangle (MBR) of type <code>Rect{T,N}</code> that contains <code>v</code>. <code>SpatialElem{T,N,D}</code> type provides generic implementation of spatial data element that explicitly stores <code>id</code>, <code>mbr</code> and data object of type <code>D</code> and implements <code>HasMBR</code> and <code>HasID</code> traits.</p><p><strong>Parameters</strong></p><p>The behaviour of <code>RTree</code> is defined by the parameters supplied at its creation:</p><ul><li><code>T</code>: the numeric type for the spatial coordinate</li><li><code>N</code>: the number of spatial dimensions</li><li><code>variant</code>: one of <code>RTreeLinear</code>, <code>RTreeQuadratic</code>, or <code>RTreeStar</code> (default)</li><li><code>tight_mbrs</code>: recalculate node MBR when the child is removed (default is <code>true</code>)</li><li><code>branch_capacity</code>: capacity of branch nodes (default is <code>100</code>)</li><li><code>leaf_capacity</code>: capacity of leaf nodes (default is <code>100</code>)</li><li><code>leafpool_capacity</code>: How many detached 1st level nodes (leaves) should be kept for reuse (default is <code>100</code>)</li><li><code>twigpool_capacity</code>: How many detached 2nd level nodes should be kept for reuse (default is <code>100</code>)</li><li><code>branchpool_capacity</code>: How many other (level &gt; 2) detached branch nodes should be kept for reuse (default is <code>100</code>)</li><li><code>nearmin_overlap</code>: How many candidates to consider when identifying the node with minimal overlap (default is <code>32</code>)</li><li><code>fill_factor</code>: How much should the node be filled (fraction of its capacity) after splitting (default is <code>0.7</code>)</li><li><code>split_factor</code>: How much can the sizes of the two nodes differ after splitting (default is <code>0.4</code>)</li><li><code>reinsert_factor</code>: How much should the node be underfilled (fraction of its capacity) to consider removing it and redistributing its children to other nodes (default is <code>0.3</code>)</li></ul><p><strong>Performance</strong></p><p>The nodes in R-tree have limited capacity (maximual number of children) specified at <code>RTree</code> creation (<code>leaf_capacity</code> and <code>branch_capacity</code>). Larger capacities results in shorter trees, but they time required to locate the specific spatial region grows linearly with the capacity.</p><p><strong>References</strong></p><p>[guttman84] “R-Trees: A Dynamic Index Structure for Spatial Searching”     A. Guttman, Proc. 1984 ACM-SIGMOD Conference on Management of     Data (1985), 47-57. [beckmann90] &quot;The R*-tree: an efficient and robust access method for points and rectangles&quot;     N. Beckmann, H.P. Kriegel, R. Schneider, B. Seeger, Proc. 1990 ACM SIGMOD     international conference on Management of data (1990), p.322</p></div></div></section><pre><code class="language-none">SpatialIndexing.RTreeIteratorState</code></pre><pre><code class="language-none">SpatialIndexing.RTreeLinear</code></pre><pre><code class="language-none">SpatialIndexing.RTreeQuadratic</code></pre><pre><code class="language-none">SpatialIndexing.RTreeQueryIteratorState</code></pre><pre><code class="language-none">SpatialIndexing.RTreeRegionQueryIterator</code></pre><pre><code class="language-none">SpatialIndexing.RTreeStar</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.RTreeVariant" href="#SpatialIndexing.RTreeVariant"><code>SpatialIndexing.RTreeVariant</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>R-Tree variants.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Rect" href="#SpatialIndexing.Rect"><code>SpatialIndexing.Rect</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Rectangular region constrained by <code>low[i]</code>...<code>high[i]</code> in each of <code>N</code> dimensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.Region" href="#SpatialIndexing.Region"><code>SpatialIndexing.Region</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base abstract class for implementing regions in <code>N</code>-dimensional space with dimensions of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.SimpleSpatialIndex" href="#SpatialIndexing.SimpleSpatialIndex"><code>SpatialIndexing.SimpleSpatialIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Vector-based <code>SpatialIndex</code>. While insertion is <code>O(1)</code>, the search is <code>O(N)</code>.</p><p>Generally should not be used, except for performance comparisons or when the number of stored elements is expected to be very small (&lt;100).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.SpatialElem" href="#SpatialIndexing.SpatialElem"><code>SpatialIndexing.SpatialElem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simple <code>N</code>-dimensional spatial data element that stores values of type <code>V</code> and supports <code>HasMBR{Rect{T,N}}</code> and <code>HasID{K}</code> (if <code>K</code> is not <code>Nothing</code>) traits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.SpatialIndex" href="#SpatialIndexing.SpatialIndex"><code>SpatialIndexing.SpatialIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base abstract class for spatial indexing of elements of type <code>V</code> in <code>N</code>-dimensional space with dimensions of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.SpatialIndexException" href="#SpatialIndexing.SpatialIndexException"><code>SpatialIndexing.SpatialIndexException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SpatialIndex</code>-related exception raised within Julia</p></div></div></section><pre><code class="language-none">SpatialIndexing.SpatialIndexing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.SpatialQueryIterator" href="#SpatialIndexing.SpatialQueryIterator"><code>SpatialIndexing.SpatialQueryIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base abstract class for implementing spatial queries in <code>N</code>-dimensional space.</p></div></div></section><pre><code class="language-none">SpatialIndexing.SubtreeContext</code></pre><pre><code class="language-none">SpatialIndexing.TwigPool</code></pre><pre><code class="language-none">SpatialIndexing.__spatial_keyerror</code></pre><pre><code class="language-none">SpatialIndexing._attach!</code></pre><pre><code class="language-none">SpatialIndexing._condense!</code></pre><pre><code class="language-none">SpatialIndexing._detach!</code></pre><pre><code class="language-none">SpatialIndexing._insert!</code></pre><pre><code class="language-none">SpatialIndexing._insert!_fullnode</code></pre><pre><code class="language-none">SpatialIndexing._insert!_fullnode_rstar</code></pre><pre><code class="language-none">SpatialIndexing._isempty</code></pre><pre><code class="language-none">SpatialIndexing._iterate</code></pre><pre><code class="language-none">SpatialIndexing._mbr_high</code></pre><pre><code class="language-none">SpatialIndexing._mbr_low</code></pre><pre><code class="language-none">SpatialIndexing._nextchild</code></pre><pre><code class="language-none">SpatialIndexing._reinsert!</code></pre><pre><code class="language-none">SpatialIndexing._release_descendants!</code></pre><pre><code class="language-none">SpatialIndexing._replace!</code></pre><pre><code class="language-none">SpatialIndexing._split!</code></pre><pre><code class="language-none">SpatialIndexing._split!_rstar</code></pre><pre><code class="language-none">SpatialIndexing._split!_rtree</code></pre><pre><code class="language-none">SpatialIndexing._splitseeds</code></pre><pre><code class="language-none">SpatialIndexing._splitseeds_linear</code></pre><pre><code class="language-none">SpatialIndexing._splitseeds_quadratic</code></pre><pre><code class="language-none">SpatialIndexing._subtract!</code></pre><pre><code class="language-none">SpatialIndexing._updatembr!</code></pre><pre><code class="language-none">SpatialIndexing.acquire</code></pre><pre><code class="language-none">SpatialIndexing.acquire!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.area" href="#SpatialIndexing.area"><code>SpatialIndexing.area</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">area(a::Region{T,N}) where {T,N}</code></pre><p><code>N</code>-dimensional &quot;area&quot; (volume etc) of <code>a</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.branchtype</code></pre><pre><code class="language-none">SpatialIndexing.capacity</code></pre><pre><code class="language-none">SpatialIndexing.center</code></pre><pre><code class="language-none">SpatialIndexing.check</code></pre><pre><code class="language-none">SpatialIndexing.check_eltype_rtree</code></pre><pre><code class="language-none">SpatialIndexing.check_hasid</code></pre><pre><code class="language-none">SpatialIndexing.check_hasmbr</code></pre><pre><code class="language-none">SpatialIndexing.children</code></pre><pre><code class="language-none">SpatialIndexing.choose_subtree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.combine" href="#SpatialIndexing.combine"><code>SpatialIndexing.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine(a::Region{T,N}, b::Region{T,N}) where {T,N}</code></pre><p>MBR that contains both <code>a</code> and <code>b</code> regions.</p></div></div></section><pre><code class="language-none">SpatialIndexing.combined_area</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.contained_in" href="#SpatialIndexing.contained_in"><code>SpatialIndexing.contained_in</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contained_in(index::SpatialIndex, region::Region)</code></pre><p>Get iterator for <code>index</code> elements contained in <code>region</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.contains" href="#SpatialIndexing.contains"><code>SpatialIndexing.contains</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contains(a::Region{T,N}, b::Region{T,N}) where {T,N}</code></pre><p>Check whether <code>a</code> contains <code>b</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.delete_subtree!</code></pre><pre><code class="language-none">SpatialIndexing.dimtype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.empty" href="#SpatialIndexing.empty"><code>SpatialIndexing.empty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">empty(::Type{T}) where T&lt;:Region</code></pre><p>Generate empty (uninitialized) region of type <code>T</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.enlargement</code></pre><pre><code class="language-none">SpatialIndexing.eval</code></pre><pre><code class="language-none">SpatialIndexing.find_least_enlargement</code></pre><pre><code class="language-none">SpatialIndexing.find_least_overlap</code></pre><pre><code class="language-none">SpatialIndexing.hasparent</code></pre><pre><code class="language-none">SpatialIndexing.height</code></pre><pre><code class="language-none">SpatialIndexing.id</code></pre><pre><code class="language-none">SpatialIndexing.idtrait</code></pre><pre><code class="language-none">SpatialIndexing.idtype</code></pre><pre><code class="language-none">SpatialIndexing.include</code></pre><pre><code class="language-none">SpatialIndexing.intersect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.intersects" href="#SpatialIndexing.intersects"><code>SpatialIndexing.intersects</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersects(a::Region{T,N}, b::Region{T,N}) where {T,N}</code></pre><p>Check whether <code>a</code> intersects with <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.intersects_with" href="#SpatialIndexing.intersects_with"><code>SpatialIndexing.intersects_with</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersects_with(index::SpatialIndex, region::Region)</code></pre><p>Get iterator for <code>index</code> elements intersecting with <code>region</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.isequal_rtree</code></pre><pre><code class="language-none">SpatialIndexing.isoverflow</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.isvalid" href="#SpatialIndexing.isvalid"><code>SpatialIndexing.isvalid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isvalid(a::Region)</code></pre><p>Check that the parameters of <code>a</code> are valid and it defines a proper region.</p></div></div></section><pre><code class="language-none">SpatialIndexing.leaftype</code></pre><pre><code class="language-none">SpatialIndexing.level</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.load!" href="#SpatialIndexing.load!"><code>SpatialIndexing.load!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load!(tree::RTree{T,N,V}, data::Any;
      convertel = identity, method = :OMT,
      leaf_fill = capacity(Leaf, tree),
      branch_fill::Tuple{Integer, Integer} = omt_branch_fill(tree)) where {T,N,V}</code></pre><p>Bulk-load <code>data</code> into <code>tree</code>.</p><ul><li><code>tree</code>: an <em>empty</em> R-tree for storing elements of type <code>V</code></li><li><code>data</code>: iterable container with the elements to put into <code>tree</code></li><li><code>convertel</code>: function to convert elements of <code>data</code> to type <code>V</code></li><li><code>method</code>: bulk-loading method</li><li><code>leaf_fill</code>: the average number of elements to store in R-tree leaves (1-level nodes)</li><li><code>branch_fill</code>: the tuple of the number of slices and the number of subtrees per slice in the R-tree nodes (level ≥ 1).</li></ul><p>The supported bulk-loading methods are:</p><ul><li><code>:OMT</code>: <em>Overlap Minimizing Top-down method</em> by Taewon Lee and Sukho Lee</li></ul></div></div></section><pre><code class="language-none">SpatialIndexing.load_omt!</code></pre><pre><code class="language-none">SpatialIndexing.mbr</code></pre><pre><code class="language-none">SpatialIndexing.mbrtrait</code></pre><pre><code class="language-none">SpatialIndexing.mbrtype</code></pre><pre><code class="language-none">SpatialIndexing.nelements</code></pre><pre><code class="language-none">SpatialIndexing.newelem</code></pre><pre><code class="language-none">SpatialIndexing.node_capacity</code></pre><pre><code class="language-none">SpatialIndexing.nodetype</code></pre><pre><code class="language-none">SpatialIndexing.omt_branch_fill</code></pre><pre><code class="language-none">SpatialIndexing.omt_subtree</code></pre><pre><code class="language-none">SpatialIndexing.overlap_area</code></pre><pre><code class="language-none">SpatialIndexing.parent</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.perimeter" href="#SpatialIndexing.perimeter"><code>SpatialIndexing.perimeter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">perimeter(a::Region)</code></pre><p>The sum of the <code>a</code> sides.</p></div></div></section><pre><code class="language-none">SpatialIndexing.pos_in_parent</code></pre><pre><code class="language-none">SpatialIndexing.querykind</code></pre><pre><code class="language-none">SpatialIndexing.regiontype</code></pre><pre><code class="language-none">SpatialIndexing.release</code></pre><pre><code class="language-none">SpatialIndexing.release!</code></pre><pre><code class="language-none">SpatialIndexing.setoverflow!</code></pre><pre><code class="language-none">SpatialIndexing.should_visit</code></pre><pre><code class="language-none">SpatialIndexing.sqrdistance</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.subtract!" href="#SpatialIndexing.subtract!"><code>SpatialIndexing.subtract!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subtract!(tree::RTree, reg::Region)</code></pre><p>Subtracts the <code>region</code> from the <code>tree</code>, i.e. removes all elements within <code>region</code>.</p></div></div></section><pre><code class="language-none">SpatialIndexing.syncmbr!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpatialIndexing.touches" href="#SpatialIndexing.touches"><code>SpatialIndexing.touches</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">touches(a::Rect{T,N}, b::Rect{T,N}) where {T,N}</code></pre><p>Check whether <code>a</code> and <code>b</code> touch (i.e. any <code>low</code> side touches <code>low</code> or <code>high</code> touches <code>high</code>).</p></div></div></section><pre><code class="language-none">SpatialIndexing.variant</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
