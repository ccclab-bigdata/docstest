<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TextParse.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TextParse.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Reading-CSV-1">Reading CSV</a></li><li><a class="toctext" href="#Extensible-parsing-framework-1">Extensible parsing framework</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TextParse-1" href="#TextParse-1">TextParse</a></h1><p>TextParse uses Julia&#39;s generated functions to generate efficient specialized parsers for text files. TextParse minimizes allocations and hence avoids involving the GC.</p><ul><li><a href="#TextParse-1">TextParse</a></li><ul><li><a href="#Installation-1">Installation</a></li><li><a href="#Reading-CSV-1">Reading CSV</a></li><li><a href="#Extensible-parsing-framework-1">Extensible parsing framework</a></li></ul></ul><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-julia">Pkg.add(&quot;TextParse&quot;)</code></pre><h2><a class="nav-anchor" id="Reading-CSV-1" href="#Reading-CSV-1">Reading CSV</a></h2><p>The most useful API is probably <code>csvread</code> - read a CSV file:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.csvread" href="#TextParse.csvread"><code>TextParse.csvread</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">csvread(file::Union{String,IO}, delim=&#39;,&#39;; &lt;arguments&gt;...)</code></pre><p>Read CSV from <code>file</code>. Returns a tuple of 2 elements:</p><ol><li>A tuple of columns each either a <code>Vector</code>, or <code>StringArray</code></li><li>column names if <code>header_exists=true</code>, empty array otherwise</li></ol><p><strong>Arguments:</strong></p><ul><li><code>file</code>: either an IO object or file name string</li><li><code>delim</code>: the delimiter character</li><li><code>spacedelim</code>: (Bool) parse space-delimited files. <code>delim</code> has no effect if true.</li><li><code>quotechar</code>: character used to quote strings, defaults to <code>&quot;</code></li><li><code>escapechar</code>: character used to escape quotechar in strings. (could be the same as quotechar)</li><li><code>nrows</code>: number of rows in the file. Defaults to <code>0</code> in which case we try to estimate this.</li><li><code>skiplines_begin</code>: skips specified number of lines at the beginning of the file</li><li><code>header_exists</code>: boolean specifying whether CSV file contains a header</li><li><code>nastrings</code>: strings that are to be considered NA. Defaults to <code>TextParse.NA_STRINGS</code></li><li><code>colnames</code>: manually specified column names. Could be a vector or a dictionary from Int index (the column) to String column name.</li><li><code>colparsers</code>: Parsers to use for specified columns. This can be a vector or a dictionary from column name / column index (Int) to a &quot;parser&quot;. The simplest parser is a type such as Int, Float64. It can also be a <code>dateformat&quot;...&quot;</code>, see <a href="@ref">CustomParser</a> if you want to plug in custom parsing behavior</li><li><code>type_detect_rows</code>: number of rows to use to infer the initial <code>colparsers</code> defaults to 20.</li></ul></div></div></section><p>Some notable features of the CSV parser are:</p><ul><li>CSV parsing kernel generated by TextParse is type-inferable.</li><li>Uses PooledArrays for strings by default, promoting to an <code>Array</code> only if number of unique elements goes over 5% (after 400 rows have been read).</li><li>Avoids allocating the string in PooledArray unless the string is not in the pool</li><li>Doesn&#39;t assume all columns are nullable by default, switches column to <code>DataValueArray</code> if an NA value is found</li><li>Flexible about predicted column types, can convert the column mid-way if the type changes and switch to a new fast generated method</li><li>Fast date time parsing even on Julia 0.5</li></ul><h2><a class="nav-anchor" id="Extensible-parsing-framework-1" href="#Extensible-parsing-framework-1">Extensible parsing framework</a></h2><p>TextParse operates by defining small parsers which are specialized to parse one kind of text very efficiently. Each such parser is described by a subtype of <code>AbstractToken{T}</code>. An <code>AbstractToken{T}</code> type should implement a <code>tryparsenext</code> method:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.tryparsenext" href="#Dates.tryparsenext"><code>Dates.tryparsenext</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>tryparsenext{T}(tok::AbstractToken{T}, str, i, till, localopts)</code></p><p>Parses the string <code>str</code> starting at position <code>i</code> and ending at or before position <code>till</code>. <code>localopts</code> is a <a href="#LocalOpts-1">LocalOpts</a> object which contains contextual options for quoting and NA parsing. (see <a href="#LocalOpts-1">LocalOpts</a> documentation)</p><p><code>tryparsenext</code> returns a tuple <code>(result, nextpos)</code> where <code>result</code> is of type <code>Union{Some{T}, Nothing}</code>, nothing if parsing failed, non-null containing the parsed value if it succeeded. If parsing succeeded, <code>nextpos</code> is the position the next token, if any, starts at. If parsing failed, <code>nextpos</code> is the position at which the parsing failed.</p></div></div></section><h3><a class="nav-anchor" id="Available-AbstractToken-types-1" href="#Available-AbstractToken-types-1">Available AbstractToken types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.Numeric" href="#TextParse.Numeric"><code>TextParse.Numeric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>parse numbers of type T</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.StringToken" href="#TextParse.StringToken"><code>TextParse.StringToken</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parses string to the AbstractString type <code>T</code>. If <code>T</code> is <code>StrRange</code> returns a <code>StrRange</code> with start position (<code>offset</code>) and <code>length</code> of the substring. It is used internally by <code>csvparse</code> for avoiding allocating strings.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.DateTimeToken" href="#TextParse.DateTimeToken"><code>TextParse.DateTimeToken</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DateTimeToken(T, fmt::DateFormat)</code></pre><p>Parse a date time string of format <code>fmt</code> into type <code>T</code> which is either <code>Date</code>, <code>Time</code> or <code>DateTime</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.NAToken" href="#TextParse.NAToken"><code>TextParse.NAToken</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>NAToken(inner::AbstractToken; options...)</code></p><p>Parses a Nullable item.</p><p><strong>Arguments</strong></p><ul><li><code>inner</code>: the token to parse if non-null.</li><li><code>emptyisna</code>: should an empty item be considered NA? defaults to true</li><li><code>nastrings</code>: strings that are to be considered NA. Defaults to <code>[&quot;#N/A&quot;, &quot;#N/A N/A&quot;, &quot;#NA&quot;, &quot;#n/a&quot;, &quot;#n/a n/a&quot;, &quot;#na&quot;, &quot;-1.#IND&quot;, &quot;-1.#QNAN&quot;, &quot;-1.#ind&quot;, &quot;-1.#qnan&quot;, &quot;-NaN&quot;, &quot;-nan&quot;, &quot;-nan&quot;, &quot;-nan&quot;, &quot;1.#IND&quot;, &quot;1.#QNAN&quot;, &quot;1.#ind&quot;, &quot;1.#qnan&quot;, &quot;N/A&quot;, &quot;N/A&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NULL&quot;, &quot;NaN&quot;, &quot;n/a&quot;, &quot;n/a&quot;, &quot;na&quot;, &quot;na&quot;, &quot;nan&quot;, &quot;nan&quot;, &quot;nan&quot;, &quot;null&quot;]</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.Quoted" href="#TextParse.Quoted"><code>TextParse.Quoted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Quoted(inner::AbstractToken; &lt;kwargs&gt;...)</code></p><p><strong>Arguments:</strong></p><ul><li><code>inner</code>: The token inside quotes to parse</li><li><code>required</code>: are quotes required for parsing to succeed? defaults to <code>false</code></li><li><code>includequotes</code>: include the quotes in the output. Defaults to <code>false</code></li><li><code>includenewlines</code>: include newlines that appear within quotes. Defaults to <code>true</code></li><li><code>quotechar</code>: character to use to quote (default decided by <code>LocalOpts</code>)</li><li><code>escapechar</code>: character that escapes the quote char (default set by <code>LocalOpts</code>)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.CustomParser" href="#TextParse.CustomParser"><code>TextParse.CustomParser</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CustomParser(f, T)</code></pre><p>Provide a custom parsing mechanism.</p><p><strong>Arguments:</strong></p><ul><li><code>f</code>: the parser function</li><li><code>T</code>: The type of the parsed value</li></ul><p>The parser function must take the following arguments:</p><ul><li><code>str</code>: the entire string being parsed</li><li><code>pos</code>: the position in the string at which to start parsing</li><li><code>len</code>: the length of the string the maximum position where to parse till</li><li><code>opts</code>: a <a href="#LocalOpts-1">LocalOpts</a> object with options local to the current field.</li></ul><p>The parser function must return a tuple of two values:</p><ul><li><code>result</code>: A <code>Union{Some{T}, Nothing}</code>. Set to nothing if parsing must fail, containing the value otherwise.</li><li><code>nextpos</code>: If parsing succeeded this must be the next position after parsing finished, if it failed this must be the position at which parsing failed.</li></ul></div></div></section><h3><a class="nav-anchor" id="LocalOpts-1" href="#LocalOpts-1">LocalOpts</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.LocalOpts" href="#TextParse.LocalOpts"><code>TextParse.LocalOpts</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LocalOpts</code></pre><p>Options local to the token currently being parsed.</p><ul><li><code>endchar</code>: Till where to parse. (e.g. delimiter or quote ending character)</li><li><code>spacedelim</code>: Treat spaces as delimiters</li><li><code>quotechar</code>: the quote character</li><li><code>escapechar</code>: char that escapes the quote</li><li><code>includequotes</code>: whether to include quotes while parsing</li><li><code>includenewlines</code>: whether to include newlines while parsing</li></ul></div></div></section><footer><hr/></footer></article></body></html>
