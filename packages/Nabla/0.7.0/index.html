<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Nabla.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Nabla.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#A-Toy-Problem-1">A Toy Problem</a></li><li><a class="toctext" href="#High-Level-Interface-1">High-Level Interface</a></li><li><a class="toctext" href="#Low-Level-Interface-1">Low-Level Interface</a></li><li><a class="toctext" href="#Gotchas-and-Best-Practice-1">Gotchas and Best Practice</a></li></ul></li><li><a class="toctext" href="pages/api/">API</a></li><li><a class="toctext" href="pages/custom/">Custom Sensitivities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Nabla-1" href="#Nabla-1">Nabla</a></h1><p><a href="https://travis-ci.org/invenia/Nabla.jl"><img src="https://travis-ci.org/invenia/Nabla.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/iamed2/nabla-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/g0gun5dxbkt631am/branch/master?svg=true" alt="Windows Build status"/></a> <a href="https://codecov.io/github/invenia/Nabla.jl?branch=master"><img src="https://codecov.io/github/invenia/Nabla.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://invenia.github.io/Nabla.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable Docs"/></a> <a href="https://invenia.github.io/Nabla.jl/latest"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt="Latest Docs"/></a></p><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><p><code>Nabla.jl</code> has two interfaces, both of which we expose to the end user. We first provide a minimal working example with the high-level interface, and subsequently show how the low-level interface can be used to achieve similar results. More involved examples can be found <a href="https://github.com/invenia/Nabla.jl/tree/master/examples">here</a>.</p><h2><a class="nav-anchor" id="A-Toy-Problem-1" href="#A-Toy-Problem-1">A Toy Problem</a></h2><p>Consider the gradient of a vector-quadratic function. The following code snippet constructs such a function, and inputs <code>x</code> and <code>y</code>.</p><pre><code class="language-">using Nabla

# Generate some data.
rng, N = MersenneTwister(123456), 2
x, y = randn.(rng, [N, N])
A = randn(rng, N, N)

# Construct a vector-quadratic function in `x` and `y`.
f(x, y) = y&#39; * (A * x)
f(x, y)</code></pre><p>Only a small amount of <a href="https://en.wikipedia.org/wiki/Matrix_calculus">matrix calculus</a> is required to the find the gradient of <code>f(x, y)</code> w.r.t. <code>x</code> and <code>y</code>, which we denote by <code>∇x</code> and <code>∇y</code> respectively, to be</p><pre><code class="language-">(∇x, ∇y) = (A&#39;y, A * x)</code></pre><h2><a class="nav-anchor" id="High-Level-Interface-1" href="#High-Level-Interface-1">High-Level Interface</a></h2><p>The high-level interface provides a simple way to &quot;just get the gradients&quot; w.r.t. each argument of <code>f</code>:</p><pre><code class="language-">∇x, ∇y = ∇(f)(x, y)</code></pre><p>This interface is implemented in <code>core.jl</code>, and is a thin wrapper of the low-level interface constructed above. Here, we first use <code>∇</code> to get a function which, when evaluated, returns the gradient of <code>f</code> w.r.t. each of it&#39;s inputs at the values of the inputs provided.</p><p>We may provide an optional argument to also return the value <code>f(x, y)</code>:</p><pre><code class="language-">(z, (∇x, ∇y)) = ∇(f; get_output=true)(x, y)</code></pre><p>If the gradient w.r.t. a single argument is all that is required, or a subset of the arguments for an N-ary function, we recommend closing over the arguments which respect to which you do not wish to take gradients. For example, to take the gradient w.r.t. just <code>x</code>, one could do the following:</p><pre><code class="language-">∇(x-&gt;f(x, y))(x)</code></pre><p>Note that this returns a 1-tuple containing the result, not the result itself!</p><p>Furthermore, indexable containers such as <code>Dict</code>s behave sensibly. For example, the following lambda with a <code>Dict</code>:</p><pre><code class="language-">∇(d-&gt;f(d[:x], d[:y]))(Dict(:x=&gt;x, :y=&gt;y))</code></pre><p>or a <code>Vector</code>:</p><pre><code class="language-">∇(v-&gt;f(v[1], v[2]))([x, y])</code></pre><p>The methods considered so far have been completely generically typed. If one wishes to use methods whose argument types are restricted then one must surround the definition of the method in the <code>@unionise</code> macro. For example, if only a single definition is required:</p><pre><code class="language-julia">@unionise g(x::Real) = ...</code></pre><p>Alternatively, if multiple methods / functions are to be defined, the following format is recommended:</p><pre><code class="language-julia">@unionise begin
g(x::Real) = ...
g(x::T, y::T) where T&lt;:Real = ...
foo(x) = ... # This definition is unaffected by `@unionise`.
end</code></pre><p><code>@unionise</code> simply changes the method signature to allow each argument to accept the union of the types specified and <code>Nabla.jl</code>&#39;s internal <code>Node</code> type. This will have no impact on the performance of your code when arguments of the types specified in the definition are provided, so you can safely <code>@unionise</code> code without worrying about potential performance implications.</p><h2><a class="nav-anchor" id="Low-Level-Interface-1" href="#Low-Level-Interface-1">Low-Level Interface</a></h2><p>We now use <code>Nabla.jl</code>&#39;s low-level interface to take the gradient of <code>f</code> w.r.t. <code>x</code> and <code>y</code> at the values of <code>x</code> and <code>y</code> generated above. We first place <code>x</code> and <code>y</code> into a <code>Leaf</code> container. This enables these variables to be traced by <code>Nabla.jl</code>. This can be achieved by first creating a <code>Tape</code> object, onto which all computations involving <code>x</code> and <code>y</code> are recorded, as follows:</p><pre><code class="language-julia">tape = Tape()
x_ = Leaf(tape, x)
y_ = Leaf(tape, y)</code></pre><p>which can be achieved more concisely using Julia&#39;s broadcasting capabilities:</p><pre><code class="language-">x_, y_ = Leaf.(Tape(), (x, y))</code></pre><p>Note that it is critical that <code>x_</code> and <code>y_</code> are constructed using the same <code>Tape</code> instance. Currently, <code>Nabla.jl</code> will fail silently if this is not the case. We then simply pass <code>x_</code> and <code>y_</code> to <code>f</code> instead of <code>x</code> and <code>y</code>:</p><pre><code class="language-">z_ = f(x_, y_)</code></pre><p>We can compute the gradients of <code>z_</code> w.r.t. <code>x_</code> and <code>y_</code> using <code>∇</code>, and access them by indexing the output with <code>x_</code> and <code>y_</code>:</p><pre><code class="language-">∇z = ∇(z_)
(∇x, ∇y) = (∇z[x_], ∇z[y_])</code></pre><h2><a class="nav-anchor" id="Gotchas-and-Best-Practice-1" href="#Gotchas-and-Best-Practice-1">Gotchas and Best Practice</a></h2><ul><li><code>Nabla.jl</code> does not currently have complete coverage of the entire standard library due to finite resources and competing priorities. Particularly notable omissions are the subtypes of <code>Factorization</code> objects and all in-place functions. These are both issues which will be resolved in the future.</li><li>The usual RMAD gotcha applies: due to the need to record each of the operations performed in the execution of a function for use in efficient gradient computation, the memory requirement of a programme scales approximately linearly in the length of the programme. Although, due to our use of a dynamically constructed computation graph, we support all forms of control flow, long <code>for</code> / <code>while</code> loops should be performed with care, so as to avoid running out of memory.</li><li>In a similar vein, develop a (strong) preference for higher-order functions and linear algebra over for-loops; <code>Nabla.jl</code> has optimisations targetting Julia&#39;s higher-order functions (<code>broadcast</code>, <code>mapreduce</code> and friends), and consequently loop-fusion / &quot;dot-syntax&quot;, and linear algebra operations which should be made use of where possible.</li></ul><footer><hr/><a class="next" href="pages/api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
