<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Nabla.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Nabla.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li><li><a class="toctext" href="../custom/">Custom Sensitivities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.Arg" href="#Nabla.Arg"><code>Nabla.Arg</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Used to flag which argument is being specified in x̄. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.Branch" href="#Nabla.Branch"><code>Nabla.Branch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A Branch is a Node with parents (args).</p><p>Fields: val - the value of this node produced in the forward pass. f - the function used to generate this Node. args - Values indicating which elements in the tape will require updating by this node. tape - The Tape to which this Branch is assigned. pos - the location of this Branch in the tape to which it is assigned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.Leaf" href="#Nabla.Leaf"><code>Nabla.Leaf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An element at the &#39;bottom&#39; of the computational graph.</p><p>Fields: val - the value of the node. tape - The Tape to which this Leaf is assigned. pos - the location of this Leaf in the tape to which it is assigned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.Node" href="#Nabla.Node"><code>Nabla.Node</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Basic unit on the computational graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.Tape" href="#Nabla.Tape"><code>Nabla.Tape</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A topologically ordered collection of Nodes. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.check_errs-Union{Tuple{T}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T,Number}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T,Number,Number}} where T" href="#Nabla.check_errs-Union{Tuple{T}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T,Number}, Tuple{Any,Union{Number, AbstractArray{#s597,N} where N where #s597&lt;:Number},T,T,Number,Number}} where T"><code>Nabla.check_errs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">check_errs(
    f,
    ȳ::∇ArrayOrScalar,
    x::T,
    v::T,
    ε_abs::∇Scalar=1e-10,
    ε_rel::∇Scalar=1e-7
)::Bool where T</code></pre><p>Check that the difference between finite differencing directional derivative estimation and RMAD directional derivative computation for function <code>f</code> at <code>x</code> in direction <code>v</code>, for both allocating and in-place modes, has absolute and relative errors of <code>ε_abs</code> and <code>ε_rel</code> respectively, when scaled by reverse-mode sensitivity <code>ȳ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.domain1-Union{Tuple{T}, Tuple{Function,Function,Array{T,1}}} where T" href="#Nabla.domain1-Union{Tuple{T}, Tuple{Function,Function,Array{T,1}}} where T"><code>Nabla.domain1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">domain1{T}(in_domain::Function, measure::Function, points::Vector{T})
domain1(f::Function)</code></pre><p>Attempt to find a domain for a unary, scalar function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>in_domain::Function</code>: Function that takes a single argument <code>x</code> and returns whether <code>x</code>   argument is in <code>f</code>&#39;s domain.</li><li><code>measure::Function</code>: Function that measures the size of a set of points for <code>f</code>.</li><li><code>points::Vector{T}</code>: Ordered set of test points to construct the domain from.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.domain2-Tuple{Function}" href="#Nabla.domain2-Tuple{Function}"><code>Nabla.domain2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">domain2(f::Function)</code></pre><p>Attempt to find a rectangular domain for a binary, scalar function <code>f</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.in_domain-Tuple{Function,Vararg{Float64,N} where N}" href="#Nabla.in_domain-Tuple{Function,Vararg{Float64,N} where N}"><code>Nabla.in_domain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">in_domain(f::Function, x::Float64...)</code></pre><p>Check whether an input <code>x</code> is in a scalar, real function <code>f</code>&#39;s domain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.preprocess-Tuple{Any,Vararg{Any,N} where N}" href="#Nabla.preprocess-Tuple{Any,Vararg{Any,N} where N}"><code>Nabla.preprocess</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">preprocess(::Function, args...)</code></pre><p>Default implementation of preprocess returns an empty Tuple. Individual sensitivity implementations should add methods specific to their use case. The output is passed in to <code>∇</code> as the 3rd or 4th argument in the new-x̄ and update-x̄ cases respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.∇-Tuple{Any}" href="#Nabla.∇-Tuple{Any}"><code>Nabla.∇</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∇(f; get_output::Bool=false)</code></pre><p>Returns a function which, when evaluated with arguments that are accepted by <code>f</code>, will return the gradient w.r.t. each of the arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.∇-Tuple{Node,Any}" href="#Nabla.∇-Tuple{Node,Any}"><code>Nabla.∇</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∇(y::Node{&lt;:∇Scalar})
∇(y::Node{T}, ȳ::T) where T</code></pre><p>Return a <code>Tape</code> object which can be indexed using <code>Node</code>s, each element of which contains the result of multiplying <code>ȳ</code> by the transpose of the Jacobian of the function specified by the <code>Tape</code> object in <code>y</code>. If <code>y</code> is a scalar and <code>ȳ = 1</code> then this is equivalent to computing the gradient of <code>y</code> w.r.t. each of the elements in the <code>Tape</code>.</p><pre><code class="language-none">∇(f::Function, ::Type{Arg{N}}, p, y, ȳ, x...)
∇(x̄, f::Function, ::Type{Arg{N}}, p, y, ȳ, x...)</code></pre><p>To implement a new reverse-mode sensitivity for the <code>N^{th}</code> argument of function <code>f</code>. p is the output of <code>preprocess</code>. <code>x1</code>, <code>x2</code>,... are the inputs to the function, <code>y</code> is its output and <code>ȳ</code> the reverse-mode sensitivity of <code>y</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.@explicit_intercepts" href="#Nabla.@explicit_intercepts"><code>Nabla.@explicit_intercepts</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@explicit_intercepts(f::Symbol, type_tuple::Expr, is_node::Expr[, kwargs::Expr])
@explicit_intercepts(f::Symbol, type_tuple::Expr)</code></pre><p>Create a collection of methods which intecept the function calls to <code>f</code> in which at least one argument is a <code>Node</code>. Types of arguments are specified by the type tuple expression in <code>type_tuple</code>. If there are arguments which are not differentiable, they can be specified by providing a boolean vector <code>is_node</code> which indicates those arguments that are differentiable with <code>true</code> values and those which are not as <code>false</code>. Keyword arguments to add to the function signature can be specified in <code>kwargs</code>, which must be a <code>NamedTuple</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.@union_intercepts" href="#Nabla.@union_intercepts"><code>Nabla.@union_intercepts</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@union_intercepts f type_tuple invoke_type_tuple [kwargs]</code></pre><p>Interception strategy based on adding a method to <code>f</code> which accepts the union of each of the types specified by <code>type_tuple</code>. If none of the arguments are <code>Node</code>s then the method of <code>f</code> specified by <code>invoke_type_tuple</code> is invoked. If applicable, keyword arguments should be provided as a <code>NamedTuple</code> and be added to the generated function&#39;s signature.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.@unionise-Tuple{Any}" href="#Nabla.@unionise-Tuple{Any}"><code>Nabla.@unionise</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@unionise code</code></pre><p>Transform code such that each function definition accepts <code>Node</code> objects as arguments, without effecting dispatch in other ways.</p></div></div></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../custom/"><span class="direction">Next</span><span class="title">Custom Sensitivities</span></a></footer></article></body></html>
