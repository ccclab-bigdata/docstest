<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PiecewiseDeterministicMarkovProcesses.jl Â· Piecewise Deterministic Markov Processes in Julia </title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Piecewise Deterministic Markov Processes in Julia </h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>PiecewiseDeterministicMarkovProcesses.jl</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Basic-example-with-CHV-method-1">Basic example with CHV method</a></li><li><a class="toctext" href="#Adding-more-sampling-points-in-between-jumps-1">Adding more sampling points in between jumps</a></li><li><a class="toctext" href="#Basic-example-with-the-rejection-method-1">Basic example with the rejection method</a></li><li><a class="toctext" href="#How-to-chose-a-simulation-method?-1">How to chose a simulation method?</a></li><li class="toplevel"><a class="toctext" href="#Advance-uses-1">Advance uses</a></li><li><a class="toctext" href="#Specify-a-jump-with-a-function-1">Specify a jump with a function</a></li><li class="toplevel"><a class="toctext" href="#Application-programming-interface-1">Application programming interface</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>PiecewiseDeterministicMarkovProcesses.jl</a></li></ul></nav><hr/><div id="topbar"><span>PiecewiseDeterministicMarkovProcesses.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PiecewiseDeterministicMarkovProcesses.jl-1" href="#PiecewiseDeterministicMarkovProcesses.jl-1">PiecewiseDeterministicMarkovProcesses.jl</a></h1><p>PiecewiseDeterministicMarkovProcesses.jl is a Julia package that allows simulation of <em>Piecewise Deterministic Markov Processes</em> (PDMP); these encompass hybrid systems and jump processes, comprised of continuous and discrete components, as well as processes with time-varying rates. The aim of the package is to provide methods for the simulation of these processes that are &quot;exact&quot; up to the ODE integrator.</p><p>We provide several methods for the simulation:</p><ul><li>a recent trick, called <strong>CHV</strong>, explained in <a href="http://arxiv.org/abs/1504.06873">paper-2015</a> which allows to implement the <strong>True Jump Method</strong> without the need to use event detection schemes for the ODE integrator. These event detections can be quite unstable as explained in <a href="http://arxiv.org/abs/1504.06873">paper-2015</a> and CHV provide a solution to this problem.</li><li><strong>rejection methods</strong> for which the user is asked to provide a bound on the reaction rates. These last methods are the most &quot;exact&quot; but not the fastest if the reaction rate bound is not tight. In case the flow is known analytically, a method is also provided.</li></ul><p>These methods require solving stiff ODEs (for CHV ) in an efficient manner. <a href="https://github.com/JuliaLang/Sundials.jl"><code>Sundials.jl</code></a> and <a href="https://github.com/rveltz/LSODA.jl"><code>LSODA.jl</code></a> are used, but other solvers could be easily added. (See <a href="http://lh3lh3.users.sourceforge.net/solveode.shtml">stiff ode solvers</a>).</p><p>We briefly recall facts about a simple class of PDMPs. They are described by a couple <span>$(x_c,x_d)$</span> where <span>$x_c$</span> is solution of the differential equation <span>$\frac{dx_c}{dt} = F(x_c,x_d,t)$</span>. The second component <span>$x_d$</span> is a jump process with rates <span>$R(x_c,x_d,t)$</span>. At each jump of <span>$x_d$</span>, a jump can also be added to the continuous variable <span>$x_c$</span>.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>To install this (unregistered) package, run the command </p><pre><code class="language-julia">add https://github.com/rveltz/PiecewiseDeterministicMarkovProcesses.jl.git</code></pre><h2><a class="nav-anchor" id="Basic-example-with-CHV-method-1" href="#Basic-example-with-CHV-method-1">Basic example with CHV method</a></h2><p><strong>A strong requirement for the CHV method is that the total rate (<em>i.e.</em> sum(rate)) must be positive. This can be easily achieved by adding a dummy Poisson process with very low intensity (see next section).</strong></p><p>See also the <a href="https://github.com/rveltz/PiecewiseDeterministicMarkovProcesses.jl/tree/master/examples">examples directory</a> for more involved examples. </p><p>A simple example of jump process is given below. More precisely, we look at the following process of switching dynamics where <span>$X(t) = (x_c(t), x_d(t)) \in\mathbb R\times\lbrace-1,1\rbrace.$</span> In between jumps, <span>$x_c$</span> evolves according to <span>$\dot x_c(t) = x_d(t)x_c(t).$</span>  </p><p>We first need to load the library.  </p><pre><code class="language-julia">using PiecewiseDeterministicMarkovProcesses</code></pre><p>We then define a function that encodes the dynamics in between jumps. We need to provide the vector field of the ODE. Hence, we need to define a function that, given continuous state <span>$x_c$</span> and discrete state <span>$x_d$</span> at time <span>$t$</span>, returns the vector field. In addition some parameters can be passed with the variable <code>parms</code>.</p><pre><code class="language-julia">function F_tcp!(xcdot, xc, xd, t, parms)
  # vector field used for the continuous variable
  xcdot[1] = xd[1]*xc[1]
end </code></pre><p>Let&#39;s consider a stochastic process with following transitions:</p><table><tr><th>Transition</th><th>Rate</th><th>Reaction number</th><th>Jump</th></tr><tr><td><span>$x_d\to x_d-2$</span> if <span>$x_d&gt;0$</span></td><td>1</td><td>1</td><td>[-2]</td></tr><tr><td><span>$x_d\to x_d+2$</span> if <span>$x_d&lt;0$</span></td><td>1</td><td>2</td><td>[2]</td></tr></table><p>We implement these jumps using a 2x1 matrix <code>nu</code> of Integers, such that the jumps on each discrete component of <code>xd</code> is given by <code>nu * xd</code>. Hence, we have <code>nu = reshape([[2];[-2]],2,1)</code>.	</p><p>These reactions with their rate are encoded in the following function.</p><pre><code class="language-julia">function R_tcp!(rate, xc, xd, t, parms, sum_rate::Bool)
  # transition rates function for each transition
  # in this case,  the transitions are xd-&gt;xd+2 or xd-&gt;xd-2
  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may 
  # i.e. the sum of the rates or the vector of the rates
  if sum_rate == false
      if xd[1] &gt; 0
          rate[1] = 0.
          rate[2] = 1.
      else
      	  rate[1] = 1.
          rate[2] = 0.
      end
      #we return 0. because nothing is supposed to be returned
      return 0.
  else
  	# we return sum(rate) without altering rate as we are asked to do
    return 1.
  end
end

# initial conditions for the continuous/discrete variables
xc0 = vec([0.05])
xd0 = vec([1])

# matrix of jumps for the discrete variables, analogous to chemical reactions
nu = reshape([[2];[-2]],2,1)


# parameters
parms = [0.]
tf = 25.

# compile the program:
dummy =  PiecewiseDeterministicMarkovProcesses.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=1)

# compute a trajectory, in this case 100 jumps
srand(123)
result =  @time PiecewiseDeterministicMarkovProcesses.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=100)

# plotting
using Plots
Plots.plot(result.time, result.xd[1,:],line=:step,title = string(&quot;#Jumps = &quot;,length(result.time)),label=&quot;Xd&quot;)
Plots.plot(result.time, result.xc&#39;,title = string(&quot;#Jumps = &quot;,length(result.time)),label=&quot;Xc&quot;)</code></pre><p>This produces the following graph:</p><p><img src="xc.png" alt="TCP"/></p><h2><a class="nav-anchor" id="Adding-more-sampling-points-in-between-jumps-1" href="#Adding-more-sampling-points-in-between-jumps-1">Adding more sampling points in between jumps</a></h2><p>The current interface &quot;only&quot; returns the jumping times. On may want to resolve the trajectory in between jumps. For example, in the previous example, in between two jumps, the trajectory should be exponential and not linear as shown. </p><p>A simple trick to do this is to add a Poisson process to the reactions set with a given sampling rate. We have to modify <code>nu, xcd0</code> and <code>R_tcp!</code> for this. The set of reactions is now the following</p><table><tr><th>Transition</th><th>Rate</th><th>Jump</th></tr><tr><td><span>$x_d[1]\to x_d[1]-2$</span> if <span>$x_d[1]&gt;0$</span></td><td>1</td><td>[-2,0]</td></tr><tr><td><span>$x_d[1]\to x_d[1]+2$</span> if <span>$x_d[1]&lt;0$</span></td><td>1</td><td>[2,0]</td></tr><tr><td><span>$x_d[2]\to x_d[2]+1$</span></td><td>rate_save</td><td>[0,1]</td></tr></table><p>Hence, we implement these jumps with the following matrix: <code>nu2 = [[2 0];[-2 0];[0 1]]</code>.</p><pre><code class="language-julia">nu2 = [[2 0];[-2 0];[0 1]]
# the second component is the Poisson process
xd0 = vec([1, 0])

function R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)
  # transition rates function for each transition
  # in this case,  the transitions are xd-&gt;xd+2 or xd-&gt;xd-2
  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may 
  # i.e. the sum of the rates or the vector of the rates
  rate_save = 10. #sampling rate in between true jumps
  if sum_rate == false
      if xd[1] &gt; 0
          rate[1] = 0.
          rate[2] = 1.
          rate[3] = rate_save #Poisson process used as sampling process
      else
          rate[1] = 1.
          rate[2] = 0.
          rate[3] = rate_save #Poisson process used as sampling process
      end
      #we return 0. because nothing is supposed to be returned
      return 0.
  else
    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so
    return 1. + rate_save
  end
end

srand(123)  
result2 =  @time PiecewiseDeterministicMarkovProcesses.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000)
Plots.plot(result2.time, result2.xc&#39;,title = string(&quot;#Jumps = &quot;,length(result2.time)),label=&quot;Xc2&quot;)</code></pre><p>This gives the following result:</p><p><img src="xc2.png" alt="TCP"/></p><h2><a class="nav-anchor" id="Basic-example-with-the-rejection-method-1" href="#Basic-example-with-the-rejection-method-1">Basic example with the rejection method</a></h2><p>The previous method is useful when the total rate function varies a lot. In the case where the total rate is mostly constant in between jumps, the <strong>rejection method</strong> is more appropriate. </p><p>The <strong>rejection method</strong> assumes some a priori knowledge of the process one wants to simulate. In particular, the user must be able to provide a bound on the total rate. More precisely, the user must provide a constant bound in between jump. To use this method, one needs to return <code>sum(rate), bound_rejection</code> in the above function <code>R_tcp!</code>. Note that this means that in between jumps, one have:</p><p><code>sum(rate)(t) &lt;= bound_rejection</code></p><pre><code class="language-julia">nu2 = [[2 0];[-2 0];[0 1]]
# the second component is the Poisson process
xd0 = vec([1, 0])

function R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)
  # transition rates function for each transition
  # in this case,  the transitions are xd-&gt;xd+2 or xd-&gt;xd-2
  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may 
  # i.e. the sum of the rates or the vector of the rates
  rate_save       = 10.           # sampling rate in between true jumps
  bound_rejection = 1.+rate_save  # bound on the total rate, here 0 + 1 + rate_save
  if sum_rate == false
      if xd[1] &gt; 0
          rate[1] = 0.
          rate[2] = 1.
          rate[3] = rate_save #Poisson process used as sampling process
      else
          rate[1] = 1.
          rate[2] = 0.
          rate[3] = rate_save #Poisson process used as sampling process
      end
      #we return 0. because nothing is supposed to be returned
      return 0., bound_rejection
  else
    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so
    return 1. + rate_save, bound_rejection
  end
end</code></pre><p>We can now simulate this process as follows</p><pre><code class="language-julia">srand(123)
result3 =  @time PiecewiseDeterministicMarkovProcesses.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000,algo=:rejection)
Plots.plot(result3.time, result3.xc&#39;,title = string(&quot;#Jumps = &quot;,length(result3.time)),label=&quot;rejection&quot;)</code></pre><h2><a class="nav-anchor" id="How-to-chose-a-simulation-method?-1" href="#How-to-chose-a-simulation-method?-1">How to chose a simulation method?</a></h2><p>The choice of the method CHV vs Rejection only depends on how much you know about the system. </p><p>More precisely, if the total rate function does not vary much in between jumps, use the rejection method. For example, if the rate is <span>$R(x_c(t)) = 1+0.1\cos(t)$</span>,  then <span>$1+0.1$</span> will provide a tight bound to use for the rejection method and almost no (fictitious) jumps will be rejected. </p><p>In all other cases, one should try the CHV method where no a priori knowledge of the rate function is requied.</p><h1><a class="nav-anchor" id="Advance-uses-1" href="#Advance-uses-1">Advance uses</a></h1><h2><a class="nav-anchor" id="Specify-a-jump-with-a-function-1" href="#Specify-a-jump-with-a-function-1">Specify a jump with a function</a></h2><p>to be done</p><h1><a class="nav-anchor" id="Application-programming-interface-1" href="#Application-programming-interface-1">Application programming interface</a></h1><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PiecewiseDeterministicMarkovProcesses.pdmp!" href="#PiecewiseDeterministicMarkovProcesses.pdmp!"><code>PiecewiseDeterministicMarkovProcesses.pdmp!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">This function performs a pdmp simulation using the Change of Variable (CHV, see https://arxiv.org/abs/1504.06873) method or the rejection method.
It takes the following arguments:</code></pre><p><code>pdmp!(xc0,xd0,F!,R!,DX,nu,parms,ti,tf;verbose::Bool = false,ode = :cvode,algo=:chv, n_jumps = 1_000,save_positions = (false,true))</code></p><pre><code class="language-none">- **xc0**: a `Vector` of `Float64`, representing the initial states of the continuous variable.
- **xd0**: a `Vector` of `Int64`, representing the initial states of the discrete variable.
- **F!**: an inplace `Function` or a callable type, which itself takes five arguments to represent the vector field; xdot a `Vector` of `Float64` representing the vector field associated to the continuous variable, xc `Vector` representing the current state of the continuous variable, xd `Vector` of `Int64` representing the current state of the discrete variable, t a `Float64` representing the current time and parms, a `Vector` of `Float64` representing the parameters of the system. `F!(xdot,xc,xd,t,parms)` returns `nothing`
- **R!**: an inplace `Function` or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate `Vector` of `Float64` holding the different reaction rates, xc `Vector` of `Float64` representing the current state of the continuous variable, xd `Vector` of `Int64` representing the current state of the discrete variable, t a `Float64` representing the current time, parms a `Vector` of `Float64` representing the parameters of the system and sum_rate a `Bool` being a flag asking to return a `Float64` if true and a `Vector` otherwise. `R!(rate,xc,xd,t,parms,sum_rate)` returns `Float64,Float64`
- **DX**: a `Function` or a callable type, which itself takes five arguments to apply the jump to the continuous/discrete variable;xc `Vector` of `Float64` representing the current state of the continuous variable, xd `Vector` of `Int64` representing the current state of the discrete variable, t a `Float64` representing the current time, parms a `Vector` of `Float64` representing the parameters of the system and ind_rec an `Int64` representing the index of the discrete jump. `DX(xc,xd,t,parms,ind_rec)` returns `nothing`
- **nu**: a `Matrix` of `Int64`, representing the transitions of the system, organised by row.
- **parms** : data for the parameters of the system. It is passed to `F!`,`R!` and `DX`.
- **ti**: the initial simulation time (`Float64`)
- **tf**: the final simulation time (`Float64`)
- **verbose**: a `Bool` for printing verbose.
- **ode**: ode time stepper `:cvode`, `:lsoda` or any solver from `DifferentialEquations.jl`, like `CVODE_BDF()`.
- **n_jumps**: an `Int64` representing the maximum number of jumps to be computed.
- **ind_save_d**: a range to hold the indices of the discrete variable to be saved
- **ind_save_c**: a range to hold the indices of the continuous variable to be saved</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PiecewiseDeterministicMarkovProcesses.chv!" href="#PiecewiseDeterministicMarkovProcesses.chv!"><code>PiecewiseDeterministicMarkovProcesses.chv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><p>chv!</p><p>This function performs a pdmp simulation using the Change of Variable (CHV) method see https://arxiv.org/abs/1504.06873. It takes the following arguments:</p><ul><li><strong>n_max</strong>: an <code>Int64</code> representing the maximum number of jumps to be computed.</li><li><strong>xc0</strong> : a <code>Vector</code> of <code>Float64</code>, representing the initial states of the continuous variable.</li><li><strong>xd0</strong> : a <code>Vector</code> of <code>Int64</code>, representing the initial states of the discrete variable.</li><li><strong>F!</strong> : an inplace <code>Function</code> or a callable type, which itself takes five arguments to represent the vector field; xdot a <code>Vector</code> of <code>Float64</code> representing the vector field associated to the continuous variable, xc <code>Vector</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time and parms, a <code>Vector</code> of <code>Float64</code> representing the parameters of the system.</li><li><strong>R</strong> : an inplace <code>Function</code> or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate <code>Vector</code> of <code>Float64</code> holding the different reaction rates, xc <code>Vector</code> of <code>Float64</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time, parms a <code>Vector</code> of <code>Float64</code> representing the parameters of the system and sum_rate a <code>Bool</code> being a flag asking to return a <code>Float64</code> if true and a <code>Vector</code> otherwise.</li><li><strong>DX</strong> : a <code>Function</code> or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc <code>Vector</code> of <code>Float64</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time, parms a <code>Vector</code> of <code>Float64</code> representing the parameters of the system and ind_rec an <code>Int64</code> representing the index of the discrete jump.</li><li><strong>nu</strong> : a <code>Matrix</code> of <code>Int64</code>, representing the transitions of the system, organised by row.</li><li><strong>parms</strong> : data for the parameters of the system.</li><li><strong>tf</strong> : the final simulation time (<code>Float64</code>)</li><li><strong>verbose</strong> : a <code>Bool</code> for printing verbose.</li><li><strong>ode</strong>: ode time stepper, must be one of those: [:cvode,:lsoda,:Adams,:BDF]</li><li><strong>save_at</strong>: array of ordered time at which the solution is required</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PiecewiseDeterministicMarkovProcesses.rejection_exact" href="#PiecewiseDeterministicMarkovProcesses.rejection_exact"><code>PiecewiseDeterministicMarkovProcesses.rejection_exact</code></a> â <span class="docstring-category">Function</span>.</div><div><div><p>rejection_exact</p><p>This function performs a simulation using the rejection method when the flow <strong>is known analytically</strong>. It takes the following arguments:</p><ul><li><strong>n_max</strong>: an <code>Int64</code> representing the maximum number of jumps to be computed.</li><li><strong>xc0</strong> : a <code>Vector</code> of <code>Float64</code>, representing the initial states of the continuous variable.</li><li><strong>xd0</strong> : a <code>Vector</code> of <code>Int64</code>, representing the initial states of the discrete variable.</li><li><strong>Phi!</strong> : a <code>Function</code> or a callable type, which itself takes 6 arguments to represent the vector field; rate a <code>Vector</code> of <code>Float64</code> representing the <strong>flow</strong> of the vector which needs to be filled with values of the rates, xdot a <code>Vector</code> of <code>Float64</code> representing the vector field associated to the continuous variable, xc <code>Vector</code> of <code>Float64</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time and parms, a <code>Vector</code> of <code>Float64</code> representing the parameters of the system, sum<em>of</em>rate a <code>Bool</code> stating if the function must return the total rate.</li><li><strong>R!</strong> : a <code>Function</code> or a callable type, which itself takes five arguments to represent the rate functions associated to the jumps;xc <code>Vector</code> of <code>Float64</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time, parms a <code>Vector</code> of <code>Float64</code> representing the parameters of the system and sum<em>rate a <code>Bool</code> being a flag asking to return a <code>Float64</code> if true and a <code>Vector</code> otherwise. The returned vector has components. If sum</em>rate is <code>False</code>, one must return rate<em>vector, bound</em> where bound_ is a bound on the total rate vector. In the case sum<em>rate is <code>True</code>, one must return total</em>rate,bound_ where total<em>rate is a <code>Float64</code> that is the sum of the rates. In any case, the function must return a couple (total</em>rates, bound) where bound is a bound for the total rate.</li><li><strong>Delta</strong> : a <code>Function</code> or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc <code>Vector</code> of <code>Float64</code> representing the current state of the continuous variable, xd <code>Vector</code> of <code>Int64</code> representing the current state of the discrete variable, t a <code>Float64</code> representing the current time, parms a <code>Vector</code> of <code>Float64</code> representing the parameters of the system and ind_rec an <code>Int64</code> representing the index of the discrete jump.</li><li><strong>nu</strong> : a <code>Matrix</code> of <code>Int64</code>, representing the transitions of the system, organised by row.</li><li><strong>parms</strong> : data for the parameters of the system.</li><li><strong>tf</strong> : the final simulation time (<code>Float64</code>)</li><li><strong>verbose</strong> : a <code>Bool</code> for printing verbose.</li></ul></div></div></section><footer><hr/></footer></article></body></html>
