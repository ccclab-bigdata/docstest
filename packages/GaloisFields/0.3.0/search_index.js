var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#GaloisFields.jl-finite-fields-for-Julia-1",
    "page": "Readme",
    "title": "GaloisFields.jl - finite fields for Julia",
    "category": "section",
    "text": "Build Status Test coverage\n[![][travis-img]][travis-url] [![][appveyor-img]][appveyor-url] [![Coverage Status][codecov-img]][codecov-url]"
},

{
    "location": "#Introduction-1",
    "page": "Readme",
    "title": "Introduction",
    "category": "section",
    "text": "This module defines types representing [finite fields][galois-fields-wiki]. It supports both fields of prime order and of prime power order.[galois-fields-wiki]: https://en.wikipedia.org/wiki/Finite_field"
},

{
    "location": "#Synopsis-1",
    "page": "Readme",
    "title": "Synopsis",
    "category": "section",
    "text": "The easiest way to create Galois fields is with the @GaloisField and @GaloisField! macros. Typically, you use the former for a field of prime order and the latter for a field of prime power order. In the prime power case, you pass a display name / variable name for the primitive element.using GaloisFields\n\nconst F = @GaloisField 29     # ℤ/29ℤ\nconst G = @GaloisField! 27 β   # degree-3 extension of ℤ/3ℤ; multiplicatively generated by β\n\nF(2)^29 == F(2)\nβ^27 == βThe macros also accept pretty-printed versions: more difficult to type but more elegant to read:const F = @GaloisField ℤ/29ℤ\nconst G = @GaloisField 𝔽₂₇ βIf you want to pass your own generator for the representation of a field of order q = p^n, you can:const F = @GaloisField! 𝔽₃ β^2 + β + 2\nβ^2 + β + 2 == 0Lastly, there\'s also function interfaces in cases where macros are not appropriate:const F = GaloisField(29)               # ℤ/29ℤ\nconst G, β = GaloisField(81, :β)        # degree-4 extension of ℤ/3ℤ\nconst G, β = GaloisField(3, 4, :β)      # same; avoid having to factorize 81\nconst F, β = GaloisField(3, :β => [2, 0, 0, 2, 1]) # same; pass our own custom minimum polynomial"
},

{
    "location": "#Fast-multiplications-1",
    "page": "Readme",
    "title": "Fast multiplications",
    "category": "section",
    "text": "In some cases, we make use of [Zech\'s logarithms][zech] for faster multiplications. By default, this happens if the order of the field is less than 2^16, if the characteristic is not 2, and if the primitive element is also a multiplicative generator. However, you can override this by calling either ofGaloisFields.enable_zech_multiplication(F)\nGaloisFields.disable_zech_multiplication(F)before doing any multiplication operation. If you call this function on a field whose primitive element is not a multiplicative generator, this will throw a warning.[zech]: https://en.wikipedia.org/wiki/Zech\'s_logarithm"
},

{
    "location": "#Conversions-1",
    "page": "Readme",
    "title": "Conversions",
    "category": "section",
    "text": "If you specify your own minimum polynomial, we make no assumptions about conversions between fields. For example, when definingconst F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ γ^2 + γ + 1an operation likeG(β)will throw an error. The mathematical reason is that  the fields F and G are isomorphic, but there is two different isomorphisms. (\"They are not canonically isomorphic.\") To choose an identification, you can use the identify function (which is not exported by default, so we use its full path):GaloisFields.identify(β => γ^2)\nGaloisFields.identify(γ => β^2)This allows for conversions such asG(β)\nconvert(F, γ + 1)The inner workings of this distinction are based on the symbol names. So if you define F and G with the same symbol and minimum polynomial:const F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ β^2 + β + 1then they are just considered equal and conversions work without extra work."
},

{
    "location": "#Conversions-for-the-default-minimum-polynomials-1",
    "page": "Readme",
    "title": "Conversions for the default minimum polynomials",
    "category": "section",
    "text": "If you do not specify a minimum polynomial, for example by usingconst F = @GaloisField! 𝔽₈₁ β\nconst G = @GaloisField! 𝔽₉ γthen we use [Conway polynomials][conway]. They have special compatibility relations between them, allowing conversions:β^10 == γThis works provided F and G have the same characteristic p. If the order of either is a power of the other, we convert into the bigger field. If not, we convert both into the field of order p^N, where N is the least common multiple of the extension degrees of F and G over ℤ/pℤ.[conway]: https://en.wikipedia.org/wiki/Conwaypolynomial(finite_fields)[travis-img]: https://travis-ci.org/tkluck/GaloisFields.jl.svg?branch=master [travis-url]: https://travis-ci.org/tkluck/GaloisFields.jl[appveyor-img]: https://ci.appveyor.com/api/projects/status/4g6ax1ni7ijx3rn4?svg=true [appveyor-url]: https://ci.appveyor.com/project/tkluck/galoisfields-jl[codecov-img]: https://codecov.io/gh/tkluck/GaloisFields.jl/branch/master/graph/badge.svg [codecov-url]: https://codecov.io/gh/tkluck/GaloisFields.jl"
},

{
    "location": "autodocs/#GaloisFields.@GaloisField",
    "page": "Docstrings",
    "title": "GaloisFields.@GaloisField",
    "category": "macro",
    "text": "F = @GaloisField 3\nF = @GaloisField ℤ/3ℤ\nF = @GaloisField 𝔽₃\nF,α = @GaloisField 3^2\n\nDifferent ways of defining a finite field.\n\nFor defining a Galois field of prime power order with n1, consider using @GaloisField! instead, which allows specifying the display name of the generator.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.@GaloisField!",
    "page": "Docstrings",
    "title": "GaloisFields.@GaloisField!",
    "category": "macro",
    "text": "const G = @GaloisField! 3 β^2 + 1\nconst G = @GaloisField! 𝔽₃ β^2 + 1\nconst G = @GaloisField! 3^2 β\nconst K = GaloisField(3)\nconst G = @GaloisField! K β^2 + 1\n\nDefine a finite field G and inject a variable for its primitive element into the current scope.\n\nNote that the variable name (e.g. β above) is part of the type. This lets you define identifications between isomorphic (sub)fields. For example, with the following definition\n\nconst F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ γ^2 + γ + 1\n\nthe fields F and G are isomorphic, but not canonically. We might define\n\n@GaloisFields.identify β => γ + 1\n@GaloisFields.identify γ => β + 1\n\nto allow for conversions like\n\nG(β)\nconvert(F, γ + 1)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.AbstractExtensionField",
    "page": "Docstrings",
    "title": "GaloisFields.AbstractExtensionField",
    "category": "type",
    "text": "abstract type AbstractExtensionField <: AbstractGaloisField end\n\nA type representing a finite extension of an underlying finite field.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.AbstractGaloisField",
    "page": "Docstrings",
    "title": "GaloisFields.AbstractGaloisField",
    "category": "type",
    "text": "abstract type AbstractGaloisField <: Number end\n\nA type representing finite fields.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.Direct",
    "page": "Docstrings",
    "title": "GaloisFields.Direct",
    "category": "type",
    "text": "Direct()\n\nA helper singleton for arithmetic operations that benefit from a log-table. Field implementations implement e.g.\n\n*(::Direct, a, b)\n\nand then define\n\n*(a::F, b::F) = zech_op(F, *, a, b)\n\nThis will use the ::Direct implementation for computing a log table where appropriate, and will either use the log table or the ::Direct implementation for computing results.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.ExtensionField",
    "page": "Docstrings",
    "title": "GaloisFields.ExtensionField",
    "category": "type",
    "text": "F = ExtensionField{F <: AbstractGaloisField, N, α, MinPoly}\n\nAlgebraic extension of a finite field F of degree N.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.GaloisField",
    "page": "Docstrings",
    "title": "GaloisFields.GaloisField",
    "category": "function",
    "text": "const F = GaloisField(p)\nconst F,α = GaloisField(p, :β => [1, 0, 1])\nconst F,α = GaloisField(p, n, :β)\n\nReturn a type representing a finite field.\n\nThe single-argument signature returns the finite field ℤpℤ.\n\nThe two-arguments signature returns an algebraic extension of that field, with minimum polynomial given by the second argument: a dense representation of the univariate, monic polynomial, with ascending degree.\n\nThe three-arguments signature returns an algebraic extension of that field, with minimum polynomial equal to the Conway polynomial  for (pn). The GaloisFields package ships with a database of Conway  polynomials and will raise an error if it does not contain an entry for  (pn).\n\nNote that in the latter two cases, the variable name (e.g. β above) is part of the type. This lets you define identifications between isomorphic (sub)fields. For example, with the following definition\n\nconst F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ γ^2 + γ + 1\n\nthe fields F and G are isomorphic, but not canonically. We might define\n\n@GaloisFields.identify β => γ + 1\n@GaloisFields.identify γ => β + 1\n\nto allow for conversions like\n\nG(β)\nconvert(F, γ + 1)\n\nIn the Conway case, you do not have to define your own identifications, as the Conway polynomials satisfy compatibility relations that allow us to use certain distinguished inclusions between them.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.GaloisFields",
    "page": "Docstrings",
    "title": "GaloisFields.GaloisFields",
    "category": "module",
    "text": "GaloisFields.jl - finite fields for Julia\n\nBuild Status Test coverage\n[![][travis-img]][travis-url] [![][appveyor-img]][appveyor-url] [![Coverage Status][codecov-img]][codecov-url]\n\nIntroduction\n\nThis module defines types representing [finite fields][galois-fields-wiki]. It supports both fields of prime order and of prime power order.\n\n[galois-fields-wiki]: https://en.wikipedia.org/wiki/Finite_field\n\nSynopsis\n\nThe easiest way to create Galois fields is with the @GaloisField and @GaloisField! macros. Typically, you use the former for a field of prime order and the latter for a field of prime power order. In the prime power case, you pass a display name / variable name for the primitive element.\n\nusing GaloisFields\n\nconst F = @GaloisField 29     # ℤ/29ℤ\nconst G = @GaloisField! 27 β   # degree-3 extension of ℤ/3ℤ; multiplicatively generated by β\n\nF(2)^29 == F(2)\nβ^27 == β\n\nThe macros also accept pretty-printed versions: more difficult to type but more elegant to read:\n\nconst F = @GaloisField ℤ/29ℤ\nconst G = @GaloisField 𝔽₂₇ β\n\nIf you want to pass your own generator for the representation of a field of order q = p^n, you can:\n\nconst F = @GaloisField! 𝔽₃ β^2 + β + 2\nβ^2 + β + 2 == 0\n\nLastly, there\'s also function interfaces in cases where macros are not appropriate:\n\nconst F = GaloisField(29)               # ℤ/29ℤ\nconst G, β = GaloisField(81, :β)        # degree-4 extension of ℤ/3ℤ\nconst G, β = GaloisField(3, 4, :β)      # same; avoid having to factorize 81\nconst F, β = GaloisField(3, :β => [2, 0, 0, 2, 1]) # same; pass our own custom minimum polynomial\n\nFast multiplications\n\nIn some cases, we make use of [Zech\'s logarithms][zech] for faster multiplications. By default, this happens if the order of the field is less than 2^16, if the characteristic is not 2, and if the primitive element is also a multiplicative generator. However, you can override this by calling either of\n\nGaloisFields.enable_zech_multiplication(F)\nGaloisFields.disable_zech_multiplication(F)\n\nbefore doing any multiplication operation. If you call this function on a field whose primitive element is not a multiplicative generator, this will throw a warning.\n\n[zech]: https://en.wikipedia.org/wiki/Zech\'s_logarithm\n\nConversions\n\nIf you specify your own minimum polynomial, we make no assumptions about conversions between fields. For example, when defining\n\nconst F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ γ^2 + γ + 1\n\nan operation like\n\nG(β)\n\nwill throw an error. The mathematical reason is that  the fields F and G are isomorphic, but there is two different isomorphisms. (\"They are not canonically isomorphic.\") To choose an identification, you can use the identify function (which is not exported by default, so we use its full path):\n\nGaloisFields.identify(β => γ^2)\nGaloisFields.identify(γ => β^2)\n\nThis allows for conversions such as\n\nG(β)\nconvert(F, γ + 1)\n\nThe inner workings of this distinction are based on the symbol names. So if you define F and G with the same symbol and minimum polynomial:\n\nconst F = @GaloisField! 𝔽₂ β^2 + β + 1\nconst G = @GaloisField! 𝔽₂ β^2 + β + 1\n\nthen they are just considered equal and conversions work without extra work.\n\nConversions for the default minimum polynomials\n\nIf you do not specify a minimum polynomial, for example by using\n\nconst F = @GaloisField! 𝔽₈₁ β\nconst G = @GaloisField! 𝔽₉ γ\n\nthen we use [Conway polynomials][conway]. They have special compatibility relations between them, allowing conversions:\n\nβ^10 == γ\n\nThis works provided F and G have the same characteristic p. If the order of either is a power of the other, we convert into the bigger field. If not, we convert both into the field of order p^N, where N is the least common multiple of the extension degrees of F and G over ℤ/pℤ.\n\n[conway]: https://en.wikipedia.org/wiki/Conwaypolynomial(finite_fields)\n\n[travis-img]: https://travis-ci.org/tkluck/GaloisFields.jl.svg?branch=master [travis-url]: https://travis-ci.org/tkluck/GaloisFields.jl\n\n[appveyor-img]: https://ci.appveyor.com/api/projects/status/4g6ax1ni7ijx3rn4?svg=true [appveyor-url]: https://ci.appveyor.com/project/tkluck/galoisfields-jl\n\n[codecov-img]: https://codecov.io/gh/tkluck/GaloisFields.jl/branch/master/graph/badge.svg [codecov-url]: https://codecov.io/gh/tkluck/GaloisFields.jl\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.PrimeField",
    "page": "Docstrings",
    "title": "GaloisFields.PrimeField",
    "category": "type",
    "text": "PrimeField{I<:Integer, p}\n\nA type representing an element in ℤ/pℤ.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.Reduced",
    "page": "Docstrings",
    "title": "GaloisFields.Reduced",
    "category": "type",
    "text": "Reduced()\n\nA helper singleton used for asserting that an input value has already been reduced mod p.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.char",
    "page": "Docstrings",
    "title": "GaloisFields.char",
    "category": "function",
    "text": "p = char(GaloisField(3)) # returns 3\n\nReturn the characteristic of a finite field, or 0 for <:Integer or <:Rational{<Integer}.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#GaloisFields.defaultshow",
    "page": "Docstrings",
    "title": "GaloisFields.defaultshow",
    "category": "function",
    "text": "defaultshow(io, t)\n\nOverloading display of types can be a bit hairy; I\'ve seen a declaration like\n\nshow(..., ::Type{<:Val{B}}) where B\n\nbeing called for non-concrete types. (I haven\'t dug deep enough to find a nice minimal example.)\n\nThat\'s why all show overloads for types do\n\n!isconcretetype(t) && return defaultshow(io, t)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "GaloisFields.@GaloisFieldGaloisFields.@GaloisField!GaloisFields.@identifyGaloisFields.AbstractExtensionFieldGaloisFields.AbstractGaloisFieldGaloisFields.BITREVERSALGaloisFields.BinaryFieldGaloisFields.BitsGaloisFields.BitsIterGaloisFields.DATAFILEGaloisFields.DirectGaloisFields.ExtensionFieldGaloisFields.GaloisFieldGaloisFields.GaloisFieldsGaloisFields.InclusionErrorGaloisFields.PrimeFieldGaloisFields.ReducedGaloisFields._conwaypolynomialsGaloisFields._factorizationGaloisFields._gcdxGaloisFields._parse_declarationGaloisFields._parsepolyGaloisFields._remGaloisFields._upgradeGaloisFields._widenGaloisFields.basefieldGaloisFields.bitswapGaloisFields.carrylessmulGaloisFields.charGaloisFields.conwaypolynomialGaloisFields.cycliclogtableGaloisFields.defaultshowGaloisFields.disable_zech_multiplicationGaloisFields.enable_zech_multiplicationGaloisFields.evalGaloisFields.expansionGaloisFields.genGaloisFields.gennameGaloisFields.identificationsGaloisFields.identifyGaloisFields.includeGaloisFields.inttypeGaloisFields.isconwayGaloisFields.iterGaloisFields.logtablesGaloisFields.minpolyGaloisFields.minpolymaskGaloisFields.nGaloisFields.overridesGaloisFields.zech_op"
},

]}
