<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ExprRules.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ExprRules.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.@grammar" href="#ExprRules.@grammar"><code>ExprRules.@grammar</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@grammar</code></pre><p>Define a grammar and return it as a Grammar. For example:</p><pre><code class="language-julia-repl">grammar = @grammar begin
    R = x
    R = 1 | 2
    R = R + R
end</code></pre></div></div></section><pre><code class="language-none">ExprRules.ExprRules</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.ExpressionIterator" href="#ExprRules.ExpressionIterator"><code>ExprRules.ExpressionIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ExpressionIterator(grammar::Grammar, max_depth::Int, sym::Symbol)</code></pre><p>An iterator over all possible expressions of a grammar up to max_depth with start symbol sym.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.Grammar" href="#ExprRules.Grammar"><code>ExprRules.Grammar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Grammar</code></pre><p>Represents a grammar and its production rules. Use the @grammar macro to create a Grammar object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.Interpreter" href="#ExprRules.Interpreter"><code>ExprRules.Interpreter</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Evaluates an expression without compiling it. Uses AST and symbol lookups. Only supports :call and :(=)  expressions at the moment. Example: tab = SymbolTable(:f =&gt; f, :x =&gt; x) ex = :(f(x)) interpret(tab, ex)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.NodeLoc" href="#ExprRules.NodeLoc"><code>ExprRules.NodeLoc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NodeLoc</code></pre><p>A helper struct that points to a node in the tree via its parent such that the child can be easily swapped out. If i is 0 the node pointed to is the root node and parent is the node itself.</p></div></div></section><pre><code class="language-none">ExprRules.NodeLocAndCount</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.NodeRecycler" href="#ExprRules.NodeRecycler"><code>ExprRules.NodeRecycler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Use a circular buffer to contain used RuleNodes to be recycled. First check the recycle bin to see if there are available RuleNodes, if not allocated a new one.  This helps minimize memory allocations and improves performance</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.RuleNode" href="#ExprRules.RuleNode"><code>ExprRules.RuleNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RuleNode</code></pre><p>Type for representing nodes in an expression tree.</p></div></div></section><pre><code class="language-none">ExprRules.RuleNodeAndCount</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.Interpreter.SymbolTable" href="#ExprRules.Interpreter.SymbolTable"><code>ExprRules.Interpreter.SymbolTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interpreter.SymbolTable(grammar::Grammar, mod::Module=Main)</code></pre><p>Returns a symbol table populated with mapping from symbols in grammar to symbols in module mod or Main, if defined.</p></div></div></section><pre><code class="language-none">ExprRules._add_to_symboltable!</code></pre><pre><code class="language-none">ExprRules._get_executable</code></pre><pre><code class="language-none">ExprRules._mindepth</code></pre><pre><code class="language-none">ExprRules._next_state!</code></pre><pre><code class="language-none">ExprRules._parse_rule!</code></pre><pre><code class="language-none">ExprRules._sample</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.child_types" href="#ExprRules.child_types"><code>ExprRules.child_types</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">child_types(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the types of the children (nonterminals) of the production rule at rule_index.</p></div></div><div><div><pre><code class="language-none">child_types(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the list of child types in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.contains_returntype" href="#ExprRules.contains_returntype"><code>ExprRules.contains_returntype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contains_returntype(node::RuleNode, grammar::Grammar, sym::Symbol, maxdepth::Int=typemax(Int))</code></pre><p>Returns true if the tree rooted at node contains at least one node at depth less than maxdepth with the given return type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.count_expressions" href="#ExprRules.count_expressions"><code>ExprRules.count_expressions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count_expressions(grammar::Grammar, max_depth::Int, sym::Symbol)</code></pre><p>Count the number of possible expressions of a grammar up to max_depth with start symbol sym.</p></div></div><div><div><pre><code class="language-none">count_expressions(iter::ExpressionIterator)</code></pre><p>Count the number of possible expressions in the expression iterator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.depth" href="#ExprRules.depth"><code>ExprRules.depth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">depth(root::RuleNode)</code></pre><p>Return the depth of the expression tree rooted at root.</p></div></div></section><pre><code class="language-none">ExprRules.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.get_childtypes" href="#ExprRules.get_childtypes"><code>ExprRules.get_childtypes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_childtypes(rule::Any, types::AbstractVector{Symbol})</code></pre><p>Returns the child types of a production rule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.get_executable" href="#ExprRules.get_executable"><code>ExprRules.get_executable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_executable(rulenode::RuleNode, grammar::Grammar)</code></pre><p>Returns the executable julia expression represented in the expression tree with root rulenode.  The returned expression can be evaluated using eval().</p></div></div></section><pre><code class="language-none">ExprRules.include</code></pre><pre><code class="language-none">ExprRules.interpret</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.iseval" href="#ExprRules.iseval"><code>ExprRules.iseval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iseval(rule::Any)</code></pre><p>Returns true if the rule is the special evaluate immediately function, i.e., _()</p></div></div><div><div><pre><code class="language-none">iseval(grammar::Grammar)</code></pre><p>Returns true if any production rules in grammar contain the special _() eval function.</p></div></div><div><div><pre><code class="language-none">iseval(grammar::Grammar, rule_index::Int)</code></pre><p>Returns true if the production rule at rule_index contains the special _() eval function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.isterminal" href="#ExprRules.isterminal"><code>ExprRules.isterminal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isterminal(rule::Any, types::AbstractVector{Symbol})</code></pre><p>Returns true if the rule is terminal, ie does not contain any of the types in the provided vector. For example, :(x) is terminal, and :(1+1) is terminal, but :(Real + Real) is typically not.</p></div></div><div><div><pre><code class="language-none">isterminal(grammar::Grammar, rule_index::Int)</code></pre><p>Returns true if the production rule at rule_index is terminal, i.e., does not contain any nonterminal symbols.</p></div></div><div><div><pre><code class="language-none">isterminal(grammar::Grammar, node::RuleNode)</code></pre><p>Returns true if the production rule used by node is terminal, i.e., does not contain any nonterminal symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.max_arity" href="#ExprRules.max_arity"><code>ExprRules.max_arity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">max_arity(grammar::Grammar)</code></pre><p>Returns the maximum arity (number of children) over all production rules in the grammar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.mindepth" href="#ExprRules.mindepth"><code>ExprRules.mindepth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mindepth(grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int})</code></pre><p>Returns the minimum depth achievable for a given nonterminal symbol</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.mindepth_map" href="#ExprRules.mindepth_map"><code>ExprRules.mindepth_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mindepth_map(grammar::Grammar)</code></pre><p>Returns the minimum depth achievable for each production rule, dmap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.nchildren" href="#ExprRules.nchildren"><code>ExprRules.nchildren</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nchildren(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the number of children (nonterminals) of the production rule at rule_index.</p></div></div><div><div><pre><code class="language-none">nchildren(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the number of children in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.node_depth" href="#ExprRules.node_depth"><code>ExprRules.node_depth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">node_depth(root::RuleNode, node::RuleNode)</code></pre><p>Return the depth of node for an expression tree rooted at root.  Depth is 1 when root == node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.nonterminals" href="#ExprRules.nonterminals"><code>ExprRules.nonterminals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nonterminals(grammar::Grammar)</code></pre><p>Returns a list of nonterminals in the grammar.</p></div></div></section><pre><code class="language-none">ExprRules.recycle!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.return_type" href="#ExprRules.return_type"><code>ExprRules.return_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">return_type(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the type of the production rule at rule_index.</p></div></div><div><div><pre><code class="language-none">return_types(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the return type in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.root_node_loc" href="#ExprRules.root_node_loc"><code>ExprRules.root_node_loc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">root_node_loc(root::RuleNode)</code></pre><p>Returns a NodeLoc pointing to the root node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(root::RuleNode, typ::Symbol, grammar::Grammar, maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node from the tree, limited to maxdepth.</p></div></div><div><div><pre><code class="language-none">sample(root::RuleNode, typ::Symbol, grammar::Grammar,
                      maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node of the given return type, typ, limited to maxdepth.</p></div></div><div><div><pre><code class="language-none">sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node in the tree no deeper than maxdepth using reservoir sampling. Returns a NodeLoc that specifies the location using its parent so that the subtree can be replaced.</p></div></div><div><div><pre><code class="language-none">sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::Grammar)</code></pre><p>Selects a uniformly random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a NodeLoc.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
