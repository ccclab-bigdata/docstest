<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Mosek</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Mosek</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"></ul></li><li><a class="toctext" href="../geco/">General Convex API</a></li><li><a class="toctext" href="../parameters/">Solver parameters</a></li><li><a class="toctext" href="../enums/">Symbolic values</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><p>This page lists all MOSEK functions available from Julia. Please note that the documentation was generated from the documentation for the MOSEK C API, so in some cases it may be slightly invalid. Specifically,</p><ul><li>Index arguments may not be displayed or documented as starting at 1 (indexes in C start at 0). Nevertheless, in the MOSEK Julia API all indexes are 1-based.</li><li>Values that are returned from functions may be documented as if they appeared in the argument list for functions.</li><li>Probably a lot of other stuff. I will be trying to improve all this when I can.</li></ul><p>For most functions there are two alternatives; one where all arguments are structly typed, and one where most arguments are untyped. The latter will convert arguments as necessary and call the former, but there appears to be a significant overhead in doing this. To improve efficiency it may be a good idea to  make sure that arguments have the correct types so the typed function is called.</p><p>For more verbose descriptions of the individual functions, it is a good idea to look at e.g. the Python documentation at <a href="http://docs.mosek.com">MOSEK docs</a>.</p><h1><a class="nav-anchor" id="Mosek.jl-Functions-1" href="#Mosek.jl-Functions-1">Mosek.jl Functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.analyzenames" href="#Mosek.analyzenames"><code>Mosek.analyzenames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">analyzenames(task_:: MSKtask,whichstream_:: Streamtype,nametype_:: Nametype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li><li><code>nametype :: Nametype</code>. The type of names e.g. valid in MPS or LP files.</li></ul><p>The function analyzes the names and issues an error if a name is invalid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.analyzeproblem" href="#Mosek.analyzeproblem"><code>Mosek.analyzeproblem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">analyzeproblem(task_:: MSKtask,whichstream_:: Streamtype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li></ul><p>The function analyzes the data of a task and writes out a report.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.analyzesolution" href="#Mosek.analyzesolution"><code>Mosek.analyzesolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">analyzesolution(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li></ul><p>Print information related to the quality of the solution and other solution statistics.</p><p>By default this function prints information about the largest infeasibilites in the solution, the primal (and possibly dual) objective value and the solution status.</p><p>Following parameters can be used to configure the printed statistics:</p><ul><li><code>MSK_IPAR_ANA_SOL_BASIS</code>` enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on.</li><li><code>MSK_IPAR_ANA_SOL_PRINT_VIOLATED</code>` enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off.</li><li><code>MSK_DPAR_ANA_SOL_INFEAS_TOL</code>` is the tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendbarvars" href="#Mosek.appendbarvars"><code>Mosek.appendbarvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendbarvars{T1}(task:: MSKtask,dim:: Vector{T1})
appendbarvars(task_:: MSKtask,dim_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>dim :: Vector{Int32}</code>. Dimensions of symmetric matrix variables to be added.</li></ul><p>Appends positive semidefinite matrix variables of dimensions given by <code>dim</code> to the problem.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendcone" href="#Mosek.appendcone"><code>Mosek.appendcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendcone{T2,T3}(task:: MSKtask,ct:: Conetype,conepar:: T2,submem:: Vector{T3})
appendcone(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>conepar :: Float64</code>. This argument is currently not used. It can be set to 0</li><li><code>submem :: Vector{Int32}</code>. Variable subscripts of the members in the cone.</li></ul><p>Appends a new conic constraint to the problem. Hence, add a constraint</p><div>\[ \hat{x} \in \mathcal{K}\]</div><p>to the problem where <span>$\mathcal{K}$</span> is a convex cone. <span>$\hat{x}$</span> is a subset of the variables which will be specified by the argument <code>submem</code>.</p><p>Depending on the value of <code>ct</code> this function appends a normal (<code>MSK_CT_QUAD</code>) or rotated quadratic cone (<code>MSK_CT_RQUAD</code>).</p><p>Define </p><div>\[ \hat{x} = x_{\mathtt{submem}[0]},\ldots,x_{\mathtt{submem}[\mathtt{nummem}-1]}.\]</div><p>Depending on the value of <code>ct</code> this function appends one of the constraints:</p><ul><li>Quadratic cone (<code>MSK_CT_QUAD</code>) : </li></ul><div>\[ \hat{x}_0 \geq \sqrt{\sum_{i=1}^{i&lt;\mathtt{nummem}} \hat{x}_i^2}\]</div><ul><li>Rotated quadratic cone (<code>MSK_CT_RQUAD</code>) : </li></ul><div>\[ 2 \hat{x}_0 \hat{x}_1 \geq \sum_{i=2}^{i&lt;\mathtt{nummem}} \hat{x}^2_i, \mathcal{C}_q \hat{x}_{0}, \hat{x}_1 \geq 0\]</div><p>Please note that the sets of variables appearing in different conic constraints must be disjoint.</p><p>For an explained code example see Section :ref:<code>doc.tutorial_cqo</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendconeseq" href="#Mosek.appendconeseq"><code>Mosek.appendconeseq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendconeseq{T2,T3,T4}(task:: MSKtask,ct:: Conetype,conepar:: T2,nummem:: T3,j:: T4)
appendconeseq(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,nummem_:: Int32,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>conepar :: Float64</code>. This argument is currently not used. It can be set to 0</li><li><code>nummem :: Int32</code>. Number of member variables in the cone.</li><li><code>j :: Int32</code>. Index of the first variable in the conic constraint.</li></ul><p>Appends a new conic constraint to the problem, as in <code>Mosek.appendcone</code>. The function assumes the members of cone are sequential where the first member has index <code>j</code> and the last <code>j+nummem-1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendconesseq" href="#Mosek.appendconesseq"><code>Mosek.appendconesseq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendconesseq{T2,T3,T4}(task:: MSKtask,ct:: Vector{Conetype},conepar:: Vector{T2},nummem:: Vector{T3},j:: T4)
appendconesseq(task_:: MSKtask,ct_:: Vector{Conetype},conepar_:: Vector{Float64},nummem_:: Vector{Int32},j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>ct :: Vector{Int32}</code>. Specifies the type of the cone.</li><li><code>conepar :: Vector{Float64}</code>. This argument is currently not used. It can be set to 0</li><li><code>nummem :: Vector{Int32}</code>. Numbers of member variables in the cones.</li><li><code>j :: Int32</code>. Index of the first variable in the first cone to be appended.</li></ul><p>Appends a number of conic constraints to the problem, as in <code>Mosek.appendcone</code>. The <span>$k$</span> th cone is assumed to be of dimension <code>nummem[k]</code>. Moreover, it is assumed that the first variable of the first cone has index <span>$j$</span> and starting from there the sequentially following variables belong to the first cone, then to the second cone and so on.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendcons" href="#Mosek.appendcons"><code>Mosek.appendcons</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendcons{T1}(task:: MSKtask,num:: T1)
appendcons(task_:: MSKtask,num_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int32</code>. Number of constraints which should be appended.</li></ul><p>Appends a number of constraints to the model. Appended constraints will be declared free. Please note that MOSEK will automatically expand the problem dimension to accommodate the additional constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendsparsesymmat" href="#Mosek.appendsparsesymmat"><code>Mosek.appendsparsesymmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">idx = appendsparsesymmat{T1,T2,T3,T4}(task:: MSKtask,dim:: T1,subi:: Vector{T2},subj:: Vector{T3},valij:: Vector{T4})
idx = appendsparsesymmat(task_:: MSKtask,dim_:: Int32,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>dim :: Int32</code>. Dimension of the symmetric matrix that is appended.</li><li><code>subi :: Vector{Int32}</code>. Row subscript in the triplets.</li><li><code>subj :: Vector{Int32}</code>. Column subscripts in the triplets.</li><li><code>valij :: Vector{Float64}</code>. Values of each triplet.</li><li><code>idx :: Int64</code>. Unique index assigned to the inputted matrix.</li></ul><p>MOSEK maintains a storage of symmetric data matrices that is used to build <span>$\bar C$</span> and <span>$\bar A$</span>. The storage can be thought of as a vector of symmetric matrices denoted <span>$E$</span>. Hence, <span>$E_i$</span> is a symmetric matrix of certain dimension.</p><p>This function appends a general sparse symmetric matrix on triplet form to the vector <span>$E$</span> of symmetric matrices.  The vectors <code>subi</code>, <code>subj</code>, and <code>valij</code> contains the row subscripts, column subscripts and values of each element in the symmetric matrix to be appended.  Since the matrix that is appended is symmetric, only the lower triangular part should be specified. Moreover, duplicates are not allowed.</p><p>Observe the function reports the index (position) of the appended matrix in <span>$E$</span>. This index should be used for later references to the appended matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.appendvars" href="#Mosek.appendvars"><code>Mosek.appendvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">appendvars{T1}(task:: MSKtask,num:: T1)
appendvars(task_:: MSKtask,num_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int32</code>. Number of variables which should be appended.</li></ul><p>Appends a number of variables to the model. Appended variables will be fixed at zero. Please note that MOSEK will automatically expand the problem dimension to accommodate the additional variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.basiscond" href="#Mosek.basiscond"><code>Mosek.basiscond</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(nrmbasis,nrminvbasis) = basiscond(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>nrmbasis :: Float64</code>. An estimate for the 1-norm of the basis.</li><li><code>nrminvbasis :: Float64</code>. An estimate for the 1-norm of the inverse of the basis.</li></ul><p>If a basic solution is available and it defines a nonsingular basis, then this function computes the 1-norm estimate of the basis matrix and a 1-norm estimate for the inverse of the basis matrix. The 1-norm estimates are computed using the method outlined in :cite:<code>STEWART:98:A</code>, pp. 388-391.</p><p>By definition the 1-norm condition number of a matrix <span>$B$</span> is defined as</p><div>\[ \kappa_1(B) := \|B\|_1 \|B^{-1}\|_1.\]</div><p>Moreover, the larger the condition number is the harder it is to solve linear equation systems involving <span>$B$</span>.  Given estimates for <span>$\|B\|_1$</span> and <span>$\|B^{-1}\|_1$</span> it is also possible to estimate <span>$\kappa_1(B)$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.bktostr" href="#Mosek.bktostr"><code>Mosek.bktostr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">str = bktostr(task_:: MSKtask,bk_:: Boundkey)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>bk :: Boundkey</code>. Bound key.</li><li><code>str :: AbstractString</code>. String corresponding to the bound key.</li></ul><p>Obtains an identifier string corresponding to a bound key.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.callbackcodetostr" href="#Mosek.callbackcodetostr"><code>Mosek.callbackcodetostr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">callbackcodestr = callbackcodetostr(code_:: Callbackcode)</code></pre><ul><li><code>code :: Callbackcode</code>. A callback code.</li><li><code>callbackcodestr :: AbstractString</code>. String corresponding to the callback code.</li></ul><p>Obtains the string representation of a callback code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.checkconvexity" href="#Mosek.checkconvexity"><code>Mosek.checkconvexity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkconvexity(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li></ul><p>This function checks if a quadratic optimization problem is convex. The amount of checking is controlled by <code>MSK_IPAR_CHECK_CONVEXITY</code>`.</p><p>The function reports an error if the problem is not convex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.checkinall" href="#Mosek.checkinall"><code>Mosek.checkinall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkinall(env_:: MSKenv)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li></ul><p>Check in all unused license features to the license token server.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.checkinlicense" href="#Mosek.checkinlicense"><code>Mosek.checkinlicense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkinlicense(env_:: MSKenv,feature_:: Feature)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>feature :: Feature</code>. Feature to check in to the license system.</li></ul><p>Check in a license feature to the license server. By default all licenses consumed by functions using a single environment are kept checked out for the lifetime of the MOSEK environment. This function checks in a given license feature back to the license server immediately.</p><p>If the given license feature is not checked out at all, or it is in use by a call to <code>Mosek.optimize</code>, calling this function has no effect.</p><p>Please note that returning a license to the license server incurs a small overhead, so frequent calls to this function should be avoided.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.checkmem" href="#Mosek.checkmem"><code>Mosek.checkmem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkmem{T2}(task:: MSKtask,file:: AbstractString,line:: T2)
checkmem(task_:: MSKtask,file_:: AbstractString,line_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>file :: String</code>. File from which the function is called.</li><li><code>line :: Int32</code>. Line in the file from which the function is called.</li></ul><p>Checks the memory allocated by the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.checkoutlicense" href="#Mosek.checkoutlicense"><code>Mosek.checkoutlicense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">checkoutlicense(env_:: MSKenv,feature_:: Feature)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>feature :: Feature</code>. Feature to check out from the license system.</li></ul><p>Checks out a license feature from the license server. Normally the required license features will be automatically checked out the first time they are needed by the function <code>Mosek.optimize</code>. This function can be used to check out one or more features ahead of time.</p><p>The feature will remain checked out until the environment is deleted or the function <code>Mosek.checkinlicense</code> is called.</p><p>If a given feature is already checked out when this function is called, the call has no effect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.chgbound" href="#Mosek.chgbound"><code>Mosek.chgbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chgbound{T2,T3,T4,T5}(task:: MSKtask,accmode:: Accmode,i:: T2,lower:: T3,finite:: T4,value:: T5)
chgbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</li><li><code>i :: Int32</code>. Index of the constraint or variable for which the bounds should be changed.</li><li><code>lower :: Int32</code>. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.</li><li><code>finite :: Int32</code>. If non-zero, then the given value is assumed to be finite.</li><li><code>value :: Float64</code>. New value for the bound.</li></ul><p>Changes a bound for one constraint or variable. If <code>accmode</code> equals <code>MSK_ACC_CON</code>, a constraint bound is changed, otherwise a variable bound is changed.</p><p>If <code>lower</code> is non-zero, then the lower bound is changed as follows:</p><div>\[\mbox{new lower bound} =
    \left\{
        \begin{array}{ll}
            - \infty,     &amp; \mathtt{finite}=0, \\
            \mathtt{value} &amp; \mbox{otherwise}. 
        \end{array}
    \right.\]</div><p>Otherwise if <code>lower</code> is zero, then</p><div>\[\mbox{new upper bound} = 
    \left\{ 
        \begin{array}{ll}
            \infty,     &amp; \mathtt{finite}=0, \\
            \mathtt{value} &amp; \mbox{otherwise}. 
        \end{array}
    \right.\]</div><p>Please note that this function automatically updates the bound key for bound, in particular, if the lower and upper bounds are identical, the bound key is changed to <code>fixed</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.chgconbound" href="#Mosek.chgconbound"><code>Mosek.chgconbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chgconbound{T1,T2,T3,T4}(task:: MSKtask,i:: T1,lower:: T2,finite:: T3,value:: T4)
chgconbound(task_:: MSKtask,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint for which the bounds should be changed.</li><li><code>lower :: Int32</code>. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.</li><li><code>finite :: Int32</code>. If non-zero, then the given value is assumed to be finite.</li><li><code>value :: Float64</code>. New value for the bound.</li></ul><p>Changes a bound for one constraint.</p><p>If <code>lower</code> is non-zero, then the lower bound is changed as follows:</p><div>\[\mbox{new lower bound} =
  \left\{
    \begin{array}{ll}
      - \infty,       &amp; \mathtt{finite}=0, \\
      \mathtt{value}  &amp; \mbox{otherwise}. 
    \end{array}
  \right.\]</div><p>Otherwise if <code>lower</code> is zero, then</p><div>\[\mbox{new upper bound} = 
  \left\{
    \begin{array}{ll}
      \infty,        &amp; \mathtt{finite}=0, \\
      \mathtt{value} &amp; \mbox{otherwise}. 
    \end{array}
  \right.\]</div><p>Please note that this function automatically updates the bound key for the  bound, in particular, if the lower and upper bounds are identical, the bound key is changed to <code>fixed</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.chgvarbound" href="#Mosek.chgvarbound"><code>Mosek.chgvarbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chgvarbound{T1,T2,T3,T4}(task:: MSKtask,j:: T1,lower:: T2,finite:: T3,value:: T4)
chgvarbound(task_:: MSKtask,j_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable for which the bounds should be changed.</li><li><code>lower :: Int32</code>. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.</li><li><code>finite :: Int32</code>. If non-zero, then the given value is assumed to be finite.</li><li><code>value :: Float64</code>. New value for the bound.</li></ul><p>Changes a bound for one variable.</p><p>If <code>lower</code> is non-zero, then the lower bound is changed as follows:</p><div>\[\mbox{new lower bound} =
  \left\{
    \begin{array}{ll}
      - \infty,     &amp; \mathtt{finite}=0, \\
      \mathtt{value} &amp; \mbox{otherwise}. 
    \end{array}
  \right.\]</div><p>Otherwise if <code>lower</code> is zero, then</p><div>\[\mbox{new upper bound} = 
  \left\{
    \begin{array}{ll}
      \infty,     &amp; \mathtt{finite}=0, \\
      \mathtt{value} &amp; \mbox{otherwise}. 
    \end{array}
  \right.\]</div><p>Please note that this function automatically updates the bound key for the bound, in particular, if the lower and upper bounds are identical, the bound key is changed to <code>fixed</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.commitchanges" href="#Mosek.commitchanges"><code>Mosek.commitchanges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">commitchanges(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li></ul><p>Commits all cached problem changes to the task. It is usually not necessary to call this function explicitly since changes will be committed automatically when required.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.conetypetostr" href="#Mosek.conetypetostr"><code>Mosek.conetypetostr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">str = conetypetostr(task_:: MSKtask,ct_:: Conetype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>str :: AbstractString</code>. String corresponding to the cone type.</li></ul><p>Obtains the cone string identifier corresponding to a cone type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.deletesolution" href="#Mosek.deletesolution"><code>Mosek.deletesolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deletesolution(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li></ul><p>Undefine a solution and free the memory it uses.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.dualsensitivity" href="#Mosek.dualsensitivity"><code>Mosek.dualsensitivity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity{T1}(task:: MSKtask,subj:: Vector{T1})
(leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity(task_:: MSKtask,subj_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subj :: Vector{Int32}</code>. Indexes of objective coefficients to analyze.</li><li><code>leftpricej :: Vector{Float64}</code>. Left shadow prices for requested coefficients.</li><li><code>rightpricej :: Vector{Float64}</code>. Right shadow prices for requested coefficients.</li><li><code>leftrangej :: Vector{Float64}</code>. Left range for requested coefficients.</li><li><code>rightrangej :: Vector{Float64}</code>. Right range for requested coefficients.</li></ul><p>Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are</p><div>\[ \{\mathtt{subj}[i] ~|~ i = 0,\ldots,\mathtt{numj}-1\}\]</div><p>The type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter <code>MSK_IPAR_SENSITIVITY_TYPE</code>`.</p><p>For an example, please see Section :ref:<code>doc.shared.sensitivity_example</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.echointro" href="#Mosek.echointro"><code>Mosek.echointro</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">echointro{T1}(env:: MSKenv,longver:: T1)
echointro(env_:: MSKenv,longver_:: Int32)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>longver :: Int32</code>. If non-zero, then the intro is slightly longer.</li></ul><p>Prints an intro to message stream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getacol" href="#Mosek.getacol"><code>Mosek.getacol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(nzj,subj,valj) = getacol{T1}(task:: MSKtask,j:: T1)
(nzj,subj,valj) = getacol(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the column.</li><li><code>nzj :: Int32</code>. Number of non-zeros in the column obtained.</li><li><code>subj :: Vector{Int32}</code>. Row indices of the non-zeros in the column obtained.</li><li><code>valj :: Vector{Float64}</code>. Numerical values in the column obtained.</li></ul><p>Obtains one column of <span>$A$</span> in a sparse format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getacolnumnz" href="#Mosek.getacolnumnz"><code>Mosek.getacolnumnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzj = getacolnumnz{T1}(task:: MSKtask,i:: T1)
nzj = getacolnumnz(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the column.</li><li><code>nzj :: Int32</code>. Number of non-zeros in the j&#39;th column of (A).</li></ul><p>Obtains the number of non-zero elements in one column of <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getacolslicetrip" href="#Mosek.getacolslicetrip"><code>Mosek.getacolslicetrip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(subi,subj,val) = getacolslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
(subi,subj,val) = getacolslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. Index of the first column in the sequence.</li><li><code>last :: Int32</code>. Index of the last column in the sequence plus one.</li><li><code>subi :: Vector{Int32}</code>. Constraint subscripts.</li><li><code>subj :: Vector{Int32}</code>. Column subscripts.</li><li><code>val :: Vector{Float64}</code>. Values.</li></ul><p>Obtains a sequence of columns from <span>$A$</span> in sparse triplet format. The function returns the content of all columns whose index <code>j</code> satisfies <code>first &lt;= j &lt; last</code>. The triplets corresponding to nonzero entries are stored in the arrays <code>subi</code>, <code>subj</code> and <code>val</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getaij" href="#Mosek.getaij"><code>Mosek.getaij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">aij = getaij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
aij = getaij(task_:: MSKtask,i_:: Int32,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Row index of the coefficient to be returned.</li><li><code>j :: Int32</code>. Column index of the coefficient to be returned.</li><li><code>aij :: Float64</code>. Returns the requested coefficient.</li></ul><p>Obtains a single coefficient in <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getapiecenumnz" href="#Mosek.getapiecenumnz"><code>Mosek.getapiecenumnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numnz = getapiecenumnz{T1,T2,T3,T4}(task:: MSKtask,firsti:: T1,lasti:: T2,firstj:: T3,lastj:: T4)
numnz = getapiecenumnz(task_:: MSKtask,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>firsti :: Int32</code>. Index of the first row in the rectangular piece.</li><li><code>lasti :: Int32</code>. Index of the last row plus one in the rectangular piece.</li><li><code>firstj :: Int32</code>. Index of the first column in the rectangular piece.</li><li><code>lastj :: Int32</code>. Index of the last column plus one in the rectangular piece.</li><li><code>numnz :: Int32</code>. Number of non-zero elements in the rectangular piece of the linear constraint matrix.</li></ul><p>Obtains the number non-zeros in a rectangular piece of <span>$A$</span>, i.e. the number of elements in the set</p><div>\[ \{ (i,j)~:~ a_{i,j} \neq 0,~ \mathtt{firsti} \leq i \leq \mathtt{lasti}-1, ~\mathtt{firstj} \leq j \leq \mathtt{lastj}-1\}\]</div><p>This function is not an efficient way to obtain the number of non-zeros in one row or column. In that case use the function <code>Mosek.getarownumnz</code> or <code>Mosek.getacolnumnz</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getarow" href="#Mosek.getarow"><code>Mosek.getarow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(nzi,subi,vali) = getarow{T1}(task:: MSKtask,i:: T1)
(nzi,subi,vali) = getarow(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the row.</li><li><code>nzi :: Int32</code>. Number of non-zeros in the row obtained.</li><li><code>subi :: Vector{Int32}</code>. Column indices of the non-zeros in the row obtained.</li><li><code>vali :: Vector{Float64}</code>. Numerical values of the row obtained.</li></ul><p>Obtains one row of <span>$A$</span> in a sparse format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getarownumnz" href="#Mosek.getarownumnz"><code>Mosek.getarownumnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nzi = getarownumnz{T1}(task:: MSKtask,i:: T1)
nzi = getarownumnz(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the row.</li><li><code>nzi :: Int32</code>. Number of non-zeros in the i&#39;th row of <code>A</code>.</li></ul><p>Obtains the number of non-zero elements in one row of <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getarowslicetrip" href="#Mosek.getarowslicetrip"><code>Mosek.getarowslicetrip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(subi,subj,val) = getarowslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
(subi,subj,val) = getarowslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. Index of the first row in the sequence.</li><li><code>last :: Int32</code>. Index of the last row in the sequence plus one.</li><li><code>subi :: Vector{Int32}</code>. Constraint subscripts.</li><li><code>subj :: Vector{Int32}</code>. Column subscripts.</li><li><code>val :: Vector{Float64}</code>. Values.</li></ul><p>Obtains a sequence of rows from <span>$A$</span> in sparse triplet format. The function returns the content of all rows whose index <code>i</code> satisfies <code>first &lt;= i &lt; last</code>.  The triplets corresponding to nonzero entries are stored in the arrays <code>subi</code>, <code>subj</code> and <code>val</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getaslice" href="#Mosek.getaslice"><code>Mosek.getaslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(ptrb,ptre,sub,val) = getaslice{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
(ptrb,ptre,sub,val) = getaslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether a column slice or a row slice is requested.</li><li><code>first :: Int32</code>. Index of the first row or column in the sequence.</li><li><code>last :: Int32</code>. Index of the last row or column in the sequence plus one.</li><li><code>ptrb :: Vector{Int64}</code>. Row or column start pointers.</li><li><code>ptre :: Vector{Int64}</code>. Row or column end pointers.</li><li><code>sub :: Vector{Int32}</code>. Contains the row or column subscripts.</li><li><code>val :: Vector{Float64}</code>. Contains the coefficient values.</li></ul><p>Obtains a sequence of rows or columns from <span>$A$</span> in sparse format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getaslicenumnz" href="#Mosek.getaslicenumnz"><code>Mosek.getaslicenumnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numnz = getaslicenumnz{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
numnz = getaslicenumnz(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether non-zeros are counted in a column slice or a row slice.</li><li><code>first :: Int32</code>. Index of the first row or column in the sequence.</li><li><code>last :: Int32</code>. Index of the last row or column plus one in the sequence.</li><li><code>numnz :: Int64</code>. Number of non-zeros in the slice.</li></ul><p>Obtains the number of non-zeros in a slice of rows or columns of <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarablocktriplet" href="#Mosek.getbarablocktriplet"><code>Mosek.getbarablocktriplet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(num,subi,subj,subk,subl,valijkl) = getbarablocktriplet(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. Number of elements in the block triplet form.</li><li><code>subi :: Vector{Int32}</code>. Constraint index.</li><li><code>subj :: Vector{Int32}</code>. Symmetric matrix variable index.</li><li><code>subk :: Vector{Int32}</code>. Block row index.</li><li><code>subl :: Vector{Int32}</code>. Block column index.</li><li><code>valijkl :: Vector{Float64}</code>. The numerical value associated with each block triplet.</li></ul><p>Obtains <span>$\bar A$</span> in block triplet form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbaraidx" href="#Mosek.getbaraidx"><code>Mosek.getbaraidx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(i,j,num,sub,weights) = getbaraidx{T1}(task:: MSKtask,idx:: T1)
(i,j,num,sub,weights) = getbaraidx(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Position of the element in the vectorized form.</li><li><code>i :: Int32</code>. Row index of the element at position idx.</li><li><code>j :: Int32</code>. Column index of the element at position idx.</li><li><code>num :: Int64</code>. Number of terms in weighted sum that forms the element.</li><li><code>sub :: Vector{Int64}</code>. A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.</li><li><code>weights :: Vector{Float64}</code>. The weights associated with each term in the weighted sum.</li></ul><p>Obtains information about an element in <span>$\bar A$</span>. Since <span>$\bar A$</span> is a sparse matrix of symmetric matrices, only the nonzero elements in <span>$\bar A$</span> are stored in order to save space. Now <span>$\bar A$</span> is stored vectorized i.e. as one long vector. This function makes it possible to obtain information such as the row index and the column index of a particular element of the vectorized form of <span>$\bar A$</span>.</p><p>Please observe if one element of <span>$\bar A$</span> is inputted multiple times then it may be stored several times in vectorized form. In that case the element with the highest index is the one that is used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbaraidxij" href="#Mosek.getbaraidxij"><code>Mosek.getbaraidxij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(i,j) = getbaraidxij{T1}(task:: MSKtask,idx:: T1)
(i,j) = getbaraidxij(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Position of the element in the vectorized form.</li><li><code>i :: Int32</code>. Row index of the element at position idx.</li><li><code>j :: Int32</code>. Column index of the element at position idx.</li></ul><p>Obtains information about an element in <span>$\bar A$</span>. Since <span>$\bar A$</span> is a sparse matrix of symmetric matrices, only the nonzero elements in <span>$\bar A$</span> are stored in order to save space. Now <span>$\bar A$</span> is stored vectorized i.e. as one long vector.  This function makes it possible to obtain information such as the row index and the column index of a particular element of the vectorized form of <span>$\bar A$</span>.</p><p>Please note that if one element of <span>$\bar A$</span> is inputted multiple times then it may be stored several times in vectorized form. In that case the element with the highest index is the one that is used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbaraidxinfo" href="#Mosek.getbaraidxinfo"><code>Mosek.getbaraidxinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num = getbaraidxinfo{T1}(task:: MSKtask,idx:: T1)
num = getbaraidxinfo(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. The internal position of the element for which information should be obtained.</li><li><code>num :: Int64</code>. Number of terms in the weighted sum that form the specified element in barA.</li></ul><p>Each nonzero element in <span>$\bar A_{ij}$</span> is formed as a weighted sum of symmetric matrices. Using this function the number of terms in the weighted sum can be obtained. See description of <code>Mosek.appendsparsesymmat</code> for details about the weighted sum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarasparsity" href="#Mosek.getbarasparsity"><code>Mosek.getbarasparsity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(numnz,idxij) = getbarasparsity(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numnz :: Int64</code>. Number of nonzero elements in barA.</li><li><code>idxij :: Vector{Int64}</code>. Position of each nonzero element in the vector representation of barA.</li></ul><p>The matrix <span>$\bar A$</span> is assumed to be a sparse matrix of symmetric matrices. This implies that many of the elements in <span>$\bar A$</span> are likely to be zero matrices. Therefore, in order to save space, only nonzero elements in <span>$\bar A$</span> are stored on vectorized form. This function is used to obtain the sparsity pattern of <span>$\bar A$</span> and the position of each nonzero element in the vectorized form of <span>$\bar A$</span>. From the index detailed information about each nonzero <span>$\bar A_{i,j}$</span> can be obtained using <code>Mosek.getbaraidxinfo</code> and <code>Mosek.getbaraidx</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarcblocktriplet" href="#Mosek.getbarcblocktriplet"><code>Mosek.getbarcblocktriplet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(num,subj,subk,subl,valjkl) = getbarcblocktriplet(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. Number of elements in the block triplet form.</li><li><code>subj :: Vector{Int32}</code>. Symmetric matrix variable index.</li><li><code>subk :: Vector{Int32}</code>. Block row index.</li><li><code>subl :: Vector{Int32}</code>. Block column index.</li><li><code>valjkl :: Vector{Float64}</code>. The numerical value associated with each block triplet.</li></ul><p>Obtains <span>$\bar C$</span> in block triplet form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarcidx" href="#Mosek.getbarcidx"><code>Mosek.getbarcidx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(j,num,sub,weights) = getbarcidx{T1}(task:: MSKtask,idx:: T1)
(j,num,sub,weights) = getbarcidx(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Index of the element for which information should be obtained.</li><li><code>j :: Int32</code>. Row index in barc.</li><li><code>num :: Int64</code>. Number of terms in the weighted sum.</li><li><code>sub :: Vector{Int64}</code>. Elements appearing the weighted sum.</li><li><code>weights :: Vector{Float64}</code>. Weights of terms in the weighted sum.</li></ul><p>Obtains information about an element in <span>$\bar C$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarcidxinfo" href="#Mosek.getbarcidxinfo"><code>Mosek.getbarcidxinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num = getbarcidxinfo{T1}(task:: MSKtask,idx:: T1)
num = getbarcidxinfo(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.</li><li><code>num :: Int64</code>. Number of terms that appear in the weighted sum that forms the requested element.</li></ul><p>Obtains the number of terms in the weighted sum that forms a particular element in <span>$\bar C$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarcidxj" href="#Mosek.getbarcidxj"><code>Mosek.getbarcidxj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">j = getbarcidxj{T1}(task:: MSKtask,idx:: T1)
j = getbarcidxj(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Index of the element for which information should be obtained.</li><li><code>j :: Int32</code>. Row index in barc.</li></ul><p>Obtains the row index of an element in <span>$\bar C$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarcsparsity" href="#Mosek.getbarcsparsity"><code>Mosek.getbarcsparsity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(numnz,idxj) = getbarcsparsity(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numnz :: Int64</code>. Number of nonzero elements in barc.</li><li><code>idxj :: Vector{Int64}</code>. Internal positions of the nonzeros elements in barc.</li></ul><p>Internally only the nonzero elements of <span>$\bar C$</span> are stored  in a vector. This function is used to obtain the nonzero elements of <span>$\bar C$</span> and their indexes in the internal vector representation (in <code>idx</code>). From the index detailed information about each nonzero <span>$\bar C_j$</span> can be obtained using <code>Mosek.getbarcidxinfo</code> and <code>Mosek.getbarcidx</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarsj" href="#Mosek.getbarsj"><code>Mosek.getbarsj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barsj = getbarsj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
barsj = getbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>j :: Int32</code>. Index of the semidefinite variable.</li><li><code>barsj :: Vector{Float64}</code>. Value of the j&#39;th dual variable of barx.</li></ul><p>Obtains the dual solution for a semidefinite variable. Only the lower triangular part of <span>$\bar S_j$</span> is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarvarname" href="#Mosek.getbarvarname"><code>Mosek.getbarvarname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name = getbarvarname{T1}(task:: MSKtask,i:: T1)
name = getbarvarname(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the variable.</li><li><code>name :: AbstractString</code>. The requested name is copied to this buffer.</li></ul><p>Obtains the name of a semidefinite variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarvarnameindex" href="#Mosek.getbarvarnameindex"><code>Mosek.getbarvarnameindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(asgn,index) = getbarvarnameindex(task_:: MSKtask,somename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>somename :: String</code>. The name of the variable.</li><li><code>asgn :: Int32</code>. Non-zero if the name somename is assigned to some semidefinite variable.</li><li><code>index :: Int32</code>. The index of a semidefinite variable with the name somename (if one exists).</li></ul><p>Obtains the index of semidefinite variable from its name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarvarnamelen" href="#Mosek.getbarvarnamelen"><code>Mosek.getbarvarnamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getbarvarnamelen{T1}(task:: MSKtask,i:: T1)
len = getbarvarnamelen(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the variable.</li><li><code>len :: Int32</code>. Returns the length of the indicated name.</li></ul><p>Obtains the length of the name of a semidefinite variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbarxj" href="#Mosek.getbarxj"><code>Mosek.getbarxj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">barxj = getbarxj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
barxj = getbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>j :: Int32</code>. Index of the semidefinite variable.</li><li><code>barxj :: Vector{Float64}</code>. Value of the j&#39;th variable of barx.</li></ul><p>Obtains the primal solution for a semidefinite variable. Only the lower triangular part of <span>$\bar X_j$</span> is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getbound" href="#Mosek.getbound"><code>Mosek.getbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getbound{T2}(task:: MSKtask,accmode:: Accmode,i:: T2)
(bk,bl,bu) = getbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</li><li><code>i :: Int32</code>. Index of the constraint or variable for which the bound information should be obtained.</li><li><code>bk :: Boundkey</code>. Bound keys.</li><li><code>bl :: Float64</code>. Values for lower bounds.</li><li><code>bu :: Float64</code>. Values for upper bounds.</li></ul><p>Obtains bound information for one constraint or variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getboundslice" href="#Mosek.getboundslice"><code>Mosek.getboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getboundslice{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
(bk,bl,bu) = getboundslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Boundkey}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Obtains bounds information for a slice of variables or constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getc" href="#Mosek.getc"><code>Mosek.getc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">c = getc(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>c :: Vector{Float64}</code>. Linear terms of the objective as a dense vector. The length is the number of variables.</li></ul><p>Obtains all objective coefficients <span>$c$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getcfix" href="#Mosek.getcfix"><code>Mosek.getcfix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cfix = getcfix(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>cfix :: Float64</code>. Fixed term in the objective.</li></ul><p>Obtains the fixed term in the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getcj" href="#Mosek.getcj"><code>Mosek.getcj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cj = getcj{T1}(task:: MSKtask,j:: T1)
cj = getcj(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable for which the c coefficient should be obtained.</li><li><code>cj :: Float64</code>. The c coefficient value.</li></ul><p>Obtains one coefficient of <span>$c$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getcodedesc" href="#Mosek.getcodedesc"><code>Mosek.getcodedesc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(symname,str) = getcodedesc(code_:: Rescode)</code></pre><ul><li><code>code :: Rescode</code>. A valid response code.</li><li><code>symname :: AbstractString</code>. Symbolic name corresponding to the code.</li><li><code>str :: AbstractString</code>. Obtains a short description of a response code.</li></ul><p>Obtains a short description of the meaning of the response code given by <code>code</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconbound" href="#Mosek.getconbound"><code>Mosek.getconbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getconbound{T1}(task:: MSKtask,i:: T1)
(bk,bl,bu) = getconbound(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint for which the bound information should be obtained.</li><li><code>bk :: Boundkey</code>. Bound keys.</li><li><code>bl :: Float64</code>. Values for lower bounds.</li><li><code>bu :: Float64</code>. Values for upper bounds.</li></ul><p>Obtains bound information for one constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconboundslice" href="#Mosek.getconboundslice"><code>Mosek.getconboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getconboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
(bk,bl,bu) = getconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Boundkey}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Obtains bounds information for a slice of the constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getcone" href="#Mosek.getcone"><code>Mosek.getcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(ct,conepar,nummem,submem) = getcone{T1}(task:: MSKtask,k:: T1)
(ct,conepar,nummem,submem) = getcone(task_:: MSKtask,k_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Index of the cone.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>conepar :: Float64</code>. This argument is currently not used. It can be set to 0</li><li><code>nummem :: Int32</code>. Number of member variables in the cone.</li><li><code>submem :: Vector{Int32}</code>. Variable subscripts of the members in the cone.</li></ul><p>Obtains a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconeinfo" href="#Mosek.getconeinfo"><code>Mosek.getconeinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(ct,conepar,nummem) = getconeinfo{T1}(task:: MSKtask,k:: T1)
(ct,conepar,nummem) = getconeinfo(task_:: MSKtask,k_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Index of the cone.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>conepar :: Float64</code>. This argument is currently not used. It can be set to 0</li><li><code>nummem :: Int32</code>. Number of member variables in the cone.</li></ul><p>Obtains information about a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconename" href="#Mosek.getconename"><code>Mosek.getconename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name = getconename{T1}(task:: MSKtask,i:: T1)
name = getconename(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the cone.</li><li><code>name :: AbstractString</code>. The required name.</li></ul><p>Obtains the name of a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconenameindex" href="#Mosek.getconenameindex"><code>Mosek.getconenameindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(asgn,index) = getconenameindex(task_:: MSKtask,somename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>somename :: String</code>. The name which should be checked.</li><li><code>asgn :: Int32</code>. Is non-zero if the name somename is assigned to some cone.</li><li><code>index :: Int32</code>. If the name somename is assigned to some cone, this is the index of the cone.</li></ul><p>Checks whether the name <code>somename</code> has been assigned to any cone. If it has been assigned to a cone, then the index of the cone is reported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconenamelen" href="#Mosek.getconenamelen"><code>Mosek.getconenamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getconenamelen{T1}(task:: MSKtask,i:: T1)
len = getconenamelen(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the cone.</li><li><code>len :: Int32</code>. Returns the length of the indicated name.</li></ul><p>Obtains the length of the name of a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconname" href="#Mosek.getconname"><code>Mosek.getconname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name = getconname{T1}(task:: MSKtask,i:: T1)
name = getconname(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint.</li><li><code>name :: AbstractString</code>. The required name.</li></ul><p>Obtains the name of a constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconnameindex" href="#Mosek.getconnameindex"><code>Mosek.getconnameindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(asgn,index) = getconnameindex(task_:: MSKtask,somename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>somename :: String</code>. The name which should be checked.</li><li><code>asgn :: Int32</code>. Is non-zero if the name somename is assigned to some constraint.</li><li><code>index :: Int32</code>. If the name somename is assigned to a constraint, then return the index of the constraint.</li></ul><p>Checks whether the name <code>somename</code> has been assigned to any constraint. If so, the index of the constraint is reported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getconnamelen" href="#Mosek.getconnamelen"><code>Mosek.getconnamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getconnamelen{T1}(task:: MSKtask,i:: T1)
len = getconnamelen(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint.</li><li><code>len :: Int32</code>. Returns the length of the indicated name.</li></ul><p>Obtains the length of the name of a constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getcslice" href="#Mosek.getcslice"><code>Mosek.getcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">c = getcslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
c = getcslice(task_:: MSKtask,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>c :: Vector{Float64}</code>. Linear terms of the requested slice of the objective as a dense vector.</li></ul><p>Obtains a sequence of elements in <span>$c$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdimbarvarj" href="#Mosek.getdimbarvarj"><code>Mosek.getdimbarvarj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dimbarvarj = getdimbarvarj{T1}(task:: MSKtask,j:: T1)
dimbarvarj = getdimbarvarj(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the semidefinite variable whose dimension is requested.</li><li><code>dimbarvarj :: Int32</code>. The dimension of the j&#39;th semidefinite variable.</li></ul><p>Obtains the dimension of a symmetric matrix variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdouinf" href="#Mosek.getdouinf"><code>Mosek.getdouinf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dvalue = getdouinf(task_:: MSKtask,whichdinf_:: Dinfitem)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichdinf :: Dinfitem</code>. Specifies a double information item.</li><li><code>dvalue :: Float64</code>. The value of the required double information item.</li></ul><p>Obtains a double information item from the task information database.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdouparam" href="#Mosek.getdouparam"><code>Mosek.getdouparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parvalue = getdouparam(task_:: MSKtask,param_:: Dparam)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Dparam</code>. Which parameter.</li><li><code>parvalue :: Float64</code>. Parameter value.</li></ul><p>Obtains the value of a double parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdualobj" href="#Mosek.getdualobj"><code>Mosek.getdualobj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dualobj = getdualobj(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>dualobj :: Float64</code>. Objective value corresponding to the dual solution.</li></ul><p>Computes the dual objective value associated with the solution. Note that if the solution is a primal infeasibility certificate, then the fixed term in the objective value is not included. </p><p>Moreover, since there is no dual solution associated with an integer solution, an error will be reported if the dual objective value is requested for the integer solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdualsolutionnorms" href="#Mosek.getdualsolutionnorms"><code>Mosek.getdualsolutionnorms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars) = getdualsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>nrmy :: Float64</code>. The norm of the y vector.</li><li><code>nrmslc :: Float64</code>. The norm of the slc vector.</li><li><code>nrmsuc :: Float64</code>. The norm of the suc vector.</li><li><code>nrmslx :: Float64</code>. The norm of the slx vector.</li><li><code>nrmsux :: Float64</code>. The norm of the sux vector.</li><li><code>nrmsnx :: Float64</code>. The norm of the snx vector.</li><li><code>nrmbars :: Float64</code>. The norm of the bars vector.</li></ul><p>Compute norms of the dual solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdviolbarvar" href="#Mosek.getdviolbarvar"><code>Mosek.getdviolbarvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getdviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getdviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of barx variables.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Let <span>$(\bar S_j)^*$</span> be the value of variable <span>$\bar S_j$</span> for the specified solution.  Then the dual violation of the solution associated with variable <span>$\bar S_j$</span> is given by</p><div>\[ \max(-\lambda_{\min}(\bar S_j),\ 0.0).\]</div><p>Both when the solution is a certificate of primal infeasibility and when it is dual feasible solution the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdviolcon" href="#Mosek.getdviolcon"><code>Mosek.getdviolcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getdviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getdviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of constraints.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>The violation of the dual solution associated with the <span>$i$</span>-th constraint is computed as follows</p><div>\[ \max( \rho( (s_l^c)_i^*,(b_l^c)_i ),\ \rho( (s_u^c)_i^*, -(b_u^c)_i ),\ |-y_i+(s_l^c)_i^*-(s_u^c)_i^*| )\]</div><p>where</p><div>\[\rho(x,l) =
  \left\{
    \begin{array}{ll}
       -x,   &amp; l &gt; -\infty , \\
       |x|, &amp;  \mbox{otherwise}.\\
    \end{array}
  \right.\]</div><p>Both when the solution is a certificate of primal infeasibility or it is a dual feasible solution the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdviolcones" href="#Mosek.getdviolcones"><code>Mosek.getdviolcones</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getdviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getdviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of conic constraints.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Let <span>$(s_n^x)^*$</span> be the value of variable <span>$(s_n^x)$</span> for the specified solution. For simplicity let us assume that <span>$s_n^x$</span> is a member of a quadratic cone, then the violation is computed as follows</p><div>\[\left\{
  \begin{array}{ll}
    \max(0,(\|s_n^x\|_{2:n}^*-(s_n^x)_1^*) / \sqrt{2}, &amp; (s_n^x)^* \geq -\|(s_n^x)_{2:n}^*\|, \\
    \|(s_n^x)^*\|, &amp; \mbox{otherwise.}
  \end{array}
\right.\]</div><p>Both when the solution is a certificate of primal infeasibility or when it is a dual feasible solution the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getdviolvar" href="#Mosek.getdviolvar"><code>Mosek.getdviolvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getdviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getdviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of x variables.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>The violation of the dual solution associated with the <span>$j$</span>-th variable is computed as follows</p><div>\[ \max \left(\rho((s_l^x)_j^*,(b_l^x)_j),\ \rho((s_u^x)_j^*,-(b_u^x)_j),\ |\sum_{i=1}^{+1{numcon}} a_{ij} y_i+(s_l^x)_j^*-(s_u^x)_j^* - \tau c_j| \right)\]</div><p>where</p><div>\[\rho(x,l) =
  \left\{
    \begin{array}{ll}
       -x,   &amp; l &gt; -\infty , \\
       |x|, &amp;  \mbox{otherwise}
    \end{array}
  \right.\]</div><p>and <span>$\tau=0$</span> if the solution is a certificate of primal infeasibility and <span>$\tau=1$</span> otherwise. The formula for computing the violation is only shown for the linear case but is generalized appropriately for the more general problems. Both when the solution is a certificate of primal infeasibility or when it is a dual feasible solution the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getinfeasiblesubproblem" href="#Mosek.getinfeasiblesubproblem"><code>Mosek.getinfeasiblesubproblem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inftask = getinfeasiblesubproblem(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Which solution to use when determining the infeasible subproblem.</li><li><code>inftask :: MSKtask</code>. A new task containing the infeasible subproblem.</li></ul><p>Given the solution is a certificate of primal or dual infeasibility then a primal or dual infeasible subproblem is obtained respectively.  The subproblem tends to be much smaller than the original problem and hence it is easier to locate the infeasibility inspecting the subproblem than the original problem.</p><p>For the procedure to be useful it is important to assign meaningful names to constraints, variables etc. in the original task because those names will be duplicated in the subproblem.</p><p>The function is only applicable to linear and conic quadratic optimization problems.</p><p>For more information see Section :ref:<code>doc.shared.feas_repair</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getinfname" href="#Mosek.getinfname"><code>Mosek.getinfname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">infname = getinfname{T2}(task:: MSKtask,inftype:: Inftype,whichinf:: T2)
infname = getinfname(task_:: MSKtask,inftype_:: Inftype,whichinf_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>inftype :: Inftype</code>. Type of the information item.</li><li><code>whichinf :: Int32</code>. An information item.</li><li><code>infname :: AbstractString</code>. Name of the information item.</li></ul><p>Obtains the name of an information item.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getintinf" href="#Mosek.getintinf"><code>Mosek.getintinf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ivalue = getintinf(task_:: MSKtask,whichiinf_:: Iinfitem)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichiinf :: Iinfitem</code>. Specifies an integer information item.</li><li><code>ivalue :: Int32</code>. The value of the required integer information item.</li></ul><p>Obtains an integer information item from the task information database.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getintparam" href="#Mosek.getintparam"><code>Mosek.getintparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parvalue = getintparam(task_:: MSKtask,param_:: Iparam)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Iparam</code>. Which parameter.</li><li><code>parvalue :: Int32</code>. Parameter value.</li></ul><p>Obtains the value of an integer parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getlenbarvarj" href="#Mosek.getlenbarvarj"><code>Mosek.getlenbarvarj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lenbarvarj = getlenbarvarj{T1}(task:: MSKtask,j:: T1)
lenbarvarj = getlenbarvarj(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the semidefinite variable whose length if requested.</li><li><code>lenbarvarj :: Int64</code>. Number of scalar elements in the lower triangular part of the semidefinite variable.</li></ul><p>Obtains the length of the <span>$j$</span>-th semidefinite variable i.e. the number of elements in the lower triangular part.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getlintinf" href="#Mosek.getlintinf"><code>Mosek.getlintinf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ivalue = getlintinf(task_:: MSKtask,whichliinf_:: Liinfitem)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichliinf :: Liinfitem</code>. Specifies a long information item.</li><li><code>ivalue :: Int64</code>. The value of the required long integer information item.</li></ul><p>Obtains a long integer information item from the task information database.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumanz" href="#Mosek.getmaxnumanz"><code>Mosek.getmaxnumanz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumanz = getmaxnumanz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumanz :: Int64</code>. Number of preallocated non-zero linear matrix elements.</li></ul><p>Obtains number of preallocated non-zeros in <span>$A$</span>. When this number of non-zeros is reached MOSEK will automatically allocate more space for <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumbarvar" href="#Mosek.getmaxnumbarvar"><code>Mosek.getmaxnumbarvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumbarvar = getmaxnumbarvar(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumbarvar :: Int32</code>. Maximum number of symmetric matrix variables for which space is currently preallocated.</li></ul><p>Obtains maximum number of symmetric matrix variables for which space is currently preallocated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumcon" href="#Mosek.getmaxnumcon"><code>Mosek.getmaxnumcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumcon = getmaxnumcon(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcon :: Int32</code>. Number of preallocated constraints in the optimization task.</li></ul><p>Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumcone" href="#Mosek.getmaxnumcone"><code>Mosek.getmaxnumcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumcone = getmaxnumcone(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcone :: Int32</code>. Number of preallocated conic constraints in the optimization task.</li></ul><p>Obtains the number of preallocated cones in the optimization task. When this number of cones is reached MOSEK will automatically allocate space for more cones.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumqnz" href="#Mosek.getmaxnumqnz"><code>Mosek.getmaxnumqnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumqnz = getmaxnumqnz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumqnz :: Int64</code>. Number of non-zero elements preallocated in quadratic coefficient matrices.</li></ul><p>Obtains the number of preallocated non-zeros for <span>$Q$</span> (both objective and constraints). When this number of non-zeros is reached MOSEK will automatically allocate more space for <span>$Q$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmaxnumvar" href="#Mosek.getmaxnumvar"><code>Mosek.getmaxnumvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxnumvar = getmaxnumvar(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumvar :: Int32</code>. Number of preallocated variables in the optimization task.</li></ul><p>Obtains the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getmemusage" href="#Mosek.getmemusage"><code>Mosek.getmemusage</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(meminuse,maxmemuse) = getmemusage(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>meminuse :: Int64</code>. Amount of memory currently used by the task.</li><li><code>maxmemuse :: Int64</code>. Maximum amount of memory used by the task until now.</li></ul><p>Obtains information about the amount of memory used by a task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnadouinf" href="#Mosek.getnadouinf"><code>Mosek.getnadouinf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dvalue = getnadouinf(task_:: MSKtask,infitemname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>infitemname :: String</code>. The name of a double information item.</li><li><code>dvalue :: Float64</code>. The value of the required double information item.</li></ul><p>Obtains a named double information item from task information database.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnadouparam" href="#Mosek.getnadouparam"><code>Mosek.getnadouparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parvalue = getnadouparam(task_:: MSKtask,paramname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>parvalue :: Float64</code>. Parameter value.</li></ul><p>Obtains the value of a named double parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnaintinf" href="#Mosek.getnaintinf"><code>Mosek.getnaintinf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ivalue = getnaintinf(task_:: MSKtask,infitemname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>infitemname :: String</code>. The name of an integer information item.</li><li><code>ivalue :: Int32</code>. The value of the required integer information item.</li></ul><p>Obtains a named integer information item from the task information database.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnaintparam" href="#Mosek.getnaintparam"><code>Mosek.getnaintparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parvalue = getnaintparam(task_:: MSKtask,paramname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>parvalue :: Int32</code>. Parameter value.</li></ul><p>Obtains the value of a named integer parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnastrparam" href="#Mosek.getnastrparam"><code>Mosek.getnastrparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(len,parvalue) = getnastrparam{T2}(task:: MSKtask,paramname:: AbstractString,sizeparamname:: T2)
(len,parvalue) = getnastrparam(task_:: MSKtask,paramname_:: AbstractString,sizeparamname_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>sizeparamname :: Int32</code>. Size of the name buffer.</li><li><code>len :: Int32</code>. Returns the length of the parameter value.</li><li><code>parvalue :: AbstractString</code>. Parameter value.</li></ul><p>Obtains the value of a named string parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumanz" href="#Mosek.getnumanz"><code>Mosek.getnumanz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numanz = getnumanz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numanz :: Int32</code>. Number of non-zero elements in the linear constraint matrix.</li></ul><p>Obtains the number of non-zeros in <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumanz64" href="#Mosek.getnumanz64"><code>Mosek.getnumanz64</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numanz = getnumanz64(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numanz :: Int64</code>. Number of non-zero elements in the linear constraint matrix.</li></ul><p>Obtains the number of non-zeros in <span>$A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumbarablocktriplets" href="#Mosek.getnumbarablocktriplets"><code>Mosek.getnumbarablocktriplets</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num = getnumbarablocktriplets(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. An upper bound on the number of elements in the block triplet form of bara.</li></ul><p>Obtains an upper bound on the number of elements in the block triplet form of <span>$\bar A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumbaranz" href="#Mosek.getnumbaranz"><code>Mosek.getnumbaranz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nz = getnumbaranz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>nz :: Int64</code>. The number of nonzero block elements in barA.</li></ul><p>Get the number of nonzero elements in <span>$\bar A$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumbarcblocktriplets" href="#Mosek.getnumbarcblocktriplets"><code>Mosek.getnumbarcblocktriplets</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num = getnumbarcblocktriplets(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. An upper bound on the number of elements in the block triplet form of barc.</li></ul><p>Obtains an upper bound on the number of elements in the block triplet form of <span>$\bar C$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumbarcnz" href="#Mosek.getnumbarcnz"><code>Mosek.getnumbarcnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nz = getnumbarcnz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>nz :: Int64</code>. The number of nonzero elements in barc.</li></ul><p>Obtains the number of nonzero elements in <span>$\bar C$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumbarvar" href="#Mosek.getnumbarvar"><code>Mosek.getnumbarvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numbarvar = getnumbarvar(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numbarvar :: Int32</code>. Number of semidefinite variables in the problem.</li></ul><p>Obtains the number of semidefinite variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumcon" href="#Mosek.getnumcon"><code>Mosek.getnumcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numcon = getnumcon(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numcon :: Int32</code>. Number of constraints.</li></ul><p>Obtains the number of constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumcone" href="#Mosek.getnumcone"><code>Mosek.getnumcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numcone = getnumcone(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numcone :: Int32</code>. Number of conic constraints.</li></ul><p>Obtains the number of cones.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumconemem" href="#Mosek.getnumconemem"><code>Mosek.getnumconemem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nummem = getnumconemem{T1}(task:: MSKtask,k:: T1)
nummem = getnumconemem(task_:: MSKtask,k_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Index of the cone.</li><li><code>nummem :: Int32</code>. Number of member variables in the cone.</li></ul><p>Obtains the number of members in a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumintvar" href="#Mosek.getnumintvar"><code>Mosek.getnumintvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numintvar = getnumintvar(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numintvar :: Int32</code>. Number of integer variables.</li></ul><p>Obtains the number of integer-constrained variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumparam" href="#Mosek.getnumparam"><code>Mosek.getnumparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numparam = getnumparam(task_:: MSKtask,partype_:: Parametertype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>partype :: Parametertype</code>. Parameter type.</li><li><code>numparam :: Int32</code>. Returns the number of parameters of the requested type.</li></ul><p>Obtains the number of parameters of a given type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumqconknz" href="#Mosek.getnumqconknz"><code>Mosek.getnumqconknz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numqcnz = getnumqconknz{T1}(task:: MSKtask,k:: T1)
numqcnz = getnumqconknz(task_:: MSKtask,k_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Index of the constraint for which the number quadratic terms should be obtained.</li><li><code>numqcnz :: Int64</code>. Number of quadratic terms.</li></ul><p>Obtains the number of non-zero quadratic terms in a constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumqobjnz" href="#Mosek.getnumqobjnz"><code>Mosek.getnumqobjnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numqonz = getnumqobjnz(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numqonz :: Int64</code>. Number of non-zero elements in the quadratic objective terms.</li></ul><p>Obtains the number of non-zero quadratic terms in the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumsymmat" href="#Mosek.getnumsymmat"><code>Mosek.getnumsymmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">num = getnumsymmat(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. The number of symmetric sparse matrices.</li></ul><p>Obtains the number of symmetric matrices stored in the vector <span>$E$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getnumvar" href="#Mosek.getnumvar"><code>Mosek.getnumvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numvar = getnumvar(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numvar :: Int32</code>. Number of variables.</li></ul><p>Obtains the number of variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getobjname" href="#Mosek.getobjname"><code>Mosek.getobjname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">objname = getobjname(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>objname :: AbstractString</code>. Assigned the objective name.</li></ul><p>Obtains the name assigned to the objective function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getobjnamelen" href="#Mosek.getobjnamelen"><code>Mosek.getobjnamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getobjnamelen(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>len :: Int32</code>. Assigned the length of the objective name.</li></ul><p>Obtains the length of the name assigned to the objective function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getobjsense" href="#Mosek.getobjsense"><code>Mosek.getobjsense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sense = getobjsense(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sense :: Objsense</code>. The returned objective sense.</li></ul><p>Gets the objective sense of the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getparamname" href="#Mosek.getparamname"><code>Mosek.getparamname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parname = getparamname{T2}(task:: MSKtask,partype:: Parametertype,param:: T2)
parname = getparamname(task_:: MSKtask,partype_:: Parametertype,param_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>partype :: Parametertype</code>. Parameter type.</li><li><code>param :: Int32</code>. Which parameter.</li><li><code>parname :: AbstractString</code>. Parameter name.</li></ul><p>Obtains the name for a parameter <code>param</code> of type <code>partype</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getprimalobj" href="#Mosek.getprimalobj"><code>Mosek.getprimalobj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primalobj = getprimalobj(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>primalobj :: Float64</code>. Objective value corresponding to the primal solution.</li></ul><p>Computes the primal objective value for the desired solution. Note that if the solution is an infeasibility certificate, then the fixed term in the objective is not included.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getprimalsolutionnorms" href="#Mosek.getprimalsolutionnorms"><code>Mosek.getprimalsolutionnorms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(nrmxc,nrmxx,nrmbarx) = getprimalsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>nrmxc :: Float64</code>. The norm of the xc vector.</li><li><code>nrmxx :: Float64</code>. The norm of the xx vector.</li><li><code>nrmbarx :: Float64</code>. The norm of the barX vector.</li></ul><p>Compute norms of the primal solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getprobtype" href="#Mosek.getprobtype"><code>Mosek.getprobtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">probtype = getprobtype(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>probtype :: Problemtype</code>. The problem type.</li></ul><p>Obtains the problem type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getprosta" href="#Mosek.getprosta"><code>Mosek.getprosta</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prosta = getprosta(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>prosta :: Prosta</code>. Problem status.</li></ul><p>Obtains the problem status.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getpviolbarvar" href="#Mosek.getpviolbarvar"><code>Mosek.getpviolbarvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getpviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getpviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of barX variables.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Computes the primal solution violation for a set of semidefinite variables.  Let <span>$(\bar X_j)^*$</span> be the value of the variable <span>$\bar X_j$</span> for the specified solution.  Then the primal violation of the solution associated with variable <span>$\bar X_j$</span> is given by</p><div>\[ \max(-\lambda_{\min}(\bar X_j),\ 0.0).\]</div><p>Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getpviolcon" href="#Mosek.getpviolcon"><code>Mosek.getpviolcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getpviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getpviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of constraints.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Computes the primal solution violation for a set of constraints.  The primal violation of the solution associated with the <span>$i$</span>-th constraint is given by</p><div>\[ \max(\tau l_i^c - (x_i^c)^*,\ (x_i^c)^* - \tau u_i^c),\ |\sum_{j=1}^{+1{numvar}} a_{ij} x_j^* - x_i^c|)\]</div><p>where <span>$\tau=0$</span> if the solution is a certificate of dual infeasibility and <span>$\tau=1$</span> otherwise. Both when the solution is a certificate of dual infeasibility and when it is primal feasible the violation should be small. The above formula applies for the linear case but is appropriately generalized in other cases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getpviolcones" href="#Mosek.getpviolcones"><code>Mosek.getpviolcones</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getpviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getpviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of conic constraints.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Computes the primal solution violation for a set of conic constraints.  Let <span>$x^*$</span> be the value of the variable <span>$x$</span> for the specified solution. For simplicity let us assume that <span>$x$</span> is a member of a quadratic cone, then the violation is computed as follows</p><div>\[\left\{
  \begin{array}{ll}
    \max(0,\|x_{2:n}\|-x_1) / \sqrt{2}, &amp; x_1 \geq -\|x_{2:n}\|, \\
    \|x\|, &amp; \mbox{otherwise.}
  \end{array}
\right.\]</div><p>Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getpviolvar" href="#Mosek.getpviolvar"><code>Mosek.getpviolvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viol = getpviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
viol = getpviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sub :: Vector{Int32}</code>. An array of indexes of x variables.</li><li><code>viol :: Vector{Float64}</code>. List of violations corresponding to sub.</li></ul><p>Computes the primal solution violation associated to a set of variables.  Let <span>$x_j^*$</span> be the value of <span>$x_j$</span> for the specified solution.  Then the primal violation of the solution associated with variable <span>$x_j$</span> is given by</p><div>\[ \max( \tau l_j^x - x_j^*,\ x_j^* - \tau u_j^x,\ 0).\]</div><p>where <span>$\tau=0$</span> if the solution is a certificate of dual infeasibility and <span>$\tau=1$</span> otherwise. Both when the solution is a certificate of dual infeasibility and when it is primal feasible the violation should be small.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getqconk" href="#Mosek.getqconk"><code>Mosek.getqconk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(numqcnz,qcsubi,qcsubj,qcval) = getqconk{T1}(task:: MSKtask,k:: T1)
(numqcnz,qcsubi,qcsubj,qcval) = getqconk(task_:: MSKtask,k_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Which constraint.</li><li><code>numqcnz :: Int64</code>. Number of quadratic terms.</li><li><code>qcsubi :: Vector{Int32}</code>. Row subscripts for quadratic constraint matrix.</li><li><code>qcsubj :: Vector{Int32}</code>. Column subscripts for quadratic constraint matrix.</li><li><code>qcval :: Vector{Float64}</code>. Quadratic constraint coefficient values.</li></ul><p>Obtains all the quadratic terms in a constraint. The quadratic terms are stored sequentially in <code>qcsubi</code>, <code>qcsubj</code>, and <code>qcval</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getqobj" href="#Mosek.getqobj"><code>Mosek.getqobj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(numqonz,qosubi,qosubj,qoval) = getqobj(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>numqonz :: Int64</code>. Number of non-zero elements in the quadratic objective terms.</li><li><code>qosubi :: Vector{Int32}</code>. Row subscripts for quadratic objective coefficients.</li><li><code>qosubj :: Vector{Int32}</code>. Column subscripts for quadratic objective coefficients.</li><li><code>qoval :: Vector{Float64}</code>. Quadratic objective coefficient values.</li></ul><p>Obtains the quadratic terms in the objective. The required quadratic terms are stored sequentially in <code>qosubi</code>, <code>qosubj</code>, and <code>qoval</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getqobjij" href="#Mosek.getqobjij"><code>Mosek.getqobjij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qoij = getqobjij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
qoij = getqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Row index of the coefficient.</li><li><code>j :: Int32</code>. Column index of coefficient.</li><li><code>qoij :: Float64</code>. The required coefficient.</li></ul><p>Obtains one coefficient <span>$q_{ij}^o$</span> in the quadratic term of the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getreducedcosts" href="#Mosek.getreducedcosts"><code>Mosek.getreducedcosts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">redcosts = getreducedcosts{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
redcosts = getreducedcosts(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. The index of the first variable in the sequence.</li><li><code>last :: Int32</code>. The index of the last variable in the sequence plus 1.</li><li><code>redcosts :: Vector{Float64}</code>. Returns the requested reduced costs.</li></ul><p>Computes the reduced costs for a slice of variables and returns them in the array <code>redcosts</code> i.e.</p><div>\[:label: ais-eq-redcost

\mathtt{redcosts}[j-\mathtt{first}] = (s_l^x)_j-(s_u^x)_j, ~j=\mathtt{first},\ldots,\mathtt{last}-1\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getskc" href="#Mosek.getskc"><code>Mosek.getskc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skc = getskc(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>skc :: Vector{Stakey}</code>. Status keys for the constraints.</li></ul><p>Obtains the status keys for the constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getskcslice" href="#Mosek.getskcslice"><code>Mosek.getskcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skc = getskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
skc = getskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>skc :: Vector{Stakey}</code>. Status keys for the constraints.</li></ul><p>Obtains the status keys for a slice of the constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getskx" href="#Mosek.getskx"><code>Mosek.getskx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skx = getskx(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>skx :: Vector{Stakey}</code>. Status keys for the variables.</li></ul><p>Obtains the status keys for the scalar variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getskxslice" href="#Mosek.getskxslice"><code>Mosek.getskxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">skx = getskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
skx = getskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>skx :: Vector{Stakey}</code>. Status keys for the variables.</li></ul><p>Obtains the status keys for a slice of the scalar variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getslc" href="#Mosek.getslc"><code>Mosek.getslc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">slc = getslc(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li></ul><p>Obtains the <span>$s_l^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getslcslice" href="#Mosek.getslcslice"><code>Mosek.getslcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">slc = getslcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
slc = getslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li></ul><p>Obtains a slice of the <span>$s_l^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getslx" href="#Mosek.getslx"><code>Mosek.getslx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">slx = getslx(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li></ul><p>Obtains the <span>$s_l^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getslxslice" href="#Mosek.getslxslice"><code>Mosek.getslxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">slx = getslxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
slx = getslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li></ul><p>Obtains a slice of the <span>$s_l^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsnx" href="#Mosek.getsnx"><code>Mosek.getsnx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">snx = getsnx(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>snx :: Vector{Float64}</code>. Dual variables corresponding to the conic constraints on the variables.</li></ul><p>Obtains the <span>$s_n^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsnxslice" href="#Mosek.getsnxslice"><code>Mosek.getsnxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">snx = getsnxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
snx = getsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>snx :: Vector{Float64}</code>. Dual variables corresponding to the conic constraints on the variables.</li></ul><p>Obtains a slice of the <span>$s_n^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsolsta" href="#Mosek.getsolsta"><code>Mosek.getsolsta</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solsta = getsolsta(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>solsta :: Solsta</code>. Solution status.</li></ul><p>Obtains the solution status.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsolution" href="#Mosek.getsolution"><code>Mosek.getsolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx) = getsolution(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>prosta :: Prosta</code>. Problem status.</li><li><code>solsta :: Solsta</code>. Solution status.</li><li><code>skc :: Vector{Stakey}</code>. Status keys for the constraints.</li><li><code>skx :: Vector{Stakey}</code>. Status keys for the variables.</li><li><code>skn :: Vector{Stakey}</code>. Status keys for the conic constraints.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li><li><code>snx :: Vector{Float64}</code>. Dual variables corresponding to the conic constraints on the variables.</li></ul><p>Obtains the complete solution.</p><p>Consider the case of linear programming. The primal problem is given by</p><div>\[\begin{array}{lccccl}
  \mbox{minimize}              &amp;      &amp;      &amp; c^T x+c^f &amp;      &amp;        \\
  \mbox{subject to} &amp;  l^c &amp; \leq &amp; A x       &amp; \leq &amp; u^c,     \\
  &amp;  l^x &amp; \leq &amp; x         &amp; \leq &amp; u^x.   \\
\end{array}\]</div><p>and the corresponding dual problem is</p><div>\[\begin{array}{lccl}
  \mbox{maximize}   &amp; (l^c)^T s_l^c - (u^c)^T s_u^c         &amp;  \\
  &amp; + (l^x)^T s_l^x - (u^x)^T s_u^x + c^f &amp;  \\
  \mbox{subject to} &amp; A^T y + s_l^x - s_u^x                 &amp; = &amp; c, \\
  &amp; -y    + s_l^c - s_u^c                 &amp; = &amp; 0, \\
  &amp; s_l^c,s_u^c,s_l^x,s_u^x \geq 0.       &amp;   &amp;    \\
\end{array}\]</div><p>A conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by:</p><div>\[\begin{array}{lccccc}
  \mbox{maximize}   &amp; (l^c)^T s_l^c - (u^c)^T s_u^c         &amp;      &amp;    \\
  &amp; +(l^x)^T s_l^x - (u^x)^T s_u^x + c^f  &amp;      &amp;    \\
  \mbox{subject to} &amp; A^T y + s_l^x - s_u^x + s_n^x         &amp; =    &amp; c, \\
  &amp; -y + s_l^c - s_u^c                    &amp; =    &amp; 0, \\
  &amp; s_l^c,s_u^c,s_l^x,s_u^x               &amp; \geq &amp; 0, \\
  &amp; s_n^x \in \mathcal{K}^*                        &amp;      &amp;    \\
\end{array}\]</div><p>The mapping between variables and arguments to the function is as follows:</p><ul><li><code>xx</code> : Corresponds to variable <span>$x$</span> (also denoted <span>$x^x$</span>).</li><li><code>xc</code> : Corresponds to <span>$x^c:=Ax$</span>.</li><li><code>y</code>  : Corresponds to variable <span>$y$</span>.</li><li><code>slc</code>: Corresponds to variable <span>$s_l^c$</span>.</li><li><code>suc</code>: Corresponds to variable <span>$s_u^c$</span>.</li><li><code>slx</code>: Corresponds to variable <span>$s_l^x$</span>.</li><li><code>sux</code>: Corresponds to variable <span>$s_u^x$</span>.</li><li><code>snx</code>: Corresponds to variable <span>$s_n^x$</span>.</li></ul><p>The meaning of the values returned by this function depend on the <em>solution status</em> returned in the argument <code>solsta</code>. The most important possible values  of <code>solsta</code> are:</p><ul><li><p><code>MSK_SOL_STA_OPTIMAL</code> : An optimal solution satisfying the optimality criteria for continuous problems is returned.</p></li><li><p><code>MSK_SOL_STA_INTEGER_OPTIMAL</code> : An optimal solution satisfying the optimality criteria for integer problems is returned.</p></li><li><p><code>MSK_SOL_STA_PRIM_FEAS</code> : A solution satisfying the feasibility criteria.</p></li><li><p><code>MSK_SOL_STA_PRIM_INFEAS_CER</code> : A primal certificate of infeasibility is returned.</p></li><li><p><code>MSK_SOL_STA_DUAL_INFEAS_CER</code> : A dual certificate of infeasibility is returned.</p></li></ul><p>In order to retrieve the primal and dual values of semidefinite variables see <code>Mosek.getbarxj</code> and <code>Mosek.getbarsj</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsolutioni" href="#Mosek.getsolutioni"><code>Mosek.getsolutioni</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(sk,x,sl,su,sn) = getsolutioni{T2}(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype)
(sk,x,sl,su,sn) = getsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether solution information for a constraint or for a variable is retrieved.</li><li><code>i :: Int32</code>. Index of the constraint or variable.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sk :: Stakey</code>. Status key of the constraint of variable.</li><li><code>x :: Float64</code>. Solution value of the primal variable.</li><li><code>sl :: Float64</code>. Solution value of the dual variable associated with the lower bound.</li><li><code>su :: Float64</code>. Solution value of the dual variable associated with the upper bound.</li><li><code>sn :: Float64</code>. Solution value of the dual variable associated with the cone constraint.</li></ul><p>Obtains the primal and dual solution information for a single constraint or variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsolutioninfo" href="#Mosek.getsolutioninfo"><code>Mosek.getsolutioninfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone) = getsolutioninfo(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>pobj :: Float64</code>. The primal objective value.</li><li><code>pviolcon :: Float64</code>. Maximal primal bound violation for a xc variable.</li><li><code>pviolvar :: Float64</code>. Maximal primal bound violation for a xx variable.</li><li><code>pviolbarvar :: Float64</code>. Maximal primal bound violation for a barx variable.</li><li><code>pviolcone :: Float64</code>. Maximal primal violation of the solution with respect to the conic constraints.</li><li><code>pviolitg :: Float64</code>. Maximal violation in the integer constraints.</li><li><code>dobj :: Float64</code>. Dual objective value.</li><li><code>dviolcon :: Float64</code>. Maximal dual bound violation for a xc variable.</li><li><code>dviolvar :: Float64</code>. Maximal dual bound violation for a xx variable.</li><li><code>dviolbarvar :: Float64</code>. Maximal dual bound violation for a bars variable.</li><li><code>dviolcone :: Float64</code>. Maximum violation of the dual solution in the dual conic constraints.</li></ul><p>Obtains information about a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsolutionslice" href="#Mosek.getsolutionslice"><code>Mosek.getsolutionslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">values = getsolutionslice{T3,T4}(task:: MSKtask,whichsol:: Soltype,solitem:: Solitem,first:: T3,last:: T4)
values = getsolutionslice(task_:: MSKtask,whichsol_:: Soltype,solitem_:: Solitem,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>solitem :: Solitem</code>. Which part of the solution is required.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>values :: Vector{Float64}</code>. The values of the requested solution elements.</li></ul><p>Obtains a slice of one item from the solution. The format of the solution is exactly as in <code>Mosek.getsolution</code>. The parameter <code>solitem</code> determines which of the solution vectors should be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsparsesymmat" href="#Mosek.getsparsesymmat"><code>Mosek.getsparsesymmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(subi,subj,valij) = getsparsesymmat{T1}(task:: MSKtask,idx:: T1)
(subi,subj,valij) = getsparsesymmat(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Index of the matrix to retrieve.</li><li><code>subi :: Vector{Int32}</code>. Row subscripts of the matrix non-zero elements.</li><li><code>subj :: Vector{Int32}</code>. Column subscripts of the matrix non-zero elements.</li><li><code>valij :: Vector{Float64}</code>. Coefficients of the matrix non-zero elements.</li></ul><p>Get a single symmetric matrix from the matrix store.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getstrparam" href="#Mosek.getstrparam"><code>Mosek.getstrparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(len,parvalue) = getstrparam(task_:: MSKtask,param_:: Sparam)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Sparam</code>. Which parameter.</li><li><code>len :: Int32</code>. The length of the parameter value.</li><li><code>parvalue :: AbstractString</code>. If this is not a null pointer, the parameter value is stored here.</li></ul><p>Obtains the value of a string parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getstrparamlen" href="#Mosek.getstrparamlen"><code>Mosek.getstrparamlen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getstrparamlen(task_:: MSKtask,param_:: Sparam)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Sparam</code>. Which parameter.</li><li><code>len :: Int32</code>. The length of the parameter value.</li></ul><p>Obtains the length of a string parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsuc" href="#Mosek.getsuc"><code>Mosek.getsuc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">suc = getsuc(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li></ul><p>Obtains the <span>$s_u^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsucslice" href="#Mosek.getsucslice"><code>Mosek.getsucslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">suc = getsucslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
suc = getsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li></ul><p>Obtains a slice of the <span>$s_u^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsux" href="#Mosek.getsux"><code>Mosek.getsux</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sux = getsux(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li></ul><p>Obtains the <span>$s_u^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsuxslice" href="#Mosek.getsuxslice"><code>Mosek.getsuxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sux = getsuxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
sux = getsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li></ul><p>Obtains a slice of the <span>$s_u^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getsymmatinfo" href="#Mosek.getsymmatinfo"><code>Mosek.getsymmatinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(dim,nz,type) = getsymmatinfo{T1}(task:: MSKtask,idx:: T1)
(dim,nz,type) = getsymmatinfo(task_:: MSKtask,idx_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>idx :: Int64</code>. Index of the matrix for which information is requested.</li><li><code>dim :: Int32</code>. Returns the dimension of the requested matrix.</li><li><code>nz :: Int64</code>. Returns the number of non-zeros in the requested matrix.</li><li><code>type :: Symmattype</code>. Returns the type of the requested matrix.</li></ul><p>MOSEK maintains a vector denoted by <span>$E$</span> of symmetric data matrices. This function makes it possible to obtain important information about a single matrix in <span>$E$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.gettaskname" href="#Mosek.gettaskname"><code>Mosek.gettaskname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">taskname = gettaskname(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>taskname :: AbstractString</code>. Returns the task name.</li></ul><p>Obtains the name assigned to the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.gettasknamelen" href="#Mosek.gettasknamelen"><code>Mosek.gettasknamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = gettasknamelen(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>len :: Int32</code>. Returns the length of the task name.</li></ul><p>Obtains the length the task name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvarbound" href="#Mosek.getvarbound"><code>Mosek.getvarbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getvarbound{T1}(task:: MSKtask,i:: T1)
(bk,bl,bu) = getvarbound(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the variable for which the bound information should be obtained.</li><li><code>bk :: Boundkey</code>. Bound keys.</li><li><code>bl :: Float64</code>. Values for lower bounds.</li><li><code>bu :: Float64</code>. Values for upper bounds.</li></ul><p>Obtains bound information for one variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvarboundslice" href="#Mosek.getvarboundslice"><code>Mosek.getvarboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(bk,bl,bu) = getvarboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
(bk,bl,bu) = getvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Boundkey}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Obtains bounds information for a slice of the variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvarname" href="#Mosek.getvarname"><code>Mosek.getvarname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name = getvarname{T1}(task:: MSKtask,j:: T1)
name = getvarname(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of a variable.</li><li><code>name :: AbstractString</code>. Returns the required name.</li></ul><p>Obtains the name of a variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvarnameindex" href="#Mosek.getvarnameindex"><code>Mosek.getvarnameindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(asgn,index) = getvarnameindex(task_:: MSKtask,somename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>somename :: String</code>. The name which should be checked.</li><li><code>asgn :: Int32</code>. Is non-zero if the name somename is assigned to a variable.</li><li><code>index :: Int32</code>. If the name somename is assigned to a variable, then return the index of the variable.</li></ul><p>Checks whether the name <code>somename</code> has been assigned to any variable. If so, the index of the variable is reported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvarnamelen" href="#Mosek.getvarnamelen"><code>Mosek.getvarnamelen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">len = getvarnamelen{T1}(task:: MSKtask,i:: T1)
len = getvarnamelen(task_:: MSKtask,i_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of a variable.</li><li><code>len :: Int32</code>. Returns the length of the indicated name.</li></ul><p>Obtains the length of the name of a variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvartype" href="#Mosek.getvartype"><code>Mosek.getvartype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vartype = getvartype{T1}(task:: MSKtask,j:: T1)
vartype = getvartype(task_:: MSKtask,j_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable.</li><li><code>vartype :: Variabletype</code>. Variable type of variable index j.</li></ul><p>Gets the variable type of one variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getvartypelist" href="#Mosek.getvartypelist"><code>Mosek.getvartypelist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vartype = getvartypelist{T1}(task:: MSKtask,subj:: Vector{T1})
vartype = getvartypelist(task_:: MSKtask,subj_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subj :: Vector{Int32}</code>. A list of variable indexes.</li><li><code>vartype :: Vector{Variabletype}</code>. Returns the variables types corresponding the variable indexes requested.</li></ul><p>Obtains the variable type of one or more variables. Upon return <code>vartype[k]</code> is the variable type of variable <code>subj[k]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getversion" href="#Mosek.getversion"><code>Mosek.getversion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(major,minor,build,revision) = getversion()</code></pre><ul><li><code>major :: Int32</code>. Major version number.</li><li><code>minor :: Int32</code>. Minor version number.</li><li><code>build :: Int32</code>. Build number.</li><li><code>revision :: Int32</code>. Revision number.</li></ul><p>Obtains MOSEK version information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getxc" href="#Mosek.getxc"><code>Mosek.getxc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xc = getxc(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li></ul><p>Obtains the <span>$x^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getxcslice" href="#Mosek.getxcslice"><code>Mosek.getxcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xc = getxcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
xc = getxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li></ul><p>Obtains a slice of the <span>$x^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getxx" href="#Mosek.getxx"><code>Mosek.getxx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xx = getxx(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li></ul><p>Obtains the <span>$x^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getxxslice" href="#Mosek.getxxslice"><code>Mosek.getxxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xx = getxxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
xx = getxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li></ul><p>Obtains a slice of the <span>$x^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.gety" href="#Mosek.gety"><code>Mosek.gety</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">y = gety(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li></ul><p>Obtains the <span>$y$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.getyslice" href="#Mosek.getyslice"><code>Mosek.getyslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">y = getyslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
y = getyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li></ul><p>Obtains a slice of the <span>$y$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.initbasissolve" href="#Mosek.initbasissolve"><code>Mosek.initbasissolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis = initbasissolve(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>basis :: Vector{Int32}</code>. The array of basis indexes to use.</li></ul><p>Prepare a task for use with the <code>Mosek.solvewithbasis</code> function.</p><p>This function should be called</p><ul><li>immediately before the first call to <code>Mosek.solvewithbasis</code>, and</li><li>immediately before any subsequent call to <code>Mosek.solvewithbasis</code> if the task has been modified. </li></ul><p>If the basis is singular i.e. not invertible, then the error :msk:res:<code>err_basis_singular</code> is reported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.inputdata" href="#Mosek.inputdata"><code>Mosek.inputdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inputdata{T1,T2,T3,T4,T5,T6,T7,T8,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,aptrb:: Vector{T5},aptre:: Vector{T6},asub:: Vector{T7},aval:: Vector{T8},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
inputdata{T1,T2,T3,T4,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,A:: SparseMatrixCSC{Float64},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
inputdata(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,c_:: Vector{Float64},cfix_:: Float64,aptrb_:: Vector{Int64},aptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcon :: Int32</code>. Number of preallocated constraints in the optimization task.</li><li><code>maxnumvar :: Int32</code>. Number of preallocated variables in the optimization task.</li><li><code>c :: Vector{Float64}</code>. Linear terms of the objective as a dense vector. The length is the number of variables.</li><li><code>cfix :: Float64</code>. Fixed term in the objective.</li><li><code>aptrb :: Vector{Int64}</code>. Row or column start pointers.</li><li><code>aptre :: Vector{Int64}</code>. Row or column end pointers.</li><li><code>asub :: Vector{Int32}</code>. Coefficient subscripts.</li><li><code>aval :: Vector{Float64}</code>. Coefficient values.</li><li><code>bkc :: Vector{Int32}</code>. Bound keys for the constraints.</li><li><code>blc :: Vector{Float64}</code>. Lower bounds for the constraints.</li><li><code>buc :: Vector{Float64}</code>. Upper bounds for the constraints.</li><li><code>bkx :: Vector{Int32}</code>. Bound keys for the variables.</li><li><code>blx :: Vector{Float64}</code>. Lower bounds for the variables.</li><li><code>bux :: Vector{Float64}</code>. Upper bounds for the variables.</li><li><code>A :: SparseMatrixCSC{Float64}</code>. Sparse matrix defining the column values</li></ul><p>Input the linear part of an optimization problem.</p><p>The non-zeros of <span>$A$</span> are inputted column-wise in the format described in Section :ref:<code>doc.optimizer.cmo_rmo_matrix</code>.</p><p>For an explained code example see Section :ref:<code>doc.tutorial_lo</code> and Section :ref:<code>doc.optimizer.matrix_formats</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.isdouparname" href="#Mosek.isdouparname"><code>Mosek.isdouparname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">param = isdouparname(task_:: MSKtask,parname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>parname :: String</code>. Parameter name.</li><li><code>param :: Dparam</code>. Returns the parameter corresponding to the name, if one exists.</li></ul><p>Checks whether <code>parname</code> is a valid double parameter name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.isintparname" href="#Mosek.isintparname"><code>Mosek.isintparname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">param = isintparname(task_:: MSKtask,parname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>parname :: String</code>. Parameter name.</li><li><code>param :: Iparam</code>. Returns the parameter corresponding to the name, if one exists.</li></ul><p>Checks whether <code>parname</code> is a valid integer parameter name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.isstrparname" href="#Mosek.isstrparname"><code>Mosek.isstrparname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">param = isstrparname(task_:: MSKtask,parname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>parname :: String</code>. Parameter name.</li><li><code>param :: Sparam</code>. Returns the parameter corresponding to the name, if one exists.</li></ul><p>Checks whether <code>parname</code> is a valid string parameter name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.licensecleanup" href="#Mosek.licensecleanup"><code>Mosek.licensecleanup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">licensecleanup()</code></pre><p>Stops all threads and deletes all handles used by the license system. If this function is called, it must be called as the last MOSEK API call. No other MOSEK API calls are valid after this.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.linkfiletostream" href="#Mosek.linkfiletostream"><code>Mosek.linkfiletostream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linkfiletostream{T3}(task:: MSKtask,whichstream:: Streamtype,filename:: AbstractString,append:: T3)
linkfiletostream(task_:: MSKtask,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li><li><code>filename :: String</code>. A valid file name.</li><li><code>append :: Int32</code>. If this argument is 0 the output file will be overwritten, otherwise it will be appended to.</li></ul><p>Directs all output from a task stream <code>whichstream</code> to a file <code>filename</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.onesolutionsummary" href="#Mosek.onesolutionsummary"><code>Mosek.onesolutionsummary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">onesolutionsummary(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li></ul><p>Prints a short summary of a specified solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.optimize" href="#Mosek.optimize"><code>Mosek.optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trmcode = optimize(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>trmcode :: Rescode</code>. Is either OK or a termination response code.</li></ul><p>Calls the optimizer. Depending on the problem type and the selected optimizer this will call one of the optimizers in MOSEK. By default the interior point optimizer will be selected for continuous problems.  The optimizer may be selected manually by setting the parameter <code>MSK_IPAR_OPTIMIZER</code>`.</p><p>.. msk_only:: c</p><p>This function is equivalent to <code>Mosek.optimize</code> except for the handling of return values. This function returns errors on the left hand side. Warnings are not returned and termination codes are returned through the separate argument <code>trmcode</code>.</p><p>.. msk_only:: java and dotnet and python</p><p>This function throws an exception if an error has occurred during the optimization, e.g the optimizer has run out of memory. Moreover it provides a termination code, relaying information about the conditions under which the optimizer terminated. For example <code>MSK_RES_TRM_MAX_ITERATIONS</code> indicates that the optimizer finished because it reached the maximum number of iterations specified by the user.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.optimizersummary" href="#Mosek.optimizersummary"><code>Mosek.optimizersummary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimizersummary(task_:: MSKtask,whichstream_:: Streamtype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li></ul><p>Prints a short summary with optimizer statistics from last optimization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.primalrepair" href="#Mosek.primalrepair"><code>Mosek.primalrepair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">primalrepair{T1,T2,T3,T4}(task:: MSKtask,wlc:: Vector{T1},wuc:: Vector{T2},wlx:: Vector{T3},wux:: Vector{T4})
primalrepair(task_:: MSKtask,wlc_:: Vector{Float64},wuc_:: Vector{Float64},wlx_:: Vector{Float64},wux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>wlc :: Vector{Float64}</code>. Weights associated with relaxing lower bounds on the constraints.</li><li><code>wuc :: Vector{Float64}</code>. Weights associated with relaxing the upper bound on the constraints.</li><li><code>wlx :: Vector{Float64}</code>. Weights associated with relaxing the lower bounds of the variables.</li><li><code>wux :: Vector{Float64}</code>. Weights associated with relaxing the upper bounds of variables.</li></ul><p>The function repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables where the adjustment is computed as the minimal weighted sum of relaxations to the bounds on the constraints and variables. Observe the function only repairs the problem but does not solve it. If an optimal solution is required the problem should be optimized after the repair.</p><p>The function is applicable to linear and conic problems possibly with integer variables.</p><p>Observe that when computing the minimal weighted relaxation the termination tolerance specified by the parameters of the task is employed. For instance the parameter <code>MSK_IPAR_MIO_MODE</code>` can be used to make MOSEK ignore the integer constraints during the repair which usually leads to a much faster repair. However, the drawback is of course that the repaired problem may not have an integer feasible solution.</p><p>Note the function modifies the task in place. If this is not desired, then apply the function to a cloned task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.primalsensitivity" href="#Mosek.primalsensitivity"><code>Mosek.primalsensitivity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity{T1,T3}(task:: MSKtask,subi:: Vector{T1},marki:: Vector{Mark},subj:: Vector{T3},markj:: Vector{Mark})
(leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity(task_:: MSKtask,subi_:: Vector{Int32},marki_:: Vector{Mark},subj_:: Vector{Int32},markj_:: Vector{Mark})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subi :: Vector{Int32}</code>. Indexes of constraints to analyze.</li><li><code>marki :: Vector{Int32}</code>. Mark which constraint bounds to analyze.</li><li><code>subj :: Vector{Int32}</code>. Indexes of variables to analyze.</li><li><code>markj :: Vector{Int32}</code>. Mark which variable bounds to analyze.</li><li><code>leftpricei :: Vector{Float64}</code>. Left shadow price for constraints.</li><li><code>rightpricei :: Vector{Float64}</code>. Right shadow price for constraints.</li><li><code>leftrangei :: Vector{Float64}</code>. Left range for constraints.</li><li><code>rightrangei :: Vector{Float64}</code>. Right range for constraints.</li><li><code>leftpricej :: Vector{Float64}</code>. Left shadow price for variables.</li><li><code>rightpricej :: Vector{Float64}</code>. Right shadow price for variables.</li><li><code>leftrangej :: Vector{Float64}</code>. Left range for variables.</li><li><code>rightrangej :: Vector{Float64}</code>. Right range for variables.</li></ul><p>Calculates sensitivity information for bounds on variables and constraints. For details on sensitivity  analysis, the definitions of <em>shadow price</em> and <em>linearity interval</em> and an example see Section :ref:<code>doc.sensitivity_analysis</code>.</p><p>The type of sensitivity analysis to be performed (basis or optimal partition) is controlled by the parameter <code>MSK_IPAR_SENSITIVITY_TYPE</code>`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.printdata" href="#Mosek.printdata"><code>Mosek.printdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">printdata{T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15}(task:: MSKtask,whichstream:: Streamtype,firsti:: T2,lasti:: T3,firstj:: T4,lastj:: T5,firstk:: T6,lastk:: T7,c:: T8,qo:: T9,a:: T10,qc:: T11,bc:: T12,bx:: T13,vartype:: T14,cones:: T15)
printdata(task_:: MSKtask,whichstream_:: Streamtype,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32,firstk_:: Int32,lastk_:: Int32,c_:: Int32,qo_:: Int32,a_:: Int32,qc_:: Int32,bc_:: Int32,bx_:: Int32,vartype_:: Int32,cones_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li><li><code>firsti :: Int32</code>. Index of first constraint for which data should be printed.</li><li><code>lasti :: Int32</code>. Index of last constraint plus 1 for which data should be printed.</li><li><code>firstj :: Int32</code>. Index of first variable for which data should be printed.</li><li><code>lastj :: Int32</code>. Index of last variable plus 1 for which data should be printed.</li><li><code>firstk :: Int32</code>. Index of first cone for which data should be printed.</li><li><code>lastk :: Int32</code>. Index of last cone plus 1 for which data should be printed.</li><li><code>c :: Int32</code>. If non-zero the linear objective terms are printed.</li><li><code>qo :: Int32</code>. If non-zero the quadratic objective terms are printed.</li><li><code>a :: Int32</code>. If non-zero the linear constraint matrix is printed.</li><li><code>qc :: Int32</code>. If non-zero q&#39;th     quadratic constraint terms are printed for the relevant constraints.</li><li><code>bc :: Int32</code>. If non-zero the constraint bounds are printed.</li><li><code>bx :: Int32</code>. If non-zero the variable bounds are printed.</li><li><code>vartype :: Int32</code>. If non-zero the variable types are printed.</li><li><code>cones :: Int32</code>. If non-zero the  conic data is printed.</li></ul><p>Prints a part of the problem data to a stream. This function is normally used for debugging purposes only, e.g. to verify that the correct data has been inputted.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.printparam" href="#Mosek.printparam"><code>Mosek.printparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">printparam(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li></ul><p>Prints the current parameter settings to the message stream.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putacol" href="#Mosek.putacol"><code>Mosek.putacol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putacol{T1,T2,T3}(task:: MSKtask,j:: T1,subj:: Vector{T2},valj:: Vector{T3})
putacol(task_:: MSKtask,j_:: Int32,subj_:: Vector{Int32},valj_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Column index.</li><li><code>subj :: Vector{Int32}</code>. Row indexes of non-zero values in column.</li><li><code>valj :: Vector{Float64}</code>. New non-zero values of column.</li></ul><p>Change one column of the linear constraint matrix <span>$A$</span>. Resets all the elements in column <span>$j$</span> to zero and then sets</p><div>\[ a_{\mathtt{subj}[k],\mathtt{j}} = \mathtt{valj}[k], \mathcal{C}_q k=0,\ldots,\mathtt{nzj}-1.\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putacollist" href="#Mosek.putacollist"><code>Mosek.putacollist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putacollist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
putacollist{T1}(task:: MSKtask,sub:: Vector{T1},A:: SparseMatrixCSC{Float64})
putacollist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sub :: Vector{Int32}</code>. Indexes of columns that should be replaced.</li><li><code>ptrb :: Vector{Int64}</code>. Array of pointers to the first element in the columns.</li><li><code>ptre :: Vector{Int64}</code>. Array of pointers to the last element plus one in the columns.</li><li><code>asub :: Vector{Int32}</code>. Row indexes</li><li><code>aval :: Vector{Float64}</code>. Coefficient values.</li><li><code>A :: SparseMatrixCSC{Float64}</code>. Sparse matrix defining the column values</li></ul><p>Change a set of columns in the linear constraint matrix <span>$A$</span> with data in sparse triplet format. The requested columns are set to zero and then updated with:</p><div>\[\begin{array}{rl}
  \mathtt{for} &amp; i=1,\ldots,+1{num}\\
              &amp; a_{\mathtt{asub}[k],\mathtt{sub}[i]} = \mathtt{aval}[k],\mathcal{C}_q k=\mathtt{ptrb}[i],\ldots,\mathtt{ptre}[i]-1. 
\end{array}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putacolslice" href="#Mosek.putacolslice"><code>Mosek.putacolslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putacolslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
putacolslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,A:: SparseMatrixCSC{Float64})
putacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First column in the slice.</li><li><code>last :: Int32</code>. Last column plus one in the slice.</li><li><code>ptrb :: Vector{Int64}</code>. Array of pointers to the first element in the columns.</li><li><code>ptre :: Vector{Int64}</code>. Array of pointers to the last element plus one in the columns.</li><li><code>asub :: Vector{Int32}</code>. Row indexes</li><li><code>aval :: Vector{Float64}</code>. Coefficient values.</li><li><code>A :: SparseMatrixCSC{Float64}</code>. Sparse matrix defining the column values</li></ul><p>Change a slice of columns in the linear constraint matrix <span>$A$</span> with data in sparse triplet format. The requested columns are set to zero and then updated with: </p><div>\[\begin{array}{rl}
  \mathtt{for} &amp; i=\mathtt{first},\ldots,\mathtt{last}-1\\
              &amp; a_{\mathtt{asub}[k],i} = \mathtt{aval}[k],\mathcal{C}_q k=\mathtt{ptrb}[i],\ldots,\mathtt{ptre}[i]-1. 
\end{array}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putaij" href="#Mosek.putaij"><code>Mosek.putaij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putaij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,aij:: T3)
putaij(task_:: MSKtask,i_:: Int32,j_:: Int32,aij_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Constraint (row) index.</li><li><code>j :: Int32</code>. Variable (column) index.</li><li><code>aij :: Float64</code>. New coefficient.</li></ul><p>Changes a coefficient in the linear coefficient matrix <span>$A$</span> using the method</p><div>\[ a_{i,j} = \mathtt{aij}.\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putaijlist" href="#Mosek.putaijlist"><code>Mosek.putaijlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putaijlist{T1,T2,T3}(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},valij:: Vector{T3})
putaijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subi :: Vector{Int32}</code>. Constraint (row) indices.</li><li><code>subj :: Vector{Int32}</code>. Variable (column) indices.</li><li><code>valij :: Vector{Float64}</code>. New coefficient values.</li></ul><p>Changes one or more coefficients in <span>$A$</span> using the method</p><div>\[ a_{\mathtt{subi[k]},\mathtt{subj[k]}} = \mathtt{valij[k]}, \mathcal{C}_q k=1,\ldots,+1{num}.\]</div><p>Duplicates are not allowed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putarow" href="#Mosek.putarow"><code>Mosek.putarow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putarow{T1,T2,T3}(task:: MSKtask,i:: T1,subi:: Vector{T2},vali:: Vector{T3})
putarow(task_:: MSKtask,i_:: Int32,subi_:: Vector{Int32},vali_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Row index.</li><li><code>subi :: Vector{Int32}</code>. Column indexes of non-zero values in row.</li><li><code>vali :: Vector{Float64}</code>. New non-zero values of row.</li></ul><p>Change one row of the linear constraint matrix <span>$A$</span>. Resets all the elements in row <span>$i$</span> to zero and then sets</p><div>\[ a_{\mathtt{i},\mathtt{subi}[k]} = \mathtt{vali}[k], \mathcal{C}_q k=0,\ldots,\mathtt{nzi}-1.\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putarowlist" href="#Mosek.putarowlist"><code>Mosek.putarowlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putarowlist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
putarowlist{T1}(task:: MSKtask,sub:: Vector{T1},At:: SparseMatrixCSC{Float64})
putarowlist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sub :: Vector{Int32}</code>. Indexes of rows or columns that should be replaced.</li><li><code>ptrb :: Vector{Int64}</code>. Array of pointers to the first element in the rows.</li><li><code>ptre :: Vector{Int64}</code>. Array of pointers to the last element plus one in the rows.</li><li><code>asub :: Vector{Int32}</code>. Variable indexes.</li><li><code>aval :: Vector{Float64}</code>. Coefficient values.</li><li><code>At :: SparseMatrixCSC{Float64}</code>. Transposed matrix defining the row values. Note that for efficiency reasons the <em>columns</em> of this matrix defines the <em>rows</em> to be replaced</li></ul><p>Change a set of rows in the linear constraint matrix <span>$A$</span> with data in sparse triplet format. The requested rows are set to zero and then updated with:  </p><div>\[\begin{array}{rl}
  \mathtt{for} &amp; i=1,\ldots,+1{num} \\
               &amp; a_{\mathtt{sub}[i],\mathtt{asub}[k]} = \mathtt{aval}[k],\mathcal{C}_q k=\mathtt{ptrb}[i],\ldots,\mathtt{ptre}[i]-1. 
\end{array}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putarowslice" href="#Mosek.putarowslice"><code>Mosek.putarowslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putarowslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
putarowslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,At:: SparseMatrixCSC{Float64})
putarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First row in the slice.</li><li><code>last :: Int32</code>. Last row plus one in the slice.</li><li><code>ptrb :: Vector{Int64}</code>. Array of pointers to the first element in the rows.</li><li><code>ptre :: Vector{Int64}</code>. Array of pointers to the last element plus one in the rows.</li><li><code>asub :: Vector{Int32}</code>. Column indexes of new elements.</li><li><code>aval :: Vector{Float64}</code>. Coefficient values.</li><li><code>At :: SparseMatrixCSC{Float64}</code>. Transposed matrix defining the row values. Note that for efficiency reasons the <em>columns</em> of this matrix defines the <em>rows</em> to be replaced</li></ul><p>Change a slice of rows in the linear constraint matrix <span>$A$</span> with data in sparse triplet format. The requested columns are set to zero and then updated with:</p><div>\[\begin{array}{rl}
  \mathtt{for} &amp; i=\mathtt{first},\ldots,\mathtt{last}-1 \\
               &amp; a_{\mathtt{sub}[i],\mathtt{asub}[k]} = \mathtt{aval}[k],\mathcal{C}_q k=\mathtt{ptrb}[i],\ldots,\mathtt{ptre}[i]-1. 
\end{array}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarablocktriplet" href="#Mosek.putbarablocktriplet"><code>Mosek.putbarablocktriplet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarablocktriplet{T1,T2,T3,T4,T5,T6}(task:: MSKtask,num:: T1,subi:: Vector{T2},subj:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valijkl:: Vector{T6})
putbarablocktriplet(task_:: MSKtask,num_:: Int64,subi_:: Vector{Int32},subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valijkl_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. Number of elements in the block triplet form.</li><li><code>subi :: Vector{Int32}</code>. Constraint index.</li><li><code>subj :: Vector{Int32}</code>. Symmetric matrix variable index.</li><li><code>subk :: Vector{Int32}</code>. Block row index.</li><li><code>subl :: Vector{Int32}</code>. Block column index.</li><li><code>valijkl :: Vector{Float64}</code>. The numerical value associated with each block triplet.</li></ul><p>Inputs the <span>$\bar A$</span> matrix in block triplet form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbaraij" href="#Mosek.putbaraij"><code>Mosek.putbaraij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbaraij{T1,T2,T3,T4}(task:: MSKtask,i:: T1,j:: T2,sub:: Vector{T3},weights:: Vector{T4})
putbaraij(task_:: MSKtask,i_:: Int32,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Row index of barA.</li><li><code>j :: Int32</code>. Column index of barA.</li><li><code>sub :: Vector{Int64}</code>. Element indexes in matrix storage.</li><li><code>weights :: Vector{Float64}</code>. Weights in the weighted sum.</li></ul><p>This function sets one element in the <span>$\bar A$</span> matrix.</p><p>Each element in the <span>$\bar A$</span> matrix is a weighted sum of symmetric matrices from the symmetric matrix storage <span>$E$</span>, so <span>$\bar A_{ij}$</span> is a symmetric matrix. By default all elements in <span>$\bar A$</span> are 0, so only non-zero elements need be added. Setting the same element again will overwrite the earlier entry. </p><p>The symmetric matrices from <span>$E$</span> are defined separately using the function <code>Mosek.appendsparsesymmat</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarcblocktriplet" href="#Mosek.putbarcblocktriplet"><code>Mosek.putbarcblocktriplet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarcblocktriplet{T1,T2,T3,T4,T5}(task:: MSKtask,num:: T1,subj:: Vector{T2},subk:: Vector{T3},subl:: Vector{T4},valjkl:: Vector{T5})
putbarcblocktriplet(task_:: MSKtask,num_:: Int64,subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valjkl_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>num :: Int64</code>. Number of elements in the block triplet form.</li><li><code>subj :: Vector{Int32}</code>. Symmetric matrix variable index.</li><li><code>subk :: Vector{Int32}</code>. Block row index.</li><li><code>subl :: Vector{Int32}</code>. Block column index.</li><li><code>valjkl :: Vector{Float64}</code>. The numerical value associated with each block triplet.</li></ul><p>Inputs the <span>$\bar C$</span> matrix in block triplet form.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarcj" href="#Mosek.putbarcj"><code>Mosek.putbarcj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarcj{T1,T2,T3}(task:: MSKtask,j:: T1,sub:: Vector{T2},weights:: Vector{T3})
putbarcj(task_:: MSKtask,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the element in barc` that should be changed.</li><li><code>sub :: Vector{Int64}</code>. sub is list of indexes of those symmetric matrices appearing in sum.</li><li><code>weights :: Vector{Float64}</code>. The weights of the terms in the weighted sum.</li></ul><p>This function sets one entry in the <span>$\bar C$</span> vector.</p><p>Each element in the <span>$\bar C$</span> vector is a weighted sum of symmetric matrices from the symmetric matrix storage <span>$E$</span>, so <span>$\bar C_{j}$</span> is a symmetric matrix. By default all elements in <span>$\bar C$</span> are 0, so only non-zero elements need be added. Setting the same element again will overwrite the earlier entry. </p><p>The symmetric matrices from <span>$E$</span> are defined separately using the function <code>Mosek.appendsparsesymmat</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarsj" href="#Mosek.putbarsj"><code>Mosek.putbarsj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarsj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barsj:: Vector{T3})
putbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barsj_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>j :: Int32</code>. Index of the semidefinite variable.</li><li><code>barsj :: Vector{Float64}</code>. Value of the j&#39;th variable of barx.</li></ul><p>Sets the dual solution for a semidefinite variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarvarname" href="#Mosek.putbarvarname"><code>Mosek.putbarvarname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
putbarvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable.</li><li><code>name :: String</code>. The variable name.</li></ul><p>Sets the name of a semidefinite variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbarxj" href="#Mosek.putbarxj"><code>Mosek.putbarxj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbarxj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barxj:: Vector{T3})
putbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barxj_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>j :: Int32</code>. Index of the semidefinite variable.</li><li><code>barxj :: Vector{Float64}</code>. Value of the j&#39;th variable of barx.</li></ul><p>Sets the primal solution for a semidefinite variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putbound" href="#Mosek.putbound"><code>Mosek.putbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putbound{T2,T4,T5}(task:: MSKtask,accmode:: Accmode,i:: T2,bk:: Boundkey,bl:: T4,bu:: T5)
putbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether the bound for a constraint or a variable is changed.</li><li><code>i :: Int32</code>. Index of the constraint or variable.</li><li><code>bk :: Boundkey</code>. New bound key.</li><li><code>bl :: Float64</code>. New lower bound.</li><li><code>bu :: Float64</code>. New upper bound.</li></ul><p>Changes the bound for either one constraint or one variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putboundlist" href="#Mosek.putboundlist"><code>Mosek.putboundlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putboundlist{T2,T4,T5}(task:: MSKtask,accmode:: Accmode,sub:: Vector{T2},bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
putboundlist(task_:: MSKtask,accmode_:: Accmode,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether to access bounds on variables or constraints.</li><li><code>sub :: Vector{Int32}</code>. Subscripts of the constraints or variables that should be changed.</li><li><code>bk :: Vector{Int32}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Changes the bounds of constraints or variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putboundslice" href="#Mosek.putboundslice"><code>Mosek.putboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putboundslice{T2,T3,T5,T6}(task:: MSKtask,con:: Accmode,first:: T2,last:: T3,bk:: Vector{Boundkey},bl:: Vector{T5},bu:: Vector{T6})
putboundslice(task_:: MSKtask,con_:: Accmode,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>con :: Accmode</code>. Determines whether variables or constraints are modified.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Int32}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Changes the bounds for a slice of constraints or variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putcfix" href="#Mosek.putcfix"><code>Mosek.putcfix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putcfix{T1}(task:: MSKtask,cfix:: T1)
putcfix(task_:: MSKtask,cfix_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>cfix :: Float64</code>. Fixed term in the objective.</li></ul><p>Replaces the fixed term in the objective by a new one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putcj" href="#Mosek.putcj"><code>Mosek.putcj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putcj{T1,T2}(task:: MSKtask,j:: T1,cj:: T2)
putcj(task_:: MSKtask,j_:: Int32,cj_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable whose objective coefficient should be changed.</li><li><code>cj :: Float64</code>. New coefficient value.</li></ul><p>Modifies one coefficient in the linear objective vector <span>$c$</span>, i.e.</p><div>\[ c_{\mathtt{j}} = \mathtt{cj}.\]</div><p>If the absolute value exceeds <code>MSK_DPAR_DATA_TOL_C_HUGE</code><code>an error is generated. If the absolute value exceeds</code>MSK<em>DPAR</em>DATA<em>TOL</em>CJ_LARGE``, a warning is generated, but the coefficient is inputted as specified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putclist" href="#Mosek.putclist"><code>Mosek.putclist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putclist{T1,T2}(task:: MSKtask,subj:: Vector{T1},val:: Vector{T2})
putclist(task_:: MSKtask,subj_:: Vector{Int32},val_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subj :: Vector{Int32}</code>. Indices of variables for which objective coefficients should be changed.</li><li><code>val :: Vector{Float64}</code>. New numerical values for the objective coefficients that should be modified.</li></ul><p>Modifies the coefficients in the linear term <span>$c$</span> in the objective using the principle</p><div>\[ c_{\mathtt{subj[t]}} = \mathtt{val[t]}, \mathcal{C}_q t=1,\ldots,+1{num}.\]</div><p>If a variable index is specified multiple times in <code>subj</code> only the last entry is used. Data checks are performed as in <code>Mosek.putcj</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putconbound" href="#Mosek.putconbound"><code>Mosek.putconbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putconbound{T1,T3,T4}(task:: MSKtask,i:: T1,bk:: Boundkey,bl:: T3,bu:: T4)
putconbound(task_:: MSKtask,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint.</li><li><code>bk :: Boundkey</code>. New bound key.</li><li><code>bl :: Float64</code>. New lower bound.</li><li><code>bu :: Float64</code>. New upper bound.</li></ul><p>Changes the bounds for one constraint.</p><p>If the bound value specified is numerically larger than <code>MSK_DPAR_DATA_TOL_BOUND_INF</code><code>it is considered infinite and the bound key is changed accordingly. If a bound value is numerically larger than</code>MSK<em>DPAR</em>DATA<em>TOL</em>BOUND_WRN``, a warning will be displayed, but the bound is inputted as specified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putconboundlist" href="#Mosek.putconboundlist"><code>Mosek.putconboundlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putconboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bk:: Vector{Boundkey},bl:: Vector{T3},bu:: Vector{T4})
putconboundlist(task_:: MSKtask,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sub :: Vector{Int32}</code>. List of constraint indexes.</li><li><code>bk :: Vector{Int32}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Changes the bounds for a list of constraints. If multiple bound changes are specified for a constraint, then only the last change takes effect. Data checks are performed as in <code>Mosek.putconbound</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putconboundslice" href="#Mosek.putconboundslice"><code>Mosek.putconboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putconboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
putconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Int32}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Changes the bounds for a slice of the constraints. Data checks are performed as in <code>Mosek.putconbound</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putcone" href="#Mosek.putcone"><code>Mosek.putcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putcone{T1,T3,T4}(task:: MSKtask,k:: T1,ct:: Conetype,conepar:: T3,submem:: Vector{T4})
putcone(task_:: MSKtask,k_:: Int32,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. Index of the cone.</li><li><code>ct :: Conetype</code>. Specifies the type of the cone.</li><li><code>conepar :: Float64</code>. This argument is currently not used. It can be set to 0</li><li><code>submem :: Vector{Int32}</code>. Variable subscripts of the members in the cone.</li></ul><p>Replaces a conic constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putconename" href="#Mosek.putconename"><code>Mosek.putconename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putconename{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
putconename(task_:: MSKtask,j_:: Int32,name_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the cone.</li><li><code>name :: String</code>. The name of the cone.</li></ul><p>Sets the name of a cone.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putconname" href="#Mosek.putconname"><code>Mosek.putconname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putconname{T1}(task:: MSKtask,i:: T1,name:: AbstractString)
putconname(task_:: MSKtask,i_:: Int32,name_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the constraint.</li><li><code>name :: String</code>. The name of the constraint.</li></ul><p>Sets the name of a constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putcslice" href="#Mosek.putcslice"><code>Mosek.putcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putcslice{T1,T2,T3}(task:: MSKtask,first:: T1,last:: T2,slice:: Vector{T3})
putcslice(task_:: MSKtask,first_:: Int32,last_:: Int32,slice_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First element in the slice of c.</li><li><code>last :: Int32</code>. Last element plus 1 of the slice in c to be changed.</li><li><code>slice :: Vector{Float64}</code>. New numerical values for the objective coefficients that should be modified.</li></ul><p>Modifies a slice in the linear term <span>$c$</span> in the objective using the principle</p><div>\[ c_{\mathtt{j}} = \mathtt{slice[j-first]}, \mathcal{C}_q j=first,..,+1{last}\]</div><p>Data checks are performed as in <code>Mosek.putcj</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putdouparam" href="#Mosek.putdouparam"><code>Mosek.putdouparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putdouparam{T2}(task:: MSKtask,param:: Dparam,parvalue:: T2)
putdouparam(task_:: MSKtask,param_:: Dparam,parvalue_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Dparam</code>. Which parameter.</li><li><code>parvalue :: Float64</code>. Parameter value.</li></ul><p>Sets the value of a double parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putintparam" href="#Mosek.putintparam"><code>Mosek.putintparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putintparam{T2}(task:: MSKtask,param:: Iparam,parvalue:: T2)
putintparam(task_:: MSKtask,param_:: Iparam,parvalue_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Iparam</code>. Which parameter.</li><li><code>parvalue :: Int32</code>. Parameter value.</li></ul><p>Sets the value of an integer parameter.</p><p>.. msk_only:: java</p><p>Please notice that some parameters take values that are defined in Enum    classes. This function accepts only integer values, so to use e.g. the value    <code>MSK_ON</code>, is necessary to use the member <code>.value</code>. For example: ::</p><pre><code class="language-none">   task.putintparam(mosek.iparam.opf_write_problem, mosek.onoffkey.on.value)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putlicensecode" href="#Mosek.putlicensecode"><code>Mosek.putlicensecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putlicensecode{T1}(env:: MSKenv,code:: Vector{T1})
putlicensecode(env_:: MSKenv,code_:: Vector{Int32})</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>code :: Vector{Int32}</code>. A license key string.</li></ul><p>Input a runtime license code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putlicensedebug" href="#Mosek.putlicensedebug"><code>Mosek.putlicensedebug</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putlicensedebug{T1}(env:: MSKenv,licdebug:: T1)
putlicensedebug(env_:: MSKenv,licdebug_:: Int32)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>licdebug :: Int32</code>. Enable output of license check-out debug information.</li></ul><p>Enables debug information for the license system. If <code>licdebug</code> is non-zero, then MOSEK will print debug info regarding the license checkout.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putlicensepath" href="#Mosek.putlicensepath"><code>Mosek.putlicensepath</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putlicensepath(env_:: MSKenv,licensepath_:: AbstractString)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>licensepath :: String</code>. A path specifying where to search for the license.</li></ul><p>Set the path to the license file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putlicensewait" href="#Mosek.putlicensewait"><code>Mosek.putlicensewait</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putlicensewait{T1}(env:: MSKenv,licwait:: T1)
putlicensewait(env_:: MSKenv,licwait_:: Int32)</code></pre><ul><li><code>env :: MSKenv</code>. The MOSEK environment.</li><li><code>licwait :: Int32</code>. Enable waiting for a license.</li></ul><p>Control whether MOSEK should wait for an available license if no license is available. If <code>licwait</code> is non-zero, then MOSEK will wait for <code>licwait-1</code> milliseconds between each check for an available license.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumanz" href="#Mosek.putmaxnumanz"><code>Mosek.putmaxnumanz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumanz{T1}(task:: MSKtask,maxnumanz:: T1)
putmaxnumanz(task_:: MSKtask,maxnumanz_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumanz :: Int64</code>. New size of the storage reserved for storing the linear coefficient matrix.</li></ul><p>Sets the number of preallocated non-zero entries in <span>$A$</span>. </p><p>MOSEK stores only the non-zero elements in the linear coefficient matrix <span>$A$</span> and it  cannot predict how much storage is required to store <span>$A$</span>. Using this function it is possible to specify the number of non-zeros to preallocate for storing <span>$A$</span>.</p><p>If the number of non-zeros in the problem is known, it is a good idea to set <code>maxnumanz</code> slightly larger than this number, otherwise a rough estimate can be used. In general, if <span>$A$</span> is inputted in many small chunks, setting this value may speed up the data input phase.</p><p>It is not mandatory to call this function, since MOSEK will reallocate internal structures whenever it is necessary.</p><p>The function call has no effect if both <code>maxnumcon</code> and <code>maxnumvar</code> are zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumbarvar" href="#Mosek.putmaxnumbarvar"><code>Mosek.putmaxnumbarvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumbarvar{T1}(task:: MSKtask,maxnumbarvar:: T1)
putmaxnumbarvar(task_:: MSKtask,maxnumbarvar_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumbarvar :: Int32</code>. Number of preallocated symmetric matrix variables.</li></ul><p>Sets the number of preallocated symmetric matrix variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.</p><p>It is not mandatory to call this function. It only gives a hint about the amount of data to preallocate for efficiency reasons.</p><p>Please note that <code>maxnumbarvar</code> must be larger than the current number of symmetric matrix variables in the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumcon" href="#Mosek.putmaxnumcon"><code>Mosek.putmaxnumcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumcon{T1}(task:: MSKtask,maxnumcon:: T1)
putmaxnumcon(task_:: MSKtask,maxnumcon_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcon :: Int32</code>. Number of preallocated constraints in the optimization task.</li></ul><p>Sets the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.</p><p>It is never mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p><p>Please note that <code>maxnumcon</code> must be larger than the current number of constraints in the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumcone" href="#Mosek.putmaxnumcone"><code>Mosek.putmaxnumcone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumcone{T1}(task:: MSKtask,maxnumcone:: T1)
putmaxnumcone(task_:: MSKtask,maxnumcone_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcone :: Int32</code>. Number of preallocated conic constraints in the optimization task.</li></ul><p>Sets the number of preallocated conic constraints in the optimization task. When this number of conic constraints is reached MOSEK will automatically allocate more space for conic constraints.</p><p>It is not mandatory to call this function, since MOSEK will reallocate any internal structures whenever it is required.</p><p>Please note that <code>maxnumcon</code> must be larger than the current number of conic  constraints in the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumqnz" href="#Mosek.putmaxnumqnz"><code>Mosek.putmaxnumqnz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumqnz{T1}(task:: MSKtask,maxnumqnz:: T1)
putmaxnumqnz(task_:: MSKtask,maxnumqnz_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumqnz :: Int64</code>. Number of non-zero elements preallocated in quadratic coefficient matrices.</li></ul><p>Sets the number of preallocated non-zero entries in quadratic terms.</p><p>MOSEK stores only the non-zero elements in <span>$Q$</span>. Therefore, MOSEK cannot predict how much storage is required to store <span>$Q$</span>. Using this function it is possible to specify the number non-zeros to preallocate for storing <span>$Q$</span> (both objective and constraints).</p><p>It may be advantageous to reserve more non-zeros for <span>$Q$</span> than actually needed since it may improve the internal efficiency of MOSEK, however, it is never worthwhile to specify more than the double of the anticipated number of non-zeros in <span>$Q$</span>.</p><p>It is not mandatory to call this function, since MOSEK will reallocate internal structures whenever it is necessary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putmaxnumvar" href="#Mosek.putmaxnumvar"><code>Mosek.putmaxnumvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putmaxnumvar{T1}(task:: MSKtask,maxnumvar:: T1)
putmaxnumvar(task_:: MSKtask,maxnumvar_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumvar :: Int32</code>. Number of preallocated variables in the optimization task.</li></ul><p>Sets the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.</p><p>It is not mandatory to call this function. It only gives  a hint about the amount of data to preallocate for efficiency reasons.</p><p>Please note that <code>maxnumvar</code> must be larger than the current number of variables in the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putnadouparam" href="#Mosek.putnadouparam"><code>Mosek.putnadouparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putnadouparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
putnadouparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>parvalue :: Float64</code>. Parameter value.</li></ul><p>Sets the value of a named double parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putnaintparam" href="#Mosek.putnaintparam"><code>Mosek.putnaintparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putnaintparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
putnaintparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Int32)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>parvalue :: Int32</code>. Parameter value.</li></ul><p>Sets the value of a named integer parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putnastrparam" href="#Mosek.putnastrparam"><code>Mosek.putnastrparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putnastrparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>paramname :: String</code>. Name of a parameter.</li><li><code>parvalue :: String</code>. Parameter value.</li></ul><p>Sets the value of a named string parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putobjname" href="#Mosek.putobjname"><code>Mosek.putobjname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putobjname(task_:: MSKtask,objname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>objname :: String</code>. Name of the objective.</li></ul><p>Assigns a new name to the objective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putobjsense" href="#Mosek.putobjsense"><code>Mosek.putobjsense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putobjsense(task_:: MSKtask,sense_:: Objsense)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sense :: Objsense</code>. The objective sense of the task</li></ul><p>Sets the objective sense of the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putparam" href="#Mosek.putparam"><code>Mosek.putparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putparam(task_:: MSKtask,parname_:: AbstractString,parvalue_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>parname :: String</code>. Parameter name.</li><li><code>parvalue :: String</code>. Parameter value.</li></ul><p>Checks if <code>parname</code> is valid parameter name. If it is, the parameter is assigned the value specified by <code>parvalue</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putqcon" href="#Mosek.putqcon"><code>Mosek.putqcon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putqcon{T1,T2,T3,T4}(task:: MSKtask,qcsubk:: Vector{T1},qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
putqcon(task_:: MSKtask,qcsubk_:: Vector{Int32},qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>qcsubk :: Vector{Int32}</code>. Constraint subscripts for quadratic coefficients.</li><li><code>qcsubi :: Vector{Int32}</code>. Row subscripts for quadratic constraint matrix.</li><li><code>qcsubj :: Vector{Int32}</code>. Column subscripts for quadratic constraint matrix.</li><li><code>qcval :: Vector{Float64}</code>. Quadratic constraint coefficient values.</li></ul><p>Replace all quadratic entries in the constraints. The list of constraints has the form</p><div>\[ l_k^c \leq  \frac{1}{2} \sum_{i=0}^{+1{numvar}} \sum_{j=0}^{+1{numvar}} q_{ij}^k x_i x_j + \sum_{j=0}^{+1{numvar}} a_{kj} x_j \leq u_k^c, ~\  k=0,\ldots,m-1.\]</div><p>This function sets all the quadratic terms to zero and then performs the update:</p><div>\[ q_{\mathtt{qcsubi[t]},\mathtt{qcsubj[t]}}^{\mathtt{qcsubk[t]}} = q_{\mathtt{\mathtt{qcsubj[t]},qcsubi[t]}}^{\mathtt{qcsubk[t]}} = q_{\mathtt{\mathtt{qcsubj[t]},qcsubi[t]}}^{\mathtt{qcsubk[t]}}  + \mathtt{qcval[t]},\]</div><p>for <span>$t=1,\ldots,+1{numqcnz}$</span>.</p><p>Please note that:</p><ul><li>For large problems it is essential for the efficiency that the function <code>Mosek.putmaxnumqnz</code> is employed to pre-allocate space.</li><li>Only the lower triangular parts should be specified because the <span>$Q$</span> matrices are symmetric. Specifying entries where <span>$i &lt; j$</span> will result in an error. </li><li>Only non-zero elements should be specified.</li><li>The order in which the non-zero elements are specified is insignificant.</li><li>Duplicate elements are added together as shown above. Hence, it is usually not recommended to specify the same entry multiple times.</li></ul><p>For a code example see Section :ref:<code>doc.tutorial_qo</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putqconk" href="#Mosek.putqconk"><code>Mosek.putqconk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putqconk{T1,T2,T3,T4}(task:: MSKtask,k:: T1,qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
putqconk{T1}(task:: MSKtask,k:: T1,Qk:: SparseMatrixCSC{Float64})
putqconk(task_:: MSKtask,k_:: Int32,qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>k :: Int32</code>. The constraint in which the new quadratic elements are inserted.</li><li><code>qcsubi :: Vector{Int32}</code>. Row subscripts for quadratic constraint matrix.</li><li><code>qcsubj :: Vector{Int32}</code>. Column subscripts for quadratic constraint matrix.</li><li><code>qcval :: Vector{Float64}</code>. Quadratic constraint coefficient values.</li><li><code>Qk :: SparseMatrixCSC{Float64}</code>. The symmetric matrix 1/2 (Qk&#39; + Qk) is used</li></ul><p>Replaces all the quadratic entries in one constraint. This function performs the same operations as <code>Mosek.putqcon</code> but only with respect to constraint number <code>k</code> and it does not modify the other constraints. See the description of <code>Mosek.putqcon</code> for definitions and important remarks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putqobj" href="#Mosek.putqobj"><code>Mosek.putqobj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putqobj{T1,T2,T3}(task:: MSKtask,qosubi:: Vector{T1},qosubj:: Vector{T2},qoval:: Vector{T3})
putqobj(task:: MSKtask,Qk:: SparseMatrixCSC{Float64})
putqobj(task_:: MSKtask,qosubi_:: Vector{Int32},qosubj_:: Vector{Int32},qoval_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>qosubi :: Vector{Int32}</code>. Row subscripts for quadratic objective coefficients.</li><li><code>qosubj :: Vector{Int32}</code>. Column subscripts for quadratic objective coefficients.</li><li><code>qoval :: Vector{Float64}</code>. Quadratic objective coefficient values.</li><li><code>Qk :: SparseMatrixCSC{Float64}</code>. The symmetric matrix 1/2 (Qk&#39; + Qk) is used</li></ul><p>Replace all quadratic terms in the objective. If the objective has the form</p><div>\[ \frac{1}{2} \sum_{i=0}^{+1{numvar}} \sum_{j=0}^{+1{numvar}} q_{ij}^o x_i x_j + \sum_{j=0}^{+1{numvar}} c_{j} x_j + c^f\]</div><p>then this function sets all the quadratic terms to zero and then performs the update:</p><div>\[ q_{\mathtt{qosubi[t]},\mathtt{qosubj[t]}}^{o} = q_{\mathtt{\mathtt{qosubj[t]},qosubi[t]}}^{o} = q_{\mathtt{\mathtt{qosubj[t]},qosubi[t]}}^{o}  + \mathtt{qoval[t]},\]</div><p>for <span>$t=1,\ldots,+1{numqonz}$</span>.</p><p>See the description of <code>Mosek.putqcon</code> for important remarks and example.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putqobjij" href="#Mosek.putqobjij"><code>Mosek.putqobjij</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putqobjij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,qoij:: T3)
putqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32,qoij_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Row index for the coefficient to be replaced.</li><li><code>j :: Int32</code>. Column index for the coefficient to be replaced.</li><li><code>qoij :: Float64</code>. The new coefficient value.</li></ul><p>Replaces one coefficient in the quadratic term in the objective. The function performs the assignment</p><div>\[ q_{ij}^o = q_{ji}^o = \mathtt{qoij}.\]</div><p>Only the elements in the lower triangular part are accepted. Setting <span>$q_{ij}$</span> with <span>$j&gt;i$</span> will cause an error.</p><p>Please note that replacing all quadratic elements one by one is more computationally expensive than replacing them all at once. Use <code>Mosek.putqobj</code> instead whenever possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putskc" href="#Mosek.putskc"><code>Mosek.putskc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putskc(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>skc :: Vector{Int32}</code>. Status keys for the constraints.</li></ul><p>Sets the status keys for the constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putskcslice" href="#Mosek.putskcslice"><code>Mosek.putskcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skc:: Vector{Stakey})
putskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skc_:: Vector{Stakey})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>skc :: Vector{Int32}</code>. Status keys for the constraints.</li></ul><p>Sets the status keys for a slice of the constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putskx" href="#Mosek.putskx"><code>Mosek.putskx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putskx(task_:: MSKtask,whichsol_:: Soltype,skx_:: Vector{Stakey})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>skx :: Vector{Int32}</code>. Status keys for the variables.</li></ul><p>Sets the status keys for the scalar variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putskxslice" href="#Mosek.putskxslice"><code>Mosek.putskxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skx:: Vector{Stakey})
putskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skx_:: Vector{Stakey})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>skx :: Vector{Int32}</code>. Status keys for the variables.</li></ul><p>Sets the status keys for a slice of the variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putslc" href="#Mosek.putslc"><code>Mosek.putslc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putslc{T2}(task:: MSKtask,whichsol:: Soltype,slc:: Vector{T2})
putslc(task_:: MSKtask,whichsol_:: Soltype,slc_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li></ul><p>Sets the <span>$s_l^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putslcslice" href="#Mosek.putslcslice"><code>Mosek.putslcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putslcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slc:: Vector{T4})
putslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slc_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li></ul><p>Sets a slice of the <span>$s_l^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putslx" href="#Mosek.putslx"><code>Mosek.putslx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putslx{T2}(task:: MSKtask,whichsol:: Soltype,slx:: Vector{T2})
putslx(task_:: MSKtask,whichsol_:: Soltype,slx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li></ul><p>Sets the <span>$s_l^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putslxslice" href="#Mosek.putslxslice"><code>Mosek.putslxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putslxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slx:: Vector{T4})
putslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li></ul><p>Sets a slice of the <span>$s_l^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsnx" href="#Mosek.putsnx"><code>Mosek.putsnx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsnx{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
putsnx(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li></ul><p>Sets the <span>$s_n^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsnxslice" href="#Mosek.putsnxslice"><code>Mosek.putsnxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsnxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,snx:: Vector{T4})
putsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,snx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>snx :: Vector{Float64}</code>. Dual variables corresponding to the conic constraints on the variables.</li></ul><p>Sets a slice of the <span>$s_n^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsolution" href="#Mosek.putsolution"><code>Mosek.putsolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsolution{T5,T6,T7,T8,T9,T10,T11,T12}(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12})
putsolution(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>skc :: Vector{Int32}</code>. Status keys for the constraints.</li><li><code>skx :: Vector{Int32}</code>. Status keys for the variables.</li><li><code>skn :: Vector{Int32}</code>. Status keys for the conic constraints.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li><li><code>slc :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the constraints.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li><li><code>slx :: Vector{Float64}</code>. Dual variables corresponding to the lower bounds on the variables.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li><li><code>snx :: Vector{Float64}</code>. Dual variables corresponding to the conic constraints on the variables.</li></ul><p>Inserts a solution into the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsolutioni" href="#Mosek.putsolutioni"><code>Mosek.putsolutioni</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsolutioni{T2,T5,T6,T7,T8}(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype,sk:: Stakey,x:: T5,sl:: T6,su:: T7,sn:: T8)
putsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64,sn_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>accmode :: Accmode</code>. Defines whether solution information for a constraint or for a variable is modified.</li><li><code>i :: Int32</code>. Index of the constraint or variable.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sk :: Stakey</code>. Status key of the constraint or variable.</li><li><code>x :: Float64</code>. Solution value of the primal constraint or variable.</li><li><code>sl :: Float64</code>. Solution value of the dual variable associated with the lower bound.</li><li><code>su :: Float64</code>. Solution value of the dual variable associated with the upper bound.</li><li><code>sn :: Float64</code>. Solution value of the dual variable associated with the conic constraint.</li></ul><p>Sets the primal and dual solution information for a single constraint or variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsolutionyi" href="#Mosek.putsolutionyi"><code>Mosek.putsolutionyi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsolutionyi{T1,T3}(task:: MSKtask,i:: T1,whichsol:: Soltype,y:: T3)
putsolutionyi(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,y_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>i :: Int32</code>. Index of the dual variable.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>y :: Float64</code>. Solution value of the dual variable.</li></ul><p>Inputs the dual variable of a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putstrparam" href="#Mosek.putstrparam"><code>Mosek.putstrparam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putstrparam(task_:: MSKtask,param_:: Sparam,parvalue_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>param :: Sparam</code>. Which parameter.</li><li><code>parvalue :: String</code>. Parameter value.</li></ul><p>Sets the value of a string parameter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsuc" href="#Mosek.putsuc"><code>Mosek.putsuc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsuc{T2}(task:: MSKtask,whichsol:: Soltype,suc:: Vector{T2})
putsuc(task_:: MSKtask,whichsol_:: Soltype,suc_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li></ul><p>Sets the <span>$s_u^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsucslice" href="#Mosek.putsucslice"><code>Mosek.putsucslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsucslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,suc:: Vector{T4})
putsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,suc_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>suc :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the constraints.</li></ul><p>Sets a slice of the <span>$s_u^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsux" href="#Mosek.putsux"><code>Mosek.putsux</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsux{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
putsux(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li></ul><p>Sets the <span>$s_u^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putsuxslice" href="#Mosek.putsuxslice"><code>Mosek.putsuxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putsuxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,sux:: Vector{T4})
putsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,sux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>sux :: Vector{Float64}</code>. Dual variables corresponding to the upper bounds on the variables.</li></ul><p>Sets a slice of the <span>$s_u^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.puttaskname" href="#Mosek.puttaskname"><code>Mosek.puttaskname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">puttaskname(task_:: MSKtask,taskname_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>taskname :: String</code>. Name assigned to the task.</li></ul><p>Assigns a new name to the task.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvarbound" href="#Mosek.putvarbound"><code>Mosek.putvarbound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvarbound{T1,T3,T4}(task:: MSKtask,j:: T1,bk:: Boundkey,bl:: T3,bu:: T4)
putvarbound(task_:: MSKtask,j_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable.</li><li><code>bk :: Boundkey</code>. New bound key.</li><li><code>bl :: Float64</code>. New lower bound.</li><li><code>bu :: Float64</code>. New upper bound.</li></ul><p>Changes the bounds for one variable.</p><p>If the bound value specified is numerically larger than <code>MSK_DPAR_DATA_TOL_BOUND_INF</code><code>it is considered infinite and the bound key is changed accordingly. If a bound value is numerically larger than</code>MSK<em>DPAR</em>DATA<em>TOL</em>BOUND_WRN``, a warning will be displayed, but the bound is inputted as specified.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvarboundlist" href="#Mosek.putvarboundlist"><code>Mosek.putvarboundlist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvarboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkx:: Vector{Boundkey},blx:: Vector{T3},bux:: Vector{T4})
putvarboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>sub :: Vector{Int32}</code>. List of variable indexes.</li><li><code>bkx :: Vector{Int32}</code>. Bound keys for the variables.</li><li><code>blx :: Vector{Float64}</code>. Lower bounds for the variables.</li><li><code>bux :: Vector{Float64}</code>. Upper bounds for the variables.</li></ul><p>Changes the bounds for one or more variables. If multiple bound changes are specified for a variable, then only the last change takes effect. Data checks are performed as in <code>Mosek.putvarbound</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvarboundslice" href="#Mosek.putvarboundslice"><code>Mosek.putvarboundslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvarboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
putvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>bk :: Vector{Int32}</code>. Bound keys.</li><li><code>bl :: Vector{Float64}</code>. Values for lower bounds.</li><li><code>bu :: Vector{Float64}</code>. Values for upper bounds.</li></ul><p>Changes the bounds for a slice of the variables. Data checks are performed as in <code>Mosek.putvarbound</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvarname" href="#Mosek.putvarname"><code>Mosek.putvarname</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
putvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable.</li><li><code>name :: String</code>. The variable name.</li></ul><p>Sets the name of a variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvartype" href="#Mosek.putvartype"><code>Mosek.putvartype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvartype{T1}(task:: MSKtask,j:: T1,vartype:: Variabletype)
putvartype(task_:: MSKtask,j_:: Int32,vartype_:: Variabletype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>j :: Int32</code>. Index of the variable.</li><li><code>vartype :: Variabletype</code>. The new variable type.</li></ul><p>Sets the variable type of one variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putvartypelist" href="#Mosek.putvartypelist"><code>Mosek.putvartypelist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putvartypelist{T1}(task:: MSKtask,subj:: Vector{T1},vartype:: Vector{Variabletype})
putvartypelist(task_:: MSKtask,subj_:: Vector{Int32},vartype_:: Vector{Variabletype})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subj :: Vector{Int32}</code>. A list of variable indexes for which the variable type should be changed.</li><li><code>vartype :: Vector{Int32}</code>. A list of variable types.</li></ul><p>Sets the variable type for one or more variables. If the same index is specified multiple times in <code>subj</code> only the last entry takes effect.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putxc" href="#Mosek.putxc"><code>Mosek.putxc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xc = putxc(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li></ul><p>Sets the <span>$x^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putxcslice" href="#Mosek.putxcslice"><code>Mosek.putxcslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putxcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xc:: Vector{T4})
putxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xc_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>xc :: Vector{Float64}</code>. Primal constraint solution.</li></ul><p>Sets a slice of the <span>$x^c$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putxx" href="#Mosek.putxx"><code>Mosek.putxx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putxx{T2}(task:: MSKtask,whichsol:: Soltype,xx:: Vector{T2})
putxx(task_:: MSKtask,whichsol_:: Soltype,xx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li></ul><p>Sets the <span>$x^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putxxslice" href="#Mosek.putxxslice"><code>Mosek.putxxslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putxxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xx:: Vector{T4})
putxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xx_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>xx :: Vector{Float64}</code>. Primal variable solution.</li></ul><p>Obtains a slice of the <span>$x^x$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.puty" href="#Mosek.puty"><code>Mosek.puty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">puty{T2}(task:: MSKtask,whichsol:: Soltype,y:: Vector{T2})
puty(task_:: MSKtask,whichsol_:: Soltype,y_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li></ul><p>Sets the <span>$y$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putyslice" href="#Mosek.putyslice"><code>Mosek.putyslice</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putyslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,y:: Vector{T4})
putyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,y_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>first :: Int32</code>. First index in the sequence.</li><li><code>last :: Int32</code>. Last index plus 1 in the sequence.</li><li><code>y :: Vector{Float64}</code>. Vector of dual variables corresponding to the constraints.</li></ul><p>Sets a slice of the <span>$y$</span> vector for a solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readdata" href="#Mosek.readdata"><code>Mosek.readdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readdata(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Reads an optimization problem and associated data from a file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readdataformat" href="#Mosek.readdataformat"><code>Mosek.readdataformat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readdataformat(task_:: MSKtask,filename_:: AbstractString,format_:: Dataformat,compress_:: Compresstype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li><li><code>format :: Dataformat</code>. File data format.</li><li><code>compress :: Compresstype</code>. File compression type.</li></ul><p>Reads an optimization problem and associated data from a file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readparamfile" href="#Mosek.readparamfile"><code>Mosek.readparamfile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readparamfile(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Reads MOSEK parameters from a file. Data is read from the file <code>filename</code> if it is a nonempty string. Otherwise data is read from the file specified by :msk:sparam:<code>param_read_file_name</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readsolution" href="#Mosek.readsolution"><code>Mosek.readsolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readsolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Reads a solution file and inserts it as a specified solution in the task. Data is read from the file <code>filename</code> if it is a nonempty string. Otherwise data is read from one of the files specified by :msk:sparam:<code>bas_sol_file_name</code>, :msk:sparam:<code>itr_sol_file_name</code> or :msk:sparam:<code>int_sol_file_name</code> depending on which solution is chosen.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readsummary" href="#Mosek.readsummary"><code>Mosek.readsummary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readsummary(task_:: MSKtask,whichstream_:: Streamtype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li></ul><p>Prints a short summary of last file that was read.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.readtask" href="#Mosek.readtask"><code>Mosek.readtask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readtask(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Load task data from a file, replacing any data that already exists in the task object. All problem data, parameters and other settings are resorted, but if the file contains solutions, the solution status after loading a file is set to unknown, even if it was optimal or otherwise well-defined when the file was dumped.</p><p>See section :ref:<code>doc.shared.taskformat</code> for a description of the Task format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.removebarvars" href="#Mosek.removebarvars"><code>Mosek.removebarvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">removebarvars{T1}(task:: MSKtask,subset:: Vector{T1})
removebarvars(task_:: MSKtask,subset_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subset :: Vector{Int32}</code>. Indexes of symmetric matrices which should be removed.</li></ul><p>The function removes a subset of the symmetric matrices  from the optimization task. This implies that the remaining symmetric matrices are renumbered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.removecones" href="#Mosek.removecones"><code>Mosek.removecones</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">removecones{T1}(task:: MSKtask,subset:: Vector{T1})
removecones(task_:: MSKtask,subset_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subset :: Vector{Int32}</code>. Indexes of cones which should be removed.</li></ul><p>Removes a number of conic constraints from the problem. This implies that the remaining conic constraints are renumbered. In general, it is much more efficient to remove a cone with a high index than a low index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.removecons" href="#Mosek.removecons"><code>Mosek.removecons</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">removecons{T1}(task:: MSKtask,subset:: Vector{T1})
removecons(task_:: MSKtask,subset_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subset :: Vector{Int32}</code>. Indexes of constraints which should be removed.</li></ul><p>The function removes a subset of the constraints  from the optimization task. This implies that the remaining constraints are renumbered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.removevars" href="#Mosek.removevars"><code>Mosek.removevars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">removevars{T1}(task:: MSKtask,subset:: Vector{T1})
removevars(task_:: MSKtask,subset_:: Vector{Int32})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>subset :: Vector{Int32}</code>. Indexes of variables which should be removed.</li></ul><p>The function removes a subset of the variables  from the optimization task. This implies that the remaining variables are renumbered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.resizetask" href="#Mosek.resizetask"><code>Mosek.resizetask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resizetask{T1,T2,T3,T4,T5}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,maxnumcone:: T3,maxnumanz:: T4,maxnumqnz:: T5)
resizetask(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,maxnumcone_:: Int32,maxnumanz_:: Int64,maxnumqnz_:: Int64)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>maxnumcon :: Int32</code>. New maximum number of constraints.</li><li><code>maxnumvar :: Int32</code>. New maximum number of variables.</li><li><code>maxnumcone :: Int32</code>. New maximum number of cones.</li><li><code>maxnumanz :: Int64</code>. New maximum number of linear non-zero elements.</li><li><code>maxnumqnz :: Int64</code>. New maximum number of quadratic non-zeros elements.</li></ul><p>Sets the amount of preallocated space assigned for each type of data in an optimization task.</p><p>It is never mandatory to call this function, since it only gives  a hint about the amount of data to preallocate for efficiency reasons.</p><p>Please note that the procedure is <strong>destructive</strong> in the sense that all existing data stored in the task is destroyed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.sensitivityreport" href="#Mosek.sensitivityreport"><code>Mosek.sensitivityreport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sensitivityreport(task_:: MSKtask,whichstream_:: Streamtype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li></ul><p>Reads a sensitivity format file from a location given by :msk:sparam:<code>sensitivity_file_name</code> and writes the result to the stream <code>whichstream</code>. If :msk:sparam:<code>sensitivity_res_file_name</code> is set to a non-empty string, then the sensitivity report is also written to a file of this name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.setdefaults" href="#Mosek.setdefaults"><code>Mosek.setdefaults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setdefaults(task_:: MSKtask)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li></ul><p>Resets all the parameters to their default values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.solutiondef" href="#Mosek.solutiondef"><code>Mosek.solutiondef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdef = solutiondef(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>isdef :: Bool</code>. Is non-zero if the requested solution is defined.</li></ul><p>Checks whether a solution is defined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.solutionsummary" href="#Mosek.solutionsummary"><code>Mosek.solutionsummary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solutionsummary(task_:: MSKtask,whichstream_:: Streamtype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichstream :: Streamtype</code>. Index of the stream.</li></ul><p>Prints a short summary of the current solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.solvewithbasis" href="#Mosek.solvewithbasis"><code>Mosek.solvewithbasis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numnz = solvewithbasis{T1,T2,T3,T4}(task:: MSKtask,transp:: T1,numnz:: T2,sub:: Vector{T3},val:: Vector{T4})
numnz = solvewithbasis(task_:: MSKtask,transp_:: Int32,numnz_:: Int32,sub_:: Vector{Int32},val_:: Vector{Float64})</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>transp :: Int32</code>. Controls which problem formulation is solved.</li><li><code>numnz :: Int32</code>. Input (number of non-zeros in right-hand side) and output (number of non-zeros in solution vector).</li><li><code>sub :: Vector{Int32}</code>. Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).</li><li><code>val :: Vector{Float64}</code>. Input (right-hand side values) and output (solution vector values).</li></ul><p>If a basic solution is available, then exactly <span>$numcon$</span> basis variables are defined.  These <span>$numcon$</span> basis variables are denoted the basis.  Associated with the basis is a basis matrix denoted <span>$B$</span>.  This function solves either the linear equation system</p><div>\[:label: ais-eq-Bxb

B \bar X = b                       \]</div><p>or the system</p><div>\[:label: ais-eq-Btxb

B^T \bar X = b\]</div><p>for the unknowns <span>$\bar X$</span>, with <span>$b$</span> being a user-defined  vector.                     In order to make sense of the solution <span>$\bar X$</span> it is important to know the ordering of the variables in the basis because the ordering specifies how <span>$B$</span> is constructed. When calling <code>Mosek.initbasissolve</code> an ordering of the basis variables is obtained, which can be used to deduce how MOSEK has constructed <span>$B$</span>. Indeed if the <span>$k$</span>-th basis variable is variable <span>$x_j$</span> it implies that</p><div>\[ B_{i,k} = A_{i,j}, ~i=1,\ldots,+1{numcon}.\]</div><p>Otherwise if the <span>$k$</span>-th basis variable is variable <span>$x_j^c$</span> it implies that</p><div>\[B_{i,k} = \left\{ \begin{array}{ll}
                        -1, &amp; i = j, \\
                        0 , &amp; i \neq j. \\
                    \end{array} 
            \right.\]</div><p>The function <code>Mosek.initbasissolve</code> must be called before a call to this function. Please note that this function exploits the sparsity in the vector <span>$b$</span> to speed up the computations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.strtoconetype" href="#Mosek.strtoconetype"><code>Mosek.strtoconetype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">conetype = strtoconetype(task_:: MSKtask,str_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>str :: String</code>. String corresponding to the cone type code.</li><li><code>conetype :: Conetype</code>. The cone type corresponding to str.</li></ul><p>Obtains cone type code corresponding to a cone type string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.strtosk" href="#Mosek.strtosk"><code>Mosek.strtosk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sk = strtosk(task_:: MSKtask,str_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>str :: String</code>. Status key string.</li><li><code>sk :: Int32</code>. Status key corresponding to the string.</li></ul><p>Obtains the status key corresponding to an explanatory string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.updatesolutioninfo" href="#Mosek.updatesolutioninfo"><code>Mosek.updatesolutioninfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updatesolutioninfo(task_:: MSKtask,whichsol_:: Soltype)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li></ul><p>Update the information items related to the solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.writedata" href="#Mosek.writedata"><code>Mosek.writedata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writedata(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Writes problem data associated with the optimization task to a file in one of the supported formats. See Section :ref:<code>doc.shared.file_formats</code> for the complete list.</p><p>By default the data file format is determined by the file name extension. This behaviour can be overridden by setting the <code>MSK_IPAR_WRITE_DATA_FORMAT</code><code>parameter. To write in compressed format append the extension</code>.gz<code>.  E.g to write a gzip compressed MPS file use the extension</code>mps.gz`.</p><p>Please note that MPS, LP and OPF files require all variables to have unique names. If a task contains no names, it is possible to write the file with automatically generated anonymous names by setting the <code>MSK_IPAR_WRITE_GENERIC_NAMES</code><code>parameter to</code>MSK_ON`.</p><p>Data is written to the file <code>filename</code> if it is a nonempty string. Otherwise data is written to the file specified by :msk:sparam:<code>data_file_name</code>.</p><p>Please note that if a general nonlinear function appears in the problem then such function <em>cannot</em> be written to file and MOSEK will issue a warning.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.writejsonsol" href="#Mosek.writejsonsol"><code>Mosek.writejsonsol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writejsonsol(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Saves the current solutions and solver information items in a JSON file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.writeparamfile" href="#Mosek.writeparamfile"><code>Mosek.writeparamfile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writeparamfile(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Writes all the parameters to a parameter file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.writesolution" href="#Mosek.writesolution"><code>Mosek.writesolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writesolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>whichsol :: Soltype</code>. Selects a solution.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Saves the current basic, interior-point, or integer solution to a file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.writetask" href="#Mosek.writetask"><code>Mosek.writetask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writetask(task_:: MSKtask,filename_:: AbstractString)</code></pre><ul><li><code>task :: MSKtask</code>. An optimization task.</li><li><code>filename :: String</code>. A valid file name.</li></ul><p>Write a binary dump of the task data. This format saves all problem data, coefficients and parameter settings but does not save callback functions and general non-linear terms.</p><p>See section :ref:<code>doc.shared.taskformat</code> for a description of the Task format.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Index</span></a><a class="next" href="../geco/"><span class="direction">Next</span><span class="title">General Convex API</span></a></footer></article></body></html>
