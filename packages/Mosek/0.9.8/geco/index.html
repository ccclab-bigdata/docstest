<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General Convex API · Mosek</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Mosek</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li><a class="toctext" href="../Mosek-Functions/">API Reference</a></li><li class="current"><a class="toctext" href>General Convex API</a><ul class="internal"></ul></li><li><a class="toctext" href="../parameters/">Solver parameters</a></li><li><a class="toctext" href="../enums/">Symbolic values</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>General Convex API</a></li></ul></nav><hr/><div id="topbar"><span>General Convex API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="General-Convex-interface-1" href="#General-Convex-interface-1">General Convex interface</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.putnlcallbacks" href="#Mosek.putnlcallbacks"><code>Mosek.putnlcallbacks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">putnlcallbacks(task::MSKtask,
               grdobjsub :: Vector{Int},
               grdconsub :: Vector{Int},
               grdconptr :: Vector{Int},
               hessubi   :: Vector{Int},
               hessubj   :: Vector{Int},
               evalobj   :: Function,
               evalconi  :: Function,
               grdlag    :: Function,
               grdobj    :: Function,
               grdconi   :: Function,
               heslag    :: Function)</code></pre><p>This sets up the structure of the non-linear terms and sets the non-linear callback functions.</p><ul><li><code>grdobjsub</code> The subscripts of the variables that appear in non-linear terms in the objective.</li><li><code>grdconsub</code> The subscripts of the variables that appear in constraints. </li><li><code>grdconptr</code> Defines the positions in <code>grdconsub</code> where rows begin, so that <code>grdconsub[grdconptr[i]]</code> is the index of the first non-linear variable in constraint <code>i</code>. </li><li><code>hessubi</code> Row subscripts of the non-zero elements of the Hessian of the Lagrangian. This matrix is symmetrix and only elements in the lower triangular should be inputted.</li><li><code>hessubj</code> Column subscripts of the non-zero elements of the Hessian of the Lagrangian. This matrix is symmetrix and only elements in the lower triangular should be inputted.</li><li><code>evalobj</code> Function that evaluates the non-linear part of the objective at a given point. See below.</li><li><code>evalconi</code> Function that evaluates the non-linear part of a constraint at a given point. See below.</li><li><code>grdlag</code> Function that evaluates the gradient of the Lagrangian at a given point. See below.</li><li><code>grdobj</code> Function that evluates the gradient of the objective at a given point. See below.</li><li><code>grdconi</code> Function that evaluates the gradient of a constraint at a given point. See below.</li><li><code>heslag</code> Function that evaluates the Hessian of the Lagrangian at a given point. See below.</li></ul><p>The Lagrangian of the non-linear part of the problem has the following form:</p><div>\[\mathcal{L}(x,yo,yc) = \mbox{yo}\cdot f_0(x) + \sum^m_{i=1} \mbox{yc}_i\cdot f_i(x)\]</div><p>It is the first and second derivatives of this that should be computed. The following sections show the form of the callback functions. </p><p><strong>evalobj</strong></p><pre><code class="language-none">function evalobj(x::Vector{Float64}) -&gt; Float64</code></pre><p>Evaluate the non-linear part of the objective at the point <code>x</code>.</p><p><strong>evalconi</strong></p><pre><code class="language-none">function evalconi(x:: Vector{Float64},i:: Int32) -&gt; Float64</code></pre><p>Evaluate the non-linear part of constraint <code>i</code> at the point <code>x</code>.</p><p><strong>grdlag</strong></p><pre><code class="language-none">function grdlag
( x   :: Vector{Float64},
  yo  :: Float64,
  yc  :: Vector{Float64},
  subi:: Vector{Int32},
  val :: Vector{Float64} )</code></pre><p>Evaluate the gradient of the Lagrangian</p><div>\[\mbox{yo}\cdot f_0&#39;(x) + \sum_i \mbox{yc}_i f_{\mbox{subi}[i]}&#39;(x)\]</div><p>Evaluate the gradient of the Lagrangian at the point <code>x</code>. Here</p><ul><li><code>x</code> is the point where the function should be evaluated.</li><li><code>yo</code> the multiplier for the objective gradient</li><li><code>subi</code> the indexes of the constraints that should be included in the Lagrangian</li><li><code>yc</code> the multipliers for the constraints that should be included in the Lagrangian</li><li><code>val</code> a vector of length <code>numvar</code> where the gradient values are returned. Only the non-zero places should be overwritten.</li></ul><p><strong>grdobj</strong></p><pre><code class="language-none">function grdobj
( x  :: Vector{Float64},
  sub:: Vector{Int32}, 
  val:: Vector{Float64} )</code></pre><p>Evaluate the gradient of <span>$f_0$</span>:</p><div>\[\mbox{val}[k] \leftarrow \frac{d}{dx_{\mbox{sub}[k]}} f_0&#39;(x)\]</div><ul><li><code>x</code> is the point where the function should be evaluated</li><li><code>sub</code> the variable subscripts corresponding to the non-zero places in the objective</li><li><code>val</code> the array that return the gradient values</li></ul><p><strong>grdconi</strong></p><pre><code class="language-none">function grdconi
( x  :: Vector{Float64},
  i  :: Int32, 
  sub:: Vector{Int32}, 
  val:: Vector{Float64})</code></pre><p>Evaluate the gradient of :math:<code>f_i</code>:</p><div>\[\mbox{val}[k] \leftarrow \frac{d}{dx_{\mbox{sub}[k]}} f_i&#39;(x)\]</div><ul><li><code>x</code> is the point where the function should be evaluated</li><li><code>i</code> the constraint index </li><li><code>sub</code> the variable subscripts corresponding to the non-zero places in the constraint</li><li><code>val</code> the array that return the gradient values</li></ul><p><strong>heslag</strong></p><pre><code class="language-none">function heslag
( x ::      Vector{Float64},
  yo::      Float64,
  yc::      Vector{Float64},
  subi::    Vector{Int32},
  hessubi:: Vector{Int32},
  hessubj:: Vector{Int32},
  hesval::  Vector{Float64})</code></pre><p>Evaluate the Hessian of the Lagrangian:</p><div>\[\frac{d^2}{dx^2} \mathcal{L}(x,yo,yc)\]</div><p>Note that the Hessian is symmetric. Only elements from the lower triangular part should be inputted, i.e. all elements</p><div>\[\frac{d^2}{dx_idx_j} \mathcal{L}(x,yo,yc),~ j\leq i\]</div><ul><li><code>x</code> is the point where the function should be evaluated.</li><li><code>yo</code> the multiplier for the objective gradient</li><li><code>subi</code> the indexes of the constraints that should be included in the Lagrangian</li><li><code>yc</code> the multipliers for the constraints that should be included in the Lagrangian</li><li><code>hessubi</code> row subscripts of the non-zeros</li><li><code>hessubj</code> column subscripts of the non-zeros</li><li><code>hesval</code> non-zero values of the Hessian</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Mosek.clearnlcallbacks" href="#Mosek.clearnlcallbacks"><code>Mosek.clearnlcallbacks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clearnlcallbacks(task::MSKtask)</code></pre><p>Remove all non-linear callbacks from the problem.</p></div></div></section><footer><hr/><a class="previous" href="../Mosek-Functions/"><span class="direction">Previous</span><span class="title">API Reference</span></a><a class="next" href="../parameters/"><span class="direction">Next</span><span class="title">Solver parameters</span></a></footer></article></body></html>
