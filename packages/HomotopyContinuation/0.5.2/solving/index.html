<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving Polynomial Systems · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Solving Polynomial Systems</a><ul class="internal"><li><a class="toctext" href="#The-*solve*-function-1">The <em>solve</em> function</a></li><li><a class="toctext" href="#The-result-of-*solve*-1">The result of <em>solve</em></a></li><li><a class="toctext" href="#Monodromy-Solve-1">Monodromy Solve</a></li></ul></li><li><a class="toctext" href="../systems/">Systems</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../predictors-correctors/">Predictors and Correctors</a></li><li><a class="toctext" href="../pathtracking/">Path tracker</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solving Polynomial Systems</a></li></ul></nav><hr/><div id="topbar"><span>Solving Polynomial Systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solving-Polynomial-Systems-1" href="#Solving-Polynomial-Systems-1">Solving Polynomial Systems</a></h1><p>At the heart of the package is the <a href="#HomotopyContinuation.solve"><code>solve</code></a> function. It takes a bunch of different input combinations and returns an <a href="#HomotopyContinuation.AffineResult"><code>AffineResult</code></a> or <a href="#HomotopyContinuation.ProjectiveResult"><code>ProjectiveResult</code></a> depending on the input.</p><p>The <code>solve</code> function works in 3 stages.</p><ol><li><p>It takes the input and constructs a homotopy <span>$H(x,t)$</span> such that <span>$H(x,1)=G(x)$</span> and <span>$H(x,0)=F(x)$</span> as well as start solutions <span>$\mathcal{X}$</span> where for all <span>$x_1 ∈ \mathcal{X}$</span> we have <span>$H(x_1, 1) ≈ 0$</span>. This step highly depends on the concrete input you provide.</p></li><li><p>Then all start solutions <span>$x(1) = x_1 ∈ \mathcal{X}$</span> will be tracked to solutions <span>$x({t_e})$</span> such that <span>$H(x({t_e}), t_e) ≈ 0$</span> using a predictor-corrector scheme where <span>$t_e$</span> is a value between <span>$0$</span> and <span>$1$</span> (by default <span>$0.1$</span>).</p></li><li><p>From these intermediate solutions <span>$x({t_e})$</span> we start the so called <em>endgame</em>. This is an algorithm to predict the value <span>$x(0)$</span> for each intermediate solution.</p></li></ol><p>The reason for step 3 is that the final solutions can be singular which provides significant challenges for our gradient based predictor-corrector methods. For more background also check the <a href="http://localhost:1313/faq/">FAQ</a>.</p><h2><a class="nav-anchor" id="The-*solve*-function-1" href="#The-*solve*-function-1">The <em>solve</em> function</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solve" href="#HomotopyContinuation.solve"><code>HomotopyContinuation.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve(F; options...)</code></pre><p>Solve the system <code>F</code> using a total degree homotopy. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li><a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a> (the system has to represent a <strong>homogenous</strong> polynomial system.)</li></ul><p><strong>Example</strong></p><p>Assume we want to solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span>.</p><pre><code class="language-julia">@polyvar x y
solve([x^2+y^2+1, 2x+3y-1])</code></pre><p>If you polynomial system is already homogenous, but you would like to consider it as an affine system you can do</p><pre><code class="language-julia">@polyvar x y z
solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)</code></pre><p>This would result in the same result as <code>solve([x^2+y^2+1, 2x+3y-1])</code>.</p><p>To solve <span>$F$</span> by a custom <code>AbstractSystem</code> you can do</p><pre><code class="language-julia">@polyvar x y z
# The system `F` has to be homgoenous system
F = SPSystem([x^2+y^2+z^2, 2x+3y-z]) # SPSystem &lt;: AbstractSystem
# To solve the original affine system we have to tell that the homogenization variable has index 3
solve(F, homvar=3)</code></pre><p>or equivalently (in this case) by</p><pre><code class="language-julia">solve([x^2+y^2+z^2, 2x+3y-z], system=SPSystem)</code></pre><p><strong>Start Target Homotopy</strong></p><pre><code class="language-none">solve(G, F, start_solutions; options...)</code></pre><p>Solve the system <code>F</code> by tracking the each provided solution of <code>G</code> (as provided by <code>start_solutions</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia">@polyvar x y
G = [x^2-1,y-1]
F = [x^2+y^2+z^2, 2x+3y-z]
solve(G, F, [[1, 1], [-1, 1]])</code></pre><p><strong>Parameter Homotopy</strong></p><pre><code class="language-none">solve(F::Vector{&lt;:MultivariatePolynomials.AbstractPolynomial},
    startsolutions; parameters::Vector{&lt;:MP.AbstractVariable}, p₁, p₀, γ₁=nothing, γ₀=nothing)</code></pre><p>Solve the parameter homotopy</p><div>\[H(x, t) = F(x, (tγ₁p₁+(1-t)γ₀p₀) / (tγ₁+(1-t)γ₀))\]</div><p>, where <code>p₁</code> and <code>p₀</code> are a vector of parameter values for <span>$F$</span> and <code>γ₁</code> and <code>γ₀</code> are complex numbers. If <code>γ₁</code> or <code>γ₀</code> is <code>nothing</code>, it is assumed that <code>γ₁</code> and <code>γ₀</code> are <span>$1$</span>. The input <code>parameters</code> specifies the parameter variables of <code>F</code> which should be considered as parameters. Neccessarily, <span>$length(parameters) == length(p₁) == length(p₀)$</span>.</p><pre><code class="language-none">solve(F::Vector{&lt;:MultivariatePolynomials.AbstractPolynomial},
        startsolutions; parameters::Vector{&lt;:MP.AbstractVariable},
        startparameters, targetparameters,
        startgamma=randn(ComplexF64), targetgamma=randn(ComplexF64))</code></pre><p>This is a non-unicode variant where <code>γ₁=start_parameters</code>, <code>γ₀=target_parameters</code>,     <code>γ₁=start_gamma</code>, γ₀=<code>target_gamma</code>.</p><p><strong>Example</strong></p><p>We want to solve a parameter homotopy <span>$H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])$</span> where</p><div>\[F(x; a) := (x₁^2-a₁, x₁x₂-a₁+a₂)\]</div><p>and let&#39;s say we are only intersted in tracking of <span>$[1,1]$</span>. This can be accomplished as follows</p><pre><code class="language-julia">@polyvar x[1:2] a[1:2]
F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]
startsolutions = [[1, 1]]
solve(F, startsolutions, parameters=a, p₁=p₁, p₀=p₀)
# If you don&#39;t like unicode this is also possible
solve(F, startsolutions, parameters=a, startparameters=p₁, targetparameters=p₀)</code></pre><p><strong>Abstract Homotopy</strong></p><pre><code class="language-none">solve(H::AbstractHomotopy, start_solutions; options...)</code></pre><p>Solve the homotopy <code>H</code> by tracking the each solution of <span>$H(⋅, t)$</span> (as provided by <code>start_solutions</code>) from <span>$t=1$</span> to <span>$t=0$</span>. Note that <code>H</code> has to be a homotopy between <em>homogenous</em> polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. <code>solve(H, startsolutions, homvar=3)</code> if the third variable is the homogenization variable.</p><p><strong>Options</strong></p><p>General options:</p><ul><li><code>system::AbstractSystem</code>: A constructor to assemble a <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>. The default is <a href="../systems/#HomotopyContinuation.FPSystem"><code>FPSystem</code></a>. This constructor is only applied to the input of <code>solve</code>. The constructor is called with <code>system(polynomials, variables)</code> where <code>polynomials</code> is a vector of <code>MultivariatePolynomials.AbstractPolynomial</code>s and <code>variables</code> determines the variable ordering.</li><li><code>homotopy::AbstractHomotopy</code>: A constructor to construct a <a href="../homotopies/#HomotopyContinuation.AbstractHomotopy"><code>AbstractHomotopy</code></a>. The default is <a href="../homotopies/#HomotopyContinuation.StraightLineHomotopy"><code>StraightLineHomotopy</code></a>. The constructor is called with <code>homotopy(start, target)</code> where <code>start</code> and <code>target</code> are homogenous <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>s.</li><li><code>seed::Int</code>: The random seed used during the computations.</li><li><code>homvar::Union{Int,MultivariatePolynomials.AbstractVariable}</code>: This considers the <em>homogenous</em> system <code>F</code> as an affine system which was homogenized by <code>homvar</code>. If <code>F</code> is an <code>AbstractSystem</code> <code>homvar</code> is the index (i.e. <code>Int</code>) of the homogenization variable. If <code>F</code> is an <code>AbstractVariables</code> (e.g. created by <code>@polyvar x</code>) <code>homvar</code> is the actual variable used in the system <code>F</code>.</li><li><code>endgame_start=0.1</code>: The value of <code>t</code> for which the endgame is started.</li><li><code>report_progress=true</code>: Whether a progress bar should be printed to <code>STDOUT</code>.</li><li><code>threading=true</code>: Enable or disable multi-threading.</li></ul><p>Pathtracking specific:</p><ul><li><code>corrector::AbstractCorrector</code>: The corrector used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.Newton"><code>Newton</code></a>.</li><li><code>corrector_maxiters=2</code>: The maximal number of correction steps in a single step.</li><li><code>predictor::AbstractPredictor</code>: The predictor used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.Heun"><code>Heun</code></a>.</li><li><code>refinement_maxiters=corrector_maxiters</code>: The maximal number of correction steps used to refine the final value.</li><li><code>refinement_tol=1e-8</code>: The precision used to refine the final value.</li><li><code>tol=1e-7</code>: The precision used to track a value.</li><li><code>initial_steplength=0.1</code>: The initial step size for the predictor.</li><li><code>minimal_steplength=1e-14</code>: The minimal step size. If the size of step is below this the path is considered failed.</li><li><code>maxiters=1000</code>: The maximal number of steps per path.</li></ul><p>Endgame specific options</p><ul><li><code>cauchy_loop_closed_tolerance=1e-3</code>: The tolerance for which is used to determine whether a loop is closed. The distance between endpoints is normalized by the maximal difference between any point in the loop and the starting point.</li><li><code>cauchy_samples_per_loop=6</code>: The number of samples used to predict an endpoint. A higher number of samples should result in a better approximation. Note that the error should be roughly <span>$t^n$</span> where <span>$t$</span> is the current time of the loop and <span>$n$</span> is <code>cauchy_samples_per_loop</code>.</li><li><code>egtol=1e-10</code>: This is the tolerance necessary to declare the endgame converged.</li><li><code>maxnorm=1e5</code>: If our original problem is affine we declare a path at infinity if the infinity norm with respect to the standard patch is larger than <code>maxnorm</code>.</li><li><code>maxwindingnumber=15</code>: The maximal windingnumber we try to find using Cauchys integral formula.</li><li><code>max_extrapolation_samples=4</code>: During the endgame a Richardson extrapolation is used to improve the accuracy of certain approximations. This is the maximal number of samples used for this.</li><li><code>minradius=1e-15</code>: A path is declared false if the endgame didn&#39;t finished until then.</li><li><code>sampling_factor=0.5</code>: During the endgame we approach <span>$0$</span> by the geometric series <span>$h^kR₀$</span> where <span>$h$</span> is <code>sampling_factor</code> and <code>R₀</code> the endgame start provided in <code>runendgame</code>.</li><li><code>maxiters_per_step=100</code>: The maximal number of steps bewtween two samples.</li></ul></div></div></section><h2><a class="nav-anchor" id="The-result-of-*solve*-1" href="#The-result-of-*solve*-1">The result of <em>solve</em></a></h2><p>Depending on the input <code>solve</code> returns one of the following types</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.AffineResult" href="#HomotopyContinuation.AffineResult"><code>HomotopyContinuation.AffineResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AffineResult &lt;: Result</code></pre><p>The result of an (non-homogenous) system of polynomials.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.ProjectiveResult" href="#HomotopyContinuation.ProjectiveResult"><code>HomotopyContinuation.ProjectiveResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ProjectiveResult &lt;: Result</code></pre><p>The result of a homogenous system of polynomials.</p></div></div></section><p>A <code>Result</code> is a wrapper around the results of each single path (<a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>) and it contains some additional informations like the used random seed for the computation.</p><p>In order to analyze a <code>Result</code> we provide the following helper functions</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.results" href="#HomotopyContinuation.results"><code>HomotopyContinuation.results</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">results(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, onlysigular=false, singulartol=1e14, onlyfinite=true)</code></pre><p>Return all <code>PathResult</code>s for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">R = solve(F)

# This gives us all PathResults considered non-singular and real (but still as a complex vector).
realsolutions = results(R, onlyreal=true, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.mapresults" href="#HomotopyContinuation.mapresults"><code>HomotopyContinuation.mapresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapresults(f::Function, result; conditions...)</code></pre><p>Apply the function <code>f</code> to all <code>PathResult</code>s for which the given conditions apply. For the possible conditions see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
realsolutions = results(solution, R, onlyreal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solutions" href="#HomotopyContinuation.solutions"><code>HomotopyContinuation.solutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solutions(result; conditions...)</code></pre><p>Return all solution (as <code>Vector</code>s) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; solutions(result)
[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]</code></pre></div></div><div><div><pre><code class="language-none">solutions(loop::Loop)</code></pre><p>Get the solutions of the loop.</p></div></div><div><div><pre><code class="language-none">solutions(result::MonodromyResult)</code></pre><p>Returns the solutions of the <code>result</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.realsolutions" href="#HomotopyContinuation.realsolutions"><code>HomotopyContinuation.realsolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">realsolutions(result; tol=1e-6, conditions...)</code></pre><p>Return all real solution (as <code>Vector</code>s of reals) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>. Note that <code>onlyreal</code> is always <code>true</code> and <code>realtol</code> is now <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; realsolutions(result)
[[2.0, -5.0], [-3.0, 0.0]]</code></pre></div></div><div><div><pre><code class="language-none">realsolutions(res::MonodromyResult; tol = 1e-6)</code></pre><p>Returns the solutions of <code>res</code> whose imaginary part has norm &lt; 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.uniquesolutions" href="#HomotopyContinuation.uniquesolutions"><code>HomotopyContinuation.uniquesolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uniquesolutions(R::Result; tol=1e-6, multiplicities=false, conditions...)</code></pre><p>Return all <em>unique</em> solutions. If <code>multiplicities</code> is <code>true</code>, then all <em>unique</em> solutions with their correspnding multiplicities as pairs <code>(s, m)</code> where <code>s</code> is the solution and <code>m</code> the multiplicity are returned. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @polyvar x;
julia&gt; uniquesolutions([(x-3)^3*(x+2)], multiplicities=true)
[([3.0+0.0im], 3), ([-2.0+0.0im], 1)]
julia&gt; uniquesolutions([(x-3)^3*(x+2)])
[[3.0+0.0im], [-2.0+0.0im]]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.finite" href="#HomotopyContinuation.finite"><code>HomotopyContinuation.finite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">finite(result::AffineResults; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is finite. This is just a shorthand for <code>results(R; onlyfinite=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Union{Result, Array{#s3153,1} where #s3153&lt;:PathResult}}" href="#Base.real-Tuple{Union{Result, Array{#s3153,1} where #s3153&lt;:PathResult}}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">real(result, tol=1e-6)</code></pre><p>Get all results where the solutions are real with the given tolerance <code>tol</code>. See <a href="#Base.isreal-Tuple{PathResult}"><code>isreal</code></a> for details regarding the determination of &#39;realness&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.atinfinity" href="#HomotopyContinuation.atinfinity"><code>HomotopyContinuation.atinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">atinfinity(result::AffineResult)</code></pre><p>Get all results where the solutions is at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.singular" href="#HomotopyContinuation.singular"><code>HomotopyContinuation.singular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">singular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is singular. This is just a shorthand for <code>results(R; onlysingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nonsingular" href="#HomotopyContinuation.nonsingular"><code>HomotopyContinuation.nonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nonsingular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is non-singular. This is just a shorthand for <code>results(R; onlynonsingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.failed" href="#HomotopyContinuation.failed"><code>HomotopyContinuation.failed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">failed(result)</code></pre><p>Get all results where the path tracking failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities" href="#HomotopyContinuation.multiplicities"><code>HomotopyContinuation.multiplicities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">multiplicities(vectors, tol, distance)</code></pre><p>Returns an array of arrays of integers. Each vector v in vectors contains all indices i,j such that V[i] and V[j] have distance at most tol.</p></div></div><div><div><pre><code class="language-none">multiplicities(V::Results; tol=1e-6)</code></pre><p>Returns a <code>Vector</code> of <code>Vector{PathResult}</code>s grouping the <code>PathResult</code>s whose solutions appear with multiplicities <em>greater</em> 1 in &#39;V&#39;. Two solutions are regarded as equal, when their pairwise distance is less than &#39;tol&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.seed" href="#HomotopyContinuation.seed"><code>HomotopyContinuation.seed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seed(result)</code></pre><p>The random seed used in the computation.</p></div></div></section><p>If you are interested in the number of solutions of a certain kind we also provide the following helper functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nresults" href="#HomotopyContinuation.nresults"><code>HomotopyContinuation.nresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nresults(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, singulartol=1e14, onlyfinite=true)</code></pre><p>The number of solutions which satisfy the corresponding predicates.</p><p><strong>Example</strong></p><pre><code class="language-julia">result = solve(F)
# Get all non-singular results where all imaginary parts are smaller than 1e-8
nresults(result, onlyreal=true, realtol=1e-8, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfinite" href="#HomotopyContinuation.nfinite"><code>HomotopyContinuation.nfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nfinite(affineresult)</code></pre><p>The number of finite solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nreal" href="#HomotopyContinuation.nreal"><code>HomotopyContinuation.nreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nreal(result; tol=1e-6)</code></pre><p>The number of real solutions where all imaginary parts of each solution are smaller than <code>tol</code>.</p></div></div><div><div><pre><code class="language-none">nreal(res::MonodromyResult; tol = 1e-6)</code></pre><p>Counts how many solutions of <code>res</code> have imaginary part norm &lt; 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nsingular" href="#HomotopyContinuation.nsingular"><code>HomotopyContinuation.nsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nsingular(result; tol=1e10)</code></pre><p>The number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nnonsingular" href="#HomotopyContinuation.nnonsingular"><code>HomotopyContinuation.nnonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nnonsingular(result; tol=1e-10)</code></pre><p>The number of non-singular solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.natinfinity" href="#HomotopyContinuation.natinfinity"><code>HomotopyContinuation.natinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">natinfinity(affineresult)</code></pre><p>The number of solutions at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfailed" href="#HomotopyContinuation.nfailed"><code>HomotopyContinuation.nfailed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nafailed(result)</code></pre><p>The number of failed paths.</p></div></div></section><h3><a class="nav-anchor" id="PathResult-1" href="#PathResult-1">PathResult</a></h3><p>For each path we return a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a> containing the detailed information about the single path.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathResult" href="#HomotopyContinuation.PathResult"><code>HomotopyContinuation.PathResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PathResult(startvalue, pathtracker_result, endgamer_result, solver)</code></pre><p>A <code>PathResult</code> is the result of the tracking of a path (inclusive endgame). Its fields are</p><ul><li><code>returncode</code>: One of <code>:success</code>, <code>:at_infinity</code> or any error code from the <code>EndgamerResult</code></li><li><code>solution::Vector{T}</code>: The solution vector. If the algorithm computed in projective space and the solution is at infinity then the projective solution is given. Otherwise an affine solution is given if the startvalue was affine and a projective solution is given if the startvalue was projective.</li><li><code>residual::Float64</code>: The value of the infinity norm of <code>H(solution, 0)</code>.</li><li><code>newton_residual</code>: The value of the 2-norm of <span>$J_H(\text{solution})^{-1}H(\text{solution}, 0)$</span></li><li><code>condition_number</code>: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.</li><li><code>windingnumber</code>: The estimated winding number</li><li><code>angle_to_infinity</code>: The angle to infinity is the angle of the solution to the hyperplane where the homogenizing coordinate is <span>$0$</span>.</li><li><code>real_solution</code>: Indicates whether the solution is real given the defined tolerance <code>at_infinity_tol</code> (from the solver options).</li><li><code>startvalue</code>: The startvalue of the path</li><li><code>iterations</code>: The number of iterations the pathtracker needed.</li><li><code>endgame_iterations</code>: The number of steps in the geometric series the endgamer did.</li><li><code>npredictions</code>: The number of predictions the endgamer did.</li><li><code>predictions</code>: The predictions of the endgamer.</li></ul></div></div></section><p>The following helper functions are provided</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solution" href="#HomotopyContinuation.solution"><code>HomotopyContinuation.solution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solution(pathresult)</code></pre><p>Get the solution of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.residual" href="#HomotopyContinuation.residual"><code>HomotopyContinuation.residual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">residual(pathresult)</code></pre><p>Get the residual of the solution <span>$x$</span> of the path, i.e., <span>$||H(x, t)||_{\infty}$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.startsolution" href="#HomotopyContinuation.startsolution"><code>HomotopyContinuation.startsolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">startsolution(pathresult)</code></pre><p>Get the start solution of the solution <span>$x$</span> of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreal-Tuple{PathResult}" href="#Base.isreal-Tuple{PathResult}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isreal(pathresult; tol=1e-6)
isreal(pathresult, tol)</code></pre><p>Determine whether infinity norm of the imaginary part of the so</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issuccess-Tuple{PathResult}" href="#LinearAlgebra.issuccess-Tuple{PathResult}"><code>LinearAlgebra.issuccess</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">issuccess(pathresult)</code></pre><p>Checks whether the path is successfull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isfailed" href="#HomotopyContinuation.isfailed"><code>HomotopyContinuation.isfailed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isfailed(pathresult)</code></pre><p>Checks whether the path failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isaffine" href="#HomotopyContinuation.isaffine"><code>HomotopyContinuation.isaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isaffine(pathresult)</code></pre><p>Checks whether the path result is affine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isprojective" href="#HomotopyContinuation.isprojective"><code>HomotopyContinuation.isprojective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isprojective(pathresult)</code></pre><p>Checks whether the path result is projective.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isatinfinity" href="#HomotopyContinuation.isatinfinity"><code>HomotopyContinuation.isatinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isatinfinity(pathresult)</code></pre><p>Checks whether the path goes to infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.issingular" href="#HomotopyContinuation.issingular"><code>HomotopyContinuation.issingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issingular(pathresult;tol=1e14)
issingular(pathresult, tol)</code></pre><p>Checks whether the path result is singular. This is true if the winding number &gt; 1 or if the condition number of the Jacobian is larger than <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isnonsingular" href="#HomotopyContinuation.isnonsingular"><code>HomotopyContinuation.isnonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnonsingular(pathresult;tol=1e14)</code></pre><p>Checks whether the path result is non-singular. This is true if it is not singular.</p></div></div></section><h2><a class="nav-anchor" id="Monodromy-Solve-1" href="#Monodromy-Solve-1">Monodromy Solve</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.monodromy_solve" href="#HomotopyContinuation.monodromy_solve"><code>HomotopyContinuation.monodromy_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">monodromy_solve(F, sols, p; parameters=..., options..., pathtrackerkwargs...)</code></pre><p>Solve a polynomial system <code>F(x;p)</code> with specified parameters and initial solutions <code>sols</code> by monodromy techniques. This makes loops in the parameter space of <code>F</code> to find new solutions.</p><p><strong>Options</strong></p><ul><li><code>target_solutions_count=nothing</code>: The computations are stopped if this number of solutions is reached.</li><li><code>done_callback=always_false</code>: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution <code>x</code> and the second one are all current solutions (including <code>x</code>). Return <code>true</code> if the compuation is done.</li><li><code>maximal_number_of_iterations_without_progress::Int=10</code>: The maximal number of iterations (i.e. loops generated) without any progress.</li><li><code>group_action=nothing</code>: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.</li><li><code>strategy</code>: The strategy used to create loops. By default this will be <code>Triangle</code> with weights if <code>F</code> is a real system.</li><li><code>showprogress=true</code>: Enable a progress meter.</li><li><code>tol::Float64=1e-7</code>: The tolerance with which paths are tracked and with which it is decided whether two solutions are identical.</li><li><code>group_actions=GroupActions(group_action)</code>: If there is more than one group action you can use this to chain the application of them.</li><li><code>group_action_on_all_nodes=false</code>: By default the group_action(s) are only applied on the solutions with the main parameter <code>p</code>. If this is enabled then it is applied for every parameter <code>q</code>.</li><li><code>parameter_sampler=independent_normal</code>: A function taking the parameter <code>p</code> and returning a new random parameter <code>q</code>. By default each entry of the parameter vector is drawn independently from the unviraite normal distribution.</li><li><code>timeout=float(typemax(Int))</code>: The maximal number of <em>seconds</em> the computation is allowed to run.</li><li><code>minimal_number_of_solutions</code>: The minimal number of solutions before a stopping heuristic is applied. By default this is half of <code>target_solutions_count</code> if applicable otherwise 2.</li></ul></div></div></section><h3><a class="nav-anchor" id="GroupActions-1" href="#GroupActions-1">GroupActions</a></h3><p>If there is a group acting on the solution set of the polynomial system this can provided with the <code>group_action</code> keyword for single group actions or with the <code>group_actions</code> keyword for compositions of group actions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.GroupActions" href="#HomotopyContinuation.GroupActions"><code>HomotopyContinuation.GroupActions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GroupActions(actions::Function...)</code></pre><p>Store a bunch of group actions <code>(f1, f2, f3, ...)</code>. Each action has to return a tuple. The actions are applied in the following sense</p><ol><li>f1 is applied on the original solution <code>s</code></li><li>f2 is applied on <code>s</code> and the results of 1</li><li>f3 is applied on <code>s</code> and the results of 1) and 2)</li></ol><p>and so on</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f1(s) = (s * s,);

julia&gt; f2(s) = (2s, -s, 5s);

julia&gt; f3(s) = (s + 1,);

julia&gt; GroupActions(f1)(3)
(9,)

julia&gt; GroupActions(f1,f2)(3)
(9, 18, -9, 45)

julia&gt; GroupActions(f1,f2, f3)(3)
(9, 18, -9, 45, 10, 19, -8, 46)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.complex_conjugation" href="#HomotopyContinuation.complex_conjugation"><code>HomotopyContinuation.complex_conjugation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">complex_conjugation(x)</code></pre><p>A group action which returns the elementwise complex conjugated solutions.</p></div></div></section><h3><a class="nav-anchor" id="Strategies-1" href="#Strategies-1">Strategies</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Triangle" href="#HomotopyContinuation.Triangle"><code>HomotopyContinuation.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Triangle(;weights=true)</code></pre><p>A triangle is a loop consisting of the main node and two addtional nodes. If <code>weights</code> is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Petal" href="#HomotopyContinuation.Petal"><code>HomotopyContinuation.Petal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Petal()</code></pre><p>A petal is a loop consisting of the main node and one other node connected by two edges with different random weights.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../systems/"><span class="direction">Next</span><span class="title">Systems</span></a></footer></article></body></html>
