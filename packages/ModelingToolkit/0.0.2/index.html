<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ModelingToolkit.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModelingToolkit.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Introduction-by-Examples-1">Introduction by Examples</a></li><li><a class="toctext" href="#Core-Principles-1">Core Principles</a></li><li><a class="toctext" href="#Details-1">Details</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ModelingToolkit.jl-1" href="#ModelingToolkit.jl-1">ModelingToolkit.jl</a></h1><p><a href="https://travis-ci.org/JuliaDiffEq/ModelingToolkit.jl"><img src="https://travis-ci.org/JuliaDiffEq/ModelingToolkit.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://coveralls.io/github/JuliaDiffEq/ModelingToolkit.jl?branch=master"><img src="https://coveralls.io/repos/JuliaDiffEq/ModelingToolkit.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a> <a href="http://codecov.io/github/JuliaDiffEq/ModelingToolkit.jl?branch=master"><img src="http://codecov.io/github/JuliaDiffEq/ModelingToolkit.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>ModelingToolkit.jl is an intermediate representation (IR) of computational graphs for scientific computing problems. Its purpose is to be a common target for modeling DSLs in order to allow for a common platform for model inspection and transformation. It uses a tagged variable IR in order to allow specification of complex models and allow for transformations of models. It has ways to plug into its function registration and derivative system so that way it can interact nicely with user-defined routines. Together, this is an abstract form of a scientific model that is easy for humans to generate but also easy for programs to manipulate.</p><h4><a class="nav-anchor" id="Warning:-This-repository-is-a-work-in-progress-1" href="#Warning:-This-repository-is-a-work-in-progress-1">Warning: This repository is a work-in-progress</a></h4><h2><a class="nav-anchor" id="Introduction-by-Examples-1" href="#Introduction-by-Examples-1">Introduction by Examples</a></h2><h3><a class="nav-anchor" id="Example:-ODE-1" href="#Example:-ODE-1">Example: ODE</a></h3><p>Let&#39;s build an ODE. First we define some variables. In a differential equation system, we need to differentiate between our dependent variables, independent variables, and parameters. Therefore we label them as follows:</p><pre><code class="language-julia">using ModelingToolkit

# Define some variables
@IVar t
@DVar x(t) y(t) z(t)
@Deriv D&#39;~t
@Param σ ρ β</code></pre><p>Then we build the system:</p><pre><code class="language-julia">eqs = [D*x ~ σ*(y-x),
       D*y ~ x*(ρ-z)-y,
       D*z ~ x*y - β*z]</code></pre><p>Each operation builds an <code>Operation</code> type, and thus <code>eqs</code> is an array of <code>Operation</code> and <code>Variable</code>s. This holds a tree of the full system that can be analyzed by other programs. We can turn this into a <code>DiffEqSystem</code> via:</p><pre><code class="language-julia">de = DiffEqSystem(eqs,[t],[x,y,z],Variable[],[σ,ρ,β])
de = DiffEqSystem(eqs)</code></pre><p>where we tell it the variable types and ordering in the first version, or let it automatically determine the variable types in the second version. This can then generate the function. For example, we can see the generated code via:</p><pre><code class="language-julia">ModelingToolkit.generate_ode_function(de)

## Which returns:
:((du, u, p, t)-&gt;begin
                x = u[1]
                y = u[2]
                z = u[3]
                σ = p[1]
                ρ = p[2]
                β = p[3]
                x_t = σ * (y - x)
                y_t = x * (ρ - z) - y
                z_t = x * y - β * z
                du[1] = x_t
                du[2] = y_t
                du[3] = z_t
            end
        end)</code></pre><p>and get the generated function via:</p><pre><code class="language-julia">f = ODEFunction(de)</code></pre><h3><a class="nav-anchor" id="Example:-Nonlinear-System-1" href="#Example:-Nonlinear-System-1">Example: Nonlinear System</a></h3><p>We can also build nonlinear systems. Let&#39;s say we wanted to solve for the steady state of the previous ODE. This is the nonlinear system defined by where the derivatives are zero. We could use dependent variables for our nonlinear system (for direct compatibility with the above ODE code), or we can use non-tagged variables. Here we will show the latter. We write:</p><pre><code class="language-julia">@Var x y z
@Param σ ρ β

# Define a nonlinear system
eqs = [0 ~ σ*(y-x),
       0 ~ x*(ρ-z)-y,
       0 ~ x*y - β*z]
ns = NonlinearSystem(eqs)
nlsys_func = ModelingToolkit.generate_nlsys_function(ns)</code></pre><p>which generates:</p><pre><code class="language-julia">(du, u, p)-&gt;begin  # C:\Users\Chris\.julia\v0.6\ModelingToolkit\src\systems.jl, line 51:
        begin  # C:\Users\Chris\.julia\v0.6\ModelingToolkit\src\utils.jl, line 2:
            y = u[1]
            x = u[2]
            z = u[3]
            σ = p[1]
            ρ = p[2]
            β = p[3]
            resid[1] = σ * (y - x)
            resid[2] = x * (ρ - z) - y
            resid[3] = x * y - β * z
        end
    end</code></pre><p>We can use this to build a nonlinear function for use with NLsolve.jl:</p><pre><code class="language-julia">f = @eval eval(nlsys_func)
# Make a closure over the parameters for for NLsolve.jl
f2 = (du,u) -&gt; f(du,u,(10.0,26.0,2.33))</code></pre><h2><a class="nav-anchor" id="Core-Principles-1" href="#Core-Principles-1">Core Principles</a></h2><p>The core idea behind ModelingToolkit.jl is that mathematical equations require context, and thus any symbolic manipulations and full model specifications requires the ability to handle such context. When writing DSLs, this fact comes to light very quickly. Every DSL seems to lower to some intermediate representation from which the final result is computed, but this process means there&#39;s a lot of repeated ideas for every DSL that creates scientific computing objects like differential equations and nonlinear systems. By having a single common contexualized IR, this gives DSLs a target to write to so that way lower-level details like computation of system Jacobians can be disconnected from the DSL and its syntax, allowing for code-reuse between modeling packages and languages.</p><p>In this section we define the core pieces of the IR and what they mean.</p><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><p>The simplest piece of the IR is the <code>Variable</code>. The <code>Variable</code> is the context-aware single variable of the IR. Its fields are described as follows:</p><ul><li><code>name</code>: the name of the <code>Variable</code>. Note that this is not necessarily the same as the name of the Julia variable. But this symbol itself is considered the core identifier of the <code>Variable</code> in the sense of equality.</li><li><code>value</code>: the value of the <code>Variable</code>. The meaning of the value can be interpreted differently for different systems, but in most cases it&#39;s tied to whatever value information would be required for the system to be well-defined such as the initial condition of a differential equation.</li><li><code>value_type</code>: the type that the values have to be. It&#39;s disconnected from the <code>value</code> because in many cases the <code>value</code> may not be able to be specified in advance even when we may already know the type. This can be used to set units or denote a variable as being of higher precision.</li><li><code>subtype</code>: the main denotation of context. Variables within systems are grouped according to their <code>subtype</code>.</li><li><code>diff</code>: the operator objects attached to the variable</li><li><code>dependents</code>: the vector of variables on which the current variable is dependent. For example, <code>u(t,x)</code> has dependents <code>[t,x]</code>. Derivatives thus require this information in order to simplify down.</li><li><code>flow</code>: a boolean that describes the connection behavior between systems, whether it should connect to have summation to zero or equality.</li><li><code>description</code>: a string description of the variable used for building printouts and other descriptive outputs.</li><li><code>domain</code>: a type which describes the domain in which the values of the variable lives.</li><li><code>size</code>: the size of the variable. By default it&#39;s <code>nothing</code>, denoting that the variable is a scalar. Otherwise it&#39;s a tuple of numbers which describes the size of the array for the variable.</li><li><code>context</code>: this is an open field for DSLs to carry along more context in the variables, but is not used in the systems themselves.</li></ul><h3><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h3><p>Operations are the basic composition of variables and puts together the pieces with a function. The operator <code>~</code> is a special operator which denotes equality between the arguments.</p><h3><a class="nav-anchor" id="Operators-1" href="#Operators-1">Operators</a></h3><p>An operator is an object which modifies variables via <code>*</code>. It adds the operator to the <code>diff</code> field of the variable and changes the interpretation of the variable. The current operators are:</p><ul><li><code>Differential</code>: a differential denotes the derivative with respect to a given variable. It can be expanded via <code>expand_derivatives</code> which symbolically differentiates expressions recursively and cancels out appropriate constant variables.</li></ul><h3><a class="nav-anchor" id="Systems-1" href="#Systems-1">Systems</a></h3><p>A system is a collection of operations with expanded context. While different systems can have different constructors and interpretations, the general structure is as follows:</p><ul><li><code>eqs</code> is the first argument which is an array of <code>Operation</code> which describe the system of equations.</li><li>Name to subtype mappings: these describe how variable <code>subtype</code>s are mapped to the contexts of the system. For example, for a differential equation, the dependent variable corresponds to given subtypes and then the <code>eqs</code> can be analyzed knowing what the state variables are.</li><li>Variable names which do not fall into one of the system&#39;s core subtypes are treated as intermediates which can be used for holding subcalculations and other pieces like that.</li></ul><h3><a class="nav-anchor" id="Transformations-1" href="#Transformations-1">Transformations</a></h3><p>Transformation functions send IR objects to like IR objects. These utilize the contextual information in a given <code>Operation</code>/<code>System</code> to build another <code>Operation</code>/<code>System</code>.</p><h2><a class="nav-anchor" id="Details-1" href="#Details-1">Details</a></h2><h3><a class="nav-anchor" id="Function-Registration-1" href="#Function-Registration-1">Function Registration</a></h3><p>A function is registered into the operation system via:</p><pre><code class="language-julia">@register f(x)
@register g(x,y)</code></pre><p>etc. where each macro call registers the function with the given signature. This will cause operations to stop recursing at this function, building <code>Operation(g,args)</code> nodes into the graph instead of tracing calls of <code>g</code> itself into <code>Operation</code>s.</p><h3><a class="nav-anchor" id="Adding-Derivatives-1" href="#Adding-Derivatives-1">Adding Derivatives</a></h3><p>There is a large amount of derivatives pre-defined by <a href="https://github.com/JuliaDiff/DiffRules.jl">DiffRules.jl</a>. Note that <code>Expression</code> types are defined as <code>&lt;:Real</code>, and thus any functions which allow the use of real numbers can automatically be traced by the derivative mechanism. Thus for example:</p><pre><code class="language-julia">f(x,y,z) = x^2 + sin(x+y) - z</code></pre><p>automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.</p><p>However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:</p><pre><code class="language-julia">ModelingToolkit.Derivative(::typeof(my_function),args,::Type{Val{i}})</code></pre><p>where <code>i</code> means that it&#39;s the derivative of the <code>i</code>th argument. <code>args</code> is the array of arguments, so for example if your function is <code>f(x,t)</code> then <code>args = [x,t]</code>. You should return an <code>Operation</code> for the derivative of your function.</p><p>For example, <code>sin(t)</code>&#39;s derivative (by <code>t</code>) is given by the following:</p><pre><code class="language-julia">ModelingToolkit.Derivative(::typeof(sin),args,::Type{Val{1}}) = cos(args[1])</code></pre><h3><a class="nav-anchor" id="Macro-free-Usage-1" href="#Macro-free-Usage-1">Macro-free Usage</a></h3><p>Given the insistence on being programming friendly, all of the functionality is accessible via a function-based interface. This means that all macros are syntactic sugar in some form. For example, the variable construction:</p><pre><code class="language-julia">@IVar t
@DVar x(t) y(t) z(t)
@Deriv D&#39;~t
@Param σ ρ β</code></pre><p>is syntactic sugar for:</p><pre><code class="language-julia">t = IndependentVariable(:t)
x = DependentVariable(:x,dependents = [t])
y = DependentVariable(:y,dependents = [t])
z = DependentVariable(:z,dependents = [t])
D = Differential(t) # Default of first derivative, Derivative(t,1)
σ = Parameter(:σ)
ρ = Parameter(:ρ)
β = Parameter(:β)</code></pre><h3><a class="nav-anchor" id="Intermediate-Calculations-1" href="#Intermediate-Calculations-1">Intermediate Calculations</a></h3><p>The system building functions can handle intermediate calculations. For example,</p><pre><code class="language-julia">@Var a x y z
@Param σ ρ β
eqs = [a ~ y-x,
       0 ~ σ*a,
       0 ~ x*(ρ-z)-y,
       0 ~ x*y - β*z]
ns = NonlinearSystem(eqs,[x,y,z],[σ,ρ,β])
nlsys_func = ModelingToolkit.generate_nlsys_function(ns)</code></pre><p>expands to:</p><pre><code class="language-julia">:((du, u, p)-&gt;begin  # C:\Users\Chris\.julia\v0.6\ModelingToolkit\src\systems.jl, line 85:
            begin  # C:\Users\Chris\.julia\v0.6\ModelingToolkit\src\utils.jl, line 2:
                x = u[1]
                y = u[2]
                z = u[3]
                σ = p[1]
                ρ = p[2]
                β = p[3]
                a = y - x
                resid[1] = σ * a
                resid[2] = x * (ρ - z) - y
                resid[3] = x * y - β * z
            end
        end)</code></pre><p>In addition, the Jacobian calculations take into account intermediate variables to appropriately handle them.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
