<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ODEInterface.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ODEInterface.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLbvpm2" href="#ODEInterface.@import_DLbvpm2"><code>ODEInterface.@import_DLbvpm2</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import bvpm2 dynamic lib name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLbvpsol" href="#ODEInterface.@import_DLbvpsol"><code>ODEInterface.@import_DLbvpsol</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import bvpsol dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLcolnew" href="#ODEInterface.@import_DLcolnew"><code>ODEInterface.@import_DLcolnew</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import colnew dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLddeabm" href="#ODEInterface.@import_DLddeabm"><code>ODEInterface.@import_DLddeabm</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Ddeabm dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLddebdf" href="#ODEInterface.@import_DLddebdf"><code>ODEInterface.@import_DLddebdf</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Ddebdf dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLdop853" href="#ODEInterface.@import_DLdop853"><code>ODEInterface.@import_DLdop853</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Dop853 dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLdopri5" href="#ODEInterface.@import_DLdopri5"><code>ODEInterface.@import_DLdopri5</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Dopri5 dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLodex" href="#ODEInterface.@import_DLodex"><code>ODEInterface.@import_DLodex</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Odex dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLradau" href="#ODEInterface.@import_DLradau"><code>ODEInterface.@import_DLradau</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Radau dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLradau5" href="#ODEInterface.@import_DLradau5"><code>ODEInterface.@import_DLradau5</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Radau5 dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLrodas" href="#ODEInterface.@import_DLrodas"><code>ODEInterface.@import_DLrodas</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import rodas dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_DLseulex" href="#ODEInterface.@import_DLseulex"><code>ODEInterface.@import_DLseulex</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import seulex dynamic lib names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_LOG" href="#ODEInterface.@import_LOG"><code>ODEInterface.@import_LOG</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing all the LOG bitmasks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_OPTcommon" href="#ODEInterface.@import_OPTcommon"><code>ODEInterface.@import_OPTcommon</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing common OPT options.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_RHScallmode" href="#ODEInterface.@import_RHScallmode"><code>ODEInterface.@import_RHScallmode</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing RHS<em>CALL</em>MODE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bandedmatrix" href="#ODEInterface.@import_bandedmatrix"><code>ODEInterface.@import_bandedmatrix</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro, for importing Banded Matrix types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bandedmatrixfuncs" href="#ODEInterface.@import_bandedmatrixfuncs"><code>ODEInterface.@import_bandedmatrixfuncs</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro, for importing Banded Matrix types and functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bvpm2" href="#ODEInterface.@import_bvpm2"><code>ODEInterface.@import_bvpm2</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import bvpm2 solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bvpm2_help" href="#ODEInterface.@import_bvpm2_help"><code>ODEInterface.@import_bvpm2_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Bvpm2 help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bvpsol" href="#ODEInterface.@import_bvpsol"><code>ODEInterface.@import_bvpsol</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import bvp solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_bvpsol_help" href="#ODEInterface.@import_bvpsol_help"><code>ODEInterface.@import_bvpsol_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Bvpsol help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_colnew" href="#ODEInterface.@import_colnew"><code>ODEInterface.@import_colnew</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import colnew solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_colnew_help" href="#ODEInterface.@import_colnew_help"><code>ODEInterface.@import_colnew_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Colnew help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_ddeabm" href="#ODEInterface.@import_ddeabm"><code>ODEInterface.@import_ddeabm</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Ddeabm solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_ddeabm_help" href="#ODEInterface.@import_ddeabm_help"><code>ODEInterface.@import_ddeabm_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Ddeabm help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_ddebdf" href="#ODEInterface.@import_ddebdf"><code>ODEInterface.@import_ddebdf</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Ddebdf solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_ddebdf_help" href="#ODEInterface.@import_ddebdf_help"><code>ODEInterface.@import_ddebdf_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Ddebdf help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_dop853" href="#ODEInterface.@import_dop853"><code>ODEInterface.@import_dop853</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Dop853 solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_dop853_help" href="#ODEInterface.@import_dop853_help"><code>ODEInterface.@import_dop853_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Dopri5 help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_dopri5" href="#ODEInterface.@import_dopri5"><code>ODEInterface.@import_dopri5</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Dopri5 solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_dopri5_help" href="#ODEInterface.@import_dopri5_help"><code>ODEInterface.@import_dopri5_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Dopri5 help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_dynamicload" href="#ODEInterface.@import_dynamicload"><code>ODEInterface.@import_dynamicload</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing (un-)load functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_exceptions" href="#ODEInterface.@import_exceptions"><code>ODEInterface.@import_exceptions</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing the ODE Exceptions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_help" href="#ODEInterface.@import_help"><code>ODEInterface.@import_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing all the help-functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_huge" href="#ODEInterface.@import_huge"><code>ODEInterface.@import_huge</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing the <em>huge</em> set of symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_normal" href="#ODEInterface.@import_normal"><code>ODEInterface.@import_normal</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing the <em>normal</em> set of symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_odecall" href="#ODEInterface.@import_odecall"><code>ODEInterface.@import_odecall</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing odecall.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_odex" href="#ODEInterface.@import_odex"><code>ODEInterface.@import_odex</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Odex solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_odex_help" href="#ODEInterface.@import_odex_help"><code>ODEInterface.@import_odex_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Odex help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_options" href="#ODEInterface.@import_options"><code>ODEInterface.@import_options</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing OptionsODE and option handling.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_outputfcn" href="#ODEInterface.@import_outputfcn"><code>ODEInterface.@import_outputfcn</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing enums, functions, etc. for output function call.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_radau" href="#ODEInterface.@import_radau"><code>ODEInterface.@import_radau</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Radau solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_radau5" href="#ODEInterface.@import_radau5"><code>ODEInterface.@import_radau5</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import Radau5 solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_radau5_help" href="#ODEInterface.@import_radau5_help"><code>ODEInterface.@import_radau5_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Radau5 help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_radau_help" href="#ODEInterface.@import_radau_help"><code>ODEInterface.@import_radau_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Radau help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_rodas" href="#ODEInterface.@import_rodas"><code>ODEInterface.@import_rodas</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import rodas solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_rodas_help" href="#ODEInterface.@import_rodas_help"><code>ODEInterface.@import_rodas_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Rodas help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_seulex" href="#ODEInterface.@import_seulex"><code>ODEInterface.@import_seulex</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for import seulex solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.@import_seulex_help" href="#ODEInterface.@import_seulex_help"><code>ODEInterface.@import_seulex_help</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>macro for importing Seulex help.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.AbstractArgumentsODESolver" href="#ODEInterface.AbstractArgumentsODESolver"><code>ODEInterface.AbstractArgumentsODESolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Ancestor for all types storing arguments for ODE-(C-/Fortran-)solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.AbstractODESolution" href="#ODEInterface.AbstractODESolution"><code>ODEInterface.AbstractODESolution</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Ancestor for all types that represent solutions (of IVPs or BVPs).</p><p>Typically such solutions can be evaluated later.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.AbstractOptionsODE" href="#ODEInterface.AbstractOptionsODE"><code>ODEInterface.AbstractOptionsODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Ancestor for all types storing options for ODE-solvers.</p><p>ODE-solvers often have serveral parameters for fine-tuning them. In this ODEInterface this parameters are called &#39;options&#39; and  they are stored in key/value paris. For the key a  <code>AbstractString</code> is used. The value can be <code>Any</code>-thing. The key is often called the option-name.</p><p>All types for this purpose have this abstract type as super-type.</p><p>Required fields are: <code>name</code>, <code>lastchanged</code>, <code>options</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ArgumentErrorODE" href="#ODEInterface.ArgumentErrorODE"><code>ODEInterface.ArgumentErrorODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that one input argument is invalid.</p><p>This is a WrappedException: If the invalidity of the argument was detected by some error/exception then, this initial error/exception can be found in the <code>error</code> field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.BandedMatrix" href="#ODEInterface.BandedMatrix"><code>ODEInterface.BandedMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for storing and changing a banded matrix.</p><p><strong>Introduction (connections to proposal #8240)</strong></p><p>This is a simple type for storing banded matrices in the band storage format used by LAPACK:</p><pre><code class="language-none"> http://www.netlib.org/lapack/lug/node124.html</code></pre><p>The emphasis here is on <em>storing</em> and <em>changing</em> the matrix elements, because this is needed in the ODE-context.</p><p>This is <em>not</em> an attempt to fully implement efficient arithmetic for banded matrices. This problem is discussed in proposal #8240:</p><pre><code class="language-none"> https://github.com/JuliaLang/julia/issues/8240</code></pre><p><strong>What are banded matrices?</strong></p><p>Take a look at the diaognals of a matrix, e.g.</p><pre><code class="language-none"> ⎛1 4 2    ⎞
 ⎜5 2 3 1  ⎟
 ⎜  4 3 0 0⎟
 ⎜    3 4 8⎟
 ⎝      2 5⎠</code></pre><p>Then we give the following names to the diagonals:</p><pre><code class="language-none">           0  1 2 3  upper diagonals
             ↘ ↘ ↘ ↘
           1  1╲4╲2╲0╲0
   lower     ↘╲ ╲ ╲ ╲ ╲          here: l = 1
 diagonals 2  5╲2╲3╲1╲0                u = 2
             ↘╲ ╲ ╲ ╲ ╲
           3  0╲4╲3╲0╲0
             ↘╲ ╲ ╲ ╲ ╲
              0╲0╲3╲4╲8
              ╲ ╲ ╲ ╲ ╲
              0╲0╲0╲2╲5</code></pre><p>The 0 diagonal is the main diagonal. The 1st diagonal above this main diagonal is called the 1st upper diagonal, etc.  The 1st digonal below the main diagonal is called the 1st lower diagonal.</p><p>A matrix has lower bandwidth l, if all diagonals below the l lower diagonal have only zeros. In the above example the matrix has lower bandwidth l=1 because the 2nd, 3rd and 4th lower diagonals are all zero.</p><p>A matrix has upper bandwidth u, if all diagonals above the u upper diagonal have only zeros. In the above example the matrix has upper bandwidth u=2.</p><p>A m×n matrix (with m,n ≥ 2) is called banded, if it has a  lower bandwidth l&lt;m-2 and/or a upper bandwidth u&lt;n-2.</p><p><strong>What is this type for?</strong></p><p>This types stores banded matrices. There are functions for banded matrices to make it easy to query and change the elements of a banded matrix.</p><p><strong>Why is this type immutable? Can the entries be changed?</strong></p><p>A banded matrix is immutable, i.e. the structure (the upper and lower bandwidths cannot be changed). The entries of a banded matrix are <em>not</em> immutable. </p><p>For an explanation of the storage format, see the help of <code>BandedMatrix_storage</code>.</p><p>There is a constructur, where you can give the entries array for the non-zero elements (diagonals) as input argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.BandedMatrix_storage" href="#ODEInterface.BandedMatrix_storage"><code>ODEInterface.BandedMatrix_storage</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><strong>How are the non-zero entries stored (in this type)?</strong></p><p>If M is a m×n matrix with upper bandwidth u and lower bandwith l, then the non-zero entries are saved in a (1+l+u)×n matrix N with</p><pre><code class="language-none"> N(i-j+u+1,j) = M(i,j) with

  max(1,j-u) ≤ i ≤ min(m,l+j)  ⎫   ⎧ -u ≤ i-j ≤ l
                               ⎬ ⇔ ⎨  1 ≤ i   ≤ m
  max(1,i-l) ≤ j ≤ max(n,u+i)  ⎭   ⎩  1 ≤ j   ≤ n</code></pre><p>This is the storage format described in the follwing URL.</p><pre><code class="language-none"> http://www.netlib.org/lapack/lug/node124.html</code></pre><p>This is not the place to discuss, if a (1+l+u)×min(m,n) matrix is a better format for storing the diagonals.</p><pre><code class="language-none"> M(i,j) = N(i-j+u+1,j)  
 N(r,s) = M(r+s-1-u,s)</code></pre><p>There can be entries in the matrix N that do <em>not</em> correspond to entries in M. In this type they are also zero. Great care is taken not to change this zeros in order not to violate the <code>==</code> and <code>hash</code> &quot;contract&quot;: Because this uncorresponding entries cannot be seen in M, they should have no effect on the hash and on the <code>==</code> relation.</p><p>Keep in mind: There are two different ways of numbering the diagonals. The (internal) form ranging from 1 to 1+u+l and the user-friendly form ranging von -l ≤ d ≤ u, see <code>BandedMatrix</code>.</p><p>For the example</p><pre><code class="language-none"> ⎛1 4 2    ⎞
 ⎜5 2 3 1  ⎟
 ⎜  4 3 0 0⎟
 ⎜    3 4 8⎟
 ⎝      2 5⎠</code></pre><p>one can visualize this storage format like this:</p><pre><code class="language-none">  *╲
  ╲│╲
  *╲*╲
  ╲│╲│╲
 ⎛1╲4╲2╲⋅ ⋅⎞
 ⎜╲│╲│╲│╲  ⎟       ⎛* * 2 1 0⎞      here: l = 1,  u = 2
 ⎜5╲2╲3╲1╲⋅⎟    ≅  ⎜* 4 3 0 8⎟
 ⎜╲│╲│╲│╲│╲⎟       ⎜1 2 3 4 5⎟      ⋅ : not saved &quot;0&quot;
 ⎜⋅╲4╲3╲0╲0⎟       ⎝5 4 3 2 *⎠      * : unused slot in storage format
 ⎜  ╲│╲│╲│╲⎟
 ⎜⋅ ⋅╲3╲4╲8⎟
 ⎜    ╲│╲│╲⎟
 ⎝⋅ ⋅ ⋅╲2╲5⎠
        ╲│╲
         ╲*</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.Bvpm2" href="#ODEInterface.Bvpm2"><code>ODEInterface.Bvpm2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Bvpm2 object for solving boundary value problems</strong></p><p>This is the Julia part of the BVP<em>M-2 (Fortran-)solution object.  For (nearly) all the operations the corresponding Fortran-Proxy  methods are called (call `help</em>bvpm2_proxy()` to get internal details).</p><p><strong>Boundary value problem (BVP)</strong></p><p>BVPs of the following form are considered:</p><pre><code class="language-none">              1
  y&#39;(x) =  ─────── Sy + f(x, y, p)         for a ≤ x ≤ b   [ODEs]
            x - a


  ga(y(a), p) = 0,     gb(y(b), p) = 0                     [BCs]</code></pre><ul><li><p>y(x) ∈ ℝᵈ and <code>d</code> is also called <code>no_odes</code> (the number of ordinary differential equations). </p></li><li><p>S ∈ ℝᵈˣᵈ is an optional constant matrix (also  called the singularity term) because the whole term S⋅y/(x-a) has a  singularity at x=a. If S is not given, then the ODEs are reduced to y&#39;(x) = f(x, y, p).</p></li><li><p>p ∈ ℝᵐ (with 0≤m) are unknown parameters of the problem. <code>m</code> is also called <code>no_par</code> (the number of parameters).</p></li><li><p>f(x, y, p) ∈ ℝᵈ is also called the right-hand side (of the ODEs).</p></li><li><p>ga(ya, p) ∈ ℝˡ describes the left boundary conditions. <code>l</code> is also called <code>no_left_bc</code> (the number of the BCs at x=a).</p></li><li><p>ga(yb, p) ∈ ℝⁿ describes the right boundary conditions. It is</p><pre><code class="language-none">  n = d + m - l 
  n = no_odes + no_par - no_left_bc</code></pre></li></ul><p><strong>Initial guess and solutions</strong></p><p>A Bvpm2 object can be used to represent either an initial guess (for a  BVP like above) or a solution. It is possible to use a solution of a  (different) BVP as initial guess to another BVP.</p><p>Such a Bvpm2 object can be in one of the following states:</p><ul><li><code>state==0</code>: object created (and connected to Fortran-object), but  not initialized, i.e. it does neither represent a guess nor an solution.</li><li><code>state==1</code>: object created, and initialized with an (initial) guess, i.e. the object represents a guess.</li><li><code>state==2</code>: object created and a solution was calculated successfully and saved in the object, i.e. the object represents a solution.</li><li><code>state==-1</code>: object is not connected to a Fortran-Proxy. Either <code>bvpm2_destroy</code> was called or at creation time, the connection to the   Fortran-Proxy couldn&#39;t be established, i.e. the object is unusable and  all associated memory was deallocated.</li></ul><p>The following table shows possible actions and the state-transitions initiated by the actions.</p><pre><code class="language-none">╔═══════════════════╤═══════════════════════════╤════════════╤════════════╗
║ Action/Function   │ Description               │state before│state after ║
╠═══════════════════╪═══════════════════════════╪════════════╪════════════╣
║ Bvpm2()           │ create object             │    ---     │     0      ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_init        │ initialize object with    │     0      │     1      ║
║                   │ initial guess, etc.       │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_show_details│ show some details of      │ 0, 1, or 2 │ not changed║
║                   │ (Fortran-)BVP_M-2 sol     │            │            ║
║                   │ object                    │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_get_details │ get dict with some details│ -1, 0, 1,  │ not changed║
║                   │ of the Bvpm2 object:      │   or 2     │            ║
║                   │ e.g. state, number of pts │            │            ║
║                   │ in current grid ...       │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_get_x       │ return current grid of    │ 1, or 2    │ not changed║
║                   │ the object.               │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_get_params  │ return current values of  │ 1, or 2    │ not changed║
║                   │ estimated/calculated      │            │            ║
║                   │ parameters                │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_terminate   │ throw away all data and   │ 0, 1, or 2 │      0     ║
║                   │ information. Bring to     │            │            ║
║                   │ state 0.                  │            │            ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_destroy     │ deallocate all (Fortran-) │ -1, 0, 1,  │     -1     ║
║                   │ resources for this object.│   or 2     │            ║
║                   │                           │            │            ║
╚═══════════════════╧═══════════════════════════╧════════════╧════════════╝ </code></pre><p>There are functions that take an Bvpm2-object <code>obj_in</code> as input,  perhaps change <code>obj_in</code> and create an additonal <code>obj_out</code>.</p><p>The following table shows possible actions, the change of the state of <code>obj_in</code> and which <code>obj_out</code> object is created:</p><pre><code class="language-none">╔═══════════════════╤═══════════════════════════╤════════════╤════════════╗
║ Action/Function   │ Description               │obj_in state│  state of  ║
║                   │                           │ from -&gt; to │   obj_out  ║
╠═══════════════════╪═══════════════════════════╪════════════╪════════════╣
║ bvpm2_solve       │ take obj_in as guess. Do  │ not changed│ 0: no      ║
║                   │ not change obj_in.        │            │    success ║
║                   │ Produces obj_out object   │            │            ║
║                   │ representing the solution.│            │ 2: success ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_copy        │ create deep copy of       │ not changed│ same as    ║
║                   │ obj_in                    │            │ obj_in     ║
╟───────────────────┼───────────────────────────┼────────────┼────────────╢
║ bvpm2_extend      │ extend solution to new    │  2 -&gt; 0    │    1       ║
║                   │ interval as new  guess.   │            │            ║
║                   │ obj_in will be terminated │            │            ║
║                   │ and will be in state 0.   │            │            ║
║                   │ Call bvpm2_copy before, if│            │            ║
║                   │ you need the solution     │            │            ║
║                   │ later on.                 │            │            ║
╚═══════════════════╧═══════════════════════════╧════════════╧════════════╝ </code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.Bvpm2_guess_cbi" href="#ODEInterface.Bvpm2_guess_cbi"><code>ODEInterface.Bvpm2_guess_cbi</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>structure to save guess-function for use in Fortran callbacks.</p><p>How to make a julia function (which typically cannot be put in <code>cfunction</code>, because it may be a closure, etc.) callable from Fortran2003 code that uses no ISO<em>C</em>BINDING and has no pass-through arguments?</p><p>Use a Fortran2003 proxy with ISO<em>C</em>BINDING. Here is the calling stack:</p><pre><code class="language-none">bvpm2_guess( ...  guess_fcn ... )
─────────────────────────────────
│ [ cbi created with guess_fcn ]
│ call init_guess3_c( ... guess_fcn_ptr=unsafe_bvpm2_guess_cb_c,
│ │    ━━━━━━━━━━━━━      guess_pthrough=cbi ... )
│ │ call bvp_init( ... guess = guess_fcn_proxy ... )
│ │ │    ════════
│ │ │ call guess_fcn_proxy(x_point, guess_vector)
│ │ │ │    ━━━━━━━━━━━━━━━
│ │ │ │ [nested guess_fcn_proxy in scope of init_guess3_c, so
│ │ │ │  the guess_pthrough info is available.]
│ │ │ │ [convert Fortran Arrays to C-Pointer-Array]
│ │ │ │ call guess_fcn_ptr/unsafe_bvpm2_guess_cb_c(x_point, ...,
│ │ │ │ │                  ───────────────────────   guess_vector 
│ │ │ │ │                                            guess_pthrough)
│ │ │ │ │   [ use guess_pthrough to recover cbi ]
│ │ │ │ │   call cbi.guess_fcn(x, guess_vector)
│ │ │ │ │   │    ─────────────
└ └ └ └ └   └

Legend:
   ─────────  julia code 
   ━━━━━━━━━  Fortran2003 code in BVP_M_Proxy with ISO_C_BINDING
   ═════════  Fortran2003 code in BVP_M-2 (without ISO_C_BINDING)</code></pre><p>For more details of this concept/idea call <code>help_bvpm2_proxy</code>.</p></div></div></section><pre><code class="language-none">ODEInterface.Bvpm2_solve_cbi</code></pre><pre><code class="language-none">ODEInterface.BvpsolArguments</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.BvpsolInternalCallInfos" href="#ODEInterface.BvpsolInternalCallInfos"><code>ODEInterface.BvpsolInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Bvpsol-Callbacks.</p><p>Unfortunately bvpsol.f does not support passthrough arguments.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> bvpsol       
     ccall( BVPSOL_  ... )
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_bvpsolrhs                           │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_bvpssolbc                           │  ⎬ cb. boundary
        │    bc                                     │  ⎪     conditions
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_bvpsolivp                           │  ⎬ cb. solving
        │    odesolver(rhs,t,tEnd,x,opt)            │  ⎪ IVP
        └───────────────────────────────────────────┘  ⎭</code></pre></div></div></section><pre><code class="language-none">ODEInterface.ColnewArguments</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ColnewInternalCallInfos" href="#ODEInterface.ColnewInternalCallInfos"><code>ODEInterface.ColnewInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for colnew-Callbacks.</p><p>Unfortunately colnew.f does not support passthrough arguments.</p><p>We have the typical calling stack:</p></div></div></section><pre><code class="language-none">ODEInterface.ColnewSolution</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_BVPM2" href="#ODEInterface.DL_BVPM2"><code>ODEInterface.DL_BVPM2</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading bvpm2 solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_BVPSOL" href="#ODEInterface.DL_BVPSOL"><code>ODEInterface.DL_BVPSOL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading bvpsol solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_BVPSOL_I32" href="#ODEInterface.DL_BVPSOL_I32"><code>ODEInterface.DL_BVPSOL_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading bvpsol solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_COLNEW" href="#ODEInterface.DL_COLNEW"><code>ODEInterface.DL_COLNEW</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading colnew solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_COLNEW_I32" href="#ODEInterface.DL_COLNEW_I32"><code>ODEInterface.DL_COLNEW_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading colnew solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DDEABM" href="#ODEInterface.DL_DDEABM"><code>ODEInterface.DL_DDEABM</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading ddeabm solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DDEABM_I32" href="#ODEInterface.DL_DDEABM_I32"><code>ODEInterface.DL_DDEABM_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading ddeabm solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DDEBDF" href="#ODEInterface.DL_DDEBDF"><code>ODEInterface.DL_DDEBDF</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading ddebdf solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DDEBDF_I32" href="#ODEInterface.DL_DDEBDF_I32"><code>ODEInterface.DL_DDEBDF_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading ddebdf solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DOP853" href="#ODEInterface.DL_DOP853"><code>ODEInterface.DL_DOP853</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading dop853 solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DOP853_I32" href="#ODEInterface.DL_DOP853_I32"><code>ODEInterface.DL_DOP853_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading dop853 solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DOPRI5" href="#ODEInterface.DL_DOPRI5"><code>ODEInterface.DL_DOPRI5</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading dopri5 solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_DOPRI5_I32" href="#ODEInterface.DL_DOPRI5_I32"><code>ODEInterface.DL_DOPRI5_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading dopri5 solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_ODEX" href="#ODEInterface.DL_ODEX"><code>ODEInterface.DL_ODEX</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading odex solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_ODEX_I32" href="#ODEInterface.DL_ODEX_I32"><code>ODEInterface.DL_ODEX_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading odex solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RADAU" href="#ODEInterface.DL_RADAU"><code>ODEInterface.DL_RADAU</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading radau solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RADAU5" href="#ODEInterface.DL_RADAU5"><code>ODEInterface.DL_RADAU5</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading radau5 solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RADAU5_I32" href="#ODEInterface.DL_RADAU5_I32"><code>ODEInterface.DL_RADAU5_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading radau5 solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RADAU_I32" href="#ODEInterface.DL_RADAU_I32"><code>ODEInterface.DL_RADAU_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading radau solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RODAS" href="#ODEInterface.DL_RODAS"><code>ODEInterface.DL_RODAS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading rodas solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_RODAS_I32" href="#ODEInterface.DL_RODAS_I32"><code>ODEInterface.DL_RODAS_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading rodas solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_SEULEX" href="#ODEInterface.DL_SEULEX"><code>ODEInterface.DL_SEULEX</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading seulex solver (64bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DL_SEULEX_I32" href="#ODEInterface.DL_SEULEX_I32"><code>ODEInterface.DL_SEULEX_I32</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Name for Loading seulex solver (32bit integers).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DdeabmArguments" href="#ODEInterface.DdeabmArguments"><code>ODEInterface.DdeabmArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct DdeabmArguments{FInt} &lt;: AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Ddeabm solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DdeabmInternalCallInfos" href="#ODEInterface.DdeabmInternalCallInfos"><code>ODEInterface.DdeabmInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Ddeabm-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> ddeabm
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     loop with iterations (intermediate-mode and/or OPT_OUTPUTATTIMES)
     │ ccall( DDEABM_ ... ) # after 1st call: continuation call
     │    ┌───────────────────────────────────────────┐  ⎫
     │    │unsafe_SLATEC1RHSCallback                  │  ⎬ cb. rhs
     │    │    rhs                                    │  ⎪
     │    └───────────────────────────────────────────┘  ⎭
     └ call_julia_output_fcn( ... STEP ...)
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre><p>see also help of <code>ODEInterface.SLATEC_continuation_call</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DdebdfArguments" href="#ODEInterface.DdebdfArguments"><code>ODEInterface.DdebdfArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct DdebdfArguments{FInt} &lt;: AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Ddebdf solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DdebdfInternalCallInfos" href="#ODEInterface.DdebdfInternalCallInfos"><code>ODEInterface.DdebdfInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Ddebdf-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> ddebdf
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     loop with iterations (intermediate-mode and/or OPT_OUTPUTATTIMES)
     │ ccall( DDEBDF_ ... ) # after 1st call: continuation call
     │    ┌───────────────────────────────────────────┐  ⎫
     │    │unsafe_SLATEC1RHSCallback                  │  ⎬ cb. rhs
     │    │    rhs                                    │  ⎪
     │    └───────────────────────────────────────────┘  ⎭
     │    ┌───────────────────────────────────────────┐  ⎫
     │    │unsafe_SLATEC1JacCallback                  │  ⎬ cb. jacobian
     │    │    call_julia_jac_fcn(             )      │  ⎪
     │    └───────────────────────────────────────────┘  ⎭
     └ call_julia_output_fcn( ... STEP ...)
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre><p>see also help of <code>ODEInterface.SLATEC_continuation_call</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DopriArguments" href="#ODEInterface.DopriArguments"><code>ODEInterface.DopriArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct DopriArguments{FInt&lt;:FortranInt} &lt;: 
          AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Dopri solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.DopriInternalCallInfos" href="#ODEInterface.DopriInternalCallInfos"><code>ODEInterface.DopriInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Dopri-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> dopri5/dop853
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     ccall( DOPRI5_/DOP853_ ... )
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW1RHSCallback                      │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_dopriSoloutCallback                 │  ⎪
        │    call_julia_output_fcn( ... STEP ...)   │  ⎪ cb. solout
        │        output_fcn ( ... STEP ...)         │  ⎬ with eval
        │            eval_sol_fcn                   │  ⎪
        │                ccall(CONTD5_/CONTD8_ ... )│  ⎪
        └───────────────────────────────────────────┘  ⎭
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.FeatureNotSupported" href="#ODEInterface.FeatureNotSupported"><code>ODEInterface.FeatureNotSupported</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that a requested feature is not supported or  is not possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.FortranInt" href="#ODEInterface.FortranInt"><code>ODEInterface.FortranInt</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>supported (signed) Integer types for Fortran codes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.FunctionCallNotSupported" href="#ODEInterface.FunctionCallNotSupported"><code>ODEInterface.FunctionCallNotSupported</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that a function was called at a time, where this is not possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.InternalErrorODE" href="#ODEInterface.InternalErrorODE"><code>ODEInterface.InternalErrorODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates an internal error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_ALL" href="#ODEInterface.LOG_ALL"><code>ODEInterface.LOG_ALL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log everything.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_BC" href="#ODEInterface.LOG_BC"><code>ODEInterface.LOG_BC</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to boundary condition function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_BVPIVPSOL" href="#ODEInterface.LOG_BVPIVPSOL"><code>ODEInterface.LOG_BVPIVPSOL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: during boundary value problems:  log calls to initial value solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_EVALSOL" href="#ODEInterface.LOG_EVALSOL"><code>ODEInterface.LOG_EVALSOL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to eval<em>sol</em>fcn function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_GENERAL" href="#ODEInterface.LOG_GENERAL"><code>ODEInterface.LOG_GENERAL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log some general info (esp. for main call).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_GUESS" href="#ODEInterface.LOG_GUESS"><code>ODEInterface.LOG_GUESS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to guess function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_JAC" href="#ODEInterface.LOG_JAC"><code>ODEInterface.LOG_JAC</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to jacobian function (of right-hand side).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_JACBC" href="#ODEInterface.LOG_JACBC"><code>ODEInterface.LOG_JACBC</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to jacobian function of boundary-/side-conditions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_MASS" href="#ODEInterface.LOG_MASS"><code>ODEInterface.LOG_MASS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to mass function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_NOTHING" href="#ODEInterface.LOG_NOTHING"><code>ODEInterface.LOG_NOTHING</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log nothing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_OUTPUTFCN" href="#ODEInterface.LOG_OUTPUTFCN"><code>ODEInterface.LOG_OUTPUTFCN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to julia output function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_RHS" href="#ODEInterface.LOG_RHS"><code>ODEInterface.LOG_RHS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to right-hand side.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_RHSDT" href="#ODEInterface.LOG_RHSDT"><code>ODEInterface.LOG_RHSDT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to right-hand side derivative function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_SOLOUT" href="#ODEInterface.LOG_SOLOUT"><code>ODEInterface.LOG_SOLOUT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log calls to solout function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.LOG_SOLVERARGS" href="#ODEInterface.LOG_SOLVERARGS"><code>ODEInterface.LOG_SOLVERARGS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Bitmask: log arguments passed to C/Fortran solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.MethodDLinfo" href="#ODEInterface.MethodDLinfo"><code>ODEInterface.MethodDLinfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type describing a dynamically loaded method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ODEInterface" href="#ODEInterface.ODEInterface"><code>ODEInterface.ODEInterface</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>ODEInterface</strong></p><p>This julia module provides an interface to solvers for  ordinary differential equations (ODEs) written in Fortran for solving initial value problems of the form</p><pre><code class="language-none">x&#39; = rhs(t,x),      x(t₀) = x₀</code></pre><p>or (for solvers supporting a &quot;mass matrix&quot; M)</p><pre><code class="language-none">M⋅x&#39; = rhs(t,x),    x(t₀) = x₀.</code></pre><p><strong>What does &quot;Interface&quot; mean?</strong></p><p>This julia module does <em>not</em> contain code for solving initial value problems, but this module does contain code for interacting with compiled Fortran-solvers. That&#39;s the reason, why this module is not called ODESuite.</p><p><strong>What solvers are currently supported?</strong></p><p>Currently the following Fortran-solvers, written by Prof. E. Hairer and Prof. G. Wanner, are supported:</p><ul><li>dopri5: explicit Runge-Kutta method of order 5(4) due to Dormand &amp; Prince</li><li>dop853: explicit Runge-Kutta method of order 8(5,3) due to Dormand &amp; Prince</li><li>odex: GBS extrapolation-algorithm based on the explicit midpoint rule</li><li>radau5: implicit Runge-Kutta method (Radau IIA) of order 5</li><li>radau: implicit Runge-Kutta method (Radau IIA) of variable order  between 5 and 13</li><li>seulex: extrapolation-algorithm based on the linear implicit Euler method</li><li>rodas: Rosenbrock method of order 4(3) (with possibly singular mass matrix)</li></ul><p>see <a href="http://www.unige.ch/~hairer/software.html">Software page of Prof. Hairer</a>.</p><p>Additionally the following Fortran-solvers from the <a href="http://www.netlib.org/slatec/">SLATEC Common Mathematical Library</a> are supported:</p><ul><li>ddeabm: Adams-Bashforth-Moulton Predictor-Corrector method (order between 1 and 12)</li><li>ddebdf: Backward Differentiation Formula (orders between 1 and 5)</li></ul><p>The following features of this solvers are supported by this ODEInterface:</p><ul><li>providing an output function (e.g. for dense output or for event location) to the solvers</li><li>providing mass- and jacobi-matrices for the solvers (with support for banded matrices)</li><li>all the solvers&#39; parameters for fine-tuning them</li><li>support for problems with &quot;special structure&quot;, see <code>help_specialstructure</code></li></ul><p>Also supported:</p><ul><li>bvpsol: a boundary value problem solver for highly nonlinear two point boundary value problems using either a local linear solver or a global sparse linear solver. <strong>Please note: The license for <code>bvpsol</code> only  covers non commercial use, see <a href="LICENSE.md">License</a>.</strong> written by P. Deuflhard, G. Bader, L. Weimann, see <a href="http://elib.zib.de/pub/elib/codelib/en/bvpode.html">CodeLib at ZIB</a>.</li><li>colnew: a multi-point boundary value problem solver for mixed order systems using collocation. Written by U. Ascher, G. Bader, see <a href="https://people.sc.fsu.edu/~jburkardt/f77_src/colnew/colnew.html">Colnew Homepage</a>.</li><li>BVP<em>M-2: a boundary value problem solver for the numerical solution of boundary value ordinary differential equations with defect and global error control. Written by J. J. Boisvert, P.H. Muir and R. J. Spiteri, see [BVP</em>M-2 Page](http://cs.stmarys.ca/~muir/BVP<em>SOLVER</em>Webpage.shtml).</li></ul><p><strong>What are the requirements for this module</strong></p><p>In order to use this module, you have to <em>compile</em> the supported Fortran solvers and provide a shared library for each solver. The build-script of this module tries to compile all solvers automatically. But you can use your own compiled versions (with different compile-time options or compilers). Just call <code>ODEInterface.help_solversupport</code> for further informations (help topics) on how to compile the solvers and how to create shared libraries.</p><p><strong>Further help</strong></p><p>see <code>ODEInterface.help_overview</code> for an overview of some help topics. </p><p><strong>Contacting the author of this module</strong></p><p>The author of this julia module is </p><pre><code class="language-none"> Dr. Christian Ludwig
 email: ludwig@ma.tum.de
   (Faculty of Mathematics, Technische Universität München)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ODE_SOLVER_INTERNAL" href="#ODEInterface.ODE_SOLVER_INTERNAL"><code>ODEInterface.ODE_SOLVER_INTERNAL</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Use the DIFEX1-solver builtin in bvpsol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ODE_SOLVER_JULIA" href="#ODEInterface.ODE_SOLVER_JULIA"><code>ODEInterface.ODE_SOLVER_JULIA</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Use the julia-function for solving the initial value problems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ODE_SOLVER_USAGE" href="#ODEInterface.ODE_SOLVER_USAGE"><code>ODEInterface.ODE_SOLVER_USAGE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The ode-solver to use for the initial value problems.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ODEinternalCallInfos" href="#ODEInterface.ODEinternalCallInfos"><code>ODEInterface.ODEinternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for ODE-Solver-Callbacks.</p></div></div></section><pre><code class="language-none">ODEInterface.OPT_ADDGRIDPOINTS</code></pre><pre><code class="language-none">ODEInterface.OPT_ATOL</code></pre><pre><code class="language-none">ODEInterface.OPT_BVPCLASS</code></pre><pre><code class="language-none">ODEInterface.OPT_COARSEGUESSGRID</code></pre><pre><code class="language-none">ODEInterface.OPT_COLLOCATIONPTS</code></pre><pre><code class="language-none">ODEInterface.OPT_DENSEOUTPUTWOEE</code></pre><pre><code class="language-none">ODEInterface.OPT_DIAGNOSTICOUTPUT</code></pre><pre><code class="language-none">ODEInterface.OPT_DIMOFIND1VAR</code></pre><pre><code class="language-none">ODEInterface.OPT_DIMOFIND2VAR</code></pre><pre><code class="language-none">ODEInterface.OPT_DIMOFIND3VAR</code></pre><pre><code class="language-none">ODEInterface.OPT_EPS</code></pre><pre><code class="language-none">ODEInterface.OPT_ERRORCONTROL</code></pre><pre><code class="language-none">ODEInterface.OPT_FREEZEINTERVALS</code></pre><pre><code class="language-none">ODEInterface.OPT_FREEZESSLEFT</code></pre><pre><code class="language-none">ODEInterface.OPT_FREEZESSRIGHT</code></pre><pre><code class="language-none">ODEInterface.OPT_INITIALSS</code></pre><pre><code class="language-none">ODEInterface.OPT_INITSTAGES</code></pre><pre><code class="language-none">ODEInterface.OPT_INTERPOLDEGREE</code></pre><pre><code class="language-none">ODEInterface.OPT_IVPOPT</code></pre><pre><code class="language-none">ODEInterface.OPT_JACOBIBANDSTRUCT</code></pre><pre><code class="language-none">ODEInterface.OPT_JACOBIMATRIX</code></pre><pre><code class="language-none">ODEInterface.OPT_JACRECOMPFACTOR</code></pre><pre><code class="language-none">ODEInterface.OPT_LAMBDADENSE</code></pre><pre><code class="language-none">ODEInterface.OPT_LOGIO</code></pre><pre><code class="language-none">ODEInterface.OPT_LOGLEVEL</code></pre><pre><code class="language-none">ODEInterface.OPT_M1</code></pre><pre><code class="language-none">ODEInterface.OPT_M2</code></pre><pre><code class="language-none">ODEInterface.OPT_MASSMATRIX</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXEXCOLUMN</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXNEWTONITER</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSS</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSTABCHECKLINE</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSTABCHECKS</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSTAGES</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSTEPS</code></pre><pre><code class="language-none">ODEInterface.OPT_MAXSUBINTERVALS</code></pre><pre><code class="language-none">ODEInterface.OPT_METHODCHOICE</code></pre><pre><code class="language-none">ODEInterface.OPT_MINSTAGES</code></pre><pre><code class="language-none">ODEInterface.OPT_NEWTONSTARTZERO</code></pre><pre><code class="language-none">ODEInterface.OPT_NEWTONSTOPCRIT</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERDECFACTOR</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERDECFRAC</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERDECSTEPFAC1</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERDECSTEPFAC2</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERINCFACTOR</code></pre><pre><code class="language-none">ODEInterface.OPT_ORDERINCFRAC</code></pre><pre><code class="language-none">ODEInterface.OPT_OUTPUTATTIMES</code></pre><pre><code class="language-none">ODEInterface.OPT_OUTPUTFCN</code></pre><pre><code class="language-none">ODEInterface.OPT_OUTPUTMODE</code></pre><pre><code class="language-none">ODEInterface.OPT_RHO</code></pre><pre><code class="language-none">ODEInterface.OPT_RHO2</code></pre><pre><code class="language-none">ODEInterface.OPT_RHSAUTONOMOUS</code></pre><pre><code class="language-none">ODEInterface.OPT_RHSTIMEDERIV</code></pre><pre><code class="language-none">ODEInterface.OPT_RHS_CALLMODE</code></pre><pre><code class="language-none">ODEInterface.OPT_RTOL</code></pre><pre><code class="language-none">ODEInterface.OPT_SINGULARTERM</code></pre><pre><code class="language-none">ODEInterface.OPT_SOLMETHOD</code></pre><pre><code class="language-none">ODEInterface.OPT_SSBETA</code></pre><pre><code class="language-none">ODEInterface.OPT_SSMAXSEL</code></pre><pre><code class="language-none">ODEInterface.OPT_SSMINSEL</code></pre><pre><code class="language-none">ODEInterface.OPT_SSREDUCTION</code></pre><pre><code class="language-none">ODEInterface.OPT_SSSELECTPAR1</code></pre><pre><code class="language-none">ODEInterface.OPT_SSSELECTPAR2</code></pre><pre><code class="language-none">ODEInterface.OPT_STEPSIZESEQUENCE</code></pre><pre><code class="language-none">ODEInterface.OPT_STEPSIZESTRATEGY</code></pre><pre><code class="language-none">ODEInterface.OPT_STEST</code></pre><pre><code class="language-none">ODEInterface.OPT_SUBINTERVALS</code></pre><pre><code class="language-none">ODEInterface.OPT_TRANSJTOH</code></pre><pre><code class="language-none">ODEInterface.OPT_TSTOP</code></pre><pre><code class="language-none">ODEInterface.OPT_WORKFORDEC</code></pre><pre><code class="language-none">ODEInterface.OPT_WORKFORJAC</code></pre><pre><code class="language-none">ODEInterface.OPT_WORKFORRHS</code></pre><pre><code class="language-none">ODEInterface.OPT_WORKFORSOL</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_CALL_DONE" href="#ODEInterface.OUTPUTFCN_CALL_DONE"><code>ODEInterface.OUTPUTFCN_CALL_DONE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is called for the last time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_CALL_INIT" href="#ODEInterface.OUTPUTFCN_CALL_INIT"><code>ODEInterface.OUTPUTFCN_CALL_INIT</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is called for 1st time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_CALL_REASON" href="#ODEInterface.OUTPUTFCN_CALL_REASON"><code>ODEInterface.OUTPUTFCN_CALL_REASON</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Possible reasons for calling the <code>OPT_OUTPUTFCN</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_CALL_STEP" href="#ODEInterface.OUTPUTFCN_CALL_STEP"><code>ODEInterface.OUTPUTFCN_CALL_STEP</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is called after a successfull  integration step</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_DENSE" href="#ODEInterface.OUTPUTFCN_DENSE"><code>ODEInterface.OUTPUTFCN_DENSE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is called after every successfull step  and dense output is supported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_MODE" href="#ODEInterface.OUTPUTFCN_MODE"><code>ODEInterface.OUTPUTFCN_MODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Possible mode for calling the <code>OPT_OUTPUTFCN</code>.</p><p>see <code>OPT_OUTPUTFCN</code> and <code>OPT_OUTPUTMODE</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_NEVER" href="#ODEInterface.OUTPUTFCN_NEVER"><code>ODEInterface.OUTPUTFCN_NEVER</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is never called.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_RETURN_VALUE" href="#ODEInterface.OUTPUTFCN_RETURN_VALUE"><code>ODEInterface.OUTPUTFCN_RETURN_VALUE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Possible return values of an <code>OPT_OUTPUTFCN</code>.</p><p>see <code>OPT_OUTPUTFCN</code> and <code>OPT_OUTPUTMODE</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_RET_CONTINUE" href="#ODEInterface.OUTPUTFCN_RET_CONTINUE"><code>ODEInterface.OUTPUTFCN_RET_CONTINUE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>tell ODE solver to continue.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_RET_CONTINUE_XCHANGED" href="#ODEInterface.OUTPUTFCN_RET_CONTINUE_XCHANGED"><code>ODEInterface.OUTPUTFCN_RET_CONTINUE_XCHANGED</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>tell ODE solver to continue and inform the solver, that the <code>OUTPUTFCN</code> has altered the numerical solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_RET_STOP" href="#ODEInterface.OUTPUTFCN_RET_STOP"><code>ODEInterface.OUTPUTFCN_RET_STOP</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>tell ODE solver to stop.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OUTPUTFCN_WODENSE" href="#ODEInterface.OUTPUTFCN_WODENSE"><code>ODEInterface.OUTPUTFCN_WODENSE</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>OPT_OUTPUTFCN</code> is called after every successfull step,  but no support for dense output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OdexArguments" href="#ODEInterface.OdexArguments"><code>ODEInterface.OdexArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct OdexArguments{FInt} &lt;: AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Odex solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OdexInternalCallInfos" href="#ODEInterface.OdexInternalCallInfos"><code>ODEInterface.OdexInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Odex-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> odex
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     ccall( ODEX_ ... )
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW1RHSCallback                      │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_odexSoloutCallback                  │  ⎪
        │    call_julia_output_fcn( ... STEP ...)   │  ⎪ cb. solout
        │        output_fcn ( ... STEP ...)         │  ⎬ with eval
        │            eval_sol_fcn                   │  ⎪
        │                ccall(CONTEX_ ... )        │  ⎪
        └───────────────────────────────────────────┘  ⎭
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OptionsODE" href="#ODEInterface.OptionsODE"><code>ODEInterface.OptionsODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Stores options for ODE-Solver(s) together with a name. Additionally the time of the last change is saved.</p><p>Options can be set at construction time, e.g.</p><pre><code class="language-none"> opt=OptionsODE(&quot;test&quot;,
                &quot;loglevel&quot; =&gt; ODEInterface.LOG_ALL,
                &quot;logio&quot;    =&gt; stderr)</code></pre><p>or later. For changing single options </p><pre><code class="language-none"> oldValue = setOption!(opt,&quot;myopt&quot;,&quot;new value&quot;)
 oldValue = setOption!(opt,&quot;myopt&quot; =&gt; &quot;new value&quot;)</code></pre><p>and for changing many options at once:</p><pre><code class="language-none"> oldValues = setOption!(opt,
             &quot;myopt&quot; =&gt; &quot;new value&quot;,
             &quot;oldopt&quot; =&gt; 56)</code></pre><p>see also: <code>setOption!</code>, <code>setOptions!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.OutputErrorODE" href="#ODEInterface.OutputErrorODE"><code>ODEInterface.OutputErrorODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that a function returned invalid output.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RHS_CALL_INSITU" href="#ODEInterface.RHS_CALL_INSITU"><code>ODEInterface.RHS_CALL_INSITU</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>The right-hand side has to return <code>nothing</code>. It gets an additional Array where it has to save the the values of <code>x&#39;</code>.</p><p>The right-hand side must be a function of the form</p><pre><code class="language-none"> funtion (t,x,dx) -&gt; nothing</code></pre><p><code>dx</code> is a <code>Vector{Float64}</code> with the same length as <code>x</code>. In <code>dx</code> the function has to fill in the values of <code>x&#39;</code>.</p></div></div></section><pre><code class="language-none">ODEInterface.RHS_CALL_MODE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RHS_CALL_RETURNS_ARRAY" href="#ODEInterface.RHS_CALL_RETURNS_ARRAY"><code>ODEInterface.RHS_CALL_RETURNS_ARRAY</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>The right-hand side has to return <code>x&#39;</code> as Array.</p><p>The right-hand side must be a function of the form</p><pre><code class="language-none"> funtion (t,x) -&gt; dx</code></pre><p><code>dx</code> is a <code>Vector{Float64}</code> with the same length as <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RadauArguments" href="#ODEInterface.RadauArguments"><code>ODEInterface.RadauArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> type RadauArguments{FInt&lt;:FortranInt} &lt;: 
          AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Radau5 and Radau solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RadauInternalCallInfos" href="#ODEInterface.RadauInternalCallInfos"><code>ODEInterface.RadauInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Radau5/Radau-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> radau5/radau
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     ccall( RADAU5_/RADAU_ ... )
         unsafe_HW1MassCallback  
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW2RHSCallback                      │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_radauSoloutCallback                 │  ⎪
        │    call_julia_output_fcn( ... STEP ...)   │  ⎪ cb. solout
        │        output_fcn ( ... STEP ...)         │  ⎬ with eval
        │            eval_sol_fcn                   │  ⎪
        │                ccall(CONTR5_/CONTRA_ ... )│  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW1JacCallback:                     │  ⎬ cb. jacobian
        │    call_julia_jac_fcn(             )      │  ⎪
        └───────────────────────────────────────────┘  ⎭
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RodasArguments" href="#ODEInterface.RodasArguments"><code>ODEInterface.RodasArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct RodasArguments{FInt&lt;:FortranInt} &lt;: 
          AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Rodas solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.RodasInternalCallInfos" href="#ODEInterface.RodasInternalCallInfos"><code>ODEInterface.RodasInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Rodas-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> rodas
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     ccall( RODAS_  ... )
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW2RHSCallback                      │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_rodasSoloutCallback:                │  ⎪
        │    call_julia_output_fcn( ... STEP ...)   │  ⎪ cb. solout
        │        output_fcn ( ... STEP ...)         │  ⎬ with eval
        │            eval_sol_fcn                   │  ⎪
        │                ccall(CONTRO_ ... )        │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW1JacCallback:                     │  ⎬ cb. jacobian
        │    call_julia_jac_fcn                     │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HWRhsTimeDerivCallback:             │  ⎬ cb. ∂f/∂t
        │    rhsdt                                  │  ⎪
        └───────────────────────────────────────────┘  ⎭
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SLATEC_continuation_call" href="#ODEInterface.SLATEC_continuation_call"><code>ODEInterface.SLATEC_continuation_call</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Some solvers have the conecpt of continuation calls (CC). This can be used to get some &quot;kind&quot; of dense output support. How does this work?</p><p>Typically the solver &quot;overshoots&quot; beyond T for calculating the solution at T (then with the help of interpolation):</p><pre><code class="language-none">                                            ↓ intermediate steps
 ──╫───┼────┼────┼─╫───┼─────             ──┼──
   t₀              T</code></pre><p>[Use <code>OPT_TSTOP</code> if the right-hand side is not defined for some t&gt;T or if there are singularities.]</p><p>If you do a CC and you want the solution at new Tₙ, then in the situtation</p><pre><code class="language-none"> ──╫───┼────┼────┼─╫──╫┼─────
   t₀              T  Tₙ</code></pre><p>where Tₙ is in the already computed interval, the solution at Tₙ can be computed simply by interpolation. If Tₙ is beyond the last computed interval then the solver continues with the process of numerical integration.</p><p>So CC can be cheap and the solver is optimized for CC. CC are much more efficient than a &quot;restart&quot; at T.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SLATEC_license" href="#ODEInterface.SLATEC_license"><code>ODEInterface.SLATEC_license</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><strong>License</strong></p><p>The solver ddeabm is part of the SLATEC Common Mathematical Library which is in the public domain. More informations can be found at</p><pre><code class="language-none"> http://www.netlib.org/slatec/guide</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SeulexArguments" href="#ODEInterface.SeulexArguments"><code>ODEInterface.SeulexArguments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none"> mutable struct SeulexArguments{FInt&lt;:FortranInt} &lt;: 
          AbstractArgumentsODESolver{FInt}</code></pre><p>Stores Arguments for Seulex solver.</p><p>FInt is the Integer type used for the fortran compilation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SeulexInternalCallInfos" href="#ODEInterface.SeulexInternalCallInfos"><code>ODEInterface.SeulexInternalCallInfos</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type encapsulating all required data for Seulex-Solver-Callbacks.</p><p>We have the typical calling stack:</p><pre><code class="language-none"> seulex       
     call_julia_output_fcn(  ... INIT ... )
         output_fcn ( ... INIT ...)
     ccall( SEULEX_  ... )
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW2RHSCallback                      │  ⎬ cb. rhs
        │    rhs                                    │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_seulexSoloutCallback                │  ⎪
        │    call_julia_output_fcn( ... STEP ...)   │  ⎪ cb. solout
        │        output_fcn ( ... STEP ...)         │  ⎬ with eval
        │            eval_sol_fcn                   │  ⎪
        │                ccall(CONTEX_ ... )        │  ⎪
        └───────────────────────────────────────────┘  ⎭
        ┌───────────────────────────────────────────┐  ⎫
        │unsafe_HW1JacCallback:                     │  ⎬ cb. jacobian
        │    call_julia_jac_fcn(             )      │  ⎪
        └───────────────────────────────────────────┘  ⎭
     call_julia_output_fcn(  ... DONE ... )
         output_fcn ( ... DONE ...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SolverDLinfo" href="#ODEInterface.SolverDLinfo"><code>ODEInterface.SolverDLinfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type describing the &quot;dynamic parts&quot; of a solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SolverInfo" href="#ODEInterface.SolverInfo"><code>ODEInterface.SolverInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type describing a solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SolverODEnotLoaded" href="#ODEInterface.SolverODEnotLoaded"><code>ODEInterface.SolverODEnotLoaded</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that a Fortran/C-solver is not loaded.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.SolverVariant" href="#ODEInterface.SolverVariant"><code>ODEInterface.SolverVariant</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type describing a &quot;variant&quot; of a solver.</p><p>What is a variant of a solver? Some solvers support more than one forms of dynamic libraries, e.g. with 32bit integers and with 64bit integers. The purpose of this type is to have enough fields for  describing such an variant.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.StateErrorODE" href="#ODEInterface.StateErrorODE"><code>ODEInterface.StateErrorODE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This error indicates that an object is in the wrong state, e.g. is not initialized.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.WrappedODEException" href="#ODEInterface.WrappedODEException"><code>ODEInterface.WrappedODEException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The ancestor for all wrapped exceptions in ODEInterface.</p><p>Required fields: msg, error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.__init__" href="#ODEInterface.__init__"><code>ODEInterface.__init__</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>will be called once after the module is loaded at runtime.</p></div></div></section><pre><code class="language-none">ODEInterface.buf2str</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_Dbc" href="#ODEInterface.bvpm2_Dbc"><code>ODEInterface.bvpm2_Dbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>Dbc</code> saved in Bvpm2<em>solve</em>cbi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_Drhs" href="#ODEInterface.bvpm2_Drhs"><code>ODEInterface.bvpm2_Drhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>Drhs</code> saved in Bvpm2<em>solve</em>cbi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_bc" href="#ODEInterface.bvpm2_bc"><code>ODEInterface.bvpm2_bc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>bc</code> saved in Bvpm2<em>solve</em>cbi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_check_handle" href="#ODEInterface.bvpm2_check_handle"><code>ODEInterface.bvpm2_check_handle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tests if Bvpm2-object is &quot;connected&quot; to a Fortran-proxy handle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_check_state" href="#ODEInterface.bvpm2_check_state"><code>ODEInterface.bvpm2_check_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tests if the Bvpm2-object is in one of the expected states.</p><p>Throws an Error of the state is not expected.</p><p>Returns details dict.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_copy" href="#ODEInterface.bvpm2_copy"><code>ODEInterface.bvpm2_copy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_copy(obj_in::Bvpm2) -&gt; obj_out</code></pre><p>creates a deep copy <code>obj_out</code> of the Bvpm2-object <code>obj_in</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_create_handle" href="#ODEInterface.bvpm2_create_handle"><code>ODEInterface.bvpm2_create_handle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_create_handle(obj::Bvpm2)</code></pre><p>create Fortran Proxy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_destroy" href="#ODEInterface.bvpm2_destroy"><code>ODEInterface.bvpm2_destroy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_destroy(obj::Bvpm2)</code></pre><p>destroys Bvpm2-object. Especially free all (Fortran-)allocated memory and disconnect from Fortran-Proxy(-handle).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_extend" href="#ODEInterface.bvpm2_extend"><code>ODEInterface.bvpm2_extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_extend(sol_obj::Bvpm2, anew, bnew, 
          yanew::Vector, ybnew::Vector; 
          p_new=[], max_num_subintervals=0)</code></pre><p>extends a solution (<code>state == 2</code>) to a new interval. Take the two given states <code>yanew</code> and <code>ybnew</code> as new states for the new interval. (If <code>anew ≥ a</code> then <code>yanew</code> is ignored. If <code>bnew ≤ b</code> then ybnew is ignored.)</p><p>You can change the parameter guess also, by using <code>p_new</code> and you can change the maximal number of subintervals, too.</p><p>sol<em>obj will be &quot;terminated&quot;. After the call `sol</em>obj<code>will be in state 0. Use</code>bvpm2_copy` before, if you need the solution afterwards.</p><p>A new Bvpm2-object <code>guess_obj</code> will be created an returned.</p></div></div><div><div><pre><code class="language-none"> function bvpm2_extend(sol_obj::Bvpm2, anew, bnew, order; 
          p_new::Vector=[], max_num_subintervals=0)</code></pre><p>extends a solution (<code>state == 2</code>) to a new interval using  constant (<code>order==0</code>) or linear (<code>order==1</code>) extrapolation.</p><p>You can change the parameter guess also, by using <code>p_new</code> and you can change the maximal number of subintervals, too.</p><p>sol<em>obj will be &quot;terminated&quot;. After the call `sol</em>obj<code>will be in state 0. Use</code>bvpm2_copy` before, if you need the solution afterwards.</p><p>A new Bvpm2-object <code>guess_obj</code> will be created an returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_get_details" href="#ODEInterface.bvpm2_get_details"><code>ODEInterface.bvpm2_get_details</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_get_details(obj::Bvpm2)</code></pre><p>returns dict with informations about an Bvpm2 object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_get_params" href="#ODEInterface.bvpm2_get_params"><code>ODEInterface.bvpm2_get_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_get_params(obj::Bvpm2)</code></pre><p>returns current vector with parameters of Bvpm2 object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_get_x" href="#ODEInterface.bvpm2_get_x"><code>ODEInterface.bvpm2_get_x</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>returns current vector with x-grid of Bvpm2 object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_global_cbi" href="#ODEInterface.bvpm2_global_cbi"><code>ODEInterface.bvpm2_global_cbi</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>BVP_M-2 uses global variables during the solution process. Hence we can only support one bvpm2 solve-call at a time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_guess" href="#ODEInterface.bvpm2_guess"><code>ODEInterface.bvpm2_guess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>guess_fcn</code> saved in Bvpm2<em>guess</em>cbi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_init" href="#ODEInterface.bvpm2_init"><code>ODEInterface.bvpm2_init</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_init(obj::Bvpm2,
   no_odes, no_left_bc, x_grid::Vector, constant_guess::Vector, 
   parameters::Vector=[], max_num_subintervals=3000)</code></pre><p>initialize Bvpm2 object with a constant intial guess.</p></div></div><div><div><pre><code class="language-none"> function bvpm2_init(obj::Bvpm2,
   no_odes, no_left_bc, x_grid::Vector, guess::Matrix, 
   parameters::Vector=[], max_num_subintervals=3000)</code></pre><p>initialize Bvpm2 object with a guess for every state at every node in x_grid.</p></div></div><div><div><pre><code class="language-none"> function bvpm2_init(obj, no_odes, no_left_bc, x_grid, 
                     guess&lt;:Function, parameters, 
                     max_num_subintervals=3000)</code></pre><p>The guess function must have the form</p><pre><code class="language-none"> function guess(x,y)</code></pre><p>where inside the function the guess for position x has to be stored in y.</p><p>initialize Bvpm2 object where the function <code>guess</code> is used to get the guesses for the state at different <code>x</code> values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_init_tests" href="#ODEInterface.bvpm2_init_tests"><code>ODEInterface.bvpm2_init_tests</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_init_tests(obj::Bvpm2, no_odes, no_left_bc, 
     x_grid::Vector, parameters::Vector, max_num_subintervals)</code></pre><p>init tests for common parameters.</p></div></div></section><pre><code class="language-none">ODEInterface.bvpm2_is_handle_valid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_rhs" href="#ODEInterface.bvpm2_rhs"><code>ODEInterface.bvpm2_rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>rhs</code> saved in Bvpm2<em>solve</em>cbi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_show_details" href="#ODEInterface.bvpm2_show_details"><code>ODEInterface.bvpm2_show_details</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_show_details(obj::Bvpm2)</code></pre><p>Debug: call show_details Fortran subroutine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_solve" href="#ODEInterface.bvpm2_solve"><code>ODEInterface.bvpm2_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_solve(guess_obj::Bvpm2, rhs, bc, 
   opt::AbstractOptionsODE) -&gt; (obj_out, retcode, stats)</code></pre><p><strong>Right-hand side for the ODEs: <code>rhs</code></strong></p><p>The function <code>rhs</code> must have the form:</p><pre><code class="language-none"> function rhs(x, y, f)              [no_par == 0]
 function rhs(x, y, p, f)           [no_par != 0]</code></pre><p>where</p><pre><code class="language-none">  x::Float, y::Vector{Float64}(no_odes), p::Vector{Float64}(no_par)
  f::Vector{Float64}(no_odes)</code></pre><p>Inside the function, the values of the right-hand side must be saved in <code>f</code>.</p><p><strong>Derivatives of right-hand side: <code>Drhs</code></strong></p><p>The function <code>Drhs</code> is optional. If not given finite differences are used to approximate the derivatives. If <code>Drhs</code> is given it must have the form:</p><pre><code class="language-none"> function Drhs(x, y, dfdy)          [no_par == 0]
 function Drhs(x, y, p, dfdy, dfdp) [no_par != 0]</code></pre><p>where</p><pre><code class="language-none">  x::Float, y::Vector{Float64}(no_odes), p::Vector{Float64}(no_par)
  dfdy::Matrix{Float64}(no_odes, no_odes)
  dfdp::Matrix{Float64}(no_odes, no_par)</code></pre><p>Inside the function, the values of the derivatives must be saved in <code>dfdy</code> and <code>dfdp</code>.</p><p><strong>Boundary conditions: <code>bc</code></strong></p><p>The function <code>bc</code> must have the form:</p><pre><code class="language-none"> function bc(ya, yb, bca, bcb)      [no_par == 0]
 function bc(ya, yb, p, bca, bcb)   [no_par != 0]</code></pre><p>where</p><pre><code class="language-none">  ya::Vector{Float64}(no_odes), yb::Vector{Float64}(no_odes), 
  p::Vector{Float64}(no_par),
  bca::Vector{Float64}(no_left_bc),
  bcb::Vector{Float64}(no_odes - no_left_bc)</code></pre><p>Inside the function, the values of the boundary conditions must be saved in <code>bca</code> and <code>bcb</code>.</p><p><strong>Derivatives of the boundary conditons: <code>Dbc</code></strong></p><p>The function <code>Dbc</code> is optional. If not given finite differences are used to approximate the derivatives. If <code>Dbc</code> is given it must have the form:</p><pre><code class="language-none"> function Dbc(ya, yb, dya, dyb)                 [no_par == 0]
 function Dbc(ya, yb, dya, dyb, p, dpa, dpb)    [no_par != 0]</code></pre><p>where</p><pre><code class="language-none">  ya::Vector{Float64}(no_odes), yb::Vector{Float64}(no_odes), 
  p::Vector{Float64}(no_par),
  dya::Matrix{Float64}(no_left_bc, no_odes)
  dyb::Matrix{Float64}(no_odes+no_par-no_left_bc, no_odes)
  dpa::Matrix{Float64}(no_left_bc, no_par)
  dpb::Matrix{Float64}(no_odes+no_par-no_left_bc, no_par)</code></pre><p>Inside the function, the values of the derivatives of the boundary  conditions must be saved in <code>dya</code>, <code>dyb</code>, <code>dpa</code> and <code>dpb</code>.</p><p><strong>Options <code>opt</code></strong></p><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL            │ relative accuracy for solution.          │    1e-6 ║
║                 │ solution. Must be a scalar.              │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ METHODCHOICE    │ Choice for IVP-solvers:                  │       4 ║
║                 │ 2: Runge-Kutta method of order 2         │         ║
║                 │ 4: Runge-Kutta method of order 4         │         ║
║                 │ 6: Runge-Kutta method of order 6         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ DIAGNOSTICOUTPUT│ diagnostic output for bvpm2:             │      -1 ║
║                 │   -1 : no output                         │         ║
║                 │    0 : only output if computation fails  │         ║
║                 │    1 : intermediate output               │         ║
║                 │    2 : full output                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ERRORCONTROL    │ determines the error-estimation for      │       1 ║
║                 │ which RTOL is used:                      │         ║
║                 │    1 : defect                            │         ║
║                 │    2 : global error                      │         ║
║                 │    3 : defect and then global error      │         ║
║                 │    4 : linear combination of defect      │         ║
║                 │        and global error                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SINGULARTERM    │ either nothing if the ODEs have no       │ nothing ║
║                 │ singular terms at the left boundary or   │         ║
║                 │ a constant (d,d) matrix for the          │         ║
║                 │ singular term.                           │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre><p><strong>Return-Code <code>retcode</code></strong></p><p><code>retcode</code> can have to following values:</p><pre><code class="language-none">  &lt;0: failure
  ≥0: computation successful</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpm2_terminate" href="#ODEInterface.bvpm2_terminate"><code>ODEInterface.bvpm2_terminate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpm2_terminate(obj::Bvpm2)</code></pre><p>Terminates Bvpm2-object. Put in state as if after creation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpsol" href="#ODEInterface.bvpsol"><code>ODEInterface.bvpsol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function bvpsol(rhs, bc,
   t::Vector, x::Matrix, odesolver, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p>The <code>bc</code> has to be a function of the following form:</p><pre><code class="language-none"> function bc(xa,xb,r) -&gt; nothing</code></pre><p>It has to calculate the residual for the boundary conditions and save them in <code>r</code>.</p><p><code>t</code> is a Vector with all the multiple-shooting nodes.</p><p><code>x</code> gives the initial guess for all multiple-shooting nodes. Hence <code>size(x,2)==length(t)</code>.</p><p><code>odesolver</code>: Either <code>nothing</code>: then the internal solver of <code>bvpsol</code> is used. Or <code>odesolver</code> is a ode-solver (like <code>dopri5</code>, <code>dop853</code>, <code>seulex</code>,  etc.).</p><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  &gt;0: computation successful: number of iterations
  -1:        Iteration stops at stationary point for OPT_SOLMETHOD==0
             Gaussian elimination failed due to singular 
             Jacobian for OPT_SOLMETHOD==1
  -2: Iteration stops after OPT_MAXSTEPS 
  -3: Integrator failed to complete the trajectory
  -4: Gauss Newton method failed to converge
  -5: Given initial values inconsistent with separable linear bc
  -6:        Iterative refinement faild to converge for OPT_SOLMETHOD==0
             Termination since multiple shooting condition or
             condition of Jacobian is too bad for OPT_SOLMETHOD==1
  -7: wrong EPS (should not happen; checked by ODEInterface module)
  -8: Condensing algorithm for linear block system fails, try
      OPT_SOLMETHOD==1
  -9: Sparse linear solver failed
 -10: Real or integer work-space exhausted
 -11: Rank reduction failed - resulting rank is zero</code></pre><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL            │ relative accuracy for soltuion           │    1e-6 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximum permitted number of iteration    │      40 ║
║                 │ steps                                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ BVPCLASS        │ boundary value problem classification:   │       2 ║
║                 │ 0: linear                                │         ║
║                 │ 1: nonlinear with good initial data      │         ║
║                 │ 2: highly nonlinear &amp; bad initial data   │         ║
║                 │ 3: highly nonlinear &amp; bad initial data &amp; │         ║
║                 │    initial rank reduction to separable   │         ║
║                 │    linear boundary conditions            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SOLMETHOD       │ switch for solution method               │       0 ║
║                 │ 0: use local linear solver with          │         ║
║                 │    condensing algorithm                  │         ║
║                 │ 1: use global sparse linear solver       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ IVPOPT          │ An OptionsODE-object with the options    │ empty   ║
║                 │ for the solver of the initial value      │ options ║
║                 │ problem.                                 │         ║
║                 │ In this OptionsODE-object bvpsol changes │         ║
║                 │ OPT_MAXSS, OPT_INITIALSS, OPT_RTOL       │         ║
║                 │ to give the IVP-solver solution hints.   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RHS_CALLMODE    │ see help_callsolvers()                   │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpsol_global_cbi" href="#ODEInterface.bvpsol_global_cbi"><code>ODEInterface.bvpsol_global_cbi</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>bvpsol does not support &quot;pass-through&quot; arguments for FCN and BC. Hence we can only support one bvpsol-call at a time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpsol_i32" href="#ODEInterface.bvpsol_i32"><code>ODEInterface.bvpsol_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>bvpsol with 32bit integers, see bvpsol.</p></div></div></section><pre><code class="language-none">ODEInterface.bvpsol_impl</code></pre><pre><code class="language-none">ODEInterface.bvpsol_ivp_dummy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.bvpsolbc" href="#ODEInterface.bvpsolbc"><code>ODEInterface.bvpsolbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function bvpsolbc{CI}(xa,xb,r,cbi::CI)</code></pre><p>This function calls <code>bc</code> saved in <code>BvpsolInternalCallInfos</code>.</p></div></div></section><pre><code class="language-none">ODEInterface.bvpsolivp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.call_julia_output_fcn" href="#ODEInterface.call_julia_output_fcn"><code>ODEInterface.call_julia_output_fcn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function call_julia_output_fcn{CI&lt;:ODEinternalCallInfos}(cbi::CI,
    reason:: OUTPUTFCN_CALL_REASON, told::Float64,t::Float64, 
    x::Vector{Float64},eval_sol_fcn::Function)</code></pre><p>calls the julia output function with the given arguments.</p><p>This is more than a simple call, because this function takes care of logging, error-checking, etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.check_slatec_output_mode" href="#ODEInterface.check_slatec_output_mode"><code>ODEInterface.check_slatec_output_mode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>checks if output mode is supported and gives hint to <code>OPT_OUTPUTATTIMES</code> if the mode <code>OUTPUTFCN_DENSE</code> was requested.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew" href="#ODEInterface.colnew"><code>ODEInterface.colnew</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function colnew(interval::Vector, orders::Vector, ζ::Vector,
    rhs, Drhs,
    bc, Dbc, guess, opt::AbstractOptionsODE)
      -&gt; (sol, retcode, stats)</code></pre><p>Solve multi-point boundary value problem with colnew.</p><p>ζ∊ℝᵈ with a ≤ ζ(1)=ζ₁ ≤ ζ(2)=ζ₂ ≤ ⋯ ≤ ζ(d) ≤ b are the (time-)points were side/boundary conditions are given:</p><pre><code class="language-none">       bc₁   bc₂       bc₃                 bcⱼ(ζⱼ, z(x(ζⱼ))) = 0
        ∙     ∙         ∙  ⋯

  ├─────┼─────┼─────────┼─....───┼─────┤
 t=a  t=ζ(1) t=ζ(2)    t=ζ(3)  t=ζ(d)  t=b</code></pre><p>for the n ODEs        ∂xᵢ       ──────  = xᵢ⁽ᵐ⁽ⁱ⁾⁾ = fᵢ(t, z(x(t))          (i=1,2,…,n)   [*]       ∂tᵐ⁽ⁱ⁾</p><p>where the i-th ODE has order m(i). [x(t)∊ℝⁿ].</p><p>z is the transformation to first order: z(x(t))∊ℝᵈ is the &quot;first-order&quot; state one gets if the n ODEs [*] are transformed to a first-order system:</p><pre><code class="language-none"> z(x(t)) = ( x₁(t), x₁&#39;(t), x₁&#39;&#39;(t), …, x₁⁽ᵐ⁽¹⁾⁻¹⁾,
             x₂(t), x₂&#39;(t), x₂&#39;&#39;(t), …, x₂⁽ᵐ⁽²⁾⁻¹⁾,
             ⋯                                    ,
             xₙ(t), xₙ&#39;(t), xₙ&#39;&#39;(t), …, xₙ⁽ᵐ⁽ⁿ⁾⁻¹⁾  )</code></pre><p>Hence one has the requirement: ∑m(i) = d.</p><p>The boundary-/side-conditions at the points ζⱼ=ζ(j) are given in the form</p><pre><code class="language-none"> bcⱼ(ζⱼ, z(x(ζⱼ))) = 0                         (j=1,2,…,d)</code></pre><p>Restrictions (in the colnew code):</p><ul><li>at maximum 20 ODEs: n ≤ 20</li><li>at maximum 40 dimensions: d ≤ 40</li><li>The orders m(i) have to satisfy: 1 ≤ m(i) ≤ 4   for all i=1,2,…,n.</li></ul><p>All (Julia-)callback-functions (like rhs, etc.) use the in-situ call-mode, i.e. they have to write the result in a preallocated vector.</p><p><strong>rhs</strong></p><p><code>rhs</code> must be a function of the form</p><pre><code class="language-none">function rhs(t, z, f)</code></pre><p>with the input data: t (scalar) time and z∈ℝᵈ (z=z(x(t))). The values of the right-hand side have to be saved in f: f∈ℝⁿ!  Only the non-trivial parts of the right-hand side must be calculated.</p><p><strong>Drhs</strong></p><p><code>Drhs</code> must be a function of the form</p><pre><code class="language-none">function Drhs(t, z, df)</code></pre><p>with the input data: t (scalar) time and z∈ℝᵈ (z=z(x(t))). The values of the jacobian of the right-hand side have to be saved in df: df∈ℝⁿˣᵈ!</p><pre><code class="language-none">           ∂fᵢ
df(i,j) = ─────      (i=1,…,n;  j=1,…,d)
           ∂zⱼ</code></pre><p><strong>bc</strong></p><p><code>bc</code> must be a function of the form</p><pre><code class="language-none">function bc(i, z, bc)</code></pre><p>with the input data: integer index i and z∈ℝᵈ (z=z(x(t))). The scalar(!) value of the i-th side-condition (at time ζ(i)) has to be saved in bc, which is a vector of length 1.</p><p><strong>Dbc</strong></p><p><code>Dbc</code> must be a function of the form</p><pre><code class="language-none">function Dbc(i, z, dbc)</code></pre><p>with the input data: integer index i and z∈ℝᵈ (z=z(x(t))). The  values of the derivative of the i-th side-condition  (at time ζ(i)) has to be saved in dbc:</p><pre><code class="language-none">          ∂bcᵢ
dbc(j) = ─────      (j=1,…,d)
          ∂zⱼ</code></pre><p><strong>guess</strong></p><p><code>guess</code> can be <code>nothing</code>, i.e. no initial guess given. Or <code>guess</code> can be the sol return value of an earilier call of <code>colnew</code>. In such a case the former mesh and the former solution is taken as an initial guess (or is coarsen, see <code>OPT_COARSEGUESSGRID</code>).</p><p>Or <code>guess</code> is a function of the form</p><pre><code class="language-none">function guess(t, z, dmx)</code></pre><p>with the input data t∈[a,b]. Guesses are needed for the following values: z=z(x(t))∈ℝᵈ and</p><pre><code class="language-none">          ∂xᵢ
dmx(i) = ────────      (i=1,…,n)
          ∂tᵐ⁽ⁱ⁾</code></pre><p><strong>return values</strong></p><p><code>sol</code> is a solution object which can be evaluated with the  <code>evalSolution</code> functions. Or you can ask for the (final) grid of the solution with <code>getSolutionGrid</code>.</p><p><code>retcode</code> can have to following values:</p><pre><code class="language-none">  &gt;0: computation successful
   0: collocation matrix is singular
  -1: the expected no. of subintervals exceeds storage
      (try to increase `OPT_MAXSUBINTERVALS`)
  -2: the nonlinear iteration has not converged
  -3: there is an input data error</code></pre><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ BVPCLASS        │ boundary value problem classification:   │       1 ║
║                 │ 0: linear                                │         ║
║                 │ 1: nonlinear and regular                 │         ║
║                 │ 2: nonlinear and &quot;extra sensitive&quot;       │         ║
║                 │    (first relax factor is rstart and the │         ║
║                 │    nonlinear iteration does not rely     │         ║
║                 │    on past convergence)                  │         ║
║                 │ 3: fail-early: return immediately upon   │         ║
║                 │    (a) two successive non-convergences   │         ║
║                 │        or                                │         ║
║                 │    (b) after obtaining an error estimate │         ║
║                 │        for the first time                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RTOL            │ relative *and* absolute accuracy for     │    1e-6 ║
║                 │ solution. Must be a vector of length d.  │         ║
║                 │ If a scalar is given (like the default   │         ║
║                 │ value of 1e-6) then the vector           │         ║
║                 │    RTOL*ones(Float64, d)                 │         ║
║                 │ is generated.                            │         ║
║                 │ Some entries can be NaN! If an entry     │         ║
║                 │ is NaN, then no error checking is done   │         ║
║                 │ for this component.                      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ COLLOCATIONPTS  │ number (=k) of collocation points per    │ see left║
║                 │ sub-interval.                            │         ║
║                 │ Requirement:                             │         ║
║                 │   orders[i] ≤ k ≤ 7                      │         ║
║                 │ Default:                                 │         ║
║                 │   k = max( max(orders)+1, 5-max(orders) )│         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SUBINTERVALS    │ Either a positive integer scalar or a    │       5 ║
║                 │ vector of (Float)-times:                 │         ║
║                 │                                          │         ║
║                 │ (a) scalar: use a &quot;uniform-like&quot; initial │         ║
║                 │ grid with the given integer as number    │         ║
║                 │ of subintervals.                         │         ║
║                 │ Why &quot;uniform-like&quot; and not &quot;uniform&quot;?    │         ║
║                 │ Because all values of ζ and all values of│         ║
║                 │ OPT_ADDGRIDPOINTS have to be in the grid.│         ║
║                 │ If the scalar is too small for all this  │         ║
║                 │ values it is increased (internally).     │         ║
║                 │                                          │         ║
║                 │ (b) vector: all points must be inside    │         ║
║                 │ the interval (a,b). Then this points     │         ║
║                 │ are used as initial grid. Values of ζ,   │         ║
║                 │ OPT_ADDGRIDPOINTS and a and b are added  │         ║
║                 │ automatically by this interface.         │         ║
║                 │                                          │         ║
║                 │ If the guess is an solution object,      │         ║
║                 │ then this grid saved there is used       │         ║
║                 │ (and not the values given in             │         ║
║                 │ `OPT_SUBINTERVALS`).                     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ FREEZEINTERVALS │ Only used if OPT_SUBINTERVALS is a       │   false ║
║                 │ vector. In this case this flags indicates│         ║
║                 │ if colnew is allowed to adaptively       │         ║
║                 │ change the grid.                         │         ║
║                 │ If true, all grid adaption is turned off │         ║
║                 │ and no mesh selection is done.           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSUBINTERVALS │ number of maximal subintervals.          │      50 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ COARSEGUESSGRID │ If `guess` is an solution obtained by a  │    true ║
║                 │ former call of `colnew`, then this       │         ║
║                 │ solution is taken as guess, and the mesh │         ║
║                 │ provided by this solution is taken twice │         ║
║                 │ as coarse.                               │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ DIAGNOSTICOUTPUT│ diagnostic output for colnew:            │       1 ║
║                 │   -1 : full diagnostic printout          │         ║
║                 │    0 : selected printout                 │         ║
║                 │    1 : no printout                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ADDGRIDPOINTS   │ additional points that are always added  │      [] ║
║                 │ to every (time-)grid.                    │         ║
║                 │ Every grid contains all values in ζ and  │         ║
║                 │ the values in the interval argument.     │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_Dbc" href="#ODEInterface.colnew_Dbc"><code>ODEInterface.colnew_Dbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>Dbc</code> saved in ColnewInternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_Drhs" href="#ODEInterface.colnew_Drhs"><code>ODEInterface.colnew_Drhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>Drhs</code> saved in ColnewInternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_bc" href="#ODEInterface.colnew_bc"><code>ODEInterface.colnew_bc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>bc</code> saved in ColnewInternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_global_cbi" href="#ODEInterface.colnew_global_cbi"><code>ODEInterface.colnew_global_cbi</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>colnew does not support &quot;pass-through&quot; arguments for FSUB, DFSUB, GSUB, DGSUB, GUES. Hence we can only support one colnew-call at a time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_guess" href="#ODEInterface.colnew_guess"><code>ODEInterface.colnew_guess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>guess</code> saved in ColnewInternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_i32" href="#ODEInterface.colnew_i32"><code>ODEInterface.colnew_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>colnew with 32bit integers, see colnew.</p></div></div></section><pre><code class="language-none">ODEInterface.colnew_impl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.colnew_rhs" href="#ODEInterface.colnew_rhs"><code>ODEInterface.colnew_rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function calls <code>rhs</code> saved in ColnewInternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.copyOptions!" href="#ODEInterface.copyOptions!"><code>ODEInterface.copyOptions!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function copyOptions!(dest::AbstractOptionsODE,source::AbstractOptionsODE)</p><p>copy all options from other ODE-Option object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.createBandedMatrix" href="#ODEInterface.createBandedMatrix"><code>ODEInterface.createBandedMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>convert full matrix to BandedMatrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.create_dopri_eval_sol_fcn_closure" href="#ODEInterface.create_dopri_eval_sol_fcn_closure"><code>ODEInterface.create_dopri_eval_sol_fcn_closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function create_dopri_eval_sol_fcn_closure( cbi::CI, d::FInt, 
         method_contd::Ptr{Cvoid}) where {FInt&lt;:FortranInt, 
                                         CI&lt;:DopriInternalCallInfos}</code></pre><p>generates a eval<em>sol</em>fcn for dopri5 and dop853.</p><p>Why is a closure needed? We need a function <code>eval_sol_fcn</code> that calls <code>CONTD5_</code> or <code>CONTD8_</code> (with <code>ccall</code>). But <code>CONTD?_</code> needs the informations for the current state. This informations were saved by <code>unsafe_dopriSoloutCallback</code> in the <code>DopriInternalCallInfos</code>. <code>eval_sol_fcn</code> needs to get this informations. Here comes <code>create_dopri_eval_sol_fcn_closure</code> into play: this function takes the call-informations and generates a <code>eval_sol_fcn</code> with this data.</p><p>Why doesn&#39;t <code>unsafe_dopriSoloutCallback</code> generate a closure (then the current state needs not to be saved in <code>DopriInternalCallInfos</code>)? Because then every call to <code>unsafe_dopriSoloutCallback</code> would have generated a closure function. That&#39;s a lot of overhead: 1 closure function for every solout call. With the strategy above, we have 1 closure function per ODE-solver-call, i.e. 1 closure function per ODE.</p><p>For the typical calling sequence, see <code>DopriInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.create_odex_eval_sol_fcn_closure" href="#ODEInterface.create_odex_eval_sol_fcn_closure"><code>ODEInterface.create_odex_eval_sol_fcn_closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function create_odex_eval_sol_fcn_closure(cbi::CI, d::FInt, 
         method_contex::Ptr{Cvoid}) where {FInt&lt;:FortranInt,
                                          CI&lt;:OdexInternalCallInfos}</code></pre><p>generates a eval<em>sol</em>fcn for odex.</p><p>Why is a closure needed? We need a function <code>eval_sol_fcn</code> that calls <code>CONTEX_</code> (with <code>ccall</code>). But <code>CONTEX_</code> needs the informations for the current state. This informations were saved by <code>unsafe_odexSoloutCallback</code> in the <code>OdexInternalCallInfos</code>. <code>eval_sol_fcn</code> needs to get this informations. Here comes <code>create_odex_eval_sol_fcn_closure</code> into play: this function takes the call informations and generates a <code>eval_sol_fcn</code> with this data.</p><p>Why doesn&#39;t <code>unsafe_odexSoloutCallback</code> generate a closure (then the current state needs not to be saved in <code>OdexInternalCallInfos</code>)? Because then every call to <code>unsafe_odexSoloutCallback</code> would have generated a closure function. That&#39;s a lot of overhead: 1 closure function for every solout call. With the strategy above, we have 1 closure function per ODE-solver-call, i.e. 1 closure function per ODE.</p><p>For the typical calling sequence, see <code>OdexInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.create_radau_eval_sol_fcn_closure" href="#ODEInterface.create_radau_eval_sol_fcn_closure"><code>ODEInterface.create_radau_eval_sol_fcn_closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function create_radau_eval_sol_fcn_closure(cbi::CI, d::FInt, 
         method_cont::Ptr{Cvoid}) where {FInt&lt;:FortranInt,
                                        CI&lt;:RadauInternalCallInfos}</code></pre><p>generates a eval<em>sol</em>fcn for radau and radau5.</p><p>Why is a closure needed? We need a function <code>eval_sol_fcn</code> that calls <code>CONTR5_</code> OR <code>CONTRA_</code> (with <code>ccall</code>). But <code>CONTR5_</code>/<code>CONTRA_</code> need the informations for the current state. This informations were saved by <code>unsafe_radauSoloutCallback</code> in the <code>RadauInternalCallInfos</code>. <code>eval_sol_fcn</code> needs to get this informations. Here comes <code>create_radau_eval_sol_fcn_closure</code> into play: this function takes call informations and generates a <code>eval_sol_fcn</code> with this data.</p><p>Why doesn&#39;t <code>unsafe_radauSoloutCallback</code> generate a closure (then the current state needs not to be saved in <code>RadauInternalCallInfos</code>)? Because then every call to <code>unsafe_radauSoloutCallback</code> would have generated a closure function. That&#39;s a lot of overhead: 1 closure function for every solout call. With the strategy above, we have 1 closure function per ODE-solver-call, i.e. 1 closure function per ODE.</p><p>For the typical calling sequence, see <code>RadauInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.create_rodas_eval_sol_fcn_closure" href="#ODEInterface.create_rodas_eval_sol_fcn_closure"><code>ODEInterface.create_rodas_eval_sol_fcn_closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function create_rodas_eval_sol_fcn_closure(cbi::CI, d::FInt, 
         method_contro::Ptr{Cvoid}) where {FInt&lt;:FortranInt, 
                                          CI&lt;:RodasInternalCallInfos}</code></pre><p>generates a eval<em>sol</em>fcn for rodas.</p><p>Why is a closure needed? We need a function <code>eval_sol_fcn</code> that calls <code>CONTRO_</code> (with <code>ccall</code>). But <code>CONTRO_</code> needs the informations for the current state. This informations were saved by <code>unsafe_rodasSoloutCallback</code> in the <code>RodasInternalCallInfos</code>. <code>eval_sol_fcn</code> needs to get this informations. Here comes <code>create_rodas_eval_sol_fcn_closure</code> into play: this function takes the call informations and generates a <code>eval_sol_fcn</code> with this data.</p><p>Why doesn&#39;t <code>unsafe_rodasSoloutCallback</code> generate a closure (then the current state needs not to be saved in <code>RodasInternalCallInfos</code>)? Because then every call to <code>unsafe_rodasSoloutCallback</code> would have generated a closure function. That&#39;s a lot of overhead: 1 closure function for every solout call. With the strategy above, we have 1 closure function per ODE-solver-call, i.e. 1 closure function per ODE.</p><p>For the typical calling sequence, see <code>RodasInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.create_seulex_eval_sol_fcn_closure" href="#ODEInterface.create_seulex_eval_sol_fcn_closure"><code>ODEInterface.create_seulex_eval_sol_fcn_closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function create_seulex_eval_sol_fcn_closure(cbi::CI, d::FInt, 
         method_contex::Ptr{Cvoid}) where {FInt&lt;:FortranInt, 
                                          CI&lt;:SeulexInternalCallInfos}</code></pre><p>generates a eval<em>sol</em>fcn for seulex.</p><p>Why is a closure needed? We need a function <code>eval_sol_fcn</code> that calls <code>CONTEX_</code> (with <code>ccall</code>). But <code>CONTEX_</code> needs the informations for the current state. This informations were saved by <code>unsafe_seulexSoloutCallback</code> in the <code>SeulexInternalCallInfos</code>. <code>eval_sol_fcn</code> needs to get this informations. Here comes <code>create_seulex_eval_sol_fcn_closure</code> into play: this function takes the call informations and generates a <code>eval_sol_fcn</code> with this data.</p><p>Why doesn&#39;t <code>unsafe_seulexSoloutCallback</code> generate a closure (then the current state needs not to be saved in <code>SeulexInternalCallInfos</code>)? Because then every call to <code>unsafe_seulexSoloutCallback</code> would have generated a closure function. That&#39;s a lot of overhead: 1 closure function for every solout call. With the strategy above, we have 1 closure function per ODE-solver-call, i.e. 1 closure function per ODE.</p><p>For the typical calling sequence, see <code>SeulexInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddeabm" href="#ODEInterface.ddeabm"><code>ODEInterface.ddeabm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function ddeabm(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 &lt;0: error</code></pre><p>main call for using Fortran-ddeabm solver. In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN either              │         ║
║                 │   (a) either for all intermediate steps  │         ║
║                 │       choosen by the solver or           │         ║
║                 │   (b) at the times given in the option   │         ║
║                 │       OPT_OUTPUTATTIMES                  │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   is *not* supported!                    │         ║
║                 │   but see OUTPUTATTIMES for an           │         ║
║                 │   alternative approach                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTATTIMES   │ If OPT_OUTPUTMODE is OUTPUTFCN_WODENSE   │ nothing ║
║                 │ then one can specify with this vector    │         ║
║                 │ the time points where the OPT_OUTPUTFCN  │         ║
║                 │ should be called.                        │         ║
║                 │ All values of OPT_OUTPUTATTIMES *must*   │         ║
║                 │ be sorted (ascending, if T&gt;t0, and       │         ║
║                 │ descending, if T&lt;t0) and they must be    │         ║
║                 │ between t0 and T.                        │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ TSTOP           │ tell the solver, that it is not          │     NaN ║
║                 │ permissable to integrate past the point  │         ║
║                 │ TSTOP. If TSTOP is NaN then the solver   │         ║
║                 │ may integrate past T and interpolate the │         ║
║                 │ result at T. Sometimes there are         │         ║
║                 │ right-hand sides, where this is not      │         ║
║                 │ possible.                                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ (allowed intermediate steps)             │         ║
║                 │ between t0, T and the values given       │         ║
║                 │ in OPT_OUTPUTATTIMES.                    │         ║
║                 │ The value will be rounded up to a        │         ║
║                 │ multiple of 500.                         │         ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddeabm_i32" href="#ODEInterface.ddeabm_i32"><code>ODEInterface.ddeabm_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ddeabm with 32bit integers, see ddeabm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddeabm_impl" href="#ODEInterface.ddeabm_impl"><code>ODEInterface.ddeabm_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function ddeabm_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::DdeabmArguments{FInt}) where FInt&lt;:FortranInt</code></pre><p>implementation of ddeabm-call for FInt.</p><p>This solver has the conecpt of continuation calls (CC), see help for <code>ODEInterface.SLATEC_continuation_call</code>.</p><p>This CC are used in this method to get the solution at user-given t-values (see <code>OPT_OUTPUTATTIMES</code>) in order to support some alternative method for dense output.</p><p>The solver also has an intermediate-output mode. If activated then the numerical integration is stoped at every (solver-chosen) intermediate step and can be continued with a CC.</p><p>Different cases for this method:</p><pre><code class="language-none">╔═══════════════════╤═══════════════════╤════════════════════╤═════════╗
║ OPT_OUTPUTMODE    │ OPT_OUTPUTATTIMES │ intermediate-mode? │  case   ║
╠═══════════════════╪═══════════════════╪════════════════════╪═════════╣
║ OUTPUTFCN_NEVER   │ &lt;ignored&gt;         │ no   INFO(3)=0     │  C1     ║
║ OUTPUTFCN_WODENSE │ nothing or empty  │ yes  INFO(3)=1     │  C2     ║
║ OUTPUTFCN_WODENSE │ given vector      │ no   INFO(3)=0     │  C3     ║
╠═══════════════════╪═══════════════════╧════════════════════╧═════════╣
║ OUTPUTFCN_DENSE   │        N O T    S U P P O R T E D !              ║
╚═══════════════════╧══════════════════════════════════════════════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddeabm_maxnum" href="#ODEInterface.ddeabm_maxnum"><code>ODEInterface.ddeabm_maxnum</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>MAXNUM value in ddeabm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddebdf" href="#ODEInterface.ddebdf"><code>ODEInterface.ddebdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function ddebdf(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 &lt;0: error</code></pre><p>main call for using Fortran-ddebdf solver. In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN either              │         ║
║                 │   (a) either for all intermediate steps  │         ║
║                 │       choosen by the solver or           │         ║
║                 │   (b) at the times given in the option   │         ║
║                 │       OPT_OUTPUTATTIMES                  │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   is *not* supported!                    │         ║
║                 │   but see OUTPUTATTIMES for an           │         ║
║                 │   alternative approach                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTATTIMES   │ If OPT_OUTPUTMODE is OUTPUTFCN_WODENSE   │ nothing ║
║                 │ then one can specify with this vector    │         ║
║                 │ the time points where the OPT_OUTPUTFCN  │         ║
║                 │ should be called.                        │         ║
║                 │ All values of OPT_OUTPUTATTIMES *must*   │         ║
║                 │ be sorted (ascending, if T&gt;t0, and       │         ║
║                 │ descending, if T&lt;t0) and they must be    │         ║
║                 │ between t0 and T.                        │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ TSTOP           │ tell the solver, that it is not          │     NaN ║
║                 │ permissable to integrate past the point  │         ║
║                 │ TSTOP. If TSTOP is NaN then the solver   │         ║
║                 │ may integrate past T and interpolate the │         ║
║                 │ result at T. Sometimes there are         │         ║
║                 │ right-hand sides, where this is not      │         ║
║                 │ possible.                                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ (allowed intermediate steps)             │         ║
║                 │ between t0, T and the values given       │         ║
║                 │ in OPT_OUTPUTATTIMES.                    │         ║
║                 │ The value will be rounded up to a        │         ║
║                 │ multiple of 500.                         │         ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIMATRIX    │ A function providing the Jacobian for    │ nothing ║
║                 │ ∂f/∂x or nothing. For nothing the solver │         ║
║                 │ uses finite differences to calculate the │         ║
║                 │ Jacobian.                                │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,J) -&gt; nothing            │         ║
║                 │ Depending on OPT_JACOBIBANDSTRUCT the    │         ║
║                 │ argument J will then by a full or a      │         ║
║                 │ banded matrix, where the user-given      │         ║
║                 │ function has to fill in the entries.     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIBANDSTRUCT│ A tuple (l,u) describing the banded      │ nothing ║
║                 │ structure of the Jacobian or nothing if  │         ║
║                 │ the Jacobian is full.                    │         ║
║                 │ Even if the option JACOBIMATRIX is empty,│         ║
║                 │ the solver will perform much better if   │         ║
║                 │ the Jacobian matrix is banded and the    │         ║
║                 │ code is told this.                       │         ║
║                 │ see also help of BandedMatrix            │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddebdf_i32" href="#ODEInterface.ddebdf_i32"><code>ODEInterface.ddebdf_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ddebdf with 32bit integers, see ddebdf.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddebdf_impl" href="#ODEInterface.ddebdf_impl"><code>ODEInterface.ddebdf_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function ddebdf_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::DdebdfArguments{FInt}) where FInt&lt;:FortranInt</code></pre><p>implementation of ddebdf-call for FInt.</p><p>This solver has the conecpt of continuation calls (CC), see help for <code>ODEInterface.SLATEC_continuation_call</code>.</p><p>This CC are used in this method to get the solution at user-given t-values (see <code>OPT_OUTPUTATTIMES</code>) in order to support some alternative method for dense output.</p><p>The solver also has an intermediate-output mode. If activated then the numerical integration is stoped at every (solver-chosen) intermediate step and can be continued with a CC.</p><p>Different cases for this method:</p><pre><code class="language-none">╔═══════════════════╤═══════════════════╤════════════════════╤═════════╗
║ OPT_OUTPUTMODE    │ OPT_OUTPUTATTIMES │ intermediate-mode? │  case   ║
╠═══════════════════╪═══════════════════╪════════════════════╪═════════╣
║ OUTPUTFCN_NEVER   │ &lt;ignored&gt;         │ no   INFO(3)=0     │  C1     ║
║ OUTPUTFCN_WODENSE │ nothing or empty  │ yes  INFO(3)=1     │  C2     ║
║ OUTPUTFCN_WODENSE │ given vector      │ no   INFO(3)=0     │  C3     ║
╠═══════════════════╪═══════════════════╧════════════════════╧═════════╣
║ OUTPUTFCN_DENSE   │        N O T    S U P P O R T E D !              ║
╚═══════════════════╧══════════════════════════════════════════════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.ddebdf_maxnum" href="#ODEInterface.ddebdf_maxnum"><code>ODEInterface.ddebdf_maxnum</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>MAXNUM value in ddebdf.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dlSolversInfo" href="#ODEInterface.dlSolversInfo"><code>ODEInterface.dlSolversInfo</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>global Dict saving informations of all loaded solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.doRadauSolverCall" href="#ODEInterface.doRadauSolverCall"><code>ODEInterface.doRadauSolverCall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>calls the radau5 or radau solver after all solver arguments are prepared.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dop853" href="#ODEInterface.dop853"><code>ODEInterface.dop853</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function dop853(rhs, t0::Real, T::Real,
                x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: input is not consistent
 -2: larger OPT_MAXSTEPS is needed
 -3: step size becomes too small
 -4: problem is probably stiff (interrupted)</code></pre><p>main call for using Fortran-dopri5 solver. In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL     &amp;      │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEST           │ stiffness test                           │    1000 ║
║                 │ done after every step number k*OPT_STEST │         ║
║                 │ OPT_STEST &lt; 0 for turning test off       │         ║
║                 │ OPT_STEST ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │ 2.3e-16 ║
║                 │ 1e-35 &lt; OPT_EPS &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RHO             │ safety factor in step size predcition    │     0.9 ║
║                 │ 1e-4  &lt; OPT_RHO &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSMINSEL   &amp;    │ parameters for step size selection       │   0.333 ║
║ SSMAXSEL        │ The new step size is chosen subject to   │     6.0 ║
║                 │ the restriction                          │         ║
║                 │ OPT_SSMINSEL ≤ hnew/hold ≤ OPT_SSMAXSEL  │         ║
║                 │ OPT_SSMINSEL, OPT_SSMAXSEL &gt; 0           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSBETA          │ β for stabilized step size control       │     0.0 ║
║                 │ OPT_SSBETA ≤ 0.2                         │         ║
║                 │ if OPT_SSBETA &lt; 0 then OPT_SSBETA = 0    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size                        │     0.0 ║
║                 │ if OPT_INITIALSS == 0 then a initial     │         ║
║                 │ guess is computed                        │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dop853_i32" href="#ODEInterface.dop853_i32"><code>ODEInterface.dop853_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dop853 with 32bit integers, see dop853</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dop853_impl" href="#ODEInterface.dop853_impl"><code>ODEInterface.dop853_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function dop853_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE,
         args::DopriArguments{FInt}) where {FInt&lt;:FortranInt}</code></pre><p>implementation of dop853 for FInt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dopri5" href="#ODEInterface.dopri5"><code>ODEInterface.dopri5</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function dopri5(rhs, t0::Real, T::Real,
                x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: input is not consistent
 -2: larger OPT_MAXSTEPS is needed
 -3: step size becomes too small
 -4: problem is probably stiff (interrupted)</code></pre><p>main call for using Fortran-dopri5 solver. In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option         │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL     &amp;      │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEST           │ stiffness test                           │    1000 ║
║                 │ done after every step number k*OPT_STEST │         ║
║                 │ OPT_STEST &lt; 0 for turning test off       │         ║
║                 │ OPT_STEST ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │ 2.3e-16 ║
║                 │ 1e-35 &lt; OPT_EPS &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RHO             │ safety factor in step size predcition    │     0.9 ║
║                 │ 1e-4  &lt; OPT_RHO &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSMINSEL   &amp;    │ parameters for step size selection       │     0.2 ║
║ SSMAXSEL        │ The new step size is chosen subject to   │    10.0 ║
║                 │ the restriction                          │         ║
║                 │ OPT_SSMINSEL ≤ hnew/hold ≤ OPT_SSMAXSEL  │         ║
║                 │ OPT_SSMINSEL, OPT_SSMAXSEL &gt; 0           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSBETA          │ β for stabilized step size control       │    0.04 ║
║                 │ OPT_SSBETA ≤ 0.2                         │         ║
║                 │ if OPT_SSBETA &lt; 0 then OPT_SSBETA = 0    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size                        │     0.0 ║
║                 │ if OPT_INITIALSS == 0 then a initial     │         ║
║                 │ guess is computed                        │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dopri5_i32" href="#ODEInterface.dopri5_i32"><code>ODEInterface.dopri5_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dopri5 with 32bit integers, see dopri5</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dopri5_impl" href="#ODEInterface.dopri5_impl"><code>ODEInterface.dopri5_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function dopri5_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::DopriArguments{FInt}) where FInt&lt;:FortranInt</code></pre><p>implementation of dopri5 for FInt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dopri_extract_commonOpt" href="#ODEInterface.dopri_extract_commonOpt"><code>ODEInterface.dopri_extract_commonOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function dopri_extract_commonOpt(
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::DopriArguments{FInt}) where FInt&lt;:FortranInt
       -&gt; (d,nrdense,rhs_mode,output_mode,output_fcn)</code></pre><p>calls solver<em>extract</em>commonOpt and additionally sets args.ITOL, args.IOUT </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.dummy_func" href="#ODEInterface.dummy_func"><code>ODEInterface.dummy_func</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>dummy function returning nothing.</p></div></div></section><pre><code class="language-none">ODEInterface.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.evalSolution" href="#ODEInterface.evalSolution"><code>ODEInterface.evalSolution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function evalSolution(sol::ColnewSolution{FInt},
   t::Real, z::Vector{Float64}) where FInt&lt;:FortranInt</code></pre><p>Evaluates an already obtained solution <code>sol</code> at time <code>t</code>. The values of the solution are saved in <code>z</code> which must be a  vector (of length d).  <code>t</code> must be in the interval [a,b] where the problem was solved.</p></div></div><div><div><pre><code class="language-none"> function evalSolution(sol::ColnewSolution{FInt}, 
   t::Real) where FInt&lt;:FortranInt</code></pre><p>Evaluates an already obtained solution <code>sol</code> at time <code>t</code>. A newly allocated vector with the solution values is retured. <code>t</code> must be in the interval [a,b] where the problem was solved.</p></div></div><div><div><pre><code class="language-none">  function evalSolution(sol::ColnewSolution{FInt}, 
    t::Vector) where FInt&lt;:FortranInt</code></pre><p>Evaluates an already obtained solution <code>sol</code> at time all times in the vector <code>t</code>. A newly allocated matrix of size <code>(length(t), d)</code> with the solution  values is retured. All values of <code>t</code> must be in the interval [a,b] where the problem was solved.</p></div></div><div><div><pre><code class="language-none"> function evalSolution(sol::Bvpm2, x::Real, z::Vector{Float64}, 
   dz::Vector{Float64})</code></pre><p>Evaluates an already obtained solution <code>sol</code> at scalar point <code>x</code>. The values of the solution are saved in <code>z</code> which must be a  vector (of length d). For the vector <code>dz</code> there are two cases: If <code>dz</code> is a empty vector (of length 0) then the derivates of z are not calculated, otherwise <code>dz</code> has to be a vector (of length d) where the derivates are stored.</p></div></div><div><div><pre><code class="language-none"> function evalSolution(sol::Bvpm2, x::Real)  -&gt; z</code></pre><p>Allocates vector <code>z</code> and calls <code>evalSolution(sol, x, z)</code>.</p></div></div><div><div><pre><code class="language-none"> function evalSolution(sol::Bvpm2, x::Vector{Float64}, 
   z::Matrix{Float64}, dz::Matrix{Float64})</code></pre><p>Evaluates an already obtained solution <code>sol</code> at scalar point <code>x</code>. The values of the solution are saved in <code>z</code> which must be a  vector (of length d). For the vector <code>dz</code> there are two cases: If <code>dz</code> is a empty vector (of length 0) then the derivates of z are not calculated, otherwise <code>dz</code> has to be a vector (of length d) where the derivates are stored.</p></div></div><div><div><pre><code class="language-none"> function evalSolution(sol::Bvpm2, x::Vector{Float64}) -&gt; z</code></pre><p>Allocates matrix <code>z</code> and calls <code>evalSolution(sol, x, z)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.eval_sol_fcn_done" href="#ODEInterface.eval_sol_fcn_done"><code>ODEInterface.eval_sol_fcn_done</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>(Dummy-)eval<em>sol</em>function, throwing an error, telling the caller,  that this is the DONE-call of the output function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.eval_sol_fcn_init" href="#ODEInterface.eval_sol_fcn_init"><code>ODEInterface.eval_sol_fcn_init</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>(Dummy-)eval<em>sol</em>function, throwing an error, telling the caller,  that this is the INIT-call of the output function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.eval_sol_fcn_noeval" href="#ODEInterface.eval_sol_fcn_noeval"><code>ODEInterface.eval_sol_fcn_noeval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>(Dummy-)eval<em>sol</em>function, throwing an error, telling the caller,  that no evaluation is possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractCommonRadauOpt" href="#ODEInterface.extractCommonRadauOpt"><code>ODEInterface.extractCommonRadauOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>extracts options specific to radau5 and to radau. Fills in <code>args</code>: <code>IWORK[1,2,4,5,6,7,8]</code>, <code>WORK[1,2,3,5,6]</code>, <code>RPAR</code>, <code>IDID</code>, <code>FCN</code>, <code>SOLOUT</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractJacobiOpt" href="#ODEInterface.extractJacobiOpt"><code>ODEInterface.extractJacobiOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractJacobiOpt(d::FInt,
         M1::FInt,M2::FInt, NM1::FInt,
         args::AbstractArgumentsODESolver{FInt}, 
         opt::AbstractOptionsODE) where FInt&lt;:FortranInt</code></pre><p>extracts jacobi options and fills <code>IJAC</code>, <code>MLJAC</code> and <code>MUJAC</code> in args.</p><p>reads options: <code>OPT_JACOBIMATRIX</code>, <code>OPT_JACOBIBANDSTRUCT</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractLogOptions" href="#ODEInterface.extractLogOptions"><code>ODEInterface.extractLogOptions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractLogOptions(opt::AbstractOptionsODE) -&gt; (lio, lev)</code></pre><p>Extract options for logging.</p><p>throws ArgumentErrorODE if logio is not an IO or if loglevel is not convertable to UInt64.</p><p>reads options: <code>OPT_LOGIO</code>, <code>OPT_LOGLEVEL</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractMassMatrix" href="#ODEInterface.extractMassMatrix"><code>ODEInterface.extractMassMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractMassMatrix(M1::FInt, M2::FInt, 
         NM1::FInt, args::AbstractArgumentsODESolver{FInt},
         opt::AbstractOptionsODE) where FInt&lt;:FortranInt</code></pre><p>extracts mass matrix and fills <code>IMAS</code>, <code>MLMAS</code> und <code>MUMAS</code> in args.</p><p>reads options: <code>OPT_MASSMATRIX</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractOutputFcn" href="#ODEInterface.extractOutputFcn"><code>ODEInterface.extractOutputFcn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractOutputFcn(opt::AbstractOptionsODE) 
        -&gt; (output_mode, output_fcn)</code></pre><p>reads options: <code>OPT_OUTPUTMODE</code>, <code>OPT_OUTPUTFCN</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractRhsTimeDerivOpt" href="#ODEInterface.extractRhsTimeDerivOpt"><code>ODEInterface.extractRhsTimeDerivOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractRhsTimeDerivOpt(
         args::AbstractArgumentsODESolver{FInt}, 
         opt::AbstractOptionsODE) where FInt&lt;:FortranInt</code></pre><p>extracts options for callback function for time-derivatives  of the right-hand-side and fills <code>IDFX</code> in args.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractSlatecJacobiOpt" href="#ODEInterface.extractSlatecJacobiOpt"><code>ODEInterface.extractSlatecJacobiOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractSlatecJacobiOpt(d::FInt,
         opt::AbstractOptionsODE) where FInt&lt;:FortranInt</code></pre><p>extracts jacobi options for some SLATEC solvers, like ddebdf.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractSlatecOutputAtTimes" href="#ODEInterface.extractSlatecOutputAtTimes"><code>ODEInterface.extractSlatecOutputAtTimes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>handles OPT_OUTPUTATTIMES for some SLATEC solvers, like ddeabm, ddebdf.</p><p>returns always an Float64-Vector. Even if nothing was given by the user. If there was a vector given then it is copied and checked for monotonicity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractSpecialStructureOpt" href="#ODEInterface.extractSpecialStructureOpt"><code>ODEInterface.extractSpecialStructureOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractSpecialStructureOpt(
         d::FInt,opt::AbstractOptionsODE) where FInt&lt;:FortranInt</code></pre><p>extracts parameters for special structure (M1, M2).</p><p>reads options: <code>OPT_M1</code>, <code>OPT_M2</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.extractTOLs" href="#ODEInterface.extractTOLs"><code>ODEInterface.extractTOLs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function extractTOLs(d::Integer, opt::AbstractOptionsODE) 
        -&gt; (scalarFlag,rtol,atol)</code></pre><p>extract <code>OPT_RTOL</code> and <code>OPT_ATOL</code> and convert to <code>Vector{Float64}</code>.</p><p>Supports scalar <code>OPT_RTOL</code> and <code>OPT_ATOL</code> and converts them to a <code>Vector{Float64}</code> of length 1.</p><p>reads options: <code>OPT_RTOL</code>, <code>OPT_ATOL</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.full" href="#ODEInterface.full"><code>ODEInterface.full</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>For banded matrices: generate and return full/dense matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.fullToArray" href="#ODEInterface.fullToArray"><code>ODEInterface.fullToArray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert banded matrix <code>bm</code> to full matrix. Save full matrix values in <code>f</code>.</p><p><code>f</code> must have the right size.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.getAllMethodPtrs" href="#ODEInterface.getAllMethodPtrs"><code>ODEInterface.getAllMethodPtrs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>return all method-pointers for a solver.</p><p>tries to return all <code>method_ptr</code>s for all methods of a solver. This method checks if the <code>method_ptr</code>s are existent and different from <code>C_NULL</code>. If not then this method tries to load the  <code>dlname</code> ODE-Solver with the <code>loadODESolvers</code> method and checks again.  If even after this the <code>method_ptr</code>s are not found a exception is thrown.</p><p>see <code>loadODESolvers</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.getMatrixCheckSize" href="#ODEInterface.getMatrixCheckSize"><code>ODEInterface.getMatrixCheckSize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function getMatrixCheckSize(mat,T::DataType,
              m::Integer,n::Integer,docopy=true) -&gt; Matrix{T}</code></pre><p>try to convert to <code>Matrix{T}&#39; and checks the size. if the</code>docopy<code>argument is</code>true<code>then the return value will always be a different object than</code>mat<code>: If</code>convert` didn&#39;t need to create a copy then this is done by this function.</p><p>throws ArgumentErrorODE this is not possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.getOption" href="#ODEInterface.getOption"><code>ODEInterface.getOption</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function getOption(opt::AbstractOptionsODE,name::AbstractString,                       default::Any=nothing)</p><p>get saved value of option with given <code>name</code> or <code>default</code>  if option is unknown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.getSolutionGrid" href="#ODEInterface.getSolutionGrid"><code>ODEInterface.getSolutionGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function getSolutionGrid(sol::ColnewSolution{FInt})
          where FInt&lt;:FortranInt</code></pre><p>returnes a Float64-vector with the (last) grid points used.</p></div></div><div><div><p>same as bvpm2<em>get</em>x.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.getVectorCheckLength" href="#ODEInterface.getVectorCheckLength"><code>ODEInterface.getVectorCheckLength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function getVectorCheckLength(vec,T::DataType,d::Integer,copy=true)
                   -&gt; Vector{T}</code></pre><p>try to convert to <code>Vector{T}</code> and checks given length. If the <code>docopy</code> argument is <code>true</code> then the return value will always be a different object than <code>vec</code>: If <code>convert</code> didn&#39;t need to create a copy then this is done by this function.</p><p>throws ArgumentErrorODE this is not possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.get_proxy_methods" href="#ODEInterface.get_proxy_methods"><code>ODEInterface.get_proxy_methods</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>get all (proxy-)methods for bvpm2 object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.get_view_function" href="#ODEInterface.get_view_function"><code>ODEInterface.get_view_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>returns function view or function sub for generating views to arrays.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.guess_path_of_module" href="#ODEInterface.guess_path_of_module"><code>ODEInterface.guess_path_of_module</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>attemt to get the path of this module.</p><p>Returns path or nothing. May throw exceptions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_bvpm2_compile" href="#ODEInterface.help_bvpm2_compile"><code>ODEInterface.help_bvpm2_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile BVP_M-2</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://cs.stmarys.ca/~muir/BVP_SOLVER_Webpage.shtml</code></pre><p>See <code>help_bvpm3_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile BVP_M-2 with <code>Float64</code> reals (and <code>Int64</code> integers with <code>gfortran</code>):</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o bvp_la-2.o bvp_la-2.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o bvp_m-2.o bvp_m-2.f90
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o bvp_m_proxy.o bvp_m_proxy.f90</code></pre><p>The last file <code>bvp_m_proxy.f90</code> is a Julia/C-Proxy and is part of this <code>ODEInterface</code> package.</p><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o bvp_m_proxy.so 
          bvp_m_proxy.o bvp_m-2.o bvp_la-2.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_bvpm2_license" href="#ODEInterface.help_bvpm2_license"><code>ODEInterface.help_bvpm2_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Licence</strong></p><p>BVP_SOLVER, Release 2, with global error estimation and control options. Copyright (c) 2012, Jason Boisvert, Paul Muir, Ray Spiteri. Jason Boisvert, Ray Spiteri, Department of Computer Science, University of Saskatchewan. Paul Muir, Mathematics and Computing Science, Saint Mary&#39;s University. All rights reserved.</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither Saint Mary&#39;s University nor Southern Methodist University nor        the names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.</p><p>THIS SOFTWARE IS PROVIDED BY Jason Boisvert, Paul Muir, and Ray Spiteri &#39;&#39;AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Paul Muir and Larry Shampine BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p><p>See documentation below for FUNCTION BVP<em>SOLVER for a description of the changes to the argument list for BVP</em>SOLVER. </p><p>Copyright (c) 2006, Paul Muir and Larry Shampine. Paul Muir, Mathematics and Computing Science, Saint Mary&#39;s University. Larry Shampine, Mathematics, Southern Methodist University. All rights reserved.</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither Saint Mary&#39;s University nor Southern Methodist University nor        the names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.</p><p>THIS SOFTWARE IS PROVIDED BY Paul Muir and Larry Shampine &#39;&#39;AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Paul Muir and Larry Shampine BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p><p>L.F. Shampine, P.H. Muir, H. Xu, A user-friendly Fortran BVP solver,  J. Numer. Anal. Indust. Appl. Math., 1, 2006, 201–217.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_bvpm2_proxy" href="#ODEInterface.help_bvpm2_proxy"><code>ODEInterface.help_bvpm2_proxy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Please call this <code>help_bvpm2_proxy</code> function to get an detailed description of the Fortran-Proxy written for BVP_M-2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_bvpsol_compile" href="#ODEInterface.help_bvpsol_compile"><code>ODEInterface.help_bvpsol_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile BVPSOL</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://elib.zib.de/pub/elib/codelib/bvpsol/</code></pre><p>See <code>help_bvpsol_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o bvpsol.o bvpsol.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o linalg_bvpsol.o linalg_bvpsol.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o zibconst.o zibconst.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o ma28_bvpsol.o ma28_bvpsol.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o bvpsol.so 
          bvpsol.o linalg_bvpsol.o zibconst.o ma28_bvpsol.o
 gfortran -shared -fPIC -o bvpsol.dylib
          bvpsol.o linalg_bvpsol.o zibconst.o ma28_bvpsol.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o bvpsol.o bvpsol.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o linalg_bvpsol.o linalg_bvpsol.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o zibconst.o zibconst.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o ma28_bvpsol.o ma28_bvpsol.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o bvpsol.so 
          bvpsol.o linalg_bvpsol.o zibconst.o ma28_bvpsol.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o bvpsol_i32.o bvpsol.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o linalg_bvpsol_i32.o linalg_bvpsol.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o zibonst_i32.o zibconst.f 
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o ma28_bvpsol_i32.o ma28_bvpsol.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o bvpsol_i32.so 
           bvpsol_i32.o linalg_bvpsol_i32.o zibconst_i32.o ma28_bvpsol_i32.o
 gfortran -shared -fPIC -o bvpsol_i32.dylib
           bvpsol_i32.o linalg_bvpsol_i32.o zibconst_i32.o ma28_bvpsol_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o bvpsol_i32.o bvpsol.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o linalg_bvpsol_i32.o linalg_bvpsol.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o zibconst_i32.o zibconst.f 
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o ma28_bvpsol_i32.o ma28_bvpsol.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o bvpsol_i32.dll
           bvpsol_i32.o linalg_bvplsol_i32.o zibconst_i32.o
           ma28_bvpsol_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_bvpsol_license" href="#ODEInterface.help_bvpsol_license"><code>ODEInterface.help_bvpsol_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Licence</strong></p><p>You may use or modify this code for your own non commercial purposes for an unlimited time. This code can be distributed in unmodified form as part of the complete ODEInterface packet. Apart from that, you should not deliver it without a special permission of the Zuse Institute Berlin (ZIB). In case you intend to use the code commercially, we oblige you to sign an according licence agreement with ZIB.</p><p><strong>Warranty</strong></p><p>This code has been tested up to a certain level. Defects and weaknesses, which may be included in the code, do not establish any warranties by ZIB. ZIB does not take over any liabilities which may follow from aquisition or application of this code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_callsolvers" href="#ODEInterface.help_callsolvers"><code>ODEInterface.help_callsolvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Calling the Solvers</strong></p><p>There are two ways of calling the solvers.</p><ol><li>A calling convention close to the original Fortran-call, trying to provide/expose all the features the Fortran-codes have.</li><li>A simplified version, closer to odecalls like in MATLAB.</li></ol><p><strong>The full-featured calling-method</strong></p><p>All ODE-solvers have the same calling convention:</p><pre><code class="language-none">(t,x,retcode,stats) = 
    odesolver(rhs, t0::Real, T::Real,
              x0::Vector, opt::AbstractOptionsODErhs)

function rhs(t::Float64,x::Vector{Float64}) -&gt; Vector{Float64}
    if OPT_RHS_CALLMODE == RHS_CALL_RETURNS_ARRAY

function rhs(t::Float64,x::Vector{Float64},dx::Vector{Float64}) 
    if OPT_RHS_CALLMODE == RHS_CALL_INSITU</code></pre><p>The input arguments are:</p><ol><li>a julia function <code>rhs</code> for evaluating the right-hand side of the ODE, see below. It&#39;s OK to return something, that <code>convert</code> can transform to a <code>Vector{Float64}</code>.</li><li>the initial time <code>t0</code>. <code>(t0,x0)</code> is the initial value of the  initial value problem.</li><li>the final time <code>T</code>.</li><li>the initial state <code>x0</code>. <code>(t0,x0)</code> is the initial value of the  initial value problem.</li><li>further parameters/options in <code>opt</code> for the solver and for the interface.  There is a separate section for the explanation of the options, see help_options.</li></ol><p>The output arguments are:</p><ol><li><code>t</code> the <em>last</em> time for which the solution has been computed  (if the whole computation was successfull, then <code>t==T</code>)</li><li><code>x</code> the numerical solation at time <code>t</code></li><li><code>retcode</code> the return code of the solver (interpretation is solver dependent)</li></ol><p>There are two possible ways to provide the Julia right-hand side:</p><pre><code class="language-none">function rhs(t::Float64,x::Vector{Float64}) -&gt; Vector{Float64}</code></pre><p>This is used, if <code>OPT_RHS_CALLMODE == RHS_CALL_RETURNS_ARRAY</code>. So you can use anonymous functions like <code>(t,x) -&gt; x</code> as right-hand sides. But this form has a price: every time the right-hand side is called, a temporary Array is created (the result). The form</p><pre><code class="language-none">function rhs(t::Float64,x::Vector{Float64},dx::Vector{Float64}) 
             -&gt; nothing</code></pre><p>used if <code>OPT_RHS_CALLMODE == RHS_CALL_INSITU</code> does not have this problem. But the right-hand side must be a function filling in the values of <code>x&#39;</code> in <code>dx</code>.</p><p><strong>The simplified version</strong></p><p>There is a simplified calling convention (using the methods above) to provide a method like odecalls in MATLAB,  see <code>odecall</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_colnew_compile" href="#ODEInterface.help_colnew_compile"><code>ODEInterface.help_colnew_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile COLNEW</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> https://people.sc.fsu.edu/~jburkardt/f77_src/colnew/colnew.html</code></pre><p>See <code>help_colnew_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o colnew.o colnew.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o colnew.so colnew.o
 gfortran -shared -fPIC -o colnew.dylib colnew.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile BVPSOL with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o colnew.o colnew.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o colnew.dll colnew.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_colnew_license" href="#ODEInterface.help_colnew_license"><code>ODEInterface.help_colnew_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Licence</strong></p><p>Colnew is licensed under the GNU LGPL license.</p><p>See <a href="https://people.sc.fsu.edu/~jburkardt/f77_src/colnew/colnew.html">Colnew Hompage</a>.</p><pre><code class="language-none">                 GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, &quot;this License&quot; refers to version 3 of the GNU Lesser
General Public License, and the &quot;GNU GPL&quot; refers to version 3 of the GNU
General Public License.

  &quot;The Library&quot; refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An &quot;Application&quot; is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A &quot;Combined Work&quot; is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the &quot;Linked
Version&quot;.

  The &quot;Minimal Corresponding Source&quot; for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The &quot;Corresponding Application Code&quot; for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user&#39;s computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License &quot;or any later version&quot;
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy&#39;s public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_ddeabm_compile" href="#ODEInterface.help_ddeabm_compile"><code>ODEInterface.help_ddeabm_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile DDEABM</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.netlib.org/slatec/src/</code></pre><p>See <code>help_ddeabm_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux, Mac and Windows)</strong></p><p>Here is an example how to compile DDEABM with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 -o slatec.o slatec.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 -o ddeabm.o ddeabm.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac, 3rd for Window):</p><pre><code class="language-none"> gfortran -shared -fPIC -o ddeabm.so ddeabm.o slatec.o
 gfortran -shared -fPIC -o ddeabm.dylib ddeabm.o slatec.o
 gfortran -shared       -o ddeabm.dll ddeabm.o slatec.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_ddeabm_license" href="#ODEInterface.help_ddeabm_license"><code>ODEInterface.help_ddeabm_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>The solver ddeabm is part of the SLATEC Common Mathematical Library which is in the public domain. More informations can be found at</p><pre><code class="language-none"> http://www.netlib.org/slatec/guide</code></pre></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_ddebdf_compile" href="#ODEInterface.help_ddebdf_compile"><code>ODEInterface.help_ddebdf_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile DDEBDF</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.netlib.org/slatec/src/</code></pre><p>See <code>help_ddebdf_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux, Mac and Windows)</strong></p><p>Here is an example how to compile DDEBDF with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 -o slatec.o slatec.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 -o ddebdf.o ddbdfm.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac, 3rd for Window):</p><pre><code class="language-none"> gfortran -shared -fPIC -o ddebdf.so ddebdf.o slatec.o
 gfortran -shared -fPIC -o ddebdf.dylib ddebdf.o slatec.o
 gfortran -shared       -o ddebdf.dll ddebdf.o slatec.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_ddebdf_license" href="#ODEInterface.help_ddebdf_license"><code>ODEInterface.help_ddebdf_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>The solver ddeabm is part of the SLATEC Common Mathematical Library which is in the public domain. More informations can be found at</p><pre><code class="language-none"> http://www.netlib.org/slatec/guide</code></pre></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_dop853_compile" href="#ODEInterface.help_dop853_compile"><code>ODEInterface.help_dop853_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile DOP853</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_dop853_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile DOP853 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dop853.o dop853.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o dop853.so dop853.o
 gfortran -shared -fPIC -o dop853.dylib dop853.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile DOP853 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dop853.o dop853.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o dop853.dll dop853.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile DOP853 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC  
          -fdefault-real-8 -fdefault-double-8 
          -o dop853_i32.o   dop853.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o dop853_i32.so dop853_i32.o
 gfortran -shared -fPIC -o dop853_i32.dylib dop853_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile DOP853 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c
          -fdefault-real-8 -fdefault-double-8 
          -o dop853_i32.o   dop853.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o dop853_i32.dll dop853_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_dop853_license" href="#ODEInterface.help_dop853_license"><code>ODEInterface.help_dop853_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_dopri5_compile" href="#ODEInterface.help_dopri5_compile"><code>ODEInterface.help_dopri5_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile DOPRI5</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_dopri5_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile DOPRI5 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dopri5.o dopri5.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o dopri5.so dopri5.o
 gfortran -shared -fPIC -o dopri5.dylib dopri5.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile DOPRI5 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dopri5.o dopri5.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o dopri5.dll dopri5.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile DOPRI5 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC  
          -fdefault-real-8 -fdefault-double-8 
          -o dopri5_i32.o   dopri5.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o dopri5_i32.so dopri5_i32.o
 gfortran -shared -fPIC -o dopri5_i32.dylib dopri5_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile DOPRI5 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c
          -fdefault-real-8 -fdefault-double-8 
          -o dopri5_i32.o   dopri5.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o dopri5_i32.dll dopri5_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_dopri5_license" href="#ODEInterface.help_dopri5_license"><code>ODEInterface.help_dopri5_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_install" href="#ODEInterface.help_install"><code>ODEInterface.help_install</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Installation</strong></p><p>Because this module is an <em>interface</em> for C-/Fortran-ODE-solvers, you need to compile/link the solvers before you can use them.</p><p>All solvers are dynamically loaded (at julia runtime), see <code>loadODESolvers</code>. Therefor a shared library is needed for every solver, i.e. you have to compile each solver and create a shared library.</p><p>See <code>help_solversupport</code> for a list with supported solvers and for further informations how to compile/link the solvers.</p><p>This module has its own build script <code>deps/build.jl</code> which tries to compile and link the shared libraries automatically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_internals" href="#ODEInterface.help_internals"><code>ODEInterface.help_internals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Internals</strong></p><ol><li>What is the typical &quot;call stack&quot; for all this callbacks? see documentation of <code>DopriInternalCallInfos</code>,  <code>OdexInternalCallInfos</code> and <code>Radau5InternalCallInfos</code>.</li><li>What closures (and how many) are generated to support the eval<em>sol</em>fcn? see <code>create_radau_eval_sol_fcn_closure</code></li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_loadsolvers" href="#ODEInterface.help_loadsolvers"><code>ODEInterface.help_loadsolvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Loading the solvers</strong></p><p>All ODE solvers are dynamically loaded. See <code>help_install</code> for  informations how to create such shared libraries for the solvers.</p><p>Before using a solver for the 1st time, it has to be loaded by a call of <code>loadODESolvers</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_odex_compile" href="#ODEInterface.help_odex_compile"><code>ODEInterface.help_odex_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile ODEX</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_odex_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile ODEX with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o odex.o odex.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o odex.so odex.o
 gfortran -shared -fPIC -o odex.dylib odex.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile ODEX with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o odex.o odex.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o odex.dll odex.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile ODEX with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC  
          -fdefault-real-8 -fdefault-double-8 
          -o odex_i32.o   odex.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o odex_i32.so odex_i32.o
 gfortran -shared -fPIC -o odex_i32.dylib odex_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile ODEX with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c
          -fdefault-real-8 -fdefault-double-8 
          -o odex_i32.o   odex.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o odex_i32.dll odex_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_odex_license" href="#ODEInterface.help_odex_license"><code>ODEInterface.help_odex_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_options" href="#ODEInterface.help_options"><code>ODEInterface.help_options</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>The <code>opt</code> Argument: the Options</strong></p><p>All options are handled by <code>OptionsODE</code>. See <code>OptionsODE</code> how to query, set and change options.</p><p>There are the following classes of options.</p><ol><li>Options for this ODEInterface (common for all solvers)</li><li>Options for the ODE solvers</li></ol><p><strong>Options of this ODEInterface</strong></p><ul><li><p><code>OPT_RHS_CALLMODE</code>: There are two possible ways to call the Julia right-hand side:  <code>RHS_CALL_RETURNS_ARRAY</code> and <code>RHS_CALL_INSITU</code>, see <code>help_callsolvers</code> for an explanation. difference.</p></li><li><p><code>OPT_LOGIO</code>: This option sets the <code>IO</code> that is used for logging messages</p></li><li><p><code>OPT_LOGLEVEL</code>: This is a bitmask for activating different logging messages.  The following bitmasks are available.</p><pre><code class="language-none">   LOG_NOTHING     log nothing
   LOG_GENERAL     log some general information, 
                   especially the main julia call of the solver
   LOG_RHS         log all calls of the right-hand side
   LOG_SOLVERARGS  log the arguments for the C-/Fortran-calls
                   before and after the call
   LOG_OUTPUTFCN   log calls of the julia output function
   LOG_SOLOUT      log calls of the solution output routine
   LOG_EVALSOL     log calls of the eval_sol_fcn
   LOG_MASS        log call(s) of the mass function
   LOG_JAC         log calls of the jacobian function of RHS
   LOG_BC          log calls of the boundary condition function
   LOG_BVPIVPSOL   log (during boundary value problems) calls to
                   initial value solvers
   LOG_RHSDT       log calls of the right-hand side time-derivative
   LOG_JACBC       log calls of the jacobian of the boundary condition
   LOG_GUESS       log calls to the guess function
   LOG_ALL         all of the above</code></pre></li></ul><p><strong>Options for the solvers</strong></p><p>Different solvers support different options. All the options a solver supports are listed in the help-command of the specific solver, e.g. <code>help_dopri5</code>.</p><p>To get an overview, what options are supported by what solvers, call <code>ODEInterface.help_options()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_outputfcn" href="#ODEInterface.help_outputfcn"><code>ODEInterface.help_outputfcn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong><code>OPT_OUTPUTMODE</code></strong></p><p>This option determines if the <code>OPT_OUTPUTFCN</code> is called, and if dense output (the <code>eval_sol_fcn</code>) is prepared/supported.</p><ul><li><code>OUTPUTFCN_NEVER</code>: don&#39;t call the output function</li><li><code>OUTPUTFCN_WODENSE</code>: call the output function, but <code>eval_sol_fcn</code> is not used</li><li><code>OUTPUTFCN_DENSE</code>: call the output function and prepare <code>eval_sol_fcn</code></li></ul><p><strong><code>OPT_OUTPUTFCN</code></strong></p><pre><code class="language-none"> function outputfcn(reason::OUTPUTFCN_CALL_REASON,
  told::Float64,t::Float64, x::Vector{Float64},eval_sol_fcn::Function,
  extra_data::Dict)  -&gt; OUTPUTFCN_RETURN_VALUE</code></pre><p>A (julia) function that is called </p><ol><li>at beginning of the solution process with <code>reason == OUTPUTFCN_CALL_INIT</code>, <code>told=t0</code>, <code>t</code>=<code>T</code>, <code>x=x0</code>, <code>eval_sol_fcn</code> a dummy function throwing an error if called, <code>extra_data</code> a <code>Dict</code> persistent until the last call of the output  function. The return value is <em>ignored</em>.</li><li>after every successfull integration step with <code>reason == OUTPUTFCN_CALL_STEP</code>, <code>[told,t]</code> the time interval of the last step, <code>x</code> the numerical solution at time <code>t</code>, <code>eval_sol_fcn</code> a function to evaluate the solution in <code>t1 ∊ [told,t]</code>, if requested by <code>OPT_OUTPUTMODE</code>, otherwise a call to this function will result in an error.</li><li>at the end (after the last step) with <code>reason == OUTPUTFCN_CALL_DONE</code>. The return value is <em>ignored</em>.</li></ol><p>With <code>eval_sol_fcn</code></p><pre><code class="language-none">    function eval_sol_fcn(t1::Float64) -&gt; Vector{Float64}</code></pre><p>the numerical solution can be evaluted in the time interval <code>[told,t]</code> (if <code>OPT_OUTPUTMODE == OUTPUTFCN_DENSE</code>).</p><p>If supported by the solver, the numerical solution may be changed in the <code>outputfcn</code> (if <code>reason == OUTPUTFCN_CALL_STEP</code>) and the solver continues the process with the changed solution. The return value <code>OUTPUTFCN_RET_CONTINUE_XCHANGED</code> indicates  this. <code>OUTPUTFCN_RET_CONTINUE</code> tells the solver to continue (without changes in <code>x</code>) and <code>OUTPUTFCN_RET_STOP</code> tells the solver to stop the solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_overview" href="#ODEInterface.help_overview"><code>ODEInterface.help_overview</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Overview</strong></p><p><strong>Importing all help topics</strong></p><p>You can use</p><pre><code class="language-none"> using ODEInterface
 @ODEInterface.import_help</code></pre><p>to have all <code>help_...</code> commands imported; so you can use</p><pre><code class="language-none"> ?help_overview
 help_overview()</code></pre><p><strong>Help topics</strong></p><pre><code class="language-none"> help_install          requirements, installation, compiling the solvers
 help_solversupport    supported ODE solvers
 help_loadsolvers      loading the ODE solvers
 help_callsolvers      how to call the ODE solvers
 help_options          how to use parameters/options for solvers
 help_outputfcn        how to use &quot;output functions&quot;, dense output
 help_specialstructure support for problems with &quot;special structure&quot;
 
 help_internals        some internal/developer information</code></pre><p><strong>Help for each solver</strong></p><p>Each solver has its own help page. Just look at the documentation of <code>dopri5</code>, <code>dop853</code>, <code>odex</code>, <code>radau5</code>, <code>radau</code>, <code>rodas</code>, <code>seulex</code>, <code>bvpsol</code>, <code>ddeabm</code> and <code>Bvpm2</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_radau5_compile" href="#ODEInterface.help_radau5_compile"><code>ODEInterface.help_radau5_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile RADAU5</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_radau5_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RADAU5 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o radau5.o radau5.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o radau5.so 
          radau5.o dc_lapack.o lapack.o lapackc.o
 gfortran -shared -fPIC -o radau5.dylib
          radau5.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile RADAU5 with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o radau5.o radau5.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o radau5.so 
          radau5.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RADAU5 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o radau5_i32.o radau5.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o radau5_i32.so 
           radau5_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o
 gfortran -shared -fPIC -o radau5_i32.dylib
           radau5_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile RADAU5 with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o radau5_i32.o radau5.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o radau5_i32.dll
           radau5_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_radau5_license" href="#ODEInterface.help_radau5_license"><code>ODEInterface.help_radau5_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_radau_compile" href="#ODEInterface.help_radau_compile"><code>ODEInterface.help_radau_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile RADAU</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_radau_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RADAU with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o radau.o radau.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o radau.so 
          radau.o dc_lapack.o lapack.o lapackc.o
 gfortran -shared -fPIC -o radau.dylib
          radau.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile RADAU with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o radau.o radau.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o radau.so 
          radau.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RADAU with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o radau_i32.o radau.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o radau_i32.so 
           radau_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o
 gfortran -shared -fPIC -o radau_i32.dylib
           radau_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile RADAU with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o radau_i32.o radau.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o radau_i32.dll
           radau_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_radau_license" href="#ODEInterface.help_radau_license"><code>ODEInterface.help_radau_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_rodas_compile" href="#ODEInterface.help_rodas_compile"><code>ODEInterface.help_rodas_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile RODAS</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_rodas_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RODAS with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o rodas.o rodas.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o rodas.so 
          rodas.o dc_lapack.o lapack.o
 gfortran -shared -fPIC -o rodas.dylib
          rodas.o dc_lapack.o lapack.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile RODAS with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o rodas.o rodas.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o rodas.so 
          rodas.o dc_lapack.o lapack.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile RODAS with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o rodas_i32.o rodas.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o rodas_i32.so 
           rodas_i32.o dc_lapack_i32.o lapack_i32.o
 gfortran -shared -fPIC -o rodas_i32.dylib
           rodas_i32.o dc_lapack_i32.o lapack_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile RODAS with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o rodas_i32.o rodas.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o rodas_i32.dll
           rodas_i32.o dc_lapack_i32.o lapack_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_rodas_license" href="#ODEInterface.help_rodas_license"><code>ODEInterface.help_rodas_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_seulex_compile" href="#ODEInterface.help_seulex_compile"><code>ODEInterface.help_seulex_compile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Compile SEULEX</strong></p><p>The julia ODEInterface tries to compile and link the solvers automatically at the build-time of this module. The following calls need only be done, if one uses a different compiler and/or if one wants to change/add some compiler options.</p><p>The Fortran source code can be found at:</p><pre><code class="language-none"> http://www.unige.ch/~hairer/software.html</code></pre><p>See <code>help_seulex_license</code> for the licsense information.</p><p><strong>Using <code>gfortran</code> and 64bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile SEULEX with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fPIC -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o seulex.o seulex.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o seulex.so 
          seulex.o dc_lapack.o lapack.o lapackc.o
 gfortran -shared -fPIC -o seulex.dylib
          seulex.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 64bit integers (Windows)</strong></p><p>Here is an example how to compile SEULEX with <code>Float64</code> reals and <code>Int64</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack.o dc_lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapack.o lapack.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o lapackc.o lapackc.f
 gfortran -c -fdefault-integer-8 
          -fdefault-real-8 -fdefault-double-8 
          -o seulex.o seulex.f</code></pre><p>In order to get create a shared library (from the object file above) use</p><pre><code class="language-none"> gfortran -shared -o seulex.so 
          seulex.o dc_lapack.o lapack.o lapackc.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Linux and Mac)</strong></p><p>Here is an example how to compile SEULEX with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fPIC -fdefault-real-8 -fdefault-double-8 
          -o seulex_i32.o seulex.f</code></pre><p>In order to get create a shared library (from the object file above) use one of the forms below (1st for Linux, 2nd for Mac):</p><pre><code class="language-none"> gfortran -shared -fPIC -o seulex_i32.so 
           seulex_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o
 gfortran -shared -fPIC -o seulex_i32.dylib
           seulex_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre><p><strong>Using <code>gfortran</code> and 32bit integers (Windows)</strong></p><p>Here is an example how to compile SEULEX with <code>Float64</code> reals and <code>Int32</code> integers with <code>gfortran</code>:</p><pre><code class="language-none"> gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o dc_lapack_i32.o dc_lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapack_i32.o lapack.f
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o lapackc_i32.o lapackc.f 
 gfortran -c -fdefault-real-8 -fdefault-double-8 
          -o seulex_i32.o seulex.f</code></pre><p>In order to get create a shared library (from the object file above) use:</p><pre><code class="language-none"> gfortran -shared -o seulex_i32.dll
           seulex_i32.o dc_lapack_i32.o lapack_i32.o lapackc_i32.o</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_seulex_license" href="#ODEInterface.help_seulex_license"><code>ODEInterface.help_seulex_license</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_solversupport" href="#ODEInterface.help_solversupport"><code>ODEInterface.help_solversupport</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function help_solversupport()</code></pre><p>This function (when called) produces a (markdown) object with informations about the supported solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.help_specialstructure" href="#ODEInterface.help_specialstructure"><code>ODEInterface.help_specialstructure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Special Structure</strong></p><p>Some solvers (e.g. radau5 and radau) supports ODEs with a &quot;special structure&quot;. In this context an ODE has special structure  if there exists M1&gt;0 and M2&gt;0 and M1 = M⋅M2 for some integer M and</p><pre><code class="language-none">             x&#39;(k) = x(k+M2)   for all k = 1,…,M1            (*)</code></pre><p>There are the options <code>OPT_M1</code> and <code>OPT_M2</code> to tell the solvers, if the ODE has this special structure. In this case only the non-trivial parts of the right-hand side, of the mass matrix and of the Jacobian matrix  had to be supplied.</p><p>If an ODE has the special structure, then the right-hand side  for <code>OPT_RHS_CALLMODE == RHS_CALL_RETURNS_ARRAY</code> has to return a vector of length d-M1 because the right-hand side for the first M1 entries are known from (*). For <code>OPT_RHS_CALLMODE == RHS_CALL_INSITU</code> the right-hand side gets (a reference) to the array of length d, but only the last d-M1 components need to be filled in.</p><p>The mass matrix has the form</p><pre><code class="language-none">     ⎛ 1    │    ⎞ ⎫
     ⎜  ⋱   │    ⎟ ⎪
     ⎜   ⋱  │    ⎟ ⎬ M1
     ⎜    ⋱ │    ⎟ ⎪
M =  ⎜     1│    ⎟ ⎭
     ⎜──────┼────⎟
     ⎜      │    ⎟ ⎫
     ⎜      │ M̃  ⎟ ⎬ d-M1
     ⎝      │    ⎠ ⎭</code></pre><p>Then there has to be only the (d-M1)×(d-M1) matrix M̃ in <code>OPT_MASSMATRIX</code>. Of course, M̃ can be banded. Then <code>OPT_MASSMATRIX</code> is a <code>BandedMatrix</code> with lower bandwidth &lt; d-M1.</p><p>If an ODE has the special structure, then the Jacobian matrix has the form</p><pre><code class="language-none">     ⎛0   1      ⎞ ⎫
     ⎜ ⋱   ⋱     ⎟ ⎪
     ⎜  ⋱   ⋱    ⎟ ⎬ M1
     ⎜   ⋱   ⋱   ⎟ ⎪
J =  ⎜    0   1  ⎟ ⎭
     ⎜───────────⎟
     ⎜           ⎟ ⎫
     ⎜      J̃    ⎟ ⎬ d-M1
     ⎝           ⎠ ⎭</code></pre><p>Then there has to be only the (d-M1)×d matrix J̃ in <code>OPT_JACOBIMATRIX</code>. In this case banded Jacobian matrices are only supported for the case M1 + M2 == d. Then in this case J̃ is divided into d/M2 = 1+(M1/M2) blocks of the size M2×M2. All this blocks can be banded with a (common) lower bandwidth &lt; M2. </p><p>The option <code>OPT_JACOBIBANDSTRUCT</code> is used to describe the banded structure of the Jacobian. It is eigher <code>nothing</code> if the Jacobian is full or a tuple <code>(l,u)</code> with the lower and upper bandwidth.</p><p>The function for providing the Jacobian for ∂f/∂x can have the following forms:</p><pre><code class="language-none"> function (t,x,J)       -&gt; nothing       (A)
 function (t,x,J1,…,JK) -&gt; nothing       (B)</code></pre><p>The following table shows when <code>OPT_JACOBIMATRIX</code> has the form (A)  and when it has the form (B):</p><pre><code class="language-none"> ╔══════╤═════════════════════════════╤════════════════════════════════╗
 ║      │ JACOBIBANDSTRUCT == nothing │ JACOBIBANDSTRUCT == (l,u)      ║
 ╟──────┼─────────────────────────────┼────────────────────────────────╢
 ║ M1==0│ (A), J full, size: d×d      │ (A) J (l,u)-banded, size d×d   ║
 ╟──────┼─────────────────────────────┼────────────────────────────────╢
 ║ M1&gt;0 │ (A), J full, size: (d-M1)×d │ (B) J1,…,JK (l,u)-banded       ║
 ║      │                             │     each with size M2×M2 and   ║
 ║      │                             │     K = 1 + M1/M2              ║
 ║      │                             │     M1 + M2 == d               ║
 ╚══════╧═════════════════════════════╧════════════════════════════════╝</code></pre></div></div></section><pre><code class="language-none">ODEInterface.hw1rhs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.hw_license" href="#ODEInterface.hw_license"><code>ODEInterface.hw_license</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><strong>License</strong></p><p>This is the license text, which can also be found at</p><pre><code class="language-none"> http://www.unige.ch/~hairer/prog/licence.txt</code></pre><p>Copyright (c) 2004, Ernst Hairer</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer.</p><ul><li>Redistributions in binary form must reproduce the above copyright </li></ul><p>notice, this list of conditions and the following disclaimer in the  documentation and/or other materials provided with the distribution.</p><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS  IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></section><pre><code class="language-none">ODEInterface.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.isdiagonalempty" href="#ODEInterface.isdiagonalempty"><code>ODEInterface.isdiagonalempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function isdiagonalempty(A::AbstractArray{T,2},d::Integer)</code></pre><p>method to check if all entries in a diagonal are zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.isinband" href="#ODEInterface.isinband"><code>ODEInterface.isinband</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tests if <code>(i,j)</code> is in the diagonal bands.</p><p>Caution: This methods does <em>not</em> test, if <code>i</code> and <code>j</code> are inside the matrix bounds. Only the diagonal bounds are checked.</p><p>This method should only be used, if the matrix bounds/dimensions have been checked before.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.isscalar" href="#ODEInterface.isscalar"><code>ODEInterface.isscalar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tests if <code>cand</code> is a number.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.isvalidinband" href="#ODEInterface.isvalidinband"><code>ODEInterface.isvalidinband</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>tests if <code>(i,j)</code> is in the matrix and in the diagonal bands.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.loadODESolvers" href="#ODEInterface.loadODESolvers"><code>ODEInterface.loadODESolvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function loadODESolvers(extrapaths::Vector=AbstractString[],
           loadlibnames::Tuple=() )</code></pre><p>tries to (dynamically) load the solvers.</p><p>additional locations/paths to look at can be given as argument.</p><p>If the 1st argument is an empty Vector, then the method tries to find the path of the ODEInterface module and (if successfull) uses this path as <code>extrapaths</code>.</p><p>The 2nd argument is a <code>Tuple</code> with libnames of solvers to load.  If it is an empty tuple, then all known solvers will be tried.</p><p>If an solver is already successfully loaded, then it will <em>not</em> be loaded again.</p><p>returns <code>Dict</code> with informations about the loaded solvers (and errors).</p><p>If a solver cannot be found (or needed methods inside a dynmic library cannot be found) then the errors are not propagated to the caller. The errors and expections are saved in the returned <code>Dict</code>. Why? Using this way, it is possible to see with one call (and try to load all solvers) which solvers are found.</p><p>You can simply <code>dump</code> the values of the output dict to get a human-readable form of the result or call <code>help_solversupport()</code>.</p><pre><code class="language-none"> for k in keys(res); dump(res[k]); end
 ODEInterface.help_solversupport()</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.odecall" href="#ODEInterface.odecall"><code>ODEInterface.odecall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function odecall(solver, rhs, t::Vector, x0::Vector,
                opt::AbstractOptionsODE)
    -&gt; (tVec,xVec,retcode,stats)</code></pre><p>Calls <code>solver</code> with the given right-hand side <code>rhs</code>. There are two cases:</p><ol><li><code>2==length(t)</code></li><li><code>2&lt;length(t)</code></li></ol><p>If <code>2==length(t)</code>, then in the output <code>tVec</code> consists of the time points the (adaptive) solver has automatically chosen. And the <code>xVec</code> has the states at this times. So: <code>tVec</code> is a <code>Vector{Float64}(m)</code> and <code>xVec</code> is a <code>Array{Float64}(m,length(x0))</code>.</p><p>If <code>2&lt;length(t)</code>, then the values in <code>t</code> must be strictly ascending or strictly descending. Then a special output function is used to get the numerical solution at the given <code>t</code>-values. In this case <code>tVec</code> is a <code>Vector{Float64}(length(t))</code> and <code>xVec</code> is a <code>Array{Float64}(length(t),length(x0))</code>.</p><p>If in <code>opt</code> a output function is given, then this output function is also called/used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.odex" href="#ODEInterface.odex"><code>ODEInterface.odex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function odex(rhs, t0::Real, T::Real, 
               x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: error</code></pre><p>main call for using Fortran-odex solver. In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │   10000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │ 2.3e-16 ║
║                 │ 1e-35 &lt; OPT_EPS &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size guess                  │    1e-4 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXEXCOLUMN     │ the maximum number of columns in         │       9 ║
║                 │ the extrapolation table                  │         ║
║                 │ OPT_MAXEXCOLUMN ≥ 3                      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEPSIZESEQUENCE│ switch for the step size sequence        │       4 ║
║                 │ 1: 2, 4,  6,  8, 10, 12, 14, 16, …       │ if      ║
║                 │ 2: 2, 4,  8, 12, 16, 20, 24, 28, …       │ OUTPUT- ║
║                 │ 3: 2, 4,  6,  8, 12, 16, 24, 32, …       │ MODE == ║
║                 │ 4: 2, 6, 10, 14, 18, 22, 26, 30, …       │ DENSE;  ║
║                 │ 5: 4, 8, 12, 16, 20, 24, 28, 32, …       │ other-  ║
║                 │ 1 ≤ OPT_STEPSIZESEQUENCE ≤ 5             │ wise  1 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTABCHECKS   │ how many times is the stability check    │       1 ║
║                 │ activated at most in one line of the     │         ║
║                 │ extrapolation table                      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTABCHECKLINE│ stability check is only activated in     │       1 ║
║                 │ the lines 1 to MAXMAXSTABCHECKLINE of    │         ║
║                 │ the extrapolation table                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ DENSEOUTPUTWOEE │ boolean flag: suppress error estimator   │   false ║
║                 │ in dense output                          │         ║
║                 │ true is only possible, if                │         ║
║                 │      OUTPUTMODE == DENSE                 │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INTERPOLDEGREE  │ determines the degree of interpolation   │       4 ║
║                 │ formula:                                 │         ║
║                 │ μ = 2*κ - INTERPOLDEGREE + 1             │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSREDUCTION     │ step size is reduced by factor if the    │     0.5 ║
║                 │ stability check is negative              │         ║
║                 │ OPT_EPS &lt; OPT_SSREDUCTION &lt; 1            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSSELECTPAR1 &amp;  │ parameters for step size selection       │    0.02 ║
║ SSSELECTPAR2    │ the new step size for the k-th diagonal  │    4.00 ║
║                 │ entry is chosen subject to               │         ║
║                 │ FMIN/SSSELECTPAR2 ≤ hnewₖ/hold ≤ 1/FMIN  │         ║
║                 │ with FMIN = SSSELECTPAR1^(1/(2*k-1))     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECFRAC &amp;  │ parameters for the order selection       │     0.8 ║
║ ORDERINCFRAC    │ decrease order if                        │     0.9 ║
║                 │         W(k-1) ≤   W(k)*ORDERDECFRAC     │         ║
║                 │ increase order if                        │         ║
║                 │         W(k)   ≤ W(k-1)*ORDERINCFRAC     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OPT_RHO      &amp;  │ safety factors for step control algorithm│    0.94 ║
║ OPT_RHO2        │ hnew=h*RHO*(RHO2*TOL/ERR)^(1/(k-1) )     │    0.65 ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.odex_i32" href="#ODEInterface.odex_i32"><code>ODEInterface.odex_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>odex with 32bit integers, see odex.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.odex_impl" href="#ODEInterface.odex_impl"><code>ODEInterface.odex_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function odex_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::OdexArguments{FInt}) where {FInt&lt;:FortranInt}</code></pre><p>implementation of odex for FInt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.output_fcn_donothing" href="#ODEInterface.output_fcn_donothing"><code>ODEInterface.output_fcn_donothing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Output function that does nothing and returns <code>OUTPUTFCN_RET_CONTINUE</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau" href="#ODEInterface.radau"><code>ODEInterface.radau</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function radau(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)
 
 function radau5(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: input is not consistent
 -2: larger OPT_MAXSTEPS is needed
 -3: step size becomes too small
 -4: matrix is repeatedly singular</code></pre><p>main call for using Fortran radau or radau5 solver.</p><p>This solver support problems with special structure, see <code>help_specialstructure</code>.</p><p>Remark: Because radau and radau5 are collocation methods, there is no difference  in the computational costs for OUTPUTFCN<em>WODENSE and OUTPUTFCN</em>DENSE.</p><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ M1 &amp; M2         │ parameter for special structure, see     │       0 ║
║                 │ above                                    │      M1 ║
║                 │ M1, M2 ≥ 0                               │         ║
║                 │ M1 +M2 ≤ length(x0)                      │         ║
║                 │ (M1==M2==0) || (M1≠0≠M2)                 │         ║
║                 │ M1 % M2 == 0 or M1==0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │   1e-16 ║
║                 │ 1e-19 &lt; OPT_EPS &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ TRANSJTOH       │ The solver transforms the jacobian       │   false ║
║                 │ matrix to Hessenberg form.               │         ║
║                 │ This option is not supported if the      │         ║
║                 │ system is &quot;implicit&quot; (i.e. a mass matrix │         ║
║                 │ is given) or if jacobian is banded.      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXNEWTONITER   │ maximum number of Newton iterations for  │       7 ║
║                 │ the solution of the implicit system in   │         ║
║                 │ each step.                               │         ║
║                 │ for radau: MAXNEWTONITER + (NS-3)*2.5    │         ║
║                 │   where NS is number of current stages   │         ║
║                 │ for radau5:     OPT_MAXNEWTONITER &gt; 0    │         ║
║                 │ for radau: 50 &gt; OPT_MAXNEWTONITER &gt; 0    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ NEWTONSTARTZERO │ if `false`, the extrapolated collocation │   false ║
║                 │ solution is taken as starting vector for │         ║
║                 │ Newton&#39;s method. If `true` zero starting │         ║
║                 │ values are used. The latter is           │         ║
║                 │ recommended if Newton&#39;s method has       │         ║
║                 │ difficulties with convergence.           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ NEWTONSTOPCRIT  │ only for radau5:                         │ see     ║
║                 │ Stopping criterion for Newton&#39;s method.  │   left  ║
║                 │ Smaller values make the code slower, but │         ║
║                 │ safer.                                   │         ║
║                 │ Default:                                 │         ║
║                 │  max(10*OPT_EPS/OPT_RTOL[1],             │         ║
║                 │       min(0.03,sqrt(OPT_RTOL[1])))       │         ║
║                 │ OPT_NEWTONSTOPCRIT &gt; OPT_EPS/OPT_RTOL[1] │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ DIMOFIND1VAR  &amp; │ For differential-algebraic systems of    │ len(x0) ║
║ DIMOFIND2VAR  &amp; │ index &gt; 1. The right-hand side should be │       0 ║
║ DIMOFIND3VAR    │ written such that the index 1,2,3        │       0 ║
║                 │ variables appear in this order.          │         ║
║                 │ DIMOFINDzVAR: number of index z vars.    │         ║
║                 │ ∑ DIMOFINDzVAR == length(x0)             │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size guess                  │    1e-6 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MINSTAGES     &amp; │ only for radau:                          │       3 ║
║ MAXSTAGES       │ minimal and maximal number of stages.    │       7 ║
║                 │ The order is given by: 2⋅stages-1        │         ║
║                 │ MINSTAGES,MAXSTAGES ∈ (1,3,5,7)          │         ║
║                 │ MINSTAGES ≤ MAXSTAGES                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITSTAGES      │ only for radau:                          │MINSTAGES║
║                 │ number of stages to start with.          │         ║
║                 │ MINSTAGES ≤ INITSTAGES ≤ MAXSTAGES       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEPSIZESTRATEGY│ Switch for step size strategy            │       1 ║
║                 │   1: mod. predictive controller          │         ║
║                 │      (Gustafsson)                        │         ║
║                 │   2: classical step size control         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OPT_RHO         │ safety factor for step control algorithm │     0.9 ║
║                 │ 0.001 &lt; OPT_RHO &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACRECOMPFACTOR │ decides whether the jacobian should be   │   0.001 ║
║                 │ recomputed.                              │         ║
║                 │ &lt;0: recompute after every accepted step  │         ║
║                 │ small (≈ 0.001): recompute often         │         ║
║                 │ large (≈ 0.1): recompute rarely          │         ║
║                 │ i.e. this number represents how costly   │         ║
║                 │ Jacobia evaluations are.                 │         ║
║                 │ OPT_JACRECOMPFACTOR ≠ 0                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ FREEZESSLEFT  &amp; │ Step size freezing: If                   │     1.0 ║
║ FREEZESSRIGHT   │ FREEZESSLEFT &lt; hnew/hold &lt; FREEZESSRIGHT │     1.2 ║
║                 │ then the step size is not changed. This  │         ║
║                 │ saves, together with a large             │         ║
║                 │ JACRECOMPFACTOR, LU-decompositions and   │         ║
║                 │ computing time for large systems.        │         ║
║                 │ small systems:                           │         ║
║                 │    FREEZESSLEFT  ≈ 1.0                   │         ║
║                 │    FREEZESSRIGHT ≈ 1.2                   │         ║
║                 │ large full systems:                      │         ║
║                 │    FREEZESSLEFT  ≈ 0.99                  │         ║
║                 │    FREEZESSRIGHT ≈ 2.0                   │         ║
║                 │                                          │         ║
║                 │ OPT_FREEZESSLEFT  ≤ 1.0                  │         ║
║                 │ OPT_FREEZESSRIGHT ≥ 1.0                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSMINSEL   &amp;    │ parameters for step size selection       │     0.2 ║
║ SSMAXSEL        │ The new step size is chosen subject to   │     8.0 ║
║                 │ the restriction                          │         ║
║                 │ OPT_SSMINSEL ≤ hnew/hold ≤ OPT_SSMAXSEL  │         ║
║                 │ OPT_SSMINSEL ≤ 1, OPT_SSMAXSEL ≥ 1       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MASSMATRIX      │ the mass matrix of the problem. If not   │ nothing ║
║                 │ given (nothing) then the identiy matrix  │         ║
║                 │ is used.                                 │         ║
║                 │ The size has to be (d-M1)×(d-M1).        │         ║
║                 │ It can be an full matrix or a banded     │         ║
║                 │ matrix (BandedMatrix).                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIMATRIX    │ A function providing the Jacobian for    │ nothing ║
║                 │ ∂f/∂x or nothing. For nothing the solver │         ║
║                 │ uses finite differences to calculate the │         ║
║                 │ Jacobian.                                │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,J) -&gt; nothing       (A)  │         ║
║                 │ or for M1&gt;0 &amp; JACOBIBANDSTRUCT ≠ nothing │         ║
║                 │   function (t,x,J1,…,JK) -&gt; nothing (B)  │         ║
║                 │ with K = 1+M1/M2 and (M1+M2==d)          │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIBANDSTRUCT│ A tuple (l,u) describing the banded      │ nothing ║
║                 │ structure of the Jacobian or nothing if  │         ║
║                 │ the Jacobian is full.                    │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECFACTOR &amp;│ only for radau:                          │     0.8 ║
║ ORDERINCFACTOR  │ Order is decreased, if the contractivity │   0.002 ║
║                 │ factor is smaller than ORDERDECFACTOR.   │         ║
║                 │ Order is increased, if the contractivity │         ║
║                 │ factor is larger than ORDERINCFACTOR.    │         ║
║                 │ ORDERDECFACTOR &gt; ORDERINCFACTOR &gt; 0      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECSTEPFAC1│ only for radau:                          │     1.2 ║
║ ORDERDECSTEPFAC2│ the order is only decreased if the       │     0.8 ║
║                 │ stepsize ratio satisfies                 │         ║
║                 │  ORDERDECSTEPFAC2 ≤ hnew/hold ≤          │         ║
║                 │               ORDERDECSTEPFAC1           │         ║
║                 │ 0 &lt; ORDERDECSTEPFAC2 &lt; ORDERDECSTEPFAC1  │         ║
║                 │                                          │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau5" href="#ODEInterface.radau5"><code>ODEInterface.radau5</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-none"> function radau(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)
 
 function radau5(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: input is not consistent
 -2: larger OPT_MAXSTEPS is needed
 -3: step size becomes too small
 -4: matrix is repeatedly singular</code></pre><p>main call for using Fortran radau or radau5 solver.</p><p>This solver support problems with special structure, see <code>help_specialstructure</code>.</p><p>Remark: Because radau and radau5 are collocation methods, there is no difference  in the computational costs for OUTPUTFCN<em>WODENSE and OUTPUTFCN</em>DENSE.</p><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ M1 &amp; M2         │ parameter for special structure, see     │       0 ║
║                 │ above                                    │      M1 ║
║                 │ M1, M2 ≥ 0                               │         ║
║                 │ M1 +M2 ≤ length(x0)                      │         ║
║                 │ (M1==M2==0) || (M1≠0≠M2)                 │         ║
║                 │ M1 % M2 == 0 or M1==0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │   1e-16 ║
║                 │ 1e-19 &lt; OPT_EPS &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ TRANSJTOH       │ The solver transforms the jacobian       │   false ║
║                 │ matrix to Hessenberg form.               │         ║
║                 │ This option is not supported if the      │         ║
║                 │ system is &quot;implicit&quot; (i.e. a mass matrix │         ║
║                 │ is given) or if jacobian is banded.      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXNEWTONITER   │ maximum number of Newton iterations for  │       7 ║
║                 │ the solution of the implicit system in   │         ║
║                 │ each step.                               │         ║
║                 │ for radau: MAXNEWTONITER + (NS-3)*2.5    │         ║
║                 │   where NS is number of current stages   │         ║
║                 │ for radau5:     OPT_MAXNEWTONITER &gt; 0    │         ║
║                 │ for radau: 50 &gt; OPT_MAXNEWTONITER &gt; 0    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ NEWTONSTARTZERO │ if `false`, the extrapolated collocation │   false ║
║                 │ solution is taken as starting vector for │         ║
║                 │ Newton&#39;s method. If `true` zero starting │         ║
║                 │ values are used. The latter is           │         ║
║                 │ recommended if Newton&#39;s method has       │         ║
║                 │ difficulties with convergence.           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ NEWTONSTOPCRIT  │ only for radau5:                         │ see     ║
║                 │ Stopping criterion for Newton&#39;s method.  │   left  ║
║                 │ Smaller values make the code slower, but │         ║
║                 │ safer.                                   │         ║
║                 │ Default:                                 │         ║
║                 │  max(10*OPT_EPS/OPT_RTOL[1],             │         ║
║                 │       min(0.03,sqrt(OPT_RTOL[1])))       │         ║
║                 │ OPT_NEWTONSTOPCRIT &gt; OPT_EPS/OPT_RTOL[1] │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ DIMOFIND1VAR  &amp; │ For differential-algebraic systems of    │ len(x0) ║
║ DIMOFIND2VAR  &amp; │ index &gt; 1. The right-hand side should be │       0 ║
║ DIMOFIND3VAR    │ written such that the index 1,2,3        │       0 ║
║                 │ variables appear in this order.          │         ║
║                 │ DIMOFINDzVAR: number of index z vars.    │         ║
║                 │ ∑ DIMOFINDzVAR == length(x0)             │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size guess                  │    1e-6 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MINSTAGES     &amp; │ only for radau:                          │       3 ║
║ MAXSTAGES       │ minimal and maximal number of stages.    │       7 ║
║                 │ The order is given by: 2⋅stages-1        │         ║
║                 │ MINSTAGES,MAXSTAGES ∈ (1,3,5,7)          │         ║
║                 │ MINSTAGES ≤ MAXSTAGES                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITSTAGES      │ only for radau:                          │MINSTAGES║
║                 │ number of stages to start with.          │         ║
║                 │ MINSTAGES ≤ INITSTAGES ≤ MAXSTAGES       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEPSIZESTRATEGY│ Switch for step size strategy            │       1 ║
║                 │   1: mod. predictive controller          │         ║
║                 │      (Gustafsson)                        │         ║
║                 │   2: classical step size control         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OPT_RHO         │ safety factor for step control algorithm │     0.9 ║
║                 │ 0.001 &lt; OPT_RHO &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACRECOMPFACTOR │ decides whether the jacobian should be   │   0.001 ║
║                 │ recomputed.                              │         ║
║                 │ &lt;0: recompute after every accepted step  │         ║
║                 │ small (≈ 0.001): recompute often         │         ║
║                 │ large (≈ 0.1): recompute rarely          │         ║
║                 │ i.e. this number represents how costly   │         ║
║                 │ Jacobia evaluations are.                 │         ║
║                 │ OPT_JACRECOMPFACTOR ≠ 0                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ FREEZESSLEFT  &amp; │ Step size freezing: If                   │     1.0 ║
║ FREEZESSRIGHT   │ FREEZESSLEFT &lt; hnew/hold &lt; FREEZESSRIGHT │     1.2 ║
║                 │ then the step size is not changed. This  │         ║
║                 │ saves, together with a large             │         ║
║                 │ JACRECOMPFACTOR, LU-decompositions and   │         ║
║                 │ computing time for large systems.        │         ║
║                 │ small systems:                           │         ║
║                 │    FREEZESSLEFT  ≈ 1.0                   │         ║
║                 │    FREEZESSRIGHT ≈ 1.2                   │         ║
║                 │ large full systems:                      │         ║
║                 │    FREEZESSLEFT  ≈ 0.99                  │         ║
║                 │    FREEZESSRIGHT ≈ 2.0                   │         ║
║                 │                                          │         ║
║                 │ OPT_FREEZESSLEFT  ≤ 1.0                  │         ║
║                 │ OPT_FREEZESSRIGHT ≥ 1.0                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSMINSEL   &amp;    │ parameters for step size selection       │     0.2 ║
║ SSMAXSEL        │ The new step size is chosen subject to   │     8.0 ║
║                 │ the restriction                          │         ║
║                 │ OPT_SSMINSEL ≤ hnew/hold ≤ OPT_SSMAXSEL  │         ║
║                 │ OPT_SSMINSEL ≤ 1, OPT_SSMAXSEL ≥ 1       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MASSMATRIX      │ the mass matrix of the problem. If not   │ nothing ║
║                 │ given (nothing) then the identiy matrix  │         ║
║                 │ is used.                                 │         ║
║                 │ The size has to be (d-M1)×(d-M1).        │         ║
║                 │ It can be an full matrix or a banded     │         ║
║                 │ matrix (BandedMatrix).                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIMATRIX    │ A function providing the Jacobian for    │ nothing ║
║                 │ ∂f/∂x or nothing. For nothing the solver │         ║
║                 │ uses finite differences to calculate the │         ║
║                 │ Jacobian.                                │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,J) -&gt; nothing       (A)  │         ║
║                 │ or for M1&gt;0 &amp; JACOBIBANDSTRUCT ≠ nothing │         ║
║                 │   function (t,x,J1,…,JK) -&gt; nothing (B)  │         ║
║                 │ with K = 1+M1/M2 and (M1+M2==d)          │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIBANDSTRUCT│ A tuple (l,u) describing the banded      │ nothing ║
║                 │ structure of the Jacobian or nothing if  │         ║
║                 │ the Jacobian is full.                    │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECFACTOR &amp;│ only for radau:                          │     0.8 ║
║ ORDERINCFACTOR  │ Order is decreased, if the contractivity │   0.002 ║
║                 │ factor is smaller than ORDERDECFACTOR.   │         ║
║                 │ Order is increased, if the contractivity │         ║
║                 │ factor is larger than ORDERINCFACTOR.    │         ║
║                 │ ORDERDECFACTOR &gt; ORDERINCFACTOR &gt; 0      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECSTEPFAC1│ only for radau:                          │     1.2 ║
║ ORDERDECSTEPFAC2│ the order is only decreased if the       │     0.8 ║
║                 │ stepsize ratio satisfies                 │         ║
║                 │  ORDERDECSTEPFAC2 ≤ hnew/hold ≤          │         ║
║                 │               ORDERDECSTEPFAC1           │         ║
║                 │ 0 &lt; ORDERDECSTEPFAC2 &lt; ORDERDECSTEPFAC1  │         ║
║                 │                                          │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau5_i32" href="#ODEInterface.radau5_i32"><code>ODEInterface.radau5_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>radau5 with 32bit integers, see radau5.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau5_impl" href="#ODEInterface.radau5_impl"><code>ODEInterface.radau5_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function radau5_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::RadauArguments{FInt}) where FInt&lt;:FortranInt</code></pre><p>implementation of radau5 for FInt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau_i32" href="#ODEInterface.radau_i32"><code>ODEInterface.radau_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>radau with 32bit integers, see radau.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.radau_impl" href="#ODEInterface.radau_impl"><code>ODEInterface.radau_impl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function radau_impl(rhs, 
         t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE, 
         args::RadauArguments{FInt}) where FInt&lt;:FortranInt</code></pre><p>implementation of radau for FInt.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.rangeofdiag" href="#ODEInterface.rangeofdiag"><code>ODEInterface.rangeofdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The columns in <code>bm.entries</code> for diagonal 1 ≤ d ≤ 1+l+u.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.rodas" href="#ODEInterface.rodas"><code>ODEInterface.rodas</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function rodas(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: computation unsuccessful</code></pre><p>main call for using Fortran rodas solver.</p><p>This solver support problems with special structure, see <code>help_specialstructure</code>.</p><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RHSAUTONOMOUS   │ Flag, if right-hand side is autonomous.  │   false ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ M1 &amp; M2         │ parameter for special structure, see     │       0 ║
║                 │ above                                    │      M1 ║
║                 │ M1, M2 ≥ 0                               │         ║
║                 │ M1 +M2 ≤ length(x0)                      │         ║
║                 │ (M1==M2==0) || (M1≠0≠M2)                 │         ║
║                 │ M1 % M2 == 0 or M1==0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │   1e-16 ║
║                 │ 0 &lt; OPT_EPS &lt; 1.0                        │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ METHODCHOICE    │ Choice of coefficients:                  │       1 ║
║                 │ 1: Hairer, Wanner: Solving ODE II,       │         ║
║                 │    page 452                              │         ║
║                 │ 2: same as 1, with different params      │         ║
║                 │ 3: G. Steinbach (1993)                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size guess                  │    1e-6 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEPSIZESTRATEGY│ Switch for step size strategy            │       1 ║
║                 │   1: mod. predictive controller          │         ║
║                 │      (Gustafsson)                        │         ║
║                 │   2: classical step size control         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OPT_RHO         │ safety factor for step control algorithm │     0.9 ║
║                 │ 0.001 &lt; OPT_RHO &lt; 1.0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSMINSEL   &amp;    │ parameters for step size selection       │     0.2 ║
║ SSMAXSEL        │ The new step size is chosen subject to   │     6.0 ║
║                 │ the restriction                          │         ║
║                 │ OPT_SSMINSEL ≤ hnew/hold ≤ OPT_SSMAXSEL  │         ║
║                 │ OPT_SSMINSEL ≤ 1, OPT_SSMAXSEL ≥ 1       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RHSTIMEDERIV    │ A function providing the time derivative │ nothing ║
║                 │ ∂f/∂t of the right-hand side or nothing. │         ║
║                 │ If the value given is nothing the solver │         ║
║                 │ uses finite differences to approximate   │         ║
║                 │ ∂f/∂t.                                   │         ║
║                 │ Obviously this options is only relevant  │         ║
║                 │ for non-autonomous problems.             │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,dfdt) -&gt; nothing         │         ║
║                 │ Even if the problem has special structure│         ║
║                 │ (M1&gt;0, see help_specialstructure) x and  │         ║
║                 │ dfdt are always vectors with full length,│         ║
║                 │ i.e. length(x)==length(dfdt)==length(x0).│         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIMATRIX    │ A function providing the Jacobian for    │ nothing ║
║                 │ ∂f/∂x or nothing. For nothing the solver │         ║
║                 │ uses finite differences to calculate the │         ║
║                 │ Jacobian.                                │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,J) -&gt; nothing       (A)  │         ║
║                 │ or for M1&gt;0 &amp; JACOBIBANDSTRUCT ≠ nothing │         ║
║                 │   function (t,x,J1,…,JK) -&gt; nothing (B)  │         ║
║                 │ with K = 1+M1/M2 and (M1+M2==d)          │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIBANDSTRUCT│ A tuple (l,u) describing the banded      │ nothing ║
║                 │ structure of the Jacobian or nothing if  │         ║
║                 │ the Jacobian is full.                    │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MASSMATRIX      │ the mass matrix of the problem. If not   │ nothing ║
║                 │ given (nothing) then the identiy matrix  │         ║
║                 │ is used.                                 │         ║
║                 │ The size has to be (d-M1)×(d-M1).        │         ║
║                 │ It can be an full matrix or a banded     │         ║
║                 │ matrix (BandedMatrix).                   │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.rodas_i32" href="#ODEInterface.rodas_i32"><code>ODEInterface.rodas_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rodas with 32bit integers, see rodas.</p></div></div></section><pre><code class="language-none">ODEInterface.rodas_impl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.setOption!" href="#ODEInterface.setOption!"><code>ODEInterface.setOption!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function setOption!(opt::AbstractOptionsODE,name::AbstractString,value::Any)</p><p>set ODE-Option with given <code>name</code> and return old value  (or <code>nothing</code> if there was no old value).</p></div></div><div><div><p>function setOption!(opt::AbstractOptionsODE,pair::Pair)</p><p>set ODE-Option with given (<code>name</code>,<code>value</code>) pair and return old value  (or <code>nothing</code> if there was no old value).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.setOptions!" href="#ODEInterface.setOptions!"><code>ODEInterface.setOptions!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function setOptions!(opt::AbstractOptionsODE,pairs::Pair...)</p><p>set many ODE-Options and return an array with the old option values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.setdiagonal!" href="#ODEInterface.setdiagonal!"><code>ODEInterface.setdiagonal!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>sets the diagonal with number <code>d</code> (0 is the main diagonal,see  <code>BandedMatrix</code>) to the given values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.setdiagonals!" href="#ODEInterface.setdiagonals!"><code>ODEInterface.setdiagonals!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>sets all diagonals at once. <code>values</code> must be a 1+u+l cell-array with the diagonals starting with the upper right one.</p></div></div><div><div><p>sets all diagonals at once copy the diagonals from an other BandedMatrix. The other Bandedmatrix must have the same size and same upper and  lower bandwidth.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.seulex" href="#ODEInterface.seulex"><code>ODEInterface.seulex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function seulex(rhs, t0::Real, T::Real,
                 x0::Vector, opt::AbstractOptionsODE)
     -&gt; (t,x,retcode,stats)</code></pre><p><code>retcode</code> can have the following values:</p><pre><code class="language-none">  1: computation successful
  2: computation. successful, but interrupted by output function
 -1: computation unsuccessful</code></pre><p>main call for using Fortran seulex solver.</p><p>This solver support problems with special structure, see <code>help_specialstructure</code>.</p><p>In <code>opt</code> the following options are used:</p><pre><code class="language-none">╔═════════════════╤══════════════════════════════════════════╤═════════╗
║  Option OPT_…   │ Description                              │ Default ║
╠═════════════════╪══════════════════════════════════════════╪═════════╣
║ RHSAUTONOMOUS   │ Flag, if right-hand side is autonomous.  │   false ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ M1 &amp; M2         │ parameter for special structure, see     │       0 ║
║                 │ above                                    │      M1 ║
║                 │ M1, M2 ≥ 0                               │         ║
║                 │ M1 +M2 ≤ length(x0)                      │         ║
║                 │ (M1==M2==0) || (M1≠0≠M2)                 │         ║
║                 │ M1 % M2 == 0 or M1==0                    │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ RTOL         &amp;  │ relative and absolute error tolerances   │    1e-3 ║
║ ATOL            │ both scalars or both vectors with the    │    1e-6 ║
║                 │ length of length(x0)                     │         ║
║                 │ error(xₖ) ≤ OPT_RTOLₖ⋅|xₖ|+OPT_ATOLₖ     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTFCN       │ output function                          │ nothing ║
║                 │ see help_outputfcn                       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OUTPUTMODE      │ OUTPUTFCN_NEVER:                         │   NEVER ║
║                 │   dont&#39;t call OPT_OUTPUTFCN              │         ║
║                 │ OUTPUTFCN_WODENSE                        │         ║
║                 │   call OPT_OUTPUTFCN, but without        │         ║
║                 │   possibility for dense output           │         ║
║                 │ OUTPUTFCN_DENSE                          │         ║
║                 │   call OPT_OUTPUTFCN with support for    │         ║
║                 │   dense output                           │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ LAMBDADENSE     │ parameter λ of dense output              │       0 ║
║                 │ OPT_LAMBDADENSE ∈ {0,1}                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ EPS             │ the rounding unit                        │   1e-16 ║
║                 │ 0 &lt; OPT_EPS &lt; 1.0                        │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ TRANSJTOH       │ The solver transforms the jacobian       │   false ║
║                 │ matrix to Hessenberg form.               │         ║
║                 │ This option is not supported if the      │         ║
║                 │ system is &quot;implicit&quot; (i.e. a mass matrix │         ║
║                 │ is given) or if jacobian is banded.      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSTEPS        │ maximal number of allowed steps          │  100000 ║
║                 │ OPT_MAXSTEPS &gt; 0                         │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXSS           │ maximal step size                        │  T - t0 ║
║                 │ OPT_MAXSS ≠ 0                            │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ INITIALSS       │ initial step size guess                  │    1e-6 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MAXEXCOLUMN     │ the maximum number of columns in         │      12 ║
║                 │ the extrapolation table                  │         ║
║                 │ OPT_MAXEXCOLUMN ≥ 3                      │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ STEPSIZESEQUENCE│ switch for the step size sequence        │       2 ║
║                 │ 1: 1, 2, 3, 6, 8, 12, 16, 24, 32, 48, …  │         ║
║                 │ 2: 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, …  │         ║
║                 │ 3: 1, 2, 3, 4, 5,  6,  7,  8,  9, 10, …  │         ║
║                 │ 4: 2, 3, 4, 5, 6,  7,  8,  9, 10, 11, …  │         ║
║                 │ 1 ≤ OPT_STEPSIZESEQUENCE ≤ 4             │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ SSSELECTPAR1 &amp;  │ parameters for step size selection       │     0.1 ║
║ SSSELECTPAR2    │ the new step size for the k-th diagonal  │     4.0 ║
║                 │ entry is chosen subject to               │         ║
║                 │ FMIN/SSSELECTPAR2 ≤ hnewₖ/hold ≤ 1/FMIN  │         ║
║                 │ with FMIN = SSSELECTPAR1^(1/(k-1))       │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ ORDERDECFRAC &amp;  │ parameters for the order selection       │     0.7 ║
║ ORDERINCFRAC    │ decrease order if                        │     0.9 ║
║                 │         W(k-1) ≤   W(k)*ORDERDECFRAC     │         ║
║                 │ increase order if                        │         ║
║                 │         W(k)   ≤ W(k-1)*ORDERINCFRAC     │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACRECOMPFACTOR │ decides whether the jacobian should be   │ min(    ║
║                 │ recomputed.                              │   1e-4, ║
║                 │ small (≈ 0.001): recompute often         │ RTOL[1])║
║                 │ large (≈ 0.1): recompute rarely          │         ║
║                 │ i.e. this number represents how costly   │         ║
║                 │ Jacobia evaluations are.                 │         ║
║                 │ OPT_JACRECOMPFACTOR ≠ 0                  │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ OPT_RHO      &amp;  │ safety factors for step control algorithm│    0.93 ║
║ OPT_RHO2        │ hnew=h*RHO*(RHO2*TOL/ERR)^(1/(k-1) )     │    0.80 ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ MASSMATRIX      │ the mass matrix of the problem. If not   │ nothing ║
║                 │ given (nothing) then the identiy matrix  │         ║
║                 │ is used.                                 │         ║
║                 │ The size has to be (d-M1)×(d-M1).        │         ║
║                 │ It can be an full matrix or a banded     │         ║
║                 │ matrix (BandedMatrix).                   │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIMATRIX    │ A function providing the Jacobian for    │ nothing ║
║                 │ ∂f/∂x or nothing. For nothing the solver │         ║
║                 │ uses finite differences to calculate the │         ║
║                 │ Jacobian.                                │         ║
║                 │ The function has to be of the form:      │         ║
║                 │   function (t,x,J) -&gt; nothing       (A)  │         ║
║                 │ or for M1&gt;0 &amp; JACOBIBANDSTRUCT ≠ nothing │         ║
║                 │   function (t,x,J1,…,JK) -&gt; nothing (B)  │         ║
║                 │ with K = 1+M1/M2 and (M1+M2==d)          │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ JACOBIBANDSTRUCT│ A tuple (l,u) describing the banded      │ nothing ║
║                 │ structure of the Jacobian or nothing if  │         ║
║                 │ the Jacobian is full.                    │         ║
║                 │ see help_specialstructure                │         ║
╟─────────────────┼──────────────────────────────────────────┼─────────╢
║ WORKFORRHS      │ estimated works (complexity) for a call  │     1.0 ║
║ WORKFORJAC      │ to                                       │     5.0 ║
║ WORKFORDEC      │ WORKFORRHS: right-hand side f            │     1.0 ║
║ WORKFORSOL      │ WORKFORJAC: JACOBIMATRIX                 │     1.0 ║
║                 │ WORKFORDEC: LU-decomposition             │         ║
║                 │ WORKFORSOL: Forward- and Backward subst. │         ║
╚═════════════════╧══════════════════════════════════════════╧═════════╝</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.seulex_i32" href="#ODEInterface.seulex_i32"><code>ODEInterface.seulex_i32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>seulex with 32bit integers, see seulex.</p></div></div></section><pre><code class="language-none">ODEInterface.seulex_impl</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solverInfo" href="#ODEInterface.solverInfo"><code>ODEInterface.solverInfo</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>In this array every (supported) solver appends its SolverInfo-record.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solver_extract_commonOpt" href="#ODEInterface.solver_extract_commonOpt"><code>ODEInterface.solver_extract_commonOpt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function solver_extract_commonOpt(t0::Real, T::Real, x0::Vector, 
              opt::AbstractOptionsODE, 
              args::AbstractArgumentsODESolver{FInt}) where FInt
   -&gt; (d,nrdense,scalarFlag,rhs_mode,output_mode,output_fcn)</code></pre><p>get d, fill args.N, args.x, args.t, args.tEnd, args.RTOL, args.ATOL</p><p>reads options: <code>OPT_RTOL</code>, <code>OPT_ATOL</code>, <code>OPT_RHS_CALLMODE</code>,  <code>OPT_OUTPUTMODE</code>, <code>OPT_OUTPUTFCN</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solver_extract_rhsMode" href="#ODEInterface.solver_extract_rhsMode"><code>ODEInterface.solver_extract_rhsMode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function solver_extract_rhsMode(opt::AbstractOptionsODE)
             -&gt; rhs_mode</code></pre><p>reads options: <code>OPT_RHS_CALLMODE</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solver_init" href="#ODEInterface.solver_init"><code>ODEInterface.solver_init</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function solver_init(solver_name::AbstractString, 
                      opt::AbstractOptionsODE)
    -&gt;  (lio,l,l_g,l_solver,lprefix)</code></pre><p>reads options: <code>OPT_LOGIO</code>, <code>OPT_LOGLEVEL</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solver_start" href="#ODEInterface.solver_start"><code>ODEInterface.solver_start</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function solver_start(solver_name::AbstractString, rhs, 
             t0::Real, T::Real, x0::Vector, opt::AbstractOptionsODE)
    -&gt;  (lio,l,l_g,l_solver,lprefix)</code></pre><p>initialization for a (typical) solver call/start.</p><p>reads options: <code>OPT_LOGIO</code>, <code>OPT_LOGLEVEL</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.solvers_outputattimes" href="#ODEInterface.solvers_outputattimes"><code>ODEInterface.solvers_outputattimes</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Solvers where OPT_OUTPUTATTIMES is needed for the get the solution at predefined times.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.trytoloadlib" href="#ODEInterface.trytoloadlib"><code>ODEInterface.trytoloadlib</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function trytoloadlib(name::AbstractString,extrapaths::Vector)</code></pre><p>tries to (dynamically) load the given shared library given by name.</p><p>if <code>ame=&quot;name&quot;</code> then all the following variants will be tried: <code>&quot;name&quot;</code>, <code>&quot;NAME&quot;</code>, <code>&quot;Name&quot;</code></p><p>returns <code>(ptr,filepath)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.trytoloadmethod" href="#ODEInterface.trytoloadmethod"><code>ODEInterface.trytoloadmethod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function trytoloadmethod(libhandle::Ptr{Cvoid},
       method_name::AbstractString) -&gt; (ptr,namefound)</code></pre><p>tries to find the given method by name in a dynamically loaded library.</p><p>if <code>method_name=&quot;name&quot;</code> then the following variants will be tried: <code>&quot;name&quot;</code>, <code>&quot;NAME&quot;</code>, <code>&quot;Name&quot;</code>, <code>&quot;name_&quot;</code>, <code>&quot;NAME_&quot;</code>, <code>&quot;Name_&quot;</code>, <code>&quot;_name&quot;</code>, <code>&quot;_NAME&quot;</code>, <code>&quot;_Name&quot;</code>, <code>&quot;_name_&quot;</code>, <code>&quot;_NAME_&quot;</code>, <code>&quot;_Name_&quot;</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unloadODESolvers" href="#ODEInterface.unloadODESolvers"><code>ODEInterface.unloadODESolvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unloadODESolvers()</code></pre><p>unload all (loaded) solvers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1JacCallback" href="#ODEInterface.unsafe_HW1JacCallback"><code>ODEInterface.unsafe_HW1JacCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1JacCallback(n_::Ptr{FInt},
         t_::Ptr{Float64},x_::Ptr{Float64},dfx_::Ptr{Float64},
         ldfx_::Ptr{FInt}, rpar_::Ptr{Float64}, 
         cbi::CI) where {FInt&lt;:FortranInt, CI&lt;:ODEinternalCallInfos}
          -&gt; nothing</code></pre><p>This is the JAC callback given to radau5, radau and seulex.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function calls the user-given Julia function cbi.jacobimatrix with the appropriate arguments (depending on M1 and jacobibandstruct).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1JacCallback_c" href="#ODEInterface.unsafe_HW1JacCallback_c"><code>ODEInterface.unsafe_HW1JacCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1JacCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1MassCallback" href="#ODEInterface.unsafe_HW1MassCallback"><code>ODEInterface.unsafe_HW1MassCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1MassCallback(n_::Ptr{FInt}, am_::Ptr{Float64}, 
         lmas_::Ptr{FInt}, rpar_::Ptr{Float64}, 
         cbi::CI) where {FInt&lt;:FortranInt,CI&lt;:ODEinternalCallInfos}
          -&gt; nothing</code></pre><p>This is the MAS callback given to radau5, radau and seulex.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function takes the values of  the mass matrix saved in  the InternalCallInfos.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1MassCallback_c" href="#ODEInterface.unsafe_HW1MassCallback_c"><code>ODEInterface.unsafe_HW1MassCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1MassCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1RHSCallback" href="#ODEInterface.unsafe_HW1RHSCallback"><code>ODEInterface.unsafe_HW1RHSCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1RHSCallback(
         n_::Ptr{FInt}, t_::Ptr{Float64}, x_::Ptr{Float64}, 
         f_::Ptr{Float64}, rpar_::Ptr{Float64}, 
         cbi::CI) where {FInt&lt;:FortranInt, CI&lt;:ODEinternalCallInfos}
          -&gt; nothing</code></pre><p>This is the right-hand side given as callback to several Fortran-solvers, e.g. dopri5, dop853, odex.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW1RHSCallback_c" href="#ODEInterface.unsafe_HW1RHSCallback_c"><code>ODEInterface.unsafe_HW1RHSCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW1RHSCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre><p>This method generates a Pointer to C-callable instructions. The two method type parameters <code>FInt</code> and <code>CI</code> are important: <code>FInt</code> is the used Fortran integer type and <code>CI</code> is the used  <code>ODEinternalCallInfos</code> <em>SubType</em>. Because <code>unsafe_HW1RHSCallback</code> is a parameterized method, special variants are compiled, if <code>FInt</code> or <code>CI</code> changes. If <code>CI</code> itself is a parameterized type (depending on all the user-given Julia-functions like right-hand side, etc.) then calls to such Julia-functions can be resolved at compile-time (instead of dynamic calls during run-time).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW2RHSCallback" href="#ODEInterface.unsafe_HW2RHSCallback"><code>ODEInterface.unsafe_HW2RHSCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW2RHSCallback(
         n_::Ptr{FInt}, t_::Ptr{Float64}, x_::Ptr{Float64}, 
         f_::Ptr{Float64}, rpar_::Ptr{Float64}, 
         cbi::CI) where {FInt&lt;:FortranInt, CI&lt;:ODEinternalCallInfos}
          -&gt; nothing</code></pre><p>This is the right-hand side given as callback to Fortran-solvers (e.g. radau5 and radau) that can handle problems with &quot;special structure&quot;,  see <code>help_specialstructure</code>.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HW2RHSCallback_c" href="#ODEInterface.unsafe_HW2RHSCallback_c"><code>ODEInterface.unsafe_HW2RHSCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HW2RHSCallback_c(cbi::CI,
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre><p>see <code>unsafe_HW1RHSCallback_c</code> for an explanation of <code>FInt</code>, <code>CI</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HWRhsTimeDerivCallback" href="#ODEInterface.unsafe_HWRhsTimeDerivCallback"><code>ODEInterface.unsafe_HWRhsTimeDerivCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HWRhsTimeDerivCallback(
         n_::Ptr{FInt}, t_::Ptr{Float64},x_::Ptr{Float64},
         dfdt_::Ptr{Float64}, rpar_::Ptr{Float64},
         cbi::CI) where {FInt&lt;:FortranInt, CI&lt;:ODEinternalCallInfos}
          -&gt; nothing</code></pre><p>This is the DFX callback given to rodas.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function calls the user-given Julia function cbi.rhstimederiv with the appropriate arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_HWRhsTimeDerivCallback_c" href="#ODEInterface.unsafe_HWRhsTimeDerivCallback_c"><code>ODEInterface.unsafe_HWRhsTimeDerivCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_HWRhsTimeDerivCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre></div></div></section><pre><code class="language-none">ODEInterface.unsafe_SLATEC1JacCallback</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_SLATEC1JacCallback_c" href="#ODEInterface.unsafe_SLATEC1JacCallback_c"><code>ODEInterface.unsafe_SLATEC1JacCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_SLATEC1JacCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt, CI}
    -&gt; C-callable function pointer</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_SLATEC1RHSCallback" href="#ODEInterface.unsafe_SLATEC1RHSCallback"><code>ODEInterface.unsafe_SLATEC1RHSCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_SLATEC1RHSCallback(
         t_::Ptr{Float64}, x_::Ptr{Float64}, f_::Ptr{Float64}, 
         rpar_::Ptr{Float64}, cbi::CI) where CI&lt;:ODEinternalCallInfos</code></pre><p>This is the right-hand side given as callback to SLATEC solvers, e.g. ddeabm.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_SLATEC1RHSCallback_c" href="#ODEInterface.unsafe_SLATEC1RHSCallback_c"><code>ODEInterface.unsafe_SLATEC1RHSCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_SLATEC1RHSCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre><p>This method generates a Pointer to C-callable instructions. The two method type parameters <code>FInt</code> and <code>CI</code> are important: <code>FInt</code> is the used Fortran integer type and <code>CI</code> is the used  <code>ODEinternalCallInfos</code> <em>SubType</em>. Because <code>unsafe_SLATEC1RHSCallback</code> is a parameterized method, special variants are compiled, if <code>FInt</code> or <code>CI</code> changes. If <code>CI</code> itself is a parameterized type (depending on all the user-given Julia-functions like right-hand side, etc.) then calls to such Julia-functions can be resolved at compile-time (instead of dynamic calls during run-time).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_Dbc_cb" href="#ODEInterface.unsafe_bvpm2_Dbc_cb"><code>ODEInterface.unsafe_bvpm2_Dbc_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the derivative of the boundary-conditions given as callback to bvpm2 in the case with no unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_Dbc_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_Dbcpar_cb" href="#ODEInterface.unsafe_bvpm2_Dbcpar_cb"><code>ODEInterface.unsafe_bvpm2_Dbcpar_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the derivative of the boundary-conditions given as callback to bvpm2 in the case with unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_Dbcpar_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_Drhs_cb" href="#ODEInterface.unsafe_bvpm2_Drhs_cb"><code>ODEInterface.unsafe_bvpm2_Drhs_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the derivative of the right-hand side given as callback to bvpm2 in the case where the problem has no unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_Drhs_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_Drhspar_cb" href="#ODEInterface.unsafe_bvpm2_Drhspar_cb"><code>ODEInterface.unsafe_bvpm2_Drhspar_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the derivative of the right-hand side given as callback to bvpm2 in the case where the problem has unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_Drhspar_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_bc_cb" href="#ODEInterface.unsafe_bvpm2_bc_cb"><code>ODEInterface.unsafe_bvpm2_bc_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the boundary-conditions function given as callback to bvpm2 in the case with no unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_bc_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_bcpar_cb" href="#ODEInterface.unsafe_bvpm2_bcpar_cb"><code>ODEInterface.unsafe_bvpm2_bcpar_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the boundary-conditions function given as callback to bvpm2 in the case with unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_bcpar_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_guess_cb" href="#ODEInterface.unsafe_bvpm2_guess_cb"><code>ODEInterface.unsafe_bvpm2_guess_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the guess function given as callback to bvpm2.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_guess_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_rhs_cb" href="#ODEInterface.unsafe_bvpm2_rhs_cb"><code>ODEInterface.unsafe_bvpm2_rhs_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the right-hand side given as callback to bvpm2 in the case where the problem has no unkown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_rhs_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpm2_rhspar_cb" href="#ODEInterface.unsafe_bvpm2_rhspar_cb"><code>ODEInterface.unsafe_bvpm2_rhspar_cb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the right-hand side given as callback to bvpm2 in the case where the problem has unknown parameters.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpm2_rhspar_cb_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpsolbc" href="#ODEInterface.unsafe_bvpsolbc"><code>ODEInterface.unsafe_bvpsolbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_bvpsolbc(xa_::Ptr{Float64}, xb_::Ptr{Float64}, 
   r_::Ptr{Float64}) -&gt; nothing</code></pre><p>This is the callback for the boundary conditions given to bvpsol.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p><p>uses bvpsolbc</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpsolbc_c" href="#ODEInterface.unsafe_bvpsolbc_c"><code>ODEInterface.unsafe_bvpsolbc_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function unsafe_bvpsolbc_c()</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpsolivp" href="#ODEInterface.unsafe_bvpsolivp"><code>ODEInterface.unsafe_bvpsolivp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_bvpsolivp(n_::Ptr{FInt}, 
         fcn_::Ptr{Cvoid}, t_::Ptr{Float64}, x_::Ptr{Float64}, 
         tend_::Ptr{Float64}, tol_::Ptr{Float64}, hmax_::Ptr{Float64}, 
         h_::Ptr{Float64}, kflag_::Ptr{FInt}) where FInt&lt;:FortranInt</code></pre><p>This is the callback for bvpsol to solve initial value problems.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p><p>uses bvpsolivp</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_bvpsolivp_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpsolrhs" href="#ODEInterface.unsafe_bvpsolrhs"><code>ODEInterface.unsafe_bvpsolrhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_bvpsolrhs(n_::Ptr{FInt}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, f_::Ptr{Float64}) where FInt&lt;:FortranInt</code></pre><p>This is the right-hand side given as callback to bvpsol.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p><p>uses hw1rhs</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_bvpsolrhs_c" href="#ODEInterface.unsafe_bvpsolrhs_c"><code>ODEInterface.unsafe_bvpsolrhs_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_bvpsolrhs_c(fint_flag::FInt) where FInt</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_colnew_Dbc" href="#ODEInterface.unsafe_colnew_Dbc"><code>ODEInterface.unsafe_colnew_Dbc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_colnew_Dbc(i_::Ptr{FInt},
   z_::Ptr{Float64}, Dbc_::Ptr{Float64}) where FInt&lt;:FortranInt</code></pre><p>This is the jacobian for the side-/boundary-conditions given as callback to colnew.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_colnew_Dbc_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_colnew_Drhs" href="#ODEInterface.unsafe_colnew_Drhs"><code>ODEInterface.unsafe_colnew_Drhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function unsafe_colnew_Drhs(t_::Ptr{Float64}, z_::Ptr{Float64},
    df_::Ptr{Float64})</code></pre><p>This is the Jacobian for the right-hand side given as callback to colnew.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_colnew_Drhs_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_colnew_bc" href="#ODEInterface.unsafe_colnew_bc"><code>ODEInterface.unsafe_colnew_bc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_colnew_bc(i_::Ptr{FInt},
   z_::Ptr{Float64}, bc_::Ptr{Float64}) where FInt&lt;:FortranInt</code></pre><p>This is the side-/boundary-conditions given as callback to colnew.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_colnew_bc_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_colnew_guess" href="#ODEInterface.unsafe_colnew_guess"><code>ODEInterface.unsafe_colnew_guess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is the guess function given as callback to colnew.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_colnew_guess_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_colnew_rhs" href="#ODEInterface.unsafe_colnew_rhs"><code>ODEInterface.unsafe_colnew_rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">  function unsafe_colnew_rhs(t_::Ptr{Float64}, z_::Ptr{Float64}, 
    f_::Ptr{Float64})</code></pre><p>This is the right-hand side given as callback to colnew.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-arguments.</p></div></div></section><pre><code class="language-none">ODEInterface.unsafe_colnew_rhs_c</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_dopriSoloutCallback" href="#ODEInterface.unsafe_dopriSoloutCallback"><code>ODEInterface.unsafe_dopriSoloutCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_dopriSoloutCallback(
         nr_::Ptr{FInt}, told_::Ptr{Float64}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, n_::Ptr{FInt}, con_::Ptr{Float64},
         icomp_::Ptr{FInt}, nd_::Ptr{FInt}, rpar_::Ptr{Float64}, 
         cbi::CI, irtrn_::Ptr{FInt}) where {FInt&lt;:FortranInt, 
                                            CI&lt;:DopriInternalCallInfos}</code></pre><p>This is the solout given as callback to Fortran-dopri.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function saves the state informations of the solver in <code>DopriInternalCallInfos</code>, where they can be found by the <code>eval_sol_fcn</code>, see <code>create_dopri_eval_sol_fcn_closure</code>.</p><p>Then the user-supplied <code>output_fcn</code> is called (which in turn can use <code>eval_sol_fcn</code>, to evalutate the solution at intermediate points).</p><p>The return value of the <code>output_fcn</code> is propagated to  <code>DOPRI5_</code> or <code>DOP853_</code>.</p><p>For the typical calling sequence, see <code>DopriInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_dopriSoloutCallback_c" href="#ODEInterface.unsafe_dopriSoloutCallback_c"><code>ODEInterface.unsafe_dopriSoloutCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_dopriSoloutCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}
    -&gt; C-callable function pointer</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_odexSoloutCallback" href="#ODEInterface.unsafe_odexSoloutCallback"><code>ODEInterface.unsafe_odexSoloutCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_odexSoloutCallback(
         nr_::Ptr{FInt}, told_::Ptr{Float64}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, n_::Ptr{FInt}, con_::Ptr{Float64}, 
         ncon_::Ptr{FInt}, icomp_::Ptr{FInt}, nd_::Ptr{FInt}, 
         rpar_::Ptr{Float64}, cbi::CI, 
         irtrn_::Ptr{FInt}) where {FInt&lt;:FortranInt,
                                   CI&lt;:OdexInternalCallInfos}</code></pre><p>This is the solout given as callback to Fortran-odex.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function saves the state informations of the solver in <code>OdexInternalCallInfos</code>, where they can be found by the <code>eval_sol_fcn</code>, see <code>create_odex_eval_sol_fcn_closure</code>.</p><p>Then the user-supplied <code>output_fcn</code> is called (which in turn can use <code>eval_sol_fcn</code>, to evalutate the solution at intermediate points).</p><p>The return value of the <code>output_fcn</code> is propagated to <code>ODEX_</code>.</p><p>For the typical calling sequence, see <code>OdexInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_odexSoloutCallback_c" href="#ODEInterface.unsafe_odexSoloutCallback_c"><code>ODEInterface.unsafe_odexSoloutCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_odexSoloutCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_radauSoloutCallback" href="#ODEInterface.unsafe_radauSoloutCallback"><code>ODEInterface.unsafe_radauSoloutCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_radauSoloutCallback(
         nr_::Ptr{FInt}, told_::Ptr{Float64}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, cont_::Ptr{Float64}, lrc_::Ptr{FInt}, 
         n_::Ptr{FInt}, rpar_::Ptr{Float64}, 
         cbi::CI, irtrn_::Ptr{FInt}) where {FInt&lt;:FortranInt,
                                            CI&lt;:RadauInternalCallInfos}</code></pre><p>This is the solout given as callback to Fortran radau5/radau.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function saves the state informations of the solver in <code>RadauInternalCallInfos</code>, where they can be found by the <code>eval_sol_fcn</code>, see <code>create_radau_eval_sol_fcn_closure</code>.</p><p>Then the user-supplied <code>output_fcn</code> is called (which in turn can use <code>eval_sol_fcn</code>, to evalutate the solution at intermediate points).</p><p>The return value of the <code>output_fcn</code> is propagated to <code>RADAU5_</code>/<code>RADAU_</code>.</p><p>For the typical calling sequence, see <code>RadauInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_radauSoloutCallback_c" href="#ODEInterface.unsafe_radauSoloutCallback_c"><code>ODEInterface.unsafe_radauSoloutCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_radauSoloutCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_rodasSoloutCallback" href="#ODEInterface.unsafe_rodasSoloutCallback"><code>ODEInterface.unsafe_rodasSoloutCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_rodasSoloutCallback(
         nr_::Ptr{FInt}, told_::Ptr{Float64}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, cont_::Ptr{Float64}, lrc_::Ptr{FInt}, 
         n_::Ptr{FInt}, rpar_::Ptr{Float64}, cbi::CI, 
         irtrn_::Ptr{FInt}) where {FInt&lt;:FortranInt, 
                                   CI&lt;:RodasInternalCallInfos}</code></pre><p>This is the solout given as callback to Fortran-rodas.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function saves the state informations of the solver in <code>RodasInternalCallInfos</code>, where they can be found by the <code>eval_sol_fcn</code>, see <code>create_rodas_eval_sol_fcn_closure</code>.</p><p>Then the user-supplied <code>output_fcn</code> is called (which in turn can use <code>eval_sol_fcn</code>, to evalutate the solution at intermediate points).</p><p>The return value of the <code>output_fcn</code> is propagated to <code>RODAS_</code>.</p><p>For the typical calling sequence, see <code>RodasInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_rodasSoloutCallback_c" href="#ODEInterface.unsafe_rodasSoloutCallback_c"><code>ODEInterface.unsafe_rodasSoloutCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_rodasSoloutCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_seulexSoloutCallback" href="#ODEInterface.unsafe_seulexSoloutCallback"><code>ODEInterface.unsafe_seulexSoloutCallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_seulexSoloutCallback(
         nr_::Ptr{FInt}, told_::Ptr{Float64}, t_::Ptr{Float64}, 
         x_::Ptr{Float64}, rc_::Ptr{Float64}, lrc_::Ptr{FInt}, 
         ic_::Ptr{FInt}, lic_::Ptr{FInt}, n_::Ptr{FInt}, 
         rpar_::Ptr{Float64}, cbi::CI, 
         irtrn_::Ptr{FInt}) where {FInt&lt;:FortranInt, 
                                   CI&lt;:SeulexInternalCallInfos}</code></pre><p>This is the solout given as callback to Fortran-seulex.</p><p>The <code>unsafe</code> prefix in the name indicates that no validations are  performed on the <code>Ptr</code>-pointers.</p><p>This function saves the state informations of the solver in <code>SeulexInternalCallInfos</code>, where they can be found by the <code>eval_sol_fcn</code>, see <code>create_seulex_eval_sol_fcn_closure</code>.</p><p>Then the user-supplied <code>output_fcn</code> is called (which in turn can use <code>eval_sol_fcn</code>, to evalutate the solution at intermediate points).</p><p>The return value of the <code>output_fcn</code> is propagated to <code>SEULEX_</code>.</p><p>For the typical calling sequence, see <code>SeulexInternalCallInfos</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODEInterface.unsafe_seulexSoloutCallback_c" href="#ODEInterface.unsafe_seulexSoloutCallback_c"><code>ODEInterface.unsafe_seulexSoloutCallback_c</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> function unsafe_seulexSoloutCallback_c(cbi::CI, 
         fint_flag::FInt) where {FInt,CI}</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
