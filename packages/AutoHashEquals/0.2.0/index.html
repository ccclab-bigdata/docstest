<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· AutoHashEquals.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AutoHashEquals.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#Warnings-1">Warnings</a></li><li><a class="toctext" href="#Credits-1">Credits</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/andrewcooke/AutoHashEquals.jl"><img src="https://travis-ci.org/andrewcooke/AutoHashEquals.jl.png" alt="Build Status"/></a> <a href="https://coveralls.io/r/andrewcooke/AutoHashEquals.jl"><img src="https://coveralls.io/repos/andrewcooke/AutoHashEquals.jl/badge.svg" alt="Coverage Status"/></a></p><p><a href="http://pkg.julialang.org/?pkg=AutoHashEquals&amp;ver=0.5"><img src="http://pkg.julialang.org/badges/AutoHashEquals_0.5.svg" alt="AutoHashEquals"/></a> <a href="http://pkg.julialang.org/?pkg=AutoHashEquals&amp;ver=0.6"><img src="http://pkg.julialang.org/badges/AutoHashEquals_0.6.svg" alt="AutoHashEquals"/></a></p><h1><a class="nav-anchor" id="AutoHashEquals-1" href="#AutoHashEquals-1">AutoHashEquals</a></h1><p>A macro to add == and hash() to composite types (ie struct and mutable struct blocks).</p><p>For example:</p><pre><code class="language-julia">@auto_hash_equals mutable struct Foo
    a::Int
    b
end</code></pre><p>becomes</p><pre><code class="language-julia">mutable struct Foo
    a::Int
    b
end
Base.hash(a::Foo, h::UInt) = hash(a.b, hash(a.a, hash(:Foo, h)))
Base.(:(==))(a::Foo, b::Foo) = isequal(a.b, b.b) &amp;&amp; isequal(a.a, b.a) &amp;&amp; true</code></pre><p>Where</p><ul><li><p>we use <code>isequal()</code> because we want to match <code>Inf</code> values, etc.</p></li><li><p>we include the type in the hash so that different types with the same contents don&#39;t collide</p></li><li><p>the type and <code>true</code> make it simple to generate code for empty records</p></li><li><p>the <code>Base</code> module is explicitly used so that you don&#39;t need to import it</p></li></ul><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>Julia has two composite types: <em>value</em> types, defined with <code>struct</code>, and <em>record</em> types, defined with <code>mutable struct</code>.</p><p>Value types are intended for compact, immutable objects.  They are stored on the stack, passed by value, and the default hash and equality are based on the literal bits in memory.</p><p>Record types are allocated on the heap, are passed by reference, and the default hash and equality are based on the pointer value (the data address).</p><p>When you embed a record type in a value type, then the pointer to the record type becomes part of the value type, and so is included in equality and hash.</p><p>Given the above, it is often necessary to define hash and equality for composite types.  Particularly when record types are used (directly, or in a value type), and when records with the same contents are semantically equal.</p><p>A common way to do this is to define the hash as a combination of the hashes of all the fields.  Similarly, equality is often defined as equality of all fields.</p><p>This macro automates this common approach.</p><h2><a class="nav-anchor" id="Warnings-1" href="#Warnings-1">Warnings</a></h2><p>If you use this macro for a mutable type, then the hash depends on the contents of that type, so changing the contents changes the hash.  Such types should not be stored in a hash table (Dict) and then mutated, because the objects will be &quot;lost&quot; (as the hash table <em>assumes</em> that hash is constant).</p><p>More generally, <strong>this macro is only useful for mutable types when they are used as <em>immutable</em> records</strong>.</p><h2><a class="nav-anchor" id="Credits-1" href="#Credits-1">Credits</a></h2><p>Thanks to Michael Hatherly, Yichao Yu, and Carlo Lucibello.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
