<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The @vlplot command Â· VegaLite.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>VegaLite.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../gettingstarted/installation/">Installation</a></li><li><a class="toctext" href="../../gettingstarted/tutorial/">Tutorial</a></li></ul></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../vlspec/">Vega-lite specifications</a></li><li class="current"><a class="toctext" href>The @vlplot command</a><ul class="internal"><li><a class="toctext" href="#JSON-syntax-vs-@vlplot-macro-1">JSON syntax vs <code>@vlplot</code> macro</a></li><li><a class="toctext" href="#Symbols-instead-of-Strings-1">Symbols instead of Strings</a></li><li><a class="toctext" href="#Shorthand-string-syntax-for-encodings-1">Shorthand string syntax for encodings</a></li><li><a class="toctext" href="#Shorthands-for-the-encoding-element-1">Shorthands for the <code>encoding</code> element</a></li><li><a class="toctext" href="#Mark-shorthands-1">Mark shorthands</a></li></ul></li><li><a class="toctext" href="../data/">Data sources</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples_simplecharts/">Simple Charts</a></li><li><span class="toctext">Single-View Plots</span><ul><li><a class="toctext" href="../../examples/examples_barchartshistograms/">Bar Charts &amp; Histograms</a></li><li><a class="toctext" href="../../examples/examples_scatter_strip_plots/">Scatter &amp; Strip Plots</a></li><li><a class="toctext" href="../../examples/examples_line_charts/">Line Charts</a></li><li><a class="toctext" href="../../examples/examples_area_Charts_streamgraphs/">Area Charts &amp; Streamgraphs</a></li><li><a class="toctext" href="../../examples/examples_table_based_plots/">Table-based Plots</a></li></ul></li><li><span class="toctext">Layered Plots</span><ul><li><a class="toctext" href="../../examples/examples_error_bars_bands/">Error Bars &amp; Error Bands</a></li><li><a class="toctext" href="../../examples/examples_box_plots/">Box Plots</a></li></ul></li><li><span class="toctext">Multi-View Displays</span><ul><li><a class="toctext" href="../../examples/examples_faceting/">Faceting (Trellis Plot / Small Multiples)</a></li><li><a class="toctext" href="../../examples/examples_repeat_concatenation/">Repeat &amp; Concatenation</a></li></ul></li><li><a class="toctext" href="../../examples/examples_maps/">Maps (Geographic Displays)</a></li></ul></li><li><span class="toctext">Reference Manual</span><ul><li><a class="toctext" href="../../referencemanual/global/">Global settings</a></li><li><a class="toctext" href="../../referencemanual/output/">Outputs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User Guide</li><li><a href>The @vlplot command</a></li></ul></nav><hr/><div id="topbar"><span>The @vlplot command</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-@vlplot-command-1" href="#The-@vlplot-command-1">The @vlplot command</a></h1><p>The <code>@vlplot</code> macro is the main method to create Vega-Lite plots from julia. The macro accepts arguments that look almost identical to the original Vega-Lite JSON syntax. It should therefore be very easy to take any given Vega-Lite JSON example and translate it into a corresponding <code>@vlplot</code> macro call. The macro also provides a number of shorthands that make it easy to create very compact plot specifications. This section will first review the difference between the original JSON Vega-Lite syntax and the <code>@vlplot</code> macro, and then discuss the various shorthands that users will typically use.</p><h2><a class="nav-anchor" id="JSON-syntax-vs-@vlplot-macro-1" href="#JSON-syntax-vs-@vlplot-macro-1">JSON syntax vs <code>@vlplot</code> macro</a></h2><p>A very simple <a href="https://vega.github.io/vega-lite/">Vega-Lite</a> JSON specification looks like this:</p><pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;values&quot;: [
      {&quot;a&quot;: &quot;A&quot;,&quot;b&quot;: 28}, {&quot;a&quot;: &quot;B&quot;,&quot;b&quot;: 55}, {&quot;a&quot;: &quot;C&quot;,&quot;b&quot;: 43},
      {&quot;a&quot;: &quot;D&quot;,&quot;b&quot;: 91}, {&quot;a&quot;: &quot;E&quot;,&quot;b&quot;: 81}, {&quot;a&quot;: &quot;F&quot;,&quot;b&quot;: 53},
      {&quot;a&quot;: &quot;G&quot;,&quot;b&quot;: 19}, {&quot;a&quot;: &quot;H&quot;,&quot;b&quot;: 87}, {&quot;a&quot;: &quot;I&quot;,&quot;b&quot;: 52}
    ]
  },
  &quot;mark&quot;: &quot;bar&quot;,
  &quot;encoding&quot;: {
    &quot;x&quot;: {&quot;field&quot;: &quot;a&quot;, &quot;type&quot;: &quot;ordinal&quot;},
    &quot;y&quot;: {&quot;field&quot;: &quot;b&quot;, &quot;type&quot;: &quot;quantitative&quot;}
  }
}</code></pre><p>This can be directly translated into the following <code>@vlplot</code> macro call:</p><pre><code class="language-julia">using VegaLite

@vlplot(
    data={
        values=[
            {a=&quot;A&quot;,b=28},{a=&quot;B&quot;,b=55},{a=&quot;C&quot;,b=43},
            {a=&quot;D&quot;,b=91},{a=&quot;E&quot;,b=81},{a=&quot;F&quot;,b=53},
            {a=&quot;G&quot;,b=19},{a=&quot;H&quot;,b=87},{a=&quot;I&quot;,b=52}
        ]
    },
    mark=&quot;bar&quot;,
    encoding={
        x={field=&quot;a&quot;, typ=&quot;ordinal&quot;},
        y={field=&quot;b&quot;, typ=&quot;quantitative&quot;}
    }
)</code></pre><p>We had to make the following adjustments to the original JSON specification:</p><ol><li>The outer pair of <code>{}</code> brackets was removed, the parenthesis <code>()</code> of the macro call instead deliminate the beginning and end of the specification.</li><li>The quotation marks <code>&quot;</code> around keys like <code>mark</code> are removed.</li><li>The JSON key-value separator <code>:</code> was replaced with <code>=</code>.</li><li>Any key that is named <code>type</code> in the JSON specification has to be renamed to <code>typ</code> in the <code>@vlplot</code> macro (<code>type</code> is a reserved keyword in julia and can therefore not be used here).</li><li>Any <code>null</code> value in the JSON specification should be replaced with <code>nothing</code> in the <code>@vlplot</code> call.</li></ol><p>These five rules should be sufficient to translate any valid JSON Vega-Lite specification into a corresponding <code>@vlplot</code> macro call.</p><h2><a class="nav-anchor" id="Symbols-instead-of-Strings-1" href="#Symbols-instead-of-Strings-1">Symbols instead of Strings</a></h2><p>A first shorthand provided by the <code>@vlplot</code> macro is that you can use a <code>Symbol</code> on the right hand side of any key-value pair instead of a <code>String</code>. For example, instead of writing <code>mark=&quot;bar&quot;</code>, you can write <code>mark=:bar</code>.</p><p>The following example demonstrates this in the context of a full plotting example:</p><pre><code class="language-julia">data |&gt;
@vlplot(
    mark=:point, # Note how we use :point instead of &quot;point&quot; here
    encoding={
        x={
            field=:a, # Note how we use :a instead of &quot;a&quot; here
            typ=:ordinal # Note how we use :ordinal instead of &quot;ordinal&quot; here
        },
        y={
            field=:b, # Note how we use :b instead of &quot;b&quot; here
            typ=:quantitative # Note how we use :quantitative instead of &quot;quantitative&quot; here
        }
    }
)</code></pre><h2><a class="nav-anchor" id="Shorthand-string-syntax-for-encodings-1" href="#Shorthand-string-syntax-for-encodings-1">Shorthand string syntax for encodings</a></h2><p><a href="https://github.com/fredo-dedup/VegaLite.jl">VegaLite.jl</a> provides a similar string shorthand syntax for encodings as <a href="https://altair-viz.github.io/">Altair</a> (the Python wrapper around Vega-Lite).</p><p>Almost any channel encoding in a specification will have the keys <code>field</code> and <code>typ</code>, as in <code>x={field=:a, typ=:ordinal}</code>. Because these patterns are so common, we provide a shorthand string syntax for this case. Using the shorthand one can write the channel encoding as <code>x={&quot;a:o&quot;}</code>. These string shorthands have to appear as the first positional argument inside the curly brackets <code>{}</code> for the encoding channel. The pattern inside the string is that one specifies the name of the field before the <code>:</code>, and then the first letter of the type of encoding (<code>o</code> for ordinal, <code>q</code> for quantitative etc.).</p><p>The string shorthand also extends to the <code>timeUnit</code> and <code>aggregate</code> key in encodings. Aggregation functions and time units can be specified using a function call syntax inside the string shorthand. For example, <code>x={&quot;mean(foo)&quot;}</code> is equivalent to <code>x={field=:foo, aggregate=:mean, typ=:quantitative}</code> (note that we don&#39;t have to specify the type explicitly when we use aggregations, the default assumption is that the result of an aggregation is quantitative). An example that uses the shorthand for a time unit is <code>x={&quot;year(foo):t&quot;}</code>, which is equivalent to <code>x={field=:foo, timeUnit=:year, typ=:quantitative}</code>. For aggregations that don&#39;t require a field name (e.g. the <code>count</code> aggregation), you can just write <code>x=&quot;count()&quot;</code>.</p><p>String shorthands can be combined with any other attributes. For example, the following example shows how one can specify an axis title and still use the string shorthand notation:</p><pre><code class="language-julia">x={&quot;foo:q&quot;, axis={title=&quot;some title&quot;}}</code></pre><p>In cases where you don&#39;t want to specify any other attributes than what can be expressed in the string shorthand you don&#39;t have to use the surrounding curly brackets <code>{}</code> for the encoding: <code>x=&quot;foo:q&quot;</code> is equivalent to <code>x={field=:foo, typ=:quantitative}</code>. If you only want to specify the field and not even the type, you can resort to using a <code>Symbol</code>: <code>x=:foo</code> is also a valid encoding.</p><p>The shorthand string syntax allows us to write the specification of the plot from the previous section in this much more concise format:</p><pre><code class="language-julia">data |&gt;
@vlplot(
    mark=:point,
    encoding={
        x=&quot;a:o&quot;,
        y=:b
    }
)</code></pre><h2><a class="nav-anchor" id="Shorthands-for-the-encoding-element-1" href="#Shorthands-for-the-encoding-element-1">Shorthands for the <code>encoding</code> element</a></h2><p>There are two shorthands for the <code>encoding</code> element in a plot specification.</p><p>The first is to simply write <code>enc</code> instead of <code>encoding</code>. For example, the previous specification can be written as</p><pre><code class="language-julia">data |&gt;
@vlplot(
    mark=:point,
    enc={
        x=&quot;a:o&quot;,
        y=:b
    }
)</code></pre><p>An even shorter notation is to just leave the level of the <code>encoding</code> element away and place the channel encodings directly into the top level specification. With that option you would write the previous example as:</p><pre><code class="language-julia">data |&gt;
@vlplot(mark=:point, x=&quot;a:o&quot;, y=:b)</code></pre><h2><a class="nav-anchor" id="Mark-shorthands-1" href="#Mark-shorthands-1">Mark shorthands</a></h2><p>There are two shorthands for the <code>mark</code> attribute in a specification. The first option is to use the first positional argument in a <code>@vlplot</code> call to specify the mark type. This only works if you don&#39;t want to specify any other mark attributes. For example, the previous plot can now be written as</p><pre><code class="language-julia">data |&gt; @vlplot(:point, x=&quot;a:o&quot;, y=:b)</code></pre><p>If you want to specify more mark attributes, you can reintroduce curly brackets <code>{}</code>, and then specify the type of the mark as the first positional argument inside the <code>mark</code> block. For example, the following code specifies that the mark color should be red, in addition to picking points as the mark type:</p><pre><code class="language-julia">data |&gt;
@vlplot(
    mark={:point, color=:red},
    x=&quot;a:o&quot;,
    y=:b
)</code></pre><footer><hr/><a class="previous" href="../vlspec/"><span class="direction">Previous</span><span class="title">Vega-lite specifications</span></a><a class="next" href="../data/"><span class="direction">Next</span><span class="title">Data sources</span></a></footer></article></body></html>
