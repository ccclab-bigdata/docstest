<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · XLSX.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>XLSX.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.CellDataFormat" href="#XLSX.CellDataFormat"><code>XLSX.CellDataFormat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Keeps track of formatting information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.CellRange" href="#XLSX.CellRange"><code>XLSX.CellRange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>CellRange</code> represents a rectangular range of cells in a spreadsheet.</p><p><code>CellRange(&quot;A1:C4&quot;)</code> denotes cells ranging from <code>A1</code> (upper left corner) to <code>C4</code> (bottom right corner).</p><p>As a convenience, <code>@range_str</code> macro is provided.</p><pre><code class="language-julia">cr = XLSX.range&quot;A1:C4&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.CellRef" href="#XLSX.CellRef"><code>XLSX.CellRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>CellRef</code> represents a cell location given by row and column identifiers.</p><p><code>CellRef(&quot;A6&quot;)</code> indicates a cell located at column <code>1</code> and row <code>6</code>.</p><p>Example:</p><pre><code class="language-julia">cn = XLSX.CellRef(&quot;AB1&quot;)
println( XLSX.row_number(cn) ) # will print 1
println( XLSX.column_number(cn) ) # will print 28
println( string(cn) ) # will print out AB1</code></pre><p>As a convenience, <code>@ref_str</code> macro is provided.</p><pre><code class="language-julia">cn = XLSX.ref&quot;AB1&quot;
println( XLSX.row_number(cn) ) # will print 1
println( XLSX.column_number(cn) ) # will print 28
println( string(cn) ) # will print out AB1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.CellValue" href="#XLSX.CellValue"><code>XLSX.CellValue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>CellValue is a Julia type of a value read from a Spreadsheet.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.Relationship" href="#XLSX.Relationship"><code>XLSX.Relationship</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Relationships are defined in ECMA-376-1 Section 9.2. This struct matches the <code>Relationship</code> tag attribute names.</p><p>A <code>Relashipship</code> defines relations between the files inside a MSOffice package. Regarding Spreadsheets, there are two kinds of relationships:</p><pre><code class="language-none">* package level: defined in `_rels/.rels`.
* workbook level: defined in `xl/_rels/workbook.xml.rels`.</code></pre><p>The function <code>parse_relationships!(xf::XLSXFile)</code> is used to parse package and workbook level relationships.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.SharedStringTable" href="#XLSX.SharedStringTable"><code>XLSX.SharedStringTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Shared String Table</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.SheetRowIterator" href="#XLSX.SheetRowIterator"><code>XLSX.SheetRowIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterates over Worksheet cells. See <code>eachrow</code> method docs. Each element is a <code>SheetRow</code>.</p><p>Implementations: SheetRowStreamIterator, WorksheetCache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.Workbook" href="#XLSX.Workbook"><code>XLSX.Workbook</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Workbook is the result of parsing file <code>xl/workbook.xml</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.XLSXFile" href="#XLSX.XLSXFile"><code>XLSX.XLSXFile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>XLSXFile</code> stores all XML data from an Excel file.</p><p><code>filepath</code> is the filepath of the source file for this XLSXFile. <code>data</code> stored the raw XML data. It maps internal XLSX filenames to XMLDocuments. <code>workbook</code> is the result of parsing <code>xl/workbook.xml</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Tuple{XLSX.CellRef,XLSX.CellRange}" href="#Base.in-Tuple{XLSX.CellRef,XLSX.CellRange}"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Base.in(ref::CellRef, rng::CellRange) :: Bool</code></pre><p>Checks wether <code>ref</code> is a cell reference inside a range given by <code>rng</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.issubset-Tuple{XLSX.CellRange,XLSX.CellRange}" href="#Base.issubset-Tuple{XLSX.CellRange,XLSX.CellRange}"><code>Base.issubset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Base.issubset(subrng::CellRange, rng::CellRange)</code></pre><p>Checks wether <code>subrng</code> is a cell range contained in <code>rng</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">SheetRowStreamIterator(ws::Worksheet)</code></pre><p>Creates a reader for row elements in the Worksheet&#39;s XML. Will return a stream reader positioned in the first row element if it exists.</p><p>If there&#39;s no row element inside sheetData XML tag, it will close all streams and return <code>nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.add_relationship!-Tuple{XLSX.Workbook,String,String}" href="#XLSX.add_relationship!-Tuple{XLSX.Workbook,String,String}"><code>XLSX.add_relationship!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Adds new relationship. Returns new generated rId.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.add_shared_string!-Tuple{XLSX.Workbook,AbstractString,AbstractString}" href="#XLSX.add_shared_string!-Tuple{XLSX.Workbook,AbstractString,AbstractString}"><code>XLSX.add_shared_string!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add_shared_string!(sheet, str_unformatted, [str_formatted]) :: Int</code></pre><p>Add string to shared string table. Returns the 0-based index of the shared string in the shared string table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.addsheet!" href="#XLSX.addsheet!"><code>XLSX.addsheet!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addsheet!(workbook, [name]) :: Worksheet</code></pre><p>Create a new worksheet with named <code>name</code>. If <code>name</code> is not provided, a unique name is created.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.column_bounds-Tuple{XLSX.SheetRow}" href="#XLSX.column_bounds-Tuple{XLSX.SheetRow}"><code>XLSX.column_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>column_bounds(sr::SheetRow)</p><p>Returns a tuple with the first and last index of the columns for a <code>SheetRow</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.column_number-Tuple{XLSX.CellRef}" href="#XLSX.column_number-Tuple{XLSX.CellRef}"><code>XLSX.column_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">column_number(c::CellRef) :: Int</code></pre><p>Returns the column number of a given cell reference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.decode_column_number-Tuple{AbstractString}" href="#XLSX.decode_column_number-Tuple{AbstractString}"><code>XLSX.decode_column_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">decode_column_number(column_name::AbstractString) :: Int</code></pre><p>Converts column name to a column number.</p><pre><code class="language-julia">julia&gt; XLSX.decode_column_number(&quot;D&quot;)
4</code></pre><p>See also: <code>encode_column_number</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.default_cell_format-Tuple{XLSX.Worksheet,Union{Missing, Bool, Float64, Int64, Date, DateTime, Time, String}}" href="#XLSX.default_cell_format-Tuple{XLSX.Worksheet,Union{Missing, Bool, Float64, Int64, Date, DateTime, Time, String}}"><code>XLSX.default_cell_format</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the default <code>CellDataFormat</code> for a type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.eachrow-Tuple{XLSX.Worksheet}" href="#XLSX.eachrow-Tuple{XLSX.Worksheet}"><code>XLSX.eachrow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eachrow(sheet)</code></pre><p>Creates a row iterator for a worksheet.</p><p>Example: Query all cells from columns 1 to 4.</p><pre><code class="language-julia">left = 1  # 1st column
right = 4 # 4th column
for sheetrow in XLSX.eachrow(sheet)
    for column in left:right
        cell = XLSX.getcell(sheetrow, column)

        # do something with cell
    end
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.eachtablerow-Tuple{XLSX.Worksheet,Union{ColumnRange, AbstractString}}" href="#XLSX.eachtablerow-Tuple{XLSX.Worksheet,Union{ColumnRange, AbstractString}}"><code>XLSX.eachtablerow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function])</code></pre><p>Constructs an iterator of table rows. Each element of the iterator is of type <code>TableRow</code>.</p><p><code>header</code> is a boolean indicating wether the first row of the table is a table header.</p><p>If <code>header == false</code> and no <code>names</code> were supplied, column names will be generated following the column names found in the Excel file. Also, the column range will be inferred by the non-empty contiguous cells in the first row of the table.</p><p>The user can replace column names by assigning the optional <code>names</code> input variable with a <code>Vector{Symbol}</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the iterator will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>. Empty rows may be returned by the iterator when <code>stop_in_empty_row=false</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="language-none">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Example code:</p><pre><code class="language-none">for r in XLSX.eachtablerow(sheet)
    # r is a `TableRow`. Values are read using column labels or numbers.
    rn = XLSX.row_number(r) # `TableRow` row number.
    v1 = r[1] # will read value at table column 1.
    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.
end</code></pre><p>See also <code>gettable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.encode_column_number-Tuple{Int64}" href="#XLSX.encode_column_number-Tuple{Int64}"><code>XLSX.encode_column_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">encode_column_number(column_number::Int) :: String</code></pre><p>Converts column number to a column name.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; XLSX.encode_column_number(4)
&quot;D&quot;</code></pre><p>See also: <code>decode_column_number</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.excel_value_to_date-Tuple{Int64,Bool}" href="#XLSX.excel_value_to_date-Tuple{Int64,Bool}"><code>XLSX.excel_value_to_date</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts Excel number to Date.</p><p>See also: <code>isdate1904</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.excel_value_to_datetime-Tuple{Float64,Bool}" href="#XLSX.excel_value_to_datetime-Tuple{Float64,Bool}"><code>XLSX.excel_value_to_datetime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts Excel number to DateTime.</p><p>The decimal part represents the Time (see <code>_time</code> function). The integer part represents the Date.</p><p>See also: <code>isdate1904</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.excel_value_to_time-Tuple{Float64}" href="#XLSX.excel_value_to_time-Tuple{Float64}"><code>XLSX.excel_value_to_time</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts Excel number to Time. <code>x</code> must be between 0 and 1.</p><p>To represent Time, Excel uses the decimal part of a floating point number. <code>1</code> equals one day.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.filenames-Tuple{XLSX.XLSXFile}" href="#XLSX.filenames-Tuple{XLSX.XLSXFile}"><code>XLSX.filenames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Lists internal files from the XLSX package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.get_dimension-Tuple{XLSX.Worksheet}" href="#XLSX.get_dimension-Tuple{XLSX.Worksheet}"><code>XLSX.get_dimension</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Retuns the dimension of this worksheet as a CellRange.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.get_shared_string_index-Tuple{XLSX.SharedStringTable,AbstractString}" href="#XLSX.get_shared_string_index-Tuple{XLSX.SharedStringTable,AbstractString}"><code>XLSX.get_shared_string_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Checks if string is inside shared string table. Returns <code>nothing</code> if it&#39;s not in the shared string table. Returns the index of the string in the shared string table. The index is 0-based.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.getcell-Tuple{XLSX.Worksheet,XLSX.CellRef}" href="#XLSX.getcell-Tuple{XLSX.Worksheet,XLSX.CellRef}"><code>XLSX.getcell</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getcell(sheet, ref)</code></pre><p>Returns an <code>AbstractCell</code> that represents a cell in the spreadsheet.</p><p>Example:</p><pre><code class="language-julia">julia&gt; xf = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = xf[&quot;mysheet&quot;]

julia&gt; cell = XLSX.getcell(sheet, &quot;A1&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.getcellrange-Tuple{XLSX.Worksheet,XLSX.CellRange}" href="#XLSX.getcellrange-Tuple{XLSX.Worksheet,XLSX.CellRange}"><code>XLSX.getcellrange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getcellrange(sheet, rng)</code></pre><p>Returns a matrix with cells as <code>Array{AbstractCell, 2}</code>. <code>rng</code> must be a valid cell range, as in <code>&quot;A1:B2&quot;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.getdata-Tuple{XLSX.Worksheet,XLSX.CellRef}" href="#XLSX.getdata-Tuple{XLSX.Worksheet,XLSX.CellRef}"><code>XLSX.getdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getdata(sheet, ref)</code></pre><p>Returns a escalar or a matrix with values from a spreadsheet. <code>ref</code> can be a cell reference or a range.</p><p>Indexing in a <code>Worksheet</code> will dispatch to <code>getdata</code> method.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; f = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = f[&quot;mysheet&quot;]

julia&gt; v = sheet[&quot;A1:B4&quot;]</code></pre><p>See also <code>readdata</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.getdata-Tuple{XLSX.Worksheet,XLSX.Cell}" href="#XLSX.getdata-Tuple{XLSX.Worksheet,XLSX.Cell}"><code>XLSX.getdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getdata(ws::Worksheet, cell::Cell) :: CellValue</code></pre><p>Returns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.</p><p>For example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose <code>Date</code> as the result type.</p><p>For numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.</p><p>If <code>cell</code> has empty value or empty <code>String</code>, this function will return <code>missing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.gettable-Tuple{XLSX.Worksheet,Union{ColumnRange, AbstractString}}" href="#XLSX.gettable-Tuple{XLSX.Worksheet,Union{ColumnRange, AbstractString}}"><code>XLSX.gettable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gettable(sheet, [columns]; [first_row], [column_labels], [header], [infer_eltypes], [stop_in_empty_row], [stop_in_row_function]) -&gt; data, column_labels</code></pre><p>Returns tabular data from a spreadsheet as a tuple <code>(data, column_labels)</code>. <code>data</code> is a vector of columns. <code>column_labels</code> is a vector of symbols. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>columns=&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells.</p><p>Use <code>first_row</code> to indicate the first row from the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> as a vector of symbols to specify names for the header of the table.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=false</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="language-none">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Rows where all column values are equal to <code>missing</code> are dropped.</p><p>Example code for <code>gettable</code>:</p><pre><code class="language-julia">julia&gt; using DataFrames, XLSX

julia&gt; df = XLSX.openxlsx(&quot;myfile.xlsx&quot;) do xf
                DataFrame(XLSX.gettable(xf[&quot;mysheet&quot;])...)
            end</code></pre><p>See also: <code>readtable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.has_sst-Tuple{XLSX.Workbook}" href="#XLSX.has_sst-Tuple{XLSX.Workbook}"><code>XLSX.has_sst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">has_sst(workbook::Workbook)</code></pre><p>Checks wether this workbook has a Shared String Table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.internal_xml_file_isread-Tuple{XLSX.XLSXFile,String}" href="#XLSX.internal_xml_file_isread-Tuple{XLSX.XLSXFile,String}"><code>XLSX.internal_xml_file_isread</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns true if the file data was read into xl.data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.is_cache_enabled-Tuple{XLSX.Worksheet}" href="#XLSX.is_cache_enabled-Tuple{XLSX.Worksheet}"><code>XLSX.is_cache_enabled</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Indicates wether worksheet cache will be fed while reading worksheet cells.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.is_end_of_sheet_data-Tuple{EzXML.StreamReader}" href="#XLSX.is_end_of_sheet_data-Tuple{EzXML.StreamReader}"><code>XLSX.is_end_of_sheet_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Detects a closing sheetData element</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.is_valid_cellname-Tuple{AbstractString}" href="#XLSX.is_valid_cellname-Tuple{AbstractString}"><code>XLSX.is_valid_cellname</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_valid_cellname(n::AbstractString) :: Bool</code></pre><p>Checks wether <code>n</code> is a valid name for a cell.</p><p>Cell names are bounded by <code>A1 : XFD1048576</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.is_writable-Tuple{XLSX.XLSXFile}" href="#XLSX.is_writable-Tuple{XLSX.XLSXFile}"><code>XLSX.is_writable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_writable(xl::XLSXFile)</code></pre><p>Indicates wether this XLSX file can be edited. This controls if assignment to worksheet cells is allowed. Writable XLSXFile instances are opened with <code>XLSX.open_xlsx_template</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.isdate1904-Tuple{XLSX.Workbook}" href="#XLSX.isdate1904-Tuple{XLSX.Workbook}"><code>XLSX.isdate1904</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isdate1904(wb) :: Bool</code></pre><p>Returns true if workbook follows date1904 convention.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.open_empty_template" href="#XLSX.open_empty_template"><code>XLSX.open_empty_template</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">open_empty_template(sheetname::AbstractString=&quot;&quot;) :: XLSXFile</code></pre><p>Returns an empty, writable <code>XLSXFile</code> with 1 worksheet.</p><p><code>sheetname</code> is the name of the worksheet, defaults to <code>Sheet1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.open_internal_file_stream-Tuple{XLSX.XLSXFile,String}" href="#XLSX.open_internal_file_stream-Tuple{XLSX.XLSXFile,String}"><code>XLSX.open_internal_file_stream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Open a file for streaming.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.open_xlsx_template-Tuple{AbstractString}" href="#XLSX.open_xlsx_template-Tuple{AbstractString}"><code>XLSX.open_xlsx_template</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">open_xlsx_template(filepath::AbstractString) :: XLSXFile</code></pre><p>Open an Excel file as template for editing and saving to another file with <code>XLSX.writexlsx</code>.</p><p>The returned <code>XLSXFile</code> instance is in closed state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.openxlsx-Tuple{Function,AbstractString}" href="#XLSX.openxlsx-Tuple{Function,AbstractString}"><code>XLSX.openxlsx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">openxlsx(f::Function, filepath::AbstractString; mode::AbstractString=&quot;r&quot;, enable_cache::Bool=true)</code></pre><p>Open XLSX file for reading and/or writing. It returns an opened XLSXFile that will be automatically closed after applying <code>f</code> to the file.</p><p><strong><code>Do</code> syntax</strong></p><p>This function should be used with <code>do</code> syntax, like in:</p><pre><code class="language-julia">XLSX.openxlsx(&quot;myfile.xlsx&quot;) do xf
    # read data from `xf`
end</code></pre><p><strong>Filemodes</strong></p><p>The <code>mode</code> argument controls how the file is opened. The following modes are allowed:</p><ul><li><p><code>r</code> : read mode. The existing data in <code>filepath</code> will be accessible for reading. This is the <strong>default</strong> mode.</p></li><li><p><code>w</code> : write mode. Opens an empty file that will be written to <code>filepath</code>.</p></li><li><p><code>rw</code> : edit mode. Opens <code>filepath</code> for editing. The file will be saved to disk when the function ends.</p></li></ul><p><strong>Arguments</strong></p><ul><li><p><code>filepath</code> is the complete path to the file.</p></li><li><p><code>mode</code> is the file mode, as explained in the last section.</p></li><li><p><code>enable_cache</code>:</p></li></ul><p>If <code>enable_cache=true</code>, all read worksheet cells will be cached. If you read a worksheet cell twice it will use the cached value instead of reading from disk in the second time.</p><p>If <code>enable_cache=false</code>, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn&#39;t fit into memory.</p><p>The default value is <code>enable_cache=true</code>.</p><p><strong>Examples</strong></p><p><strong>Read from file</strong></p><p>The following example shows how you would read worksheet cells, one row at a time, where <code>myfile.xlsx</code> is a spreadsheet that doesn&#39;t fit into memory.</p><pre><code class="language-julia">julia&gt; XLSX.openxlsx(&quot;myfile.xlsx&quot;, enable_cache=false) do xf
          for r in XLSX.eachrow(xf[&quot;mysheet&quot;])
              # read something from row `r`
          end
       end</code></pre><p><strong>Write a new file</strong></p><pre><code class="language-julia">XLSX.openxlsx(&quot;new.xlsx&quot;, mode=&quot;w&quot;) do xf
    sheet = xf[1]
    sheet[1, :] = [1, Date(2018, 1, 1), &quot;test&quot;]
end</code></pre><p><strong>Edit an existing file</strong></p><pre><code class="language-julia">XLSX.openxlsx(&quot;edit.xlsx&quot;, mode=&quot;rw&quot;) do xf
    sheet = xf[1]
    sheet[2, :] = [2, Date(2019, 1, 1), &quot;add new line&quot;]
end</code></pre><p>See also <code>readxlsx</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.parse_file_mode-Tuple{AbstractString}" href="#XLSX.parse_file_mode-Tuple{AbstractString}"><code>XLSX.parse_file_mode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Parses filemode string to the tuple (read, write). See <code>openxlsx</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.parse_relationships!-Tuple{XLSX.XLSXFile}" href="#XLSX.parse_relationships!-Tuple{XLSX.XLSXFile}"><code>XLSX.parse_relationships!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Parses package level relationships defined in <code>_rels/.rels</code>. Prases workbook level relationships defined in <code>xl/_rels/workbook.xml.rels</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.parse_workbook!-Tuple{XLSX.XLSXFile}" href="#XLSX.parse_workbook!-Tuple{XLSX.XLSXFile}"><code>XLSX.parse_workbook!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>parse_workbook!(xf::XLSXFile)</p><p>Updates xf.workbook from xf.data[&quot;xl/workbook.xml&quot;]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.readtable-Tuple{AbstractString,Union{Int64, AbstractString}}" href="#XLSX.readtable-Tuple{AbstractString,Union{Int64, AbstractString}}"><code>XLSX.readtable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readtable(filepath, sheet, [columns]; [first_row], [column_labels], [header], [infer_eltypes], [stop_in_empty_row], [stop_in_row_function]) -&gt; data, column_labels</code></pre><p>Returns tabular data from a spreadsheet as a tuple <code>(data, column_labels)</code>. <code>data</code> is a vector of columns. <code>column_labels</code> is a vector of symbols. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells.</p><p>Use <code>first_row</code> to indicate the first row from the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> as a vector of symbols to specify names for the header of the table.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=false</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="language-none">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Rows where all column values are equal to <code>missing</code> are dropped.</p><p>Example code for <code>readtable</code>:</p><pre><code class="language-julia">julia&gt; using DataFrames, XLSX

julia&gt; df = DataFrame(XLSX.readtable(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;)...)

See also: `gettable`.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.readxlsx-Tuple{AbstractString}" href="#XLSX.readxlsx-Tuple{AbstractString}"><code>XLSX.readxlsx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readxlsx(filepath) :: XLSXFile</code></pre><p>Main function for reading an Excel file. This function will read the whole Excel file into memory and return a closed XLSXFile.</p><p>Consider using <code>openxlsx</code> for lazy loading of Excel file contents.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.relative_cell_position-Tuple{XLSX.CellRef,XLSX.CellRange}" href="#XLSX.relative_cell_position-Tuple{XLSX.CellRef,XLSX.CellRange}"><code>XLSX.relative_cell_position</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns (row, column) representing a <code>ref</code> position relative to <code>rng</code>.</p><p>For example, for a range &quot;B2:D4&quot;, we have:</p><ul><li><p>&quot;C3&quot; relative position is (2, 2)</p></li><li><p>&quot;B2&quot; relative position is (1, 1)</p></li><li><p>&quot;C4&quot; relative position is (3, 2)</p></li><li><p>&quot;D4&quot; relative position is (3, 3)</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.row_number-Tuple{XLSX.CellRef}" href="#XLSX.row_number-Tuple{XLSX.CellRef}"><code>XLSX.row_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">row_number(c::CellRef) :: Int</code></pre><p>Returns the row number of a given cell reference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.sheet_column_numbers-Tuple{XLSX.Index}" href="#XLSX.sheet_column_numbers-Tuple{XLSX.Index}"><code>XLSX.sheet_column_numbers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns real sheet column numbers (based on cellref)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.sheetcount-Tuple{XLSX.Workbook}" href="#XLSX.sheetcount-Tuple{XLSX.Workbook}"><code>XLSX.sheetcount</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Counts the number of sheets in the Workbook.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.sheetnames-Tuple{XLSX.Workbook}" href="#XLSX.sheetnames-Tuple{XLSX.Workbook}"><code>XLSX.sheetnames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Lists Worksheet names for this Workbook.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.split_cellname-Tuple{AbstractString}" href="#XLSX.split_cellname-Tuple{AbstractString}"><code>XLSX.split_cellname</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">split_cellname(n::AbstractString) -&gt; column_name, row_number</code></pre><p>Splits a string representing a cell name to its column name and row number.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; XLSX.split_cellname(&quot;AB:12&quot;)
(&quot;AB:&quot;, 12)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.split_cellrange-Tuple{AbstractString}" href="#XLSX.split_cellrange-Tuple{AbstractString}"><code>XLSX.split_cellrange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">split_cellrange(n::AbstractString) -&gt; start_name, stop_name</code></pre><p>Splits a string representing a cell range into its cell names.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; XLSX.split_cellrange(&quot;AB12:CD24&quot;)
(&quot;AB12&quot;, &quot;CD24&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.split_column_range-Tuple{AbstractString}" href="#XLSX.split_column_range-Tuple{AbstractString}"><code>XLSX.split_column_range</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns tuple (column<em>name</em>start, column<em>name</em>stop).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.sst_formatted_string-Tuple{XLSX.Workbook,Int64}" href="#XLSX.sst_formatted_string-Tuple{XLSX.Workbook,Int64}"><code>XLSX.sst_formatted_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sst_formatted_string(wb, index) :: String</code></pre><p>Looks for a formatted string inside the Shared Strings Table (sst). <code>index</code> starts at 0.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.sst_unformatted_string-Tuple{XLSX.Workbook,Int64}" href="#XLSX.sst_unformatted_string-Tuple{XLSX.Workbook,Int64}"><code>XLSX.sst_unformatted_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sst_unformatted_string(wb, index) :: String</code></pre><p>Looks for a string inside the Shared Strings Table (sst). <code>index</code> starts at 0.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_add_font-Tuple{XLSX.Workbook,Array{Union{Pair{String,Pair{String,String}}, AbstractString},1}}" href="#XLSX.styles_add_font-Tuple{XLSX.Workbook,Array{Union{Pair{String,Pair{String,String}}, AbstractString},1}}"><code>XLSX.styles_add_font</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Defines a custom font. Returns the index to be used as the <code>fontId</code> in a cellXf definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_add_numFmt-Tuple{XLSX.Workbook,AbstractString}" href="#XLSX.styles_add_numFmt-Tuple{XLSX.Workbook,AbstractString}"><code>XLSX.styles_add_numFmt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Defines a custom number format to render numbers, dates or text. Returns the index to be used as the <code>numFmtId</code> in a cellXf definition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_cell_xf-Tuple{XLSX.Workbook,Int64}" href="#XLSX.styles_cell_xf-Tuple{XLSX.Workbook,Int64}"><code>XLSX.styles_cell_xf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the xf XML node element for style <code>index</code>. <code>index</code> is 0-based.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_cell_xf_numFmtId-Tuple{XLSX.Workbook,Int64}" href="#XLSX.styles_cell_xf_numFmtId-Tuple{XLSX.Workbook,Int64}"><code>XLSX.styles_cell_xf_numFmtId</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Queries numFmtId from cellXfs -&gt; xf nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_get_cellXf_with_numFmtId-Tuple{XLSX.Workbook,Int64}" href="#XLSX.styles_get_cellXf_with_numFmtId-Tuple{XLSX.Workbook,Int64}"><code>XLSX.styles_get_cellXf_with_numFmtId</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Cell Xf element follows the XML format below. This function queries the 0-based index of the first xf element that has the provided numFmtId. Returns -1 if not found.</p><pre><code class="language-none">&lt;styleSheet ...
    &lt;cellXfs count=&quot;5&quot;&gt;
            &lt;xf borderId=&quot;0&quot; fillId=&quot;0&quot; fontId=&quot;0&quot; numFmtId=&quot;0&quot; xfId=&quot;0&quot;/&gt;
            &lt;xf applyNumberFormat=&quot;1&quot; borderId=&quot;0&quot; fillId=&quot;0&quot; fontId=&quot;0&quot; numFmtId=&quot;14&quot; xfId=&quot;0&quot;/&gt;
            &lt;xf applyNumberFormat=&quot;1&quot; borderId=&quot;0&quot; fillId=&quot;0&quot; fontId=&quot;0&quot; numFmtId=&quot;20&quot; xfId=&quot;0&quot;/&gt;
            &lt;xf applyNumberFormat=&quot;1&quot; borderId=&quot;0&quot; fillId=&quot;0&quot; fontId=&quot;0&quot; numFmtId=&quot;22&quot; xfId=&quot;0&quot;/&gt;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.styles_numFmt_formatCode-Tuple{XLSX.Workbook,AbstractString}" href="#XLSX.styles_numFmt_formatCode-Tuple{XLSX.Workbook,AbstractString}"><code>XLSX.styles_numFmt_formatCode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Queries numFmt formatCode field by numFmtId.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.table_column_numbers-Tuple{XLSX.Index}" href="#XLSX.table_column_numbers-Tuple{XLSX.Index}"><code>XLSX.table_column_numbers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns an iterator for table column numbers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.table_column_to_sheet_column_number-Tuple{XLSX.Index,Int64}" href="#XLSX.table_column_to_sheet_column_number-Tuple{XLSX.Index,Int64}"><code>XLSX.table_column_to_sheet_column_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Maps table column index (1-based) -&gt; sheet column index (cellref based)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.unformatted_text-Tuple{EzXML.Node}" href="#XLSX.unformatted_text-Tuple{EzXML.Node}"><code>XLSX.unformatted_text</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unformatted_text(el::EzXML.Node) :: String</code></pre><p>Helper function to gather unformatted text from Excel data files. It looks at all childs of <code>el</code> for tag name <code>t</code> and returns a join of all the strings found.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.writetable-Tuple{AbstractString,Any,Any}" href="#XLSX.writetable-Tuple{AbstractString,Any,Any}"><code>XLSX.writetable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writetable(filename, data, columnnames; [overwrite], [sheetname])</code></pre><p><code>data</code> is a vector of columns. <code>columnames</code> is a vector of column labels. <code>overwrite</code> is a <code>Bool</code> to control if <code>filename</code> should be overwritten if already exists. <code>sheetname</code> is the name for the worksheet.</p><p>Example using <code>DataFrames.jl</code>:</p><pre><code class="language-julia">import DataFrames, XLSX
df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[&quot;Hey&quot;, &quot;You&quot;, &quot;Out&quot;, &quot;There&quot;], floats=[10.2, 20.3, 30.4, 40.5])
XLSX.writetable(&quot;df.xlsx&quot;, DataFrames.columns(df), DataFrames.names(df))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.writetable-Tuple{AbstractString}" href="#XLSX.writetable-Tuple{AbstractString}"><code>XLSX.writetable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writetable(filename::AbstractString; overwrite::Bool=false, kw...)
writetable(filename::AbstractString, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)</code></pre><p>Write multiple tables.</p><p><code>kw</code> is a variable keyword argument list. Each element should be in this format: <code>sheetname=( data, column_names )</code>, where <code>data</code> is a vector of columns and <code>column_names</code> is a vector of column labels.</p><p>Example:</p><pre><code class="language-julia">import DataFrames, XLSX

df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[&quot;Fist&quot;, &quot;Sec&quot;, &quot;Third&quot;])
df2 = DataFrames.DataFrame(AA=[&quot;aa&quot;, &quot;bb&quot;], AB=[10.1, 10.2])

XLSX.writetable(&quot;report.xlsx&quot;, REPORT_A=( DataFrames.columns(df1), DataFrames.names(df1) ), REPORT_B=( DataFrames.columns(df2), DataFrames.names(df2) ))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.writexlsx-Tuple{AbstractString,XLSX.XLSXFile}" href="#XLSX.writexlsx-Tuple{AbstractString,XLSX.XLSXFile}"><code>XLSX.writexlsx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">writexlsx(output_filepath, xlsx_file; [overwrite=false])</code></pre><p>Writes an Excel file given by <code>xlsx_file::XLSXFile</code> to file at path <code>output_filepath</code>.</p><p>If <code>overwrite=true</code>, <code>output_filepath</code> will be overwritten if it exists.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.xlsx_encode-Tuple{XLSX.Worksheet,AbstractString}" href="#XLSX.xlsx_encode-Tuple{XLSX.Worksheet,AbstractString}"><code>XLSX.xlsx_encode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the datatype and value for <code>val</code> to be inserted into <code>ws</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.xmldocument-Tuple{XLSX.XLSXFile,String}" href="#XLSX.xmldocument-Tuple{XLSX.XLSXFile,String}"><code>XLSX.xmldocument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">xmldocument(xl::XLSXFile, filename::String) :: EzXML.Document</code></pre><p>Utility method to find the XMLDocument associated with a given package filename. Returns xl.data[filename] if it exists. Throws an error if it doesn&#39;t.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="XLSX.xmlroot-Tuple{XLSX.XLSXFile,String}" href="#XLSX.xmlroot-Tuple{XLSX.XLSXFile,String}"><code>XLSX.xmlroot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">xmlroot(xl::XLSXFile, filename::String) :: EzXML.Node</code></pre><p>Utility method to return the root element of a given XMLDocument from the package. Returns EzXML.root(xl.data[filename]) if it exists.</p></div></div></section><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a></footer></article></body></html>
