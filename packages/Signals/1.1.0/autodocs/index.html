<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Signals.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Signals.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Signals.DropRepeats</code></pre><pre><code class="language-none">Signals.Filter</code></pre><pre><code class="language-none">Signals.Merge</code></pre><pre><code class="language-none">Signals.PullAction</code></pre><pre><code class="language-none">Signals.PullType</code></pre><pre><code class="language-none">Signals.RecursionFree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.Signal" href="#Signals.Signal"><code>Signals.Signal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">S = Signal(val; strict_push = false)</code></pre><p>Create a source <code>Signal</code> with initial value <code>val</code>, setting <code>strict_push</code> to <code>true</code> guarantees that every push to this <code>Signal</code> will be carried out independently. Otherwise if updates occur faster than what the <code>eventloop</code> can process, then only the last value before the <code>eventloop</code> kicks in will be used(<em>default</em>).</p><pre><code class="language-none">S = Signal(f,args...; v0 = nothing)</code></pre><p>Create a derived <code>Signal</code> whos value is <code>f(args...)</code>, args can be of any type, <code>Signal</code> args get replaced by their value before calling <code>f(args...)</code>. reads best with with <code>do</code> notation(see example).if <code>v0</code> is not <code>nothing</code> then <code>f(args...)</code> will not be called directly after Signal creation instead the Signal will be initialized to have value v0.</p><p><strong>Syntax</strong></p><pre><code class="language-none">S[] = val</code></pre><p>Set the value of <code>S</code> to <code>val</code> without propogating the change to the rest of the signal graph, usefull in pull based paradigm.</p><pre><code class="language-none">S()</code></pre><p><code>pull!</code> Signal, pulling any changes in the Signal graph that affects <code>S</code>.</p><pre><code class="language-none">S(val)</code></pre><p>Set the value of <code>S</code> to <code>val</code> and pushes the changes along the Signal graph.</p><pre><code class="language-none">S[]</code></pre><p>Get the current value stored in <code>S</code> without pulling changes from the graph.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; A = Signal(1) # source Signal
Signal
value: 1

julia&gt; B = 2 # non-Signal input
2

julia&gt; C = Signal(A, B) do a, b # derived Signal
           a + b
       end

Signal
value: 3

julia&gt; A[] = 10 # set value without propogation
10
julia&gt; C[] # reads current value
3
julia&gt; C() # pull latest changes from the Signal graph
12
julia&gt; A(100) # set value to a signal and propogate this change
100
julia&gt; C[]
102</code></pre></div></div></section><pre><code class="language-none">Signals.SignalData</code></pre><pre><code class="language-none">Signals.SignalException</code></pre><pre><code class="language-none">Signals.Signals</code></pre><pre><code class="language-none">Signals.StandardPull</code></pre><pre><code class="language-none">Signals.Stateless</code></pre><pre><code class="language-none">Signals.Throttle</code></pre><pre><code class="language-none">Signals.TypedSignal</code></pre><pre><code class="language-none">Signals.When</code></pre><pre><code class="language-none">Signals.__init__</code></pre><pre><code class="language-none">Signals._async_mode</code></pre><pre><code class="language-none">Signals._debug_mode</code></pre><pre><code class="language-none">Signals.action</code></pre><pre><code class="language-none">Signals.activate_timer</code></pre><pre><code class="language-none">Signals.add_child!</code></pre><pre><code class="language-none">Signals.async_mode</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.async_signal" href="#Signals.async_signal"><code>Signals.async_signal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = async_signal(f, args...; init = nothing)</code></pre><p>Create a signal initialized to <code>init</code> whos action <code>f(args...)</code> will run asynchronously in a different task whenever its arguments update.async signals only work in a push based paradigm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.bind!" href="#Signals.bind!"><code>Signals.bind!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bind!(dest::Signal, src::Signal)</code></pre><p>For every update to <code>src</code> also update <code>dest</code> with the same value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.buffer" href="#Signals.buffer"><code>Signals.buffer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = buffer(input; buf_size = Inf, timespan = 1, type_stable = false)</code></pre><p>Create a signal who buffers updates to signal <code>input</code> until maximum size of <code>buf_size</code> or until <code>timespan</code> seconds have passed. The signal value is the last full buffer emitted or an empty vector if the buffer have never been filled before.</p><p>Buffer type will be <code>Any</code> unless <code>type_stable</code> is set to <code>true</code>, then it will be set to the value of the first encountered item.</p></div></div></section><pre><code class="language-none">Signals.call_no_inline</code></pre><pre><code class="language-none">Signals.clean_stacktrace</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.count" href="#Base.count"><code>Base.count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count_signal(s::Signal)</code></pre><p>Create a <code>Signal</code> that counts updates to input <code>Signal</code> <code>s</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.debounce" href="#Signals.debounce"><code>Signals.debounce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">debounce(f, args...; delay = 1, v0 = nothing)</code></pre><p>Create a <code>Signal</code> whos action <code>f(args...)</code> will be called only after <code>delay</code> seconds have passed since the last time its <code>args</code> were updated. Only works in push based paradigm. If <code>v0</code> is not specified then the initial value is <code>f(args...)</code>.</p></div></div></section><pre><code class="language-none">Signals.debug_mode</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.droprepeats" href="#Signals.droprepeats"><code>Signals.droprepeats</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">droprepeats(input)</code></pre><p>Drop updates to <code>input</code> whenever the new value is the same as the previous value of the signal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.echo" href="#Signals.echo"><code>Signals.echo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">echo(s::Signal,name = &quot;&quot;)</code></pre><p>echos the value of signal <code>s</code> on each update, you can specify a <code>name</code> to distinguish between different echos</p></div></div></section><pre><code class="language-none">Signals.empty_queues</code></pre><pre><code class="language-none">Signals.eval</code></pre><pre><code class="language-none">Signals.eventloop</code></pre><pre><code class="language-none">Signals.eventloop_cond</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.every" href="#Signals.every"><code>Signals.every</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = every(dt; duration = Inf)</code></pre><p>A signal that updates every <code>dt</code> seconds to the current timestamp, for <code>duration</code> seconds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.foldp" href="#Signals.foldp"><code>Signals.foldp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>fold over past values</p><pre><code class="language-none">foldp(op, v0 ,sig)</code></pre><p>reduce the given signal <code>sig</code> with the given binary operator <code>op</code>.  the value of the signal just after creation is <code>op(v0,sig[])</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.for_signal" href="#Signals.for_signal"><code>Signals.for_signal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> s = for_signal(f::Function, range, args...; fps = 1)</code></pre><p>Create a <code>Signal</code> that updates to <code>f(i,args....) for i in range</code> every <code>1/fps</code> seconds. <code>range</code> and <code>args</code> can be of type <code>Signal</code> or any other type. The loop starts whenever one of the arguments updates. If the previous for loop did not complete it gets cancelled.</p><p><strong>Example</strong></p><pre><code class="language-none">rng = Signal(1:5)
A = Signal(2)
B = for_signal(rng,A;fps = 30) do i,a
    println(a^i)
end;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.fps" href="#Signals.fps"><code>Signals.fps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = fps(freq; duration = Inf)</code></pre><p>A signal that updates <code>freq</code> times a second to the current timestamp, for <code>duration</code> seconds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.fpswhen" href="#Signals.fpswhen"><code>Signals.fpswhen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = fpswhen(switch::Signal, freq; duration = Inf)</code></pre><p>A signal that updates &#39;freq&#39; times a second to the current timestamp, for <code>duration</code> seconds if and only if the value of <code>switch</code> is <code>true</code>.</p></div></div></section><pre><code class="language-none">Signals.handle_err</code></pre><pre><code class="language-none">Signals.include</code></pre><pre><code class="language-none">Signals.invalidate!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.previous" href="#Signals.previous"><code>Signals.previous</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">previous(s::Signal)</code></pre><p>Create a <code>Signal</code> that holds previous input to <code>s</code></p></div></div></section><pre><code class="language-none">Signals.propagated</code></pre><pre><code class="language-none">Signals.propogate!</code></pre><pre><code class="language-none">Signals.pull!</code></pre><pre><code class="language-none">Signals.pull_args</code></pre><pre><code class="language-none">Signals.pull_enqueue</code></pre><pre><code class="language-none">Signals.pull_queue</code></pre><pre><code class="language-none">Signals.push_queue</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.recursion_free" href="#Signals.recursion_free"><code>Signals.recursion_free</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recursion_free(f::Function,args...)</code></pre><p>creates a <code>Signal</code> whos action <code>f(args...)</code> is protected against infinite loop recursion.</p><pre><code class="language-none">julia&gt; A = Signal(1)
julia&gt; B = recursion_free(A) do a
            A(a+1)
       end

julia&gt; A(10)
10
julia&gt; A[]
11</code></pre><p>In the example above ,if <code>recursion_free</code> were to be subsituted with regular <code>Signal</code> it would result in an infinite loop in the non-async mode <code>recursion_free</code> protects against that</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.remote_signal" href="#Signals.remote_signal"><code>Signals.remote_signal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">s = remote_signal(f, args...; init = nothing, procid = first(workers()))</code></pre><p>Create a signal initialized to <code>init</code> whos action <code>f(args...)</code> will run remotely in a process with id <code>procid</code>, whenever its arguments update.remote signals only work in a push based paradigm.</p></div></div></section><pre><code class="language-none">Signals.run_till_now</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.sampleon" href="#Signals.sampleon"><code>Signals.sampleon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sampleon(A, B)</code></pre><p>Sample the value of <code>B</code> whenever <code>A</code> updates.</p></div></div></section><pre><code class="language-none">Signals.set_value!</code></pre><pre><code class="language-none">Signals.soft_push!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.state" href="#Signals.state"><code>Signals.state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Retrieve the internal state of a <code>Signal</code></p></div></div></section><pre><code class="language-none">Signals.store!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.strict_push!" href="#Signals.strict_push!"><code>Signals.strict_push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strict_push!(s::Signal, val, async = Signals.async_mode())</code></pre><p>Set <code>s</code> to <code>val</code> and propagate into derived signals, is <code>async</code> is <code>true</code>(default) then updates to derived signals will occur asynchronically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.throttle" href="#Signals.throttle"><code>Signals.throttle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">throttle(f::Function, args...; maxfps = 0.03)</code></pre><p>Create a throttled <code>Signal</code> whos action <code>f(args...)</code> will be called only if <code>1/maxfps</code> time has passed since the last time it updated. The resulting <code>Signal</code> will be updated maximum of <code>maxfps</code> times per second.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.unbind!" href="#Signals.unbind!"><code>Signals.unbind!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unbind!(dst::Signal,src::Signal)</code></pre><p>Remove bindings from <code>src</code> to <code>dst</code> that were previously created using <code>bind</code>.</p><pre><code class="language-none">unbind!(dst::Signal)</code></pre><p>Remove all bindings that were previously created using <code>bind</code> that will cause <code>dst</code> to update.</p></div></div></section><pre><code class="language-none">Signals.valid</code></pre><pre><code class="language-none">Signals.valid_args</code></pre><pre><code class="language-none">Signals.validate</code></pre><pre><code class="language-none">Signals.value</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Signals.when" href="#Signals.when"><code>Signals.when</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">when(f, condition::Signal, args...; v0 = nothing)</code></pre><p>Create a <code>Signal</code> that will update to <code>f(args...)</code> when any of its input <code>args</code> updates <em>only if</em> <code>condition</code> has value <code>true</code>. If <code>condition != true</code> in the time of creation the signal will be initialized to value <code>v0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; A = Signal(1)
julia&gt; condition = Signal(A) do a
           a&lt;10
       end
julia&gt; B = when(condition,A) do a
       println(&quot;$a is smaller than 10&quot;)
   end
julia&gt; A(1)
1 is smaller than 10
1

julia&gt; A(12)
12</code></pre></div></div></section><pre><code class="language-none">Signals.world_age</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
