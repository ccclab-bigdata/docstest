<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· ArnoldiMethod.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ArnoldiMethod.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#What-algorithm-is-ArnoldiMethod.jl?-1">What algorithm is ArnoldiMethod.jl?</a></li><li><a class="toctext" href="#What-problems-does-this-package-solve-specifically?-1">What problems does this package solve specifically?</a></li><li><a class="toctext" href="#Goal-of-this-package:-a-pure-Julia-implementation-1">Goal of this package: a pure Julia implementation</a></li><li><a class="toctext" href="#Status-1">Status</a></li></ul></li><li><a class="toctext" href="theory/">Theory</a></li><li><span class="toctext">Using ArnoldiMethod.jl</span><ul><li><a class="toctext" href="usage/01_getting_started/">Getting started</a></li><li><a class="toctext" href="usage/02_spectral_transformations/">Transformations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ArnoldiMethod.jl-1" href="#ArnoldiMethod.jl-1">ArnoldiMethod.jl</a></h1><p>ArnoldiMethod.jl provides an iterative method to find a few approximate  solutions to the eigenvalue problem in <em>standard form</em>:</p><div>\[Ax = x\lambda,\]</div><p>where <span>$A$</span> is a general matrix of size <span>$n \times n$</span>; and <span>$x \in \mathbb{C}^n$</span> and <span>$\lambda \in \mathbb{C}$</span> are eigenvectors and eigenvalues respectively. By  <em>general matrix</em> we mean that <span>$A$</span> has no special structure. It can be symmetric or non-symmetric and either real or complex.</p><p>The method is <em>matrix-free</em>, meaning that it only requires multiplication with  the matrix <span>$A$</span>.</p><p>The package exports just two functions:</p><ul><li><a href="usage/01_getting_started/#ArnoldiMethod.partialschur"><code>partialschur</code></a> to compute a stable basis for an eigenspace;</li><li><a href="usage/01_getting_started/#ArnoldiMethod.partialeigen"><code>partialeigen</code></a> to compute an eigendecomposition from a partial Schur decomposition.</li></ul><p>See <strong><a href="usage/01_getting_started/#getting_started-1">Using ArnoldiMethod.jl</a></strong>  on how to use these  functions.</p><h2><a class="nav-anchor" id="What-algorithm-is-ArnoldiMethod.jl?-1" href="#What-algorithm-is-ArnoldiMethod.jl?-1">What algorithm is ArnoldiMethod.jl?</a></h2><p>The underlying algorithm is the restarted Arnoldi method, which be viewed as a mix between a subspace accelerated version of the power method and a truncated  version of the dense QR algorithm.</p><p>Initially the method was based on the <em>Implicitly Restarted Arnoldi Method</em> (or IRAM for short), which is the algorithm implemented by ARPACK. This method has a very elegant restarting scheme based on exact QR iterations, but is  unfortunately susceptible to forward instabilities of the QR algorithm.</p><p>For this reason the <em>Krylov-Schur</em> method is currently embraced in this package, which is mathematically equivalent to IRAM, but has better stability by  replacing exact QR iterations with a direct method that reorders the Schur form. In fact we see Krylov-Schur just as an implementation detail of the Arnoldi  method.</p><h2><a class="nav-anchor" id="What-problems-does-this-package-solve-specifically?-1" href="#What-problems-does-this-package-solve-specifically?-1">What problems does this package solve specifically?</a></h2><p>By design the Arnoldi method is best at finding eigenvalues on the boundary of the convex hull of eigenvalues. For instance eigenvalues of largest modulus and largest or smallest real part. In the case of complex matrices one can target eigenvalues of largest and smallest imaginary part as well.</p><p>The scope is much broader though, since there is a whole zoo of spectral  transformations possible to find for instance interior eigenvalues or  eigenvalues closest to the imaginary axis.</p><p>Further, one can solve generalized eigenvalue problems <span>$Ax = Bx \lambda$</span> by applying a suitable spectral transformation as well. Also quadratic eigenvalue  problems can be casted to standard form.</p><p>See <a href="theory/#theory-1">Theory</a> for more information.</p><h2><a class="nav-anchor" id="Goal-of-this-package:-a-pure-Julia-implementation-1" href="#Goal-of-this-package:-a-pure-Julia-implementation-1">Goal of this package: a pure Julia implementation</a></h2><p>This project started with two goals:</p><ul><li>Having a <em>native</em> Julia implementation of the <code>eigs</code> function that performs as well as ARPACK. With native we mean that its implementation should be generic and support any number type. Currently the <a href="usage/01_getting_started/#ArnoldiMethod.partialschur"><code>partialschur</code></a> function  does not depend on LAPACK, and removing the last remnants of direct calls to  BLAS is in the pipeline.</li><li>Removing the dependency of the Julia language on ARPACK. This goal was already achieved before the package was stable enough, since ARPACK moved to a  separate repository  <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl/">Arpack.jl</a>.</li></ul><h2><a class="nav-anchor" id="Status-1" href="#Status-1">Status</a></h2><p>An overview of what we have, how it&#39;s done and what we&#39;re missing.</p><h3><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h3><ul><li>The method does not make assumptions about the type of the matrix; it is  matrix-free.</li><li>Converged Ritz vectors are locked (or deflated).</li><li>Important matrices and vectors are pre-allocated and operations on the  Hessenberg matrix are in-place; Julia&#39;s garbage collector can sit back.</li><li>Krylov basis vectors are orthogonalized with repeated classical Gram-Schmidt to ensure they are orthogonal up to machine precision; this is a BLAS-2 operation.</li><li>To compute the Schur decomposition of the Hessenberg matrix we use a dense  QR algorithm written natively in Julia. It is based on implicit (or Francis)  shifts and handles real arithmetic efficiently.</li><li>Locking and purging of Ritz vectors is done by reordering the Schur form,  which is also implemented natively in Julia. In the real case it is done by casting tiny Sylvester equations to linear systems and solving them with  complete pivoting.</li><li>Shrinking the size of the Krylov subspace and changing its basis is done by accumulating all rotations and reflections in a unitary matrix <code>Q</code>, and then simply computing the matrix-matrix product <code>V := V * Q</code>, where <code>V</code> is the  original orthonormal basis. This is not in-place in <code>V</code>, but with good reason:  the dense matrix-matrix product is not memory-bound.</li></ul><h3><a class="nav-anchor" id="Not-implemented-(yet)-and-future-ideas-1" href="#Not-implemented-(yet)-and-future-ideas-1">Not implemented (yet) and future ideas</a></h3><ul><li>Being able to kickstart the method from a given Arnoldi relation. This also captures:<ol><li>Making an initial guess by providing a known approximate eigenvector;</li><li>Deflating some subspace by starting the Arnoldi method with a given partial Schur decomposition.</li></ol></li><li>Matrix-induced inner product for generalized eigenvalue problems.</li><li>Efficient implementation of symmetric problems with Lanczos.</li></ul><p>On my wish list is to allow custom vector or matrix types, so that we can  delegate expensive but trivial work to hardware that can do it faster  (distributed memory / GPU). The basic concept would be: </p><ol><li>The core Arnoldi method performs tedious linear algebra on the projected,  low-dimensional problem, but finally just outputs a change of basis in the form of a unitary matrix Q.</li><li>Appropriate hardware does the change of basis <code>V := V * Q</code>.</li></ol><p>Similar things should happen for expansion of the subspace and  orthogonalization.</p><footer><hr/><a class="next" href="theory/"><span class="direction">Next</span><span class="title">Theory</span></a></footer></article></body></html>
