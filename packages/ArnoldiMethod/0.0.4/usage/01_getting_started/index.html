<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · ArnoldiMethod.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ArnoldiMethod.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../theory/">Theory</a></li><li><span class="toctext">Using ArnoldiMethod.jl</span><ul><li class="current"><a class="toctext" href>Getting started</a><ul class="internal"><li><a class="toctext" href="#Installing-1">Installing</a></li><li><a class="toctext" href="#Construct-a-partial-Schur-decomposition-1">Construct a partial Schur decomposition</a></li><li><a class="toctext" href="#From-a-Schur-decomposition-to-an-eigendecomposition-1">From a Schur decomposition to an eigendecomposition</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#The-PartialSchur-and-History-structs-1">The PartialSchur and History structs</a></li></ul></li><li><a class="toctext" href="../02_spectral_transformations/">Transformations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Using ArnoldiMethod.jl</li><li><a href>Getting started</a></li></ul></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="getting_started-1" href="#getting_started-1">Getting started</a></h1><h2><a class="nav-anchor" id="Installing-1" href="#Installing-1">Installing</a></h2><p>In Julia open the package manager in the REPL via <code>]</code> and run:</p><pre><code class="language-julia">(v1.0) pkg&gt; add ArnoldiMethod</code></pre><p>Then use the package.</p><pre><code class="language-julia">using ArnoldiMethod</code></pre><h2><a class="nav-anchor" id="Construct-a-partial-Schur-decomposition-1" href="#Construct-a-partial-Schur-decomposition-1">Construct a partial Schur decomposition</a></h2><p>ArnoldiMethod.jl exports the <code>partialschur</code> function which can be used to  obtain a partial Schur decomposition of any matrix <code>A</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArnoldiMethod.partialschur" href="#ArnoldiMethod.partialschur"><code>ArnoldiMethod.partialschur</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">partialschur(A; nev, which, tol, mindim, maxdim, restarts) → PartialSchur, History</code></pre><p>Find <code>nev</code> approximate eigenpairs of <code>A</code> with eigenvalues near a specified target.</p><p>The matrix <code>A</code> can be any linear map that implements <code>mul!(y, A, x)</code>, <code>eltype</code> and <code>size</code>.</p><p>The method will run iteratively until the eigenpairs are approximated to the prescribed tolerance or until <code>restarts</code> restarts have passed.</p><p><strong>Arguments</strong></p><p>The most important keyword arguments:</p><table><tr><th>Keyword</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td><code>nev</code></td><td><code>Int</code></td><td><code>min(6, size(A, 1))</code></td><td>Number of eigenvalues</td></tr><tr><td><code>which</code></td><td><code>Target</code></td><td><code>LM()</code></td><td>One of <code>LM()</code>, <code>LR()</code>, <code>SR()</code>, <code>LI()</code>, <code>SI()</code>, see below.</td></tr><tr><td><code>tol</code></td><td><code>Real</code></td><td><code>√eps</code></td><td>Tolerance for convergence: ‖Ax - xλ‖₂ &lt; tol * ‖λ‖</td></tr></table><p>The target <code>which</code> can be any of <code>subtypes(ArnoldiMethod.Target)</code>:</p><table><tr><th>Target</th><th>Description</th></tr><tr><td><code>LM()</code></td><td>Largest magnitude: <code>abs(λ)</code> is largest</td></tr><tr><td><code>LR()</code></td><td>Largest real part: <code>real(λ)</code> is largest</td></tr><tr><td><code>SR()</code></td><td>Smallest real part: <code>real(λ)</code> is smallest</td></tr><tr><td><code>LI()</code></td><td>Largest imaginary part: <code>imag(λ)</code> is largest</td></tr><tr><td><code>SI()</code></td><td>Smallest imaginary part: <code>imag(λ)</code> is smallest</td></tr></table><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The targets <code>LI()</code> and <code>SI()</code> only make sense in complex arithmetic. In real arithmetic <code>λ</code> is an eigenvalue iff <code>conj(λ)</code> is an eigenvalue and this  conjugate pair converges simultaneously.</p></div></div><p><strong>Return values</strong></p><p>The function returns a tuple</p><pre><code class="language-julia">decomp, history = partialschur(A, ...)</code></pre><p>where <code>decomp</code> is a <a href="#ArnoldiMethod.PartialSchur"><code>PartialSchur</code></a> struct which  forms a partial Schur decomposition of <code>A</code> to a prescribed tolerance:</p><pre><code class="language-julia">&gt; norm(A * decomp.Q - decomp.Q * decomp.R)</code></pre><p><code>history</code> is a <a href="#ArnoldiMethod.History"><code>History</code></a> struct that holds some basic information about convergence of the method:</p><pre><code class="language-julia">&gt; history.converged
true
&gt; @show history
Converged after 359 matrix-vector products</code></pre><p><strong>Advanced usage</strong></p><p>Further there are advanced keyword arguments for tuning the algorithm:</p><table><tr><th>Keyword</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td><code>mindim</code></td><td><code>Int</code></td><td><code>min(max(10, nev), size(A,1))</code></td><td>Minimum Krylov dimension (≥ nev)</td></tr><tr><td><code>maxdim</code></td><td><code>Int</code></td><td><code>min(max(20, 2nev), size(A,1))</code></td><td>Maximum Krylov dimension (≥ min)</td></tr><tr><td><code>restarts</code></td><td><code>Int</code></td><td><code>200</code></td><td>Maximum number of restarts</td></tr></table><p>When the algorithm does not converge, one can increase <code>restarts</code>. When the  algorithm converges too slowly, one can play with <code>mindim</code> and <code>maxdim</code>. It is  suggested to keep <code>mindim</code> equal to or slightly larger than <code>nev</code>, and <code>maxdim</code> is usually about two times <code>mindim</code>.</p></div></div></section><h2><a class="nav-anchor" id="From-a-Schur-decomposition-to-an-eigendecomposition-1" href="#From-a-Schur-decomposition-to-an-eigendecomposition-1">From a Schur decomposition to an eigendecomposition</a></h2><p>The eigenvalues and eigenvectors are obtained from the Schur form with the  <code>partialeigen</code> function that is exported by ArnoldiMethod.jl:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArnoldiMethod.partialeigen" href="#ArnoldiMethod.partialeigen"><code>ArnoldiMethod.partialeigen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">partialeigen(P::PartialSchur) → (Vector{&lt;:Union{Real,Complex}}, Matrix{&lt;:Union{Real,Complex}})</code></pre><p>Transforms a partial Schur decomposition into an eigendecomposition.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For real-symmetric and Hermitian matrices the Schur vectors coincide with  the eigenvectors, and hence it is not necessary to call this function in  that case.</p></div></div><p>The method still relies on LAPACK to compute the eigenvectors of the (quasi) upper triangular matrix <code>R</code> from the partial Schur decomposition.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method is currently type unstable for real matrices, since we have not yet decided how to deal with complex conjugate pairs of eigenvalues. E.g. if almost all eigenvalues are real, but there are just a few conjugate  pairs, should all eigenvectors be complex-valued?</p></div></div></div></div></section><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Here we compute the first ten eigenvalues and eigenvectors of a tridiagonal sparse matrix.</p><pre><code class="language-julia">julia&gt; using ArnoldiMethod, LinearAlgebra, SparseArrays
julia&gt; A = spdiagm(
           -1 =&gt; fill(-1.0, 99),
            0 =&gt; fill(2.0, 100), 
            1 =&gt; fill(-1.0, 99)
       );
julia&gt; decomp, history = partialschur(A, nev=10, tol=1e-6, which=SR());
julia&gt; decomp
PartialSchur decomposition (Float64) of dimension 10
eigenvalues:
10-element Array{Complex{Float64},1}:
 0.0009674354160236865 + 0.0im
  0.003868805732811139 + 0.0im
  0.008701304061962657 + 0.0im
   0.01546025527344699 + 0.0im
  0.024139120518486677 + 0.0im
    0.0347295035554728 + 0.0im
   0.04722115887278571 + 0.0im
   0.06160200160067088 + 0.0im
    0.0778581192025522 + 0.0im
   0.09597378493453936 + 0.0im
julia&gt; history
Converged: 10 of 10 eigenvalues in 174 matrix-vector products
julia&gt; norm(A * decomp.Q - decomp.Q * decomp.R)
6.39386920955869e-8
julia&gt; λs, X = partialeigen(decomp);
julia&gt; norm(A * X - X * Diagonal(λs))
6.393869211477937e-8</code></pre><h2><a class="nav-anchor" id="The-PartialSchur-and-History-structs-1" href="#The-PartialSchur-and-History-structs-1">The PartialSchur and History structs</a></h2><p>For completeness, the return values of the <a href="#ArnoldiMethod.partialschur"><code>partialschur</code></a> function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArnoldiMethod.PartialSchur" href="#ArnoldiMethod.PartialSchur"><code>ArnoldiMethod.PartialSchur</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PartialSchur(Q, R, eigenvalues)</code></pre><p>Holds an orthonormal basis <code>Q</code> and a (quasi) upper triangular matrix <code>R</code>.</p><p>For convenience the eigenvalues that appear on the diagonal of <code>R</code> are also  listed as <code>eigenvalues</code>, which is in particular useful in the case of real  matrices with complex eigenvalues. Note that the eigenvalues are always a  complex, even when the matrix <code>R</code> is real.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArnoldiMethod.History" href="#ArnoldiMethod.History"><code>ArnoldiMethod.History</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">History(mvproducts, nconverged, converged, nev)</code></pre><p>History shows whether the method has converged (when <code>nconverged</code> ≥ <code>nev</code>) and how many matrix-vector products were necessary to do so.</p></div></div></section><footer><hr/><a class="previous" href="../../theory/"><span class="direction">Previous</span><span class="title">Theory</span></a><a class="next" href="../02_spectral_transformations/"><span class="direction">Next</span><span class="title">Transformations</span></a></footer></article></body></html>
