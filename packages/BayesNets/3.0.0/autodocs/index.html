<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BayesNets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BayesNets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">BayesNets.+</code></pre><pre><code class="language-none">BayesNets.-</code></pre><pre><code class="language-none">BayesNets.@csv2_str</code></pre><pre><code class="language-none">BayesNets.@csv_str</code></pre><pre><code class="language-none">BayesNets.@pack_GibbsSamplingFull</code></pre><pre><code class="language-none">BayesNets.@pack_GibbsSamplingFull!</code></pre><pre><code class="language-none">BayesNets.@pack_GibbsSamplingNodewise</code></pre><pre><code class="language-none">BayesNets.@pack_GibbsSamplingNodewise!</code></pre><pre><code class="language-none">BayesNets.@pack_LikelihoodWeightingInference</code></pre><pre><code class="language-none">BayesNets.@pack_LikelihoodWeightingInference!</code></pre><pre><code class="language-none">BayesNets.@pack_LoopyBelief</code></pre><pre><code class="language-none">BayesNets.@pack_LoopyBelief!</code></pre><pre><code class="language-none">BayesNets.@tsv_str</code></pre><pre><code class="language-none">BayesNets.@unpack_GibbsSamplingFull</code></pre><pre><code class="language-none">BayesNets.@unpack_GibbsSamplingNodewise</code></pre><pre><code class="language-none">BayesNets.@unpack_LikelihoodWeightingInference</code></pre><pre><code class="language-none">BayesNets.@unpack_LoopyBelief</code></pre><pre><code class="language-none">BayesNets.@wsv_str</code></pre><pre><code class="language-none">BayesNets.AbstractCategoricalArray</code></pre><pre><code class="language-none">BayesNets.AbstractCategoricalMatrix</code></pre><pre><code class="language-none">BayesNets.AbstractCategoricalVector</code></pre><pre><code class="language-none">BayesNets.AbstractDataFrame</code></pre><pre><code class="language-none">BayesNets.AbstractMissingCategoricalArray</code></pre><pre><code class="language-none">BayesNets.AbstractMissingCategoricalMatrix</code></pre><pre><code class="language-none">BayesNets.AbstractMissingCategoricalVector</code></pre><pre><code class="language-none">BayesNets.AbstractMixtureModel</code></pre><pre><code class="language-none">BayesNets.AbstractMvNormal</code></pre><pre><code class="language-none">BayesNets.Arcsine</code></pre><pre><code class="language-none">BayesNets.Assignment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.BDeuPrior" href="#BayesNets.BDeuPrior"><code>BayesNets.BDeuPrior</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Assigns equal scores to Markov equivalent structures</p><pre><code class="language-none">α_ijk = x/{q_i * r_i} for each j, k and some given x</code></pre><p>see DMU section 2.4.3</p></div></div></section><pre><code class="language-none">BayesNets.BayesNet</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.BayesNetSampler" href="#BayesNets.BayesNetSampler"><code>BayesNets.BayesNetSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for sampling with:</p><ul><li><code>Random.rand(BayesNet, BayesNetSampler)</code></li><li><code>Random.rand(BayesNet, BayesNetSampler, nsamples)</code></li><li><code>Random.rand!(Assignment, BayesNet, BayesNetSampler)</code></li></ul></div></div></section><pre><code class="language-none">BayesNets.BayesNets</code></pre><pre><code class="language-none">BayesNets.Bernoulli</code></pre><pre><code class="language-none">BayesNets.Beta</code></pre><pre><code class="language-none">BayesNets.BetaBinomial</code></pre><pre><code class="language-none">BayesNets.BetaPrime</code></pre><pre><code class="language-none">BayesNets.Binomial</code></pre><pre><code class="language-none">BayesNets.Biweight</code></pre><pre><code class="language-none">BayesNets.CPD</code></pre><pre><code class="language-none">BayesNets.CPDs</code></pre><pre><code class="language-none">BayesNets.Categorical</code></pre><pre><code class="language-none">BayesNets.CategoricalArray</code></pre><pre><code class="language-none">BayesNets.CategoricalArrays</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.CategoricalCPD" href="#BayesNets.CPDs.CategoricalCPD"><code>BayesNets.CPDs.CategoricalCPD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A categorical distribution, P(x|parents(x)) where all parents are discrete integers 1:N.</p><p>The ordering of <code>distributions</code> array follows the convention in Decision Making Under Uncertainty. Suppose a variable has three discrete parents. The first parental instantiation assigns all parents to their first bin. The second will assign the first parent (as defined in <code>parents</code>) to its second bin and the other parents to their first bin. The sequence continues until all parents are instantiated to their last bins.</p><p>This is equivalent to:</p><p>X,Y,Z 1,1,1 2,1,1 1,2,1 2,2,1 1,1,2 ...</p></div></div></section><pre><code class="language-none">BayesNets.CategoricalMatrix</code></pre><pre><code class="language-none">BayesNets.CategoricalPool</code></pre><pre><code class="language-none">BayesNets.CategoricalString</code></pre><pre><code class="language-none">BayesNets.CategoricalValue</code></pre><pre><code class="language-none">BayesNets.CategoricalVector</code></pre><pre><code class="language-none">BayesNets.Cauchy</code></pre><pre><code class="language-none">BayesNets.Chi</code></pre><pre><code class="language-none">BayesNets.Chisq</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ConditionalLinearGaussianCPD" href="#BayesNets.CPDs.ConditionalLinearGaussianCPD"><code>BayesNets.CPDs.ConditionalLinearGaussianCPD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A conditional linear Gaussian CPD, always returns a Normal{Float64}</p><pre><code class="language-none">This is a combination of the CategoricalCPD and the LinearGaussianCPD.
For a variable with N discrete parents and M continuous parents, it will construct
a linear gaussian distribution for all M parents for each discrete instantiation.

                  { Normal(μ=a₁×continuous_parents(x) + b₁, σ₁) for discrete instantiation 1
P(x|parents(x)) = { Normal(μ=a₂×continuous_parents(x) + b₂, σ₂) for discrete instantiation 2
                  { ...</code></pre></div></div></section><pre><code class="language-none">BayesNets.Continuous</code></pre><pre><code class="language-none">BayesNets.ContinuousDistribution</code></pre><pre><code class="language-none">BayesNets.ContinuousMatrixDistribution</code></pre><pre><code class="language-none">BayesNets.ContinuousMultivariateDistribution</code></pre><pre><code class="language-none">BayesNets.ContinuousUnivariateDistribution</code></pre><pre><code class="language-none">BayesNets.Cosine</code></pre><pre><code class="language-none">BayesNets.DAG</code></pre><pre><code class="language-none">BayesNets.DataFrame</code></pre><pre><code class="language-none">BayesNets.DataFrameRow</code></pre><pre><code class="language-none">BayesNets.DataFrames</code></pre><pre><code class="language-none">BayesNets.DiagNormal</code></pre><pre><code class="language-none">BayesNets.DiagNormalCanon</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.DirectSampler" href="#BayesNets.DirectSampler"><code>BayesNets.DirectSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Straightforward sampling from a BayesNet. The default sampler.</p></div></div></section><pre><code class="language-none">BayesNets.Dirichlet</code></pre><pre><code class="language-none">BayesNets.DirichletMultinomial</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.DirichletPrior" href="#BayesNets.DirichletPrior"><code>BayesNets.DirichletPrior</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Baysian Structure learning seeks to maximize P(G|D) In the Bayesian fashion, we can provide a prior over the parameters in our learning network. This is described using a Dirichlet Prior.</p></div></div></section><pre><code class="language-none">BayesNets.Discrete</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.DiscreteBayesNet" href="#BayesNets.DiscreteBayesNet"><code>BayesNets.DiscreteBayesNet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DiscreteBayesNet</code>s are Bayesian Networks where every variable is an integer within 1:Nᵢ and every distribution is Categorical.</p><p>This representation is very common, and allows for the use of factors, for example in <em>Probabilistic Graphical Models</em> by Koller and Friedman</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.DiscreteCPD" href="#BayesNets.CPDs.DiscreteCPD"><code>BayesNets.CPDs.DiscreteCPD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A categorical distribution, P(x|parents(x)) where all parents are discrete integers 1:N.</p><p>The ordering of <code>distributions</code> array follows the convention in Decision Making Under Uncertainty. Suppose a variable has three discrete parents. The first parental instantiation assigns all parents to their first bin. The second will assign the first parent (as defined in <code>parents</code>) to its second bin and the other parents to their first bin. The sequence continues until all parents are instantiated to their last bins.</p><p>This is equivalent to:</p><p>X,Y,Z 1,1,1 2,1,1 1,2,1 2,2,1 1,1,2 ...</p></div></div></section><pre><code class="language-none">BayesNets.DiscreteDistribution</code></pre><pre><code class="language-none">BayesNets.DiscreteMatrixDistribution</code></pre><pre><code class="language-none">BayesNets.DiscreteMultivariateDistribution</code></pre><pre><code class="language-none">BayesNets.DiscreteUniform</code></pre><pre><code class="language-none">BayesNets.DiscreteUnivariateDistribution</code></pre><pre><code class="language-none">BayesNets.Distribution</code></pre><pre><code class="language-none">BayesNets.Distributions</code></pre><pre><code class="language-none">BayesNets.DoubleExponential</code></pre><pre><code class="language-none">BayesNets.EdgeworthMean</code></pre><pre><code class="language-none">BayesNets.EdgeworthSum</code></pre><pre><code class="language-none">BayesNets.EdgeworthZ</code></pre><pre><code class="language-none">BayesNets.EmpiricalUnivariateDistribution</code></pre><pre><code class="language-none">BayesNets.Epanechnikov</code></pre><pre><code class="language-none">BayesNets.Erlang</code></pre><pre><code class="language-none">BayesNets.Estimator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.ExactInference" href="#BayesNets.ExactInference"><code>BayesNets.ExactInference</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Exact inference using factors and variable eliminations</p></div></div></section><pre><code class="language-none">BayesNets.Exponential</code></pre><pre><code class="language-none">BayesNets.FDist</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.Factor" href="#BayesNets.Factor"><code>BayesNets.Factor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Factor(dims, potential)</code></pre><p>Create a Factor corresponding to the potential.</p></div></div></section><pre><code class="language-none">BayesNets.FisherNoncentralHypergeometric</code></pre><pre><code class="language-none">BayesNets.Frechet</code></pre><pre><code class="language-none">BayesNets.FullNormal</code></pre><pre><code class="language-none">BayesNets.FullNormalCanon</code></pre><pre><code class="language-none">BayesNets.FunctionalCPD</code></pre><pre><code class="language-none">BayesNets.Gamma</code></pre><pre><code class="language-none">BayesNets.GeneralizedExtremeValue</code></pre><pre><code class="language-none">BayesNets.GeneralizedPareto</code></pre><pre><code class="language-none">BayesNets.Geometric</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.GibbsSampler" href="#BayesNets.GibbsSampler"><code>BayesNets.GibbsSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The GibbsSampler type houses the parameters of the Gibbs sampling algorithm.  The parameters are defined below:</p><p>burn<em>in:  The first burn</em>in samples will be discarded.  They will not be returned. The thinning parameter does not affect the burn in period. This is used to ensure that the Gibbs sampler converges to the target stationary distribution before actual samples are drawn.</p><p>thinning: For every thinning + 1 number of samples drawn, only the last is kept. Thinning is used to reduce autocorrelation between samples. Thinning is not used during the burn in period. e.g. If thinning is 1, samples will be drawn in groups of two and only the second sample will be in the output.</p><p>time<em>limit: The number of milliseconds to run the algorithm. The algorithm will return the samples it has collected when either nsamples samples have been collected or time</em>limit milliseconds have passed.  If time_limit is null then the algorithm will run until nsamples have been collected. This means it is possible that zero samples are returned.</p><p>error<em>if</em>time<em>out: If error</em>if<em>time</em>out is true and the time<em>limit expires, an error will be raised. If error</em>if<em>time</em>out is false and the time limit expires, the samples that have been collected so far will be returned.         This means it is possible that zero samples are returned.  Burn in samples will not be returned. If time_limit is null, this parameter does nothing.</p><p>consistent_with: the assignment that all samples must be consistent with (ie, Assignment(:A=&gt;1) means all samples must have :A=1). Use to sample conditional distributions.</p><p>max<em>cache</em>size:  If null, cache as much as possible, otherwise cache at most &quot;max<em>cache</em>size&quot;  distributions</p><p>variable<em>order: variable</em>order determines the order of variables changed when generating a new sample. If null use a random order for every sample (this is different from updating the variables at random). Otherwise should be a list containing all the variables in the order they should be updated.</p><p>initial_sample:  The inital assignment to variables to use.  If null, the initial sample is chosen by briefly using a LikelihoodWeightedSampler.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.GibbsSamplerState" href="#BayesNets.GibbsSamplerState"><code>BayesNets.GibbsSamplerState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Used to cache various things the Gibbs sampler needs</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.GibbsSamplingFull" href="#BayesNets.GibbsSamplingFull"><code>BayesNets.GibbsSamplingFull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">infer(im, inf)</code></pre><p>Run Gibbs sampling for <code>N</code> iterations. Each iteration changes all nodes. Discareds first <code>burn_in</code> samples and keeps only the <code>thin</code>-th sample. Ex, if <code>thin=3</code>, will discard the first two samples and keep the third.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.GibbsSamplingNodewise" href="#BayesNets.GibbsSamplingNodewise"><code>BayesNets.GibbsSamplingNodewise</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">infer(GibbsSampling, state::Assignment, InferenceState)</code></pre><p>Run Gibbs sampling for <code>N</code> iterations. Each iteration changes one node.</p><p>Discareds first <code>burn_in</code> samples and keeps only the <code>thin</code>-th sample. Ex, if <code>thin=3</code>, will discard the first two samples and keep the third.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.GraphSearchStrategy" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.GraphSearchStrategy"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.GraphSearchStrategy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GraphSearchStrategy</code></pre><p>An abstract type which defines a graph search strategy for learning probabilistic graphical model structures These allow: fit(::Type{ProbabilisticGraphicalModel}, data, GraphSearchStrategy)</p></div></div></section><pre><code class="language-none">BayesNets.GreedyHillClimbing</code></pre><pre><code class="language-none">BayesNets.GreedyThickThinning</code></pre><pre><code class="language-none">BayesNets.GroupApplied</code></pre><pre><code class="language-none">BayesNets.GroupedDataFrame</code></pre><pre><code class="language-none">BayesNets.Gumbel</code></pre><pre><code class="language-none">BayesNets.Hypergeometric</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceMethod" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceMethod"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for probability inference</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceState" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceState"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.InferenceState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for capturing the inference state</p></div></div></section><pre><code class="language-none">BayesNets.InverseGamma</code></pre><pre><code class="language-none">BayesNets.InverseGaussian</code></pre><pre><code class="language-none">BayesNets.InverseWishart</code></pre><pre><code class="language-none">BayesNets.IsoNormal</code></pre><pre><code class="language-none">BayesNets.IsoNormalCanon</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.K2GraphSearch" href="#BayesNets.K2GraphSearch"><code>BayesNets.K2GraphSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">K2GraphSearch</code></pre><p>A GraphSearchStrategy following the K2 algorithm. Takes polynomial time to find the optimal structure assuming a topological variable ordering.</p></div></div></section><pre><code class="language-none">BayesNets.KSDist</code></pre><pre><code class="language-none">BayesNets.KSOneSided</code></pre><pre><code class="language-none">BayesNets.Kolmogorov</code></pre><pre><code class="language-none">BayesNets.Laplace</code></pre><pre><code class="language-none">BayesNets.LevelsException</code></pre><pre><code class="language-none">BayesNets.Levy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.LikelihoodWeightedSampler" href="#BayesNets.LikelihoodWeightedSampler"><code>BayesNets.LikelihoodWeightedSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Likelihood Weighted Sampling</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.LikelihoodWeightingInference" href="#BayesNets.LikelihoodWeightingInference"><code>BayesNets.LikelihoodWeightingInference</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Approximates p(query|evidence) with N weighted samples using likelihood weighted sampling</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.LinearGaussianCPD" href="#BayesNets.CPDs.LinearGaussianCPD"><code>BayesNets.CPDs.LinearGaussianCPD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A linear Gaussian CPD, always returns a Normal</p><pre><code class="language-none">Assumes that target and all parents can be converted to Float64 (ie, are numeric)

P(x|parents(x)) = Normal(μ=a×parents(x) + b, σ)</code></pre></div></div></section><pre><code class="language-none">BayesNets.LocationScale</code></pre><pre><code class="language-none">BayesNets.LogNormal</code></pre><pre><code class="language-none">BayesNets.Logistic</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.LoopyBelief" href="#BayesNets.LoopyBelief"><code>BayesNets.LoopyBelief</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Loopy belief propogation for a network.</p><p>Early stopping if change is messages &lt; <code>tol</code> for `iters<em>for</em>convergence&#39; iterations. For no stopping, use tol &lt; 0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L5">source</a></section><pre><code class="language-none">BayesNets.MLEstimator</code></pre><pre><code class="language-none">BayesNets.MatrixDistribution</code></pre><pre><code class="language-none">BayesNets.Matrixvariate</code></pre><pre><code class="language-none">BayesNets.Missing</code></pre><pre><code class="language-none">BayesNets.MissingCategoricalArray</code></pre><pre><code class="language-none">BayesNets.MissingCategoricalMatrix</code></pre><pre><code class="language-none">BayesNets.MissingCategoricalVector</code></pre><pre><code class="language-none">BayesNets.MissingException</code></pre><pre><code class="language-none">BayesNets.Missings</code></pre><pre><code class="language-none">BayesNets.MixtureModel</code></pre><pre><code class="language-none">BayesNets.Multinomial</code></pre><pre><code class="language-none">BayesNets.Multivariate</code></pre><pre><code class="language-none">BayesNets.MultivariateDistribution</code></pre><pre><code class="language-none">BayesNets.MultivariateMixture</code></pre><pre><code class="language-none">BayesNets.MultivariateNormal</code></pre><pre><code class="language-none">BayesNets.MvLogNormal</code></pre><pre><code class="language-none">BayesNets.MvNormal</code></pre><pre><code class="language-none">BayesNets.MvNormalCanon</code></pre><pre><code class="language-none">BayesNets.MvNormalKnownCov</code></pre><pre><code class="language-none">BayesNets.MvTDist</code></pre><pre><code class="language-none">BayesNets.NamedCategorical</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.NegativeBayesianInformationCriterion" href="#BayesNets.NegativeBayesianInformationCriterion"><code>BayesNets.NegativeBayesianInformationCriterion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NegativeBayesianInformationCriterion</code></pre><p>A ScoringFunction for the negative Bayesian information criterion.</p><pre><code class="language-none">BIC = -2⋅L + k⋅ln(n)

   L - the log likelihood of the data under the cpd
   k - the number of free parameters to be estimated
   n - the sample size</code></pre></div></div></section><pre><code class="language-none">BayesNets.NegativeBinomial</code></pre><pre><code class="language-none">BayesNets.NodeName</code></pre><pre><code class="language-none">BayesNets.NodeNameUnion</code></pre><pre><code class="language-none">BayesNets.NodeNames</code></pre><pre><code class="language-none">BayesNets.NonMatrixDistribution</code></pre><pre><code class="language-none">BayesNets.NoncentralBeta</code></pre><pre><code class="language-none">BayesNets.NoncentralChisq</code></pre><pre><code class="language-none">BayesNets.NoncentralF</code></pre><pre><code class="language-none">BayesNets.NoncentralHypergeometric</code></pre><pre><code class="language-none">BayesNets.NoncentralT</code></pre><pre><code class="language-none">BayesNets.Normal</code></pre><pre><code class="language-none">BayesNets.NormalCanon</code></pre><pre><code class="language-none">BayesNets.NormalInverseGaussian</code></pre><pre><code class="language-none">BayesNets.OrderedLevelsException</code></pre><pre><code class="language-none">BayesNets.ParentFunctionalCPD</code></pre><pre><code class="language-none">BayesNets.Pareto</code></pre><pre><code class="language-none">BayesNets.Poisson</code></pre><pre><code class="language-none">BayesNets.PoissonBinomial</code></pre><pre><code class="language-none">BayesNets.ProbabilisticGraphicalModel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels" href="#BayesNets.CPDs.ProbabilisticGraphicalModels"><code>BayesNets.CPDs.ProbabilisticGraphicalModels</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Provides a basic interface for defining and working with probabilistic graphical models</p></div></div></section><pre><code class="language-none">BayesNets.QQPair</code></pre><pre><code class="language-none">BayesNets.Rayleigh</code></pre><pre><code class="language-none">BayesNets.RealInterval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.RejectionSampler" href="#BayesNets.RejectionSampler"><code>BayesNets.RejectionSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Rejection Sampling in which the assignments are forced to be consistent with the provided values. Each sampler is attempted at most <code>max_nsamples</code> times before returning an empty assignment.</p></div></div></section><pre><code class="language-none">BayesNets.Sampleable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.Sampler" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.Sampler"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.Sampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for sampling with Base.rand(ProbabilisticGraphicalModel, Sampler, nsamples)                                 Base.rand!(Assignment, ProbabilisticGraphicalModel, Sampler)                                 Base.rand(ProbabilisticGraphicalModel, Sampler)</p></div></div></section><pre><code class="language-none">BayesNets.ScanGreedyHillClimbing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.ScoreComponentCache" href="#BayesNets.ScoreComponentCache"><code>BayesNets.ScoreComponentCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScoreComponentCache</code></pre><p>Used to store scores in a priority queue such that graph search algorithms know when a particular construction has already been made.     cache<a href="parentsⱼ, score">ⱼ</a> for the ith variable with parents parents</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.ScoringFunction" href="#BayesNets.ScoringFunction"><code>BayesNets.ScoringFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScoringFunction</code></pre><p>An abstract type for which subtypes allow extracting CPD score components, which are to be maximized: score_component(::ScoringFunction, cpd::CPD, data::DataFrame)</p></div></div></section><pre><code class="language-none">BayesNets.Semicircle</code></pre><pre><code class="language-none">BayesNets.Skellam</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.StaticCPD" href="#BayesNets.CPDs.StaticCPD"><code>BayesNets.CPDs.StaticCPD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A CPD for which the distribution never changes.     target: name of the CPD&#39;s variable     parents: list of parent variables.     d: a Distributions.jl distribution</p><p>While a StaticCPD can have parents, their assignments will not affect the distribution.</p></div></div></section><pre><code class="language-none">BayesNets.SubDataFrame</code></pre><pre><code class="language-none">BayesNets.SufficientStats</code></pre><pre><code class="language-none">BayesNets.SymTriangularDist</code></pre><pre><code class="language-none">BayesNets.TDist</code></pre><pre><code class="language-none">BayesNets.Table</code></pre><pre><code class="language-none">BayesNets.TriangularDist</code></pre><pre><code class="language-none">BayesNets.Triweight</code></pre><pre><code class="language-none">BayesNets.Truncated</code></pre><pre><code class="language-none">BayesNets.TruncatedNormal</code></pre><pre><code class="language-none">BayesNets.Uniform</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.UniformPrior" href="#BayesNets.UniformPrior"><code>BayesNets.UniformPrior</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A uniform Dirichlet prior such that all α are the same</p><p>Defaults to the popular K2 prior, α = 1, which is similar to Laplace Smoothing</p><pre><code class="language-none">https://en.wikipedia.org/wiki/Additive_smoothing</code></pre></div></div></section><pre><code class="language-none">BayesNets.Univariate</code></pre><pre><code class="language-none">BayesNets.UnivariateDistribution</code></pre><pre><code class="language-none">BayesNets.UnivariateGMM</code></pre><pre><code class="language-none">BayesNets.UnivariateMixture</code></pre><pre><code class="language-none">BayesNets.ValueSupport</code></pre><pre><code class="language-none">BayesNets.VariateForm</code></pre><pre><code class="language-none">BayesNets.VonMises</code></pre><pre><code class="language-none">BayesNets.VonMisesFisher</code></pre><pre><code class="language-none">BayesNets.WalleniusNoncentralHypergeometric</code></pre><pre><code class="language-none">BayesNets.Weibull</code></pre><pre><code class="language-none">BayesNets.Wishart</code></pre><pre><code class="language-none">BayesNets.ZeroMeanDiagNormal</code></pre><pre><code class="language-none">BayesNets.ZeroMeanDiagNormalCanon</code></pre><pre><code class="language-none">BayesNets.ZeroMeanFullNormal</code></pre><pre><code class="language-none">BayesNets.ZeroMeanFullNormalCanon</code></pre><pre><code class="language-none">BayesNets.ZeroMeanIsoNormal</code></pre><pre><code class="language-none">BayesNets.ZeroMeanIsoNormalCanon</code></pre><pre><code class="language-none">BayesNets._build_dag_from_cpds</code></pre><pre><code class="language-none">BayesNets._check_dims_valid</code></pre><pre><code class="language-none">BayesNets._ckeck_dims_unique</code></pre><pre><code class="language-none">BayesNets._enforce_topological_order</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets._evidence_lambda" href="#BayesNets._evidence_lambda"><code>BayesNets._evidence_lambda</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the lambda-message to itself for an evidence node. If it isn&#39;t an evidence node, this will break</p></div></div></section><pre><code class="language-none">BayesNets._get_dag</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets._get_parent_indeces" href="#BayesNets._get_parent_indeces"><code>BayesNets._get_parent_indeces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">score_component(a::ScoringFunction, cpd::CPD, data::DataFrame, cache::ScoreComponentCache)</code></pre><p>As score_component(ScoringFunction, cpd, data), but returns pre-computed values from the cache if they exist, and populates the cache if they don&#39;t</p></div></div></section><pre><code class="language-none">BayesNets._get_parental_ncategories</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets._init_gibbs_sample" href="#BayesNets._init_gibbs_sample"><code>BayesNets._init_gibbs_sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">_init_gibbs_sample(bn, evidence)</code></pre><p>A random sample of non-evidence nodes uniformly over their domain</p></div></div></section><pre><code class="language-none">BayesNets._reddim</code></pre><pre><code class="language-none">BayesNets._translate_index</code></pre><pre><code class="language-none">BayesNets.add_edge!</code></pre><pre><code class="language-none">BayesNets.adding_edge_preserves_acyclicity</code></pre><pre><code class="language-none">BayesNets.aggregate</code></pre><pre><code class="language-none">BayesNets.allowmissing</code></pre><pre><code class="language-none">BayesNets.allowmissing!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.bayesian_score" href="#BayesNets.bayesian_score"><code>BayesNets.bayesian_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bayesian_score(G::DAG, names::Vector{Symbol}, data::DataFrame[, ncategories::Vector{Int}[, prior::DirichletPrior]])</code></pre><p>Compute the bayesian score for graph structure <code>g</code>, with the data in <code>data</code>. <code>names</code> containes a symbol corresponding to each vertex in <code>g</code> that is the name of a column in <code>data</code>. <code>ncategories</code> is a vector of the number of values that each variable in the Bayesian network can take.</p><p>Note that every entry in data must be an integer greater than 0</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.bayesian_score_component" href="#BayesNets.bayesian_score_component"><code>BayesNets.bayesian_score_component</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the Bayesian score component for the given target variable index and     Dirichlet prior counts given in alpha</p><p>INPUT:     i       - index of the target variable     parents - list of indeces of parent variables (should not contain self)     r       - list of instantiation counts accessed by variable index               r[1] gives number of discrete states variable 1 can take on     data - matrix of sufficient statistics / counts               d[j,k] gives the number of times the target variable took on its kth instantiation               given the jth parental instantiation</p><p>OUTPUT:     the Bayesian score, Float64</p></div></div></section><pre><code class="language-none">BayesNets.bayesian_score_component_uniform</code></pre><pre><code class="language-none">BayesNets.bayesian_score_components</code></pre><pre><code class="language-none">BayesNets.binaryentropy</code></pre><pre><code class="language-none">BayesNets.by</code></pre><pre><code class="language-none">BayesNets.canonform</code></pre><pre><code class="language-none">BayesNets.categorical</code></pre><pre><code class="language-none">BayesNets.categorical!</code></pre><pre><code class="language-none">BayesNets.ccdf</code></pre><pre><code class="language-none">BayesNets.cdf</code></pre><pre><code class="language-none">BayesNets.cf</code></pre><pre><code class="language-none">BayesNets.cgf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.children" href="#BayesNets.children"><code>BayesNets.children</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the children as a list of NodeNames</p></div></div></section><pre><code class="language-none">BayesNets.circvar</code></pre><pre><code class="language-none">BayesNets.coalesce</code></pre><pre><code class="language-none">BayesNets.colwise</code></pre><pre><code class="language-none">BayesNets.combine</code></pre><pre><code class="language-none">BayesNets.compact</code></pre><pre><code class="language-none">BayesNets.complete_cases</code></pre><pre><code class="language-none">BayesNets.complete_cases!</code></pre><pre><code class="language-none">BayesNets.completecases</code></pre><pre><code class="language-none">BayesNets.component</code></pre><pre><code class="language-none">BayesNets.components</code></pre><pre><code class="language-none">BayesNets.componentwise_logpdf</code></pre><pre><code class="language-none">BayesNets.componentwise_pdf</code></pre><pre><code class="language-none">BayesNets.compress</code></pre><pre><code class="language-none">BayesNets.concentration</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.consistent" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.consistent"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.consistent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">consistent(a::Assignment, b::Assignment)</code></pre><p>True if all shared NodeNames have the same value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert(DiscreteCPD, cpd)</code></pre><p>Construct a Factor from a DiscreteCPD.</p></div></div><div><div><p>Convert a Factor to a DataFrame</p></div></div></section><pre><code class="language-none">BayesNets.cor</code></pre><pre><code class="language-none">BayesNets.cov</code></pre><pre><code class="language-none">BayesNets.cquantile</code></pre><pre><code class="language-none">BayesNets.cumulant</code></pre><pre><code class="language-none">BayesNets.cut</code></pre><pre><code class="language-none">BayesNets.decompress</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete!(bn::BayesNets, target::NodeName)</code></pre><p>Removing cpds will alter the vertex indeces. In particular, removing the ith cpd will swap i and n and then remove n.</p></div></div></section><pre><code class="language-none">BayesNets.deletecols!</code></pre><pre><code class="language-none">BayesNets.deleterows!</code></pre><pre><code class="language-none">BayesNets.descendants</code></pre><pre><code class="language-none">BayesNets.describe</code></pre><pre><code class="language-none">BayesNets.dim</code></pre><pre><code class="language-none">BayesNets.disallowmissing</code></pre><pre><code class="language-none">BayesNets.disallowmissing!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.disttype" href="#BayesNets.CPDs.disttype"><code>BayesNets.CPDs.disttype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disttype(cpd::CPD)</code></pre><p>Return the type of the CPD&#39;s distribution</p></div></div></section><pre><code class="language-none">BayesNets.dof</code></pre><pre><code class="language-none">BayesNets.droplevels!</code></pre><pre><code class="language-none">BayesNets.dropmissing</code></pre><pre><code class="language-none">BayesNets.dropmissing!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.duplicate" href="#BayesNets.duplicate"><code>BayesNets.duplicate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">duplicate(A, dims)</code></pre><p>Repeates an array only through higer dimensions <code>dims</code>.</p><p>Custom version of repeate, but only outer repetition, and only duplicates the array for the number of times specified in <code>dims</code> for dimensions greater than <code>ndims(A)</code>. If <code>dims</code> is empty, returns a copy of <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; duplicate(collect(1:3), 2)
3×2 Array{Int64,2}:
 1  1
 2  2
 3  3

julia&gt; duplicate([1 3; 2 4], 3)
2×2×3 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 1  3
 2  4

[:, :, 3] =
 1  3
 2  4</code></pre></div></div></section><pre><code class="language-none">BayesNets.eltypes</code></pre><pre><code class="language-none">BayesNets.enforce_topological_order!</code></pre><pre><code class="language-none">BayesNets.entropy</code></pre><pre><code class="language-none">BayesNets.estimate</code></pre><pre><code class="language-none">BayesNets.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.eval_mb_cpd" href="#BayesNets.eval_mb_cpd"><code>BayesNets.eval_mb_cpd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_mb_cpd(node, ncategories, assignment, mb_cpds)</code></pre><p>Return the potential of all instances of a node given its markove blanket as a WeightVec:     P(node | pa<em>node) * Prod (c in children) P(c | pa</em>c)</p><p>Trys out all possible values of node (assumes categorical) Assignment should have values for all in the Markov blanket, including the variable itself.</p></div></div></section><pre><code class="language-none">BayesNets.expected_logdet</code></pre><pre><code class="language-none">BayesNets.failprob</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit" href="#StatsBase.fit"><code>StatsBase.fit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fit(::Type{ProbabilisticGraphicalModel}, data::DataFrame, params::GraphSearchStrategy)</code></pre><p>Runs the graph search algorithm to learn a probabilistic graphical model of the provided type from data.</p></div></div><div><div><pre><code class="language-none">fit(::Type{CPD}, data::DataFrame, target::NodeName, parents::NodeNames)</code></pre><p>Construct a CPD for target by fitting it to the provided data</p></div></div><div><div><pre><code class="language-none">fit(::Type{BayesNet}, data, edges)</code></pre><p>Fit a Bayesian Net whose variables are the columns in data and whose edges are given in edges</p><pre><code class="language-none">ex: fit(DiscreteBayesNet, data, (:A=&gt;:B, :C=&gt;B))</code></pre></div></div><div><div><pre><code class="language-none">fit{C&lt;:CPD}(::Type{BayesNet{C}}, ::DataFrame, ::GraphSearchStrategy)</code></pre><p>Run the graph search algorithm defined by GraphSearchStrategy</p></div></div><div><div><p>takes a list of observations of assignments represented as a DataFrame or a set of data samples (without :p), takes the unique assignments, and estimates the associated probability of each assignment based on its frequency of occurrence.</p></div></div></section><pre><code class="language-none">BayesNets.fit_map</code></pre><pre><code class="language-none">BayesNets.fit_map!</code></pre><pre><code class="language-none">BayesNets.fit_mle</code></pre><pre><code class="language-none">BayesNets.fit_mle!</code></pre><pre><code class="language-none">BayesNets.freecumulant</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_asia_bn" href="#BayesNets.get_asia_bn"><code>BayesNets.get_asia_bn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>An ergodic version of the asia network, with the E variable removed</p><p>Orignal network: Lauritzen, Steffen L. and David J. Spiegelhalter, 1988</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_finite_distribution!" href="#BayesNets.get_finite_distribution!"><code>BayesNets.get_finite_distribution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Helper to sample<em>posterior</em>finite</p><p>Modifies a and gss</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_mb_cpds" href="#BayesNets.get_mb_cpds"><code>BayesNets.get_mb_cpds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get the cpd&#39;s of a node and its children</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_sat_fail_bn" href="#BayesNets.get_sat_fail_bn"><code>BayesNets.get_sat_fail_bn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Satellite failure network from DMU, pg 17</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_sprinkler_bn" href="#BayesNets.get_sprinkler_bn"><code>BayesNets.get_sprinkler_bn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The usual sprinkler problem</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_weighted_dataframe" href="#BayesNets.get_weighted_dataframe"><code>BayesNets.get_weighted_dataframe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A dataset of variable assignments is obtained with an additional column of weights in accordance with the likelihood of each assignment.</p></div></div></section><pre><code class="language-none">BayesNets.get_weighted_sample</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.get_weighted_sample!" href="#BayesNets.get_weighted_sample!"><code>BayesNets.get_weighted_sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Draw an assignment from the Bayesian network but set any variables in the evidence accordingly. Returns the assignment and the probability weighting associated with the evidence.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.gibbs_sample" href="#BayesNets.gibbs_sample"><code>BayesNets.gibbs_sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements Gibbs sampling. (https://en.wikipedia.org/wiki/Gibbs_sampling) For finite variables, the posterior distribution is sampled by building the exact distribution. For continuous variables, the posterior distribution is sampled using Metropolis Hastings MCMC. Discrete variables with infinite support are currently not supported. The Gibbs Sampler only supports CPDs that return Univariate Distributions. (CPD{D&lt;:UnivariateDistribution})</p><p>bn:: A Bayesian Network to sample from.  bn should only contain CPDs that return UnivariateDistributions.</p><p>nsamples: The number of samples to return.</p><p>burn<em>in:  The first burn</em>in samples will be discarded.  They will not be returned. The thinning parameter does not affect the burn in period. This is used to ensure that the Gibbs sampler converges to the target stationary distribution before actual samples are drawn.</p><p>thinning: For every thinning + 1 number of samples drawn, only the last is kept. Thinning is used to reduce autocorrelation between samples. Thinning is not used during the burn in period. e.g. If thinning is 1, samples will be drawn in groups of two and only the second sample will be in the output.</p><p>time<em>limit: The number of milliseconds to run the algorithm. The algorithm will return the samples it has collected when either nsamples samples have been collected or time</em>limit milliseconds have passed.  If time_limit is null then the algorithm will run until nsamples have been collected. This means it is possible that zero samples are returned.</p><p>error<em>if</em>time<em>out: If error</em>if<em>time</em>out is true and the time<em>limit expires, an error will be raised. If error</em>if<em>time</em>out is false and the time limit expires, the samples that have been collected so far will be returned. 	This means it is possible that zero samples are returned.  Burn in samples will not be returned. If time_limit is null, this parameter does nothing.</p><p>consistent_with: the assignment that all samples must be consistent with (ie, Assignment(:A=&gt;1) means all samples must have :A=1). Use to sample conditional distributions.</p><p>max<em>cache</em>size:  If null, cache as much as possible, otherwise cache at most &quot;max<em>cache</em>size&quot;  distributions</p><p>variable<em>order: variable</em>order determines the order of variables changed when generating a new sample. If null use a random order for every sample (this is different from updating the variables at random). Otherwise should be a list containing all the variables in the order they should be updated.</p><p>initial<em>sample:  The inital assignment to variables to use.  If null, the initial sample is chosen by briefly running rand(bn, get</em>weighted_dataframe).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.gibbs_sample_main_loop" href="#BayesNets.gibbs_sample_main_loop"><code>BayesNets.gibbs_sample_main_loop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The main loop associated with Gibbs sampling Returns a data frame with nsamples samples</p><p>Supports the various parameters supported by gibbs<em>sample Refer to gibbs</em>sample for parameter meanings</p></div></div></section><pre><code class="language-none">BayesNets.gradlogpdf</code></pre><pre><code class="language-none">BayesNets.greedy_score</code></pre><pre><code class="language-none">BayesNets.groupby</code></pre><pre><code class="language-none">BayesNets.groupindices</code></pre><pre><code class="language-none">BayesNets.groupvars</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.has_edge" href="#LightGraphs.has_edge"><code>LightGraphs.has_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Whether the BayesNet contains the given edge</p></div></div></section><pre><code class="language-none">BayesNets.hasfinitesupport</code></pre><pre><code class="language-none">BayesNets.head</code></pre><pre><code class="language-none">BayesNets.include</code></pre><pre><code class="language-none">BayesNets.index_data</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.infer" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.infer"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.infer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">infer(InferenceMethod, InferenceState)</code></pre><p>Infer p(query|evidence)</p></div></div><div><div><p>Approximates p(query|evidence) with <code>nsamples</code> likelihood weighted samples.</p><p>Since this uses a Factor, it is only efficient if the number of samples is (signifcantly) greater than the number of possible instantiations for the query variables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.infer_number_of_instantiations" href="#BayesNets.CPDs.infer_number_of_instantiations"><code>BayesNets.CPDs.infer_number_of_instantiations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">infer_number_of_instantiations{I&lt;:Int}(arr::AbstractVector{I})</code></pre><p>Infer the number of instantiations, N, for a data type, assuming that it takes on the values 1:N</p></div></div></section><pre><code class="language-none">BayesNets.insert!</code></pre><pre><code class="language-none">BayesNets.insertcols!</code></pre><pre><code class="language-none">BayesNets.insupport</code></pre><pre><code class="language-none">BayesNets.invalid_dims_error</code></pre><pre><code class="language-none">BayesNets.invcov</code></pre><pre><code class="language-none">BayesNets.invlogccdf</code></pre><pre><code class="language-none">BayesNets.invlogcdf</code></pre><pre><code class="language-none">BayesNets.invscale</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.is_independent" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.is_independent"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.is_independent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>is_independent(PGM, x::NodeNames, y::NodeNames, given::NodeNames) Returns whether the set of node names <code>x</code> is d-separated from the set <code>y</code> given the set <code>given</code></p></div></div><div><div><p>Returns whether the set of node names <code>x</code> is d-separated from the set <code>y</code> given the set <code>given</code></p></div></div></section><pre><code class="language-none">BayesNets.isbounded</code></pre><pre><code class="language-none">BayesNets.isleptokurtic</code></pre><pre><code class="language-none">BayesNets.islowerbounded</code></pre><pre><code class="language-none">BayesNets.ismesokurtic</code></pre><pre><code class="language-none">BayesNets.ismissing</code></pre><pre><code class="language-none">BayesNets.isordered</code></pre><pre><code class="language-none">BayesNets.isplatykurtic</code></pre><pre><code class="language-none">BayesNets.isprobvec</code></pre><pre><code class="language-none">BayesNets.isupperbounded</code></pre><pre><code class="language-none">BayesNets.kde</code></pre><pre><code class="language-none">BayesNets.keys</code></pre><pre><code class="language-none">BayesNets.kurtosis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">length(PGM)</code></pre><p>Returns the number of variables in the probabilistic graphical model</p></div></div><div><div><p>Total number of elements in Factor (potential)</p></div></div></section><pre><code class="language-none">BayesNets.levels</code></pre><pre><code class="language-none">BayesNets.levels!</code></pre><pre><code class="language-none">BayesNets.location</code></pre><pre><code class="language-none">BayesNets.location!</code></pre><pre><code class="language-none">BayesNets.logccdf</code></pre><pre><code class="language-none">BayesNets.logcdf</code></pre><pre><code class="language-none">BayesNets.logdetcov</code></pre><pre><code class="language-none">BayesNets.loglikelihood</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.logpdf" href="#Distributions.logpdf"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The logpdf of a given assignment after conditioning on the values</p></div></div><div><div><p>The logpdf of a set of assignment after conditioning on the values</p></div></div><div><div><pre><code class="language-none">logpdf(cpd::CPD)</code></pre><p>Condition and then return the logpdf</p></div></div><div><div><pre><code class="language-none">logpdf(cpd::CPD, data::DataFrame)</code></pre><p>Return the logpdf across the dataset</p></div></div><div><div><p>The logpdf of a given assignment after conditioning on the values</p></div></div></section><pre><code class="language-none">BayesNets.logpdf!</code></pre><pre><code class="language-none">BayesNets.map</code></pre><pre><code class="language-none">BayesNets.mapcols</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.ProbabilisticGraphicalModels.markov_blanket" href="#BayesNets.CPDs.ProbabilisticGraphicalModels.markov_blanket"><code>BayesNets.CPDs.ProbabilisticGraphicalModels.markov_blanket</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>markov_blanket(PGM) Returns the list of NodeNames forming the Markov blanket for the PGM</p></div></div><div><div><p>Return the children, parents, and parents of children (excluding target) as a Set of NodeNames</p></div></div></section><pre><code class="language-none">BayesNets.mean</code></pre><pre><code class="language-none">BayesNets.meandir</code></pre><pre><code class="language-none">BayesNets.meanform</code></pre><pre><code class="language-none">BayesNets.meanlogx</code></pre><pre><code class="language-none">BayesNets.median</code></pre><pre><code class="language-none">BayesNets.melt</code></pre><pre><code class="language-none">BayesNets.meltdf</code></pre><pre><code class="language-none">BayesNets.merge!</code></pre><pre><code class="language-none">BayesNets.meshgrid</code></pre><pre><code class="language-none">BayesNets.mgf</code></pre><pre><code class="language-none">BayesNets.missing</code></pre><pre><code class="language-none">BayesNets.missings</code></pre><pre><code class="language-none">BayesNets.mode</code></pre><pre><code class="language-none">BayesNets.modes</code></pre><pre><code class="language-none">BayesNets.moment</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.name" href="#BayesNets.CPDs.name"><code>BayesNets.CPDs.name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">name(cpd::CPD)</code></pre><p>Return the NodeName for the variable this CPD is defined for.</p></div></div></section><pre><code class="language-none">BayesNets.names!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.ncategories" href="#Distributions.ncategories"><code>Distributions.ncategories</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Distributions.ncategories(cpd::CategoricalCPD)</code></pre><p>Return the number of categories for a cpd.</p></div></div><div><div><pre><code class="language-none">Distributions.ncategories(bn::DiscreteBayesNet, node::Symbol)</code></pre><p>Return the number of categories for a node in the network.</p></div></div></section><pre><code class="language-none">BayesNets.ncol</code></pre><pre><code class="language-none">BayesNets.ncomponents</code></pre><pre><code class="language-none">BayesNets.ndgrid</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.ndgrid_fill!" href="#BayesNets.ndgrid_fill!"><code>BayesNets.ndgrid_fill!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>???</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.neighbors" href="#LightGraphs.neighbors"><code>LightGraphs.neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns all neighbors as a list of NodeNames.</p></div></div></section><pre><code class="language-none">BayesNets.non_unique_dims_error</code></pre><pre><code class="language-none">BayesNets.non_unique_states_error</code></pre><pre><code class="language-none">BayesNets.nonunique</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize!(ϕ, dims; p=1)
normalize!(ϕ; p=1)</code></pre><p>Return a normalized copy of the factor so all instances of dims have (or the entire factors has) p-norm of 1</p></div></div></section><pre><code class="language-none">BayesNets.not_in_factor_error</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.nparams" href="#BayesNets.CPDs.nparams"><code>BayesNets.CPDs.nparams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nparams(cpd::CPD)</code></pre><p>Return the number of free parameters that needed to be estimated for the CPD</p></div></div></section><pre><code class="language-none">BayesNets.nrow</code></pre><pre><code class="language-none">BayesNets.nsamples</code></pre><pre><code class="language-none">BayesNets.ntrials</code></pre><pre><code class="language-none">BayesNets.nullable!</code></pre><pre><code class="language-none">BayesNets.order</code></pre><pre><code class="language-none">BayesNets.ordered</code></pre><pre><code class="language-none">BayesNets.ordered!</code></pre><pre><code class="language-none">BayesNets.params</code></pre><pre><code class="language-none">BayesNets.params!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.parentless" href="#BayesNets.CPDs.parentless"><code>BayesNets.CPDs.parentless</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parentless(cpd::CPD)</code></pre><p>Return whether this CPD has parents.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.parents" href="#BayesNets.CPDs.parents"><code>BayesNets.CPDs.parents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parents(cpd::CPD)</code></pre><p>Return the parents for this CPD as a vector of NodeName.</p></div></div><div><div><p>Returns the parents as a list of NodeNames</p></div></div></section><pre><code class="language-none">BayesNets.partype</code></pre><pre><code class="language-none">BayesNets.passmissing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.pattern" href="#BayesNets.pattern"><code>BayesNets.pattern</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pattern(ϕ, [dims])</code></pre><p>Return an array with the pattern of each dimension&#39;s state for all possible instances</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.pdf" href="#Distributions.pdf"><code>Distributions.pdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The pdf of a given assignment after conditioning on the values</p></div></div><div><div><p>The pdf of a set of assignments after conditioning on the values</p></div></div><div><div><pre><code class="language-none">pdf(cpd::CPD)</code></pre><p>Condition and then return the pdf</p></div></div><div><div><pre><code class="language-none">pdf(cpd::CPD, data::DataFrame)</code></pre><p>Return the pdf across the dataset</p></div></div><div><div><p>The pdf of a given assignment after conditioning on the values</p></div></div></section><pre><code class="language-none">BayesNets.permutecols!</code></pre><pre><code class="language-none">BayesNets.pool</code></pre><pre><code class="language-none">BayesNets.pool!</code></pre><pre><code class="language-none">BayesNets.probs</code></pre><pre><code class="language-none">BayesNets.probval</code></pre><pre><code class="language-none">BayesNets.qqbuild</code></pre><pre><code class="language-none">BayesNets.quantile</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.rand_bn_inference" href="#BayesNets.rand_bn_inference"><code>BayesNets.rand_bn_inference</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand_bn_inference(bn, num_query=2, num_evidence=3)</code></pre><p>Generate a random inference state for a Bayesian Network with an evidence assignment sample uniformly over the chosen nodes&#39; domain.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.rand_cpd" href="#BayesNets.rand_cpd"><code>BayesNets.rand_cpd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand_cpd(bn::DiscreteBayesNet, ncategories::Int, target::NodeName, parents::NodeNames=NodeName[])</code></pre><p>Return a CategoricalCPD with the given number of categories with random categorical distributions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.rand_discrete_bn" href="#BayesNets.rand_discrete_bn"><code>BayesNets.rand_discrete_bn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand_discrete_bn(num_nodes16, max_num_parents=3,
        max_num_states=5, connected=true)</code></pre><p>Generate a random DiscreteBayesNet.</p><p>Creates DiscreteBayesNet with <code>num_nodes</code> nodes, with each node having a random number of states and parents, up to <code>max_num_parents</code> and <code>max_num_parents</code>, respectively. If <code>connected</code>, each node (except the first) will be guaranteed at least one parent, making the graph connected.</p></div></div></section><pre><code class="language-none">BayesNets.rate</code></pre><pre><code class="language-none">BayesNets.readtable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.readxdsl" href="#BayesNets.readxdsl"><code>BayesNets.readxdsl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readxdsl( filename::AbstractString )</code></pre><p>Return a DiscreteBayesNet read from the xdsl file</p></div></div></section><pre><code class="language-none">BayesNets.recode</code></pre><pre><code class="language-none">BayesNets.recode!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.reducedim" href="#BayesNets.reducedim"><code>BayesNets.reducedim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reducedim(op, ϕ, dims, [v0])</code></pre><p>Reduce dimensions <code>dims</code> in <code>ϕ</code> using function <code>op</code>.</p></div></div></section><pre><code class="language-none">BayesNets.reducedim!</code></pre><pre><code class="language-none">BayesNets.rename</code></pre><pre><code class="language-none">BayesNets.rename!</code></pre><pre><code class="language-none">BayesNets.required_func</code></pre><pre><code class="language-none">BayesNets.sample</code></pre><pre><code class="language-none">BayesNets.sample!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.sample_posterior!" href="#BayesNets.sample_posterior!"><code>BayesNets.sample_posterior!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>set a[varname] ~ P(varname | not varname)</p><p>Modifies a and caches in gss</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.sample_posterior_continuous!" href="#BayesNets.sample_posterior_continuous!"><code>BayesNets.sample_posterior_continuous!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements Metropolis-Hastings with a normal distribution proposal with mean equal to the previous value of the variable &quot;varname&quot; and stddev equal to 10 times the standard deviation of the distribution of the target variable given its parents ( var_distribution should be get(bn, varname)(a) )</p><p>MH will go through nsamples iterations.  If no proposal is accepted, the original value will remain</p><p>This function expects that a[varname] is within the support of the distribution, it will not check to make sure this is true</p><p>Helper to sample_posterior Should only be used to sampling continuous distributions</p><p>set a[varname] ~ P(varname | not varname)</p><p>Modifies a and caches in gss</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.sample_posterior_finite!" href="#BayesNets.sample_posterior_finite!"><code>BayesNets.sample_posterior_finite!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Helper to sample_posterior Should only be called if the variable associated with varname is discrete</p><p>set a[varname] ~ P(varname | not varname)</p><p>Modifies both a and gss</p></div></div></section><pre><code class="language-none">BayesNets.sample_weighted_dataframe</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.sample_weighted_dataframe!" href="#BayesNets.sample_weighted_dataframe!"><code>BayesNets.sample_weighted_dataframe!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Chooses a sample at random from a weighted dataframe</p></div></div></section><pre><code class="language-none">BayesNets.sampler</code></pre><pre><code class="language-none">BayesNets.scale</code></pre><pre><code class="language-none">BayesNets.scale!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.score_component" href="#BayesNets.score_component"><code>BayesNets.score_component</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">score_component(a::ScoringFunction, cpd::CPD, data::DataFrame)</code></pre><p>Extract a Float64 score for a cpd given the data. One seeks to maximize the score.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.score_components" href="#BayesNets.score_components"><code>BayesNets.score_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">score_components(a::ScoringFunction, cpd::CPD, data::DataFrame)
score_components(a::ScoringFunction, cpds::Vector{CPD}, data::DataFrame, cache::ScoreComponentCache)</code></pre><p>Get a list of score components for all cpds</p></div></div></section><pre><code class="language-none">BayesNets.setindex!</code></pre><pre><code class="language-none">BayesNets.shape</code></pre><pre><code class="language-none">BayesNets.show</code></pre><pre><code class="language-none">BayesNets.showall</code></pre><pre><code class="language-none">BayesNets.showcols</code></pre><pre><code class="language-none">BayesNets.singleton_dimension_error</code></pre><pre><code class="language-none">BayesNets.skewness</code></pre><pre><code class="language-none">BayesNets.span</code></pre><pre><code class="language-none">BayesNets.sqmahal</code></pre><pre><code class="language-none">BayesNets.sqmahal!</code></pre><pre><code class="language-none">BayesNets.stack</code></pre><pre><code class="language-none">BayesNets.stackdf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.statistics" href="#BayesNets.statistics"><code>BayesNets.statistics</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">statistics(
    targetind::Int,
    parents::AbstractVector{Int},
    ncategories::AbstractVector{Int},
    data::AbstractMatrix{Int}
    )</code></pre><p>outputs a sufficient statistics table for the target variable that is r × q where r = ncategories[i] is the number of variable instantiations and q is the number of parental instantiations of variable i</p><p>The r-values are ordered from 1 → ncategories[i] The q-values are ordered in the same ordering as ind2sub() in Julia Base     Thus the instantiation of the first parent (by order given in parents[i])     is varied the fastest.</p><p>ex:     Variable 1 has parents 2 and 3, with r₁ = 2, r₂ = 2, r₃ = 3     q for variable 1 is q = r₂×r₃ = 6     N will be a 6×2 matrix where:         N[1,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 1         N[2,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 1         N[3,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 2         N[4,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 2         N[5,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 3         N[6,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 3         N[6,2] is the number of time v₁ = 2, v₂ = 1, v₃ = 1         ...</p></div></div><div><div><pre><code class="language-none">statistics(
    parent_list::Vector{Vector{Int}},
    ncategories::AbstractVector{Int},
    data::AbstractMatrix{Int},
    )</code></pre><p>Computes sufficient statistics from a discrete dataset for a Discrete Bayesian Net structure</p><p>INPUT:     parents:         list of lists of parent indices         A variable with index i has ncategories[i]         and row in data[i,:]         No acyclicity checking is done     ncategories:         list of variable bin counts, or number of         discrete values the variable can take on, v ∈ {1 : ncategories[i]}     data:         table of discrete values [n×m]         where n is the number of nodes         and m is the number of samples</p><p>OUTPUT:     N :: Vector{Matrix{Int}}         a sufficient statistics table for each variable         Variable with index i has statistics table N[i],         which is r × q where         r = ncategories[i] is the number of variable instantiations and         q is the number of parental instantiations of variable i</p><pre><code class="language-none">    The r-values are ordered from 1 → ncategories[i]
    The q-values are ordered in the same ordering as ind2sub() in Julia Base
        Thus the instantiation of the first parent (by order given in parents[i])
        is varied the fastest.

    ex:
        Variable 1 has parents 2 and 3, with r₁ = 2, r₂ = 2, r₃ = 3
        q for variable 1 is q = r₂×r₃ = 6
        N[1] will be a 6×2 matrix where:
            N[1][1,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 1
            N[1][2,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 1
            N[1][3,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 2
            N[1][4,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 2
            N[1][5,1] is the number of time v₁ = 1, v₂ = 1, v₃ = 3
            N[1][6,1] is the number of time v₁ = 1, v₂ = 2, v₃ = 3
            N[1][6,2] is the number of time v₁ = 2, v₂ = 1, v₃ = 1
            ...</code></pre><p>This function uses sparse matrix black magic and was mercilessly stolen from Ed Schmerling.</p></div></div></section><pre><code class="language-none">BayesNets.std</code></pre><pre><code class="language-none">BayesNets.stdlogx</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.CPDs.strip_arg" href="#BayesNets.CPDs.strip_arg"><code>BayesNets.CPDs.strip_arg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strip_arg(arg::Symbol)</code></pre><p>Strip anything extra (type annotations, default values, etc) from an argument. For now this cannot handle keyword arguments (it will throw an error).</p></div></div></section><pre><code class="language-none">BayesNets.sub</code></pre><pre><code class="language-none">BayesNets.sub2ind_vec</code></pre><pre><code class="language-none">BayesNets.succprob</code></pre><pre><code class="language-none">BayesNets.suffstats</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.sumout" href="#BayesNets.sumout"><code>BayesNets.sumout</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sumout(t, v)</code></pre><p>Table marginalization</p></div></div></section><pre><code class="language-none">BayesNets.support</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BayesNets.table" href="#BayesNets.table"><code>BayesNets.table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">table(bn::DiscreteBayesNet, name::NodeName)</code></pre><p>Constructs the CPD factor associated with the given node in the BayesNet</p></div></div></section><pre><code class="language-none">BayesNets.tail</code></pre><pre><code class="language-none">BayesNets.test_distr</code></pre><pre><code class="language-none">BayesNets.test_samples</code></pre><pre><code class="language-none">BayesNets.uncompact</code></pre><pre><code class="language-none">BayesNets.unique!</code></pre><pre><code class="language-none">BayesNets.unstack</code></pre><pre><code class="language-none">BayesNets.values</code></pre><pre><code class="language-none">BayesNets.var</code></pre><pre><code class="language-none">BayesNets.varlogx</code></pre><pre><code class="language-none">BayesNets.vcat</code></pre><pre><code class="language-none">BayesNets.writetable</code></pre><pre><code class="language-none">BayesNets.wsample</code></pre><pre><code class="language-none">BayesNets.wsample!</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
