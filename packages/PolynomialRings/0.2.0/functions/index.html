<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · PolynomialRings.jl</title><link rel="canonical" href="http://tkluck.github.io/PolynomialRings.jl/stable/functions/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PolynomialRings.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../design-goals/">Design Goals</a></li><li><a class="toctext" href="../other-packages/">Other packages</a></li><li class="current"><a class="toctext" href>Types and Functions</a><ul class="internal"><li><a class="toctext" href="#Entry-points-1">Entry points</a></li><li><a class="toctext" href="#Arithmetic-1">Arithmetic</a></li></ul></li><li><a class="toctext" href="../reference/">Reference Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Types and Functions</a></li></ul></nav><hr/><div id="topbar"><span>Types and Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Types-and-Functions-1" href="#Types-and-Functions-1">Types and Functions</a></h1><h2><a class="nav-anchor" id="Entry-points-1" href="#Entry-points-1">Entry points</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.EntryPoints.@ring!" href="#PolynomialRings.EntryPoints.@ring!"><code>PolynomialRings.EntryPoints.@ring!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@ring! ℚ[x,y]</code></pre><p>Define and return the specified polynomial ring, and bind the variable names to its generators.</p><p>Currently, the supported rings are: ℚ (<code>Rational{BigInt}</code>), ℤ (<code>BigInt</code>), ℝ (<code>BigFloat</code>) and ℂ (<code>Complex{BigFloat}</code>).</p><p>Note: <code>@ring!</code> returns the ring and injects the variables. The macro <code>@ring</code> only returns the ring.</p><p>If you need different coefficient rings, or need to specify a non-default monomial order or exponent integer type, use <code>polynomial_ring</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; @ring! ℚ[x,y];

julia&gt; x^3 + y
x^3 + y</code></pre><p><strong>See also</strong></p><p><code>polynomial_ring</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.EntryPoints.@ring" href="#PolynomialRings.EntryPoints.@ring"><code>PolynomialRings.EntryPoints.@ring</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@ring ℚ[x,y]</code></pre><p>Define and return the specified polynomial ring.</p><p>Currently, the supported rings are: ℚ (<code>Rational{BigInt}</code>), ℤ (<code>BigInt</code>), ℝ (<code>BigFloat</code>) and ℂ (<code>Complex{BigFloat}</code>).</p><p>Note: <code>@ring!</code> returns the ring and injects the variables into the surrounding scope. The macro <code>@ring</code> only returns the ring.</p><p>If you need different coefficient rings, or need to specify a non-default monomial order or exponent integer type, use <code>polynomial_ring</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; @ring ℚ[x,y]
ℚ[x,y]</code></pre><p><strong>See also</strong></p><p><code>polynomial_ring</code> <code>@ring!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.EntryPoints.@polyvar" href="#PolynomialRings.EntryPoints.@polyvar"><code>PolynomialRings.EntryPoints.@polyvar</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@polyvar var [var...]</code></pre><p>Define a polynomial ring in the given variables, and inject them into the surrounding scope.</p><p>This is equivalent to <code>@ring! Int[var...]</code>.</p><p>If you need different coefficient rings, or need to specify a non-default monomial order or exponent integer type, use <code>@ring!</code> or <code>polynomial_ring</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; @polyvar x y;

julia&gt; x + 3y
x + 3*y

julia&gt; @polyvar ε[];

julia&gt; 1 + ε()*x + ε()*y
ε[1]*x + ε[2]*y + 1</code></pre><p><strong>See also</strong></p><p><code>polynomial_ring</code> <code>@ring!</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.EntryPoints.@polynomial" href="#PolynomialRings.EntryPoints.@polynomial"><code>PolynomialRings.EntryPoints.@polynomial</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@polynomial x^3 + 3x^2 + 3x + 1</code></pre><p>Create a multi-variate polynomial from an expression by creating the ring generated by all symbols appearing in the expression.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; @polynomial x^3 + x^2*y + x*y^2 + y^3
x^3 + x^2*y + x*y^2 + y^3

julia&gt; @polynomial x^3 + x^2*y + x*y^2 + y^3
x^3 + x^2*y + x*y^2 + y^3</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In general, you cannot use variables from outside the macro expression; all symbols are interpreted as variables. For example:</p><pre><code class="language-none">d = 4
@polynomial d*x</code></pre><p>will give a polynomial in two variables, <code>d</code> and <code>x</code>.</p><p>As a special exception, exponents are not interpreted, so</p><pre><code class="language-none">@polynomial(x^d) == @polynomial(x)^d</code></pre><p>Unfortunately/confusingly, together, this gives</p><pre><code class="language-none">@polynomial(d*x^(d-1))</code></pre><p>will have <code>d-1</code> interpreting <code>d</code> as an outer variable, and <code>d*x</code> is a monomial.</p><p>This behaviour may (should?) change.</p></div></div><p><strong>See also</strong></p><p><code>@ring</code>, <code>polynomial_ring</code>, <code>convert(R, symbol)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Polynomials.polynomial_ring" href="#PolynomialRings.Polynomials.polynomial_ring"><code>PolynomialRings.Polynomials.polynomial_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">polynomial_ring(symbols::Symbol...; basering=Rational{BigInt}, exptype=Int16, monomialorder=:degrevlex)</code></pre><p>Create a type for the polynomial ring over <code>basering</code> in variables with names specified by <code>symbols</code>, and return the type and a tuple of these variables.</p><p>The <code>exptype</code> parameter defines the integer type for the exponents.</p><p>The <code>monomialorder</code> defines an order for the monomials for e.g. Gröbner basis computations; it also defines the internal sort order. Built-in values are <code>:degrevlex</code>, <code>:deglex</code> and <code>:lex</code>. This function will accept any symbol, though, and you can define your own monomial order by implementing</p><pre><code class="language-none">Base.Order.lt(::MonomialOrder{:myorder}, a::M, b::M) where M &lt;: AbstractMonomial</code></pre><p>See <code>PolynomialRings.MonomialOrderings</code> for examples.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y,z) = polynomial_ring(:x, :y, :z);

julia&gt; x*y + z
x*y + z</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.EntryPoints.formal_coefficients" href="#PolynomialRings.EntryPoints.formal_coefficients"><code>PolynomialRings.EntryPoints.formal_coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">formal_coefficients(R, name::Symbol)</code></pre><p>Return an object representing formal coefficients for the polynomial ring <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x];


julia&gt; c = formal_coefficients(R, :c);


julia&gt; c[1:3]
3-element Array{ℤ[c[]][x],1}:
 c[1]
 c[2]
 c[3]

julia&gt; [c()*x^2 + c()*x + c() , c()*x^2 + c()*x + c()]
2-element Array{ℤ[c[]][x],1}:
 c[1]*x^2 + c[2]*x + c[3]
 c[4]*x^2 + c[5]*x + c[6]</code></pre></div></div></section><h2><a class="nav-anchor" id="Arithmetic-1" href="#Arithmetic-1">Arithmetic</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rem" href="#Base.rem"><code>Base.rem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f_red = rem(f, G)</code></pre><p>Return the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>. By definition, this means that no leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f_red + factors * G == f</code> for some factors.</p><p>If you need to obtain the vector of factors, use <code>divrem</code> instead.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; rem(x^2 + 1, [x-im])
0

julia&gt; rem(x^2 + y^2 + 1, [x, y])
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">factors, f_red = divrem(f, G)</code></pre><p>Return the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>, together with  row vector of factors. By definition, this means that no leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f_red + factors * G == f</code>.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; divrem(x^2 + 1, [x-im])
(Complex{Int64}[x,y][x + 0 + 1im], 0)

julia&gt; divrem(x^2 + y^2 + 1, [x, y])
(Complex{Int64}[x,y][x y], 1 + 0im)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.diff" href="#Base.diff"><code>Base.diff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diff(polynomial, variable)</code></pre><p>Return the derivative of <code>polynomial</code> w.r.t. <code>variable</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; diff(x^3, :x)
3*x^2

julia&gt; diff(x^3, :y)
0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.div!" href="#PolynomialRings.div!"><code>PolynomialRings.div!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">factors = div!(f, G)</code></pre><p>Compute the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>, in-place. By definition, this means that after applying <code>rem!</code> no, leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f + factors * G</code> is equal to the original value of <code>f</code>.</p><p>The return value is <code>nothing</code> if no reduction has taken place. This situation could also be represented by the zero vector, but we choose <code>nothing</code> for efficiency.</p><p>If you want to allow clearing denominators, e.g. reduce <code>2x^2</code> by <code>3x</code> even though your base ring is ℤ, use <code>xdiv!</code> instead.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; f = x^2 + 1 + 0im
x^2 + 1 + 0im

julia&gt; collect(div!(f, [x-im]))
1×1 Array{Complex{Int64}[x,y],2}:
 x + 0 + 1im

julia&gt; f
0

julia&gt; g = x^2 + y^2 + 1
x^2 + y^2 + 1 + 0im

julia&gt; collect(div!(g, [x, y]))
1×2 Array{Complex{Int64}[x,y],2}:
 x  y

julia&gt; g
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.rem!" href="#PolynomialRings.rem!"><code>PolynomialRings.rem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">any_reductions = rem!(f, G)</code></pre><p>Compute the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>, in-place. By definition, this means that after applying <code>rem!</code> no, leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f + factors * G</code> is equal to the original value of <code>f</code> for some row vector <code>factors</code>.</p><p>The return value <code>any_reductions</code> is <code>true</code> if and only if <code>factors</code> is nonzero. Note that <code>factors</code> itself is not actually computed and not returned. If you need to obtain it, use <code>div!</code>.</p><p>If you want to allow clearing denominators, e.g. reduce <code>2x^2</code> by <code>3x</code> even though your base ring is ℤ, use <code>xrem!</code> instead.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; f = x^2 + 1
x^2 + 1 + 0im

julia&gt; rem!(f, [x-im])
true

julia&gt; f
0

julia&gt; g = x^2 + y^2 + 1
x^2 + y^2 + 1 + 0im

julia&gt; rem!(g, [x, y])
true

julia&gt; g
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.xrem" href="#PolynomialRings.xrem"><code>PolynomialRings.xrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f_red = xrem(f, G)</code></pre><p>Return the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>. By definition, this means that no leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f_red + factors * G == m * f</code> for some factors and for some integer <code>m</code>.</p><p>If you need to obtain the vector of factors, use <code>xdivrem</code> instead.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; xrem(x^2 + 1, [x-im])
0

julia&gt; xrem(x^2 + y^2 + 1, [x, y])
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.xdiv!" href="#PolynomialRings.xdiv!"><code>PolynomialRings.xdiv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">m, factors = xdiv!(f, G)</code></pre><p>Compute the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>, in-place. By definition, this means that after applying <code>rem!</code> no, leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f + factors * G</code> is equal to <code>m</code> times the original value of <code>f</code>.</p><p>The difference between <code>xdiv!</code> and <code>div</code> is that the former allows clearing denominators, e.g. reduce <code>2x^2</code> by <code>3x</code> even when the base ring is ℤ.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; f = x^2 + y^2 + 1
x^2 + y^2 + 1 + 0im

julia&gt; xdiv!(f, [x-im])
(1 + 0im, Complex{Int64}[x,y][x + 0 + 1im])

julia&gt; f
y^2

julia&gt; g = x^2 + y^2 + 1
x^2 + y^2 + 1 + 0im

julia&gt; xdiv!(g, [x, y])
(1 + 0im, Complex{Int64}[x,y][x y])

julia&gt; g
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.xrem!" href="#PolynomialRings.xrem!"><code>PolynomialRings.xrem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">any_reductions = xrem!(f, G)</code></pre><p>Compute the multivariate reduction of a polynomial <code>f</code> by a vector of polynomials <code>G</code>, in-place. By definition, this means that after applying <code>rem!</code> no, leading term of a polynomial in <code>G</code> divides any monomial in <code>f</code>, and <code>f + factors * G</code> is equal to <code>m</code> times the original value of <code>f</code> for some scalar <code>m</code> and for some row vector <code>factors</code>.</p><p>The return value <code>any_reductions</code> is <code>true</code> if and only if <code>factors</code> is nonzero. Note that <code>factors</code> itself is not actually computed and not returned. If you need to obtain it, use <code>xdiv!</code>. The same holds for <code>m</code>.</p><p>The difference between <code>xdiv!</code> and <code>div</code> is that the former allows clearing denominators, e.g. reduce <code>2x^2</code> by <code>3x</code> even when the base ring is ℤ.</p><p><strong>Examples</strong></p><p>In one variable, this is just the normal Euclidean algorithm:</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R,(x,y) = polynomial_ring(:x, :y, basering=Complex{Int});

julia&gt; f = x^2 + 1
x^2 + 1 + 0im

julia&gt; xrem!(f, [x-im])
true

julia&gt; f
0

julia&gt; g = x^2 + y^2 + 1
x^2 + y^2 + 1 + 0im

julia&gt; xrem!(g, [x, y])
true

julia&gt; g
1 + 0im</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Operators.map_coefficients" href="#PolynomialRings.Operators.map_coefficients"><code>PolynomialRings.Operators.map_coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">p = map_coefficients(f, q)</code></pre><p>Apply a function <code>f</code> to all coefficients of <code>q</code>, and return the result.</p></div></div></section><h3><a class="nav-anchor" id="Monomial-orderings-1" href="#Monomial-orderings-1">Monomial orderings</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.MonomialOrderings.MonomialOrder" href="#PolynomialRings.MonomialOrderings.MonomialOrder"><code>PolynomialRings.MonomialOrderings.MonomialOrder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct MonomialOrder{Rule, Names} &lt;: Ordering end</code></pre><p>For implementing your own monomial order, do the following:</p><ol><li>Choose a symbol to represent it, say <code>:myorder</code></li><li><code>import Base.Order: lt</code></li><li><code>lt(::MonomialOrder{:myorder}, a::M, b::M) where M &lt;: AbstractMonomial = ...</code></li></ol><p>A few useful functions are <a href="@ref"><code>enumeratenz</code></a>, <a href="@ref"><code>index_union</code></a>, and <a href="@ref"><code>rev_index_union</code></a>. See <a href="@ref"><code>PolynomialRings.Monomials</code></a> and <a href="@ref"><code>PolynomialRings.MonomialOrderings</code></a> for details.</p><p>You can then create a ring that uses it by calling</p><pre><code class="language-none">R,vars = polynomial_ring(vars...; monomialorder=:myorder)</code></pre><p>There is no performance cost for using your own monomial order compared to a built-in one.</p></div></div></section><h3><a class="nav-anchor" id="Expansions,-coefficients,-collecting-monomials-1" href="#Expansions,-coefficients,-collecting-monomials-1">Expansions, coefficients, collecting monomials</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@expansion" href="#PolynomialRings.Expansions.@expansion"><code>PolynomialRings.Expansions.@expansion</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@expansion(f, var, [var...])</code></pre><p>Return a collection of (exponent tuple, coefficient) tuples decomposing f into its consituent parts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(@expansion(x^3 + y^2, y))
2-element Array{Tuple{Tuple{Int16},ℤ[x]},1}:
 ((0,), x^3)
 ((2,), 1)

julia&gt; collect(@expansion(x^3 + y^2, x, y))
2-element Array{Tuple{Tuple{Int16,Int16},BigInt},1}:
 ((0, 2), 1)
 ((3, 0), 1)</code></pre><p><strong>See also</strong></p><p><code>@expand</code>, <code>expansion(...)</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.expansion" href="#PolynomialRings.Expansions.expansion"><code>PolynomialRings.Expansions.expansion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expansion(f, symbol, [symbol...])</code></pre><p>Return a collection of (exponent_tuple, coefficient) tuples decomposing f into its consituent parts.</p><p>In the REPL, you likely want to use the friendlier version <code>@expansion</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(expansion(x^3 + y^2, :y))
2-element Array{Tuple{Tuple{Int16},ℤ[x]},1}:
 ((0,), x^3)
 ((2,), 1)

julia&gt; collect(expansion(x^3 + y^2, :x, :y))
2-element Array{Tuple{Tuple{Int16,Int16},BigInt},1}:
 ((0, 2), 1)
 ((3, 0), 1)</code></pre><p><strong>See also</strong></p><p><code>@expansion(...)</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@expand" href="#PolynomialRings.Expansions.@expand"><code>PolynomialRings.Expansions.@expand</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@expand(f, var, [var...])</code></pre><p>Return a collection of (monomial, coefficient) tuples decomposing f into its consituent parts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(@expand(x^3 + y^2, y))
2-element Array{Tuple{Int64[y],ℤ[x]},1}:
 (1, x^3)
 (y^2, 1)

julia&gt; collect(@expand(x^3 + y^2, x, y))
2-element Array{Tuple{Int64[x,y],BigInt},1}:
 (y^2, 1)
 (x^3, 1)</code></pre><p><strong>See also</strong></p><p><code>expansion(...)</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@coefficient" href="#PolynomialRings.Expansions.@coefficient"><code>PolynomialRings.Expansions.@coefficient</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@coefficient(f, monomial)</code></pre><p>Return a the coefficient of <code>f</code> at <code>monomial</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>monomial</code> needs to be a literal monomial; it cannot be a variable containing a monomial.  This macro has a rather naive parser that gets exponents and variable names from <code>monomial</code>.</p><p>This is considered a feature (not a bug) because it is only as a literal monomial that we can distinguish e.g. <code>x^4</code> from <code>x^4*y^0</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; @coefficient(x^3*y + x, x)
1

julia&gt; @coefficient(x^3*y + x, x^3)
y

julia&gt; @coefficient(x^3*y + x, x^3*y^0)
0

julia&gt; @coefficient(x^3*y + x, x^3*y^1)
1</code></pre><p><strong>See also</strong></p><p><code>coefficient</code>, <code>expansion</code> and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Terms.coefficient" href="#PolynomialRings.Terms.coefficient"><code>PolynomialRings.Terms.coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coefficient(f, exponent_tuple, symbol, [symbol...])</code></pre><p>Return a the coefficient of f at monomial. In the REPL, you likely want to use the friendlier version <code>@coefficient</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; coefficient(x^3*y + x, (1,), :x)
1

julia&gt; coefficient(x^3*y + x, (3,), :x)
y

julia&gt; coefficient(x^3*y + x, (3,0), :x, :y)
0

julia&gt; coefficient(x^3*y + x, (3,1), :x, :y)
1</code></pre><p><strong>See also</strong></p><p><code>@coefficient</code>, <code>expansion</code> and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@coefficients" href="#PolynomialRings.Expansions.@coefficients"><code>PolynomialRings.Expansions.@coefficients</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@coefficients(f, vars...)</code></pre><p>Return the coefficients of <code>f</code> when expanded as a polynomial in the given variables.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be literal variable names; it cannot be a variable containing it.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(@coefficients(x^3 + y^2, y))
2-element Array{ℤ[x],1}:
 x^3
 1

julia&gt; collect(@coefficients(x^3 + y^2, x, y))
2-element Array{BigInt,1}:
 1
 1</code></pre><p><strong>See also</strong></p><p><code>coefficients</code>, <code>@expansion</code>, <code>expansion</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.coefficients" href="#PolynomialRings.Expansions.coefficients"><code>PolynomialRings.Expansions.coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coefficients(f, symbol, [symbol...])</code></pre><p>Return the coefficients of <code>f</code> when expanded as a polynomial in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(coefficients(x^3 + y^2, :y))
2-element Array{ℤ[x],1}:
 x^3
 1

julia&gt; collect(coefficients(x^3 + y^2, :x, :y))
2-element Array{BigInt,1}:
 1
 1</code></pre><p><strong>See also</strong></p><p><code>@coefficients</code>, <code>@expansion</code>, <code>expansion</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@deg" href="#PolynomialRings.Expansions.@deg"><code>PolynomialRings.Expansions.@deg</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@deg(f, vars...)</code></pre><p>Return the total degree of <code>f</code> when expanded as a polynomial in the given variables.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be literal variable names; it cannot be a variable containing it.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; @deg (x^2 + x*y - 1) x
2

julia&gt; @deg (x^2 + x*y - 1) y
1</code></pre><p><strong>See also</strong></p><p><code>deg</code>, <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.deg" href="#PolynomialRings.Expansions.deg"><code>PolynomialRings.Expansions.deg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deg(f, vars...)</code></pre><p>Return the total degree of <code>f</code> when regarded as a polynomial in <code>vars</code>. Returns -1 for the zero polynomial.</p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; deg(x^2, :x)
2

julia&gt; deg(x^2, :x, :y)
2

julia&gt; deg(x^2, :y)
0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@linear_coefficients" href="#PolynomialRings.Expansions.@linear_coefficients"><code>PolynomialRings.Expansions.@linear_coefficients</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@linear_coefficient(f, vars...)
linear_coefficients(f, vars...)</code></pre><p>Return the linear coefficients of <code>f</code> as a function of <code>vars</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be symbols; e.g. they cannot be the polynomial <code>x</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; @linear_coefficients(x^3*y + x + y + 1, x)
1-element Array{ℤ[y],1}:
 1

julia&gt; @linear_coefficients(x^3*y + x + y + 1, x, y)
2-element Array{BigInt,1}:
 1
 1</code></pre><p><strong>See also</strong></p><p><code>@constant_coefficient</code>, <code>@coefficient</code>, and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.linear_coefficients" href="#PolynomialRings.Expansions.linear_coefficients"><code>PolynomialRings.Expansions.linear_coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linear_coefficients(f, vars...)</code></pre><p>Return the linear coefficients of <code>f</code> as a function of <code>vars</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be symbols; e.g. they cannot be the polynomial <code>x</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; linear_coefficients(x^3*y + x + y + 1, :x)
1-element Array{ℤ[y],1}:
 1

julia&gt; linear_coefficients(x^3*y + x + y + 1, :x, :y)
2-element Array{BigInt,1}:
 1
 1</code></pre><p><strong>See also</strong></p><p><code>@constant_coefficient</code>, <code>@coefficient</code>, and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.@constant_coefficient" href="#PolynomialRings.Expansions.@constant_coefficient"><code>PolynomialRings.Expansions.@constant_coefficient</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@constant_coefficient(f, vars...)</code></pre><p>Return the constant coefficient of <code>f</code> as a function of <code>vars</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be literal variable names; it cannot be a variable containing it.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; @constant_coefficient(x^3*y + x + y + 1, x)
y + 1

julia&gt; @constant_coefficient(x^3*y + x + y + 1, x, y)
1</code></pre><p><strong>See also</strong></p><p><code>constant_coefficient</code>, <code>@coefficient</code>, and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Expansions.constant_coefficient" href="#PolynomialRings.Expansions.constant_coefficient"><code>PolynomialRings.Expansions.constant_coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">constant_coefficient(f, vars...)</code></pre><p>Return the constant coefficient of <code>f</code> as a function of <code>vars</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>vars</code> need to be symbols; e.g. they cannot be the polynomial <code>x</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; constant_coefficient(x^3*y + x + y + 1, :x)
y + 1

julia&gt; constant_coefficient(x^3*y + x + y + 1, :x, :y)
1</code></pre><p><strong>See also</strong></p><p><code>@constant_coefficient</code>, <code>@coefficient</code>, and <code>@expansion</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Arrays.@flat_coefficients" href="#PolynomialRings.Arrays.@flat_coefficients"><code>PolynomialRings.Arrays.@flat_coefficients</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@flat_coefficients(a, var, [var...])</code></pre><p>Return the <em>polynomial</em> coefficients of the <em>matrix</em> coefficients of <code>a</code>, when those matrix coefficients are regarded as polynomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(flat_coefficients([x^3 + y^2; y^5], :y))
3-element Array{ℤ[x],1}:
 x^3
 1
 1

julia&gt; collect(flat_coefficients([x^3 + y^2, y^5], :x, :y))
3-element Array{BigInt,1}:
 1
 1
 1</code></pre><p><strong>See also</strong></p><p><code>flat_coefficients</code>, <code>@expansion</code>, <code>expansion</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Arrays.flat_coefficients" href="#PolynomialRings.Arrays.flat_coefficients"><code>PolynomialRings.Arrays.flat_coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flat_coefficients(a, symbol, [symbol...])</code></pre><p>Return the <em>polynomial</em> coefficients of the <em>matrix</em> coefficients of <code>a</code>, when those matrix coefficients are regarded as polynomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; collect(flat_coefficients([x^3 + y^2; y^5], :y))
3-element Array{ℤ[x],1}:
 x^3
 1
 1

julia&gt; collect(flat_coefficients([x^3 + y^2, y^5], :x, :y))
3-element Array{BigInt,1}:
 1
 1
 1</code></pre><p><strong>See also</strong></p><p><code>@coefficients</code>, <code>@expansion</code>, <code>expansion</code>, <code>@coefficient</code> and <code>coefficient</code></p></div></div></section><h3><a class="nav-anchor" id="Gröbner-basis-computations-1" href="#Gröbner-basis-computations-1">Gröbner basis computations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.gröbner_basis" href="#PolynomialRings.gröbner_basis"><code>PolynomialRings.gröbner_basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis = gröbner_basis(polynomials)</code></pre><p>Return a Gröbner basis for the ideal generated by <code>polynomials</code>.</p><p>This is computed using the GWV algorithm; see <a href="#PolynomialRings.GröbnerGWV.gwv"><code>PolynomialRings.GröbnerGWV.gwv</code></a> for details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.gröbner_transformation" href="#PolynomialRings.gröbner_transformation"><code>PolynomialRings.gröbner_transformation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis, transformation = gröbner_transformation(polynomials)</code></pre><p>Return a Gröbner basis for the ideal generated by <code>polynomials</code>, together with a <code>transformation</code> that proves that each element in <code>basis</code> is in that ideal (i.e. <code>basis == transformation * polynomials</code>).</p><p>This is computed using the GWV algorithm with a few standard optmizations; see <a href="#PolynomialRings.GröbnerGWV.gwv"><code>PolynomialRings.GröbnerGWV.gwv</code></a> for details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.syzygies" href="#PolynomialRings.syzygies"><code>PolynomialRings.syzygies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syz = syzygies(G)</code></pre><p>Return all relations between the elements of G.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using PolynomialRings

julia&gt; R = @ring! ℤ[x,y];

julia&gt; I = [x^5, x^2 + y, x*y + y^2];

julia&gt; G, tr = gröbner_transformation(I);

julia&gt; K = syzygies(G) * tr; # the kernel of the map R^3 -&gt; I induced by these generators

julia&gt; iszero(K * I)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.lift" href="#PolynomialRings.lift"><code>PolynomialRings.lift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">factors = lift(polynomials, y)</code></pre><p>Return a row vector of <code>factors</code> such that <code>factors * polynomials</code> is equal to <code>y</code>, or <code>nothing</code> if <code>y</code> is not in the ideal generated by <code>polynomials</code>.</p><p>This is computed using <code>gröbner_transformation</code>; see there for more information.</p><p>Note: if you need to compute many lifts for the same set of <code>polynomials</code>, it is beneficial to use <code>gröbner_transformation</code> yourself as it avoids re-doing the most computationally intensive part.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Solve.matrix_solve_affine" href="#PolynomialRings.Solve.matrix_solve_affine"><code>PolynomialRings.Solve.matrix_solve_affine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = matrix_solve_affine(f, y, dims, Type=eltype(y))</code></pre><p>Return the solution <code>x</code> to the equation</p><pre><code class="language-none">``f(x) = y``</code></pre><p>where <span>$x$</span> is assumed to be a matrix of size <code>dims</code>, and <code>f</code> is assumed to be a linear map over <code>Type</code>.</p><p>Note: I haven&#39;t really considered the proper semantics when type(x) is not necessarily equal to type(y), and the behaviour of this function may (will) change when I do.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.GröbnerGWV.gwv" href="#PolynomialRings.GröbnerGWV.gwv"><code>PolynomialRings.GröbnerGWV.gwv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gröbner_basis = gwv(monomialorder, polynomials)</code></pre><p>An implementation of the GWV algorithm as popularized by</p><blockquote><p>Shuhong Gao, Frank Volny, and Mingsheng Wang. &quot;A new algorithm for computing Groebner bases.&quot; IACR Cryptology ePrint Archive 2010 (2010): 641.</p></blockquote></div></div></section><h3><a class="nav-anchor" id="Internal-types-and-functions-1" href="#Internal-types-and-functions-1">Internal types and functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Monomials.AbstractMonomial" href="#PolynomialRings.Monomials.AbstractMonomial"><code>PolynomialRings.Monomials.AbstractMonomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractMonomial{Order}</code></pre><p>The abstract base type for multi-variate monomials.</p><p>Specifying a monomial is equivalent to specifying the exponents for all variables. The concrete type decides whether this happens as a tuple or as a (sparse or dense) array.</p><p>The type also encodes the monomial order, and as part of that, the names of the variables.</p><p>Each concrete implementation <code>M</code> should implement for elements <code>m</code>:</p><pre><code class="language-none">m[i]
nzindices(m)
_construct(M, i -&gt; exponent, nonzero_indices, [total_degree])
exptype(M)</code></pre><p>In addition, one may choose to add specific optimizations by overloading other functions, as well.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Monomials.TupleMonomial" href="#PolynomialRings.Monomials.TupleMonomial"><code>PolynomialRings.Monomials.TupleMonomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TupleMonomial{N, I, Order} &lt;: AbstractMonomial where I &lt;: Integer where Order</code></pre><p>An implementation of AbstractMonomial that stores exponents as a tuple of integers. This is a dense representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Monomials.VectorMonomial" href="#PolynomialRings.Monomials.VectorMonomial"><code>PolynomialRings.Monomials.VectorMonomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VectorMonomial{V,I,Order} &lt;: AbstractMonomial where V &lt;: AbstractVector{I} where I &lt;: Integer where Order</code></pre><p>An implementation of AbstractMonomial that stores exponents as a vector of integers. This can be a sparse or dense representation, depending on the type specialization.</p><p>This representation is intended for the case when the number of variables is unbounded. In particular, the indexing operation <code>m[i]</code> returns <code>0</code> when <code>i</code> is out-of-bounds, instead of throwing an exception.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Monomials.enumeratenz" href="#PolynomialRings.Monomials.enumeratenz"><code>PolynomialRings.Monomials.enumeratenz</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enumeratenz(monomial)</code></pre><p>Enumerate (i.e. return an iterator) for <code>(variable index, exponent)</code> tuples for <code>monomial</code>, where <code>exponent</code> is a structural nonzero (hence <code>nz</code>).</p><p>This means that, depending on implementation details, the variable indices with zero exponent <em>may</em> be skipped, but this is not guaranteed. In practice, this only happens if the storage format is sparse.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Terms.Term" href="#PolynomialRings.Terms.Term"><code>PolynomialRings.Terms.Term</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Term{M, C} where M &lt;: AbstractMonomial where C</code></pre><p>This type represents a single term of a multivariate polynomial: that is, it represents the combination of a coefficient and a monomial.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialRings.Polynomials.Polynomial" href="#PolynomialRings.Polynomials.Polynomial"><code>PolynomialRings.Polynomials.Polynomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Polynomial{T} where T &lt;: Term</code></pre><p>This type represents a polynomial as a vector of terms. All methods guarantee and assume that the vector is sorted by increasing monomial order (see <code>PolynomialRings.MonomialOrderings</code>).</p></div></div></section><footer><hr/><a class="previous" href="../other-packages/"><span class="direction">Previous</span><span class="title">Other packages</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference Index</span></a></footer></article></body></html>
