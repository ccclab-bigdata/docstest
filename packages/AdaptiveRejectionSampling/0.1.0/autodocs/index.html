<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · AdaptiveRejectionSampling.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AdaptiveRejectionSampling.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.AdaptiveRejectionSampling" href="#AdaptiveRejectionSampling.AdaptiveRejectionSampling"><code>AdaptiveRejectionSampling.AdaptiveRejectionSampling</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A log conconcave function is majorized with a piecewise envelop, which on the original scale is piecewise exponential. As the resulting extremely precise envelop adapts, the rejection rate dramatically decreases.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.Envelop" href="#AdaptiveRejectionSampling.Envelop"><code>AdaptiveRejectionSampling.Envelop</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Envelop(lines::Vector{Line}, support::Tuple{Float64, Float64})</code></pre><p>A piecewise linear function with k segments defined by the lines <code>L_1, ..., L_k</code> and cutpoints <code>c_1, ..., c_k+1</code> with <code>c1 = support[1]</code> and <code>c2 = support[2]</code>. A line L<em>k is active in the segment [c</em>k, c<em>k+1], and it&#39;s assigned a weight w</em>k based on <a href="@exp_integral">exp_integral</a>. The weighted integral over c<em>1 to c</em>k+1 is one, so that the envelop is interpreted as a density.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.Line" href="#AdaptiveRejectionSampling.Line"><code>AdaptiveRejectionSampling.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Line(slope::Float64, intercept::Float64)</code></pre><p>Basic ensamble-unit for an envelop.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.Objective" href="#AdaptiveRejectionSampling.Objective"><code>AdaptiveRejectionSampling.Objective</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Objective(logf::Function, support:)
Objective(logf::Function, grad::Function)</code></pre><p>Convenient structure to store the objective function to be sampled. It must receive the logarithm of f and not f directly. It uses automatic differentiation by default, but the user can provide the derivative optionally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.RejectionSampler" href="#AdaptiveRejectionSampling.RejectionSampler"><code>AdaptiveRejectionSampling.RejectionSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RejectionSampler(f::Function, support::Tuple{Float64, Float64}[ ,δ::Float64])
RejectionSampler(f::Function, support::Tuple{Float64, Float64}, init::Tuple{Float64, Float64})</code></pre><p>An adaptive rejection sampler to obtain iid samples from a logconcave function <code>f</code>, supported in the domain <code>support</code> = (support[1], support[2]). To create the object, two initial points <code>init = init[1], init[2]</code> such that <code>loff&#39;(init[1]) &gt; 0</code> and <code>logf&#39;(init[2]) &lt; 0</code> are necessary. If they are not provided, the constructor will perform a greedy search based on <code>δ</code>.</p><p>The argument <code>support</code> must be of the form <code>(-Inf, Inf), (-Inf, a), (b, Inf), (a,b)</code>, and it represent the interval in which f has positive value, and zero elsewhere.</p><p><strong>Keyword arguments</strong></p><ul><li><code>max_segments::Int = 10</code> : max size of envelop, the rejection-rate is usually slow with a small number of segments</li><li><code>max_failed_factor::Float64 = 0.001</code>: level at which throw an error if one single sample has a rejection rate   exceeding this value</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.add_segment!" href="#AdaptiveRejectionSampling.add_segment!"><code>AdaptiveRejectionSampling.add_segment!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_segment!(e::Envelop, l::Line)</code></pre><p>Adds a new line segment to an envelop based on the value of its slope (slopes must be decreasing always in the envelop). The cutpoints are automatically determined by intersecting the line with the adjacent lines.</p></div></div></section><pre><code class="language-none">AdaptiveRejectionSampling.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.eval_envelop" href="#AdaptiveRejectionSampling.eval_envelop"><code>AdaptiveRejectionSampling.eval_envelop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eval_envelop(e::Envelop, x::Float64)</code></pre><p>Eval point a point <code>x</code> in the piecewise linear function defined by <code>e</code>. Necessary for evaluating the density assigned to the point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.exp_integral" href="#AdaptiveRejectionSampling.exp_integral"><code>AdaptiveRejectionSampling.exp_integral</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">exp_integral(l::Line, x1::Float64, x2::Float64)</code></pre><p>Computes the integral     <span>$LaTeX \int_{x_1} ^ {x_2} \exp\{ax + b\} dx.$</span> The resulting value is the weight assigned to the segment [x1, x2] in the envelop</p></div></div></section><pre><code class="language-none">AdaptiveRejectionSampling.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.intersection" href="#AdaptiveRejectionSampling.intersection"><code>AdaptiveRejectionSampling.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersection(l1::Line, l2::Line)</code></pre><p>Finds the horizontal coordinate of the intersection between lines</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.run_sampler!" href="#AdaptiveRejectionSampling.run_sampler!"><code>AdaptiveRejectionSampling.run_sampler!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">run_sampler!(sampler::RejectionSampler, n::Int)</code></pre><p>It draws <code>n</code> iid samples of the objective function of <code>sampler</code>, and at each iteration it adapts the envelop of <code>sampler</code> by adding new segments to its envelop.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdaptiveRejectionSampling.sample_envelop" href="#AdaptiveRejectionSampling.sample_envelop"><code>AdaptiveRejectionSampling.sample_envelop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample_envelop(p::Envelop)</code></pre><p>Samples an element from the density defined by the envelop <code>e</code> with it&#39;s exponential weights. See <a href="@Envelop"><code>Envelop</code></a> for details.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
