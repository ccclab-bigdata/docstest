<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Interpolations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interpolations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#General-usage-1">General usage</a></li><li><a class="toctext" href="#Control-of-interpolation-algorithm-1">Control of interpolation algorithm</a></li><li><a class="toctext" href="#Extrapolation-1">Extrapolation</a></li><li><a class="toctext" href="#Performance-shootout-1">Performance shootout</a></li><li><a class="toctext" href="#Contributing-1">Contributing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interpolations-1" href="#Interpolations-1">Interpolations</a></h1><p><a href="https://travis-ci.org/tlycken/Interpolations.jl"><img src="https://travis-ci.org/tlycken/Interpolations.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://pkg.julialang.org/?pkg=Interpolations"><img src="http://pkg.julialang.org/badges/Interpolations_0.4.svg" alt="PkgEval Status"/></a> <a href="http://pkg.julialang.org/?pkg=Interpolations"><img src="http://pkg.julialang.org/badges/Interpolations_0.5.svg" alt="Interpolations"/></a></p><p>This package implements a variety of interpolation schemes for the Julia langauge.  It has the goals of ease-of-use, broad algorithmic support, and exceptional performance.</p><p>This package is still relatively new. Currently its support is best for <a href="https://en.wikipedia.org/wiki/B-spline">B-splines</a> and also supports irregular grids.  However, the API has been designed with intent to support more options. Pull-requests are more than welcome! It should be noted that the API may continue to evolve over time.</p><p>Other interpolation packages for Julia include:</p><ul><li><a href="https://github.com/timholy/Grid.jl">Grid.jl</a> (the predecessor of this package)</li><li><a href="https://github.com/kbarbary/Dierckx.jl">Dierckx.jl</a></li><li><a href="https://github.com/sisl/GridInterpolations.jl">GridInterpolations.jl</a></li><li><a href="https://github.com/floswald/ApproXD.jl">ApproXD.jl</a></li></ul><p>Some of these packages support methods that <code>Interpolations</code> does not, so if you can&#39;t find what you need here, check one of them or submit a pull request here.</p><p>At the bottom of this page, you can find a &quot;performance shootout&quot; among these methods (as well as SciPy&#39;s <code>RegularGridInterpolator</code>).</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Just</p><pre><code class="language-none">Pkg.add(&quot;Interpolations&quot;)</code></pre><p>from the Julia REPL.</p><h2><a class="nav-anchor" id="General-usage-1" href="#General-usage-1">General usage</a></h2><p>Given an <code>AbstractArray</code> <code>A</code>, construct an &quot;interpolation object&quot; <code>itp</code> as</p><pre><code class="language-jl">itp = interpolate(A, options...)</code></pre><p>where <code>options...</code> (discussed below) controls the type of interpolation you want to perform.  This syntax assumes that the samples in <code>A</code> are equally-spaced. </p><p>To evaluate the interpolation at position <code>(x, y, ...)</code>, simply do</p><pre><code class="language-jl">v = itp[x, y, ...]</code></pre><p>Some interpolation objects support computation of the gradient, which can be obtained as</p><pre><code class="language-jl">g = gradient(itp, x, y, ...)</code></pre><p>or, if you&#39;re evaluating the gradient repeatedly, a somewhat more efficient option is</p><pre><code class="language-jl">gradient!(g, itp, x, y, ...)</code></pre><p>where <code>g</code> is a pre-allocated vector.</p><p>Some interpolation objects support computation of the hessian, which can be obtained as</p><pre><code class="language-jl">h = hessian(itp, x, y, ...)</code></pre><p>or, if you&#39;re evaluating the hessian repeatedly, a somewhat more efficient option is</p><pre><code class="language-jl">hessian!(h, itp, x, y, ...)</code></pre><p>where <code>h</code> is a pre-allocated matrix.</p><p><code>A</code> may have any element type that supports the operations of addition and multiplication.  Examples include scalars like <code>Float64</code>, <code>Int</code>, and <code>Rational</code>, but also multi-valued types like <code>RGB</code> color vectors.</p><p>Positions <code>(x, y, ...)</code> are n-tuples of numbers. Typically these will be real-valued (not necessarily integer-valued), but can also be of types such as <a href="https://github.com/JuliaDiff/DualNumbers.jl">DualNumbers</a> if you want to verify the computed value of gradients. You can also use Julia&#39;s iterator objects, e.g.,</p><pre><code class="language-jl">function ongrid!(dest, itp)
    for I in CartesianRange(size(itp))
        dest[I] = itp[I]
    end
end</code></pre><p>would store the on-grid value at each grid point of <code>itp</code> in the output <code>dest</code>. Finally, courtesy of Julia&#39;s indexing rules, you can also use</p><pre><code class="language-jl">fine = itp[linspace(1,10,1001), linspace(1,15,201)]</code></pre><h2><a class="nav-anchor" id="Control-of-interpolation-algorithm-1" href="#Control-of-interpolation-algorithm-1">Control of interpolation algorithm</a></h2><h3><a class="nav-anchor" id="BSplines-1" href="#BSplines-1">BSplines</a></h3><p>The interpolation type is described in terms of <em>degree</em>, <em>grid behavior</em> and, if necessary, <em>boundary conditions</em>. There are currently three degrees available: <code>Constant</code>, <code>Linear</code>, <code>Quadratic</code>,  and <code>Cubic</code> corresponding to B-splines of degree 0, 1, 2, and 3 respectively.</p><p>You also have to specify what <em>grid representation</em> you want. There are currently two choices: <code>OnGrid</code>, in which the supplied data points are assumed to lie <em>on</em> the boundaries of the interpolation interval, and <code>OnCell</code> in which the data points are assumed to lie on half-intervals between cell boundaries.</p><p>B-splines of quadratic or higher degree require solving an equation system to obtain the interpolation coefficients, and for that you must specify a <em>boundary condition</em> that is applied to close the system. The following boundary conditions are implemented: <code>Flat</code>, <code>Line</code> (alternatively, <code>Natural</code>), <code>Free</code>, <code>Periodic</code> and <code>Reflect</code>; their mathematical implications are described in detail in the pdf document under <code>/doc/latex</code>.</p><p>Some examples:</p><pre><code class="language-jl"># Nearest-neighbor interpolation
itp = interpolate(a, BSpline(Constant()), OnCell())
v = itp[5.4]   # returns a[5]

# (Multi)linear interpolation
itp = interpolate(A, BSpline(Linear()), OnGrid())
v = itp[3.2, 4.1]  # returns 0.9*(0.8*A[3,4]+0.2*A[4,4]) + 0.1*(0.8*A[3,5]+0.2*A[4,5])

# Quadratic interpolation with reflecting boundary conditions
# Quadratic is the lowest order that has continuous gradient
itp = interpolate(A, BSpline(Quadratic(Reflect())), OnCell())

# Linear interpolation in the first dimension, and no interpolation (just lookup) in the second
itp = interpolate(A, (BSpline(Linear()), NoInterp()), OnGrid())
v = itp[3.65, 5]  # returns  0.35*A[3,5] + 0.65*A[4,5]</code></pre><p>There are more options available, for example:</p><pre><code class="language-jl"># In-place interpolation
itp = interpolate!(A, BSpline(Quadratic(InPlace())), OnCell())</code></pre><p>which destroys the input <code>A</code> but also does not need to allocate as much memory.</p><h3><a class="nav-anchor" id="Gridded-interpolation-1" href="#Gridded-interpolation-1">Gridded interpolation</a></h3><p>These use a very similar syntax to BSplines, with the major exception being that one does not get to choose the grid representation (they are all <code>OnGrid</code>). As such one must specify a set of coordinate arrays defining the knots of the array.</p><p>In 1D</p><pre><code class="language-jl">A = rand(20)
A_x = collect(1.0:2.0:40.0)
knots = (A_x,)
itp = interpolate(knots, A, Gridded(Linear()))
itp[2.0] </code></pre><p>The spacing between adjacent samples need not be constant, you can use the syntax</p><pre><code class="language-jl">itp = interpolate(knots, A, options...)</code></pre><p>where <code>knots = (xknots, yknots, ...)</code> to specify the positions along each axis at which the array <code>A</code> is sampled for arbitrary (&quot;rectangular&quot;) samplings.</p><p>For example:</p><pre><code class="language-jl">A = rand(8,20)
knots = ([x^2 for x = 1:8], [0.2y for y = 1:20])
itp = interpolate(knots, A, Gridded(Linear()))
itp[4,1.2]  # approximately A[2,6]</code></pre><p>One may also mix modes, by specifying a mode vector in the form of an explicit tuple:</p><pre><code class="language-jl">itp = interpolate(knots, A, (Gridded(Linear()),Gridded(Constant())))</code></pre><p>Presently there are only three modes for gridded:</p><pre><code class="language-jl">Gridded(Linear())</code></pre><p>whereby a linear interpolation is applied between knots,</p><pre><code class="language-jl">Gridded(Constant())</code></pre><p>whereby nearest neighbor interpolation is used on the applied axis,</p><pre><code class="language-jl">NoInterp</code></pre><p>whereby the coordinate of the selected input vector MUST be located on a grid point. Requests for off grid coordinates results in the throwing of an error.</p><h2><a class="nav-anchor" id="Extrapolation-1" href="#Extrapolation-1">Extrapolation</a></h2><p>The call to <code>extrapolate</code> defines what happens if you try to index into the interpolation object with coordinates outside of <code>[1, size(data,d)]</code> in any dimension <code>d</code>. The implemented boundary conditions are <code>Throw</code>, <code>Flat</code>, <code>Linear</code>, <code>Periodic</code> and <code>Reflect</code>, with more options planned. <code>Periodic</code> and <code>Reflect</code> require that there is a method of <code>Base.mod</code> that can handle the indices used.</p><h2><a class="nav-anchor" id="Performance-shootout-1" href="#Performance-shootout-1">Performance shootout</a></h2><p>In the <code>perf</code> directory, you can find a script that tests interpolation with several different packages.  We consider interpolation in 1, 2, 3, and 4 dimensions, with orders 0 (<code>Constant</code>), 1 (<code>Linear</code>), and 2 (<code>Quadratic</code>).  Methods include Interpolations <code>BSpline</code> (<code>IBSpline</code>) and <code>Gridded</code> (<code>IGridded</code>), methods from the <a href="https://github.com/timholy/Grid.jl">Grid.jl</a> package, methods from the <a href="https://github.com/kbarbary/Dierckx.jl">Dierckx.jl</a> package, methods from the <a href="https://github.com/sisl/GridInterpolations.jl">GridInterpolations.jl</a> package (<code>GI</code>), methods from the <a href="https://github.com/floswald/ApproXD.jl">ApproXD.jl</a> package, and methods from SciPy&#39;s <code>RegularGridInterpolator</code> accessed via <code>PyCall</code> (<code>Py</code>).  All methods are tested using an <code>Array</code> with approximately <code>10^6</code> elements, and the interpolation task is simply to visit each grid point.</p><p>First, let&#39;s look at the two B-spline algorithms, <code>IBspline</code> and <code>Grid</code>.  Here&#39;s a plot of the &quot;construction time,&quot; the amount of time it takes to initialize an interpolation object (smaller is better):</p><p><img src="perf/constructionB.png" alt="construction"/></p><p>The construction time is negligible until you get to second order (quadratic); that&#39;s because quadratic is the lowest order requiring the solution of tridiagonal systems upon construction.  The solvers used by Interpolations are much faster than the approach taken in Grid.</p><p>Now let&#39;s examine the interpolation performance.  Here we&#39;ll measure &quot;throughput&quot;, the number of interpolations performed per second (larger is better):</p><p><img src="perf/rateB.png" alt="throughput"/></p><p>Once again, Interpolations wins on every test, by a factor that ranges from 7 to 13.</p><p>Now let&#39;s look at the &quot;gridded&quot; methods that allow irregular spacing along each axis.  For some of these, we compare interpolation performance in both &quot;vectorized&quot; form <code>itp[xvector, yvector]</code> and in &quot;scalar&quot; form <code>for y in yvector, x in xvector; val = itp[x,y]; end</code>.</p><p>First, construction time (smaller is better):</p><p><img src="perf/constructionG.png" alt="construction"/></p><p>Missing dots indicate cases that were not tested, or not supported by the package.  (For construction, differences between &quot;vec&quot; and &quot;scalar&quot; are just noise, since no interpolation is performed during construction.)  The only package that takes appreciable construction time is Dierckx.</p><p>And here&#39;s &quot;throughput&quot; (larger is better). To ensure we can see the wide range of scales, here we use &quot;square-root&quot; scaling of the y-axis:</p><p><img src="perf/rateG.png" alt="throughput"/></p><p>For 1d, the &quot;Dierckx scalar&quot; and &quot;GI&quot; tests were interrupted because they ran more than 20 seconds (far longer than any other test).  Both performed much better in 2d, interestingly.  You can see that Interpolations wins in every case, sometimes by a very large margin.</p><h2><a class="nav-anchor" id="Contributing-1" href="#Contributing-1">Contributing</a></h2><p>Work is very much in progress, but and help is always welcome. If you want to help out but don&#39;t know where to start, take a look at issue <a href="https://github.com/tlycken/Interpolations.jl/issues/5">#5 - our feature wishlist</a> =) There is also some <a href="doc/devdocs.md">developer documentation</a> that may help you understand how things work internally.</p><p>Contributions in any form are appreciated, but the best pull requests come with tests!</p><footer><hr/></footer></article></body></html>
