<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ApproxBayes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ApproxBayes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.ABCRejection" href="#ApproxBayes.ABCRejection"><code>ApproxBayes.ABCRejection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ABCRejection(sim_func::Function, nparams::Int64, ϵ::Float64, prior::Prior; &lt;keyword arguments&gt;)</code></pre><p>Create an ABCRejection type which will simulate data with sim<em>func. nparams is the number of parameters inputted into sim</em>func, ϵ is the target tolerance and prior sets the priors for the parameters. sim_func needs to take in 3 values, the parameters (in an array), constants (array) and target data in that order and needs to return 2 values, the first being the distance between the target data and simulated data and the second can be anything but is useful if for example you want to record some additional information about the simulations. ...</p><p><strong>Arguments</strong></p><ul><li><code>maxiterations = 10^5</code>: Maximum number of samples before the ABC algorithm terminates.</li><li><code>constants = []</code>: Any constants needed to simulate from sim_func</li><li><code>nparticles = 100</code>: Number of particles (ie samples) of ABC algorithm</li></ul><p>...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.ABCRejectionModel" href="#ApproxBayes.ABCRejectionModel"><code>ApproxBayes.ABCRejectionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ABCRejectionModel(sim_func::Array{Function, 1}, nparams::Array{Int64, 1}, ϵ::Float64, prior::Array{Prior, 1}; &lt;keyword arguments&gt;)</code></pre><p>Create an ABCRejectionModel type which will create a type to run ABC with model selection. Each model is specified with a function, first input is an array of functions. nparams and priors are arrays for the number of parameters and priors for each model. each sim_func needs to take in 3 values, the parameters (in an array), constants (array) and target data in that order and needs to return 2 values, the first being the distance between the target data and simulated data and the second can be anything but is useful if for example you want to record some additional information about the simulations. ...</p><p><strong>Arguments</strong></p><ul><li><code>maxiterations = 10^5</code>: Maximum number of samples before the ABC algorithm terminates.</li><li><code>constants = [[]]</code>: Any constants needed to simulate from sim_func, needs to be an array of arrays, each one corresponding to a model function.</li><li><code>nparticles = 100</code>: Number of particles (ie samples) of ABC algorithm</li></ul><p>...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.ABCSMC" href="#ApproxBayes.ABCSMC"><code>ApproxBayes.ABCSMC</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ABCRejection(sim_func::Function, nparams::Int64, ϵT::Float64, prior::Prior; &lt;keyword arguments&gt;)</code></pre><p>Create an ABCSMC type which will simulate data with sim<em>func. nparams is the number of parameters inputted into sim</em>func, ϵT is the target tolerance and prior sets the priors for the parameters. sim_func needs to take in 3 values, the parameters (in an array), constants (array) and target data in that order and needs to return 2 values, the first being the distance between the target data and simulated data and the second can be anything but is useful if for example you want to record some additional information about the simulations. ...</p><p><strong>Arguments</strong></p><ul><li><code>maxiterations = 10^5</code>: Maximum number of samples before the ABC algorithm terminates.</li><li><code>constants = []</code>: Any constants needed to simulate from sim_func</li><li><code>nparticles = 100</code>: Number of particles (ie samples) of ABC algorithm</li><li><code>α = 0.3</code>: The αth quantile of population i is chosen as the ϵ for population i + 1</li><li><code>ϵ1 = 10^5</code>: Starting ϵ for first ABC SMC populations</li><li><code>convergence = 0.05</code>: ABC SMC stops when ϵ in population i + 1 is within 0.05 of populations i</li><li><code>kernel = uniformkernel</code>: Parameter perturbation kernel, default is a uniform distribution. <code>gaussiankernel</code> is also an option that is already available in ApproxBayes.jl. Alternatively you can code up your own kernel function. See kernels.jl for examples.</li></ul><p>...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.ABCSMCModel" href="#ApproxBayes.ABCSMCModel"><code>ApproxBayes.ABCSMCModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ABCSMCModel(sim_func::Array{Function, 1}, nparams::Array{Int64, 1}, ϵT::Float64, prior::Array{Prior, 1}; &lt;keyword arguments&gt;)</code></pre><p>Create an ABCSMCModel type which will create a type to run the ABC SMC with model selection algorithm. Each model is specified with a function, first input is an array of functions. nparams and priors are arrays for the number of parameters and priors for each model, ϵT is the target tolerance. Each sim_func needs to take in 3 values, the parameters (in an array), constants (array) and target data in that order and needs to return 2 values, the first being the distance between the target data and simulated data and the second can be anything but is useful if for example you want to record some additional information about the simulations. ...</p><p><strong>Arguments</strong></p><ul><li><code>maxiterations = 10^5</code>: Maximum number of samples before the ABC algorithm terminates.</li><li><code>constants = []</code>: Any constants needed to simulate from sim_func</li><li><code>nparticles = 100</code>: Number of particles (ie samples) of ABC algorithm</li><li><code>α = 0.3</code>: The αth quantile of population i is chosen as the ϵ for population i + 1</li><li><code>ϵ1 = 10^5</code>: Starting ϵ for first ABC SMC populations</li><li><code>convergence = 0.05</code>: ABC SMC stops when ϵ in population i + 1 is within 0.05 of populations i</li><li><code>modelkern = 0.7</code>: Probability model stays the same in model perturbation kernel, ie 70% of the time the model perturbation kernel will leave the model the same.</li></ul><p>...</p></div></div></section><pre><code class="language-none">ApproxBayes.ABCSMCmodelresults</code></pre><pre><code class="language-none">ApproxBayes.ABCSMCresults</code></pre><pre><code class="language-none">ApproxBayes.ABCrejectionmodelresults</code></pre><pre><code class="language-none">ApproxBayes.ABCrejectionresults</code></pre><pre><code class="language-none">ApproxBayes.ABCtype</code></pre><pre><code class="language-none">ApproxBayes.ApproxBayes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.Kernel" href="#ApproxBayes.Kernel"><code>ApproxBayes.Kernel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Kernel(perturbation_function::Function,
pdf_function::Function,
calculate_kernel_parameters::Function)</code></pre><p>Create a parameter perturbation kernel. Required inputs are 3 functions. First is the <code>perturbation_function</code> which should take 2 parameters, the parameter to be perturbed and any kernel specific parameter (for example the standard deviation of a normal distribution if this is the kernel of choice). Second function is the <code>pdf_function</code>, that requires 4 inputs:     1) the newparticle     2) the old particle     3) kernel specific parameters and     4) an index i. The third function is <code>calculate_kernel_parameters</code> which given an array of particles should calculate the kernel specific parameters for the next population. Should you wish to keep the same parameters throughout you can just write a function that returns a number(s).</p></div></div></section><pre><code class="language-none">ApproxBayes.Particle</code></pre><pre><code class="language-none">ApproxBayes.ParticleRejection</code></pre><pre><code class="language-none">ApproxBayes.ParticleRejectionModel</code></pre><pre><code class="language-none">ApproxBayes.ParticleSMC</code></pre><pre><code class="language-none">ApproxBayes.ParticleSMCModel</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.Prior" href="#ApproxBayes.Prior"><code>ApproxBayes.Prior</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Prior(distributions)

Create Prior type for ABC algorithm specifying priors for each parameters. This is an array of Distribution types from Distribution.jl, each element corresponding to a parameter.</code></pre></div></div></section><pre><code class="language-none">ApproxBayes.abctype</code></pre><pre><code class="language-none">ApproxBayes.calculate_kernel_parameters</code></pre><pre><code class="language-none">ApproxBayes.calculate_kernel_parameters_gauss</code></pre><pre><code class="language-none">ApproxBayes.copyparticle</code></pre><pre><code class="language-none">ApproxBayes.eval</code></pre><pre><code class="language-none">ApproxBayes.gaussiankernel</code></pre><pre><code class="language-none">ApproxBayes.getmodelfreq</code></pre><pre><code class="language-none">ApproxBayes.getmodelprob</code></pre><pre><code class="language-none">ApproxBayes.getparticleweights</code></pre><pre><code class="language-none">ApproxBayes.getproposal</code></pre><pre><code class="language-none">ApproxBayes.include</code></pre><pre><code class="language-none">ApproxBayes.kernelprob</code></pre><pre><code class="language-none">ApproxBayes.ksdist</code></pre><pre><code class="language-none">ApproxBayes.modelperturbation</code></pre><pre><code class="language-none">ApproxBayes.modelselection_kernel</code></pre><pre><code class="language-none">ApproxBayes.parameterperturbation</code></pre><pre><code class="language-none">ApproxBayes.pdf_function</code></pre><pre><code class="language-none">ApproxBayes.pdf_function_gauss</code></pre><pre><code class="language-none">ApproxBayes.perturbation_function</code></pre><pre><code class="language-none">ApproxBayes.perturbation_function_gauss</code></pre><pre><code class="language-none">ApproxBayes.perturbmodel</code></pre><pre><code class="language-none">ApproxBayes.perturbparticle</code></pre><pre><code class="language-none">ApproxBayes.priorprob</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.runabc" href="#ApproxBayes.runabc"><code>ApproxBayes.runabc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">runabc(ABCsetup::ABCtype, targetdata; progress = false, verbose = false, parallel = true)</code></pre><p>Run ABC with ABCsetup defining the algorithm and inputs to algorithm, targetdata is the data we wish to fit the model to and will be used as an input for the simulation function defined in ABCsetup. If progress is set to <code>true</code> a progress meter will be shown. Inference will be run in parallel via multithreading if <code>parallel = true</code>. The environmental variable JULIA<em>NUM</em>THREADS needs to be set prior to launching a julia session.</p></div></div><div><div><pre><code class="language-none">runabc(ABCsetup::ABCtype, targetdata; progress = false, verbose = false)</code></pre><p>When the SMC algorithms are used, a print out at the end of each population will be made if verbose = true.</p></div></div></section><pre><code class="language-none">ApproxBayes.setupSMCparticles</code></pre><pre><code class="language-none">ApproxBayes.smcweights</code></pre><pre><code class="language-none">ApproxBayes.smcweightsmodel</code></pre><pre><code class="language-none">ApproxBayes.uniformkernel</code></pre><pre><code class="language-none">ApproxBayes.update_newparams!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ApproxBayes.writeoutput" href="#ApproxBayes.writeoutput"><code>ApproxBayes.writeoutput</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">writeoutput(results; &lt;keyword arguments&gt;)</code></pre><p>Write the results of an ABC inference to a text file. For model selection algorithms a text file with the parameters of each model will be written and a text file with model probabilities. ...</p><p><strong>Arguments</strong></p><ul><li><code>dir = &quot;&quot;</code>: Directory where the text file will be written to.</li><li><code>file= &quot;&quot;</code>: Filename to write to, default depends on the type of inference.</li></ul><p>...</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
