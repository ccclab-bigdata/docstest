<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ExponentialUtilities.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ExponentialUtilities.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.@diagview" href="#ExponentialUtilities.@diagview"><code>ExponentialUtilities.@diagview</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@diagview(A,d) -&gt; view of the `d`th diagonal of `A`.</code></pre></div></div></section><pre><code class="language-none">ExponentialUtilities.ExponentialUtilities</code></pre><pre><code class="language-none">ExponentialUtilities.ExpvCache</code></pre><pre><code class="language-none">ExponentialUtilities.HermitianSubspaceCache</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.KrylovSubspace" href="#ExponentialUtilities.KrylovSubspace"><code>ExponentialUtilities.KrylovSubspace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">KrylovSubspace{T}(n,[maxiter=30]) -&gt; Ks</code></pre><p>Constructs an uninitialized Krylov subspace, which can be filled by <code>arnoldi!</code>.</p><p>The dimension of the subspace, <code>Ks.m</code>, can be dynamically altered but should be smaller than <code>maxiter</code>, the maximum allowed arnoldi iterations.</p><pre><code class="language-none">getV(Ks) -&gt; V
getH(Ks) -&gt; H</code></pre><p>Access methods for the (extended) orthonormal basis <code>V</code> and the (extended) Gram-Schmidt coefficients <code>H</code>. Both methods return a view into the storage arrays and has the correct dimensions as indicated by <code>Ks.m</code>.</p><pre><code class="language-none">resize!(Ks, maxiter) -&gt; Ks</code></pre><p>Resize <code>Ks</code> to a different <code>maxiter</code>, destroying its contents.</p><p>This is an expensive operation and should be used scarcely.</p></div></div></section><pre><code class="language-none">ExponentialUtilities.PhivCache</code></pre><pre><code class="language-none">ExponentialUtilities.Stegr</code></pre><pre><code class="language-none">ExponentialUtilities.StegrCache</code></pre><pre><code class="language-none">ExponentialUtilities.SubspaceCache</code></pre><pre><code class="language-none">ExponentialUtilities._expv_ee</code></pre><pre><code class="language-none">ExponentialUtilities._expv_hb</code></pre><pre><code class="language-none">ExponentialUtilities._phiv_timestep_adapt</code></pre><pre><code class="language-none">ExponentialUtilities._phiv_timestep_caches</code></pre><pre><code class="language-none">ExponentialUtilities._phiv_timestep_estimate_flops</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.arnoldi" href="#ExponentialUtilities.arnoldi"><code>ExponentialUtilities.arnoldi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arnoldi(A,b[;m,tol,opnorm,iop]) -&gt; Ks</code></pre><p>Performs <code>m</code> anoldi iterations to obtain the Krylov subspace K_m(A,b).</p><p>The n x (m + 1) basis vectors <code>getV(Ks)</code> and the (m + 1) x m upper Hessenberg matrix <code>getH(Ks)</code> are related by the recurrence formula</p><pre><code class="language-none">v_1=b,\quad Av_j = \sum_{i=1}^{j+1}h_{ij}v_i\quad(j = 1,2,\ldots,m)</code></pre><p><code>iop</code> determines the length of the incomplete orthogonalization procedure <a href="#footnote-1">[1]</a>. The default value of 0 indicates full Arnoldi. For symmetric/Hermitian <code>A</code>, <code>iop</code> will be ignored and the Lanczos algorithm will be used instead.</p><p>Refer to <code>KrylovSubspace</code> for more information regarding the output.</p><p>Happy-breakdown occurs whenver <code>norm(v_j) &lt; tol * opnorm</code>, in this case the dimension of <code>Ks</code> is smaller than <code>m</code>.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Koskela, A. (2015). Approximating the matrix exponential of an</p></div><p>advection-diffusion operator using the incomplete orthogonalization method. In Numerical Mathematics and Advanced Applications-ENUMATH 2013 (pp. 345-353). Springer, Cham.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.arnoldi!" href="#ExponentialUtilities.arnoldi!"><code>ExponentialUtilities.arnoldi!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arnoldi!(Ks,A,b[;tol,m,opnorm,iop]) -&gt; Ks</code></pre><p>Non-allocating version of <code>arnoldi</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.arnoldi_step!" href="#ExponentialUtilities.arnoldi_step!"><code>ExponentialUtilities.arnoldi_step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arnoldi_step!(j, iop, n, A, V, H)</code></pre><p>Take the <code>j</code>:th step of the Lanczos iteration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.coeff" href="#ExponentialUtilities.coeff"><code>ExponentialUtilities.coeff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coeff(::Type,α)</code></pre><p>Helper functions that returns the real part if that is what is required (for Hermitian matrices), otherwise returns the value as-is.</p></div></div></section><pre><code class="language-none">ExponentialUtilities.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.expT!" href="#ExponentialUtilities.expT!"><code>ExponentialUtilities.expT!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expT!(α, β, t, cache)</code></pre><p>Calculate the subspace exponential <code>exp(t*T)</code> for a tridiagonal subspace matrix <code>T</code> with <code>α</code> on the diagonal and <code>β</code> on the super-/subdiagonal, diagonalizing via <code>stegr!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.expv" href="#ExponentialUtilities.expv"><code>ExponentialUtilities.expv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expv(t,A,b; kwargs) -&gt; exp(tA)b</code></pre><p>Compute the matrix-exponential-vector product using Krylov.</p><p>A Krylov subspace is constructed using <code>arnoldi</code> and <code>exp!</code> is called on the Hessenberg matrix. Consult <code>arnoldi</code> for the values of the keyword arguments. An alternative algorithm, where an error estimate generated on-the-fly is used to terminate the Krylov iteration, can be employed by setting the kwarg <code>mode=:error_estimate</code>.</p><pre><code class="language-none">expv(t,Ks; cache) -&gt; exp(tA)b</code></pre><p>Compute the expv product using a pre-constructed Krylov subspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.expv!" href="#ExponentialUtilities.expv!"><code>ExponentialUtilities.expv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expv!(w,t,Ks[;cache]) -&gt; w</code></pre><p>Non-allocating version of <code>expv</code> that uses precomputed Krylov subspace <code>Ks</code>.</p></div></div><div><div><pre><code class="language-none">expv!(w, t, A, b, Ks, cache)</code></pre><p>Alternative interface for calculating the action of <code>exp(t*A)</code> on the vector <code>b</code>, storing the result in <code>w</code>. The Krylov iteration is terminated when an error estimate for the matrix exponential in the generated subspace is below the requested tolerance. <code>Ks</code> is a <code>KrylovSubspace</code> and <code>typeof(cache)&lt;:HermitianSubspaceCache</code>, the exact type decides which algorithm is used to compute the subspace exponential.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.expv_timestep" href="#ExponentialUtilities.expv_timestep"><code>ExponentialUtilities.expv_timestep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">exp_timestep(ts,A,b[;adaptive,tol,kwargs...]) -&gt; U</code></pre><p>Evaluates the matrix exponentiation-vector product using time stepping</p><div>\[u = \exp(tA)b\]</div><p><code>ts</code> is an array of time snapshots for u, with <code>U[:,j] ≈ u(ts[j])</code>. <code>ts</code> can also be just one value, in which case only the end result is returned and <code>U</code> is a vector.</p><p>The time stepping formula of Niesen &amp; Wright is used <a href="#footnote-1">[1]</a>. If the time step <code>tau</code> is not specified, it is chosen according to (17) of Neisen &amp; Wright. If <code>adaptive==true</code>, the time step and Krylov subsapce size adaptation scheme of Niesen &amp; Wright is used, the relative tolerance of which can be set using the keyword parameter <code>tol</code>. The delta and gamma parameter of the adaptation scheme can also be adjusted.</p><p>Set <code>verbose=true</code> to print out the internal steps (for debugging). For the other keyword arguments, consult <code>arnoldi</code> and <code>phiv</code>, which are used internally.</p><p>Note that this function is just a special case of <code>phiv_timestep</code> with a more intuitive interface (vector <code>b</code> instead of a n-by-1 matrix <code>B</code>).</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Niesen, J., &amp; Wright, W. (2009). A Krylov subspace algorithm for</p></div><p>evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.expv_timestep!" href="#ExponentialUtilities.expv_timestep!"><code>ExponentialUtilities.expv_timestep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expv_timestep!(u,t,A,b[;kwargs]) -&gt; u</code></pre><p>Non-allocating version of <code>expv_timestep</code>.</p></div></div></section><pre><code class="language-none">ExponentialUtilities.getH</code></pre><pre><code class="language-none">ExponentialUtilities.getV</code></pre><pre><code class="language-none">ExponentialUtilities.get_cache</code></pre><pre><code class="language-none">ExponentialUtilities.get_caches</code></pre><pre><code class="language-none">ExponentialUtilities.get_subspace_cache</code></pre><pre><code class="language-none">ExponentialUtilities.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.lanczos!" href="#ExponentialUtilities.lanczos!"><code>ExponentialUtilities.lanczos!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos!(Ks,A,b[;tol,m,opnorm]) -&gt; Ks</code></pre><p>A variation of <code>arnoldi!</code> that uses the Lanczos algorithm for Hermitian matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.lanczos_step!" href="#ExponentialUtilities.lanczos_step!"><code>ExponentialUtilities.lanczos_step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos_step!(j, m, n, A, V, H)</code></pre><p>Take the <code>j</code>:th step of the Lanczos iteration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phi" href="#ExponentialUtilities.phi"><code>ExponentialUtilities.phi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phi(z,k[;cache]) -&gt; [phi_0(z),phi_1(z),...,phi_k(z)]</code></pre><p>Compute the scalar phi functions for all orders up to k.</p><p>The phi functions are defined as</p><div>\[\varphi_0(z) = \exp(z),\quad \varphi_{k+1}(z) = \frac{\varphi_k(z) - 1}{z}\]</div><p>Instead of using the recurrence relation, which is numerically unstable, a formula given by Sidje is used (Sidje, R. B. (1998). Expokit: a software package for computing matrix exponentials. ACM Transactions on Mathematical Software (TOMS), 24(1), 130-156. Theorem 1).</p></div></div><div><div><pre><code class="language-none">phi(A,k[;cache]) -&gt; [phi_0(A),phi_1(A),...,phi_k(A)]</code></pre><p>Compute the matrix phi functions for all orders up to k. <code>k</code> &gt;= 1.</p><p>The phi functions are defined as</p><div>\[\varphi_0(z) = \exp(z),\quad \varphi_{k+1}(z) = \frac{\varphi_k(z) - 1}{z}\]</div><p>Calls <code>phiv_dense</code> on each of the basis vectors to obtain the answer. If A is <code>Diagonal</code>, instead calls the scalar <code>phi</code> on each diagonal element and the return values are also <code>Diagonal</code>s</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phi!" href="#ExponentialUtilities.phi!"><code>ExponentialUtilities.phi!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phi!(out,A,k[;caches]) -&gt; out</code></pre><p>Non-allocating version of <code>phi</code> for non-diagonal matrix inputs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv" href="#ExponentialUtilities.phiv"><code>ExponentialUtilities.phiv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv(t,A,b,k;correct,kwargs) -&gt; [phi_0(tA)b phi_1(tA)b ... phi_k(tA)b][, errest]</code></pre><p>Compute the matrix-phi-vector products using Krylov. <code>k</code> &gt;= 1.</p><p>The phi functions are defined as</p><div>\[\varphi_0(z) = \exp(z),\quad \varphi_{k+1}(z) = \frac{\varphi_k(z) - 1}{z}\]</div><p>A Krylov subspace is constructed using <code>arnoldi</code> and <code>phiv_dense</code> is called on the Hessenberg matrix. If <code>correct=true</code>, then phi<em>0 through phi</em>k-1 are updated using the last Arnoldi vector v_m+1 <a href="#footnote-1">[1]</a>. If <code>errest=true</code> then an additional error estimate for the second-to-last phi is also returned. For the additional keyword arguments, consult <code>arnoldi</code>.</p><p>phiv(t,Ks,k;correct,kwargs) -&gt; [phi<em>0(tA)b phi</em>1(tA)b ... phi_k(tA)b][, errest]</p><p>Compute the matrix-phi-vector products using a pre-constructed Krylov subspace.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Niesen, J., &amp; Wright, W. (2009). A Krylov subspace algorithm for evaluating</p></div><p>the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631. Formula (10).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv!" href="#ExponentialUtilities.phiv!"><code>ExponentialUtilities.phiv!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv!(w,t,Ks,k[;cache,correct,errest]) -&gt; w[,errest]</code></pre><p>Non-allocating version of &#39;phiv&#39; that uses precomputed Krylov subspace <code>Ks</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv_dense" href="#ExponentialUtilities.phiv_dense"><code>ExponentialUtilities.phiv_dense</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv_dense(A,v,k[;cache]) -&gt; [phi_0(A)v phi_1(A)v ... phi_k(A)v]</code></pre><p>Compute the matrix-phi-vector products for small, dense <code>A</code>. <code>k</code>` &gt;= 1.</p><p>The phi functions are defined as</p><div>\[\varphi_0(z) = \exp(z),\quad \varphi_{k+1}(z) = \frac{\varphi_k(z) - 1}{z}\]</div><p>Instead of using the recurrence relation, which is numerically unstable, a formula given by Sidje is used (Sidje, R. B. (1998). Expokit: a software package for computing matrix exponentials. ACM Transactions on Mathematical Software (TOMS), 24(1), 130-156. Theorem 1).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv_dense!" href="#ExponentialUtilities.phiv_dense!"><code>ExponentialUtilities.phiv_dense!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv_dense!(w,A,v,k[;cache]) -&gt; w</code></pre><p>Non-allocating version of <code>phiv_dense</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv_timestep" href="#ExponentialUtilities.phiv_timestep"><code>ExponentialUtilities.phiv_timestep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv_timestep(ts,A,B[;adaptive,tol,kwargs...]) -&gt; U</code></pre><p>Evaluates the linear combination of phi-vector products using time stepping</p><div>\[u = \varphi_0(tA)b_0 + t\varphi_1(tA)b_1 + \cdots + t^p\varphi_p(tA)b_p\]</div><p><code>ts</code> is an array of time snapshots for u, with <code>U[:,j] ≈ u(ts[j])</code>. <code>ts</code> can also be just one value, in which case only the end result is returned and <code>U</code> is a vector.</p><p>The time stepping formula of Niesen &amp; Wright is used <a href="#footnote-1">[1]</a>. If the time step <code>tau</code> is not specified, it is chosen according to (17) of Neisen &amp; Wright. If <code>adaptive==true</code>, the time step and Krylov subsapce size adaptation scheme of Niesen &amp; Wright is used, the relative tolerance of which can be set using the keyword parameter <code>tol</code>. The delta and gamma parameter of the adaptation scheme can also be adjusted.</p><p>Set <code>verbose=true</code> to print out the internal steps (for debugging). For the other keyword arguments, consult <code>arnoldi</code> and <code>phiv</code>, which are used internally.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Niesen, J., &amp; Wright, W. (2009). A Krylov subspace algorithm for</p></div><p>evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.phiv_timestep!" href="#ExponentialUtilities.phiv_timestep!"><code>ExponentialUtilities.phiv_timestep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">phiv_timestep!(U,ts,A,B[;kwargs]) -&gt; U</code></pre><p>Non-allocating version of <code>phiv_timestep</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExponentialUtilities.realview" href="#ExponentialUtilities.realview"><code>ExponentialUtilities.realview</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">realview(::Type, V) -&gt; real view of `V`</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
