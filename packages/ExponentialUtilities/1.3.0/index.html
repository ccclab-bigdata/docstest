<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ExponentialUtilities.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ExponentialUtilities.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Matrix-phi-vector-product-1">Matrix-phi-vector product</a></li><li><a class="toctext" href="#Matrix-phi-function-phi-1">Matrix-phi function <code>phi</code></a></li><li><a class="toctext" href="#Arnoldi-iteration-arnoldi-1">Arnoldi iteration <code>arnoldi</code></a></li><li><a class="toctext" href="#Advanced-features-1">Advanced features</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ExponentialUtilities-1" href="#ExponentialUtilities-1">ExponentialUtilities</a></h1><p><a href="https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/JuliaDiffEq/Lobby.svg" alt="Join the chat at https://gitter.im/JuliaDiffEq/Lobby"/></a> <a href="https://travis-ci.org/JuliaDiffEq/ExponentialUtilities.jl"><img src="https://travis-ci.org/JuliaDiffEq/ExponentialUtilities.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/MSeeker1340/exponentialutilities-jl"><img src="https://ci.appveyor.com/api/projects/status/eeww1qm5rrf984bc?svg=true" alt="Build status"/></a> <a href="https://coveralls.io/github/JuliaDiffEq/ExponentialUtilities.jl?branch=master"><img src="https://coveralls.io/repos/github/JuliaDiffEq/ExponentialUtilities.jl/badge.svg?branch=master" alt="Coverage Status"/></a> <a href="https://codecov.io/gh/JuliaDiffEq/ExponentialUtilities.jl"><img src="https://codecov.io/gh/JuliaDiffEq/ExponentialUtilities.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><p>ExponentialUtilities is a package of utility functions used by the exponential integrators in OrdinaryDiffEq. It is a lightweight pure Julia package with no external dependencies, so it can also be used independently.</p><h2><a class="nav-anchor" id="Matrix-phi-vector-product-1" href="#Matrix-phi-vector-product-1">Matrix-phi-vector product</a></h2><p>The main functionality of ExponentialUtilities is the computation of matrix-phi-vector products. The phi functions are defined as</p><pre><code class="language-none">ϕ_0(z) = exp(z)
ϕ_(k+1)(z) = (ϕ_k(z) - 1) / z</code></pre><p>In exponential algorithms, products in the form of <code>ϕ_m(tA)b</code> is frequently encountered. Instead of computing the matrix function first and then computing the matrix-vector product, the common alternative is to construct a <a href="https://en.wikipedia.org/wiki/Krylov_subspace">Krylov subspace</a> <code>K_m(A,b)</code> and then approximate the matrix-phi-vector product.</p><h3><a class="nav-anchor" id="expv-and-phiv-1" href="#expv-and-phiv-1"><code>expv</code> and <code>phiv</code></a></h3><pre><code class="language-julia">expv(t,A,b;kwargs) -&gt; exp(tA)b
phiv(t,A,b,k;kwargs) -&gt; [ϕ_0(tA)b ϕ_1(tA)b ... ϕ_k(tA)b][, errest]</code></pre><p>For <code>phiv</code>, <em>all</em> <code>ϕ_m(tA)b</code> products up to order <code>k</code> is returned as a matrix. This is because it&#39;s more economical to produce all the results at once than individually. A second output is returned if <code>errest=true</code> in <code>kwargs</code>. The error estimate is given for the second-to-last product, using the last product as an estimator. If <code>correct=true</code>, then <code>ϕ_0</code> through <code>ϕ_(k-1)</code> are updated using the last Arnoldi vector. The correction algorithm is described in [1].</p><p>You can adjust how the Krylov subspace is constructed by setting various keyword arguments. See the Arnoldi iteration section for more details.</p><h3><a class="nav-anchor" id="expv_timestep-and-phiv_timestep-1" href="#expv_timestep-and-phiv_timestep-1"><code>expv_timestep</code> and <code>phiv_timestep</code></a></h3><p>Unlike <code>expv</code> and <code>phiv</code>, the timestepping methods divide <code>t</code> into smaller time steps and compute the product step-by-step. By doing this in smaller chunks, the methods allow for finer error control as well as adaptation. The timestepping algorithm is described in [1], which is based upon the numerical package Expokit [2].</p><pre><code class="language-julia">exp_timestep(ts,A,b;kwargs) -&gt; U</code></pre><p>Evaluates the matrix exponentiation-vector product <code>u = exp(tA)b</code> using time stepping.</p><pre><code class="language-julia">phiv_timestep(ts,A,[b_0 b_1 ... b_p];kwargs) -&gt; U</code></pre><p>Evaluates the linear combination of phi-vector products <code>u = ϕ_0(tA)b_0 + tϕ_1(tA)b_1 + ... + t^pϕ_p(tA)b_p</code> using time stepping.</p><p>In both cases, <code>ts</code> is an array of time snapshots for u, with <code>U[:,j] ≈ u(ts[j])</code>. <code>ts</code> can also be just one value, in which case only the end result is returned and <code>U</code> is a vector.</p><p>Apart from keyword arguments that affect the computation of Krylov subspaces (see the Arnoldi iteration section), you can also adjust the timestepping behavior using the arguments. By setting <code>adaptive=true</code>, the time step and Krylov subsapce size adaptation scheme of Niesen &amp; Wright is used and the relative tolerance of which can be set using the keyword parameter <code>tol</code>. The <code>delta</code> and <code>gamma</code> parameter of the adaptation scheme can also be adjusted. The <code>tau</code> parameter adjusts the size of the timestep (and for <code>adaptive=true</code>, the initial timestep). By default, it is calculated using a heuristic formula by Niesen &amp; Wright.</p><h3><a class="nav-anchor" id="Support-for-matrix-free-operators-1" href="#Support-for-matrix-free-operators-1">Support for matrix-free operators</a></h3><p>You can use any object as the &quot;matrix&quot; <code>A</code> as long as it implements the following linear operator interface:</p><ul><li><code>LinearAlgebra.mul!(y, A, x)</code> (for computing <code>y = A * x</code> in place).</li><li><code>Base.size(A, dim)</code></li><li><code>LinearAlgebra.opnorm(A, p=Inf)</code>. If this is not implemented or the default implementation can be slow, you can manually pass in the operator norm (a rough estimate is fine) using the keyword argument <code>opnorm</code>.</li><li><code>LinearAlgebra.ishermitian(A)</code>. If this is not implemented or the default implementation can be slow, you can manually pass in the value using the keyword argument <code>ishermitian</code>.</li></ul><h2><a class="nav-anchor" id="Matrix-phi-function-phi-1" href="#Matrix-phi-function-phi-1">Matrix-phi function <code>phi</code></a></h2><pre><code class="language-julia">phi(z,k[;cache]) -&gt; [ϕ_0(z),ϕ_1(z),...,ϕ_k(z)]</code></pre><p>Compute ϕ function directly. <code>z</code> can both be a scalar or a <code>AbstractMatrix</code> (note that unlike the previous functions, you <em>need</em> to use a concrete matrix). This is used by the caching versions of the ExpRK integrators to precompute the operators.</p><p>Instead of using the recurrence relation, which is numerically unstable, a formula given by Sidje is used [2].</p><h2><a class="nav-anchor" id="Arnoldi-iteration-arnoldi-1" href="#Arnoldi-iteration-arnoldi-1">Arnoldi iteration <code>arnoldi</code></a></h2><pre><code class="language-julia">arnoldi(A,b[;m,tol,opnorm,iop,cache]) -&gt; Ks</code></pre><p>Performs <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Anoldi iterations</a> to obtain the Krylov subspace <code>K_m(A,b)</code>. The result is a <code>KrylovSubspace</code> that can be used by <code>phiv</code> via the alternative interface</p><pre><code class="language-julia">phiv(t,Ks,k;kwargs) -&gt; [ϕ_0(tA)b ϕ_1(tA)b ... ϕ_k(tA)b][, errest]</code></pre><p>The reason for having this alternative interface is that we may want to compute <code>ϕ_m(tA)b</code> for different values of <code>t</code>. In this case, we can compute <code>Ks</code> just once (which is expensive) and follow up with several <code>phiv</code> calls using <code>Ks</code> (which is not as expensive).</p><p>For <code>arnoldi</code>, if <code>A</code> is hermitian, then the more efficient <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm">Lanczos algorithm</a> is used instead. For cases when <code>A</code> is almost hermitian or when accuracy is not important, the incomplete orthogonalization procedure (IOP) can be used by setting the IOP length <code>iop</code> in <code>kwargs</code>.</p><p>For the other keyword arguments, <code>m</code> determines the dimension of the Krylov subspace and <code>tol</code> is the relative tolerance used to determine the &quot;happy-breakdown&quot; condition. You can also set custom operator norm in <code>opnorm</code>, e.g. efficient norm estimation functions instead of the default <code>LinearAlgebra.opnorm</code>. Only <code>opnorm(A, Inf)</code> needs to be defined.</p><h2><a class="nav-anchor" id="Advanced-features-1" href="#Advanced-features-1">Advanced features</a></h2><p>&quot;In-place&quot; versions for <code>phi</code>, <code>arnoldi</code>, <code>expv</code>, <code>phiv</code>, <code>expv_timestep</code> and <code>phiv_timestep</code> are available as <code>phi!</code>, <code>arnoldi!</code>, <code>expv!</code>, <code>phiv!</code>, <code>expv_timestep!</code> and <code>phiv_timestep!</code>. You can refer to the docstrings for more information.</p><p>In addition, you may provide pre-allocated caches to the functions to further improve efficiency. In particular, dedicated cache types for <code>expv!</code> and <code>phiv!</code> are available as <code>ExpvCache</code> and <code>PhivCache</code>. Both of them can be dynamically resized, which is crucial for the adaptive <code>phiv_timestep!</code> method.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>[1] Niesen, J., &amp; Wright, W. (2009). A Krylov subspace algorithm for evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631.</p><p>[2] Sidje, R. B. (1998). Expokit: a software package for computing matrix exponentials. ACM Transactions on Mathematical Software (TOMS), 24(1), 130-15.</p><p>[3] Koskela, A. (2015). Approximating the matrix exponential of an advection-diffusion operator using the incomplete orthogonalization method. In Numerical Mathematics and Advanced Applications-ENUMATH 2013 (pp. 345-353). Springer, Cham.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
