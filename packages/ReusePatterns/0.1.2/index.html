<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· ReusePatterns.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ReusePatterns.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Simple-tools-to-implement-*composition*-and-*concrete-subtyping*-patterns-in-Julia.-1">Simple tools to implement <em>composition</em> and <em>concrete subtyping</em> patterns in Julia.</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Composition-1">Composition</a></li><li><a class="toctext" href="#Concrete-subtyping-1">Concrete subtyping</a></li><li><a class="toctext" href="#Complete-examples-1">Complete examples</a></li><li><a class="toctext" href="#Links-1">Links</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ReusePatterns.jl-1" href="#ReusePatterns.jl-1">ReusePatterns.jl</a></h1><h2><a class="nav-anchor" id="Simple-tools-to-implement-*composition*-and-*concrete-subtyping*-patterns-in-Julia.-1" href="#Simple-tools-to-implement-*composition*-and-*concrete-subtyping*-patterns-in-Julia.-1">Simple tools to implement <em>composition</em> and <em>concrete subtyping</em> patterns in Julia.</a></h2><p><a href="https://travis-ci.org/gcalderone/ReusePatterns.jl"><img src="https://travis-ci.org/gcalderone/ReusePatterns.jl.svg?branch=master" alt="Build Status"/></a></p><p>Assume an author <strong>A</strong> (say, Alice) wrote a very powerful Julia code, extensively used by user <strong>C</strong> (say, Charlie).  The best code reusing practice in this &quot;two actors&quot; scenario is the package deployment, thoroughly discussed in the Julia manual.  Now assume a third person <strong>B</strong> (say, Bob) slip between Alice and Charlie: he wish to reuse Alice&#39;s code to provide more complex/extended functionalities to Charlie.  Most likely Bob will need a more sophisticated reuse pattern...</p><p>This package provides a few tools to facilitate Bob&#39;s work in reusing Alice&#39;s code, by mean of two of the most common reuse patterns: <em>composition</em> and <em>subtyping</em> (<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">implementation inheritance</a> is not supported in Julia), and check which one provides the best solution.  Also, it aims to relieve Charlie from dealing with the underlying details, and seamlessly use the new functionalities introduced by Bob.</p><p>The motivation to develop this package stems from the following posts on the Discourse:</p><ul><li>https://discourse.julialang.org/t/how-to-add-metadata-info-to-a-dataframe/11168</li><li>https://discourse.julialang.org/t/composition-and-inheritance-the-julian-way/11231</li></ul><p>but several other topics apply as well (see list in the <em>Links</em> section below).</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The <strong>ReusePatterns.jl</strong> package is currently under testing, hence you may download the development version with:</p><pre><code class="language-julia">] add ReusePatterns</code></pre><h2><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h2><p>With <a href="https://en.wikipedia.org/wiki/Object_composition">composition</a> we wrap an Alice&#39;s object into a structure implemented by Bob, and let Charlie use the latter without even knowing if it actually is the original Alice&#39;s object or the wrapped one by Bob.</p><p>We pursue this goal by automatically forwarding all methods calls from Bob&#39;s structure to the appropriate Alice&#39;s object.</p><h3><a class="nav-anchor" id="Example:-1" href="#Example:-1">Example:</a></h3><p>Alice implemented a code to keep track of all her books, but forgot to add room for the number of pages and the issue year of each book.  Bob wishes to add these informations, and to provide the final functionalities to Charlie:</p><pre><code class="language-julia"># #####  Alice&#39;s code  #####
julia&gt; struct Book
      title::String
      author::String
  end
julia&gt; Base.show(io::IO, b::Book) = println(io, &quot;$(b.title) (by $(b.author))&quot;)
julia&gt; Base.print(b::Book) = println(&quot;In a hole in the ground there lived a hobbit...&quot;)
julia&gt; author(b::Book) = b.author

# #####  Bob&#39;s code  #####
julia&gt; struct PaperBook
    b::Book
    number_of_pages::Int
end
julia&gt; @forward((PaperBook, :b), Book)
julia&gt; pages(book::PaperBook) = book.number_of_pages

julia&gt; struct Edition
    b::PaperBook
    year::Int
end
julia&gt; @forward((Edition, :b), PaperBook)
julia&gt; year(book::Edition) = book.year

# #####  Charlie&#39;s code  #####
julia&gt; book = Edition(PaperBook(Book(&quot;The Hobbit&quot;, &quot;J.R.R. Tolkien&quot;), 374), 2013)

julia&gt; print(author(book), &quot;, &quot;, pages(book), &quot; pages, Ed. &quot;, year(book))
J.R.R. Tolkien, 374 pages, Ed. 2013

julia&gt; print(book)
In a hole in the ground there lived a hobbit...</code></pre><p>The key lines here are:</p><pre><code class="language-julia">@forward((PaperBook, :b), Book)
@forward((Edition, :b), PaperBook)</code></pre><p>The <code>@forward</code> macro identifies all methods accepting a <code>Book</code> object, and defines new methods with the same name and arguments, but accepting <code>PaperBook</code> arguments in place of the <code>Book</code>  ones.  The purpose of each newly defined method is simply to forward the call to the original method, passing the <code>Book</code> object stored in the <code>:p</code> field.  The second line does the same job, forwarding calls from <code>Edition</code> objects to <code>PaperBook</code> ones.</p><p>The <strong>ReusePatterns.jl</strong> package exports the following functions and macros aimed at supporting <em>composition</em> in Julia:</p><ul><li><code>@forward</code>: forward method calls from an object to a field structure;</li><li><code>forward</code>: returns a <code>Vector{String}</code> with the Julia code to properly forward method calls.</li></ul><p>To preview the forwarding code without actually evaluating it you can use the <code>forward</code> function, which has the same syntax as the <code>@forward</code> macro.  Continuing from previous example:</p><pre><code class="language-none">julia&gt; forward((Edition, :b), PaperBook)
4-element Array{String,1}:
 &quot;@eval Main Base.:(print)(p1::Main.Edition; kw...) = Main.:(print)(getfield(p1, :b); kw...)&quot;
 &quot;@eval Main Base.:(show)(p1::IO, p2::Main.Edition; kw...) = Main.:(show)(p1, getfield(p2, :b); kw...)&quot;
 &quot;@eval Main Main.:(author)(p1::Main.Edition; kw...) = Main.:(author)(getfield(p1, :b); kw...)&quot;
 &quot;@eval Main Main.:(pages)(p1::Main.Edition; kw...) = Main.:(pages)(getfield(p1, :b); kw...)&quot;</code></pre><p>Each function and macro has its own online documentation accessible by prepending <code>?</code> to the name.</p><p>The <em>composition</em> approach has the following advantages:</p><ul><li>It is applicable even if Alice and Bob do not agree on a particular type architecture;</li><li>it is the recommended Julian way to pursue code reusing;</li></ul><p>...and disadvantages:</p><ul><li>It may be cumbersome to apply if the number of involved methods is very high, or if the method definitions are spread across many modules;</li><li><em>composition</em> is not recursive, i.e. if further users (<strong>D</strong>an, <strong>E</strong>mily, etc.) build composite layers on top of Bob&#39;s one they&#39;ll need to implement new forwarding methods;</li><li>It introduces a small overhead for each composition layer, resulting in performance loss.</li></ul><h2><a class="nav-anchor" id="Concrete-subtyping-1" href="#Concrete-subtyping-1">Concrete subtyping</a></h2><p>Julia supports <a href="https://en.wikipedia.org/wiki/Subtyping">subtyping</a> of abstract types, allowing to build type hierarchies where each node provides the same behavior as all its descendants, i.e. each abstract type can be <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">substituted</a> with any of its subtypes.  This is one of the most powerful feature in Julia: in a function argument you may require an <em>AbstractArray</em> and seamlessly work with any of its concrete implementations (e.g. dense, strided or sparse arrays, ranges, etc.). This mechanism actually stem from a <strong>rigid separation</strong> of the desired behavior for a type (represented by the abstract type and the <a href="https://docs.julialang.org/en/v1/manual/interfaces">interface</a> definition) and the actual machine implementation (represented by the concrete type and the interface implementations).</p><p>However, in Julia you can only subtype abstract types, hence this powerful substitutability mechanism can not be pushed beyond a concrete type. Citing the <a href="https://docs.julialang.org/en/v1/manual/types">manual</a>: <em>this [limitation] might at first seem unduly restrictive, [but] it has many beneficial consequences with surprisingly few drawbacks.</em></p><p>The most striking drawback pops out in case Alice defines an abstract type with only one subtype, namely a concrete one.  Clearly, in all methods requiring access to the actual data representation, the argument types will be annotated with the concrete type, not the abstract one.  This is an important protection against Alice&#39;s package misuse: those methods require <strong>exactly</strong> that concrete type, not something else, even if it is a subtype of the same parent abstract type.  However, this is a serious problem for Bob, since he can not reuse those methods even if he defines concrete structures with the same contents as Alice&#39;s one (plus something else).</p><p>The <strong>ReusePatterns.jl</strong> package allows to overtake this limitation by introducing the concept of <em>quasi abstract</em> type, i.e. a type without a rigid separation between a type behaviour and its concrete implementation.  Operatively, a <em>quasi abstract</em> type is an abstract type satisfying the following constraints:</p><p>1 - it can have as many abstract or <em>quasi abstract</em> subtypes as desired, but it can have <strong>only one</strong> concrete subtype (the so called <em>associated concrete type</em>);</p><p>2 - if a <em>quasi abstract</em> type has another <em>quasi abstract</em> type among its ancestors, its associated concrete type must have (at least) the same field names and types of the ancestor associated data structure.</p><p>Note that for the example discussed above constraint 1 is not an actual limitation, since Alice already defined only one concrete type.  Also note that constraint 2 implies <em>concrete structure subtyping</em>.</p><p>The <code>@quasiabstract</code> macro provided by the <strong>ReusePatterns.jl</strong> package, ensure the above constraints are properly satisfied.</p><p>The guidelines to exploit <em>quasi abstract</em> types are straightforward:</p><ul><li>define the <em>quasi abstract</em> type as a simple structure, possibly with a parent type;</li><li>use the <em>quasi abstract</em> type name for object creation, method argument annotations, etc.</li></ul><p>Finally note that although two types are actually defined under the hood (an abstract and a concrete one), you may simply forget about the concrete one, and safely use the abstract one everywhere in the code.</p><h3><a class="nav-anchor" id="Example:-2" href="#Example:-2">Example:</a></h3><p>As for the <em>composition</em> case discussed above, assume alice implemented a code to keep track of all her books, but forgot to add room for the number of pages and the issue year of each book.  Bob wishes to add these informations, and to provide the final functionalities to Charlie.</p><pre><code class="language-julia"># #####  Alice&#39;s code  #####
julia&gt; @quasiabstract struct Book
      title::String
      author::String
  end
julia&gt; Base.show(io::IO, b::Book) = println(io, &quot;$(b.title) (by $(b.author))&quot;)
julia&gt; Base.print(b::Book) = println(&quot;In a hole in the ground there lived a hobbit...&quot;)
julia&gt; author(b::Book) = b.author

# #####  Bob&#39;s code  #####
julia&gt; @quasiabstract struct PaperBook &lt;: Book
    number_of_pages::Int
end
julia&gt; pages(book::PaperBook) = book.number_of_pages

julia&gt; @quasiabstract struct Edition &lt;: PaperBook
    year::Int
end
julia&gt; year(book::Edition) = book.year

julia&gt; println(fieldnames(concretetype(Edition)))
(:title, :author, :number_of_pages, :year)

# #####  Charlie&#39;s code  #####
julia&gt; book = Edition(&quot;The Hobbit&quot;, &quot;J.R.R. Tolkien&quot;, 374, 2013)

julia&gt; print(author(book), &quot;, &quot;, pages(book), &quot; pages, Ed. &quot;, year(book))
J.R.R. Tolkien, 374 pages, Ed. 2013

julia&gt; print(book)
In a hole in the ground there lived a hobbit...</code></pre><p>The <strong>ReusePatterns.jl</strong> package exports the following functions and macros aimed at supporting <em>concrete subtyping</em> in Julia:</p><ul><li><code>@quasiabstract</code>: define a new <em>quasi abstract</em> type, i.e. a pair of an abstract and a (exclusively associated) concrete types;</li><li><code>concretetype</code>: return the concrete type associated to a <em>quasi abstract</em> type;</li><li><code>isquasiabstract</code>: test whether a type is <em>quasi abstract</em>;</li><li><code>isquasiconcrete</code>: test whether a type is the concrete type associated to a <em>quasi abstract</em> type.</li></ul><p>Continuing the previous example:</p><pre><code class="language-julia">julia&gt; isquasiconcrete(typeof(book))
true

julia&gt; isquasiabstract(supertype(typeof(book)))
true

julia&gt; concretetype(typeof(book)) === supertype(typeof(book))
true</code></pre><p>Each function and macro has its own online documentation accessible by prepending <code>?</code> to the name.</p><p>This <em>concrete subtyping</em> approach has the following advantages:</p><ul><li>It is a recursive approach, i.e. if further users (<strong>D</strong>an, <strong>E</strong>mily, etc.) subtype Bob&#39;s structure they will have all the inherited behavior for free;</li><li>There is no overhead or performance loss.</li></ul><p>...and disadvantages:</p><ul><li>it is applicable <strong>only if</strong> both Alice and Bob agree to use <em>quasi abstract</em> types.</li><li>Charlie may break Alice&#39;s or Bob&#39;s code by using a concrete type with the <em>quasi abstract</em> type as ancestor, but without the required fields.  However, this problem can be easily fixed by adding the following check to the methods accepting a <em>quasi abstract</em> type, e.g. in the <code>pages</code> method shown above:</li></ul><pre><code class="language-julia">function pages(book::PaperBook)
    @assert isquasiconcrete(typeof(book))
    book.number_of_pages
end</code></pre><p>Note also that <code>isquasiconcrete</code> is a pure function, hence it can be used as a trait.</p><h2><a class="nav-anchor" id="Complete-examples-1" href="#Complete-examples-1">Complete examples</a></h2><h3><a class="nav-anchor" id="Adding-metadata-to-a-DataFrame-object-1" href="#Adding-metadata-to-a-DataFrame-object-1">Adding metadata to a <code>DataFrame</code> object</a></h3><p>This <a href="https://discourse.julialang.org/t/how-to-add-metadata-info-to-a-dataframe/11168">topic</a> raised a long discussion about the possibility to extend the functionalities provided by the <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames</a> package by adding a simple metadata dictionary, and the approaches to follow.  With the <em>composition</em> tools provided by <strong>ReusePatterns.jl</strong> this problem can now be solved with just 8 lines of code:</p><pre><code class="language-julia">struct DataFrameMeta &lt;: AbstractDataFrame
    p::DataFrame
    meta::Dict{String, Any}
    DataFrameMeta(args...; kw...) = new(DataFrame(args...; kw...), Dict{Symbol, Any}())
    DataFrameMeta(df::DataFrame) = new(df, Dict{Symbol, Any}())
end
meta(d::DataFrameMeta) = getfield(d,:meta)  # &lt;-- new functionality added to DataFrameMeta
@forward((DataFrameMeta, :p), DataFrame)    # &lt;-- reuse all existing functionalities</code></pre><p>(see the complete example <a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/dataframes.jl">here</a>).</p><h3><a class="nav-anchor" id="Polygon-drawings-(a-comparison-of-the-*composition*-and-*concrete-subtyping*-approaches)-1" href="#Polygon-drawings-(a-comparison-of-the-*composition*-and-*concrete-subtyping*-approaches)-1">Polygon drawings (a comparison of the <em>composition</em> and <em>concrete subtyping</em> approaches)</a></h3><p>We will consider the problem of implementing the code to draw several polygons on a plot.</p><p>The objects and methods implemented by Alice are:</p><ul><li><code>Polygon</code>: a structure to store the 2D cartesian coordinates of a <strong>generic polygon</strong>;</li><li><code>vertices</code>, <code>coords_x</code> and <code>coords_y</code>: methods to retrieve the number of vertices and the X and Y coordinates;</li><li><code>move!</code>, <code>scale!</code> and <code>rotate!</code>: methods to move, scale and rotate a polygon.</li></ul><p>The objects and methods implemented by Bob are:</p><ul><li><code>RegularPolygon</code>: a structure including (in the <em>composition</em> case) or subtyping (in the <em>concrete subtyping</em> case) a <code>Polygon</code> object, and represeting a <strong>regular polygon</strong>;</li><li><code>side</code>, <code>area</code>: methods to caluclate the length of a side and the area of a regular polygon;</li><li><code>Named</code>: a generic wrapper for an object (either a <code>Polygon</code>, or <code>RegularPolygon</code>), providing the possibility to attach a label for plotting purposes.</li></ul><p>Finally, Charlie&#39;s code will:</p><ul><li>Instantiate several regular polygons;</li><li>Move, scale and rotate them...</li><li>and produce the final plot.</li></ul><p>The same problem has been implemented following both the <em>composition</em> and the <em>concrete subtype</em> approaches in order to highlight the differences.  Also, each approach has been implemented both with and without <strong>ReusePatterns.jl</strong> facilities, in order to clearly show the code being generated by the macros.</p><p>The four complete examples are available here:</p><ul><li><p><a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/composition.jl"><em>composition</em></a>  (without using <strong>ReusePatterns.jl</strong> facilities);</p></li><li><p><a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/composition_wmacro.jl"><em>composition</em></a>  (with <strong>ReusePatterns.jl</strong> facilities);</p></li><li><p><a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/subtyping.jl"><em>concrete subtyping</em></a>  (without using <strong>ReusePatterns.jl</strong> facilities);</p></li><li><p><a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/subtyping_wmacro.jl"><em>concrete subtyping</em></a> (with <strong>ReusePatterns.jl</strong> facilities);</p></li></ul><p>Note that in all files the common statements appears on the same line, in order to make clear how much code is being saved by the considered approaches.  Finally, <a href="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/charlie.jl">Charlie&#39;s code</a> is identical for all of the above cases, and can be used to produce the final plot:</p><p><img src="https://github.com/gcalderone/ReusePatterns.jl/blob/master/examples/polygons.png" alt="polygons"/></p><h2><a class="nav-anchor" id="Links-1" href="#Links-1">Links</a></h2><p>The above discussion reflects my personal view of how I understood code reusing patterns in Julia, and <strong>ReusePatterns.jl</strong> is just the framework I use to implement those patterns.  But there is a lot of ongoing discussion on these topics, hence I encourage the reader to give a look around to see whether there are better solutions.  Below, you will find a (non-exhaustive) list of the links I found very useful to develoip this package.</p><h3><a class="nav-anchor" id="Related-topics-on-Discourse-and-other-websites:-1" href="#Related-topics-on-Discourse-and-other-websites:-1">Related topics on Discourse and other websites:</a></h3><p>The topics mentioned here, or related ones, have been thorougly discussed in many places, e.g.:</p><ul><li>https://discourse.julialang.org/t/how-to-add-metadata-info-to-a-dataframe/11168</li><li>https://discourse.julialang.org/t/composition-and-inheritance-the-julian-way/11231</li><li>https://discourse.julialang.org/t/workaround-for-traditional-inheritance-features-in-object-oriented-languages/1195</li><li>https://github.com/mauro3/SimpleTraits.jl</li><li>http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/</li><li>https://discourse.julialang.org/t/why-doesnt-julia-allow-multiple-inheritance/14342/4</li><li>https://discourse.julialang.org/t/oop-in-julia-inherit-from-parametric-composite-type/1841/</li><li>https://discourse.julialang.org/t/wrap-and-inherit-number/4799</li><li>https://discourse.julialang.org/t/guidelines-to-distinguish-concrete-from-abstract-types/19162</li></ul><h3><a class="nav-anchor" id="Pacakges-providing-similar-functionalities:-1" href="#Pacakges-providing-similar-functionalities:-1">Pacakges providing similar functionalities:</a></h3><p>Also, there are several packages related to the code reuse topic, or which provide similar functionalities as <strong>ReusePatterns.jl</strong> (in no particolar order):</p><ul><li>https://github.com/WschW/StructuralInheritance.jl</li><li>https://github.com/JuliaArbTypes/TypedDelegation.jl</li><li>https://github.com/AleMorales/ModularTypes.jl</li><li>https://github.com/JuliaCollections/DataStructures.jl/blob/master/src/delegate.jl</li><li>https://github.com/Jeffrey-Sarnoff/Delegate.jl</li><li>https://github.com/rjplevin/Classes.jl</li><li>https://github.com/jasonmorton/Typeclass.jl</li><li>https://github.com/KlausC/TypeEmulator.jl</li><li>https://github.com/MikeInnes/Lazy.jl (<code>@forward</code> macro)</li><li>https://github.com/tbreloff/ConcreteAbstractions.jl</li></ul><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
