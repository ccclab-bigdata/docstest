<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Reference Frame Rotations</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Reference Frame Rotations logo"/></a><h1>Reference Frame Rotations</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../man/dcm/">Direction Cosine Matrices</a></li><li><a class="toctext" href="../../man/euler_angle_axis/">Euler Angle and Axis</a></li><li><a class="toctext" href="../../man/euler_angles/">Euler Angles</a></li><li><a class="toctext" href="../../man/quaternions/">Quaternions</a></li><li><a class="toctext" href="../../man/conversions/">Conversions</a></li><li><a class="toctext" href="../../man/kinematics/">Kinematics</a></li><li><a class="toctext" href="../../man/composing_rotations/">Composing rotations</a></li><li><a class="toctext" href="../../man/inv_rotations/">Inverting rotations</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><p>Documentation for <code>ReferenceFrameRotations.jl</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.DCM" href="#ReferenceFrameRotations.DCM"><code>ReferenceFrameRotations.DCM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The Direction Cosine Matrix of type <code>T</code> is a <code>SMatrix{3,3,T,9}</code>, which is a 3x3 static matrix of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngleAxis" href="#ReferenceFrameRotations.EulerAngleAxis"><code>ReferenceFrameRotations.EulerAngleAxis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct EulerAngleAxis{T}</code></pre><p>The definition of Euler Angle and Axis to represent a 3D rotation.</p><p><strong>Fields</strong></p><ul><li><code>a</code>: The Euler angle [rad].</li><li><code>v</code>: The unitary vector aligned with the Euler axis.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">function EulerAngleAxis(a::T1, v::AbstractVector{T2}) where {T1,T2}</code></pre><p>Create an Euler Angle and Axis representation structure with angle <code>a</code> [rad] and vector <code>v</code>. Notice that the vector <code>v</code> will not be normalized. The type of the returned structure will be selected according to the input types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.EulerAngles" href="#ReferenceFrameRotations.EulerAngles"><code>ReferenceFrameRotations.EulerAngles</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct EulerAngles{T}</code></pre><p>The definition of Euler Angles, which is composed of three angles <code>a1</code>, <code>a2</code>, and <code>a3</code> together with a rotation sequence <code>rot_seq</code>. The latter is provided by a symbol with three characters, each one indicating the rotation axis of the corresponding angle (for example, <code>:ZYX</code>). The valid values for <code>rot_seq</code> are:</p><ul><li><code>:XYX</code>, <code>:XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>ZYZ</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">function EulerAngles(a1::T1, a2::T2, a3::T3, rot_seq::Symbol = :ZYX) where {T1,T2,T3}</code></pre><p>Create a new instance of <code>EulerAngles</code> with the angles <code>a1</code>, <code>a2</code>, and <code>a3</code> and the rotation sequence <code>rot_seq</code>. The type will be inferred from <code>T1</code>, <code>T2</code>, and <code>T3</code>. If <code>rot_seq</code> is not provided, then it defaults to <code>:ZYX</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion" href="#ReferenceFrameRotations.Quaternion"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>struct Quaternion{T}</strong></p><p>The definition of the quaternion. It has four values of type <code>T</code>. The quaternion representation is:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(v::AbstractVector)</code></pre><p>If the vector <code>v</code> has 3 components, then create a quaternion in which the real part is <code>0</code> and the vectorial or imaginary part has the same components of the vector <code>v</code>. In other words:</p><pre><code class="language-none">q = 0 + v[1].i + v[2].j + v[3].k</code></pre><p>Otherwise, if the vector <code>v</code> has 4 components, then create a quaternion in which the elements match those of the input vector:</p><pre><code class="language-none">q = v[1] + v[2].i + v[3].j + v[4].k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.Quaternion-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(r::Number, v::AbstractVector)</code></pre><p>Create a quaternion with real part <code>r</code> and vectorial or imaginary part <code>v</code>:</p><pre><code class="language-none">r + v[1].i + v[2].j + v[3].k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0,T1,T2,T3}} where T3 where T2 where T1 where T0" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T0}, Tuple{T0,T1,T2,T3}} where T3 where T2 where T1 where T0"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(q0::T0, q1::T1, q2::T2, q3::T3) where {T0,T1,T2,T3}</code></pre><p>Create the following quaternion:</p><pre><code class="language-none">q0 + q1.i + q2.j + q3.k</code></pre><p>in which:</p><ul><li><code>q0</code> is the real part of the quaternion.</li><li><code>q1</code> is the X component of the quaternion vectorial part.</li><li><code>q2</code> is the Y component of the quaternion vectorial part.</li><li><code>q3</code> is the Z component of the quaternion vectorial part.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{UniformScaling,Quaternion{T}}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{T}, Tuple{UniformScaling,Quaternion{T}}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(::UniformScaling,::Quaternion{T}) where T</code></pre><p>Create an identity quaternion of type <code>T</code>:</p><pre><code class="language-none">T(1) + T(0).i + T(0).j + T(0).k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.Quaternion-Union{Tuple{UniformScaling{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.Quaternion-Union{Tuple{UniformScaling{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.Quaternion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function Quaternion(u::UniformScaling{T}) where T
function Quaternion{T}(u::UniformScaling) where T</code></pre><p>Create the quaternion <code>u.λ + 0.i + 0.j + 0.k</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{EulerAngles}" href="#Base.inv-Tuple{EulerAngles}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function inv(Θ::EulerAngles)</code></pre><p>Return the Euler angles that represent the inverse rotation of <code>Θ</code>. Notice that the rotation sequence of the result will be the inverse of the input. Hence, if the input rotation sequence is, for example, <code>:XYZ</code>, then the result will be represented using <code>:ZYX</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Quaternion}" href="#Base.inv-Tuple{Quaternion}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv(q::Quaternion)</code></pre><p>Compute the inverse of the quaternion <code>q</code>:</p><pre><code class="language-none">conj(q)
-------
  |q|²</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number" href="#Base.inv-Union{Tuple{EulerAngleAxis{T}}, Tuple{T}} where T&lt;:Number"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv(ea::EulerAngleAxis)</code></pre><p>Compute the inverse rotation of <code>ea</code>. The Euler angle returned by this function will always be in the interval [0, π].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Quaternion}" href="#LinearAlgebra.norm-Tuple{Quaternion}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function norm(q::Quaternion)</code></pre><p>Compute the Euclidean norm of the quaternion <code>q</code>:</p><pre><code class="language-none">sqrt(q0² + q1² + q2² + q3²)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angle-Tuple{Number,Number,Number,Symbol,Symbol}" href="#ReferenceFrameRotations.angle_to_angle-Tuple{Number,Number,Number,Symbol,Symbol}"><code>ReferenceFrameRotations.angle_to_angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function angle_to_angle(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq_orig::Symbol, rot_seq_dest::Symbol)
@inline function angle_to_angle(Θ::EulerAngles, rot_seq_dest::Symbol)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq_orig</code> to a new set of Euler angles with rotation sequence <code>rot_seq_dest</code>. The input values of the origin Euler angles can also be passed inside the structure <code>Θ</code> (see <code>EulerAngles</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_angle(-pi/2, -pi/3, -pi/4, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X):  -1.0472 rad ( -60.0000 deg)
  R(Y):   0.7854 rad (  45.0000 deg)
  R(Z):  -1.5708 rad ( -90.0000 deg)

julia&gt; angle_to_angle(-pi/2, 0, 0, :ZYX, :XYZ)
EulerAngles{Float64}:
  R(X):   0.0000 rad (   0.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):  -1.5708 rad ( -90.0000 deg)

julia&gt; Θ = EulerAngles(1,2,3,:XYX)
EulerAngles{Int64}:
  R(X):   1.0000 rad (  57.2958 deg)
  R(Y):   2.0000 rad ( 114.5916 deg)
  R(X):   3.0000 rad ( 171.8873 deg)

julia&gt; angle_to_angle(Θ,:ZYZ)
EulerAngles{Float64}:
  R(Z):  -2.7024 rad (-154.8356 deg)
  R(Y):   1.4668 rad (  84.0393 deg)
  R(Z):  -1.0542 rad ( -60.3984 deg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_angleaxis" href="#ReferenceFrameRotations.angle_to_angleaxis"><code>ReferenceFrameRotations.angle_to_angleaxis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">@inline function angle_to_angleaxis(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)
@inline function angle_to_angleaxis(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to an Euler angle and axis representation.  Those values can also be passed inside the structure <code>Θ</code> (see <code>EulerAngles</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_angleaxis(1,0,0,:XYZ)
EulerAngleAxis{Float64}:
  Euler angle:   1.0000 rad ( 57.2958 deg)
   Euler axis: [  1.0000,   0.0000,   0.0000]

julia&gt; Θ = EulerAngles(1,1,1,:XYZ);

julia&gt; angle_to_angleaxis(Θ)
EulerAngleAxis{Float64}:
  Euler angle:   1.9391 rad (111.1015 deg)
   Euler axis: [  0.6924,   0.2031,   0.6924]
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm" href="#ReferenceFrameRotations.angle_to_dcm"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function angle_to_dcm(θ₁::Number, θ₂::Number, θ₃::Number, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a direction cosine matrix.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">dcm = angle_to_dcm(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_dcm-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angle_to_dcm(Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a direction cosine matrix.</p><p><strong>Returns</strong></p><p>The direction cosine matrix.</p><p><strong>Remarks</strong></p><p>This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_dcm(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_quat-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angle_to_quat(eulerang::EulerAngles)</code></pre><p>Convert the Euler angles <code>eulerang</code> (see <code>EulerAngles</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T3}, Tuple{T1,T2,T3,Symbol}} where T3&lt;:Number where T2&lt;:Number where T1&lt;:Number" href="#ReferenceFrameRotations.angle_to_quat-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T3}, Tuple{T1,T2,T3,Symbol}} where T3&lt;:Number where T2&lt;:Number where T1&lt;:Number"><code>ReferenceFrameRotations.angle_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angle_to_quat(θ₁::T1, θ₂::T2, θ₃::T3, rot_seq::Symbol = :ZYX) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}</code></pre><p>Convert the Euler angles <code>θ₁</code>, <code>θ₂</code>, and <code>θ₃</code> [rad] with the rotation sequence <code>rot_seq</code> to a quaternion.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Remarks</strong></p><p>This function assigns <code>q = q1 * q2 * q3</code> in which <code>qi</code> is the quaternion related with the <em>i</em>-th rotation, <code>i Є [1,2,3]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; angle_to_quat(pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{EulerAngles}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline angle_to_rot([T,] Θ::EulerAngles)</code></pre><p>Convert the Euler angles <code>Θ</code> (see <code>EulerAngles</code>) to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(EulerAngles(pi/2, pi/3, pi/4, :ZYX))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,EulerAngles(pi/2, pi/3, pi/4, :ZYX))
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j +
  0.43045933457687935.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angle_to_rot-Tuple{Number,Number,Number,Symbol}" href="#ReferenceFrameRotations.angle_to_rot-Tuple{Number,Number,Number,Symbol}"><code>ReferenceFrameRotations.angle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline angle_to_rot([T,] θx::Number, θy::Number, θz::Number, rot_seq::Symbol)</code></pre><p>Convert the Euler angles <code>Θx</code>, <code>Θy</code>, and <code>Θz</code> [rad] with the rotation sequence <code>rot_seq</code> to a rotation description of type <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then it defaults to <code>DCM</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_rot(pi/2, pi/3, pi/4, :ZYX)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  3.06162e-17  0.5       -0.866025
 -0.707107     0.612372   0.353553
  0.707107     0.612372   0.353553

julia&gt; q   = angle_to_rot(Quaternion,pi/2, pi/3, pi/4, :ZYX)
Quaternion{Float64}:
  + 0.7010573846499779 - 0.09229595564125714.i + 0.5609855267969309.j + 0.43045933457687935.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number,AbstractArray{T,1} where T,Symbol}" href="#ReferenceFrameRotations.angleaxis_to_angle-Tuple{Number,AbstractArray{T,1} where T,Symbol}"><code>ReferenceFrameRotations.angleaxis_to_angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function angleaxis_to_angle(θ::Number, v::AbstractVector, rot_seq::Symbol)
@inline function angleaxis_to_angle(ea::EulerAngleAxis, rot_seq::Symbol)</code></pre><p>Convert the Euler angle <code>θ</code> [rad]  and Euler axis <code>v</code>, which must be a unit vector, to Euler angles with rotation sequence <code>rot_seq</code>. Those values can also be passed inside the structure <code>ea</code> (see <code>EulerAngleAxis</code>).</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ea = EulerAngleAxis(45*pi/180, [1;0;0]);

julia&gt; angleaxis_to_angles(ea, :ZXY)
EulerAngles{Float64}:
  R(Z):   0.0000 rad (   0.0000 deg)
  R(X):   0.7854 rad (  45.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.angleaxis_to_dcm-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.angleaxis_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function angleaxis_to_dcm(a::Number, v::AbstractVector)
@inline function angleaxis_to_dcm(ea::EulerAngleAxis)</code></pre><p>Convert the Euler angle <code>a</code> [rad] and Euler axis <code>v</code>, which must be a unit vector to a DCM. Those values can also be passed inside the structure <code>ea</code> (see <code>EulerAngleAxis</code>).</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_dcm(pi/2,v)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333

julia&gt; ea = EulerAngleAxis(pi/2,v);

julia&gt; angleaxis_to_dcm(ea)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.333333   0.910684  -0.244017
 -0.244017   0.333333   0.910684
  0.910684  -0.244017   0.333333</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{EulerAngleAxis}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angleaxis_to_quat(angleaxis::EulerAngleAxis)</code></pre><p>Convert a Euler angle and Euler axis <code>angleaxis</code> (see <code>EulerAngleAxis</code>) to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>angleaxis.v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(EulerAngleAxis(pi/2,v))
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.angleaxis_to_quat-Tuple{Number,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.angleaxis_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function angleaxis_to_quat(θ::Number, v::AbstractVector)</code></pre><p>Convert the Euler angle <code>θ</code> [rad] and Euler axis <code>v</code>, which must be a unit vector, to a quaternion.</p><p><strong>Remarks</strong></p><p>It is expected that the vector <code>v</code> is unitary. However, no verification is performed inside the function. The user must handle this situation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1;1;1];

julia&gt; v /= norm(v);

julia&gt; angleaxis_to_quat(pi/2,v)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.408248290463863.i + 0.408248290463863.j + 0.408248290463863.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.compose_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.compose_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function compose_rotation(R1, [, R2, R3, R4, R5, ...])</code></pre><p>Compute a composed rotation using the rotations <code>R1</code>, <code>R2</code>, <code>R3</code>, <code>R4</code>, ..., in the following order:</p><pre><code class="language-none"> First rotation
 |
 |
R1 =&gt; R2 =&gt; R3 =&gt; R4 =&gt; ...
       |
       |
       Second rotation</code></pre><p>The rotations can be described by:</p><ul><li>A direction cosina matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler anlges (<code>EulerAngles</code>); or</li><li>A quaternion (<code>Quaternion</code>).</li></ul><p>Notice, however, that all rotations <strong>must be</strong> of the same type (DCM or quaternion).</p><p>The output will have the same type as the inputs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D1 = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; D2 = angle_to_dcm(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(D1,D2)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          0.0          5.55112e-17
 0.0          1.0          5.55112e-17
 5.55112e-17  5.55112e-17  1.0

julia&gt; ea1 = EulerAngleAxis(30*pi/180, [0;1;0]);

julia&gt; ea2 = EulerAngleAxis(45*pi/180, [0;1;0]);

julia&gt; compose_rotation(ea1,ea2)
EulerAngleAxis{Float64}:
  Euler angle:   1.3090 rad ( 75.0000 deg)
   Euler axis: [  0.0000,   1.0000,   0.0000]

julia&gt; Θ1 = EulerAngles(1,2,3,:ZYX);

julia&gt; Θ2 = EulerAngles(-3,-2,-1,:XYZ);

julia&gt; compose_rotation(Θ1, Θ2)
EulerAngles{Float64}:
  R(X):  -0.0000 rad (  -0.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):  -0.0000 rad (  -0.0000 deg)

julia&gt; q1 = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; q2 = angle_to_quat(-pi/5,-pi/4,-pi/3,:XYZ);

julia&gt; compose_rotation(q1,q2)
Quaternion{Float64}:
  + 1.0 + 0.0.i + 2.0816681711721685e-17.j + 5.551115123125783e-17.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.create_rotation_matrix" href="#ReferenceFrameRotations.create_rotation_matrix"><code>ReferenceFrameRotations.create_rotation_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function create_rotation_matrix(angle::Number, axis::Symbol = :X)</code></pre><p>Compute a rotation matrix that rotates a coordinate frame about the axis <code>axis</code> by the angle <code>angle</code>. The <code>axis</code> must be one of the following symbols: <code>:X</code>, <code>:Y</code>, or <code>:Z</code>.</p><p><strong>Example</strong></p><pre><code class="language-jldocstest">julia&gt; create_rotation_matrix(pi/2, :X)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0          0.0
 0.0   6.12323e-17  1.0
 0.0  -1.0          6.12323e-17</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angle-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}, Tuple{SArray{Tuple{3,3},T,2,9},Symbol}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angle-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}, Tuple{SArray{Tuple{3,3},T,2,9},Symbol}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dcm_to_angle(dcm::DCM, rot_seq::Symbol=:ZYX)</code></pre><p>Convert the DCM <code>dcm</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Gimbal-lock and special cases</strong></p><p>If the rotations are about three different axes, <em>e.g.</em> <code>:XYZ</code>, <code>:ZYX</code>, etc., then a second rotation of <code>±90˚</code> yields a gimbal-lock. This means that the rotations between the first and third axes have the same effect. In this case, the net rotation angle is assigned to the first rotation and the angle of the third rotation is set to 0.</p><p>If the rotations are about two different axes, <em>e.g.</em> <code>:XYX</code>, <code>:YXY</code>, etc., then a rotation about the duplicated axis yields multiple representations. In this case, the entire angle is assigned to the first rotation and the third rotation is set to 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM([1. 0. 0.; 0. 0. -1; 0. -1 0.]);

julia&gt; dcm_to_angle(D,:XYZ)
EulerAngles{Float64}:
  R(X):   1.5708 rad (  90.0000 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(Z):   0.0000 rad (   0.0000 deg)

julia&gt; D = angle_to_dcm(1, -pi/2, 2, :ZYX);

julia&gt; dcm_to_angle(D,:ZYX)
EulerAngles{Float64}:
  R(Z):   3.0000 rad ( 171.8873 deg)
  R(Y):  -1.5708 rad ( -90.0000 deg)
  R(X):   0.0000 rad (   0.0000 deg)

julia&gt; D = create_rotation_matrix(1,:X)*create_rotation_matrix(2,:X);

julia&gt; dcm_to_angle(D,:XYX)
EulerAngles{Float64}:
  R(X):   3.0000 rad ( 171.8873 deg)
  R(Y):   0.0000 rad (   0.0000 deg)
  R(X):   0.0000 rad (   0.0000 deg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}} where T&lt;:Number" href="#ReferenceFrameRotations.dcm_to_angleaxis-Union{Tuple{SArray{Tuple{3,3},T,2,9}}, Tuple{T}} where T&lt;:Number"><code>ReferenceFrameRotations.dcm_to_angleaxis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dcm_to_angleaxis(dcm::DCM{T}) where T&lt;:Number</code></pre><p>Convert the DCM <code>dcm</code> to an Euler angle and axis representation. By convention, the returned Euler angle will always be in the interval [0, π].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.dcm_to_quat-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.dcm_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dcm_to_quat(dcm::DCM)</code></pre><p>Convert the DCM <code>dcm</code> to a quaternion. The type of the quaternion will be automatically selected by the constructor <code>Quaternion</code> to avoid <code>InexactError</code>.</p><p><strong>Remarks</strong></p><p>By convention, the real part of the quaternion will always be positive. Moreover, the function does not check if <code>dcm</code> is a valid direction cosine matrix. This must be handle by the user.</p><p>This algorithm was obtained from:</p><pre><code class="language-none">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = angle_to_dcm(pi/2,0.0,0.0,:XYZ);

julia&gt; q   = dcm_to_quat(dcm)
Quaternion{Float64}:
  + 0.7071067811865476 + 0.7071067811865475.i + 0.0.j + 0.0.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T,AbstractArray}" href="#ReferenceFrameRotations.ddcm-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T,AbstractArray}"><code>ReferenceFrameRotations.ddcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function ddcm(Dba::DCM, wba_b::AbstractArray)</code></pre><p>Compute the time-derivative of the DCM <code>dcm</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Returns</strong></p><p>The time-derivative of the DCM <code>Dba</code> (3x3 matrix of type <code>SMatrix{3,3}</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(Matrix{Float64}(I,3,3));

julia&gt; ddcm(D,[1;0;0])
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.0   0.0  0.0
 0.0   0.0  1.0
 0.0  -1.0  0.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.dquat-Tuple{Quaternion,AbstractArray{T,1} where T}" href="#ReferenceFrameRotations.dquat-Tuple{Quaternion,AbstractArray{T,1} where T}"><code>ReferenceFrameRotations.dquat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function dquat(qba::Quaternion, wba_b::AbstractVector)</code></pre><p>Compute the time-derivative of the quaternion <code>qba</code> that rotates a reference frame <code>a</code> into alignment to the reference frame <code>b</code> in which the angular velocity of <code>b</code> with respect to <code>a</code>, and represented in <code>b</code>, is <code>wba_b</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(1.0I);

julia&gt; dquat(q,[1;0;0])
Quaternion{Float64}:
  + 0.0 + 0.5.i + 0.0.j + 0.0.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.inv_rotation-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.inv_rotation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function inv_rotation(R)</code></pre><p>Compute the inverse rotation of <code>R</code>, which can be:</p><ul><li>A direction cosina matrix (<code>DCM</code>);</li><li>An Euler angle and axis (<code>EulerAngleAxis</code>);</li><li>A set of Euler anlges (<code>EulerAngles</code>); or</li><li>A quaternion (<code>Quaternion</code>).</li></ul><p>The output will have the same type as <code>R</code> (DCM or quaternion).</p><p><strong>Remarks</strong></p><p>If <code>R</code> is a DCM, than its transpose is computed instead of its inverse to reduce the computational burden. The both are equal if the DCM has unit norm. This must be verified by the user.</p><p>If <code>R</code> is a quaternion, than its conjugate is computed instead of its inverse to reduce the computational burden. The both are equal if the quaternion has unit norm. This must be verified by the used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = angle_to_dcm(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.353553  -0.492816  0.795068
  0.612372   0.764452  0.201527
 -0.707107   0.415627  0.572061

julia&gt; ea = EulerAngleAxis(30*pi/180, [1;0;0]);

julia&gt; inv_rotation(ea)
EulerAngleAxis{Float64}:
  Euler angle:   0.5236 rad ( 30.0000 deg)
   Euler axis: [ -1.0000,  -0.0000,  -0.0000]

julia&gt; Θ = EulerAngles(-pi/3, -pi/2, -pi, :YXZ);

julia&gt; inv_rotation(Θ)
EulerAngles{Float64}:
  R(Z):   3.1416 rad ( 180.0000 deg)
  R(X):   1.5708 rad (  90.0000 deg)
  R(Y):   1.0472 rad (  60.0000 deg)

julia&gt; q = angle_to_quat(+pi/3,+pi/4,+pi/5,:ZYX);

julia&gt; inv_rotation(q)
Quaternion{Float64}:
  + 0.8200711519756747 - 0.06526868310243991.i - 0.45794027732580056.j - 0.336918398289752.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}" href="#ReferenceFrameRotations.orthonormalize-Tuple{StaticArrays.SArray{Tuple{3,3},T,2,9} where T}"><code>ReferenceFrameRotations.orthonormalize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function orthonormalize(dcm::DCM)</code></pre><p>Perform the Gram-Schmidt orthonormalization process in the DCM <code>dcm</code> and return the new matrix.</p><p><strong>Warning</strong>: This function does not check if the columns of the input matrix span a three-dimensional space. If not, then the returned matrix should have <code>NaN</code>. Notice, however, that such input matrix is not a valid direction cosine matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = DCM(3I)

julia&gt; orthonormalize(D)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angle" href="#ReferenceFrameRotations.quat_to_angle"><code>ReferenceFrameRotations.quat_to_angle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function quat_to_angle(q::Quaternion, rot_seq::Symbol = :ZYX)</code></pre><p>Convert the quaternion <code>q</code> to Euler Angles (see <code>EulerAngles</code>) given a rotation sequence <code>rot_seq</code>.</p><p>The rotation sequence is defined by a <code>:Symbol</code>. The possible values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>, <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, and <code>:ZYZ</code>. If no value is specified, then it defaults to <code>:ZYX</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angle(q,:XYZ)
EulerAngles{Float64}(0.7853981633974484, 0.0, -0.0, :XYZ)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#ReferenceFrameRotations.quat_to_angleaxis-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>ReferenceFrameRotations.quat_to_angleaxis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function quat_to_angleaxis(q::Quaternion{T}) where T</code></pre><p>Convert the quaternion <code>q</code> to a Euler angle and axis representation (see <code>EulerAngleAxis</code>). By convention, the Euler angle will be kept between [0, π] rad.</p><p><strong>Remarks</strong></p><p>This function will not fail if the quaternion norm is not 1. However, the meaning of the results will not be defined, because the input quaternion does not represent a 3D rotation. The user must handle such situations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_angleaxis(q)
EulerAngleAxis{Float64}(0.7853981633974484, [1.0, 0.0, 0.0])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}" href="#ReferenceFrameRotations.quat_to_dcm-Tuple{Quaternion}"><code>ReferenceFrameRotations.quat_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function quat_to_dcm(q::Quaternion)</code></pre><p>Convert the quaternion <code>q</code> to a Direction Cosine Matrix (DCM).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Quaternion(cosd(45/2), sind(45/2), 0, 0);

julia&gt; quat_to_dcm(q)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0   0.0       0.0
 0.0   0.707107  0.707107
 0.0  -0.707107  0.707107</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_dcm-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_dcm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_dcm(θx::Number, θy::Number, θz::Number; normalize = true)</code></pre><p>Create a direction cosine matrix from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively. If the keyword <code>normalize</code> is <code>true</code>, then the matrix will be normalized using the function <code>orthonormalize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; smallangle_to_dcm(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_quat-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_quat-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_quat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_quat(θx::Number, θy::Number, θz::Number)</code></pre><p>Create a quaternion from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p><strong>Remarks</strong></p><p>The quaternion is normalized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; smallangle_to_quat(+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.smallangle_to_rot-Tuple{Number,Number,Number}" href="#ReferenceFrameRotations.smallangle_to_rot-Tuple{Number,Number,Number}"><code>ReferenceFrameRotations.smallangle_to_rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function smallangle_to_rot([T,] θx::Number, θy::Number, θz::Number[; normalize = true])</code></pre><p>Create a rotation description of type <code>T</code> from three small rotations of angles <code>θx</code>, <code>θy</code>, and <code>θz</code> [rad] about the axes X, Y, and Z, respectively.</p><p>The type <code>T</code> of the rotation description can be <code>DCM</code> or <code>Quaternion</code>. If the type <code>T</code> is not specified, then if defaults to <code>DCM</code>.</p><p>If <code>T</code> is <code>DCM</code>, then the resulting matrix will be orthonormalized using the <code>orthonormalize</code> function if the keyword <code>normalize</code> is <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.9999     0.00989903  0.010098
 -0.009999   0.999901    0.00989802
 -0.009999  -0.009998    0.9999

julia&gt; dcm = smallangle_to_rot(+0.01, -0.01, +0.01; normalize = false)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0    0.01  0.01
 -0.01   1.0   0.01
 -0.01  -0.01  1.0

julia&gt; q   = smallangle_to_rot(Quaternion,+0.01, -0.01, +0.01)
Quaternion{Float64}:
  + 0.9999625021092433 + 0.004999812510546217.i - 0.004999812510546217.j + 0.004999812510546217.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReferenceFrameRotations.vect-Tuple{Quaternion}" href="#ReferenceFrameRotations.vect-Tuple{Quaternion}"><code>ReferenceFrameRotations.vect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function vect(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,1} where T,Quaternion}" href="#Base.:*-Tuple{AbstractArray{T,1} where T,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(v::AbstractVector, q::Quaternion)
@inline function *(q::Quaternion, v::AbstractVector)</code></pre><p>Compute the multiplication <code>qv*q</code> or <code>q*qv</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{EulerAngles,EulerAngles}" href="#Base.:*-Tuple{EulerAngles,EulerAngles}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function *(Θ₂::EulerAngles, Θ₁::EulerAngles)</code></pre><p>Compute the composed rotation of <code>Θ₁ -&gt; Θ₂</code>. Notice that the rotation will be represented by Euler angles (see <code>EulerAngles</code>) with the same rotation sequence as <code>Θ₂</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:*-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(u::UniformScaling, q::Quaternion)
@inline function *(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu*q</code> or <code>q*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Number,Quaternion}" href="#Base.:*-Tuple{Number,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(λ::Number, q::Quaternion)
@inline function *(q::Quaternion, λ::Number)</code></pre><p>Compute <code>λ*q</code> or <code>q*λ</code>, in which <code>λ</code> is a scalar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Quaternion,Quaternion}" href="#Base.:*-Tuple{Quaternion,Quaternion}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function *(q1::Quaternion, q2::Quaternion)</code></pre><p>Compute the quaternion multiplication <code>q1*q2</code> (Hamilton product).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1},EulerAngleAxis{T2}}} where T2 where T1" href="#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{EulerAngleAxis{T1},EulerAngleAxis{T2}}} where T2 where T1"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function *(ea₂::EulerAngleAxis{T1}, ea₁::EulerAngleAxis{T2}) where {T1,T2}</code></pre><p>Compute the composed rotation of <code>ea₁ -&gt; ea₂</code>. Notice that the rotation will be represented by a Euler angle and axis (see <code>EulerAngleAxis</code>). By convention, the output angle will always be in the range [0, π] [rad].</p><p>Notice that the vector representing the axis in <code>ea₁</code> and <code>ea₂</code> must be unitary. This function neither verifies this nor normalizes the vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:+-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function +(u::UniformScaling, q::Quaternion)
@inline function +(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu + q</code> or <code>q + qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{Quaternion,Quaternion}" href="#Base.:+-Tuple{Quaternion,Quaternion}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function +(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa + qb</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:--Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function -(u::UniformScaling, q::Quaternion)
@inline function -(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu - q</code> or <code>q - qu</code>, in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Quaternion,Quaternion}" href="#Base.:--Tuple{Quaternion,Quaternion}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function -(qa::Quaternion, qb::Quaternion)</code></pre><p>Compute <code>qa - qb</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:/-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function /(u::UniformScaling, q::Quaternion)
@inline function /(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>qu/q</code> or <code>q/qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{Number,Quaternion}" href="#Base.:/-Tuple{Number,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function /(λ::Number, q::Quaternion)
@inline function /(q::Quaternion, λ::Number)</code></pre><p>Compute the division <code>λ/q</code> or <code>q/λ</code>, in which <code>λ</code> is a scalar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/-Tuple{Quaternion,Quaternion}" href="#Base.:/-Tuple{Quaternion,Quaternion}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline /(q1::Quaternion, q2::Quaternion) = q1*inv(q2)</code></pre><p>Compute <code>q1*inv(q2)</code> (Hamilton product).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{LinearAlgebra.UniformScaling,Quaternion}" href="#Base.:\\-Tuple{LinearAlgebra.UniformScaling,Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function \(u::UniformScaling, q::Quaternion)
@inline function \(q::Quaternion, u::UniformScaling)</code></pre><p>Compute <code>inv(qu)*q</code> or <code>inv(q)*qu</code> (Hamilton product), in which <code>qu</code> is the scaled identity quaternion <code>qu = u.λ * I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion,AbstractArray{T,1} where T}" href="#Base.:\\-Tuple{Quaternion,AbstractArray{T,1} where T}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline \(q::Quaternion, v::AbstractVector)
@inline \(v::AbstractVector, q::Quaternion)</code></pre><p>Compute <code>inv(q)*qv</code> or <code>inv(qv)*q</code> in which <code>qv</code> is a quaternion with real part <code>0</code> and vectorial/imaginary part <code>v</code> (Hamilton product).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Quaternion,Quaternion}" href="#Base.:\\-Tuple{Quaternion,Quaternion}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline \(q1::Quaternion, q2::Quaternion) = inv(q1)*q2</code></pre><p>Compute <code>inv(q1)*q2</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj-Tuple{Quaternion}" href="#Base.conj-Tuple{Quaternion}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function conj(q::Quaternion)</code></pre><p>Compute the complex conjugate of the quaternion <code>q</code>:</p><pre><code class="language-none">q0 - q1.i - q2.j - q3.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.copy-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function copy(q::Quaternion{T}) where T</code></pre><p>Create a copy of the quaternion <code>q</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Quaternion,Colon}" href="#Base.getindex-Tuple{Quaternion,Colon}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function getindex(q::Quaternion, ::Colon)</code></pre><p>Transform the quaternion into a 4x1 vector of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.imag-Tuple{Quaternion}" href="#Base.imag-Tuple{Quaternion}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function imag(q::Quaternion)</code></pre><p>Return the vectorial or imaginary part of the quaternion <code>q</code> represented by a 3 × 1 vector of type <code>SVector{3}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Quaternion}" href="#Base.real-Tuple{Quaternion}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function real(q::Quaternion)</code></pre><p>Return the real part of the quaternion <code>q</code>: <code>q0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO,EulerAngleAxis{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO,EulerAngleAxis{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function display(ea::EulerAngleAxis{T}) where T
function show(io::IO, mime::MIME&quot;text/plain&quot;, ea::EulerAngleAxis{T}) where T</code></pre><p>Display in <code>stdout</code> the Euler angle and axis <code>ea</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO,EulerAngles{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO,EulerAngles{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function show(io::IO, Θ::EulerAngles{T}) where T
function show(io::IO, mime::MIME&quot;text/plain&quot;, Θ::EulerAngles{T}) where T</code></pre><p>Print the Euler angles <code>Θ</code> to the IO <code>io</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO,Quaternion{T}}} where T" href="#Base.show-Union{Tuple{T}, Tuple{IO,Quaternion{T}}} where T"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function show(io::IO, q::Quaternion{T}) where T
function show(io::IO, mime::MIME&quot;text/plain&quot;, q::Quaternion{T}) where T</code></pre><p>Print the quaternion <code>q</code> to the stream <code>io</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Quaternion{T}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function zeros(q::Quaternion{T}) where T</code></pre><p>Create the null quaternion with the same type <code>T</code> of another quaternion <code>q</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q1 = Quaternion{Float32}(cosd(45/2),sind(45/2),0,0);

julia&gt; zeros(q1)
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T" href="#Base.zeros-Union{Tuple{Type{Quaternion{T}}}, Tuple{T}} where T"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">@inline function zeros(::Type{Quaternion{T}}) where T</code></pre><p>Create the null quaternion of type <code>T</code>:</p><pre><code class="language-none">T(0) + T(0).i + T(0).j + T(0).k</code></pre><p>If the type <code>T</code> is omitted, then it defaults to <code>Float64</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; zeros(Quaternion{Float32})
Quaternion{Float32}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k

julia&gt; zeros(Quaternion)
Quaternion{Float64}:
  + 0.0 + 0.0.i + 0.0.j + 0.0.k</code></pre></div></div></section><footer><hr/><a class="previous" href="../../man/inv_rotations/"><span class="direction">Previous</span><span class="title">Inverting rotations</span></a></footer></article></body></html>
