<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · LLLplus.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LLLplus.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LLLplus-1" href="#LLLplus-1">LLLplus</a></h1><p><a href="https://travis-ci.org/christianpeel/LLLplus.jl"><img src="https://travis-ci.org/christianpeel/LLLplus.jl.svg?branch=master" alt="Build Status"/></a> <a href="http://pkg.julialang.org/?pkg=LLLplus&amp;ver=0.7"><img src="http://pkg.julialang.org/badges/LLLplus_release.svg" alt="LLLplus"/></a></p><p>Lattice reduction and related lattice tools are used in wireless communication, cryptography, and mathematics.  This package provides the following tools: Lenstra-Lenstra-Lovacsz (LLL) lattice reduction, Seysen lattice reduction, a sphere decoder, and VBLAST matrix decomposition. This package was created as a way to explore the Julia language, and is not intended to be a cannonical tool for lattice reduction; <em>use at your own risk!</em> :-)</p><p><a href="https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm">LLL</a> [1] lattice reduction is a powerful tool in computer science that is used to cryptanalysis of public-key systems, to solve quadratic equations, and to solve other linear problems such as in multi-terminal wireless. The LLL is often used as a bounded-complexity approximate solution to the <a href="https://en.wikipedia.org/wiki/Lattice_problem#Shortest_vector_problem_.28SVP.29">shortest vector problem</a> (SVP). Seysen [2] introduced a lattice reduction which focuses on global optimization rather than local optimization as in LLL. The <a href="https://en.wikipedia.org/wiki/Lattice_problem#Closest_vector_problem_.28CVP.29">closest vector problem</a> (CVP) is related to the SVP; in the context of multi-antenna decoding it is referred to as <a href="https://en.wikipedia.org/wiki/Lattice_problem#Sphere_decoding">sphere-decoding</a>.</p><p>Finally, we include code to do a <a href="https://en.wikipedia.org/wiki/Bell_Laboratories_Layered_Space-Time">V-BLAST</a> (Vertical-Bell Laboratories Layered Space-Time) matrix decomposition. This decomposition is used in a detection algorithm [3] for decoding spatially-multiplexed streams of data on multiple antennas or other multi-terminal systems. V-BLAST is not as widely used outside of the wireless communication community as lattice reduction and CVP techniques such as the sphere decoder. In the Julia package <a href="https://github.com/christianpeel/MUMIMO.jl">MUMIMO.jl</a> we use the LLL, sphere-decoder, and V-BLAST functions in this package to decode multi-user, multi-antenna signals.</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>Here are a few examples of using the functions in the package on random lattices.</p><pre><code class="language-julia">Pkg.add(&quot;LLLplus&quot;)
using LLLplus

# Time LLL, VBLAST decomposition of a complex matrix with randn entries 
N = 1000;
H = randn(N,N) + im*randn(N,N);
println(&quot;Testing LLL on $(N)x$(N) complex matrix...&quot;)
@time (B,T,Q,R) = lll(H);
M = 200;
println(&quot;Testing VBLAST on $(M)x$(M) chunk of same matrix...&quot;)
@time (W,P,B) = vblast(H[1:M,1:M]);

# Time LLL, Seysen decompositions of a 100x100 Int64 matrix with
# rand entries distributed uniformly between -100:100
N = 100;
H = rand(-100:100,N,N);
println(&quot;Testing LLL on $(N)x$(N) real matrix...&quot;)
@time (B,T,Q,R) = lll(H);
println(&quot;Testing Seysen on same $(N)x$(N) matrix...&quot;)
@time (B,T) = seysen(H);</code></pre><h3><a class="nav-anchor" id="Execution-Time-results-1" href="#Execution-Time-results-1">Execution Time results</a></h3><p>On this page we give a few performance results obtained from the following command in the top-level LLLplus directory: <code>julia -e &#39;include(&quot;benchmark/perftest.jl&quot;)&#39;</code> In the tests we time execution of the lattice-reduction functions, average the results over multiple random matrices, and show results as a function of the size of the matrix and of the data type. </p><p>We first show how the time varies with matrix size (1,2,4,...64); the vertical axis shows execution time on a logarithmic scale; the x-axis is also logarithmic. The generally linear nature of the LLL curve supports the polynomial-time nature of the algorithm. Each data point is the average of execution time of 10 runs of a lattice-reduction technique, where the matrices used were generated using &#39;randn&#39; to emulate unit-variance Gaussian-distributed values. <img src="benchmark/perfVsNfloat32.png" alt="Time vs matrix size"/></p><p>Though the focus of the package is on floating-point,  all the modules can handle a variety of data types. In the next figure we show execution time for several datatypes (Int32, Int64, Int128, Float64, BitInt, and BigFloat) which are used to generate 100 4x4 matrices, over which execution time for the lattice reduction techniques is averaged.  The vertical axis is a logarithmic representation of execution time as in the previous figure. <img src="benchmark/perfVsDataTypeN16.png" alt="Time vs data type"/></p><h3><a class="nav-anchor" id="Future-1" href="#Future-1">Future</a></h3><p>Possible improvements include:</p><ul><li>Change from &quot;LLLplus&quot; to &quot;LLLtoy&quot; or some such to emphasize the nature of this package.</li><li>Add Block-Korkin-Zolotarev lattice redution, with improvements   as in [4], and Brun lattice reduction </li><li>The <a href="http://www.latticechallenge.org/svp-challenge/">SVP</a> Challenge and the <a href="http://www.latticechallenge.org/ideallattice-challenge/">Ideal</a> Lattice challenge have code to generate lattices for the respective contests which could be used or duplicated to make challenging performance tests. The main <a href="http://www.latticechallenge.org/">Lattice</a> Challenge also lists references which could be used to replicate tests.</li><li>Compare with the <a href="http://www.shoup.net/ntl/">Number Theory Library</a>.</li></ul><h3><a class="nav-anchor" id="References-1" href="#References-1">References</a></h3><p>[1] Lenstra, A. K.; Lenstra, H. W., Jr.; Lovász, L. (1982). &quot;Factoring polynomials with rational coefficients&quot;. Mathematische Annalen 261 (4): 515–534.</p><p>[2] M. Seysen, <a href="http://link.springer.com/article/10.1007%2FBF01202355">&quot;Simultaneous reduction of a lattice basis and its reciprocal basis&quot;</a> Combinatorica, Vol 13, no 3, pp 363-376, 1993.</p><p>[3] P. W. Wolniansky, G. J. Foschini, G. D. Golden, R. A. Valenzuela (September 1998). <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=738086">&quot;V-BLAST: An Architecture for Realizing Very High Data Rates Over the Rich-Scattering Wireless Channel&quot;</a>. Proc. URSI ISSSE: 295–300. </p><p>[4] Y. Chen, P. Q. Nguyen (2011) <a href="http://www.iacr.org/archive/asiacrypt2011/70730001/70730001.pdf">&quot;BKZ 2.0: Better Lattice Security Estimates&quot;</a>. Proc. ASIACRYPT 2011.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
