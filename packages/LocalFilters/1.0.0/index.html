<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · LocalFilters.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LocalFilters.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Summary-1">Summary</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li><li><a class="toctext" href="#Neighborhoods-1">Neighborhoods</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LocalFilters.jl-1" href="#LocalFilters.jl-1">LocalFilters.jl</a></h1><p><a href="LICENSE.md"><img src="http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat" alt="License"/></a> <a href="https://travis-ci.org/emmt/LocalFilters.jl"><img src="https://travis-ci.org/emmt/LocalFilters.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/emmt/LocalFilters-jl/branch/master"><img src="https://ci.appveyor.com/api/projects/status/github/emmt/LocalFilters.jl?branch=master" alt="Build Status"/></a> <a href="https://coveralls.io/github/emmt/LocalFilters.jl?branch=master"><img src="https://coveralls.io/repos/emmt/LocalFilters.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a> <a href="http://codecov.io/github/emmt/LocalFilters.jl?branch=master"><img src="http://codecov.io/github/emmt/LocalFilters.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>This package implements multi-dimensional local filters for <a href="http://julialang.org/">Julia</a> (convolution, mathematical morphology, etc.). Local filters are defined by specific operations combining each value of a source array with the values in a local neighborhood which may have any size, shape and dimensionality.  Predefined local filters are provided as well as means to simply implement custom filters.</p><p>This document is structured as follows:</p><ul><li><p><a href="#summary">Summary</a> provides a quick introduction.</p></li><li><p><a href="#implementation">Implementation</a> explains how to implement you own filter.</p></li><li><p><a href="#neighborhoods">Neighborhoods</a> describes the concept of neighborhoods.</p></li><li><p><a href="#installation">Installation</a> to install the package.</p></li></ul><p>Note that this is a first implementation to define the API.  It is is reasonably fast (see <a href="src/benchmarks.jl">benchmarks.jl</a>) but separable kernels can be made faster.</p><p>Packages with overlapping functionalities:</p><ul><li><p><a href="https://github.com/JuliaImages/ImageFiltering.jl">ImageFiltering</a> for local filters on multidimensional arrays (not just <em>images</em>), also implement various boundary conditions;</p></li><li><p><a href="https://github.com/JuliaImages/ImageMorphology.jl">ImageMorphology</a> for fast morphological operations with separable structuring elements;</p></li></ul><h2><a class="nav-anchor" id="Summary-1" href="#Summary-1">Summary</a></h2><p><strong>LocalFilters</strong> implements local filtering operations which combine the values of an array in a neighborhood of each elements of the array (and possibly the values of a kernel associated with the neighborhood).  The neighborhood is defined relatively to a given position by an instance of a type derived from <code>Neighborhood</code>.  For <a href="https://en.wikipedia.org/wiki/Mathematical_morphology">mathematical morphology</a> operations, a neighborhood is called a <em>structuring element</em>.</p><p>Denoting <code>A</code> the source array and <code>B</code> the neighborhood or the kernel (by default <code>B</code> is a centered box of size 3 along every dimension), the available filters are:</p><ul><li><p><code>erode(A, B=3)</code> performs an erosion (local minimum) of <code>A</code> by <code>B</code>;</p></li><li><p><code>dilate(A, B=3)</code> performs a dilation (local maximum) of <code>A</code> by <code>B</code>;</p></li><li><p><code>localextrema(A, B=3)</code> yields the erosion and the dilation of <code>A</code> by <code>B</code>;</p></li><li><p><code>opening(A, B=3)</code> performs an erosion followed by a dilation;</p></li><li><p><code>closing(A, B=3)</code> performs a dilation followed by an erosion;</p></li><li><p><code>top_hat(A, B=3 [, S])</code> performs a summit detection (an optional third argument <code>S</code> may be supplied to pre-smooth <code>A</code> by <code>S</code>);</p></li><li><p><code>bottom_hat(A, B=3 [, S])</code> performs a valley detection (an optional third argument <code>S</code> may be supplied to pre-smooth <code>A</code> by <code>S</code>);</p></li><li><p><code>localmean(A, B=3)</code> performs a local averaging;</p></li><li><p><code>convolve(A, B=3)</code> performs a convolution by the kernel <code>B</code> or by the support of <code>B</code> is <code>eltype(B)</code> is <code>Bool</code>;</p></li><li><p><code>bilateralfilter(A, Fr, Gs)</code> performs a bilateral filtering of array <code>A</code> with <code>Fr</code> the range kernel for smoothing differences in intensities and <code>Gs</code> the spatial kernel for smoothing differences in coordinates (see: https://en.wikipedia.org/wiki/Bilateral_filter).</p></li></ul><p>and many more to come...</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>The pseudo-code for a local filtering operation <code>C = filter(A, B)</code> writes:</p><pre><code class="language-julia">for i ∈ Sup(A)
    v = initial(A[i])
    for j ∈ Sup(B) and such that i-j ∈ Sup(A)
        v = update(v, A[i-j], B[j])
    end
    store(C, i, v)
end</code></pre><p>where <code>A</code> is the source of the operation, <code>B</code> is the neighborhood, <code>C</code> is the result of the operation.  Here <code>Sup(A)</code> denotes the support of <code>A</code> (that is the set of indices in <code>A</code>).  The methods <code>initial</code>, <code>update</code> and <code>store</code> are specific to the considered operation.  To execute the filter, call the <code>localfilter!</code> method as:</p><pre><code class="language-julia">localfilter!(dst, A, B, initial, update, store)</code></pre><p><code>localfilter!</code> applies the local filter defined by the neighborhood <code>B</code> and methods <code>initial</code>, <code>update</code> and <code>store</code> to the source array <code>A</code> and stores the reseult in the destination <code>dst</code> which is then returned.</p><p>For instance, to compute a local maximum (<em>i.e.</em> a <strong>dilation</strong> in mathematical morphology terms):</p><pre><code class="language-julia">initial(a) = typemin(T)
update(v,a,b) = (b &amp;&amp; v &lt; a ? a : v)
store(c,i,v) = c[i] = v</code></pre><p>with <code>T</code> the type of the elements of <code>A</code>.  Of course, anonymous functions can be exploited to implement this filter in a single call:</p><pre><code class="language-julia">localfilter!(dst, A, B,
             (a)     -&gt; typemin(T),           # initial method
             (v,a,b) -&gt; (b &amp;&amp; v &lt; a ? a : v), # update method
             (c,i,v) -&gt; c[i] = v)             # store method</code></pre><p>Below is another example of the methods needed to implement a local average:</p><pre><code class="language-julia">initial(a) = (0, zero(T))
update(v,a,b) = v[1] + 1, v[2] + (b ? a : zero(T))
store(c,i,v) = c[i] = v[2]/v[1]</code></pre><p>The same mechanism can be used to implement other operations such as convolution, median filtering, <em>etc.</em> via the <code>localfilter!</code> driver.</p><h2><a class="nav-anchor" id="Neighborhoods-1" href="#Neighborhoods-1">Neighborhoods</a></h2><p><code>Neighborhood</code> (a.k.a. <em>structuring element</em> for the fans of mathematical morphology) is a central concept in <code>LocalFilters</code>.  The neighborhood defines which values are involved in a local operation for each component of the source array.  Neighborhoods are assumed to be shift invariant but may have any support shape and may have embedded weights (<em>e.g.</em>, to implement <em>local convolution</em>).</p><h3><a class="nav-anchor" id="Types-of-neighborhoods-1" href="#Types-of-neighborhoods-1">Types of neighborhoods</a></h3><p>From the user point of view, there are three kinds of neighborhoods:</p><ul><li><p><strong>Rectangular boxes</strong> are rectangular neighborhoods whose edges are aligned with the axes of array indices and which may be centered or have arbitrary offsets along the dimensions.  These neighborhoods are represented by instances of <code>LocalFilters.RectangularBox</code>.</p></li><li><p><strong>Arbitrarily shaped neighborhoods</strong> are neighborhoods with arbitrary shape and offset.  These neighborhoods are represented by instances of <code>LocalFilters.Kernel</code> with boolean element type.  These neighborhoods are constructed from an array of booleans and an optional starting index.</p></li><li><p><strong>Kernels</strong> are neighborhoods whose elements are weights and which be may have arbitrary offset.  These neighborhoods are represented by instances of <code>LocalFilters.Kernel</code> with numerical element type.  These neighborhoods are constructed from an array of weights and an optional starting index.</p></li></ul><h3><a class="nav-anchor" id="Syntax-for-neighborhoods-1" href="#Syntax-for-neighborhoods-1">Syntax for neighborhoods</a></h3><ul><li><p>The <em>default neighborhood</em> is a centered rectangular box of width 3 in each of its dimensions.</p></li><li><p>A <em>scalar</em> integer <code>w</code> yields a centered rectangular box of size <code>w</code> along all dimensions.  <code>w</code> must be at least equal to 1 and the geometrical center of the box is defined according to the conventions in <code>fftshift</code>.</p></li><li><p>A <em>tuple</em> <code>t</code> of integers yields a centered rectangular box whose size is <code>t[i]</code> along the <code>i</code>-th dimension.  All values of <code>t</code> must be larger or equal to 1.  Tip: Remember that you can use <code>v...</code> to convert a <em>vector</em> <code>v</code> into a tuple.</p></li><li><p>An <em>array</em> <code>A</code> yields a <code>LocalFilters.Kernel</code> whose coefficients are the values of <code>A</code> and whose neighborhood is the centered bounding-box of <code>A</code>.</p></li><li><p>A <em>Cartesian range</em> <code>R</code> (an instance of <code>CartesianIndices</code> or of <code>CartesianRange</code>) yields a <code>LocalFilters.RectangularBox</code> which is a rectangular neighborhood whose support contains all relative positions within <code>first(R)</code> and <code>last(R)</code>.</p></li><li><p>A rectangular box neighborhood created by calling <code>LocalFilters.RectangularBox</code> as:</p><pre><code class="language-julia">LocalFilters.RectangularBox(R)
LocalFilters.RectangularBox(I1, I2)
LocalFilters.RectangularBox(dims, offs)
LocalFilters.RectangularBox(inds)</code></pre><p>where <code>R</code> is an instance of<code>CartesianIndices</code> (or of <code>CartesianRange</code> for old Julia version), <code>I1</code> and <code>I2</code> are two <code>CartesianIndex</code> specifying the first and last relative position within the neighborhood, <code>dims</code> and <code>offs</code> are tuples of integers specifying the dimensions of the neighborhood and its offsets, <code>inds</code> are unit ranges.</p><p>Assuming <code>dim</code> is an integer, then:</p><pre><code class="language-julia">LocalFilters.RectangularBox{N}(dim)</code></pre><p>yields an <code>N</code>-dimensional rectangular box of size <code>dim</code> along all dimensions and centered at the geometrical center of the box (with the same conventions as <code>fftshift</code>).</p><p>Similarly, assuming <code>i1</code> and <code>i2</code> are integers, then:</p><pre><code class="language-julia">LocalFilters.RectangularBox{N}(i1:i2)</code></pre><p>yields an <code>N</code>-dimensional rectangular box with index range <code>i1:i2</code> along all dimensions.</p></li></ul><h3><a class="nav-anchor" id="Methods-on-a-neighborhood-1" href="#Methods-on-a-neighborhood-1">Methods on a neighborhood</a></h3><p>The following methods make sense on a neighborhood <code>B</code>:</p><pre><code class="language-julia">eltype(B) -&gt; element type of B
ndims(B)  -&gt; number of dimensions of B
length(B) -&gt; number of elements in the bounding-box of B
size(B)   -&gt; size of the bounding-box of B along all dimensions
size(B,d) -&gt; size of the bounding-box of B along d-th dimension
first(B)  -&gt; CartesianIndex of first position in the bounding-box
             of B relative to its anchor
last(B)   -&gt; CartesianIndex of last position in the bounding-box
             of B relative to its anchor
B[i]      -&gt; yields the kernel value of B at index i</code></pre><p>Note that the index <code>i</code> in <code>B[i]</code> is assumed to be between <code>first(B)</code> and <code>last(B)</code>, for efficiency reasons this is not checked.  The type returned by <code>eltype(B)</code> is <code>Bool</code> for a neighborhood which is just defined by its support (<em>e.g.</em> a <code>LocalFilters.CenteredBox</code> or a <code>LocalFilters.RectangularBox</code>), the element type of its kernel otherwise.</p><pre><code class="language-julia">CartesianRange(B)</code></pre><p>yields the Cartesian range of relative positions of the bounding-box of neighborhood <code>B</code>.</p><p>If the argument <code>B</code> which defines a neighborhood (see previous section) is not an instance of a type derived from <code>LocalFilters.Neighborhood</code>, it may be explicitly converted by:</p><pre><code class="language-julia">convert(LocalFilters.Neighborhood{N}, B)</code></pre><p>with <code>N</code> the number of dimensions of the target array.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>To install the last official version:</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;LocalFilters&quot;)</code></pre><p>To use the last development version:</p><pre><code class="language-julia">using Pkg
Pkg.clone(&quot;https://github.com/emmt/LocalFilters.jl.git&quot;)</code></pre><p>The <code>LocalFilters</code> package is pure Julia code and there is nothing to build.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
