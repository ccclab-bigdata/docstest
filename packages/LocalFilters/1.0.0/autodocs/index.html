<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · LocalFilters.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LocalFilters.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">LocalFilters.BilateralFilter</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.CartesianRegion" href="#LocalFilters.CartesianRegion"><code>LocalFilters.CartesianRegion</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>CartesianRegion{N}</code> is an union of the types of anything suitable to define a Cartesian region in <code>N</code> dimensions.  That is, an interval of Cartesian indices in <code>N</code> dimensions.  Methods <a href="#LocalFilters.initialindex"><code>initialindex</code></a>, <a href="@ref"><code>finalindex</code></a>, <a href="#LocalFilters.limits"><code>limits</code></a> and <a href="#LocalFilters.cartesianregion"><code>cartesianregion</code></a> can be applied to anything whose type belongs to <code>CartesianRegion</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.Dimensions" href="#LocalFilters.Dimensions"><code>LocalFilters.Dimensions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Dimensions{N}</code> is an <code>N</code>-tuple of integers, that is the type of an argument suitable for specifying a list of dimensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.IndexInterval" href="#LocalFilters.IndexInterval"><code>LocalFilters.IndexInterval</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>IndexInterval</code> is an union of the types of any argument suitable to specify an interval of indices along a dimension (that is, an integer or an integer valued unit range).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.Kernel" href="#LocalFilters.Kernel"><code>LocalFilters.Kernel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Kernel</code> can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology).  It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood.  In general, it is sufficient to specify <code>::Kernel{T,N}</code> in the signature of methods, with <code>T</code> the type of the coefficients and <code>N</code> the number of dimensions (the third parameter <code>A</code> of the type is to fully qualify the type of the array of coefficients).</p><p>A kernel is built as:</p><pre><code class="language-julia">B = Kernel([T,] C, start=defaultstart(C))</code></pre><p>where <code>C</code> is the array of coefficients (which can be retrieved by <code>coefs(B)</code>) and <code>start</code> the initial <code>CartesianIndex</code> for indexing the kernel (which can be retrieved by <code>initialindex(B)</code>).  The <code>start</code> parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:</p><pre><code class="language-julia">B[k] ≡ C[k + off]</code></pre><p>where <code>off = initialindex(C) - initialindex(B)</code>.</p><p>If <code>start</code> is omitted, its value is set so that the <em>origin</em> (whose index is <code>zero(CartesianIndex{N})</code> with <code>N</code> the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see <a href="#LocalFilters.defaultstart"><code>LocalFilters.defaultstart</code></a>).  Optional argument <code>T</code> is to impose the type of the coefficients.</p><p>To convert the element type of the coefficients of an existing kernel, do:</p><pre><code class="language-julia">Kernel(T, K)</code></pre><p>which yields a kernel whose coefficients are those of the kernel <code>K</code> converted to type <code>T</code>.</p><p>It is also possible to convert instances of <a href="#LocalFilters.RectangularBox"><code>RectangularBox</code></a> into a kernel with boolean coefficients by calling:</p><pre><code class="language-julia">Kernel(B)</code></pre><p>where <code>B</code> is the neighborhood to convert into an instance of <code>Kernel</code>.</p></div></div></section><pre><code class="language-none">LocalFilters.LocalFilters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.Neighborhood" href="#LocalFilters.Neighborhood"><code>LocalFilters.Neighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>All neighborhoods are instances of a type derived from <code>Neighborhood</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.RectangularBox" href="#LocalFilters.RectangularBox"><code>LocalFilters.RectangularBox</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RectangularBox(start, stop)</code></pre><p>yields a neighborhood which is a rectangular (Cartesian) box defined by the bounds of the multi-dimensional indices in the box.</p><p>Another possibility is to specify the dimensions of the box and the offsets of its central element:</p><pre><code class="language-julia">RectangularBox(dims, offs)</code></pre><p>with <code>dims</code> a <code>N</code>-tuple of dimensions and <code>offs</code> either a <code>N</code>-tuple of indices of an instance of <code>CartesianIndex{N}</code>.</p><p>A <code>RectangularBox</code> can also be defined by the index ranges along all the dimensions.  For example:</p><pre><code class="language-julia">RectangularBox(-3:3, 0, -2:1)
RectangularBox((-3:3, 0, -2:1))
</code></pre><p>both yield a 3-dimensional <code>RectangularBox</code> of size <code>7×1×4</code> and whose first index varies on <code>-3:3</code>, its second index is <code>0</code> while its third index varies on <code>-2:1</code>.</p><p>Finally, a <code>RectangularBox</code> can be defined as:</p><pre><code class="language-julia">RectangularBox(R)</code></pre><p>where <code>R</code> is an instance of <code>CartesianIndices</code> or, on version of Julia ≤ 0.6, <code>CartesianRange</code>.</p></div></div></section><pre><code class="language-none">LocalFilters.Separable</code></pre><pre><code class="language-none">LocalFilters.USE_CARTESIAN_RANGE</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.UnitIndexRange" href="#LocalFilters.UnitIndexRange"><code>LocalFilters.UnitIndexRange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>UnitIndexRange</code> is any integer valued range with unit step, that is the type of an argument suitable for specifying a range of contiguous indices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.UnitIndexRanges" href="#LocalFilters.UnitIndexRanges"><code>LocalFilters.UnitIndexRanges</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>UnitIndexRanges{N}</code> is an <code>N</code>-tuple of <code>UnitIndexRange</code>, that is the type of an argument suitable for specifying a list of Cartesian indices.</p></div></div></section><pre><code class="language-none">LocalFilters._ball!</code></pre><pre><code class="language-none">LocalFilters._length</code></pre><pre><code class="language-none">LocalFilters._range</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters._store!" href="#LocalFilters._store!"><code>LocalFilters._store!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_store!(arr, idx, val)</code> stores value <code>val</code> in array <code>arr</code> at index <code>idx</code>, taking care of rounding <code>val</code> if it is of floating-point type while the elements of <code>arr</code> are integers.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters._typeofsum" href="#LocalFilters._typeofsum"><code>LocalFilters._typeofsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_typeofsum(T)</code> yields a numerical type suitable for storing a sum of elements of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.ball" href="#LocalFilters.ball"><code>LocalFilters.ball</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LocalFilters.ball(N, r)</code></pre><p>yields a boolean mask which is a <code>N</code>-dimensional array with all dimensions odd and equal and set to true where position is inside a <code>N</code>-dimesional ball of radius <code>r</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.BilateralFilter.bilateralfilter" href="#LocalFilters.BilateralFilter.bilateralfilter"><code>LocalFilters.BilateralFilter.bilateralfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">bilateralfilter([T,] A, Fr, Gs, ...)</code></pre><p>yields the result of applying the bilateral filter on array <code>A</code>.</p><p>Argument <code>Fr</code> specifies the range kernel for smoothing differences in intensities, it is a function which takes two values from <code>A</code> as arguments and returns a nonnegative value.</p><p>Arguments <code>Gs, ...</code> specify the spatial kernel for smoothing differences in coordinates.</p><p>Optional argument <code>T</code> can be used to force the floating-point type used for (most) computations.</p><p>The in-place version is:</p><pre><code class="language-julia">bilateralfilter!([T,] dst, A, Fr, Gs, ...)</code></pre><p>which stores in <code>dst</code> the result of applying the bilateral filter on array <code>A</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Bilateral_filter">wikipedia</a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.BilateralFilter.bilateralfilter!" href="#LocalFilters.BilateralFilter.bilateralfilter!"><code>LocalFilters.BilateralFilter.bilateralfilter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bilateralfilter([T,] A, Fr, Gs, ...)</code></pre><p>yields the result of applying the bilateral filter on array <code>A</code>.</p><p>Argument <code>Fr</code> specifies the range kernel for smoothing differences in intensities, it is a function which takes two values from <code>A</code> as arguments and returns a nonnegative value.</p><p>Arguments <code>Gs, ...</code> specify the spatial kernel for smoothing differences in coordinates.</p><p>Optional argument <code>T</code> can be used to force the floating-point type used for (most) computations.</p><p>The in-place version is:</p><pre><code class="language-julia">bilateralfilter!([T,] dst, A, Fr, Gs, ...)</code></pre><p>which stores in <code>dst</code> the result of applying the bilateral filter on array <code>A</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Bilateral_filter">wikipedia</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.bottom_hat" href="#LocalFilters.bottom_hat"><code>LocalFilters.bottom_hat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">top_hat(A, R)
top_hat(A, R, S)
bottom_hat(A, R)
bottom_hat(A, R, S)</code></pre><p>Perform A summit/valley detection by applying a top-hat filter to array <code>A</code>.  Argument <code>R</code> defines the structuring element for the feature detection.  Optional argument <code>S</code> specifies the structuring element used to apply a smoothing to <code>A</code> prior to the top-hat filter.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.  For instance:</p><pre><code class="language-julia">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bimap image.</p><p>The in-place versions:</p><pre><code class="language-julia">top_hat!(dst, wrk, src, R)
bottom_hat!(dst, wrk, src, R)</code></pre><p>apply the top-hat filter on the source <code>src</code> and store the result in the destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.dilate"><code>dilate</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a> and <a href="@ref"><code>morph_enhance</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.bottom_hat!" href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">top_hat(A, R)
top_hat(A, R, S)
bottom_hat(A, R)
bottom_hat(A, R, S)</code></pre><p>Perform A summit/valley detection by applying a top-hat filter to array <code>A</code>.  Argument <code>R</code> defines the structuring element for the feature detection.  Optional argument <code>S</code> specifies the structuring element used to apply a smoothing to <code>A</code> prior to the top-hat filter.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.  For instance:</p><pre><code class="language-julia">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bimap image.</p><p>The in-place versions:</p><pre><code class="language-julia">top_hat!(dst, wrk, src, R)
bottom_hat!(dst, wrk, src, R)</code></pre><p>apply the top-hat filter on the source <code>src</code> and store the result in the destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.dilate"><code>dilate</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a> and <a href="@ref"><code>morph_enhance</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.cartesianregion" href="#LocalFilters.cartesianregion"><code>LocalFilters.cartesianregion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cartesianregion(args...) -&gt; R</code></pre><p>yields the rectangular region (as an instance of <code>CartesianIndices</code> or <code>CartesianRange</code> depending on Julia version) specified by the arguments which can be:</p><ul><li><p>an abstract array whose axes define the region (see <a href="@ref"><code>axes</code></a>);</p></li><li><p>a list of unit range indices and/or indices along each dimension;</p></li><li><p>the corners of the bounding box, say <code>start</code> and <code>stop</code>, specified as two instances of <code>CartesianIndex</code>;</p></li><li><p>a neighborhood (see <a href="#LocalFilters.Neighborhood"><code>Neighborhood</code></a>);</p></li><li><p>an instance of <code>CartesianIndices</code> or <code>CartesianRange</code>.</p></li></ul><p>This method is a workaround to deal with optimization issues between different versions of Julia.  In recent Julia versions (≥ 0.7), <code>cartesianregion(args...)</code> yields an instance of <code>CartesianIndices</code>; while in Julia version 0.6, <code>cartesianregion(args...)</code> yields a <code>CartesianRange</code> which appears to be faster than <code>CartesianIndices</code> as provided by <code>Compat</code>.</p><p>See also: <a href="#LocalFilters.initialindex"><code>initialindex</code></a>, <a href="@ref"><code>finalindex</code></a> and <a href="#LocalFilters.limits"><code>limits</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.closing" href="#LocalFilters.closing"><code>LocalFilters.closing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">closing(A, R)
opening(A, R)</code></pre><p>respectively perform a closing or an opening of array <code>A</code> by the structuring element <code>R</code>.  If not specified, <code>R</code> is a box of size 3 along all the dimensions of <code>A</code>.  A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.</p><p>The in-place versions are:</p><pre><code class="language-julia">closing!(dst, wrk, src, R)
opening!(dst, wrk, src, R)</code></pre><p>which perform the operation on the source <code>src</code> and store the result in destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar arrays, <code>dst</code> and <code>src</code> may be identical, but <code>wrk</code> must not be the same array as <code>src</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for the meaning of the arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.closing!" href="#LocalFilters.closing!"><code>LocalFilters.closing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">closing(A, R)
opening(A, R)</code></pre><p>respectively perform a closing or an opening of array <code>A</code> by the structuring element <code>R</code>.  If not specified, <code>R</code> is a box of size 3 along all the dimensions of <code>A</code>.  A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.</p><p>The in-place versions are:</p><pre><code class="language-julia">closing!(dst, wrk, src, R)
opening!(dst, wrk, src, R)</code></pre><p>which perform the operation on the source <code>src</code> and store the result in destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar arrays, <code>dst</code> and <code>src</code> may be identical, but <code>wrk</code> must not be the same array as <code>src</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for the meaning of the arguments.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.coefs" href="#LocalFilters.coefs"><code>LocalFilters.coefs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>LocalFilters.coefs(B)</code> yields the array of coefficients embedded in kernel <code>B</code>.</p><p>See also: <a href="#LocalFilters.offset"><code>LocalFilters.offset</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.convertcoefs" href="#LocalFilters.convertcoefs"><code>LocalFilters.convertcoefs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convertcoefs(T, A)</code></pre><p>yields an array of kernel coefficients equivalent to array <code>A</code> but whose elements have type <code>T</code>.</p><p>If <code>T</code> is a floating-point type and <code>A</code> is a boolean array, then the values of the result are <code>one(T)</code> where <code>A</code> is <code>true</code> and <code>zero(T)</code> elsewhere.  To use different values (for instance, to define <em>flat</em> <em>structuring</em> <em>elements</em>), you may call:</p><pre><code class="language-julia">convertcoefs((vtrue, vfalse), A)</code></pre><p>with <code>A</code> a boolean array to get an array whose elements are equal to <code>vtrue</code> where <code>A</code> is <code>true</code> and to <code>vfalse</code> otherwise.</p><p>See also: <a href="#LocalFilters.strel"><code>strel</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.convolve" href="#LocalFilters.convolve"><code>LocalFilters.convolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convolve(A, B)</code></pre><p>yields the convolution of <code>A</code> by the support of the neighborhood defined by <code>B</code> of by the kernel <code>B</code> if it is an instance of <code>LocalFilters.Kernel</code> with numerical coefficients.  The result is an array similar to <code>A</code>.</p><p>The in-place version is:</p><pre><code class="language-julia">convolve!(dst, A, B) -&gt; dst</code></pre><p>See also <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.convolve!" href="#LocalFilters.convolve!"><code>LocalFilters.convolve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">convolve(A, B)</code></pre><p>yields the convolution of <code>A</code> by the support of the neighborhood defined by <code>B</code> of by the kernel <code>B</code> if it is an instance of <code>LocalFilters.Kernel</code> with numerical coefficients.  The result is an array similar to <code>A</code>.</p><p>The in-place version is:</p><pre><code class="language-julia">convolve!(dst, A, B) -&gt; dst</code></pre><p>See also <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.defaultstart" href="#LocalFilters.defaultstart"><code>LocalFilters.defaultstart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">defaultstart(A) -&gt; I::CartesianIndex</code></pre><p>yields the initial (multi-dimensional) index of a rectangular region which has the same size as the array <code>A</code> but whose origin (that is, index <code>zero(CartesianIndex{N})</code>) is at the geometrical center of the region (with the same conventions as <a href="@ref"><code>fftshift</code></a>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.dilate" href="#LocalFilters.dilate"><code>LocalFilters.dilate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.dilate!" href="#LocalFilters.dilate!"><code>LocalFilters.dilate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.erode" href="#LocalFilters.erode"><code>LocalFilters.erode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.erode!" href="#LocalFilters.erode!"><code>LocalFilters.erode!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></div></section><pre><code class="language-none">LocalFilters.eval</code></pre><pre><code class="language-none">LocalFilters.finalindex</code></pre><pre><code class="language-none">LocalFilters.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.initialindex" href="#LocalFilters.initialindex"><code>LocalFilters.initialindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialindex(B) -&gt; Imin::CartesianIndex{N}
finalindex(B)   -&gt; Imax::CartesianIndex{N}</code></pre><p>respectively yield the initial and final multi-dimensional index for indexing the Cartesian region defined by <code>B</code>.  A Cartesian region defines a rectangular set of indices whose edges are aligned with the indexing axes.</p><p>Compared to similar methods <a href="@ref"><code>firstindex</code></a>, <a href="@ref"><code>lastindex()</code></a>, <a href="@ref"><code>first()</code></a> and <a href="@ref"><code>last()</code></a>, the returned value is always an instance of <code>CartesianIndex{N}</code> with <code>N</code> the number of dimensions.</p><p>Any multi-dimensional index <code>I::CartesianIndex{N}</code> is in the Cartesian region defined <code>B</code> if and only if <code>Imin ≤ I ≤ Imax</code>.</p><p>Also see: <a href="#LocalFilters.limits"><code>limits</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.ismmbox" href="#LocalFilters.ismmbox"><code>LocalFilters.ismmbox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ismmbox(B)</code></pre><p>yields whether neighborhood <code>B</code> has the same effect as a rectangular box for mathematical morphology operations.  This may be used to use fast separable versions of mathematical morphology operations like the van Herk-Gil-Werman algorithm.</p><p>See also: <a href="#LocalFilters.RectangularBox"><code>LocalFilters.RectangularBox</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.limits" href="#LocalFilters.limits"><code>LocalFilters.limits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">limits(T::DataType) -&gt; typemin(T), typemax(T)</code></pre><p>yields the infimum and supremum of a type <code>T</code>.</p><pre><code class="language-julia">limits(B) -&gt; Imin, Imax</code></pre><p>yields the corners (as a tuple of 2 <code>CartesianIndex</code>) of the Cartesian region defined by <code>B</code>.</p><p>Also see: <a href="#LocalFilters.initialindex"><code>initialindex</code></a> and <a href="@ref"><code>finalindex</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localextrema" href="#LocalFilters.localextrema"><code>LocalFilters.localextrema</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localextrema!" href="#LocalFilters.localextrema!"><code>LocalFilters.localextrema!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><div><p>Basic operations of mathematical morphology are:</p><pre><code class="language-julia">erode(A, B) -&gt; Amin
dilate(A, B) -&gt; Amax</code></pre><p>which respectively return the local minima <code>Amin</code> and the local maxima <code>Amax</code> of argument <code>A</code> in a neighborhood defined by <code>B</code>.  The returned result is similar to <code>A</code> (same size and type).</p><p>The two operations can be combined in one call:</p><pre><code class="language-julia">localextrema(A, B) -&gt; Amin, Amax</code></pre><p>The in-place versions:</p><pre><code class="language-julia">erode!(Amin, A, B) -&gt; Amin
dilate!(Amax, A, B) -&gt; Amax
localextrema!(Amin, Amax, A, B) -&gt; Amin, Amax</code></pre><p>apply the operation to <code>A</code> with structuring element <code>B</code> and store the result in the provided arrays <code>Amin</code> and/or <code>Amax</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a>, <a href="#LocalFilters.opening"><code>opening</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a>, <a href="#LocalFilters.top_hat"><code>top_hat</code></a> and <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a>.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localfilter" href="#LocalFilters.localfilter"><code>LocalFilters.localfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><p><strong>General local filters</strong></p><p>A local filtering operation can be performed by calling:</p><pre><code class="language-julia">localfilter!(dst, A, B, initial, update, store) -&gt; dst</code></pre><p>where <code>dst</code> is the destination, <code>A</code> is the source, <code>B</code> defines the neighborhood, <code>initial</code>, <code>update</code> and <code>store</code> are three functions whose purposes are explained by the following pseudo-code to implement the local operation:</p><pre><code class="language-none">for i ∈ Sup(A)
    v = initial(A[i])
    for j ∈ Sup(A) and i - j ∈ Sup(B)
        v = update(v, A[j], B[i-j])
    end
    store(dst, i, v)
end</code></pre><p>where <code>A</code> <code>Sup(A)</code> yields the support of <code>A</code> (that is the set of indices in <code>A</code>) and likely <code>Sup(B)</code> for <code>B</code>.</p><p>For instance, to compute a local minimum (that is, an <em>erosion</em>):</p><pre><code class="language-julia">localfilter!(dst, A, B,
             (a)     -&gt; typemax(T),
             (v,a,b) -&gt; min(v,a),
             (d,i,v) -&gt; d[i] = v)</code></pre><p><strong>Important:</strong> Because the result of an elementary operation can be something else than just a scalar, the loop(s) in <code>localfilter!</code> are performed without bound checking of the destination and it is the caller&#39;s responsability to insure that the destination have the correct sizes.</p></div></div><div><div><p><strong>Local filter by the van Herk-Gil-Werman algorithm</strong></p><pre><code class="language-julia">localfilter!([dst = A,] A, dims, op, rngs [, w])</code></pre><p>overwrite the contents of <code>dst</code> with the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code>.  Optional argument <code>w</code> is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector of same element type as <code>A</code> which is resized (with <a href="@ref"><code>resize!</code></a>) as needed.  The destination <code>dst</code> must have the same indices as the source <code>A</code> (see <a href="@ref"><code>axes</code></a>).  Operation can be done in-place; that is, <code>dst</code> and <code>A</code> can be the same.</p><p>Argument <code>dims</code> specifies along which dimension(s) of <code>A</code> the filter is to be applied, it can be a single integer, several integers or a colon <code>:</code> to specify all dimensions.  Dimensions are processed in the order given by <code>dims</code> (the same dimension may appear several times) and there must be a matching interval in <code>rngs</code> to specify the structuring element (except that if <code>rngs</code> is a single interval, it is used for every dimension in <code>dims</code>).  An interval is either an integer or an integer unit range in the form <code>kmin:kmax</code> (an interval specified as a single integer, say <code>k</code>, is the same as specifying <code>k:k</code>).</p><p>Assuming mono-dimensional arrays <code>A</code> and <code>dst</code>, the single filtering pass:</p><pre><code class="language-julia">localfilter!(dst, A, :, op, rng)</code></pre><p>yields:</p><pre><code class="language-none">dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]</code></pre><p>for all <code>j ∈ [first(axes(A,1)):last(axes(A,1))]</code>, with <code>x ⋄ y = op(x, y)</code>, <code>kmin = first(rng)</code> and <code>kmax = last(rng)</code>.  Note that if <code>kmin = kmax = k</code> (which occurs if <code>rng</code> is a simple integer), the result of the filter is to operate a simple shift by <code>k</code> along the corresponding dimension and has no effects if <code>k = 0</code>.  This can be exploited to not filter some dimension(s).</p><p>The out-place version, allocates the destination array and is called as:</p><pre><code class="language-julia">localfilter([T,] A, dims, op, rngs [, w])</code></pre><p>with <code>T</code> the element type of the result (by default <code>T = eltype(A)</code>).</p><p><strong>Examples</strong></p><p>The in-place <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be applied by:</p><pre><code class="language-julia">localfilter!(A, :, min, -3:3)</code></pre><p>One can specify index interval <code>0</code> to do nothing along the corresponding dimension.  For instance:</p><pre><code class="language-julia">localfilter!(A, :, max, (-3:3, 0, -4:4))</code></pre><p>will overwrite <code>A</code> with the local maxima (a.k.a. <em>morphological dilation</em>) of the three-dimensional array <code>A</code> in a centered local neighborhood of size <code>7×1×9</code> (nothing is done along the second dimension).  The same result may be obtained with:</p><pre><code class="language-julia">localfilter!(A, (1,3), max, (-3:3, -4:4))</code></pre><p>where the second dimension is omitted from the list of dimensions.</p><p>The <em>local average</em> of the two-dimensional array <code>A</code> on a centered structuring element of size 11×11 can be computed as:</p><pre><code class="language-julia">localfilter(A, :, +, (-5:5, -5:5))*(1/11)</code></pre><p><strong>Efficiency and restrictions</strong></p><p>The van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements.  It takes at most 3 operations to filter an element along a given dimension whatever the width <code>p</code> of the considered local neighborhood.  For <code>N</code>-dimensional arrays, the algorithm requires only <code>3N</code> operations per element instead of <code>p^N - 1</code> operations for a naive implementation.  This however requires to make a pass along each dimension so memory page faults may reduce the performances.  This is somewhat attenuated by the fact that the algorithm can be applied in-place.  For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.</p><p>To apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous.  In other words, the algorithm is only applicable for <code>N</code>-dimensional rectangular neighborhoods.  The structuring element may however be off-centered by arbitrary offsets along each dimension.</p><p>To take into account boundary conditions (for now only least neighborhood is implemented) and allow for in-place operation, the algorithm allocates a workspace array.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localfilter!" href="#LocalFilters.localfilter!"><code>LocalFilters.localfilter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Local filter by the van Herk-Gil-Werman algorithm</strong></p><pre><code class="language-julia">localfilter!([dst = A,] A, dims, op, rngs [, w])</code></pre><p>overwrite the contents of <code>dst</code> with the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code>.  Optional argument <code>w</code> is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector of same element type as <code>A</code> which is resized (with <a href="@ref"><code>resize!</code></a>) as needed.  The destination <code>dst</code> must have the same indices as the source <code>A</code> (see <a href="@ref"><code>axes</code></a>).  Operation can be done in-place; that is, <code>dst</code> and <code>A</code> can be the same.</p><p>Argument <code>dims</code> specifies along which dimension(s) of <code>A</code> the filter is to be applied, it can be a single integer, several integers or a colon <code>:</code> to specify all dimensions.  Dimensions are processed in the order given by <code>dims</code> (the same dimension may appear several times) and there must be a matching interval in <code>rngs</code> to specify the structuring element (except that if <code>rngs</code> is a single interval, it is used for every dimension in <code>dims</code>).  An interval is either an integer or an integer unit range in the form <code>kmin:kmax</code> (an interval specified as a single integer, say <code>k</code>, is the same as specifying <code>k:k</code>).</p><p>Assuming mono-dimensional arrays <code>A</code> and <code>dst</code>, the single filtering pass:</p><pre><code class="language-julia">localfilter!(dst, A, :, op, rng)</code></pre><p>yields:</p><pre><code class="language-none">dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]</code></pre><p>for all <code>j ∈ [first(axes(A,1)):last(axes(A,1))]</code>, with <code>x ⋄ y = op(x, y)</code>, <code>kmin = first(rng)</code> and <code>kmax = last(rng)</code>.  Note that if <code>kmin = kmax = k</code> (which occurs if <code>rng</code> is a simple integer), the result of the filter is to operate a simple shift by <code>k</code> along the corresponding dimension and has no effects if <code>k = 0</code>.  This can be exploited to not filter some dimension(s).</p><p>The out-place version, allocates the destination array and is called as:</p><pre><code class="language-julia">localfilter([T,] A, dims, op, rngs [, w])</code></pre><p>with <code>T</code> the element type of the result (by default <code>T = eltype(A)</code>).</p><p><strong>Examples</strong></p><p>The in-place <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be applied by:</p><pre><code class="language-julia">localfilter!(A, :, min, -3:3)</code></pre><p>One can specify index interval <code>0</code> to do nothing along the corresponding dimension.  For instance:</p><pre><code class="language-julia">localfilter!(A, :, max, (-3:3, 0, -4:4))</code></pre><p>will overwrite <code>A</code> with the local maxima (a.k.a. <em>morphological dilation</em>) of the three-dimensional array <code>A</code> in a centered local neighborhood of size <code>7×1×9</code> (nothing is done along the second dimension).  The same result may be obtained with:</p><pre><code class="language-julia">localfilter!(A, (1,3), max, (-3:3, -4:4))</code></pre><p>where the second dimension is omitted from the list of dimensions.</p><p>The <em>local average</em> of the two-dimensional array <code>A</code> on a centered structuring element of size 11×11 can be computed as:</p><pre><code class="language-julia">localfilter(A, :, +, (-5:5, -5:5))*(1/11)</code></pre><p><strong>Efficiency and restrictions</strong></p><p>The van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements.  It takes at most 3 operations to filter an element along a given dimension whatever the width <code>p</code> of the considered local neighborhood.  For <code>N</code>-dimensional arrays, the algorithm requires only <code>3N</code> operations per element instead of <code>p^N - 1</code> operations for a naive implementation.  This however requires to make a pass along each dimension so memory page faults may reduce the performances.  This is somewhat attenuated by the fact that the algorithm can be applied in-place.  For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.</p><p>To apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous.  In other words, the algorithm is only applicable for <code>N</code>-dimensional rectangular neighborhoods.  The structuring element may however be off-centered by arbitrary offsets along each dimension.</p><p>To take into account boundary conditions (for now only least neighborhood is implemented) and allow for in-place operation, the algorithm allocates a workspace array.</p></div></div><div><div><p><strong>General local filters</strong></p><p>A local filtering operation can be performed by calling:</p><pre><code class="language-julia">localfilter!(dst, A, B, initial, update, store) -&gt; dst</code></pre><p>where <code>dst</code> is the destination, <code>A</code> is the source, <code>B</code> defines the neighborhood, <code>initial</code>, <code>update</code> and <code>store</code> are three functions whose purposes are explained by the following pseudo-code to implement the local operation:</p><pre><code class="language-none">for i ∈ Sup(A)
    v = initial(A[i])
    for j ∈ Sup(A) and i - j ∈ Sup(B)
        v = update(v, A[j], B[i-j])
    end
    store(dst, i, v)
end</code></pre><p>where <code>A</code> <code>Sup(A)</code> yields the support of <code>A</code> (that is the set of indices in <code>A</code>) and likely <code>Sup(B)</code> for <code>B</code>.</p><p>For instance, to compute a local minimum (that is, an <em>erosion</em>):</p><pre><code class="language-julia">localfilter!(dst, A, B,
             (a)     -&gt; typemax(T),
             (v,a,b) -&gt; min(v,a),
             (d,i,v) -&gt; d[i] = v)</code></pre><p><strong>Important:</strong> Because the result of an elementary operation can be something else than just a scalar, the loop(s) in <code>localfilter!</code> are performed without bound checking of the destination and it is the caller&#39;s responsability to insure that the destination have the correct sizes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localmean" href="#LocalFilters.localmean"><code>LocalFilters.localmean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">localmean(A, B)</code></pre><p>yields the local mean of <code>A</code> in a neighborhood defined by <code>B</code>.  The result is an array similar to <code>A</code>.</p><p>The in-place version is:</p><pre><code class="language-julia">localmean!(dst, A, B) -&gt; dst</code></pre><p>See also <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.localmean!" href="#LocalFilters.localmean!"><code>LocalFilters.localmean!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">localmean(A, B)</code></pre><p>yields the local mean of <code>A</code> in a neighborhood defined by <code>B</code>.  The result is an array similar to <code>A</code>.</p><p>The in-place version is:</p><pre><code class="language-julia">localmean!(dst, A, B) -&gt; dst</code></pre><p>See also <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.offset" href="#LocalFilters.offset"><code>LocalFilters.offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>LocalFilters.offset(B)</code> yields the index offset of the array of coefficients embedded in kernel <code>B</code>.   That is, <code>B[k] ≡ coefs(B)[k + offset(B)]</code>.</p><p>See also: <a href="#LocalFilters.coefs"><code>LocalFilters.coefs</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.opening" href="#LocalFilters.opening"><code>LocalFilters.opening</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">closing(A, R)
opening(A, R)</code></pre><p>respectively perform a closing or an opening of array <code>A</code> by the structuring element <code>R</code>.  If not specified, <code>R</code> is a box of size 3 along all the dimensions of <code>A</code>.  A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.</p><p>The in-place versions are:</p><pre><code class="language-julia">closing!(dst, wrk, src, R)
opening!(dst, wrk, src, R)</code></pre><p>which perform the operation on the source <code>src</code> and store the result in destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar arrays, <code>dst</code> and <code>src</code> may be identical, but <code>wrk</code> must not be the same array as <code>src</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for the meaning of the arguments.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.opening!" href="#LocalFilters.opening!"><code>LocalFilters.opening!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">closing(A, R)
opening(A, R)</code></pre><p>respectively perform a closing or an opening of array <code>A</code> by the structuring element <code>R</code>.  If not specified, <code>R</code> is a box of size 3 along all the dimensions of <code>A</code>.  A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.</p><p>The in-place versions are:</p><pre><code class="language-julia">closing!(dst, wrk, src, R)
opening!(dst, wrk, src, R)</code></pre><p>which perform the operation on the source <code>src</code> and store the result in destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar arrays, <code>dst</code> and <code>src</code> may be identical, but <code>wrk</code> must not be the same array as <code>src</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for the meaning of the arguments.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.strel" href="#LocalFilters.strel"><code>LocalFilters.strel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">strel(T, A)</code></pre><p>yields a <em>structuring element</em> suitable for mathematical morphology operations. The result is a <code>Kernel</code> whose elements have type <code>T</code> (which can be <code>Bool</code> or a floating-point type).  Argument <code>A</code> can be a rectangular box or a <code>Kernel</code> with boolean elements.</p><p>If <code>T</code> is a floating-point type, then the result is a so-called <em>flat</em> structuring element whose coefficients are <code>zero(T)</code> inside the shape defined by <code>A</code> and <code>-T(Inf)</code> elsewhere.</p><p>See also: <a href="#LocalFilters.convertcoefs"><code>convertcoefs</code></a>.</p></div></div></section><pre><code class="language-none">LocalFilters.strictfloor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.top_hat" href="#LocalFilters.top_hat"><code>LocalFilters.top_hat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">top_hat(A, R)
top_hat(A, R, S)
bottom_hat(A, R)
bottom_hat(A, R, S)</code></pre><p>Perform A summit/valley detection by applying a top-hat filter to array <code>A</code>.  Argument <code>R</code> defines the structuring element for the feature detection.  Optional argument <code>S</code> specifies the structuring element used to apply a smoothing to <code>A</code> prior to the top-hat filter.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.  For instance:</p><pre><code class="language-julia">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bimap image.</p><p>The in-place versions:</p><pre><code class="language-julia">top_hat!(dst, wrk, src, R)
bottom_hat!(dst, wrk, src, R)</code></pre><p>apply the top-hat filter on the source <code>src</code> and store the result in the destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.dilate"><code>dilate</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a> and <a href="@ref"><code>morph_enhance</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LocalFilters.top_hat!" href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">top_hat(A, R)
top_hat(A, R, S)
bottom_hat(A, R)
bottom_hat(A, R, S)</code></pre><p>Perform A summit/valley detection by applying a top-hat filter to array <code>A</code>.  Argument <code>R</code> defines the structuring element for the feature detection.  Optional argument <code>S</code> specifies the structuring element used to apply a smoothing to <code>A</code> prior to the top-hat filter.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.  For instance:</p><pre><code class="language-julia">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bimap image.</p><p>The in-place versions:</p><pre><code class="language-julia">top_hat!(dst, wrk, src, R)
bottom_hat!(dst, wrk, src, R)</code></pre><p>apply the top-hat filter on the source <code>src</code> and store the result in the destination <code>dst</code> using <code>wrk</code> as a workspace array.  These 3 arguments must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.dilate"><code>dilate</code></a>, <a href="#LocalFilters.closing"><code>closing</code></a> and <a href="@ref"><code>morph_enhance</code></a>.</p></div></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
