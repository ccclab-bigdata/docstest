<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · PEG.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PEG.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Versus-[ParserCombinator](https://github.com/andrewcooke/ParserCombinator.jl)-1">Versus ParserCombinator</a></li><li><a class="toctext" href="#Migrating-from-PEG-0.2-to-PEG-1.0-1">Migrating from PEG 0.2 to PEG 1.0</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/wdebeaum/PEG.jl"><img src="https://travis-ci.org/wdebeaum/PEG.jl.png" alt="Build Status"/></a></p><p><a href="http://pkg.julialang.org/?pkg=PEG&amp;ver=0.7"><img src="http://pkg.julialang.org/badges/PEG_0.7.svg" alt="PEG"/></a></p><h1><a class="nav-anchor" id="PEG-1" href="#PEG-1">PEG</a></h1><p>Define a <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammar</a> via a macro and abuse of Julia syntax.</p><ul><li>Rules: <code>@rule name = expression</code></li><li>Choice: infix <code>,</code></li><li>Sequence: infix <code>&amp;</code></li><li>Positive lookahead: prefix <code>+</code></li><li>Negative lookahead: prefix <code>-</code></li><li>Option (zero or one time): postfix <code>[:?]</code> (≡ <code>[0:1]</code>)<ul><li>(note that [?] won&#39;t work in Julia &gt;= 1.0 per JuliaLang/julia#22712)</li></ul></li><li>Zero or more times: postfix <code>[*]</code> (≡ <code>[0:end]</code>)</li><li>One or more times: postfix <code>[+]</code> (≡ <code>[1:end]</code>)</li><li>Exactly <code>m</code> times: postfix <code>[m]</code> (≡ <code>[m:m]</code>) (where m is an integer)</li><li>Between <code>m</code> and <code>n</code> times inclusive: postfix <code>[m:n]</code></li><li>At most <code>n</code> times: postfix <code>[0:n]</code></li><li>At least <code>m</code> times: postfix <code>[m:end]</code></li><li>Terminals: <code>r&quot;regex&quot;</code>, <code>&quot;string&quot;</code><ul><li>Extra regex flags: <code>p</code> is for punctuation, and eats whitespace (<code>\s*</code>) after the match; <code>w</code> is for word, and implies <code>p</code>, but also makes sure match boundaries are word boundaries (<code>\b</code>); <code>h</code> modifies <code>p</code> and <code>w</code> to eat only horizontal whitespace (<code>\h</code>). Values passed to semantics functions exclude eaten whitespace.</li></ul></li><li>Semantics: <code>expression |&gt; unary_function</code> (like ParserCombinator)<ul><li>or <code>expression &gt; nary_function</code> to interpolate args.</li><li>Returning the special singleton value <code>PEG.Failure()</code> from a semantics function causes the parsing expression it&#39;s attached to to fail (return <code>nothing</code> instead of a tuple). Returning <code>nothing</code> from a semantics function is not special; it just makes the first part of the tuple <code>nothing</code>. See the parsing function signature below.</li></ul></li></ul><p>Put another way:</p><pre><code class="language-julia">using PEG
@rule grammar = &quot;using PEG\n&quot; &amp; rule[*]
@rule rule = r&quot;@rule&quot;p &amp; nonterminal &amp; r&quot;=&quot;p &amp; choice
@rule choice = seq &amp; (r&quot;,&quot;p &amp; seq)[*]
@rule seq = item &amp; (r&quot;&amp;&quot;p &amp; item)[*] &amp; (r&quot;\|?&gt;&quot;p &amp; julia_function)[:?]
@rule item = lookahead , counted
@rule lookahead = r&quot;\(&quot;p &amp; (r&quot;[+-]&quot;p) &amp; seq &amp; r&quot;\)&quot;p
@rule counted = single &amp; (count)[:?]
@rule count = range , r&quot;\[&quot;p &amp; (&quot;:?&quot; , r&quot;[\*\+]&quot;p) &amp; r&quot;]&quot;p
@rule range = r&quot;\[&quot;p &amp; integer &amp; (r&quot;:&quot;p &amp; (integer , r&quot;end&quot;w))[:?] &amp; r&quot;]&quot;p
@rule integer = r&quot;\d+&quot;w
@rule single = parens , terminal , nonterminal
@rule parens = r&quot;\(&quot;p &amp; choice &amp; r&quot;\)&quot;p
@rule nonterminal = r&quot;\pL\w+&quot;w
@rule terminal = regex , string &amp; r&quot;\s*&quot;
@rule regex = r&quot;\br&quot; &amp; string &amp; r&quot;[himpswx]*\s*&quot;
@rule string = r&quot;\&quot;(\\.|[^\&quot;])*\&quot;&quot;
@rule julia_function = # left as an exercise ;)</code></pre><p>Each rule defines a parsing function with the following signature:</p><pre><code class="language-julia">nonterminal(input::T, cache=PEG.Cache()) where T &lt;: AbstractString
  ::Union{Nothing,Tuple{Any,SubString}}</code></pre><p>The <code>Any</code> part of the return value is the abstract syntax tree, while the <code>SubString</code> is the remaining input after the parsed portion. If parsing fails, <code>nothing</code> is returned.</p><p>While you can use rules defined in this way directly, it might be more convenient to use the functions <code>parse_next(rule, input; whole=false)</code> or <code>parse_whole(rule, input)</code>. See their documentation for more information.</p><p>Call <code>PEG.setdebug!()</code> to have debugging information printed during parsing. Call <code>PEG.setdebug!(false)</code> to turn it off again.</p><h2><a class="nav-anchor" id="Versus-[ParserCombinator](https://github.com/andrewcooke/ParserCombinator.jl)-1" href="#Versus-[ParserCombinator](https://github.com/andrewcooke/ParserCombinator.jl)-1">Versus <a href="https://github.com/andrewcooke/ParserCombinator.jl">ParserCombinator</a></a></h2><p>PEG...</p><ul><li>is simpler/less featureful. PEG does not:<ul><li>backtrack, except within regexen and to try the next choice (<code>,</code>). That is, repetition <code>[]</code> is always greedy and possessive (to use PCRE terminology).</li><li>have <code>Empty(x)</code>/<code>@e_str</code>. Use semantics functions to discard values.</li><li>have <code>Dot()</code>. Use <code>r&quot;.&quot;</code>.</li><li>have <code>Eos()</code>. Use <code>parse_whole</code>.</li><li>parse streams. Use <code>open(x-&gt;parse_whole(rule, read(x, String)), args...)</code>.</li><li>include parsers for two random languages.</li></ul></li><li>has nicer syntax:<ul><li>Operator precedence makes sense. Tight to loose, the operators are: postfix <code>[]</code> (whatever is in the brackets), prefix <code>+</code>/<code>-</code>, infix <code>&amp;</code>, <code>|&gt;</code>/<code>&gt;</code>, <code>,</code>.</li><li>PC&#39;s <code>Plus(x)</code> and <code>Star(x)</code> become actual plusses and stars: <code>x[+]</code> and <code>x[*]</code>. And PEG has <code>x[:?]</code> too.</li><li><code>Equal</code>/<code>@e_str</code> and <code>Pattern</code>/<code>@p_str</code> are unneccessary, just use bare strings and regexen (with extra flags).</li></ul></li><li>does not require mutual recursion loops to be broken with <code>Delayed()</code>.</li><li>does not have special types for matchers/rules, and does not require a trampoline to &quot;interpret&quot; them. They&#39;re just plain functions you can call directly.</li></ul><h2><a class="nav-anchor" id="Migrating-from-PEG-0.2-to-PEG-1.0-1" href="#Migrating-from-PEG-0.2-to-PEG-1.0-1">Migrating from PEG 0.2 to PEG 1.0</a></h2><p>PEG 0.2 works with julia 0.6, while PEG 1.0 works with julia 1.0 (and julia 0.7). Julia 1.0 has a number of differences from julia 0.7 that required some changes to PEG, which will in turn require some minor syntactic changes to any grammars written with PEG 0.2 if you want to use them with PEG 1.0/julia 1.0.</p><ul><li>change <code>&gt;&gt;</code> to <code>|&gt;</code></li><li>change <code>&gt;&gt;&gt;</code> to <code>&gt;</code></li><li>change <code>|</code> to <code>,</code><ul><li>Note that this also makes it so you don&#39;t have to put parens around your lambda expressions.</li></ul></li><li>change <code>[?]</code> to <code>[:?]</code></li></ul><p>There are some other changes outside the grammar syntax as well:</p><ul><li>If you were doing this to parse a stream as previously suggested:<ul><li><code>open(x-&gt;parse_whole(rule, readstring(x)), args...)</code></li></ul></li><li>now you should do this instead:<ul><li><code>open(x-&gt;parse_whole(rule, read(x, String)), args...)</code></li></ul></li><li>change <code>Void</code> to <code>Nothing</code></li><li>change <code>ParseError</code> to <code>Meta.ParseError</code></li></ul><p>Also note that <code>PEG.Failure</code> is now an immutable type (<code>struct</code>). That shouldn&#39;t really matter because it has no fields, but it is still technically a visible change; <code>isbits(PEG.Failure())</code> is now <code>true</code> where before it was <code>false</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
