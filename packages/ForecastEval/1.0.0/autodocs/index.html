<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ForecastEval.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ForecastEval.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.DMBoot" href="#ForecastEval.DMBoot"><code>ForecastEval.DMBoot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DMBoot(data ; alpha, bootinput_kwargs...)</code></pre><p>Method type for doing a Diebold-Mariano test using a dependent bootstrap. A constructor that takes the data and several keyword arguments is provided. Relevant keyword arguments are: </p><pre><code class="language-none">alpha=0.05 &lt;- The confidence level to use in the test 

blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>See the DependentBootstrap package docs for more info on bootstrap input keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.DMHAC" href="#ForecastEval.DMHAC"><code>ForecastEval.DMHAC</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DMHAC(data ; alpha::Float64=0.05, kernelfunction, bandwidth::Int=-1)</code></pre><p>Method type for doing a Diebold-Mariano test using a HAC variance estimator. A constructor that takes the data and three keyword arguments is provided. Relevant keyword arguments are: </p><pre><code class="language-none">alpha &lt;- The confidence level for the test 

kernelfunction &lt;- Kernel function to use in HAC variance estimator. Valid values are
    KernelEpanechnikov(), KernelGaussian(), KernelUniform(), KernelBartlett(). You can
    also :epanechnikov, :gaussian, :uniform, :bartlett, or String variants of these symbols. 

bandwidth &lt;- Bandwidth to use in HAC variance estimator (set less than or equal to -1 to estimate bandwidth using Politis (2003) &quot;Adaptive Bandwidth Choice&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.DMMethod" href="#ForecastEval.DMMethod"><code>ForecastEval.DMMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DMMethod</code></pre><p>Abstract type for nesting the various methods that can be used to perform Diebold-Mariano tests. Subtypes are: </p><pre><code class="language-none">DMHAC
DMBoot</code></pre><p>The subtypes have entries in the help (?) menu.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.DMTest" href="#ForecastEval.DMTest"><code>ForecastEval.DMTest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DMTest(rejH0::Int, pvalue::Float64, bestinput::Int, teststat::Float64, dmmethod::DMMethod)</code></pre><p>Output type for a Diebold-Mariano test. A description of the fields follows: </p><pre><code class="language-none">rejH0 &lt;- true if the null is rejected, false otherwise
pvalue &lt;- p-value from the test
bestinput &lt;- 1 if forecast 1 is more accurate, and 2 if forecast 2 is more accurate. See ?dm for definition of forecast 1 versus 2.
teststat &lt;- If dmmethod == :hac then is the mean of loss difference scaled by HAC variance
            If dmmethod == :boot then is the mean of loss difference
dmmethod &lt;- Diebold-Mariano method used in the test. See ?DMMethod for more detail.</code></pre></div></div></section><pre><code class="language-none">ForecastEval.ForecastEval</code></pre><pre><code class="language-none">ForecastEval.KERNEL_FUNCTION_DICT</code></pre><pre><code class="language-none">ForecastEval.KernelBartlett</code></pre><pre><code class="language-none">ForecastEval.KernelEpanechnikov</code></pre><pre><code class="language-none">ForecastEval.KernelFunction</code></pre><pre><code class="language-none">ForecastEval.KernelGaussian</code></pre><pre><code class="language-none">ForecastEval.KernelUniform</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.MCSBoot" href="#ForecastEval.MCSBoot"><code>ForecastEval.MCSBoot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCSBoot(data ; alpha, basecaseindex, kwargs...)</code></pre><p>Method type for doing a MCS test using a dependent bootstrap. Relevant keyword arguments are: </p><pre><code class="language-none">alpha=0.05 &lt;- The confidence level to use in the test 

basecaseindex=1 &lt;- The MCS does not have a natural basecase. However, the input data is a
	matrix of losses, not loss differentials, and the method itself considers every possible
	loss differential combination. This is far too many to check for determining
	the optimal block length for bootstrapping, so users who wish to auto-estimate
	the appropriate block length can specify a notional base case variable index
	for the purposes of computing a optimal block lengths of all loss differences
	relative to the base case.
blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>Note, see the DependentBootstrap docs for more information on valid keyword arguments for the BootInput constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.MCSBootLowRAM" href="#ForecastEval.MCSBootLowRAM"><code>ForecastEval.MCSBootLowRAM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCSBootLowRAM(data ; alpha::Float64=0.05, kwargs...)</code></pre><p>Method type for doing an MCS test using a dependent bootstrap. This method type has an identical constructor arguments to MCSBoot, so use ?MCSBoot for more detail.</p><p>WARNING: This method corresponds to a MCS algorithm that has double the runtime of MCSBoot, but uses about half as much RAM. The vast majority of users will want to use MCSBoot.</p><p>WARNING: Results from MCSBootLowRAM are not guaranteed to be identical to those from MCSBoot in finite sample, although they are very likely to both recommend the same set of models in the model confidence set.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.MCSMethod" href="#ForecastEval.MCSMethod"><code>ForecastEval.MCSMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCSMethod</code></pre><p>Abstract type for nesting the various methods that can be used to perform a model confidence set. Subtypes are: </p><pre><code class="language-none">MCSBoot
MCSBootLowRAM</code></pre><p>The subtypes have entries in the help (?) menu.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.MCSTest" href="#ForecastEval.MCSTest"><code>ForecastEval.MCSTest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCSTest(inQF::Vector{Int}, outQF::Vector{Int}, pvalueQF::Vector{Float64}, inMT::Vector{Int}, outMT::Vector{Int}, pvalueMT::Vector{Float64})</code></pre><p>Output type from performing the MCS test proposed in Hansen, Lunde, Nason (2011) &quot;The Model Confidence Set&quot;, Econometrica, 79 (2), pp. 453-497. </p><p>The field names of this type have trailing &quot;QF&quot; or &quot;MT&quot;, where QF corresponds to the quadratic form test (see section 3.1.1 of original paper), while MT corresponds to the maximum t-stat test (see section 3.1.2 of original paper). </p><p>Note, in the fields of this type, the forecast models input to the MCS method are indicated via an integer counting up from 1 for each forecast model. These integers correspond to the columns of the input loss matrix; see ?mcs for more info. </p><p>The fields of this type follow: </p><pre><code class="language-none">inQF &lt;- Models that are in the MCS via the quadratic form method
outQF &lt;- Models that are not in the MCS via the quadratic form method
pvalueQF &lt;- The cumulative p-values from the quadratic form method
inMT &lt;- Models that are in the MCS via the max t-stat method
outMT &lt;- Models that are not in the MCS via the max t-stat method
pvalueMT &lt;- The cumulative p-values from the max t-stat method</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.RCBoot" href="#ForecastEval.RCBoot"><code>ForecastEval.RCBoot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RCBoot(data ; alpha::Float64=0.05, bootinput_kwargs...)</code></pre><p>Method type for doing a Reality Check using a dependent bootstrap. A constructor that takes the data and several keyword arguments is provided. The data refers to the loss differences for each forecast relative to the basecase. Use ?rc for more detail. Relevant keyword arguments are:     alpha=0.05 &lt;- The confidence level to use in the test </p><pre><code class="language-none">kernelfunction=KernelEpanechnikov() &lt;- The kernel function to use with HAC variance estimator. See ?hacvariance for more detail. 

bandwidth=-1 &lt;- The bandwidth for HAC variance estimator. If bandwidth &lt;= -1 then bandwidth is estimated using Politis (2003) &quot;Adaptive Bandwidth Choice&quot; 

blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>See the DependentBootstrap package docs for more info on bootstrap input keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.RCMethod" href="#ForecastEval.RCMethod"><code>ForecastEval.RCMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RCMethod</code></pre><p>Abstract type for nesting the various methods that can be used to perform a Reality Check. Subtypes are: </p><pre><code class="language-none">RCBoot</code></pre><p>The subtypes have entries in the help (?) menu.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.RCTest" href="#ForecastEval.RCTest"><code>ForecastEval.RCTest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RCTest(rejH0::Int, pvalue::Float64)</code></pre><p>Output type from a Reality Check test. The fields of this type follow: </p><pre><code class="language-none">rejH0 &lt;- true if the null is rejected, false otherwise
pvalue &lt;- p-value from the test</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.SPABoot" href="#ForecastEval.SPABoot"><code>ForecastEval.SPABoot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SPABoot(data ; alpha, kernelfunction, bandwidth, bootinput_kwargs...)</code></pre><p>Method type for doing an SPA test using a dependent bootstrap. A constructor that takes the data and several keyword arguments is provided. The data refers to the loss differences for each forecast relative to the basecase. Use ?spa for more detail. Relevant keyword arguments are: </p><pre><code class="language-none">alpha=0.05 &lt;- The confidence level to use in the test 

kernelfunction=KernelEpanechnikov() &lt;- The kernel function to use with HAC variance estimator. See ?hacvariance for more detail. 

bandwidth=-1 &lt;- The bandwidth for HAC variance estimator. If bandwidth &lt;= -1 then bandwidth is estimated using Politis (2003) &quot;Adaptive Bandwidth Choice&quot; 

blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>Note, see the DependentBootstrap docs for more information on valid keyword arguments for the BootInput constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.SPAMethod" href="#ForecastEval.SPAMethod"><code>ForecastEval.SPAMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SPAMethod</code></pre><p>Abstract type for nesting the various methods that can be used to perform an SPA test. Subtypes are: </p><pre><code class="language-none">SPABoot</code></pre><p>The subtypes have entries in the help (?) menu.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.SPATest" href="#ForecastEval.SPATest"><code>ForecastEval.SPATest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SPATest(rejH0::Int, mu_u::Vector{Float64}, mu_c::Vector{Float64}, mu_l::Vector{Float64}, pvalue_u::Float64, pvalue_c::Float64, pvalue_l::Float64, pvalue::Float64, teststat::Float64)</code></pre><p>Output type for an SPA test proposed in Hansen (2005) &quot;A Test for Superior Predictive Ability&quot;. The names of the fields for this type follow those in the referenced paper, so see that paper for more detail. The fields of this type follow: </p><pre><code class="language-none">rejH0 &lt;- true if the null is rejected, false otherwise
mu_u &lt;- mu associated with upper bound on threshold rate
mu_c &lt;- Recommended mu
mu_l &lt;- mu associated with lower bound on threshold rate
pvalue_u &lt;- pvalue associated with mu_u
pvalue_c &lt;- pvalue assoicated with mu_c
pvalue_l &lt;- pvalue associated with mu_l
pvalueauto &lt;- Recommended p-value (usually pvalue_c except in rare situations where this method can fail)
teststat::Float64 &lt;- SPA test statistic (look for tSPA in source paper)</code></pre><p>Note the different mu variables, {u, c, l} are described in the referenced article on p370-371. </p><p>Most users will just be interested in the field pvalueauto.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.dm" href="#ForecastEval.dm"><code>ForecastEval.dm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dm(lossdiff::Vector{&lt;:Number}, dmmethod ; kwargs...)</code></pre><p>This function implements the test proposed in Diebold, Mariano (1995) &quot;Comparing Predictive Accuracy&quot;. </p><p>Let x<em>1 denote forecast 1, x</em>2 denote forecast 2, and let y denote the forecast target. Let L(., .) denote a loss function. Then the first argument lossdiff is assumed to be a vector created by the following operation: </p><p>L(x<em>1, y) - L(x</em>2, y) </p><p>The second argument, dmmethod, can be an explicit method type, currently DMHAC or DMBoot, (see ?DMHAC and ?DMBoot for more detail), in which case the keyword arguments are not needed. </p><p>Alternatively, dmmethod can be set to the Symbol :hac or :boot, depending on whether the user wants to use the HAC method or the bootstrap method. In this instance, the keyword arguments provided will be passed on to DMHAC or DMBoot constructors (see ?DMHAC and ?DMBoot for more detail). </p><p>Finally, the second argument can be omitted entirely, in which case the method will default to the default bootstrap method, which is the stationary bootstrap of Politis and Romano (1993) with block length estimated followed Patton, Politis, and White (2009). </p><p>The output of a Diebold-Mariano test is of type DMTest. Use ?DMTest for more information.</p></div></div></section><pre><code class="language-none">ForecastEval.eval</code></pre><pre><code class="language-none">ForecastEval.get_kernel_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.hacvariance" href="#ForecastEval.hacvariance"><code>ForecastEval.hacvariance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hacvariance{T&lt;:Number}(x::AbstractVector{T} ; kf::Symbol=:epanechnikov, bw::Int=-1)::Tuple{Float64, Int}</code></pre><p>Get the heteroskedasticity and autocorrelation consistent variance estimator of data vector x. The function has the following keyword arguments: 	kf &lt;- Kernel function used in estimator. Valid values are :epanechnikov, :gaussian, :uniform, :bartlett 	bw &lt;- Bandwidth used in estimator. If &lt;= -1, then estimate bandwidth using Politis (2003) &quot;Adaptive Bandwidth Choice&quot;</p></div></div></section><pre><code class="language-none">ForecastEval.include</code></pre><pre><code class="language-none">ForecastEval.kernel_eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.loss_diff_base_case" href="#ForecastEval.loss_diff_base_case"><code>ForecastEval.loss_diff_base_case</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>loss<em>diff</em>base_case &lt;- Local function for getting loss differences relative to notional base case for purposes of estimating the block length</p></div></div></section><pre><code class="language-none">ForecastEval.ltri_cart_index</code></pre><pre><code class="language-none">ForecastEval.ltri_index_match</code></pre><pre><code class="language-none">ForecastEval.ltri_to_utri!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.mcs" href="#ForecastEval.mcs"><code>ForecastEval.mcs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mcs(l::Matrix{&lt;:Number}, method ; kwargs...)
mcs(l::Matrix{&lt;:Number} ; kwargs...)</code></pre><p>This function implements the MCS test proposed in Hansen, Lunde, Nason (2011) &quot;The Model Confidence Set&quot;, Econometrica, 79 (2), pp. 453-497. </p><p>Let x_k, k = 1, ..., K, denote K forecasts (from K different forecasting models), and y denote the forecast target. Let L(., .) denote a loss function. The first argument of mcs is a matrix where the kth column of the matrix is created by the operation: </p><p>L(x_k, y) </p><p>Note that unlike the Reality Check and SPA test, there is no base case for the MCS. </p><p>The second method argument determines which methodology to use. Currently, only MCSBoot is available and if this input type is provided, the keyword arguments are not needed. Alternatively, the user can omit the second argument, and then any keyword arguments will be passed to the MCSBoot constructor. See ?MCSBoot for more detail. The most relevant keyword arguments are:     alpha=0.05 &lt;- The confidence level to use in the test </p><pre><code class="language-none">basecaseindex=1 &lt;- The MCS does not have a natural basecase. However, the input data is a
	matrix of losses, not loss differentials, and the method itself considers every possible
	loss differential combination. This is far too many to check for determining
	the optimal block length for bootstrapping, so users who wish to auto-estimate
	the appropriate block length can specify a notional base case variable index
	for the purposes of computing a optimal block lengths of all loss differences
	relative to the base case.
blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>For more detail on the bootstrap options, please see the docs for the DependentBootstrap package. </p><p>The output of a MCS test is of type MCSTest. Use ?MCSTest for more information. </p><p>Note, if you are hitting RAM limits, type ?ForecastEval.MCSBootLowRAM at the REPL for more detail on an alternative algorithm that is also available. </p><p>Note, for any developers, the main algorithm (associated with MCSBoot) still has the following potential performance issues: </p><pre><code class="language-none">ISSUE 1: Some of the temporary arrays in the loops could probably be eliminated 

ISSUE 2: For MCS method A, I think the loop over K could be terminated as soon as cumulative p-values are greater than method.alpha. Need to double check this. 

ISSUE 3: Need to add option to do just max(abs) method or just sum(sq) method (or both)</code></pre><p>Comments or pull requests on these issues would be most welcome on the package github page.</p></div></div></section><pre><code class="language-none">ForecastEval.msym_mat_from_ltri_inds</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.pvaluelocal" href="#ForecastEval.pvaluelocal"><code>ForecastEval.pvaluelocal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pvaluelocal(d::ContinuousUnivariateDistribution, x::Number ; tail::Symbol=:both)::Float64
pvaluelocal{T&lt;:Number}(d::Vector{T}, x::Number ; tail::Symbol=:both, as::Bool=false)::Float64</code></pre><p>Obtain the p-value associated with the inputs. d::ContinuousUnivariateDistribution -&gt; d is the distribution under the null and x is the test statistic. d::Vector{T} -&gt; d is a bootstrapped vector of test statistics and x is the value of the test statistic under the null.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.rc" href="#ForecastEval.rc"><code>ForecastEval.rc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rc(lD::Matrix{T}, method ; kwargs)
rc(lD::Matrix{T} ; kwargs)</code></pre><p>This function implements the test proposed in White (2000) &quot;A Reality Check for Data Snooping&quot; following the methodology in Hansen (2005). </p><p>Let x<em>0 denote a base-case forecast, x</em>k, k = 1, ..., K, denote K alternative forecasts, and y denote the forecast target. Let L(., .) denote a loss function. The first argument of rc is a matrix where the kth column of the matrix is created by the operation: </p><p>L(x<em>k, y) - L(x</em>0, y) </p><p>Note that the forecast loss comes first and the base case loss comes second. This is the opposite to what is described in White&#39;s paper. </p><p>The second method argument determines which methodology to use. Currently, only RCBoot is available and if this input type is provided, the keyword arguments are not needed. Alternatively, the user can omit the second argument, and then any keyword arguments will be passed to the RCBoot constructor. See ?RCBoot for more detail. The most relevant keyword arguments are:     alpha=0.05 &lt;- The confidence level to use in the test </p><pre><code class="language-none">blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>The output of a Reality Check test is of type RCTest. Use ?RCTest for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForecastEval.spa" href="#ForecastEval.spa"><code>ForecastEval.spa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spa{T&lt;:Number}(lossDiff::Matrix{T}, method ; kwargs...)::SPATest
spa{T&lt;:Number}(lossDiff::Matrix{T} ; kwargs...)</code></pre><p>This function implements the SPA test proposed in Hansen (2005) &quot;A Test for Superior Predictive Ability&quot;. </p><p>Let x<em>0 denote a base-case forecast, x</em>k, k = 1, ..., K, denote K alternative forecasts, and y denote the forecast target. Let L(., .) denote a loss function. The first argument of spa is a matrix where the kth column of the matrix is created by the operation: </p><p>L(x<em>k, y) - L(x</em>0, y) </p><p>Note that the forecast loss comes first and the base case loss comes second. This is the opposite to what is described in Hansen&#39;s paper. </p><p>The second method argument determines which methodology to use. Currently, only SPABoot is available and if this input type is provided, the keyword arguments are not needed. Alternatively, the user can omit the second argument, and then any keyword arguments will be passed to the SPABoot constructor. See ?SPABoot for more detail. The most relevant keyword arguments are:     alpha=0.05 &lt;- The confidence level to use in the test </p><pre><code class="language-none">kernelfunction=KernelEpanechnikov() &lt;- The kernel function to use with HAC variance estimator. See ?hacvariance for more detail. 

bandwidth=-1 &lt;- The bandwidth for HAC variance estimator. If bandwidth &lt;= -1 then bandwidth is estimated using Politis (2003) &quot;Adaptive Bandwidth Choice&quot; 

blocklength=0.0 &lt;- Block length to use with the bootstrap. Default of 0.0 implies
    the block length will be optimally estimated from the data use the method deemed
    most appropriate by the DependentBootstrap package (typically the selection procedure
    of Patton, Politis, and White (2009)). 

numresample=1000 &lt;- Number of resamples to use when bootstrapping. 

bootmethod=:stationary &lt;- Bootstrap methodology to use, where the default is the
    stationary bootstrap of Politis and Romano (1993)</code></pre><p>The output of an SPA test is of type SPATest. Use ?SPATest for more information. </p><p>Note, Hansen suggests using the Stationary Bootstrap implied HAC variance estimator, which is not currently supported in this package. However, note that any consistent HAC estimator is valid and in many cases may be preferred.</p></div></div></section><pre><code class="language-none">ForecastEval.trinum</code></pre><pre><code class="language-none">ForecastEval.trinumroot</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
