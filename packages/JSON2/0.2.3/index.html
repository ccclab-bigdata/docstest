<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · JSON2.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JSON2.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Project-Status-1">Project Status</a></li><li><a class="toctext" href="#Contributing-and-Questions-1">Contributing and Questions</a></li><li><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="JSON2-1" href="#JSON2-1">JSON2</a></h1><p><em>Fast JSON for Julia types</em></p><table><tr><th><strong>PackageEvaluator</strong></th><th><strong>Build Status</strong></th></tr><tr><td>[![][pkg-0.6-img]][pkg-0.6-url]</td><td>[![][travis-img]][travis-url] [![][codecov-img]][codecov-url]</td></tr></table><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package is registered in <code>METADATA.jl</code> and so can be installed with <code>Pkg.add</code>.</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;JSON2&quot;)</code></pre><h2><a class="nav-anchor" id="Project-Status-1" href="#Project-Status-1">Project Status</a></h2><p>The package is tested against the current Julia <code>0.6</code> release and nightly on Linux and OS X.</p><h2><a class="nav-anchor" id="Contributing-and-Questions-1" href="#Contributing-and-Questions-1">Contributing and Questions</a></h2><p>Contributions are very welcome, as are feature requests and suggestions. Please open an [issue][issues-url] if you encounter any problems or would just like to ask a question.</p><p>&lt;!– [docs-latest-img]: https://img.shields.io/badge/docs-latest-blue.svg [docs-latest-url]: https://quinnj.github.io/JSON2.jl/latest –&gt;</p><p>[docs-stable-img]: https://img.shields.io/badge/docs-stable-blue.svg [docs-stable-url]: https://quinnj.github.io/JSON2.jl/stable</p><p>[travis-img]: https://travis-ci.org/quinnj/JSON2.jl.svg?branch=master [travis-url]: https://travis-ci.org/quinnj/JSON2.jl</p><p>[codecov-img]: https://codecov.io/gh/quinnj/JSON2.jl/branch/master/graph/badge.svg [codecov-url]: https://codecov.io/gh/quinnj/JSON2.jl</p><p>[issues-url]: https://github.com/quinnj/JSON2.jl/issues</p><p>[pkg-0.6-img]: http://pkg.julialang.org/badges/JSON2_0.6.svg [pkg-0.6-url]: http://pkg.julialang.org/?pkg=JSON2</p><h2><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h2><p>For most use-cases, all you ever need are:</p><pre><code class="language-julia">JSON2.write(obj) =&gt; String
JSON2.read(str, T) =&gt; T
@pretty json_string # print a &quot;prettified&quot; version of a JSON string</code></pre><p>Native support for reading/writing is provided for:</p><ul><li><code>NamedTuple</code></li><li><code>Array</code></li><li><code>Number</code></li><li><code>Nothing</code>/<code>Missing</code>: corresponds to JSON <code>null</code></li><li><code>String</code></li><li><code>Bool</code></li><li><code>JSON2.Function</code>: type that represents a javascipt function (stored in plain text)</li><li><code>Union{T, Nothing}</code></li><li><code>AbstractDict</code></li><li><code>Tuple</code></li><li><code>Set</code></li><li><code>Char</code></li><li><code>Symbol</code></li><li><code>Enum</code></li><li><code>Date</code>/<code>DateTime</code></li></ul><p>Custom types are supported by default as well, utilizing reflection to generate compiled JSON parsers for a type&#39;s fields. So in general, you really can just do <code>JSON2.read(str, MyType)</code> and everything will &quot;Just Work&quot; (and be freaky fast as well!).</p><h3><a class="nav-anchor" id="Custom-JSON-Formatting-1" href="#Custom-JSON-Formatting-1">Custom JSON Formatting</a></h3><h4><a class="nav-anchor" id="Default-1" href="#Default-1">Default</a></h4><p>In many cases, a type doesn&#39;t even <em>need</em> to use <code>JSON2.@format</code> since the default reflection-based parsing is somewhat flexible. By default, the JSON input is expected to contain each field of a type and be in the same order as the type was defined. For example, the struct:</p><pre><code class="language-julia">struct T
    a::Int
    b::Int
    c::Union{Nothing, Int}
end</code></pre><p>Could have valid JSON in the forms:</p><pre><code class="language-json">{&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: null} // all 3 fields provided in correct order
{&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2}
{&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: null, &quot;d&quot;: 3} // extra fields are ignored
{&quot;a&quot;: 0} // will work if T(a) constructor is defined
{&quot;a&quot;: 0, &quot;b&quot;: 1} // will work if T(a, b) constructor is defined</code></pre><p>That is, each field <em>must</em> be present in the JSON input and match in position to the original struct definition. Extra arguments after the struct&#39;s own fieldtypes are ignored. As noted, the exception to a field needing to be present is if 1) the field and <em>all subsequent fields</em> are not present and 2) appropriate constructors are defined that take these limited subsets of inputs when constructing, e.g. <code>T(a)</code>, <code>T(a, b)</code>, etc.</p><h4><a class="nav-anchor" id="JSON.@format-T-1" href="#JSON.@format-T-1">JSON.@format T</a></h4><pre><code class="language-julia">JSON2.@format T [noargs|keywordargs] begin
    _field_ =&gt; (; options...)
    _field2_ =&gt; (; options...)
end</code></pre><p>Specify a custom JSON formatting for a struct <code>T</code>, with individual field options being given like <code>fieldname =&gt; (; option1=value1, option2=value2)</code>, i.e a Pair of the name of the field to a NamedTuple of options. Valid field options include:</p><ul><li><code>name</code>: if a field&#39;s name should be read/written differently than it&#39;s defined name</li><li><code>jsontype</code>: if the JSON type of a field is different than the julia field type, the JSON type can be provided like <code>jsontype=String</code></li><li><code>omitempty</code>: whether an &quot;empty&quot; julia field should still be written; applies to collection types like <code>AbstractArray</code>, <code>AbstractDict</code>, <code>AbstractSet</code>, etc.</li><li><code>exclude</code>: whether a julia field should be excluded altogether from JSON reading/writing</li><li><code>default</code>: a default value that can be provided for a julia field if it may not appear in a JSON input string when parsing</li></ul><p>Again, the default case is for JSON input that will have consistently ordered, always-present fields; for cases where the input JSON is <em>not</em> well-ordered or if there is a possibility of a field not being present in the JSON input, there are a few additional options for custom parsing.</p><h4><a class="nav-anchor" id="Default-field-values-1" href="#Default-field-values-1">Default field values</a></h4><p>If the JSON input fields will always be consistenly-ordered, but fields may be missing (i.e. field isn&#39;t present at all in the input), field defaults can be provided like:</p><pre><code class="language-julia">JSON2.@format T begin
    c =&gt; (default=0,)
end</code></pre><p>This says that, when reading from a JSON input, if field <code>c</code> isn&#39;t present, to set it&#39;s value to 0.</p><p>If the JSON input is not consistenly-ordered, there are two other options for allowing direct type parsing</p><h4><a class="nav-anchor" id="Keywordargs-Constructor-1" href="#Keywordargs-Constructor-1">Keywordargs Constructor</a></h4><pre><code class="language-julia">T(; a=0, b=0, c=0, kwargs...) = T(a, b, c)
JSON2.@format T keywordargs begin
    # ...
end</code></pre><p>Here we&#39;ve defined a &quot;keywordargs&quot; constructor for <code>T</code> that essentially takes a default for each field as keyword arguments, then constructs <code>T</code>. During parsing, the JSON input will be parsed for any valid field key-values and the keyword constructor will be called with whatever arguments are parsed in whatever order. Note that we also included a catchall <code>kwargs...</code> in our constructor which can be used to &quot;throw away&quot; or ignore any extra fields in the JSON input.</p><h4><a class="nav-anchor" id="Noargs-Constructor-1" href="#Noargs-Constructor-1">Noargs Constructor</a></h4><pre><code class="language-julia">mutable struct T
    a::Int
    b::Int
    c::Union{Nothing, Int}
end
T() = T(0, 0, 0)
JSON2.@format T noargs begin
    #...
end</code></pre><p>In this case, we&#39;ve made <code>T</code> a <em>mutable</em> struct and defined a &quot;noargs&quot; constructor <code>T() = ...</code>; we then specified in <code>JSON2.@format T noargs</code> the <code>noargs</code> option. During parsing, an instance of <code>T</code> will first constructed using the &quot;noargs&quot; constructor, then fields will be set as they&#39;re parsed from the JSON input (hence why <code>mutable struct</code> is required).</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
