<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · SurrealNumbers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SurrealNumbers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Intro-1">Intro</a></li><li><a class="toctext" href="#Background:-the-Surreal-Numbers-1">Background: the Surreal Numbers</a></li><li><a class="toctext" href="#Icky-bits-–-implementation-details-1">Icky bits – implementation details</a></li><li><a class="toctext" href="#Other-comments-1">Other comments</a></li><li><a class="toctext" href="#Final-notes-1">Final notes</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SurrealNumbers-1" href="#SurrealNumbers-1">SurrealNumbers</a></h1><p><a href="https://travis-ci.org/mroughan/SurrealNumbers.jl"><img src="https://travis-ci.org/mroughan/SurrealNumbers.jl.svg?branch=master" alt="Build Status"/></a></p><p><a href="https://coveralls.io/github/mroughan/SurrealNumbers.jl?branch=master"><img src="https://coveralls.io/repos/github/mroughan/SurrealNumbers.jl/badge.svg?branch=master" alt="Coverage Status"/></a></p><p><a href="http://codecov.io/github/mroughan/SurrealNumbers.jl?branch=master"><img src="http://codecov.io/github/mroughan/SurrealNumbers.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><h2><a class="nav-anchor" id="Intro-1" href="#Intro-1">Intro</a></h2><p>This is a package implementing some parts of the Surreal Number system invented by John Horton Conway, and explained by Knuth in <a href="http://www.math.harvard.edu/~knill/teaching/mathe320_2015_fall/blog15/surreal1.pdf">&quot;Surreal Numbers: How Two Ex-Students Turned on to Pure Mathematics and Found Total Happiness.&quot;</a></p><p>It isn&#39;t intended to be useful, so much as educational, and an interesting test of Julia itseld. It was educational for me to write, in terms of learning Julia. I wanted a task that would be painful to do in Matlab but &quot;easy&quot; to do in Julia. It might also be helpful, I hope, for someone trying to learn about Surreal numbers. I certainly did learn a lot about them that would have been easily brushed to the side if I had only gone through the theorems.</p><h2><a class="nav-anchor" id="Background:-the-Surreal-Numbers-1" href="#Background:-the-Surreal-Numbers-1">Background: the Surreal Numbers</a></h2><p>Surreal numbers aren&#39;t numbers as we are taught, but they have many of the same properties. The tricky thing is that they are defined recursively from the very start. The nice part is that they use only set operations.</p><p>The definition is as follows: a surreal number <span>$x$</span> is an ordered pair of sets of surreal numbers (call them the left set <span>$X_L$</span> and right set <span>$X_R$</span>) such that every member of the left set is <code>&lt;</code> all of the members of the right set (technically no member of the left set is <span>$&gt;=$</span> a member of the right).</p><p>There is a starting point – we can always use empty sets – as so the first surreal number (usually denoted zero, because it will turn out to be the additive identity) is <span>$\{ | \}$</span>, where I will use this  bracket and pipe notation to denote <span>$x = \{ X_L | X_R\}$</span>. Also, to  make the empty spaces clearer (and the coding more efficient) I have  defined $ ∅ = { } $ the empty set. </p><p>Then on the &quot;first day&quot; a new generation of surreals can be created in terms of the initial case. On the second day we create a new generation and so on. Each has a meaning corresponding to traditional numbers in order to place a consistent interpretation on standard mathematical operators defined on the surreals. </p><p>Just to reiterate, the tricky thing is that everything is recursive. Even comparitors like <code>&lt;</code>, and hence, we can&#39;t even know if something is a valid surreal in its own right, but only through recursively investigating its component sets. </p><p>In any case, this is not a survey or tutorial on surreal numbers. There are many out there better than I can write, e.g.,</p><ul><li>https://en.wikipedia.org/wiki/Surreal_number</li><li>https://conservancy.umn.edu/bitstream/handle/11299/174778/Hebert<em>umn</em>0130M_15912.pdf?sequence=1</li><li>https://math.stackexchange.com/questions/816540/proof-of-conways-simplicity-rule-for-surreal-numbers</li><li>http://www.math.harvard.edu/~knill/teaching/mathe320<em>2015</em>fall/blog15/surreal1.pdf</li><li>https://www.cut-the-knot.org/WhatIs/Infinity/SurrealNumbers.shtml</li><li>https://www.whitman.edu/Documents/Academics/Mathematics/Grimm.pdf</li><li>https://www.tondering.dk/download/sur16.pdf</li><li>https://en.wikibooks.org/wiki/Surreal<em>Numbers</em>and_Games</li><li>https://www.encyclopediaofmath.org/index.php/Surreal_numbers</li><li>https://www.scmp.com/article/241601/game-go-inspires-new-surreal-numbers-theory</li><li>https://www.edge.org/response-detail/27156</li><li>https://ncatlab.org/nlab/show/surreal+number#conwaystyle_definitions</li></ul><p>The purpose here is simply to introduce the key reasons for implementing this in Julia – it enables users to define high-performance types of their own, and those types can be recursively defined.</p><p>I know you can do this in other languages, and in some cases also achieve high performance. But it&#39;s <em>so</em> easy in Julia. </p><h3><a class="nav-anchor" id="An-example-1" href="#An-example-1">An example</a></h3><p>Let&#39;s start off with some small examples of using the package. After installing the package we can create basic surreals using (i) the constructor, (ii) conversion from another real number, or (iii) a couple of special functions, e.g., <code>zero</code> and <code>one</code>. There are two constructors, one includes an extra string we&#39;ll call the <em>shorthand</em> for the surreal. It&#39;s use in printing out numbers. The second constructor, and many other operators leave this blank. The empty set is designated by ∅, which you can get in Julia by typing <code>\emptyset TAB</code>. </p><pre><code class="language-none">julia&gt; using SurrealNumbers
julia&gt; z = zero(SurrealShort)
julia&gt; x1 = SurrealShort(&quot;1&quot;, [z], ∅)
julia&gt; x2 = SurrealShort(&quot;2&quot;, [x1], ∅)
julia&gt; x_something = SurrealShort([z, x1], ∅)
julia&gt; x_half = convert(SurrealShort, 1 // 2)</code></pre><p>These commands create several surreals, starting at zero, then 1, and 2, showing the recursive construction. Then a surreal whose value we might not know (to start with), and then we convert the rational value 1/2 into a surreal. The type <code>SurrealShort</code> is named because the subset of surreals that are implemented here (those with finite representations) is called the short surreals. There are several aliases to this in the code: <code>SurrealFinite</code> (which was what I started with, and so is the fundamental type), and <code>SurrealDyadic</code> (for reasons described below). </p><p>Note that the output of these varies: in the case where a shorthand was defined it just outputs (in bold) the shorthand, but otherwise it will show the bracket format of the components. To see the bracket format even when there is a shorthand defined use the command <code>pf</code>, e.g.</p><pre><code class="language-none">julia&gt; println(&quot; x_half = &quot;, x_half, &quot; = &quot;)
julia&gt; pf(x_half)
julia&gt; println()</code></pre><p>We have most of the standard arithmetic operators (division has some restrictions – see below), so you can do things such as</p><pre><code class="language-none">julia&gt; x2 + x_half</code></pre><p>which will produce quite a long sequence. To see what it is, convert back to a real number, </p><pre><code class="language-none">julia&gt; float( x2 + x_half )</code></pre><p>or do a picture of the recursion using DOT (which needs to be separately installed from <a href="https://www.graphviz.org/">GraphViz</a>), e.g.,</p><pre><code class="language-none">julia&gt; file = &quot;test_dot.dot&quot;
julia&gt; FID = open(file, &quot;w&quot;)
julia&gt; surreal2dot(FID, x2 + x_half)
julia&gt; close(FID)
julia&gt; run(`dot -Tsvg -O $file`)</code></pre><p>with the following result. Note that the red notations were added manually. Each box is a surreal number, designated by the number at the top of the box, and its left and right sets are in the corresponding boxes below, with links shown in red for left, and blue for right. The recursion for each is show below, down to the point where each recursion stops at zero.</p><p><img src="/test/Data/test_dot.svg" alt="3/2"/></p><p>That seems like enough to get you started, so now a little about the implementation. </p><h2><a class="nav-anchor" id="Icky-bits-–-implementation-details-1" href="#Icky-bits-–-implementation-details-1">Icky bits – implementation details</a></h2><p>While surreals use sets, and Julia has a Set type, implementation wise, sorted arrays of surreals were a better bet because that exchanges a once off cost when constructing a surreal with a reduced cost for many operations throughout the lifetime of the surreal. Also Julia creates a whole suite of array functions automagically when you define scalars so using arrays was a low pain way to get things working. Also, although the surreals use sets, i.e., order of the elements is not important, almost all texts do write these sets in order.</p><p>The surreals include all real numbers (and infinity and epsilon and others). However, many of these require infinitely large sets <span>$X_L$</span> and/or <span>$X_R$</span>. I have some ideas about how to do that (using lazy evaluation), but they aren&#39;t fleshed out yet so for the moment, I will restrict myself to finite surreals, i.e., surreals with finite sets <span>$X_L$</span> and <span>$X_R$</span>. </p><p>So the type <code>Surreal</code> is an abstract type (a subtype of <code>Real</code>) with at present only one useful subtype <code>SurrealShort</code>, where finite (here) means that the representation is finite, not that the number itself is finite. </p><p>This is a pretty rich set by itself, but it doesn&#39;t cover even the entire set of Rationals; only the <em>dyadic</em> rationals. So a few words on them seem in order (see below).</p><p>The plan is to add a <code>SurrealTrans</code> for the transfinites and other surreals with infinite representations. But that is a little harder to do, so I leave that for the moment.</p><p>The actual type structure (minus the constructor – see the code) is just</p><pre><code class="language-none">struct SurrealShort &lt;: Surreal
    shorthand::String
    L::Array{SurrealShort,1} 
    R::Array{SurrealShort,1}  
    h::UInt64 
end</code></pre><p>Note the addition of a <code>shorthand</code> string, which isn&#39;t necessary, but carries a little bit of extra information to make pretty printing and hence debugging a little easier.</p><p>The variable <code>h</code> contains the hash value of the surreal, which is calculated the first time it is used. This avoids incurring the cost of this (recursive) calculation every time the value is needed, which is often as the hash is used to speed up other operations. </p><h3><a class="nav-anchor" id="Dyadic-numbers-1" href="#Dyadic-numbers-1">Dyadic numbers</a></h3><p>The dyadic rational numbers are those that have a denominator that is an exact power of 2, that is, numbers of the form (note seems that GitHub doesn&#39;t let me use Mathjax to interpret maths). </p><pre><code class="language-none"> \[ x = \frac{ n }{ 2^k } \]</code></pre><p>It turns out that every dyadic has a finite representation as a surreal, and every finite surreal represents a dyadic. The easiest way to represent this is as a DAG (Directed Acyclic Graph) of the constructions as shown below:</p><p><img src="/examples/Data/dyadic_tree_3.dot.svg" alt="dyadics"/></p><p>It might seem a little limiting to be restricted to this set, but remember that floating point numbers are dyadics. They are a (binary) integer (the <em>significand</em>) multiplied by 2 to the power of a (binary) exponent (just called the <em>exponent</em>). Thus all (finite) floating point numbers have a finite surreal representation (though it may be very, very long).</p><p>I did start writing a type for dyadics, but I&#39;m not sure what it would be useful for, so it didn&#39;t get far (I realise the irony here – the surreals themselves aren&#39;t exactly useful).</p><h3><a class="nav-anchor" id="Converting-a-number-to-a-surreal-1" href="#Converting-a-number-to-a-surreal-1">Converting a number to a surreal</a></h3><p>The description of a surreal given above generates a <em>form</em>. The forms satisfy the rules of arithmetic (<span>$+$</span>, <span>$-$</span>, <span>$\times$</span> and <span>$/$</span>), and so we can identify these with the real numbers. However, there are many <em>forms</em> that equate to the same real number. Thus there are sets of <em>forms</em> that are equivalent in the sense that <span>$x \equiv y$</span> if and only if <span>$x \leq y$</span> and <span>$y \leq x$</span>.</p><p>I think of this loosely by analogy to the rationals, e.g., we can have two different forms that have the same value, and we usually call the same &quot;number&quot; </p><pre><code class="language-none">2 // 4 = 1 // 2</code></pre><p>However, it seems important to distinguish equality (where two forms are identical) from equivalence (where they have the same value). In programming terms two &quot;things&quot; are equal when they are the same, not some airy-fairy notion of equivalence, so equality and equivalence have different meanings and uses. Hence, here we have the relation ≅ defined to test equivalence separate from ==.</p><p>BTW, here we hit one of the weirdnesses of Julia; 99\% of the time, you can redefine operators and comparators to do whatever you like on your new type. But you can&#39;t redefine <span>$===$</span> or <span>$\equiv$</span>. The blog I read suggests that this is because this is a core operation, that might cause problems if a user broke it. From what I can tell, <span>$===$</span> tests that the things being tested are the same object, i.e. ,the same piece of memory. That doesn&#39;t seem like something we want to mess with. </p><ul><li>https://docs.julialang.org/en/stable/devdocs/functions/#Builtins-1</li><li>https://discourse.julialang.org/t/overload-for-custom-type/4898</li></ul><p>Anyway, I have defined <em>congruence</em> <span>$\cong$</span> or <code>≅</code> to do the same thing, check for equivalence (equality of value). However, as there are many possible surreal forms we could create to represent any given real number, we have to chose one. Call that the <em>canonical</em> form. We could define it in several ways, but the standard is</p><ul><li><p>zero =&gt; <span>$0 = \{ | \}$</span></p></li><li><p>integers n =&gt; <span>$n+1 = \{ n | \}$</span></p></li><li><p>dyadic fraction =&gt; $ x = \frac{ n }{ 2^k } $ (for n odd) becomes</p><p>[  { x - 1/2^{k} | x + 1/2^{k} } ]</p></li><li><p>negative number =&gt; use the identity that <span>$-x = \{-X_R | -X_L\}$</span></p></li></ul><p>This is the set of conversions implemented, and it includes all dyadics, and hence floats. Note the recursion inherent in the construction/conversion. So some care (particularly) with floats should be taken not to create a variable that exhausts the stack. The current code isn&#39;t very clever in checking for this another place some work is needed. </p><p>Examples:</p><pre><code class="language-none">julia&gt; pf( convert(SurrealShort, 1//2) )
{ 0 | 1 }
julia&gt; pf( convert(SurrealShort, 3//4) )
{ 1//2 | 1 } 
julia&gt; pf( convert(SurrealShort, -11//8) )
{ -3//2 | -5//4 }</code></pre><p>The <code>pf</code> function used here is a &quot;print-in-full&quot;, which prints the left and right sets of the surreal, not the real equivalent shorthand. </p><h3><a class="nav-anchor" id="Converting-a-surreal-back-to-a-real-1" href="#Converting-a-surreal-back-to-a-real-1">Converting a surreal back to a real</a></h3><p>The conversion of canonical forms is relatively easy, but remember that non-canonical forms are possible, and can be quite counter-intuitive. </p><p>For instance, naively, you might expect that the form <span>$\{ 3 | 17 \}$</span> could be mapped to the mean of the two sets, i.e., 10. However, <span>$x = \{ X_L | X_R \}$</span> is the simplest number such that <span>$X_L &lt; x &lt; X_R$</span>, so, in fact, this form is equivalent to 4.</p><p>Note, often in texts it is written <span>$X \not \leq Y$</span> whereas I am writing <span>$X &gt; Y$</span>. The original definition is intended (I think) to take care of the case where one or the other is the empty set, but we can equally define <span>$&gt;$</span> to be synonomous with <span>$\not \leq$</span>, and just move on. </p><p>Conway defines a surreal <span>$x = \{ X_L | X_R \}$</span> to be the simplest <span>$x$</span> that satisfies <span>$X_L &lt; x &lt; X_R$</span>, where simplest means comes from the earliest generation.</p><p>The secret of the conversion is again to use recursion, but that is not quite enough in this case. We use several tricks along the way:</p><ul><li>If <span>$x$</span> is equivalent to a known surreal such as 0 or 1, we convert</li></ul><p>directly</p><ul><li>If <span>$x$</span> is negative, we use the identity that <span>$-x = \{ -X_R | -X_L \}$</span></li><li>And, most importantly, if <span>$0 &lt; x &lt; 1$</span> we know <span>$x$</span> will be the</li></ul><p>&quot;simplest&quot; dyadic rational number such that <span>$x_L &lt; x &lt; x_R$</span>. In the interval <span>$(0,1)$</span> simplest means having the denominator with the lowest power, i.e., in order of preference we would like the denomator to the <span>$1,2,3, \ldots$</span>.</p><p>We can find the latter though a simple modification of the standard binary search a simplified version of which is shown below.</p><pre><code class="language-none"> a = 0; b = 1
 while true
   d = (a + b) / 2   
   if xl &lt; c &lt; xr
     return d
   elseif c &lt;= xl
     a = d 
   elseif c &gt;= xr 
     b = d
   end
 end</code></pre><p>The first and last rules allow us to convert any number <span>$x \in [0,1]$</span>. To convert numbers above this range, i.e., <span>$x &gt; 1$</span>, we subtract 1 (the surreal additive identity), convert the result (recursively), and then add back 1 (this time a real). To convert negative numbers we apply the second rule.</p><p>The result is not the world&#39;s most beautiful code – I&#39;m sure it can be improved, but there are so many other inefficiency&#39;s here, I am not sure it warrants it.</p><h3><a class="nav-anchor" id="Implementations-of-operators-and-standard-functions-1" href="#Implementations-of-operators-and-standard-functions-1">Implementations of operators and standard functions</a></h3><p>Most of the operators follow standard surreal definitions and defining them in Julia is easy. They are all recursive, as you might guess, and so very inefficient – I wouldn&#39;t want to do demanding computations this way, but they are easy to understand, for instance</p><pre><code class="language-none"> +(x::SurrealShort, y::SurrealShort) = SurrealShort([x.X_L .+ y; x .+ y.X_L], [x.X_R .+ y; x .+ y.X_R] )</code></pre><p>Notice that we are exploiting here Julia&#39;s natural extension of operators from scalar to vectors (this is one of the reasons that using arrays instead of sets for <span>$X_L$</span> and <span>$X_R$</span> is appealling). Thus we can write</p><pre><code class="language-none"> x .+ [y_1, y_2]</code></pre><p>once addition is defined on the scalar surreal type, without any additional definitions, and this is particular appealling here as the scalar addition operator is recursively defined in terms of the vector+scalar addition <code>.+</code>. </p><p>Mutiplication was a bit of a bugbear to get right because I misinterpreted the definition. The definition of multiplication of <span>$x= \{ X_L |X_R \}$</span> and <span>$y=\{ Y_L | Y_R \}$</span> had terms like</p><pre><code class="language-none">X_L y + x Y_L - X_L Y_L</code></pre><p>I assumed the <code>+</code> operator in this definition was the standard (surreal) addition of sets of surreals, but it isn&#39;t. Instead the entire expression should be interpreted as &quot;for all pairs of elements from X<em>L and Y</em>L perform the above computation, and form a set from the results.&quot; That&#39;s easy enough to do once you work out what you are trying to do. There is another underlying problem which is that canonical forms all have sets with 1 or 0 elements, and my broken multiplication worked for them. It was only when I created products of non-canonical forms that I saw problems, and then only when I had cleaned out another misunderstanding from the code.</p><p>The one interesting thing to note is that even simple computations often generate non-canonical forms. Part of the aim of this package was to let people experiment and see such things. It is otherwise far to laborious to calculate anything but the very simplest cases (none of the above texts do any but the simplest).</p><p>One really useful example (for me to understand the surreals) is the following, which was obtained by multiplying the canonical form of 2 with itself. You might naively think that operators applied to canonical forms resulted in canonical forms, but this is not the case. The form is quite complex. Moreover, superficially it recurse into itself, i.e., the surreal number 4 appears twice in the tree. However, the form is defined in terms of the tree, so the dependent &quot;4&quot; is not the same surreal as the parent &quot;4&quot;. That is, they are not  equal, but they are equivalent. Thus the parent &quot;4&quot; is defined in terms of simpler forms (even though one of these is equivalent). </p><p><img src="/test/Data/test_dot_x43.svg" alt="2x2 = 4"/></p><p>The other pieces of the toolkit are the standard things you expect to be able to do with numbers, e.g. round, sign, isinteger, ...  I haven&#39;t implemented all of these, but hopefully enough that any others can be easily added.</p><p>There are two approaches: one is to use intrinsic surreal arithmetic, e.g. <code>sign</code> and <code>abs</code> are implemented using native surreal arithmetic and operators. The result is that they looks almost exactly like it would for any other number.</p><pre><code class="language-none">sign(x::SurrealShort) = x&lt;zero(x) ? -one(x) : x&gt;zero(x) ? one(x) : zero(x)
abs(x::SurrealShort) = x&lt;zero(x) ? -x : x</code></pre><p>Actually, I don&#39;t even have to define <code>abs</code> as I get this for free because Julia has a similar operation defined <code>abs(x::Real)</code> for all real numbers. This is a great feature of Julia&#39;s type hierarchy and multiple dispatch function selection. </p><p>The other approach to function definition is somewhat of a cheat. It involves converting the number to a real, and then using the appropriate operation on that field. I have tried to avoid that approach when possible. At the moment, only the <code>simplify</code> function uses this approach. But if I am going to do more complex math functions, e.g., logs or trig functions, I think I will have to take this approach. The mathematical definitions of such in pure surreal terms are obscure. </p><p>The cheat is used as part of one of the pieces of this that is hard to implement, namely division. Division is well-defined on the surreals, but, as even simple divisions such as 1/3 result in non-dyadic rational numbers, and hence have a infinite representations as a surreal, the class of &quot;finite&quot; surreals defined here is not <em>closed</em> under division. Eventually, this can be solved by outputting a non-finite surreal, but for the moment I have only implemented division when dividing by <span>$2^k$</span> or by a divisor of the numerator of the dyadic. The first is easy (it can be implemented in terms of multiplication). The second (at the moment) requires the cheat (see below) of converting back into a rational number, but in either case the check to see which case requires the conversion. Some work is needed here.</p><p>The <code>show</code> command is designed to show the full structure unless there is a &quot;shorthand&quot; defined for a surreal (most of the simple conversions will set this up). This aids in viewing the surreals succintly, but sometimes we want to see deeper. In the case where shorthand is defined we can use the command <code>pf</code> to see deeper, but it will stop at the first layer below with a shorthand.</p><p>To see the full recursion I have implemented output of a surreal form into the DOT syntax from <a href="https://www.graphviz.org/">GraphViz</a>. The function <code>surreal2dot</code> can output a <code>.dot</code> file, and then this can be parsed (assuming you have GraphVis installed) by commands such as </p><pre><code class="language-none">using SurrealNumbers

s2 = convert(SurrealShort, 3//4)
file = &quot;test_dot_s2.dot&quot;
FID = open(file, &quot;w&quot;)
surreal2dot(FID, s2)
close(FID)
run(`dot -Tsvg -O $file`)

x5 = SurrealShort( convert.(SurrealShort, [-1, -1//2, 0]), [one(SurrealShort)] )
file = &quot;test_dot_x5.dot&quot;
FID = open(file, &quot;w&quot;)
surreal2dot(FID, x5)
close(FID)
run(`dot -Tsvg -O $file`)</code></pre><p>Which produces the figures like those below, illustrating the recursive definition of the two surreal numbers given. </p><p><img src="/test/Data/test_dot_s2.dot.svg" alt="s2"/> &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt; <img src="/test/Data/test_dot_x5.dot.svg" alt="x5"/>. </p><p>The thing to note about these tree representations is that they are inefficient, the same surreal forms are repeated. The code includes a function <code>surreal2dag</code> that you use in exactly the same way to generate a DAG (Directed Acyclic Graph) representation of the surreal as you see below.</p><p><img src="/test/Data/test_dag_s2.dot.svg" alt="s2"/> &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt; <img src="/test/Data/test_dag_x5.dot.svg" alt="x5"/>. </p><p>See the code <code>test/test_dot.jl</code> for other examples. </p><h3><a class="nav-anchor" id="Uniquely-surreal-functions-1" href="#Uniquely-surreal-functions-1">Uniquely surreal functions</a></h3><p>There are two pieces that are unique to surreals:</p><p><strong>Generation:</strong> the generation of a surreal is 1 + the generation of the surreals used to construct it. Again this is easy to implement recursively.  Generation comes from Knuth&#39;s story where it&#39;s called the &quot;birth day&quot; of the surreal. Generation can be thought of as a function <span>$g(\cdot)$</span></p><pre><code class="language-none"> \[ g(x) = \sup_{y \in X_L \cup X_R} \big[ g(y) + 1 \big] \]</code></pre><p>Implicitly, generation is the tree <em>depth</em>, if viewed as the recursive tree shown above. </p><p>Generation is important as <span>$x = \{ X_L | X_R \}$</span> is defined to be the simplest number such that <span>$X_L &lt; x &lt; X_R$</span>, i.e., the number with the lowest birth day. </p><p>Note that within an equivalence class of forms, not all forms have the same generation. </p><p><strong>Canonicalise:</strong> convert a surreal into its equivalent canonical form. The easiest way to implement this was to use a similar cheat to that above, i.e., convert to a real, and then convert back to the equivalent surreal in canonical form.</p><h3><a class="nav-anchor" id="Arrays-of-Surreals-1" href="#Arrays-of-Surreals-1">Arrays of Surreals</a></h3><p>We mentioned arrays of surreals earlier – they are used in the implementation instead of sets. One of the nice things about Julia us that you get many of the array operators and functions for free when you create scalar operators. So, for instance, you can write</p><pre><code class="language-none">convert.(SurrealShort, [-1, 0, 1, 2] )</code></pre><p>which will broadcasts the convert function across the array of integers to create an array containing the respective surreals. Likewise, we can use <em>comprehensions</em> to construct arrays, e.g.,</p><pre><code class="language-none">[ convert(SurrealShort, i) for i=-1:2 ]</code></pre><p>Or we could construct and iterator for the same thing (once <code>floor</code> and some promotion rules are defined), e.g.., the iterator from -1 to 2 is  </p><pre><code class="language-none">convert(SurrealShort, -1 ):convert(SurrealShort, 2)</code></pre><p>However, in order to use arrays as sets we need, in the constructor for a surreal to reduce the &quot;set&quot; to a sorted array containing unique elements. Julia has nice sort and unique functions, but they rely on hash functions, so we have to add a hash. These need to be recursive, and work for arrays of surreals as well. The hash function help says that we should implement such for new types such that <code>isequal(x,y)</code> implies <code>hash(x)==hash(y)</code>, with a second argument to be mixed in the results. This is linked to the idea that we should separate the == and the <em>congruent</em> comparisons – my hash is based on two forms being equal, not being equivalent. In any case, Julia&#39;s syntax is again simple and concise for specifying the hashes need (believe it or not its another recursive function), but I need the hash to be really fast. I use it to speed other pieces of code up, so I can&#39;t afford to recurse every time. So instead, the hash value is calculated the first time it is needed, and then stored in the surreal data structure itself, so that we only need call the function once at most. We could have defined the hash in the constructor, but it turns out that many temporary surreals are created in multiplication (in particular), and so avoiding the overhead when it isn&#39;t needed is just fine.</p><h2><a class="nav-anchor" id="Other-comments-1" href="#Other-comments-1">Other comments</a></h2><p>Don&#39;t bother to tell me that this is horribly inefficient. It will never be anything but. Surreals were not created with numerical computing in mind. They are about as inefficient a way to do calculations as I can reasonably think of (excluding the addition of nullops everywhere).</p><p>I&#39;m still learning Julia, and part of this is absorbing the style guide    https://docs.julialang.org/en/stable/manual/style-guide/ so the code is still morphing to make it more efficient, and more stylish.    </p><p>And note that this isn&#39;t really exploring an entire chunk of the surreals, i.e., the transfinite numbers that can be represented this way. I&#39;ll get to that one day, time gods willing.</p><p>There are other implementations of the surreals. For instance</p><ul><li>Coq https://dl.acm.org/citation.cfm?id=2150520</li><li>Coq https://github.com/pirapira/surreal</li><li>Haskell https://github.com/Lacaranian/surreal (only integers)</li><li>Haskell https://github.com/serialhex/Surreal-Numbers (not quite working)</li><li>Haskell https://github.com/elfakyn/Haskell-surreals (only integers)</li><li>Javascript http://www.iwriteiam.nl/SurrealNumbers.html</li><li>Mathematica http://demonstrations.wolfram.com/GeneratingTheSurrealNumbers/             (only generation)</li><li>Lua https://github.com/Ryan1729/lua-Surreal-numbers?files=1 </li><li>Python https://github.com/codeinthehole/python-surreal (not much        implemented)</li><li>Python https://github.com/314eter/surreal-numbers</li><li>Ruby http://raganwald.com/2009/03/07/elegance-and-the-surreals.html</li></ul><p>And some of these languages might be more appropriate in some ways for this task. But I wanted to learn Julia, and see how far I could take it here. Moreover, most of these are at least as incomplete as the code here. For instance, none (as far as I am aware) implement division (the Julia toolkit here has a very limited version of division included). </p><h3><a class="nav-anchor" id="More-information-about-Surreals-1" href="#More-information-about-Surreals-1">More information about Surreals</a></h3><ul><li>https://www.ics.uci.edu/~eppstein/cgt/surreal.html</li></ul><h3><a class="nav-anchor" id="More-Examples-1" href="#More-Examples-1">More Examples</a></h3><p>Some examples of code are included here to make a little of this more real. </p><h4><a class="nav-anchor" id="Creating-surreals-1" href="#Creating-surreals-1">Creating surreals</a></h4><p>Let&#39;s start by creating some surreals</p><pre><code class="language-none">x0 = SurrealShort(&quot;0&quot;, ∅,   ∅)  
x1 = SurrealShort(&quot;1&quot;, [x0], ∅)
x11 = SurrealShort(&quot;-1&quot;, ∅,  [x0])
x4 = SurrealShort( [x11],  [x1,x0])
x5 = SurrealShort( [x11,x0,x4],  [x1])
x21  = SurrealShort(&quot;2&quot;, [x1],  ∅)
x22  = SurrealShort( [x0, x1],  ∅)
x23  = SurrealShort( [x11,x1],  ∅)
x24  = SurrealShort( [x11,x0,x1],  ∅)
x25 = [x11,x0,x1] ≀ ∅
z = zero(x1)
z = zero(SurrealShort)
z = one(x1)
s1 = convert(SurrealShort, 1//2)
s2 = convert(SurrealShort, 3//4)</code></pre><p>You can check the values using <code>float</code> to convert them back to standard floating point numbers. Note that ∅ is shorthand for an empty array of surreal numbers, which is quite helpful in many places.</p><p>Try printing them out in various forms:</p><pre><code class="language-none">print(&quot;s1 = &quot;, s1, &quot; = &quot; )
pf(s1)
println()</code></pre><h4><a class="nav-anchor" id="Operations-on-surreals-and-arrays-of-surreals-1" href="#Operations-on-surreals-and-arrays-of-surreals-1">Operations on surreals and arrays of surreals</a></h4><p>Test out some operations on the above variables with expected results</p><pre><code class="language-none"> # comparisons
 x0 &lt;= x1
 x0 &lt;= x0
 x1 &gt;= x11
 !( x11 ≅ x1 )
 x21 ≅ x22 ≅ x23 ≅ x24

 # addition and subtraction
 -x1 == x11
 - -x0 == x0
 - -x4 == x4 
 x1 + x11 ≅ x0
 x1 - x1 ≅ x0
 x1 + x0 == x1

 # multiplication
 x1*x1 ≅ x1
 x0*x1 ≅ x0
 x4*x0 ≅ x0 
 convert(SurrealShort,2)*convert(SurrealShort,2) ≅ convert(SurrealShort,4)
 
 # division
 x11/one(x11) ≅ -x1
 x22 / x22 ≅ one(x22)
 x22/x1 ≅ x22
 x4/x1 ≅ x4
 float(x1/x4) == float(x1)/float(x4)
 convert(SurrealShort, 6)/ convert(SurrealShort, 3) ≅ convert(SurrealShort, 2)</code></pre><h4><a class="nav-anchor" id="Simple-functions-1" href="#Simple-functions-1">Simple functions</a></h4><p>Many of the simple numerical functions will work, but not the more advanced ones such as <code>log</code>. The two specific to surreals are <code>generation</code> which returns the generation or birth day of a surreal, and <code>canonicalise</code> which reduces it to the canonical form of the surreal. </p><pre><code class="language-none"> generation( zero(SurrealShort) ) == 0
 canonicalise( convert(SurrealShort,2)*convert(SurrealShort,2) ) == convert(SurrealShort,4)</code></pre><h4><a class="nav-anchor" id="Converting-back-to-standard-real-1" href="#Converting-back-to-standard-real-1">Converting back to standard real</a></h4><p>Examples of how to convert a number back to rationals or floats. </p><pre><code class="language-none"> convert(Rational, convert(SurrealShort, 1//8)) == 1//8
 float( x4 ) == -0.5
 convert( Rational, SurrealShort( [ 7//16 ], [ 15//16 ] ) ) == 1//2
 convert(String, x4) == &quot;-1/2&quot;</code></pre><p>And of how conversion is automatically applied by promotion rules</p><pre><code class="language-none"> x0 &lt;= 1.0
 x1 == 1//1
 1.0 + x1 == 2.0
 canonicalise(1//2 + x1) == 1.5
 1//2 + x1 ≅ 1.5</code></pre><h2><a class="nav-anchor" id="Final-notes-1" href="#Final-notes-1">Final notes</a></h2><p>The total implementation here is a little more than 1,000 lines of code. No doubt an expert in Julia could make it a good deal tighter – I have concentrated on making the code easy (for me) to understand rather than super concise.</p><p>This little project would have been a lot easier if I knew more Julia, or more about the surreals. Trying to build something to learn about two moving parts at once wasn&#39;t a brilliant idea :)</p><p>But I was correct in thinking that (at least for me) this would have been almost impossible to build in Matlab. And at the least, it would have required a good deal more work without all the automagical pieces of Julia helping.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
