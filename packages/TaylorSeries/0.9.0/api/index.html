<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorSeries.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorSeries.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../background/">Background</a></li><li><a class="toctext" href="../userguide/">User guide</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Module-1">Module</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-and-methods-1">Functions and methods</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><hr/><h2><a class="nav-anchor" id="Module-1" href="#Module-1">Module</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorSeries" href="#TaylorSeries.TaylorSeries"><code>TaylorSeries.TaylorSeries</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">TaylorSeries</code></pre><p>A Julia package for Taylor expansions in one or more independent variables.</p><p>The basic constructors are <a href="#TaylorSeries.Taylor1"><code>Taylor1</code></a> and <a href="#TaylorSeries.TaylorN"><code>TaylorN</code></a>; see also <a href="#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1" href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Taylor1{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in one independent variable.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs :: Array{T,1}</code> Expansion coefficients; the <span>$i$</span>-th   component is the coefficient of degree <span>$i-1$</span> of the expansion.</li><li><code>order  :: Int</code> Maximum order (degree) of the polynomial.</li></ul><p>Note that <code>Taylor1</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial" href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HomogeneousPolynomial{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for homogenous polynomials in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs  :: Array{T,1}</code> Expansion coefficients of the homogeneous</li></ul><p>polynomial; the <span>$i$</span>-th component is related to a monomial, where the degrees of the independent variables are specified by <code>coeff_table[order+1][i]</code>.</p><ul><li><code>order   :: Int</code> order (degree) of the homogenous polynomial.</li></ul><p>Note that <code>HomogeneousPolynomial</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN" href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TaylorN{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs  :: Array{HomogeneousPolynomial{T},1}</code> Vector containing the</li></ul><p><code>HomogeneousPolynomial</code> entries. The <span>$i$</span>-th component corresponds to the homogeneous polynomial of degree <span>$i-1$</span>.</p><ul><li><code>order   :: Int</code>  maximum order of the polynomial expansion.</li></ul><p>Note that <code>TaylorN</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.AbstractSeries" href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractSeries{T&lt;:Number} &lt;: Number</code></pre><p>Parameterized abstract type for <a href="#TaylorSeries.Taylor1"><code>Taylor1</code></a>, <a href="#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> and <a href="#TaylorSeries.TaylorN"><code>TaylorN</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Functions-and-methods-1" href="#Functions-and-methods-1">Functions and methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number" href="#TaylorSeries.Taylor1-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.Taylor1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Taylor1([T::Type=Float64], [order::Int=1])</code></pre><p>Shortcut to define the independent variable of a <code>Taylor1{T}</code> polynomial of given <code>order</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; Taylor1(16)
 1.0 t + 𝒪(t¹⁷)

julia&gt; Taylor1(Rational{Int}, 4)
 1//1 t + 𝒪(t⁵)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number" href="#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">HomogeneousPolynomial([T::Type=Float64], nv::Int])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>HomogeneousPolynomial{T}</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; HomogeneousPolynomial(1)
 1.0 x₁

julia&gt; HomogeneousPolynomial(Rational{Int}, 2)
 1//1 x₂</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number" href="#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">TaylorN([T::Type=Float64], nv::Int; [order::Int=get_order()])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>TaylorN{T}</code> variable as a polynomial. The order is defined through the keyword parameter <code>order</code>, whose default corresponds to <code>get_order()</code>. The default of type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; TaylorN(1)
 1.0 x₁ + 𝒪(‖x‖⁷)

julia&gt; TaylorN(Rational{Int},2)
 1//1 x₂ + 𝒪(‖x‖⁷)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.set_variables" href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_variables([T::Type], names::String; [order=get_order(), numvars=-1])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. <code>names</code> defines the output for each variable (separated by a space). The default type <code>T</code> is <code>Float64</code>, and the default for <code>order</code> is the one defined globally. Changing the <code>order</code> or <code>numvars</code> resets the hash_tables.</p><p>If <code>numvars</code> is not specified, it is inferred from <code>names</code>. If only one variable name is defined and <code>numvars&gt;1</code>, it uses this name with subscripts for the different variables.</p><pre><code class="language-julia">julia&gt; set_variables(Int, &quot;x y z&quot;, order=4)
3-element Array{TaylorSeries.TaylorN{Int},1}:
  1 x + 𝒪(‖x‖⁵)
  1 y + 𝒪(‖x‖⁵)
  1 z + 𝒪(‖x‖⁵)

julia&gt; set_variables(&quot;α&quot;, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 α₁ + 𝒪(‖x‖⁵)
  1.0 α₂ + 𝒪(‖x‖⁵)

julia&gt; set_variables(&quot;x&quot;, order=6, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x₁ + 𝒪(‖x‖⁷)
  1.0 x₂ + 𝒪(‖x‖⁷)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.get_variables" href="#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_variables(T::Type, [order::Int=get_order()])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. It takes the default <code>_params_TaylorN_</code> values if <code>set_variables</code> hasn&#39;t been changed with the exception that <code>order</code> can be explicitely established by the user without changing internal values for <code>num_vars</code> or <code>variable_names</code>. Ommiting <code>T</code> defaults to <code>Float64</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.show_params_TaylorN" href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_params_TaylorN()</code></pre><p>Display the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.show_monomials" href="#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_monomials(ord::Int) --&gt; nothing</code></pre><p>List the indices and corresponding of a <code>HomogeneousPolynomial</code> of degree <code>ord</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.getcoeff" href="#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getcoeff(a, n)</code></pre><p>Return the coefficient of order <code>n::Int</code> of a <code>a::Taylor1</code> polynomial.</p></div></div><div><div><pre><code class="language-none">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::HomogeneousPolynomial</code>, specified by <code>v</code>, which is a tuple (or vector) with the indices of the specific monomial.</p></div></div><div><div><pre><code class="language-none">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::TaylorN</code>, specified by <code>v</code>, which is a tuple (or vector) with the indices of the specific monomial.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate" href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate(a, [dx])</code></pre><p>Evaluate a <code>Taylor1</code> polynomial using Horner&#39;s rule (hand coded). If <code>dx</code> is ommitted, its value is considered as zero. Note that the syntax <code>a(dx)</code> is equivalent to <code>evaluate(a,dx)</code>, and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(x, δt)</code></pre><p>Evaluates each element of <code>x::Union{ Vector{Taylor1{T}}, Matrix{Taylor1{T}} }</code>, representing the dependent variables of an ODE, at <em>time</em> δt. Note that the syntax <code>x(δt)</code> is equivalent to <code>evaluate(x, δt)</code>, and <code>x()</code> is equivalent to <code>evaluate(x)</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(a, x)</code></pre><p>Substitute <code>x::Taylor1</code> as independent variable in a <code>a::Taylor1</code> polynomial. Note that the syntax <code>a(x)</code> is equivalent to <code>evaluate(a, x)</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(a, [vals])</code></pre><p>Evaluate a <code>HomogeneousPolynomial</code> polynomial at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div></div><div><div><pre><code class="language-none">evaluate(a, [vals])</code></pre><p>Evaluate the <code>TaylorN</code> polynomial <code>a</code> at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate!" href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate!(x, δt, x0)</code></pre><p>Evaluates each element of <code>x::Array{Taylor1{T},1}</code>, representing the Taylor expansion for the dependent variables of an ODE at <em>time</em> <code>δt</code>. It updates the vector <code>x0</code> with the computed values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.taylor_expand" href="#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">taylor_expand(f, x0; order)</code></pre><p>Computes the Taylor expansion of the function <code>f</code> around the point <code>x0</code>.</p><p>If <code>x0</code> is a scalar, a <code>Taylor1</code> expansion will be returned. If <code>x0</code> is a vector, a <code>TaylorN</code> expansion will be computed. If the dimension of x0 (<code>length(x0)</code>) is different from the variables set for <code>TaylorN</code> (<code>get_numvars()</code>), an <code>AssertionError</code> will be thrown.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.update!" href="#TaylorSeries.update!"><code>TaylorSeries.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">update!(a, x0)</code></pre><p>Takes <code>a &lt;: Union{Taylo1,TaylorN}</code> and expands it around the coordinate <code>x0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.derivative" href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">derivative(a)</code></pre><p>Return the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code>. The last coefficient is set to zero.</p><p>The function <code>differentiate</code> is an exact synonym of <code>derivative</code>.</p></div></div><div><div><pre><code class="language-none">derivative(a, n)</code></pre><p>Compute recursively the <code>Taylor1</code> polynomial of the n-th derivative of <code>a::Taylor1</code>.</p></div></div><div><div><pre><code class="language-none">derivative(n, a)</code></pre><p>Return the value of the <code>n</code>-th derivative of the polynomial <code>a</code>.</p></div></div><div><div><pre><code class="language-none">derivative(a, r)</code></pre><p>Partial differentiation of <code>a::HomogeneousPolynomial</code> series with respect to the <code>r</code>-th variable.</p></div></div><div><div><pre><code class="language-none">derivative(a, r)</code></pre><p>Partial differentiation of <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable. The <code>r</code>-th variable may be also specified through its symbol.</p></div></div><div><div><pre><code class="language-none">derivative(a::TaylorN{T}, ntup::NTuple{N,Int})</code></pre><p>Return a <code>TaylorN</code> with the partial derivative of <code>a</code> defined by <code>ntup::NTuple{N,Int}</code>, where the first entry is the number of derivatives with respect to the first variable, the second is the number of derivatives with respect to the second, and so on.</p></div></div><div><div><pre><code class="language-none">derivative(ntup::NTuple{N,Int}, a::TaylorN{T})</code></pre><p>Returns the value of the coefficient of <code>a</code> specified by <code>ntup::NTuple{N,Int}</code>, multiplied by the corresponding factorials.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.differentiate" href="#TaylorSeries.differentiate"><code>TaylorSeries.differentiate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">differentiate</code></pre><p>An exact synonym of <a href="#TaylorSeries.derivative"><code>derivative</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.integrate" href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrate(a, [x])</code></pre><p>Return the integral of <code>a::Taylor1</code>. The constant of integration (0-th order coefficient) is set to <code>x</code>, which is zero if ommitted.</p></div></div><div><div><pre><code class="language-none">integrate(a, r)</code></pre><p>Integrate the <code>a::HomogeneousPolynomial</code> with respect to the <code>r</code>-th variable. The returned <code>HomogeneousPolynomial</code> has no added constant of integration. If the order of a corresponds to <code>get_order()</code>, a zero <code>HomogeneousPolynomial</code> of 0-th order is returned.</p></div></div><div><div><pre><code class="language-none">integrate(a, r, [x0])</code></pre><p>Integrate the <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable, where <code>x0</code> the integration constant and must be independent of the <code>r</code>-th variable; if <code>x0</code> is ommitted, it is taken as zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.gradient" href="#TaylorSeries.gradient"><code>TaylorSeries.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    gradient(f)
    ∇(f)</code></pre><p>Compute the gradient of the polynomial <code>f::TaylorN</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian" href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    jacobian(vf)
    jacobian(vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian!" href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    jacobian!(jac, vf)
    jacobian!(jac, vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials evaluated at the vector <code>vals</code>, and write results to <code>jac</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian" href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    hessian(f)
    hessian(f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian!" href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    hessian!(hes, f)
    hessian!(hes, f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>, and write results to <code>hes</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.inverse" href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inverse(f)</code></pre><p>Return the Taylor expansion of <span>$f^{-1}(t)$</span>, of order <code>N = f.order</code>, for <code>f::Taylor1</code> polynomial if the first coefficient of <code>f</code> is zero. Otherwise, an <code>ArgumentError</code> is thrown.</p><p>The algorithm implements Lagrange inversion at <span>$t=0$</span> if <span>$f(0)=0$</span>:</p><div>\[\begin{equation*}
f^{-1}(t) = \sum_{n=1}^{N} \frac{t^n}{n!} \left.
    \frac{{\rm d}^{n-1}}{{\rm d} z^{n-1}}\left(\frac{z}{f(z)}\right)^n
    \right\vert_{z=0}.
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.abs" href="#Base.abs"><code>Base.abs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">abs(a)</code></pre><p>Returns <code>a</code> if <code>constant_term(a) &gt; 0</code> and <code>-a</code> if <code>constant_term(a) &lt; 0</code> for <code>a &lt;:Union{Taylor1,TaylorN}</code>. Notice that <code>typeof(abs(a)) &lt;: AbstractSeries</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(x::AbstractSeries, p::Real)</code></pre><p>Returns the p-norm of an <code>x::AbstractSeries</code>, defined by</p><div>\[\begin{equation*}
\left\Vert x \right\Vert_p =  \left( \sum_k | x_k |^p \right)^{\frac{1}{p}},
\end{equation*}\]</div><p>which returns a non-negative number.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isapprox(x::AbstractSeries, y::AbstractSeries; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false)</code></pre><p>Inexact equality comparison between polynomials: returns <code>true</code> if <code>norm(x-y,1) &lt;= atol + rtol*max(norm(x,1), norm(y,1))</code>, where <code>x</code> and <code>y</code> are polynomials. For more details, see <a href="#Base.isapprox"><code>Base.isapprox</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isfinite" href="#Base.isfinite"><code>Base.isfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isfinite(x::AbstractSeries) -&gt; Bool</code></pre><p>Test whether the coefficients of the polynomial <code>x</code> are finite.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.displayBigO" href="#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">displayBigO(d::Bool) --&gt; nothing</code></pre><p>Set/unset displaying of the big 𝒪 notation in  the output of <code>Taylor1</code> and <code>TaylorN</code> polynomials. The initial value is <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.use_show_default" href="#TaylorSeries.use_show_default"><code>TaylorSeries.use_show_default</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">use_Base_show(d::Bool) --&gt; nothing</code></pre><p>Use <code>Base.show_default</code> method (default <code>show</code> method in Base), or a custom display. The initial value is <code>false</code>, so customized display is used.</p></div></div></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.ParamsTaylorN" href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ParamsTaylorN</code></pre><p>DataType holding the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code>.</p><p><strong>Fields:</strong></p><ul><li><code>order            :: Int</code>  Order (degree) of the polynomials</li><li><code>num_vars         :: Int</code>  Number of variables</li><li><code>variable_names   :: Vector{String}</code> Names of the variables</li><li><code>variable_symbols :: Vector{Symbol}</code>  Symbols of the variables</li></ul><p>These parameters can be changed using <a href="#TaylorSeries.set_variables"><code>set_variables</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._InternalMutFuncs" href="#TaylorSeries._InternalMutFuncs"><code>TaylorSeries._InternalMutFuncs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>_InternalMutFuncs</code></p><p>Contains parameters and expressions that allow a simple programatic construction for calling the internal mutating functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_tables" href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_tables(num_vars, order)</code></pre><p>Return the hash tables <code>coeff_table</code>, <code>index_table</code>, <code>size_table</code> and <code>pos_table</code>. Internally, these are treated as <code>const</code>.</p><p><strong>Hash tables</strong></p><pre><code class="language-none">coeff_table :: Array{Array{Array{Int,1},1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector with the vectors of all the possible combinations of monomials of a <code>HomogeneousPolynomial</code> of order <span>$i$</span>.</p><pre><code class="language-none">index_table :: Array{Array{Int,1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector of (hashed) indices that represent the distinct monomials of a <code>HomogeneousPolynomial</code> of order (degree) <span>$i$</span>.</p><pre><code class="language-none">size_table :: Array{Int,1}</code></pre><p>The <span>$i+1$</span>-th component contains the number of distinct monomials of the <code>HomogeneousPolynomial</code> of order <span>$i$</span>, equivalent to <code>length(coeff_table[i])</code>.</p><pre><code class="language-none">pos_table :: Array{Dict{Int,Int},1}</code></pre><p>The <span>$i+1$</span>-th component maps the hash index to the (lexicographic) position of the corresponding monomial in <code>coeffs_table</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_index_vectors" href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_index_vectors(num_vars, degree)</code></pre><p>Return a vector of index vectors with <code>num_vars</code> (number of variables) and degree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.in_base" href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">in_base(order, v)</code></pre><p>Convert vector <code>v</code> of non-negative integers to base <code>order+1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.make_inverse_dict" href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">make_inverse_dict(v)</code></pre><p>Return a Dict with the enumeration of <code>v</code>: the elements of <code>v</code> point to the corresponding index.</p><p>It is used to construct <code>pos_table</code> from <code>index_table</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffs1!" href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resize_coeffs1!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than <code>order+1</code>, it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffsHP!" href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resize_coeffsHP!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than the number of coefficients correspondinf to <code>order</code> (given by <code>size_table[order+1]</code>), it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.constant_term" href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">constant_term(a)</code></pre><p>Return the constant value (zero order coefficient) for <code>Taylor1</code> and <code>TaylorN</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mul!(c, a, b, k::Int) --&gt; nothing</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k]</code> of <code>c = a * b</code>, where all <code>c</code>, <code>a</code>, and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \sum_{j=0}^k a_j b_{k-j}.\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{HomogeneousPolynomial,HomogeneousPolynomial,HomogeneousPolynomial}" href="#LinearAlgebra.mul!-Tuple{HomogeneousPolynomial,HomogeneousPolynomial,HomogeneousPolynomial}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(c, a, b) --&gt; nothing</code></pre><p>Return <code>c = a*b</code> with no allocation; all arguments are <code>HomogeneousPolynomial</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T},1},Union{Array{T,2}, SparseMatrixCSC{T,Ti} where Ti&lt;:Integer},Array{Taylor1{T},1}}} where T&lt;:Number" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T},1},Union{Array{T,2}, SparseMatrixCSC{T,Ti} where Ti&lt;:Integer},Array{Taylor1{T},1}}} where T&lt;:Number"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(Y, A, B)</code></pre><p>Multiply A*B and save the result in Y.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.div!" href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">div!(c, a, b, k::Int, ordfact::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a / b</code>, where all <code>c</code>, <code>a</code> and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k =  \frac{1}{b_0} \big(a_k - \sum_{j=0}^{k-1} c_j b_{k-j}\big).\]</div><p>For <code>Taylor1</code> polynomials, <code>ordfact</code> is the order of the factorized term of the denominator.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.pow!" href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pow!(c, a, r::Real, k::Int, k0::Int=0)</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k]</code> of <code>c = a^r</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \frac{1}{k a_0} \sum_{j=0}^{k-1} \big(r(k-j) -j\big)a_{k-j} c_j.\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient of <code>a</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.square" href="#TaylorSeries.square"><code>TaylorSeries.square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">square(a::AbstractSeries) --&gt; typeof(a)</code></pre><p>Return <code>a^2</code>; see <a href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!" href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqr!(c, a, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a^2</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-1)/2} a_{k-j} a_j,
    \text{ if k is odd,} \\
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2,
    \text{ if k is even. }
\end{eqnarray*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T},HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}" href="#TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T},HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}"><code>TaylorSeries.sqr!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sqr!(c, a)</code></pre><p>Return <code>c = a*a</code> with no allocation; all parameters are <code>HomogeneousPolynomial</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqrt!" href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqrt!(c, a, k::Int, k0::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = sqrt(a)</code> for both<code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=1}^{(k-1)/2} c_{k-j}c_j\big),
    \text{ if k is odd,} \\
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=1}^{(k-2)/2} c_{k-j}c_j
    - (c_{k/2})^2\big), \text{ if k is even.}
\end{eqnarray*}\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient, which must be even.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.exp!" href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = exp(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j.
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.log!" href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = log(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{a_0} \big(a_k - \frac{1}{k} \sum_{j=0}^{k-1} j a_{k-j} c_j \big).
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sincos!" href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sincos!(s, c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sin(a)</code> and <code>c = cos(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp;  \frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j ,\\
c_k &amp;=&amp; -\frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tan!" href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tan!(c, a, p, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = c^2</code> and is passed as an argument for efficiency.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = a_k + \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.asin!" href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asin!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = asin(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{ \sqrt{r_0} }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.acos!" href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acos!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = acos(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = - \frac{1}{ r_0 }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.atan!" href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atan!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = atan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = 1+a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{r_0}\big(a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j\big).
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sinhcosh!" href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinhcosh!(s, c, a, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sinh(a)</code> and <code>c = cosh(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\
c_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tanh!" href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tanh!(c, a, p, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tanh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = a_k - \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.derivative!" href="#TaylorSeries.derivative!"><code>TaylorSeries.derivative!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">derivative!(res, a) --&gt; nothing</code></pre><p>In-place version of <code>derivative</code>. Compute the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code> and save it into <code>res</code>. The last coefficient is set to zero.</p></div></div><div><div><pre><code class="language-none">derivative!(p, a, k) --&gt; nothing</code></pre><p>Update in-place the <code>k-th</code> expansion coefficient <code>p[k]</code> of <code>p = derivative(a)</code> for both <code>p</code> and <code>a</code> <code>Taylor1</code>.</p><p>The coefficients are given by</p><div>\[p_k = (k+1)a_{k+1}.\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._internalmutfunc_call" href="#TaylorSeries._internalmutfunc_call"><code>TaylorSeries._internalmutfunc_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">_internalmutfunc_call( fn :: _InternalMutFuncs )</code></pre><p>Creates the appropriate call to the internal mutating function defined by the <code>_InternalMutFuncs</code> object. This is used to construct <a href="#TaylorSeries._dict_unary_calls"><code>_dict_unary_calls</code></a> and <a href="#TaylorSeries._dict_binary_calls"><code>_dict_binary_calls</code></a>. The call contains the prefix <code>TaylorSeries.</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._dict_unary_ops" href="#TaylorSeries._dict_unary_ops"><code>TaylorSeries._dict_unary_ops</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>_dict_binary_ops</code></p><p><code>Dict{Symbol, Array{Any,1}}</code> with the information to construct the <code>_InternalMutFuncs</code> related to unary operations.</p><p>The keys correspond to the function symbols.</p><p>The arguments of the array are the function name (e.g. <code>add!</code>), a tuple with the function arguments, and an <code>Expr</code> with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use <code>:_res</code> for the (mutated) result, <code>:_arg1</code>, for the required argument, possibly <code>:_aux</code> when there is an auxiliary expression needed, and <code>:_k</code> for the computed order of <code>:_res</code>. When an auxiliary expression is required, and <code>Expr</code> defining its calling pattern is added as the last entry of the vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._dict_binary_calls" href="#TaylorSeries._dict_binary_calls"><code>TaylorSeries._dict_binary_calls</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>_dict_binary_calls::Dict{Symbol, NTuple{2,Expr}}</code></p><p>Dictionary with the expressions that define the internal binary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.</p><p>Evaluating the entries generates symbols that represent the actual calls to the internal mutating functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._dict_unary_calls" href="#TaylorSeries._dict_unary_calls"><code>TaylorSeries._dict_unary_calls</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>_dict_unary_calls::Dict{Symbol, NTuple{2,Expr}}</code></p><p>Dictionary with the expressions that define the internal unary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.</p><p>Evaluating the entries generates expressions that represent the actual calls to the internal mutating functions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries._dict_binary_ops" href="#TaylorSeries._dict_binary_ops"><code>TaylorSeries._dict_binary_ops</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>_dict_binary_ops</code></p><p><code>Dict{Symbol, Array{Any,1}}</code> with the information to construct the <code>_InternalMutFuncs</code> related to binary operations.</p><p>The keys correspond to the function symbols.</p><p>The arguments of the array are the function name (e.g. <code>add!</code>), a tuple with the function arguments, and an <code>Expr</code> with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use <code>:_res</code> for the (mutated) result, <code>:_arg1</code> and <code>_arg2</code> for the required arguments, and <code>:_k</code> for the computed order of <code>:_res</code>.</p></div></div></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a></li><li><a href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a></li><li><a href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a></li><li><a href="#TaylorSeries.Taylor1-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.Taylor1</code></a></li><li><a href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a></li><li><a href="#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a></li><li><a href="#TaylorSeries._InternalMutFuncs"><code>TaylorSeries._InternalMutFuncs</code></a></li><li><a href="#Base.abs"><code>Base.abs</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.isfinite"><code>Base.isfinite</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{HomogeneousPolynomial,HomogeneousPolynomial,HomogeneousPolynomial}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T},1},Union{Array{T,2}, SparseMatrixCSC{T,Ti} where Ti&lt;:Integer},Array{Taylor1{T},1}}} where T&lt;:Number"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li><li><a href="#TaylorSeries._internalmutfunc_call"><code>TaylorSeries._internalmutfunc_call</code></a></li><li><a href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a></li><li><a href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a></li><li><a href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a></li><li><a href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a></li><li><a href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a></li><li><a href="#TaylorSeries.derivative!"><code>TaylorSeries.derivative!</code></a></li><li><a href="#TaylorSeries.differentiate"><code>TaylorSeries.differentiate</code></a></li><li><a href="#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a></li><li><a href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a></li><li><a href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a></li><li><a href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a></li><li><a href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a></li><li><a href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a></li><li><a href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a></li><li><a href="#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a></li><li><a href="#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a></li><li><a href="#TaylorSeries.gradient"><code>TaylorSeries.gradient</code></a></li><li><a href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a></li><li><a href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a></li><li><a href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a></li><li><a href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a></li><li><a href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a></li><li><a href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a></li><li><a href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a></li><li><a href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a></li><li><a href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a></li><li><a href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a></li><li><a href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a></li><li><a href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a></li><li><a href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a></li><li><a href="#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a></li><li><a href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a></li><li><a href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a></li><li><a href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a></li><li><a href="#TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T},HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}"><code>TaylorSeries.sqr!</code></a></li><li><a href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a></li><li><a href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a></li><li><a href="#TaylorSeries.square"><code>TaylorSeries.square</code></a></li><li><a href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a></li><li><a href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a></li><li><a href="#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a></li><li><a href="#TaylorSeries.update!"><code>TaylorSeries.update!</code></a></li><li><a href="#TaylorSeries.use_show_default"><code>TaylorSeries.use_show_default</code></a></li></ul><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
