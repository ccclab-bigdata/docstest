<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · EventSimulation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>EventSimulation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.AbstractReservoir" href="#EventSimulation.AbstractReservoir"><code>EventSimulation.AbstractReservoir</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract class for reservoirs. <code>SimQueue</code> and <code>SimResource</code> are concrete types implementing it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.AbstractState" href="#EventSimulation.AbstractState"><code>EventSimulation.AbstractState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for holding state of the simulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.Action" href="#EventSimulation.Action"><code>EventSimulation.Action</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Structure holding an information that <code>what</code> should be executed by scheduler at time <code>when</code>; <code>what</code> should accept one argument of type <code>Scheduler</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.EmptyState" href="#EventSimulation.EmptyState"><code>EventSimulation.EmptyState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Simplest concrete type implementing <code>AbstractState</code> that does not hold any data</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.EventSimulation" href="#EventSimulation.EventSimulation"><code>EventSimulation.EventSimulation</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>EventSimulation is an event-based discrete event simulation engine.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.PriorityTime" href="#EventSimulation.PriorityTime"><code>EventSimulation.PriorityTime</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Subtype of <code>Real</code> defining a lexicographically comparable pair of <code>Real</code>. It is designed to be used by <code>Scheduler</code> where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.</p><p><code>PriorityTime</code> two fields <code>time</code> and <code>priority</code> may have different types, but both have to be subtypes of <code>Real</code>. <code>priority</code> should be used to determine order of execution of <code>Action</code>s that have the same time. Two actions with identical <code>time</code> and <code>priority</code> have undefined oreder of execution so this should be avoided.</p><p><code>PriorityTime</code> type has defined lexicographic order and <code>+</code>, <code>-</code>. It is immutable, has a custom <code>hash</code> function and conversions from <code>Real</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.ResourceRequest" href="#EventSimulation.ResourceRequest"><code>EventSimulation.ResourceRequest</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Internal structure that remembers that <code>quantity</code> was requested by <code>request</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.Scheduler" href="#EventSimulation.Scheduler"><code>EventSimulation.Scheduler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Holds information about current simulation state Contains the following fields:</p><ul><li><code>now</code>         current simulation time</li><li><code>event_queue</code> priority queue of <code>Actions</code> planned to be executed</li><li><code>state</code>       user defined subtype of <code>AbstractState</code> of the simulation</li><li><code>monitor</code>     function that is called before event is triggered               must accept two arguments <code>Scheduler</code> and <code>Δ</code>, a difference               between time of event to be executed and time of last executed event</li></ul><p>If two <code>Action</code>s have identical <code>when</code> time in <code>event_queue</code> then the order of their execution is undefined</p><p>When <code>monitor</code> is executed the event to happen is still on <code>event_queue</code>, but time is updated to time when the event is to be executed (i.e. <code>monitor</code> sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics <code>monitor</code> may assume that the simulation spent <code>Δ</code> time in this state. Function <code>monitor</code> should not modify <code>event_queue[1]</code> as EventSimulation assumes that the event to be triggered after <code>monitor</code> executes will not be modified. Additionally it it not guaranteed that <code>event_queue[1]</code> will be executed after <code>monitor</code> finishes because simulation might terminate earlier.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.SimQueue" href="#EventSimulation.SimQueue"><code>EventSimulation.SimQueue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>SimQueue type for holding arbitrary objects <code>O</code>. It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.</p><p>Fields:</p><ul><li><code>fifo_queue</code>    if <code>true</code> <code>queue</code> is FIFO, otherwise LIFO</li><li><code>max_queue</code>     maximum <code>queue</code> size</li><li><code>queue</code>         vector of objects in a queue</li><li><code>fifo_requests</code> if <code>true</code> <code>requests</code> is FIFO, otherwise LIFO</li><li><code>max_requests</code>  maximum <code>requests</code> size</li><li><code>requests</code>      vector of request functions</li></ul><p>Functions in <code>requests</code> must accept two arguments <code>Scheduler</code> and <code>O</code>. When <code>O</code> arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with <code>O</code>.</p><p>Initially an empty <code>SimQueue</code> with no requests is constructed. By default <code>queue</code> and <code>requests</code> have FIFO policy and are unbounded.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.SimResource" href="#EventSimulation.SimResource"><code>EventSimulation.SimResource</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Resource type for holding numeric values (like amount of liquid). It stores current <code>quantity</code> of matter and its allowed <code>lo</code> and <code>hi</code> amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.</p><p>Fields:</p><ul><li><code>quantity</code>       current quantity in resource</li><li><code>lo</code>            minimum quantity of resource</li><li><code>hi</code>            maximum quantity of resource</li><li><code>fifo_requests</code> if <code>true</code> <code>requests</code> is FIFO, otherwise LIFO</li><li><code>max_requests</code>  maximum <code>requests</code> size</li><li><code>requests</code>      vector of request and requested quantity</li></ul><p>Functions in <code>requests</code> must accept one argument <code>Scheduler</code>, so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.</p><p>Initially an empty <code>SimResource</code> with no requests is constructed. Initial <code>quantity</code>, <code>lo</code> and <code>hi</code> may be provided. By default <code>SimResource</code> is empty, and has minimum quantity of zero and unbounded maximum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.bulk_register!" href="#EventSimulation.bulk_register!"><code>EventSimulation.bulk_register!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bulk_register!(s, who, what, Δ, randomize)</code></pre><p>Put event at time <code>s.now+Δ</code> to <code>s.event_queue</code> that will execute <code>what(scheduler, w)</code> for all <code>w</code> in <code>who</code>. If <code>randomize</code> is <code>false</code> then <code>who</code> is traversed in natural order otherwise it is traversed in random order. <code>what</code> must accept exactly two arguments of type <code>Scheduler</code> and <code>eltype(who)</code>. The function does not check if <code>Δ</code> is a valid (finite) number. Returns inserted bulk <code>Action</code>.</p><p>Function is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.dispatch!" href="#EventSimulation.dispatch!"><code>EventSimulation.dispatch!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dispatch!(s, r)
dispatch!(s, q)</code></pre><p>Internal function used for dispatching requests in <code>SimResource</code> and <code>SimQueue</code>. Puts appropriate <code>Action</code>s in <code>s</code> immediately.</p></div></div></section><pre><code class="language-none">EventSimulation.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.go!" href="#EventSimulation.go!"><code>EventSimulation.go!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">go!(s, until)</code></pre><p>Runs simulation defined by <code>s</code> until <code>s.now</code> is greater or equal than <code>until</code> or <code>s.event_queue</code> is empty (i.e. nothing is left to be done). By default <code>until</code> equals <code>Inf</code>.</p></div></div></section><pre><code class="language-none">EventSimulation.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.interrupt!" href="#EventSimulation.interrupt!"><code>EventSimulation.interrupt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">interrupt!(s, a)</code></pre><p>First occurrence of <code>Action</code> <code>a</code> is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns <code>true</code> if <code>a</code> was found in queue and <code>false</code> otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.pq_insert!" href="#EventSimulation.pq_insert!"><code>EventSimulation.pq_insert!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pq_insert!(pq, what, when)</code></pre><p>Specialized core Julia code for insertion to priority queue <code>pq</code> Not exported Put <code>Action(what, when)</code> to <code>pq</code>. Return inserted <code>Action</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.pq_remove!" href="#EventSimulation.pq_remove!"><code>EventSimulation.pq_remove!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pq_remove!(pq)</code></pre><p>Specialized core Julia code for getting top element from priority queue <code>pq</code> Not exported Return <code>Action</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.provide!" href="#EventSimulation.provide!"><code>EventSimulation.provide!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">provide!(s, r, quantity)
provide!(s, q, object)</code></pre><p>Allows to fill <code>SimResource</code> with <code>quantity</code> or <code>SimQueue</code> with <code>object</code>.</p><p>In <code>SimResource</code> changes the balance of <code>r.quantity</code>. Given quantity may be any number, but the balance of <code>SimResource</code> will be changed only in <code>lo</code>-<code>hi</code> range. Returns the actual change in <code>SimResource</code> balance.</p><p>In <code>SimQueue</code> adds <code>object</code> to <code>q.queue</code>. Returns <code>true</code> on success and <code>false</code> if there were too many objects in queue already.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.register!" href="#EventSimulation.register!"><code>EventSimulation.register!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">register!(s, what, Δ)</code></pre><p>Put <code>what</code> at time <code>s.now+Δ</code> to <code>s.event_queue</code>. <code>what</code> must accept exactly one argument of type <code>Scheduler</code>. The function does not check if <code>Δ</code> is a valid (finite) number. Returns inserted <code>Action</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.repeat_bulk_register!" href="#EventSimulation.repeat_bulk_register!"><code>EventSimulation.repeat_bulk_register!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat_bulk_register!(s, who, what, interval, randomize)</code></pre><p>Repeat <code>bulk_register!</code> at time intervals specified by <code>interval</code> function, which must accept <code>Scheduler</code> argument. <code>interval</code> function is called after the previous event was executed. <code>what</code> must accept exactly two arguments of type <code>Scheduler</code> and <code>typeof(who)</code>. Returns <code>nothing</code>. Calling <code>terminate!</code> in function <code>interval</code> will not stop the simulation. Instead, if <code>interval</code> returns <code>nothing</code> the action is not scheduled and <code>repeat_register</code> will effectively terminate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.repeat_register!" href="#EventSimulation.repeat_register!"><code>EventSimulation.repeat_register!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat_register!(s, what, interval)</code></pre><p>Put <code>what</code> to <code>s.event_queue</code> repeatedly in time intervals specified by <code>interval</code> function, which must accept one argument of type <code>Scheduler</code>. <code>what</code> must accept exactly one argument of type <code>Scheduler</code>. <code>interval</code> function is called after the previous event was executed. Returns <code>nothing</code>. Calling <code>terminate!</code> in function <code>interval</code> will not stop the simulation. Instead, if <code>interval</code> returns <code>nothing</code> the action is not scheduled and <code>repeat_register</code> will effectively terminate.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.request!" href="#EventSimulation.request!"><code>EventSimulation.request!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">request!(s, r, quantity, request)
request!(s, q, request)</code></pre><p>Function used to register request for resource in <code>SimResource</code> or object from <code>SimQueue</code>.</p><p>In <code>SimResource</code> requested <code>quantity</code> must be provided and <code>request</code> accepts only <code>Scheduler</code> argument (it must know what it wanted). Returns tuple of:</p><ul><li><code>true</code> if successfull and <code>false</code> when too many requests were made</li><li><code>ResourceRequest</code> object created</li></ul><p>In <code>SimResource</code> function <code>request</code> must accept one argument <code>Scheduler</code>. In <code>SimQueue</code> function <code>request</code> must accept two arguments <code>Scheduler</code> and object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.terminate!" href="#EventSimulation.terminate!"><code>EventSimulation.terminate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">terminate!(s)</code></pre><p>Empties <code>s.event_queue</code> which will lead to termination of simulation unless it is refilled before execution returns to <code>go!</code>. Useful for event-triggered termination of simulation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.waive!" href="#EventSimulation.waive!"><code>EventSimulation.waive!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">waive!(r, res_request)
waive!(q, request)</code></pre><p>Allows to remove first occurence that would be served of <code>res_request</code> from <code>SimResource</code> or <code>request</code> from <code>SimQueue</code>.</p><p>Returns <code>true</code> on success and <code>false</code> if <code>res_request</code> or <code>request</code> respectively was not found.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EventSimulation.withdraw!" href="#EventSimulation.withdraw!"><code>EventSimulation.withdraw!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">withdraw!(q, object)</code></pre><p>Allows to remove first occurrence that would be served of <code>object</code> from <code>SimQueue</code>.</p><p>Returns <code>true</code> on success and <code>false</code> if <code>object</code> was not found.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
