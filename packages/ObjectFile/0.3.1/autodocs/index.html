<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ObjectFile.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ObjectFile.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.@constants" href="#ObjectFile.@constants"><code>ObjectFile.@constants</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@constants</code></pre><p>Macro to create intelligent enum arrays in Julia.  Defines not only variables mapping names to values within Julia, but also a dictionary mapping those values back to a string representation of the variable names itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.@derefmethod" href="#ObjectFile.@derefmethod"><code>ObjectFile.@derefmethod</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@derefmethod</code></pre><p>Macro to create a method that works on a reference type by generating a wrapper call to <code>deref(x)</code> where <code>x</code> is the first argument in the call.  Example:</p><pre><code class="language-none">@derefmethod foo(x::SectionRef)</code></pre><p>Will generate the following code:</p><pre><code class="language-none">foo(x::SectionRef, args...) = foo(deref(x), args...)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.@mustimplement" href="#ObjectFile.@mustimplement"><code>ObjectFile.@mustimplement</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@mustimplement</code></pre><p>Macro to create fallthrough implementations of basic functions such as <code>readheader(oh::ObjectHandle)</code>; these fallthrough implementations are meant to be overridden by methods in packages such as <code>ELF.jl</code> or <code>MachO.jl</code>.</p></div></div></section><pre><code class="language-none">ObjectFile.COFF</code></pre><pre><code class="language-none">ObjectFile.COFFDataDirectories</code></pre><pre><code class="language-none">ObjectFile.COFFDynamicLink</code></pre><pre><code class="language-none">ObjectFile.COFFDynamicLinks</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.COFF.COFFHandle" href="#ObjectFile.COFF.COFFHandle"><code>ObjectFile.COFF.COFFHandle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">COFFHandle</code></pre><p>An <code>ObjectHandle</code> subclass for COFF files, this is the primary object by which client applications will interact with COFF files.</p></div></div></section><pre><code class="language-none">ObjectFile.COFFHeader</code></pre><pre><code class="language-none">ObjectFile.COFFImageDataDirectory</code></pre><pre><code class="language-none">ObjectFile.COFFOptionalHeader32</code></pre><pre><code class="language-none">ObjectFile.COFFOptionalHeader64</code></pre><pre><code class="language-none">ObjectFile.COFFOptionalHeaderStandard</code></pre><pre><code class="language-none">ObjectFile.COFFOptionalHeaderWindows32</code></pre><pre><code class="language-none">ObjectFile.COFFOptionalHeaderWindows64</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.COFF.COFFRPath" href="#ObjectFile.COFF.COFFRPath"><code>ObjectFile.COFF.COFFRPath</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">COFFRPath</code></pre><p>COFF RPath object; note that while COFF files do not have an RPath within them, they <em>do</em> seach the same directory as the loading binary (e.g. the <code>$ORIGIN</code>). We use <code>COFFRPath</code> to effect this, although strictly speaking there is no such thing as a &quot;COFF RPath&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.COFF.COFFStrTab" href="#ObjectFile.COFF.COFFStrTab"><code>ObjectFile.COFF.COFFStrTab</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">COFFStrTab</code></pre><p>COFF <code>StrTab</code> type, containing the metadata necessary to perform string table lookups, via the <code>strtab_lookup()</code> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.COFF.COFFSymbolRef" href="#ObjectFile.COFF.COFFSymbolRef"><code>ObjectFile.COFF.COFFSymbolRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">COFFSymbolRef</code></pre><p>Contains a reference to an <code>COFFSymtabEntry</code>, as well as an <code>COFFSymbols</code>, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.COFF.COFFSymbols" href="#ObjectFile.COFF.COFFSymbols"><code>ObjectFile.COFF.COFFSymbols</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">COFFSymbols</code></pre><p>COFF symbol table, contains the list of symbols defined within the object file.</p><p>Note that because COFF Symbols are variable-length, we store a table of offsets at which the (non-auxilliary) symbols can be found.</p></div></div></section><pre><code class="language-none">ObjectFile.COFFSymtabEntry</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.DynamicLink" href="#ObjectFile.DynamicLink"><code>ObjectFile.DynamicLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicLink</code></pre><p>This type encapsulates the linkage of one object file to another.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>DynamicLink()</em></li></ul><p><strong>Accessors:</strong></p><ul><li><em>DynamicLinks()</em></li><li><em>handle()</em></li><li><em>path()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.DynamicLinks" href="#ObjectFile.DynamicLinks"><code>ObjectFile.DynamicLinks</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicLinks</code></pre><p>This type encapsulates the list of dynamic links within an object, holding a collection of <code>DynamicLink</code> objects.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>DynamicLinks()</em></li></ul><p><strong>Iteration</strong></p><ul><li><em>getindex()</em></li><li><em>lastindex()</em></li><li>iterate()</li><li>eltype()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><pre><code class="language-none">ObjectFile.ELF</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFDynEntries" href="#ObjectFile.ELF.ELFDynEntries"><code>ObjectFile.ELF.ELFDynEntries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ELFDynEntries(oh::ELFHandle)</code></pre><p>Read all <code>ELFDynEntry</code> objects from an ELF object, returning them as an array.</p></div></div><div><div><pre><code class="language-none">ELFDynEntries(oh::ELFHandle, kinds::Vector)</code></pre><p>Read all <code>ELFDynEntry</code> objects from an ELF object, returning them as an array if they are one of the <code>kinds</code> passed in, such as <code>DT_NEEDED</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFDynEntry" href="#ObjectFile.ELF.ELFDynEntry"><code>ObjectFile.ELF.ELFDynEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFDynEntry</code></pre><p>ELF Dynamic table entry type.  This is comprised by a <code>d_tag</code> member and a <code>d_val</code> member; the <code>d_tag</code> tells what kind of command this is to the dynamic linker (e.g. <code>DT_NEEDED</code> denotes a shared library that must be loaded for this ELF object to link properly), whereas <code>d_val</code> is a pointer to another data structure that contains more information.  (E.g. for a <code>DT_NEEDED</code> entry, <code>d_val</code> would represent an offset within the dynamic string table)</p></div></div></section><pre><code class="language-none">ObjectFile.ELFDynEntry32</code></pre><pre><code class="language-none">ObjectFile.ELFDynEntry64</code></pre><pre><code class="language-none">ObjectFile.ELFDynEntryRef</code></pre><pre><code class="language-none">ObjectFile.ELFDynamicLink</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFDynamicLinks" href="#ObjectFile.ELF.ELFDynamicLinks"><code>ObjectFile.ELF.ELFDynamicLinks</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFDynamicLinks</code></pre><p>ELF dynamic linkage table, contains the list dynamic loader commands, see the <code>ELFDynEntry</code> type for an opaque and unhelpful detailing of these commands.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFHandle" href="#ObjectFile.ELF.ELFHandle"><code>ObjectFile.ELF.ELFHandle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFHandle</code></pre><p>An <code>ObjectHandle</code> subclass for ELF files, this is the primary object by which client applications will interact with ELF files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFHeader" href="#ObjectFile.ELF.ELFHeader"><code>ObjectFile.ELF.ELFHeader</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFHeader</code></pre><p>ELF Header type, containing metadata about the ELF object itself, such as its type, offsets for the Program and Section headers, the number of other header entries, etc...</p></div></div></section><pre><code class="language-none">ObjectFile.ELFHeader32</code></pre><pre><code class="language-none">ObjectFile.ELFHeader64</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFInternal" href="#ObjectFile.ELF.ELFInternal"><code>ObjectFile.ELF.ELFInternal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ELFInternal</p><p>Internal datastructure used within the ELF file format to convey fundamental information such as the endianness of the file, whether it&#39;s a 32-bit or 64-bit ELF file, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFRPath" href="#ObjectFile.ELF.ELFRPath"><code>ObjectFile.ELF.ELFRPath</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFRPath</code></pre><p>Stores the RPath entries from an ELF object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSection" href="#ObjectFile.ELF.ELFSection"><code>ObjectFile.ELF.ELFSection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSection</code></pre><p>ELF Section type, containing information about a <code>Section</code> within the ELF object, such as the <code>Section</code>&#39;s name, its size, etc...</p></div></div></section><pre><code class="language-none">ObjectFile.ELFSection32</code></pre><pre><code class="language-none">ObjectFile.ELFSection64</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSectionRef" href="#ObjectFile.ELF.ELFSectionRef"><code>ObjectFile.ELF.ELFSectionRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSectionRef</code></pre><p>ELF <code>SectionRef</code> type, containing an <code>ELFSection</code> and important metadata.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSections" href="#ObjectFile.ELF.ELFSections"><code>ObjectFile.ELF.ELFSections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSections</code></pre><p>ELF Section header table type, containing information about the number of sections within the ELF object, the location of the section headers, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSegment" href="#ObjectFile.ELF.ELFSegment"><code>ObjectFile.ELF.ELFSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSegment</code></pre><p>ELF Segment type, also known as a program header, containing information about the virtual memory layout of a chunk of the program.</p></div></div></section><pre><code class="language-none">ObjectFile.ELFSegment32</code></pre><pre><code class="language-none">ObjectFile.ELFSegment64</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSegments" href="#ObjectFile.ELF.ELFSegments"><code>ObjectFile.ELF.ELFSegments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSegments</code></pre><p>ELF segment header table type, containing information about the number of segments within the ELF object, the location of the segment headers, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFStrTab" href="#ObjectFile.ELF.ELFStrTab"><code>ObjectFile.ELF.ELFStrTab</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFStrTab</code></pre><p>ELF string table type, containing information about a <code>Section</code> that contains a string table.  Note that an ELF file may contain multiple string tables, use the different constructors to reference the different string tables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSymbolRef" href="#ObjectFile.ELF.ELFSymbolRef"><code>ObjectFile.ELF.ELFSymbolRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSymbolRef</code></pre><p>Contains a reference to an <code>ELFSymtabEntry</code>, as well as an <code>ELFSymbols</code>, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSymbols" href="#ObjectFile.ELF.ELFSymbols"><code>ObjectFile.ELF.ELFSymbols</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSymbols</code></pre><p>ELF symbol table, contains the list of symbols defined within the object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.ELFSymtabEntry" href="#ObjectFile.ELF.ELFSymtabEntry"><code>ObjectFile.ELF.ELFSymtabEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ELFSymtabEntry</code></pre><p>ELF Symtab Entry type, contains the data relevant to a symbol defined within this ELF file, garnered from the symbol table (symtab)</p></div></div></section><pre><code class="language-none">ObjectFile.ELFSymtabEntry32</code></pre><pre><code class="language-none">ObjectFile.ELFSymtabEntry64</code></pre><pre><code class="language-none">ObjectFile.FatMachOHandle</code></pre><pre><code class="language-none">ObjectFile.MachFatArch</code></pre><pre><code class="language-none">ObjectFile.MachFatHeader</code></pre><pre><code class="language-none">ObjectFile.MachHeader</code></pre><pre><code class="language-none">ObjectFile.MachHeader32</code></pre><pre><code class="language-none">ObjectFile.MachHeader64</code></pre><pre><code class="language-none">ObjectFile.MachO</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachODynamicLink" href="#ObjectFile.MachO.MachODynamicLink"><code>ObjectFile.MachO.MachODynamicLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachODynamicLink</code></pre><p>MachO type representing a dynamic link between a MachO file and one of its dynamic dependencies.  Although Mach-O encodes more than just the path of the dependency, in order to get at it you will need to dig into the LoadCmd that describes it.</p></div></div></section><pre><code class="language-none">ObjectFile.MachODynamicLinks</code></pre><pre><code class="language-none">ObjectFile.MachOHandle</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOIdDylibCmd" href="#ObjectFile.MachO.MachOIdDylibCmd"><code>ObjectFile.MachO.MachOIdDylibCmd</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOIdDylibCmd</code></pre><p>MachO dylibs have an &quot;identity&quot;, analogous to the SONAME of an ELF shared library.  This Load Command tells the linker about the identity of this particular shared library.  The API of this object is identical to that of the <code>MachOLoadDylibCmd</code> object, as they are intrinsically identical, it is the semantic meaning behind the data that changes, and so this object is all but a typealias for <code>MachOLoadDylibCmd</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOLoadCmd" href="#ObjectFile.MachO.MachOLoadCmd"><code>ObjectFile.MachO.MachOLoadCmd</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOLoadCmd</code></pre><p>Abstraction over all Load Commands that can exist within a Mach-O object file, containing subclasses such as <code>MachOSegmentCmd</code> or <code>MachODySymtabCmd</code>. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li>MachOLoadCmd()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOLoadCmdHeader" href="#ObjectFile.MachO.MachOLoadCmdHeader"><code>ObjectFile.MachO.MachOLoadCmdHeader</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MachOLoadCmdHeader</p><p>All MachO Load Commands have a common header, containing information about what kind of Load Command it is, and how large the load command is.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOLoadCmdRef" href="#ObjectFile.MachO.MachOLoadCmdRef"><code>ObjectFile.MachO.MachOLoadCmdRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOLoadCmdRef</code></pre><p>Datatype containing a Mach-O Load Command, its header, and a reference back to the <code>MachOLoadCmds</code> object it was garnered from</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOLoadCmds" href="#ObjectFile.MachO.MachOLoadCmds"><code>ObjectFile.MachO.MachOLoadCmds</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOLoadCmds</code></pre><p>Allows iteration over the LoadCmds within a Mach-O file.</p><p><strong>Creation</strong></p><ul><li>MachOLoadCmds()</li></ul><p><strong>Iteration</strong></p><ul><li>getindex()</li><li>lastindex()</li><li>iterate()</li><li>length()</li><li>eltype()</li></ul><p><strong>Access</strong></p><ul><li>find</li></ul><p><strong>Convenience constructors</strong></p><ul><li>Segments()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOLoadDylibCmd" href="#ObjectFile.MachO.MachOLoadDylibCmd"><code>ObjectFile.MachO.MachOLoadDylibCmd</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOLoadDylibCmd</code></pre><p>The Load Command that gives information about a dylib that must be loaded for this Mach-O file to link properly.  The API for this laod command is given as follows:</p><p><strong>Creation:</strong></p><ul><li>MachOLoadCmd()</li></ul><p><strong>Accessors:</strong></p><ul><li>dylib_name()</li><li>dylib_timestamp()</li><li>dylib_version()</li><li>dylib_compatibility()</li></ul></div></div></section><pre><code class="language-none">ObjectFile.MachORPath</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSection" href="#ObjectFile.MachO.MachOSection"><code>ObjectFile.MachO.MachOSection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSection</code></pre><p>Mach-O <code>Section</code> type, containing information about the section name, segment name, size, address, etc... of the <code>Section.</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSectionRef" href="#ObjectFile.MachO.MachOSectionRef"><code>ObjectFile.MachO.MachOSectionRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSectionRef</code></pre><p>Mach-O <code>SectionRef</code> type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSections" href="#ObjectFile.MachO.MachOSections"><code>ObjectFile.MachO.MachOSections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSections</code></pre><p>Mach-O <code>Section</code> object collection type.  Mach-O sections are split out over multiple segments, one per load command.  As an example, most executables have at least two segments, <code>__DATA</code> and <code>__TEXT</code>, each of which have multiple sections embedded within them.  A <code>MachOSections</code> object is created from multiple segments (in this case, realized as multiple load commands) which contain the necessary sections, and these sections can then be accessed as desired.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSegment" href="#ObjectFile.MachO.MachOSegment"><code>ObjectFile.MachO.MachOSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSegment</code></pre><p>MachO <code>Segment</code> type which is returned from a <code>MachOSegmentRef</code> when it is dereferenced.  Note that this type exists only for the purposes of type conformity; all the real work is done within <code>MachOSegmentCmd</code>; but since that already inherits from <code>MachOLoadCmd</code>, it cannot also inherit from <code>Segment</code>. Thus, this wrapper type was born to bridge the type hierarchy.</p></div></div></section><pre><code class="language-none">ObjectFile.MachOSegment32Cmd</code></pre><pre><code class="language-none">ObjectFile.MachOSegment64Cmd</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSegmentCmd" href="#ObjectFile.MachO.MachOSegmentCmd"><code>ObjectFile.MachO.MachOSegmentCmd</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSegmentCmd</code></pre><p>Mach-O Segment load command type, containing information about the virtual memory layout of a chunk of the program.  This type is very MachO-specific, so it is not comparable to other object file formats directly.  However, note that this data structure is the gateway through which the file sections are accessed, and while there is a convenience <code>Sections(::MachOHandle)</code> method that will abstract all that away for you, you can also directly call <code>Sections(::MachOLoadCmdRef{MachOSegmentCmd})</code> to get the sections belonging to the given segment.  Note that the <code>Sections</code> call works only upon a <code>MachOLoadCmdRef{MachOSegmentCmd}</code>, it will not work on the <code>MachOSegmentCmd</code> itself directly.</p><p><strong>Creation:</strong></p><ul><li>MachOSegmentCmd()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li>segment_name()</li><li>segment_offset()</li><li>segment<em>file</em>size()</li><li>segment<em>memory</em>size()</li><li>segment<em>num</em>sections()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSegmentRef" href="#ObjectFile.MachO.MachOSegmentRef"><code>ObjectFile.MachO.MachOSegmentRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSegmentRef</code></pre><p>MachO <code>SegmentRef</code> type which is returned from a <code>MachOSegments</code> when it is indexed into.  Note that this type exists only for the purposes of type conformity; all the real work is done within <code>MachOSegmentCmd</code>; but since that already inherits from <code>MachOLoadCmd</code>, and we needed a <code>MachOSegment</code> type that would inherit from <code>Segment</code>, we figured might as well make a <code>MachOSegmentRef</code> as well to keep things nice and symmetric.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSegments" href="#ObjectFile.MachO.MachOSegments"><code>ObjectFile.MachO.MachOSegments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSegments</code></pre><p><code>Segments</code> type that contains all load commands within a Mach-O file that contain segment commands.</p></div></div></section><pre><code class="language-none">ObjectFile.MachOSymbolRef</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSymbols" href="#ObjectFile.MachO.MachOSymbols"><code>ObjectFile.MachO.MachOSymbols</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSymbols</code></pre><p>MachO container type for <code>SymtabEntry</code> objects.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.MachOSymtabEntry" href="#ObjectFile.MachO.MachOSymtabEntry"><code>ObjectFile.MachO.MachOSymtabEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MachOSymtabEntry</code></pre><p>MachO Symbol Table entry type, internally represented as an <code>nlist</code> type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MagicMismatch" href="#ObjectFile.MagicMismatch"><code>ObjectFile.MagicMismatch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MagicMismatch</code></pre><p>This is an error type used to denote that <code>readmeta()</code> was called on a file that does not contain the proper magic at the beginning for the type of object file that was attempting to be loaded.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ObjTypes" href="#ObjectFile.ObjTypes"><code>ObjectFile.ObjTypes</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">ObjTypes::Vector{Type}</code></pre><p><code>ObjTypes</code> contains the registry of file formats that will be used to try and open a object file, (e.g. <code>ELF</code>, <code>MachO</code>, etc...).  This vector is initialized at <code>__init__()</code> time, and used within <code>readmeta()</code>.</p></div></div></section><pre><code class="language-none">ObjectFile.ObjectFile</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ObjectHandle" href="#ObjectFile.ObjectHandle"><code>ObjectFile.ObjectHandle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectHandle</code></pre><p>The basic type that provides access to object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note tha &quot;must implement&quot; is a bit of a misnomer, if an Object file does not have need of a certain piece of this API (e.g. <code>COFF</code> files have no concept of <code>Segment</code>s), leaving that chunk of the API undefined will simply cause errors if a user attempts to use methods that use that part of the API (in the example above, an error will be thrown if the user calls <code>Segments(oh)</code> where <code>oh &lt;: COFFHandle</code>).</p><p><strong>Creation</strong></p><ul><li><em>readmeta()</em></li></ul><p><strong>IOStream-like operations:</strong></p><ul><li>seek()</li><li>seekstart()</li><li>skip()</li><li>startaddr()</li><li>iostream()</li><li>position()</li><li>read()</li><li>readuntil()</li><li>eof()</li><li>unpack()</li></ul><p><strong>Format-specific properties</strong></p><ul><li><em>endianness()</em></li><li><em>is64bit()</em></li><li><em>isrelocatable()</em></li><li><em>isexecutable()</em></li><li><em>islibrary()</em></li><li><em>isdynamic()</em></li><li><em>mangle<em>section</em>name()</em></li><li><em>mangle<em>symbol</em>name()</em></li><li>handle()</li><li><em>header()</em></li><li><em>format_string()</em></li></ul><p><strong>Section properties</strong></p><ul><li><em>section<em>header</em>offset()</em></li><li><em>section<em>header</em>size()</em></li><li><em>section<em>header</em>type()</em></li></ul><p><strong>Segment properties</strong></p><ul><li><em>segment<em>header</em>offset()</em></li><li><em>segment<em>header</em>size()</em></li><li><em>segment<em>header</em>type()</em></li></ul><p><strong>Symbol properties</strong></p><ul><li><em>symtab<em>entry</em>offset()</em></li><li><em>symtab<em>entry</em>size()</em></li><li><em>symtab<em>entry</em>type()</em></li></ul><p><strong>Misc</strong></p><ul><li><em>path()</em></li><li>show()</li><li>find_library()</li><li>find_libraries()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.RPath" href="#ObjectFile.RPath"><code>ObjectFile.RPath</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RPath</code></pre><p>This type encapsulates the search path used by an object file when looking for a shared library.  This class enables not only looking at the path, but querying the path for matches for given library names.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>RPath()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>handle()</em></li></ul><p><strong>RPath operations</strong></p><ul><li><em>rpaths()</em></li><li>canonical_rpaths()</li><li>find_library()</li><li>lastindex()</li><li>iterate()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Section" href="#ObjectFile.Section"><code>ObjectFile.Section</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Section</code></pre><p>An abstraction over the concept of a <code>Section</code> within an object file.  Because many operations upon sections require global operations (access to the string table, knowledge of position within the file, etc...) some operations are defined only upon the <code>SectionRef</code> datatype.  As a user, the <code>SectionRef</code> type should be the primary method of interacting with sections, as a developer adding new object file formats, some methods must support <code>Section</code>s, others must support only <code>SectionRef</code>s.  Note that any method that works on a <code>Section</code> must also work with a <code>SectionRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SectionRef</code> -&gt; <code>Section</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>read()</em></li></ul><p><strong>Utility:</strong></p><ul><li>deref()</li></ul><p><strong>IO-like operations:</strong></p><ul><li>contents()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>section_name()</em></li><li><em>section_size()</em></li><li><em>section_offset()</em></li><li><em>section_address()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SectionRef" href="#ObjectFile.SectionRef"><code>ObjectFile.SectionRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SectionRef</code></pre><p>Provides a reference to a <code>Section</code>, along with a reference to the <code>ObjectHandle</code> this <code>Section</code> comes from.  This should be the primary method by which users interact with sections inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>Section</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>Section</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SectionRef()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>deref()</em></li><li><em>handle()</em></li><li><em>Sections()</em></li></ul><p><strong>IO-like operations:</strong></p><ul><li>read()</li><li>seekstart()</li><li>seek()</li><li>eof()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li>section_name()</li><li><em>section_number()</em></li><li>section_type()</li><li>section_size()</li><li>section_offset()</li><li>section_address()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Sections" href="#ObjectFile.Sections"><code>ObjectFile.Sections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Sections</code></pre><p>An abstraction over the concept of a collection of <code>Section</code> types within an object file.  One can think of the <code>Sections</code> object containing the table of section headers within the object file, whereas the <code>Section</code>/<code>SectionRef</code> objects contain the actual section data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Sections()</em></li></ul><p><strong>Iteration</strong></p><ul><li>getindex()</li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Search</strong></p><ul><li>findall()</li><li>findfirst()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Segment" href="#ObjectFile.Segment"><code>ObjectFile.Segment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Segment</code></pre><p>An abstraction over the concept of a <code>Segment</code> within an object file.  A <code>Segment</code> is a portion of an object file that is given instruction on its layout in virtual memory; this is in contrast to a <code>Section</code>, which delineates different portions of an object file on disk.  ELF files have the strictest separation here, with a single executable file containing multiple <code>Segment</code> and <code>Section</code> objects, with <code>Section</code>s being assigned to one or more <code>Segment</code>s for virtual memory placement.  Mach-O files typically have two <code>Segment</code>s, one called <code>__TEXT</code>, one called <code>__DATA</code>.  COFF files do not have <code>Segment</code>.</p><p>Just like with <code>Section</code> objects, many operations upon segments require global operations (access to the string table, knowledge of position within the file, etc...) which causes some operations to be defined only upon the <code>SegmentRef</code> datatype.  As a user, the <code>SegmentRef</code> type should be the primary method of interacting with segments, as a developer adding new object file formats, some methods must support <code>Segment</code>s, others must support only <code>SegmentRef</code>s. Note that any method that works on a <code>Segment</code> must also work with a <code>SegmentRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SegmentRef</code> -&gt; <code>Section</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>read()</em></li></ul><p><strong>Utility:</strong></p><ul><li>deref()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>segment_name()</em></li><li><em>segment_offset()</em></li><li><em>segment<em>file</em>size()</em></li><li><em>segment<em>memory</em>size()</em></li><li><em>segment_address()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SegmentRef" href="#ObjectFile.SegmentRef"><code>ObjectFile.SegmentRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SegmentRef</code></pre><p>Provides a reference to a <code>Segment</code>, along with a reference to the <code>ObjectHandle</code> this <code>Segment</code> comes from.  This should be the primary method by which users interact with segments inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>Segment</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>Segment</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SegmentRef()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>deref()</em></li><li><em>Segments()</em></li><li>handle()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>segment_name()</em></li><li><em>segment_number()</em></li><li>segment_offset()</li><li>segment<em>file</em>size()</li><li>segment<em>memory</em>size()</li><li>segment_address()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Segments" href="#ObjectFile.Segments"><code>ObjectFile.Segments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Segments</code></pre><p>An abstraction over the concept of a collection of <code>Segment</code> types within an object file.  One can think of the <code>Segments</code> object containing the table of segment headers within the object file, whereas the <code>Segment</code>/<code>SegmentRef</code> objects contain the actual segment data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Segments()</em></li></ul><p><strong>Iteration</strong></p><ul><li><em>getindex()</em></li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Search</strong></p><ul><li>findall()</li><li>findfirst()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.StrTab" href="#ObjectFile.StrTab"><code>ObjectFile.StrTab</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StrTab</code></pre><p>This type encapsulates a string table within an object file, enabling queries against the string table for symbol names, section names, etc... The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>StrTab()</em></li></ul><p><strong>Accessors</strong></p><ul><li><em>handle()</em></li><li><em>strtab_lookup()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SymbolRef" href="#ObjectFile.SymbolRef"><code>ObjectFile.SymbolRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymbolRef</code></pre><p>Provides a reference to a <code>SymtabEntry</code>, along with a reference to the <code>ObjectHandle</code> this <code>SymtabEntry</code> comes from.  This should be the primary method by which users interact with symbols inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>SymtabEntry</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>SymtabEntry</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SymbolRef()</em></li></ul><p><strong>Util:</strong></p><ul><li><em>deref()</em></li><li><em>Symbols()</em></li><li>handle()</li></ul><p><strong>Properties:</strong></p><ul><li><em>symbol_number()</em></li><li><em>symbol_name()</em></li><li>symbol_value()</li><li>isundef()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Symbols" href="#ObjectFile.Symbols"><code>ObjectFile.Symbols</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Symbols</code></pre><p>An abstraction over the concept of a collection of symbol (<code>SymtabEntry</code>) types within an object file.  One can think of the <code>Symbols</code> object containing the table of symbols within the object file, whereas the <code>SymtabEntry</code>/<code>SymbolRef</code> objects contain the actual symbol data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Symbols()</em></li></ul><p><strong>Iteration</strong></p><ul><li>getindex()</li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SymtabEntry" href="#ObjectFile.SymtabEntry"><code>ObjectFile.SymtabEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymtabEntry</code></pre><p>An abstraction over the concept of a symbol within an object file.  This type does not use the <code>Symbol</code> name as this would conflict with the builtin Julia <code>Symbol</code> type, so the name <code>SymtabEntry</code> is used instead.  As a user, the <code>SymbolRef</code> type should be the primary method of interacting with symbols, as a developer adding new object file formats, some methods must support <code>SymtabEntry</code>s, others must support only <code>SymbolRef</code>s.  Note that any method that works on a <code>SymtabEntry</code> must also work with a <code>SymbolRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SymbolRef</code> -&gt; <code>SymtabEntry</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>SymtabEntry()</em></li></ul><p><strong>Util:</strong></p><ul><li>deref()</li></ul><p><strong>Properties:</strong></p><ul><li><em>symbol_name()</em></li><li><em>symbol_value()</em></li><li><em>isundef()</em></li><li><em>isglobal()</em></li><li><em>islocal()</em></li><li><em>isweak()</em></li></ul></div></div></section><pre><code class="language-none">ObjectFile.__init__</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.canonical_rpaths" href="#ObjectFile.canonical_rpaths"><code>ObjectFile.canonical_rpaths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">canonical_rpaths(rpath::RPath)</code></pre><p>Return a canonicalized list of paths that will be searched.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.contents" href="#ObjectFile.contents"><code>ObjectFile.contents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contents(oh::ObjectHandle, section::Section)</code></pre><p>Read the contents of the section referred to by <code>section</code> from the given <code>ObjectHandle</code>, returning a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.deref" href="#ObjectFile.deref"><code>ObjectFile.deref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deref(section::SectionRef)</code></pre><p>Dereference the given <code>SectionRef</code> object to a <code>Section</code>.</p></div></div><div><div><pre><code class="language-none">deref(seg::SegmentRef)</code></pre><p>Dereference the given <code>SegmentRef</code> object to a <code>Segment</code>.</p></div></div></section><pre><code class="language-none">ObjectFile.dylib_compatibility</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.dylib_name" href="#ObjectFile.MachO.dylib_name"><code>ObjectFile.MachO.dylib_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dylib_name(cmd)</code></pre><p>Return the name of the dylib referred to by the given Load Command.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.dylib_timestamp" href="#ObjectFile.MachO.dylib_timestamp"><code>ObjectFile.MachO.dylib_timestamp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dylib_timestamp(cmd)</code></pre><p>Return the build timestamp of the dylib referred to by the given Load Command.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MachO.dylib_version" href="#ObjectFile.MachO.dylib_version"><code>ObjectFile.MachO.dylib_version</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dylib_version(cmd)</code></pre><p>Return the version of the dylib referred to by the given Load Command.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.dyn_entry_is_string" href="#ObjectFile.ELF.dyn_entry_is_string"><code>ObjectFile.ELF.dyn_entry_is_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dyn_entry_is_string(d::ELFDynEntry)</code></pre><p>Return <code>true</code> if the given <code>ELFDynEntry</code> represents an offset within the dynamic string table, and therefore can be used in a <code>strtab_lookup()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.dyn_entry_type" href="#ObjectFile.ELF.dyn_entry_type"><code>ObjectFile.ELF.dyn_entry_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dyn_entry_type(d::ELFDynEntry)</code></pre><p>Return the type of the given <code>ELFDynEntry</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ELF.dyn_entry_type_string" href="#ObjectFile.ELF.dyn_entry_type_string"><code>ObjectFile.ELF.dyn_entry_type_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dyn_entry_type_string(d::ELFDynEntry)</code></pre><p>Return the given <code>ELFDynEntry</code>&#39;s type as a string.</p></div></div></section><pre><code class="language-none">ObjectFile.eltype</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.endianness" href="#ObjectFile.endianness"><code>ObjectFile.endianness</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">endianness(oh::ObjectHandle)</code></pre><p>Returns the endianness of the given <code>ObjectHandle</code> (e.g. <code>:LittleEndian</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eof" href="#Base.eof"><code>Base.eof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eof(section::SectionRef)</code></pre><p>Returns <code>true</code> if the <code>ObjectHandle</code> that this <code>SectionRef</code> refers to has read beyond the current section&#39;s extent</p></div></div></section><pre><code class="language-none">ObjectFile.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.find_libraries" href="#ObjectFile.find_libraries"><code>ObjectFile.find_libraries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_libraries(oh::ObjectHandle)</code></pre><p>Return a mapping from sonames to absolute paths, containing all the sonames declared as beeing needed by the given <code>ObjectHandle</code>.  See the documentation for <code>find_library(::RPath, ::String)</code> and <code>RPath</code> for more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.find_library" href="#ObjectFile.find_library"><code>ObjectFile.find_library</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">find_library(oh::ObjectHandle, soname::String)</code></pre><p>Return the absolute path to the given <code>soname</code>, using the linker search path that the given <code>ObjectHandle</code> would use at runtime.  See the documentation for <code>find_library(::RPath, ::String)</code> for more details.</p></div></div><div><div><pre><code class="language-none">find_library(rpath::RPath, soname::String)</code></pre><p>Return the full path to a library, searching the given <code>RPath</code>, and then the default library search paths.  This method takes the given <code>soname</code> and joins it to the end of every path within the given <code>RPath</code>, returning the resultant path if it exists, returning back the original <code>soname</code> if it doesn&#39;t.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findall" href="#Base.findall"><code>Base.findall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findall(sections::Sections, name::String)</code></pre><p>Return a list of sections that match the given <code>name</code>.</p></div></div><div><div><pre><code class="language-none">findall(sections::Sections, name::String)</code></pre><p>Return a list of sections that match one of the given <code>names</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst" href="#Base.findfirst"><code>Base.findfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">findfirst(sections::Sections, name::String)</code></pre><p>Return the first section that matches the given <code>name</code>.</p></div></div><div><div><pre><code class="language-none">findfirst(sections::Sections, names::Vector{String})</code></pre><p>Return the first section that matches on of the given <code>names</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.fixed_string" href="#ObjectFile.fixed_string"><code>ObjectFile.fixed_string</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">fixed_string{T}</code></pre><p>A fixed-byte string, stored as an integer type (e.g. <code>T</code> = <code>UInt128</code>, or <code>T</code> = <code>UInt64</code>) but displayed and treated as a string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.format_string" href="#ObjectFile.format_string"><code>ObjectFile.format_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">format_string(::Type{H}) where {H &lt;: ObjectHandle}</code></pre><p>Return the string name of the given <code>ObjectHandle</code>, examples are &quot;ELF&quot;, &quot;MachO&quot;, &quot;COFF&quot;, etc...</p></div></div></section><pre><code class="language-none">ObjectFile.getindex</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.getindex_ref" href="#ObjectFile.getindex_ref"><code>ObjectFile.getindex_ref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getindex_ref(collection, offset, stride, T, ref_type, idx)</code></pre><p>Given a <code>collection</code>, such as <code>Sections</code>, <code>DynamicLinks</code>, etc... use the given <code>offset</code>, <code>stride</code>, and <code>T</code> parameters to read in and construct a <code>ref_type</code> object located at index <code>idx</code>.  Example invocation:</p><pre><code class="language-none">getindex_ref(
    sections,
    section_header_offset(oh),
    section_header_size(oh),
    section_header_type(oh),
    SectionRef,
    idx
)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle" href="#ObjectFile.handle"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">handle(sections::Sections)</code></pre><p>Return the <code>ObjectHandle</code> that this <code>Sections</code> object belongs to</p></div></div><div><div><pre><code class="language-none">handle(section::SectionRef)</code></pre><p>Return the <code>ObjectHandle</code> this <code>SectionRef</code> belongs to.  This method is <code>SectionRef</code>-only.</p></div></div><div><div><pre><code class="language-none">handle(seg::SegmentRef)</code></pre><p>Return the <code>ObjectHandle</code> this <code>SegmentRef</code> belongs to.  This method is <code>SegmentRef</code>-only.</p></div></div><div><div><pre><code class="language-none">handle(s::StrTab)</code></pre><p>Return the <code>ObjectHandle</code> this <code>StrTab</code> belongs to.</p></div></div><div><div><pre><code class="language-none">handle(sym::SymbolRef)</code></pre><p>Return the <code>ObjectHandle</code> that this <code>SymbolRef</code> belongs to.</p></div></div><div><div><pre><code class="language-none">handle(rpath::RPath)</code></pre><p>Return the handle that this <code>RPath</code> object refers to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.header" href="#ObjectFile.header"><code>ObjectFile.header</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">header(oh::ObjectHandle)</code></pre><p>Return the <code>ObjectHandle</code>&#39;s header object, whatever that may be for this particular object file format.</p></div></div></section><pre><code class="language-none">ObjectFile.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.iostream" href="#ObjectFile.iostream"><code>ObjectFile.iostream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iostream(oh::ObjectHandle)</code></pre><p>Returns the <code>IOStream</code> backing the <code>ObjectHandle</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.is64bit" href="#ObjectFile.is64bit"><code>ObjectFile.is64bit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is64bit(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a 64-bit object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isdynamic" href="#ObjectFile.isdynamic"><code>ObjectFile.isdynamic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdynamic(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> makes use of dynamic linking.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isexecutable" href="#ObjectFile.isexecutable"><code>ObjectFile.isexecutable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isexecutable(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents an executable object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isglobal" href="#ObjectFile.isglobal"><code>ObjectFile.isglobal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isglobal(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is global</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.islibrary" href="#ObjectFile.islibrary"><code>ObjectFile.islibrary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">islibrary(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a shared library</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.islocal" href="#ObjectFile.islocal"><code>ObjectFile.islocal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">islocal(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is local</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isrelocatable" href="#ObjectFile.isrelocatable"><code>ObjectFile.isrelocatable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isrelocatable(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a relocatable object file, e.g. an <code>.o</code> file as generated by <code>gcc -c</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isundef" href="#ObjectFile.isundef"><code>ObjectFile.isundef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isundef(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is undefined</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isweak" href="#ObjectFile.isweak"><code>ObjectFile.isweak</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isweak(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is weak</p></div></div></section><pre><code class="language-none">ObjectFile.iterate</code></pre><pre><code class="language-none">ObjectFile.lastindex</code></pre><pre><code class="language-none">ObjectFile.length</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.mangle_section_name" href="#ObjectFile.mangle_section_name"><code>ObjectFile.mangle_section_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mangle_section_name(oh::ObjectHandle, name::AbstractString)</code></pre><p>Turn a section <code>name</code> into the object-format specific naming convention, e.g. returning <code>&quot;.bss&quot;</code> for <code>ELF</code>/<code>COFF</code> files, and <code>&quot;__bss&quot;</code> for <code>MachO</code> files</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.mangle_symbol_name" href="#ObjectFile.mangle_symbol_name"><code>ObjectFile.mangle_symbol_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mangle_symbol_name(oh::ObjectHandle, name::AbstractString)</code></pre><p>Mangle a symbol name using the object-format specific naming convention, e.g. prefixing <code>&quot;_&quot;</code> for MachO files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.path" href="#ObjectFile.path"><code>ObjectFile.path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">path(oh::ObjectHandle)</code></pre><p>Return the absolute path to the given <code>ObjectHandle</code>, if it was a file loaded from the local disk.  If it was loaded from a general <code>IOStream</code> or in some other way such that the path is unknown or unknowable, return the empty string.</p></div></div><div><div><pre><code class="language-none">path(io::IO)</code></pre><p>Try to guess the path of an <code>IO</code> object.  If it cannot be guessed, returns the empty string.</p></div></div></section><pre><code class="language-none">ObjectFile.position</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.read" href="#Base.read"><code>Base.read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read(section::SectionRef)</code></pre><p>Read the contents of the section referred to by <code>section</code>, returning a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.read_struct" href="#ObjectFile.read_struct"><code>ObjectFile.read_struct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_struct(oh, type_func, size_func, name)</code></pre><p>Given a <code>Type</code>, (such as <code>ELFSection64</code>), <code>unpack()</code> it from the given object and return it, throwing errors as appropriate, and skipping over any excess padding bytes as determined by <code>type_func</code> and <code>size_func</code>. Example invocation:</p><p>read<em>struct(oh, symtab</em>entry<em>type, symtab</em>entry_size, &quot;Symbol Entry&quot;)</p></div></div></section><pre><code class="language-none">ObjectFile.readbytes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.readmeta" href="#ObjectFile.readmeta"><code>ObjectFile.readmeta</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readmeta(io::IO, ::ObjectHandle)</code></pre><p>Read an Object File out from an <code>IOStream</code>.  This is the first method you should call in order to manipulate object files.</p></div></div><div><div><pre><code class="language-none">readmeta(io::IO)</code></pre><p>Read an Object File out from an <code>IOStream</code>, guessing at the type of object within the stream by calling <code>readmeta(io, T)</code> for each <code>T</code> within <code>ObjTypes</code>, and returning the first that does not throw a <code>MagicMismatch</code>.</p></div></div><div><div><pre><code class="language-none">readmeta(f::Function, file::AbstractString)</code></pre><p>Do-block variant of <code>readmeta()</code>.  Use via something like:</p><pre><code class="language-none">readmeta(&quot;libfoo.so&quot;) do f
    ...
end</code></pre></div></div></section><pre><code class="language-none">ObjectFile.readuntil</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.rpaths" href="#ObjectFile.rpaths"><code>ObjectFile.rpaths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rpaths(rpath::RPath)</code></pre><p>Return the list of paths that will be searched for shared libraries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_address" href="#ObjectFile.section_address"><code>ObjectFile.section_address</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_address(section::Section)</code></pre><p>The address of the section in virtual memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_offset" href="#ObjectFile.section_header_offset"><code>ObjectFile.section_header_offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_header_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the sections start within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_size" href="#ObjectFile.section_header_size"><code>ObjectFile.section_header_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_header_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a section header (used for reading in the sections header when trying to load a <code>Section</code> object or iterating over a <code>Sections</code> object)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_type" href="#ObjectFile.section_header_type"><code>ObjectFile.section_header_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_header_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a section header (used for reading in the sections header when trying to load a <code>Section</code> object or iterating over a <code>Sections</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSection64</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_name" href="#ObjectFile.section_name"><code>ObjectFile.section_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_name(section::Section)</code></pre><p>Return the name of the given section as a string.  In order to return a true name, it is necessary to perform a lookup within the object&#39;s string table, which cannot be done using just a <code>Section</code> object; use a <code>SectionRef</code> object instead if you need that.  For sanity sake, this method will return a string, but the contents of the string may be something like the offset within the string table pointing to this <code>Section</code>&#39;s name, e.g. &quot;@strtab.123&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_number" href="#ObjectFile.section_number"><code>ObjectFile.section_number</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_number(section::SectionRef)</code></pre><p>The index of the given section within the section header table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_offset" href="#ObjectFile.section_offset"><code>ObjectFile.section_offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_offset(section::Section)</code></pre><p>The offset of the section in the file, in bytes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_size" href="#ObjectFile.section_size"><code>ObjectFile.section_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">section_size(section::Section)</code></pre><p>The size of the actual data contained in the section. This should exclude any padding mandated by the file format e.g. due to alignment rules</p></div></div></section><pre><code class="language-none">ObjectFile.section_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seek" href="#Base.seek"><code>Base.seek</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seek(section::SectionRef, offset)</code></pre><p>Seek to <code>offset</code> relative to <code>section</code> in the <code>ObjectHandle</code> that this <code>SectionRef</code> refers to</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seekstart" href="#Base.seekstart"><code>Base.seekstart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">seekstart(section::SectionRef)</code></pre><p>Seek to the beginning of <code>section</code> in the <code>ObjectHandle</code> it was loaded from.</p></div></div></section><pre><code class="language-none">ObjectFile.segment_address</code></pre><pre><code class="language-none">ObjectFile.segment_file_size</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_offset" href="#ObjectFile.segment_header_offset"><code>ObjectFile.segment_header_offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segment_header_offset(oh::ELFHandle)</code></pre><p>Return the offset of the segment header table within the given ELF object.</p></div></div><div><div><pre><code class="language-none">segment_header_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the segments start within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_size" href="#ObjectFile.segment_header_size"><code>ObjectFile.segment_header_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segment_header_offset(oh::ELFHandle)</code></pre><p>Return the size of a segment header within the given ELF object.</p></div></div><div><div><pre><code class="language-none">segment_header_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a segment header (used for reading in the segments header when trying to load a <code>Segment</code> object or iterating over a <code>Segments</code> object)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_type" href="#ObjectFile.segment_header_type"><code>ObjectFile.segment_header_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segment_header_type(oh::ELFHandle)</code></pre><p>Return the type of a segment header within the given ELF object.  E.g. within a 64-bit ELF object, this will return <code>ELFSegment64</code>.</p></div></div><div><div><pre><code class="language-none">segment_header_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a segment header (used for reading in the segments header when trying to load a <code>Segment</code> object or iterating over a <code>Segments</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSegment64</code></p></div></div></section><pre><code class="language-none">ObjectFile.segment_memory_size</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_name" href="#ObjectFile.segment_name"><code>ObjectFile.segment_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segment_name(seg::SegmentRef)</code></pre><p>The name of the given <code>Segment</code>, returned as a string.  This method often performs some kind of lookup within the string table of the object to get the full name of the segment.</p></div></div></section><pre><code class="language-none">ObjectFile.segment_num_sections</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_number" href="#ObjectFile.segment_number"><code>ObjectFile.segment_number</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">segment_number(seg::SegmentRef)</code></pre><p>Return the index of the referred segment.</p></div></div></section><pre><code class="language-none">ObjectFile.segment_offset</code></pre><pre><code class="language-none">ObjectFile.segment_type</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.show_collection" href="#ObjectFile.show_collection"><code>ObjectFile.show_collection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_collection(io, collection, ::Type{H&lt;:ObjectHandle})</code></pre><p>Given a collection-like object, (<code>Symbols</code>, <code>DynamicLinks</code>, ``)</p></div></div></section><pre><code class="language-none">ObjectFile.skip</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.startaddr" href="#ObjectFile.startaddr"><code>ObjectFile.startaddr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">startaddr(oh::ObjectHandle)</code></pre><p>Returns the offset within the underlying <code>IOStream</code> at which this <code>ObjectHandle</code> is located.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.strtab_lookup" href="#ObjectFile.strtab_lookup"><code>ObjectFile.strtab_lookup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strtab_lookup(s::StrTab, index)</code></pre><p>Reads a string from the given <code>StrTab</code> at <code>index</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_name" href="#ObjectFile.symbol_name"><code>ObjectFile.symbol_name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symbol_name(sym::SymtabEntry)</code></pre><p>Return the name of the given section as a string.  In order to return a true name, it is necessary to perform a lookup within the object&#39;s string table, which cannot be done using just a <code>SymtabEntry</code> object; use a <code>SymbolRef</code> object instead if you need that.  For sanity sake, this method will return a string, but the contents of the string may be something like the offset within the string table pointing to this <code>SymtabEntry</code>&#39;s name, e.g. &quot;@strtab.123&quot;</p></div></div><div><div><pre><code class="language-none">symbol_name(sym::SymbolRef)</code></pre><p>Return the name of the given symbol as a string.  This method often performs some kind of lookup within the string table of the object to get the full name of the symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_number" href="#ObjectFile.symbol_number"><code>ObjectFile.symbol_number</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symbol_number(sym::SymbolRef)</code></pre><p>Return the number (index) of the given symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_value" href="#ObjectFile.symbol_value"><code>ObjectFile.symbol_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symbol_value(sym::SymtabEntry)</code></pre><p>Return the value of the given symbol</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_offset" href="#ObjectFile.symtab_entry_offset"><code>ObjectFile.symtab_entry_offset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symtab_entry_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the symbol table starts within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_size" href="#ObjectFile.symtab_entry_size"><code>ObjectFile.symtab_entry_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symtab_entry_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a symbol table entry (used for reading in the symbol table when trying to load a <code>SymtabEntry</code> object or iterating over a <code>Symbols</code> object).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_type" href="#ObjectFile.symtab_entry_type"><code>ObjectFile.symtab_entry_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symtab_entry_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a symbol table entry (used for reading in the symbol table when trying to load a <code>SymtabEntry</code> object or iterating over a <code>Symbols</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSymtabEntry64</code></p></div></div></section><pre><code class="language-none">ObjectFile.write</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
