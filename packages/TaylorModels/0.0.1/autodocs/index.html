<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · TaylorModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">TaylorModels...</code></pre><pre><code class="language-none">TaylorModels.@I_str</code></pre><pre><code class="language-none">TaylorModels.@biginterval</code></pre><pre><code class="language-none">TaylorModels.@decorated</code></pre><pre><code class="language-none">TaylorModels.@floatinterval</code></pre><pre><code class="language-none">TaylorModels.@format</code></pre><pre><code class="language-none">TaylorModels.@interval</code></pre><pre><code class="language-none">TaylorModels.@make_interval</code></pre><pre><code class="language-none">TaylorModels.AbstractInterval</code></pre><pre><code class="language-none">TaylorModels.AbstractSeries</code></pre><pre><code class="language-none">TaylorModels.DecoratedInterval</code></pre><pre><code class="language-none">TaylorModels.HomogeneousPolynomial</code></pre><pre><code class="language-none">TaylorModels.Interval</code></pre><pre><code class="language-none">TaylorModels.IntervalArithmetic</code></pre><pre><code class="language-none">TaylorModels.IntervalBox</code></pre><pre><code class="language-none">TaylorModels.NumberNotSeries</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.RTaylorModel1" href="#TaylorModels.RTaylorModel1"><code>TaylorModels.RTaylorModel1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RTaylorModel1{T,S}</code></pre><p>Taylor model in 1 variable, providing a rigurous polynomial approximation (around <code>x_0</code>) and a relative remainder <code>\delta</code> for a function <code>f(x)</code> in one variable, valid in the interval <code>I</code>. Corresponds to definition 2.3.2 of Mioara Joldes&#39; thesis.</p><p>Fields:</p><ul><li><code>pol</code>: polynomial approximation, represented as <code>TaylorSeries.Taylor1</code></li><li><code>rem</code>: the interval bound</li><li><code>x0</code>: expansion point</li><li><code>I</code>: interval over which the Taylor model is defined / valid</li></ul><p>The approximation <code>f(x) = \sum_i p_i (x - x_0)^i + \delta (x - x_0)^{n+1}</code> is satisfied for all <code>x\in I</code>; <code>n</code> is the order (degree) of the polynomial <code>p(x)</code>.</p></div></section><pre><code class="language-none">TaylorModels.Region</code></pre><pre><code class="language-none">TaylorModels.RoundTiesToAway</code></pre><pre><code class="language-none">TaylorModels.RoundTiesToEven</code></pre><pre><code class="language-none">TaylorModels.Taylor1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.TaylorModel1" href="#TaylorModels.TaylorModel1"><code>TaylorModels.TaylorModel1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TaylorModel1{T,S}</code></pre><p>Taylor model in 1 variable, providing a rigurous polynomial approximation (around <code>x_0</code>) and an absolute remainder <code>\Delta</code> for a function <code>f(x)</code> in one variable, valid in the interval <code>I</code>. Corresponds to definition 2.1.3 of Mioara Joldes&#39; thesis.</p><p>Fields:</p><ul><li><code>pol</code>: polynomial approximation, represented as <code>TaylorSeries.Taylor1</code></li><li><code>rem</code>: the interval bound</li><li><code>x0</code>: expansion point</li><li><code>I</code>: interval over which the Taylor model is defined / valid</li></ul><p>The approximation <code>f(x) = \sum_{i=0}^n p_i (x - x_0)^i + \Delta</code> is satisfied for all <code>x\in I</code> (<code>0\in\Delta</code>); <code>n</code> is the order (degree) of the polynomial <code>p(x)</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.TaylorModelN" href="#TaylorModels.TaylorModelN"><code>TaylorModels.TaylorModelN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TaylorModelN{N,T,S}</code></pre><p>Taylor Models with absolute remainder for <code>N</code> independent variables.</p></div></div></section><pre><code class="language-none">TaylorModels.TaylorModels</code></pre><pre><code class="language-none">TaylorModels.TaylorN</code></pre><pre><code class="language-none">TaylorModels.TaylorSeries</code></pre><pre><code class="language-none">TaylorModels._evaluate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels._rpaar" href="#TaylorModels._rpaar"><code>TaylorModels._rpaar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>_rpaar(f::Function, x0::Interval, I::Interval, _order::Integer)</p><p>Rigurous polynomial approximation (RPA) with absolute remainder for the function <code>f</code> on the interval <code>I</code>,  using a Taylor expansion around the <em>interval</em> <code>x0</code> of order <code>_order</code>. The bound is computed by <code>bound_absrem</code>(@ref) exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels._rparr" href="#TaylorModels._rparr"><code>TaylorModels._rparr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>_rparr(f::Function, x0::Interval, I::Interval, _order::Integer)</p><p>Rigurous polynomial approximation (RPA) with relative remainder for the function <code>f</code> on the interval <code>I</code>,  using a Taylor expansion around the <em>interval</em> <code>x0</code> of order <code>_order</code>. The bound is computed by <code>bound_relrem</code>(@ref) exploiting monotonicity if possible, otherwise, it uses the Lagrange coefficient.</p></div></div></section><pre><code class="language-none">TaylorModels.basediv</code></pre><pre><code class="language-none">TaylorModels.bisect</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_absrem" href="#TaylorModels.bound_absrem"><code>TaylorModels.bound_absrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>bound_absrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)</p><p>Bound the absolute remainder of the polynomial approximation of <code>f</code> given by the Taylor polynomial <code>polf</code> around <code>x0</code> on the interval <code>I</code>. It requires the interval extension <code>polfI</code> of the polynomial that approximates <code>f</code> for the whole interval <code>I</code>, in order to compute the Lagrange remainder.</p><p>If <code>polfI[end]</code> has a definite sign, then it is monotonic in the intervals [I.lo, x0] and [x0.hi, I.hi], which is exploited; otherwise, it is used to compute the Lagrange remainder.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_relrem" href="#TaylorModels.bound_relrem"><code>TaylorModels.bound_relrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>bound_relrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)</p><p>Bound the relative remainder of the polynomial approximation of <code>f</code> given by the Taylor polynomial <code>polf</code> around <code>x0</code> on the interval <code>I</code>. It requires an the interval extension <code>polfI</code> of a polynomial that approximates <code>f</code> for the whole interval <code>I</code>, in order to compute the Lagrange remainder.</p><p>If <code>polfI[end]</code> has a definite sign, then it is monotonic in the interval <code>I</code>, which is exploited; otherwise, the last coefficients bounds the relative remainder.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_taylor1" href="#TaylorModels.bound_taylor1"><code>TaylorModels.bound_taylor1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bound_taylor1(fT::Taylor1, I::Interval)</code></pre><p>Compute a <em>tight</em> polynomial bound for the Taylor polynomial <code>fT</code> in the interval <code>I</code>.</p><p>Note: Algorithm 2.1.1 corresponds to <code>evaluate(fT, I)</code> or simply <code>fT(I). This function uses the roots of the derivative of</code>ft` to obtain a tighter bound.</p></div></div><div><div><pre><code class="language-none">bound_taylor1(fT::Taylor1, fTd::Taylor1, I::Interval)</code></pre><p>Compute a <em>tight</em> polynomial bound for the Taylor polynomial <code>fT</code> in the interval <code>I</code>, considering whether its derivative <code>ftd</code> has a definite sign.</p></div></div></section><pre><code class="language-none">TaylorModels.cancelminus</code></pre><pre><code class="language-none">TaylorModels.cancelplus</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.check_existence" href="#TaylorModels.check_existence"><code>TaylorModels.check_existence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_existence(f, tm::T, xm::T, x0::Interval, x_test::Interval)</code></pre><p>Checks that the range of one iterate of the Picard-Lindelöf operator is contained in the a-priori interval <code>x_test</code> (of the dependent variable) that bounds the solution of the ODE defined by <code>f</code>. This function returns an interval of the independent variable where the a-priori solution is warranted to exist; see <a href="#TaylorModels.shrink_for_existance"><code>shrink_for_existance</code></a>. Here, <code>tm</code> and <code>xm</code> are Taylor Models (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) defined for the independent and dependent variables, and <code>x0</code> is the initial condition.</p></div></div></section><pre><code class="language-none">TaylorModels.com</code></pre><pre><code class="language-none">TaylorModels.constant_term</code></pre><pre><code class="language-none">TaylorModels.contains_zero</code></pre><pre><code class="language-none">TaylorModels.dac</code></pre><pre><code class="language-none">TaylorModels.decoration</code></pre><pre><code class="language-none">TaylorModels.def</code></pre><pre><code class="language-none">TaylorModels.derivative</code></pre><pre><code class="language-none">TaylorModels.diam</code></pre><pre><code class="language-none">TaylorModels.differentiate</code></pre><pre><code class="language-none">TaylorModels.displayBigO</code></pre><pre><code class="language-none">TaylorModels.displaymode</code></pre><pre><code class="language-none">TaylorModels.dist</code></pre><pre><code class="language-none">TaylorModels.dot</code></pre><pre><code class="language-none">TaylorModels.emptyinterval</code></pre><pre><code class="language-none">TaylorModels.entireinterval</code></pre><pre><code class="language-none">TaylorModels.eps</code></pre><pre><code class="language-none">TaylorModels.eval</code></pre><pre><code class="language-none">TaylorModels.evaluate</code></pre><pre><code class="language-none">TaylorModels.evaluate!</code></pre><pre><code class="language-none">TaylorModels.extended_div</code></pre><pre><code class="language-none">TaylorModels.fnlist</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.fp_rpa" href="#TaylorModels.fp_rpa"><code>TaylorModels.fp_rpa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fp_rpa(tm::TaylorModel1{Interval{T},T})
fp_rpa(tm::RTaylorModel1{Interval{T},T})</code></pre><p>Convert a <code>tm</code> TaylorModel to a TaylorModel whose polynomial coefficients of type <code>T&lt;:Real</code>. The accumulated error is added to the remainder. The mid point of the expansion interval is preferentially rounded down if it is not an exactly representable value.</p></div></div></section><pre><code class="language-none">TaylorModels.get_numvars</code></pre><pre><code class="language-none">TaylorModels.get_order</code></pre><pre><code class="language-none">TaylorModels.get_variable_names</code></pre><pre><code class="language-none">TaylorModels.get_variable_symbols</code></pre><pre><code class="language-none">TaylorModels.get_variables</code></pre><pre><code class="language-none">TaylorModels.getcoeff</code></pre><pre><code class="language-none">TaylorModels.hull</code></pre><pre><code class="language-none">TaylorModels.ill</code></pre><pre><code class="language-none">TaylorModels.include</code></pre><pre><code class="language-none">TaylorModels.inf</code></pre><pre><code class="language-none">TaylorModels.infimum</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.integrate" href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrate(a::T, c0::Interval)</code></pre><p>Integrates the one-variable Taylor Model (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) with respect to the independent variable; <code>c0</code> is the interval representing the integration constant; if omitted it is considered as the zero interval.</p></div></div></section><pre><code class="language-none">TaylorModels.interval</code></pre><pre><code class="language-none">TaylorModels.interval_from_midpoint_radius</code></pre><pre><code class="language-none">TaylorModels.interval_part</code></pre><pre><code class="language-none">TaylorModels.inverse</code></pre><pre><code class="language-none">TaylorModels.isatomic</code></pre><pre><code class="language-none">TaylorModels.iscommon</code></pre><pre><code class="language-none">TaylorModels.isdisjoint</code></pre><pre><code class="language-none">TaylorModels.isempty</code></pre><pre><code class="language-none">TaylorModels.isentire</code></pre><pre><code class="language-none">TaylorModels.isinterior</code></pre><pre><code class="language-none">TaylorModels.isnai</code></pre><pre><code class="language-none">TaylorModels.isthin</code></pre><pre><code class="language-none">TaylorModels.isunbounded</code></pre><pre><code class="language-none">TaylorModels.mag</code></pre><pre><code class="language-none">TaylorModels.mid</code></pre><pre><code class="language-none">TaylorModels.midpoint_radius</code></pre><pre><code class="language-none">TaylorModels.mig</code></pre><pre><code class="language-none">TaylorModels.nai</code></pre><pre><code class="language-none">TaylorModels.parameters</code></pre><pre><code class="language-none">TaylorModels.pi_interval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.picard_lindelöf" href="#TaylorModels.picard_lindelöf"><code>TaylorModels.picard_lindelöf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">picard_lindelöf(f, tm::T, xm::T, x0::Interval)
𝒫(f, tm::T, xm::T, x0::Interval)</code></pre><p>Returns the application of the Picard-Lindelöf operator associated to the ODE <span>$\dot{x} = f(t,x)$</span>, with initial condition <code>x0</code>. Here, <code>tm</code> and <code>xm</code> are (one-variable) Taylor Models (<code>TaylorModel1</code> or <code>RTaylorModel1</code>).</p><p>𝒫 is an abbreviation of this operator, which is obtained as <code>\mscrP&lt;TAB&gt;</code>.)</p></div></div></section><pre><code class="language-none">TaylorModels.polynomial</code></pre><pre><code class="language-none">TaylorModels.pow</code></pre><pre><code class="language-none">TaylorModels.precedes</code></pre><pre><code class="language-none">TaylorModels.radius</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.reducetoorder" href="#TaylorModels.reducetoorder"><code>TaylorModels.reducetoorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reducetoorder(a::RTaylorModel1, m::Integer)</code></pre><p>From <code>a::RTaylorModel1</code>, it returns a RTaylorModel1 of order <code>m</code>.</p></div></div></section><pre><code class="language-none">TaylorModels.remainder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.rpa" href="#TaylorModels.rpa"><code>TaylorModels.rpa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rpa(g::Function, tmf::TaylorModel1)    rpa(g::Function, tmf::TaylorModelN)</p><p>Rigurous polynomial approximation (RPA) for the function <code>g</code> using the Taylor Model with absolute remainder <code>tmf</code>. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div><div><div><p>rpa(g::Function, tmf::RTaylorModel1)</p><p>Rigurous polynomial approximation (RPA) for the function <code>g</code> using the Taylor Model with absolute remainder <code>tmf</code>. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div></section><pre><code class="language-none">TaylorModels.set_variables</code></pre><pre><code class="language-none">TaylorModels.setformat</code></pre><pre><code class="language-none">TaylorModels.setindex</code></pre><pre><code class="language-none">TaylorModels.show_monomials</code></pre><pre><code class="language-none">TaylorModels.show_params_TaylorN</code></pre><pre><code class="language-none">TaylorModels.showfull</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.shrink_for_existance" href="#TaylorModels.shrink_for_existance"><code>TaylorModels.shrink_for_existance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shrink_for_existance(xm::T, t_interval, x_test, max_steps::Integer=20)</code></pre><p>Shrinks the a-priori independent-variable interval <code>t_interval</code> so the range of <code>xm</code>, the Taylor Model (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) associated with the dependent variable, is contained in the a-priori interval <code>x_test</code>. The method used is some sort of bisection. If no independent-variable interval is found within <code>max_steps</code>, an empty interval is returned.</p></div></div></section><pre><code class="language-none">TaylorModels.strictprecedes</code></pre><pre><code class="language-none">TaylorModels.sup</code></pre><pre><code class="language-none">TaylorModels.supremum</code></pre><pre><code class="language-none">TaylorModels.taylor_expand</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.tight_remainder" href="#TaylorModels.tight_remainder"><code>TaylorModels.tight_remainder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tight_remainder(f, tm::T, xm::T, x0::Interval, max_steps::Integer=20)</code></pre><p>Returns a Taylor Model for the dependent variable, with a tighter remainder, which is obtained after successive iteration of the Picard-Lindelöf. If the remainder is not tighter (and identity with the former iterate is not obtained) a Taylor Model with an empty interval is returned.</p></div></div></section><pre><code class="language-none">TaylorModels.tmdata</code></pre><pre><code class="language-none">TaylorModels.trv</code></pre><pre><code class="language-none">TaylorModels.tupleTMs</code></pre><pre><code class="language-none">TaylorModels.update!</code></pre><pre><code class="language-none">TaylorModels.use_show_default</code></pre><pre><code class="language-none">TaylorModels.widen</code></pre><pre><code class="language-none">TaylorModels.±</code></pre><pre><code class="language-none">TaylorModels.×</code></pre><pre><code class="language-none">TaylorModels.α_mid</code></pre><pre><code class="language-none">TaylorModels.∅</code></pre><pre><code class="language-none">TaylorModels.∇</code></pre><pre><code class="language-none">TaylorModels.∞</code></pre><pre><code class="language-none">TaylorModels.≺</code></pre><pre><code class="language-none">TaylorModels.⊂</code></pre><pre><code class="language-none">TaylorModels.⊃</code></pre><pre><code class="language-none">TaylorModels.⊇</code></pre><pre><code class="language-none">TaylorModels.⪽</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.𝒫" href="#TaylorModels.𝒫"><code>TaylorModels.𝒫</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">picard_lindelöf(f, tm::T, xm::T, x0::Interval)
𝒫(f, tm::T, xm::T, x0::Interval)</code></pre><p>Returns the application of the Picard-Lindelöf operator associated to the ODE <span>$\dot{x} = f(t,x)$</span>, with initial condition <code>x0</code>. Here, <code>tm</code> and <code>xm</code> are (one-variable) Taylor Models (<code>TaylorModel1</code> or <code>RTaylorModel1</code>).</p><p>𝒫 is an abbreviation of this operator, which is obtained as <code>\mscrP&lt;TAB&gt;</code>.)</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
