<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · StaticArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StaticArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Guide-1">Guide</a></li><li><a class="toctext" href="#Docstrings-1">Docstrings</a></li></ul></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Guide-1" href="#Guide-1">Guide</a></h2><h3><a class="nav-anchor" id="SVector-1" href="#SVector-1"><code>SVector</code></a></h3><p>The simplest static array is the type <code>SVector{N,T}</code>, which provides an immutable vector of fixed length <code>N</code> and type <code>T</code>.</p><p><code>SVector</code> defines a series of convenience constructors, so you can just type e.g. <code>SVector(1,2,3)</code>. Alternatively there is an intelligent <code>@SVector</code> macro where you can use native Julia array literals syntax, comprehensions, and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions, such as <code>@SVector [1,2,3]</code>, <code>@SVector Float64[1,2,3]</code>, <code>@SVector [f(i) for i = 1:10]</code>, <code>@SVector zeros(3)</code>, <code>@SVector randn(Float32, 4)</code>, etc (Note: the range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables, but is not limited to just simple ranges. Extending this to (hopefully statically known by type-inference) local-scope variables is hoped for the future. The <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions do not have this limitation.)</p><h3><a class="nav-anchor" id="SMatrix-1" href="#SMatrix-1"><code>SMatrix</code></a></h3><p>Statically sized <code>N×M</code> matrices are provided by <code>SMatrix{N,M,T,L}</code>.</p><p>Here <code>L</code> is the <code>length</code> of the matrix, such that <code>N × M = L</code>. However, convenience constructors are provided, so that <code>L</code>, <code>T</code> and even <code>M</code> are unnecessary. At minimum, you can type <code>SMatrix{2}(1,2,3,4)</code> to create a 2×2 matrix (the total number of elements must divide evenly into <code>N</code>). A convenience macro <code>@SMatrix [1 2; 3 4]</code> is provided (which also accepts comprehensions and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code>, <code>randn()</code> and <code>eye()</code> functions).</p><h3><a class="nav-anchor" id="SArray-1" href="#SArray-1"><code>SArray</code></a></h3><p>A container with arbitrarily many dimensions is defined as <code>struct SArray{Size,T,N,L} &lt;: StaticArray{Size,T,N}</code>, where <code>Size = Tuple{S1, S2, ...}</code> is a tuple of <code>Int</code>s. You can easily construct one with the <code>@SArray</code> macro, supporting all the features of <code>@SVector</code> and <code>@SMatrix</code> (but with arbitrary dimension).</p><p>The main reason <code>SVector</code> and <code>SMatrix</code> are defined is to make it easier to define the types without the extra tuple characters (compare <code>SVector{3}</code> to <code>SArray{Tuple{3}}</code>).</p><h3><a class="nav-anchor" id="Scalar-1" href="#Scalar-1"><code>Scalar</code></a></h3><p>Sometimes you want to broadcast an operation, but not over one of your inputs. A classic example is attempting to displace a collection of vectors by the same vector. We can now do this with the <code>Scalar</code> type:</p><pre><code class="language-julia">[[1,2,3], [4,5,6]] .+ Scalar([1,0,-1]) # [[2,2,2], [5,5,5]]</code></pre><p><code>Scalar</code> is simply an implementation of an immutable, 0-dimensional <code>StaticArray</code>.</p><h3><a class="nav-anchor" id="The-Size-trait-1" href="#The-Size-trait-1">The <code>Size</code> trait</a></h3><p>The size of a statically sized array is a static parameter associated with the type of the array. The <code>Size</code> trait is provided as an abstract representation of the dimensions of a static array. An array <code>sa::SA</code> of size <code>(dims...)</code> is associated with <code>Size{(dims...)}()</code>. The following are equivalent (<code>@pure</code>) constructors:</p><pre><code class="language-julia">Size{(dims...,)}()
Size(dims...)
Size(sa::StaticArray)
Size(SA) # SA &lt;: StaticArray</code></pre><p>This is extremely useful for (a) performing dispatch depending on the size of an array, and (b) passing array dimensions that the compiler can reason about.</p><p>An example of size-based dispatch for the determinant of a matrix would be:</p><pre><code class="language-julia">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre><p>Examples of using <code>Size</code> as a compile-time constant include</p><pre><code class="language-julia">reshape(svector, Size(2,2))  # Convert SVector{4} to SMatrix{2,2}
Size(3,3)(rand(3,3))         # Construct a random 3×3 SizedArray (see below)</code></pre><h3><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h3><p>Statically sized indexing can be realized by indexing each dimension by a scalar, a <code>StaticVector</code> or <code>:</code>. Indexing in this way will result a statically sized array (even if the input was dynamically sized, in the case of <code>StaticVector</code> indices) of the closest type (as defined by <code>similar_type</code>).</p><p>Conversely, indexing a statically sized array with a dynamically sized index (such as a <code>Vector{Integer}</code> or <code>UnitRange{Integer}</code>) will result in a standard (dynamically sized) <code>Array</code>.</p><h3><a class="nav-anchor" id="similar_type()-1" href="#similar_type()-1"><code>similar_type()</code></a></h3><p>Since immutable arrays need to be constructed &quot;all-at-once&quot;, we need a way of obtaining an appropriate constructor if the element type or dimensions of the output array differs from the input. To this end, <code>similar_type</code> is introduced, behaving just like <code>similar</code>, except that it returns a type. Relevant methods are:</p><pre><code class="language-julia">similar_type(::Type{A}) where {A &lt;: StaticArray} # defaults to A
similar_type(::Type{A}, ::Type{ElType}) where {A &lt;: StaticArray, ElType} # Change element type
similar_type(::Type{A}, size::Size) where {A &lt;: AbstractArray} # Change size
similar_type(::Type{A}, ::Type{ElType}, size::Size) where {A &lt;: AbstractArray, ElType} # Change both</code></pre><p>These setting will affect everything, from indexing, to matrix multiplication and <code>broadcast</code>. Users wanting introduce a new array type should <em>only</em> overload the last method in the above.</p><p>Use of <code>similar</code> will fall back to a mutable container, such as a <code>MVector</code> (see below), and it requires use of the <code>Size</code> trait if you wish to set a new static size (or else a dynamically sized <code>Array</code> will be generated when specifying the size as plain integers).</p><h3><a class="nav-anchor" id="Mutable-arrays:-MVector,-MMatrix-and-MArray-1" href="#Mutable-arrays:-MVector,-MMatrix-and-MArray-1">Mutable arrays: <code>MVector</code>, <code>MMatrix</code> and <code>MArray</code></a></h3><p>These statically sized arrays are identical to the above, but are defined as <code>mutable struct</code>s, instead of immutable <code>struct</code>s. Because they are mutable, they allow <code>setindex!</code> to be defined (achieved through pointer manipulation, into a tuple).</p><p>As a consequence of Julia&#39;s internal implementation, these mutable containers live on the heap, not the stack. Their memory must be allocated and tracked by the garbage collector. Nevertheless, there is opportunity for speed improvements relative to <code>Base.Array</code> because (a) there may be one less pointer indirection, (b) their (typically small) static size allows for additional loop unrolling and inlining, and consequentially (c) their mutating methods like <code>map!</code> are extremely fast. Benchmarking shows that operations such as addition and matrix multiplication are faster for <code>MMatrix</code> than <code>Matrix</code>, at least for sizes up to 14 × 14, though keep in mind that optimal speed will be obtained by using mutating functions (like <code>map!</code> or <code>A_mul_B!</code>) where possible, rather than reallocating new memory.</p><p>Mutable static arrays also happen to be very useful containers that can be constructed on the heap (with the ability to use <code>setindex!</code>, etc), and later copied as e.g. an immutable <code>SVector</code> to the stack for use, or into e.g. an <code>Array{SVector}</code> for storage.</p><p>Convenience macros <code>@MVector</code>, <code>@MMatrix</code> and <code>@MArray</code> are provided.</p><h3><a class="nav-anchor" id="SizedArray:-a-decorate-size-wrapper-for-Array-1" href="#SizedArray:-a-decorate-size-wrapper-for-Array-1"><code>SizedArray</code>: a decorate size wrapper for <code>Array</code></a></h3><p>Another convenient mutable type is the <code>SizedArray</code>, which is just a wrapper-type about a standard Julia <code>Array</code> which declares its knwon size. For example, if we knew that <code>a</code> was a 2×2 <code>Matrix</code>, then we can type <code>sa = SizedArray{Tuple{2,2}}(a)</code> to construct a new object which knows the type (the size will be verified automatically). A more convenient syntax for obtaining a <code>SizedArray</code> is by calling a <code>Size</code> object, e.g. <code>sa = Size(2,2)(a)</code>.</p><p>Then, methods on <code>sa</code> will use the specialized code provided by the <em>StaticArrays</em> pacakge, which in many cases will be much, much faster. For example, calling <code>eig(sa)</code> will be signficantly faster than <code>eig(a)</code> since it will perform a specialized 2×2 matrix diagonalization rather than a general algorithm provided by Julia and <em>LAPACK</em>.</p><p>In some cases it will make more sense to use a <code>SizedArray</code>, and in other cases an <code>MArray</code> might be preferable.</p><h3><a class="nav-anchor" id="FieldVector-1" href="#FieldVector-1"><code>FieldVector</code></a></h3><p>Sometimes it might be useful to imbue your own types, having multiple fields, with vector-like properties. <em>StaticArrays</em> can take care of this for you by allowing you to inherit from <code>FieldVector{N, T}</code>. For example, consider:</p><pre><code class="language-julia">struct Point3D &lt;: FieldVector{3, Float64}
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>With this type, users can easily access fields to <code>p = Point3D(x,y,z)</code> using <code>p.x</code>, <code>p.y</code> or <code>p.z</code>, or alternatively via <code>p[1]</code>, <code>p[2]</code>, or <code>p[3]</code>. You may even permute the coordinates with <code>p[SVector(3,2,1)]</code>). Furthermore, <code>Point3D</code> is a complete <code>AbstractVector</code> implementation where you can add, subtract or scale vectors, multiply them by matrices, etc.</p><p>It is also worth noting that <code>FieldVector</code>s may be mutable or immutable, and that <code>setindex!</code> is defined for use on mutable types. For immutable containers, you may want to define a method for <code>similar_type</code> so that operations leave the type constant (otherwise they may fall back to <code>SVector</code>). For mutable containers, you may want to define a default constructor (no inputs) and an appropriate method for <code>similar</code>,</p><h3><a class="nav-anchor" id="Implementing-your-own-types-1" href="#Implementing-your-own-types-1">Implementing your own types</a></h3><p>You can easily create your own <code>StaticArray</code> type, by defining linear <code>getindex</code> (and optionally <code>setindex!</code> for mutable types - see <code>setindex(::MArray, val, i)</code> in <em>MArray.jl</em> for an example of how to achieve this through pointer manipulation). Your type should define a constructor that takes a tuple of the data (and mutable containers may want to define a default constructor).</p><p>Other useful functions to overload may be <code>similar_type</code> (and <code>similar</code> for mutable containers).</p><h3><a class="nav-anchor" id="Conversions-from-Array-1" href="#Conversions-from-Array-1">Conversions from <code>Array</code></a></h3><p>In order to convert from a dynamically sized <code>AbstractArray</code> to one of the statically sized array types, you must specify the size explicitly.  For example,</p><pre><code class="language-julia">v = [1,2]

m = [1 2;
     3 4]

# ... a lot of intervening code

sv = SVector{2}(v)
sm = SMatrix{2,2}(m)
sa = SArray{(2,2)}(m)

sized_v = Size(2)(v)     # SizedArray{(2,)}(v)
sized_m = Size(2,2)(m)   # SizedArray{(2,2)}(m)</code></pre><p>We have avoided adding <code>SVector(v::AbstractVector)</code> as a valid constructor to help users avoid the type instability (and potential performance disaster, if used without care) of this innocuous looking expression. However, the simplest way to deal with an <code>Array</code> is to create a <code>SizedArray</code> by calling a <code>Size</code> instance, e.g. <code>Size(2)(v)</code>.</p><h3><a class="nav-anchor" id="Arrays-of-static-arrays-1" href="#Arrays-of-static-arrays-1">Arrays of static arrays</a></h3><p>Storing a large number of static arrays is convenient as an array of static arrays. For example, a collection of positions (3D coordinates - <code>SVector{3,Float64}</code>) could be represented as a <code>Vector{SVector{3,Float64}}</code>.</p><p>Another common way of storing the same data is as a 3×<code>N</code> <code>Matrix{Float64}</code>. Rather conveniently, such types have <em>exactly</em> the same binary layout in memory, and therefore we can use <code>reinterpret</code> to convert between the two formats</p><pre><code class="language-julia">function svectors(x::Matrix{Float64})
    @assert size(x,1) == 3
    reinterpret(SVector{3,Float64}, x, (size(x,2),))
end</code></pre><p>Such a conversion does not copy the data, rather it refers to the <em>same</em> memory referenced by two different Julia <code>Array</code>s. Arguably, a <code>Vector</code> of <code>SVector</code>s is preferable to a <code>Matrix</code> because (a) it provides a better abstraction of the objects contained in the array and (b) it allows the fast <em>StaticArrays</em> methods to act on elements.</p><h3><a class="nav-anchor" id="Working-with-mutable-and-immutable-arrays-1" href="#Working-with-mutable-and-immutable-arrays-1">Working with mutable and immutable arrays</a></h3><p>Generally, it is performant to rebind an <em>immutable</em> array, such as</p><pre><code class="language-julia">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(SVector{3,Float64})
    for pos ∈ positions
        x = x + pos
    end
    return x / length(positions)
end</code></pre><p>so long as the <code>Type</code> of the rebound variable (<code>x</code>, above) does not change.</p><p>On the other hand, the above code for mutable containers like <code>Array</code>, <code>MArray</code> or <code>SizedArray</code> is <em>not</em> very efficient. Mutable containers in Julia 0.5 must be <em>allocated</em> and later <em>garbage collected</em>, and for small, fixed-size arrays this can be a leading contribution to the cost. In the above code, a new array will be instantiated and allocated on each iteration of the loop. In order to avoid unnecessary allocations, it is best to allocate an array only once and apply mutating functions to it:</p><pre><code class="language-julia">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(MVector{3,Float64})
    for pos ∈ positions
        # Take advantage of Julia 0.5 broadcast fusion
        x .= (+).(x, pos) # same as broadcast!(+, x, x, positions[i])
    end
    x .= (/).(x, length(positions))
    return x
end</code></pre><p>Keep in mind that Julia 0.5 does not fuse calls to <code>.+</code>, etc (or <code>.+=</code> etc), however the <code>.=</code> and <code>(+).()</code> syntaxes are fused into a single, efficient call to <code>broadcast!</code>. The simpler syntax <code>x .+= pos</code> is expected to be non-allocating (and therefore faster) in Julia 0.6.</p><p>The functions <code>setindex</code>, <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>insert</code> and <code>deleteat</code> are provided for performing certain specific operations on static arrays, in analogy with the standard functions <code>setindex!</code>, <code>push!</code>, <code>pop!</code>, etc. (Note that if the size of the static array changes, the type of the output will differ from the input.)</p><h3><a class="nav-anchor" id="SIMD-optimizations-1" href="#SIMD-optimizations-1">SIMD optimizations</a></h3><p>It seems Julia and LLVM are smart enough to use processor vectorization extensions like SSE and AVX - however they are currently partially disabled by default. Run Julia with <code>julia -O</code> or <code>julia -O3</code> to enable these optimizations, and many of your (immutable) <code>StaticArray</code> methods <em>should</em> become significantly faster!</p><h2><a class="nav-anchor" id="Docstrings-1" href="#Docstrings-1">Docstrings</a></h2><ul><li><a href="#StaticArrays.Dynamic"><code>StaticArrays.Dynamic</code></a></li><li><a href="#StaticArrays.FieldVector"><code>StaticArrays.FieldVector</code></a></li><li><a href="#StaticArrays.MArray"><code>StaticArrays.MArray</code></a></li><li><a href="#StaticArrays.MMatrix"><code>StaticArrays.MMatrix</code></a></li><li><a href="#StaticArrays.MVector"><code>StaticArrays.MVector</code></a></li><li><a href="#StaticArrays.SArray"><code>StaticArrays.SArray</code></a></li><li><a href="#StaticArrays.SMatrix"><code>StaticArrays.SMatrix</code></a></li><li><a href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a></li><li><a href="#StaticArrays.SVector"><code>StaticArrays.SVector</code></a></li><li><a href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a></li><li><a href="#StaticArrays.Size"><code>StaticArrays.Size</code></a></li><li><a href="#StaticArrays.Size-Union{Tuple{Array}, Tuple{S}} where S"><code>StaticArrays.Size</code></a></li><li><a href="#StaticArrays.SizedArray"><code>StaticArrays.SizedArray</code></a></li><li><a href="#StaticArrays.StaticArray"><code>StaticArrays.StaticArray</code></a></li><li><a href="#Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray"><code>Base.similar</code></a></li><li><a href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a></li><li><a href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a></li><li><a href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a></li><li><a href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a></li><li><a href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a></li><li><a href="#StaticArrays.similar_type"><code>StaticArrays.similar_type</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S"><code>StaticArrays.sizematch</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1"><code>StaticArrays.sizematch</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.FieldVector" href="#StaticArrays.FieldVector"><code>StaticArrays.FieldVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract FieldVector{N, T} &lt;: StaticVector{N, T}</code></pre><p>Inheriting from this type will make it easy to create your own vector types. A <code>FieldVector</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldVector</code> will be as performant as an <code>SVector</code> of similar length and element type, while a mutable <code>FieldVector</code> will behave similarly to an <code>MVector</code>.</p><p>For example:</p><pre><code class="language-none">struct Point3D &lt;: FieldVector{3, Float64}
    x::Float64
    y::Float64
    z::Float64
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MArray" href="#StaticArrays.MArray"><code>StaticArrays.MArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MArray{S, T, L}()
MArray{S, T, L}(x::NTuple{L, T})
MArray{S, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable array <code>MArray</code>. The data may optionally be provided upon construction and can be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="language-none">MArray{S}(a::Array)</code></pre><p>Construct a statically-sized, mutable array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MMatrix" href="#StaticArrays.MMatrix"><code>StaticArrays.MMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MMatrix{S1, S2, T, L}()
MMatrix{S1, S2, T, L}(x::NTuple{L, T})
MMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable matrix <code>MMatrix</code>. The data may optionally be provided upon construction and can be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="language-none">MMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized, mutable matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.MVector" href="#StaticArrays.MVector"><code>StaticArrays.MVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MVector{S,T}()
MVector{S,T}(x::NTuple{S, T})
MVector{S,T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable vector <code>MVector</code>. Data may optionally be provided upon construction, and can be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>MVector(1,2,3)</code> constructs an <code>MVector{3, Int}</code>).</p><pre><code class="language-none">MVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized, mutable vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SArray" href="#StaticArrays.SArray"><code>StaticArrays.SArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SArray{S, T, L}(x::NTuple{L, T})
SArray{S, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized array <code>SArray</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="language-none">SArray{S}(a::Array)</code></pre><p>Construct a statically-sized array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SMatrix" href="#StaticArrays.SMatrix"><code>StaticArrays.SMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SMatrix{S1, S2, T, L}(x::NTuple{L, T})
SMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized matrix <code>SMatrix</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="language-none">SMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SOneTo" href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SOneTo(n)</code></pre><p>Return a statically-sized <code>AbstractUnitRange</code> starting at <code>1</code>, functioning as the <code>axes</code> of a <code>StaticArray</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SVector" href="#StaticArrays.SVector"><code>StaticArrays.SVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SVector{S, T}(x::NTuple{S, T})
SVector{S, T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized vector <code>SVector</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>SVector(1,2,3)</code> constructs an <code>SVector{3, Int}</code>).</p><pre><code class="language-none">SVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Scalar" href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Scalar{T}(x::T)</code></pre><p>Construct a statically-sized 0-dimensional array that contains a single element, <code>x</code>. This type is particularly useful for influencing broadcasting operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Size" href="#StaticArrays.Size"><code>StaticArrays.Size</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Size(dims::Int...)</code></pre><p><code>Size</code> is used extensively throughout the <code>StaticArrays</code> API to describe <em>compile-time</em> knowledge of the size of an array. The dimensions are stored as a type parameter and are statically propagated by the compiler, resulting in efficient, type-inferrable code. For example, to create a static matrix of zeros, use <code>zeros(Size(3,3))</code> (rather than <code>zeros(3,3)</code>, which constructs a <code>Base.Array</code>).</p><p>Note that if dimensions are not known statically (e.g., for standard <code>Array</code>s), <a href="#StaticArrays.Dynamic"><code>Dynamic()</code></a> should be used instead of an <code>Int</code>.</p><pre><code class="language-none">Size(a::AbstractArray)
Size(::Type{T&lt;:AbstractArray})</code></pre><p>The <code>Size</code> constructor can be used to extract static dimension information from a given array. For example:</p><pre><code class="language-julia-repl">julia&gt; Size(zeros(SMatrix{3, 4}))
Size(3, 4)

julia&gt; Size(zeros(3, 4))
Size(StaticArrays.Dynamic(), StaticArrays.Dynamic())</code></pre><p>This has multiple uses, including &quot;trait&quot;-based dispatch on the size of a statically-sized array. For example:</p><pre><code class="language-julia">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Size-Union{Tuple{Array}, Tuple{S}} where S" href="#StaticArrays.Size-Union{Tuple{Array}, Tuple{S}} where S"><code>StaticArrays.Size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Size(dims)(array)</code></pre><p>Creates a <code>SizedArray</code> wrapping <code>array</code> with the specified statically-known <code>dims</code>, so to take advantage of the (faster) methods defined by the static array package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.SizedArray" href="#StaticArrays.SizedArray"><code>StaticArrays.SizedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SizedArray{Tuple{dims...}}(array)</code></pre><p>Wraps an <code>Array</code> with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (<code>length</code>) match, but the array may be reshaped.</p><p>(Also, <code>Size(dims...)(array)</code> acheives the same thing)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.StaticArray" href="#StaticArrays.StaticArray"><code>StaticArrays.StaticArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type StaticArray{S, T, N} &lt;: AbstractArray{T, N} end
StaticScalar{T}     = StaticArray{Tuple{}, T, 0}
StaticVector{N,T}   = StaticArray{Tuple{N}, T, 1}
StaticMatrix{N,M,T} = StaticArray{Tuple{N,M}, T, 2}</code></pre><p><code>StaticArray</code>s are Julia arrays with fixed, known size.</p><p><strong>Dev docs</strong></p><p>They must define the following methods:</p><ul><li>Constructors that accept a flat tuple of data.</li><li><code>getindex()</code> with an integer (linear indexing) (preferably <code>@inline</code> with <code>@boundscheck</code>).</li><li><code>Tuple()</code>, returning the data in a flat Tuple.</li></ul><p>It may be useful to implement:</p><ul><li><code>similar_type(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>, returning a type (or type constructor) that accepts a flat tuple of data.</li></ul><p>For mutable containers you may also need to define the following:</p><ul><li><code>setindex!</code> for a single element (linear indexing).</li><li><code>similar(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>.</li><li>In some cases, a zero-parameter constructor, <code>MyStaticArray{...}()</code> for unintialized data is assumed to exist.</li></ul><p>(see also <code>SVector</code>, <code>SMatrix</code>, <code>SArray</code>, <code>MVector</code>, <code>MMatrix</code>, <code>MArray</code>, <code>SizedArray</code> and <code>FieldVector</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.similar_type" href="#StaticArrays.similar_type"><code>StaticArrays.similar_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">similar_type(static_array)
similar_type(static_array, T)
similar_type(array, ::Size)
similar_type(array, T, ::Size)</code></pre><p>Returns a constructor for a statically-sized array similar to the input array (or type) <code>static_array</code>/<code>array</code>, optionally with different element type <code>T</code> or size <code>Size</code>. If the input <code>array</code> is not a <code>StaticArray</code> then the <code>Size</code> is mandatory.</p><p>This differs from <code>similar()</code> in that the resulting array type may not be mutable (or define <code>setindex!()</code>), and therefore the returned type may need to be <em>constructed</em> with its data.</p><p>Note that the (optional) size <em>must</em> be specified as a static <code>Size</code> object (so the compiler can infer the result statically).</p><p>New types should define the signature <code>similar_type(::Type{A},::Type{T},::Size{S}) where {A&lt;:MyType,T,S}</code> if they wish to overload the default behavior.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.Dynamic" href="#StaticArrays.Dynamic"><code>StaticArrays.Dynamic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Dynamic()</code></pre><p>Used to signify that a dimension of an array is not known statically.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray" href="#Base.similar-Union{Tuple{SA}, Tuple{SA}} where SA&lt;:StaticArray"><code>Base.similar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">similar(static_array)
similar(static_array, T)
similar(array, ::Size)
similar(array, T, ::Size)</code></pre><p>Constructs and returns a mutable but statically-sized array (i.e. a <code>StaticArray</code>). If the input <code>array</code> is not a <code>StaticArray</code>, then the <code>Size</code> is required to determine the output size (or else a dynamically sized array will be returned).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.qr" href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qr(A::StaticMatrix, pivot=Val(false))</code></pre><p>Compute the QR factorization of <code>A</code>. The factors can be obtain by iteration:</p><pre><code class="language-julia">julia&gt; A = @SMatrix rand(3,4);

julia&gt; Q, R = qr(A);

julia&gt; Q * R ≈ A
true</code></pre><p>or by using <code>getfield</code>:</p><pre><code class="language-julia">julia&gt; F = qr(A);

julia&gt; F.Q * F.R ≈ A
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays._size-Tuple{Any}" href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return either the statically known Size() or runtime size()</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">arithmetic_closure(T)</code></pre><p>Return the type which values of type <code>T</code> will promote to under a combination of the arithmetic operations <code>+, -, *</code> and <code>/</code>.</p><pre><code class="language-julia-repl">julia&gt; import StaticArrays.arithmetic_closure

julia&gt; arithmetic_closure(Bool)
Float64

julia&gt; arithmetic_closure(Int32)
Float64

julia&gt; arithmetic_closure(BigFloat)
BigFloat

julia&gt; arithmetic_closure(BigInt)
BigFloat</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.dimmatch" href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dimmatch(x::StaticDimension, y::StaticDimension)</code></pre><p>Return whether dimensions <code>x</code> and <code>y</code> match at compile time, that is:</p><ul><li>if <code>x</code> and <code>y</code> are both <code>Int</code>s, check that they are equal</li><li>if <code>x</code> or <code>y</code> are <code>Dynamic()</code>, return true</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.same_size-Tuple" href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the common Size of the inputs (or else throws a DimensionMismatch)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1" href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1},Size{S2}}} where S2 where S1"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sizematch(::Size, ::Size)
sizematch(::Tuple, ::Tuple)</code></pre><p>Determine whether two sizes match, in the sense that they have the same number of dimensions, and their dimensions match as determined by <a href="#StaticArrays.dimmatch"><code>dimmatch</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S" href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S},StaticArray}} where S"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sizematch(::Size, A::AbstractArray)</code></pre><p>Determine whether array <code>A</code> matches the given size. If <code>A</code> is a <code>StaticArray</code>, the check is performed at compile time, otherwise, the check is performed at runtime.</p></div></div></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../quickstart/"><span class="direction">Next</span><span class="title">Quick Start</span></a></footer></article></body></html>
