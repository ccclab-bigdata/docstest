<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · CSTParser.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CSTParser.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">CSTParser.@addctx</code></pre><pre><code class="language-none">CSTParser.@closebrace</code></pre><pre><code class="language-none">CSTParser.@closeparen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.@closer" href="#CSTParser.@closer"><code>CSTParser.@closer</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@closer ps rule body</code></pre><p>Continues parsing closing on <code>rule</code>.</p></div></div></section><pre><code class="language-none">CSTParser.@closesquare</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.@default" href="#CSTParser.@default"><code>CSTParser.@default</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@default ps body</code></pre><p>Parses the next expression using default closure rules.</p></div></div></section><pre><code class="language-none">CSTParser.@enterctx</code></pre><pre><code class="language-none">CSTParser.@exitctx</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.@nocloser" href="#CSTParser.@nocloser"><code>CSTParser.@nocloser</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@nocloser ps rule body</code></pre><p>Continues parsing not closing on <code>rule</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.@precedence" href="#CSTParser.@precedence"><code>CSTParser.@precedence</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@precedence ps prec body</code></pre><p>Continues parsing binary operators until it hits a more loosely binding operator (with precdence lower than <code>prec</code>).</p></div></div></section><pre><code class="language-none">CSTParser.Abstract</code></pre><pre><code class="language-none">CSTParser.AbstractEXPR</code></pre><pre><code class="language-none">CSTParser.AnonFuncOp</code></pre><pre><code class="language-none">CSTParser.ArrowOp</code></pre><pre><code class="language-none">CSTParser.AssignmentOp</code></pre><pre><code class="language-none">CSTParser.BareModule</code></pre><pre><code class="language-none">CSTParser.Begin</code></pre><pre><code class="language-none">CSTParser.BinaryOpCall</code></pre><pre><code class="language-none">CSTParser.BinarySyntaxOpCall</code></pre><pre><code class="language-none">CSTParser.BitShiftOp</code></pre><pre><code class="language-none">CSTParser.Block</code></pre><pre><code class="language-none">CSTParser.Braces</code></pre><pre><code class="language-none">CSTParser.BracesCat</code></pre><pre><code class="language-none">CSTParser.CSTParser</code></pre><pre><code class="language-none">CSTParser.Call</code></pre><pre><code class="language-none">CSTParser.ChainOpCall</code></pre><pre><code class="language-none">CSTParser.Closer</code></pre><pre><code class="language-none">CSTParser.Closer_TMP</code></pre><pre><code class="language-none">CSTParser.ColonOp</code></pre><pre><code class="language-none">CSTParser.ColonOpCall</code></pre><pre><code class="language-none">CSTParser.Comparison</code></pre><pre><code class="language-none">CSTParser.ComparisonOp</code></pre><pre><code class="language-none">CSTParser.Comprehension</code></pre><pre><code class="language-none">CSTParser.ConditionalOp</code></pre><pre><code class="language-none">CSTParser.ConditionalOpCall</code></pre><pre><code class="language-none">CSTParser.Const</code></pre><pre><code class="language-none">CSTParser.Curly</code></pre><pre><code class="language-none">CSTParser.DddotOp</code></pre><pre><code class="language-none">CSTParser.DeclarationOp</code></pre><pre><code class="language-none">CSTParser.DictComprehension</code></pre><pre><code class="language-none">CSTParser.Do</code></pre><pre><code class="language-none">CSTParser.DotOp</code></pre><pre><code class="language-none">CSTParser.EXPR</code></pre><pre><code class="language-none">CSTParser.EmptyWS</code></pre><pre><code class="language-none">CSTParser.EmptyWSToken</code></pre><pre><code class="language-none">CSTParser.Error</code></pre><pre><code class="language-none">CSTParser.ErrorToken</code></pre><pre><code class="language-none">CSTParser.Export</code></pre><pre><code class="language-none">CSTParser.Expr_char</code></pre><pre><code class="language-none">CSTParser.Expr_cmd</code></pre><pre><code class="language-none">CSTParser.Expr_float</code></pre><pre><code class="language-none">CSTParser.Expr_int</code></pre><pre><code class="language-none">CSTParser.Expr_tcmd</code></pre><pre><code class="language-none">CSTParser.FALSE</code></pre><pre><code class="language-none">CSTParser.File</code></pre><pre><code class="language-none">CSTParser.FileH</code></pre><pre><code class="language-none">CSTParser.Filter</code></pre><pre><code class="language-none">CSTParser.Flatten</code></pre><pre><code class="language-none">CSTParser.For</code></pre><pre><code class="language-none">CSTParser.FunctionDef</code></pre><pre><code class="language-none">CSTParser.Generator</code></pre><pre><code class="language-none">CSTParser.Global</code></pre><pre><code class="language-none">CSTParser.GlobalRefDOC</code></pre><pre><code class="language-none">CSTParser.GlobalRefDoc</code></pre><pre><code class="language-none">CSTParser.Hcat</code></pre><pre><code class="language-none">CSTParser.Head</code></pre><pre><code class="language-none">CSTParser.IDENTIFIER</code></pre><pre><code class="language-none">CSTParser.INSTANCE</code></pre><pre><code class="language-none">CSTParser.If</code></pre><pre><code class="language-none">CSTParser.Import</code></pre><pre><code class="language-none">CSTParser.ImportAll</code></pre><pre><code class="language-none">CSTParser.InvisBrackets</code></pre><pre><code class="language-none">CSTParser.KEYWORD</code></pre><pre><code class="language-none">CSTParser.Kw</code></pre><pre><code class="language-none">CSTParser.LITERAL</code></pre><pre><code class="language-none">CSTParser.LazyAndOp</code></pre><pre><code class="language-none">CSTParser.LazyOrOp</code></pre><pre><code class="language-none">CSTParser.LeafNode</code></pre><pre><code class="language-none">CSTParser.Let</code></pre><pre><code class="language-none">CSTParser.Local</code></pre><pre><code class="language-none">CSTParser.LtoR</code></pre><pre><code class="language-none">CSTParser.Macro</code></pre><pre><code class="language-none">CSTParser.MacroCall</code></pre><pre><code class="language-none">CSTParser.MacroName</code></pre><pre><code class="language-none">CSTParser.ModuleH</code></pre><pre><code class="language-none">CSTParser.Mutable</code></pre><pre><code class="language-none">CSTParser.NOTHING</code></pre><pre><code class="language-none">CSTParser.NewLineWS</code></pre><pre><code class="language-none">CSTParser.OPERATOR</code></pre><pre><code class="language-none">CSTParser.Outer</code></pre><pre><code class="language-none">CSTParser.PUNCTUATION</code></pre><pre><code class="language-none">CSTParser.Parameters</code></pre><pre><code class="language-none">CSTParser.ParseState</code></pre><pre><code class="language-none">CSTParser.PipeOp</code></pre><pre><code class="language-none">CSTParser.PlusOp</code></pre><pre><code class="language-none">CSTParser.PowerOp</code></pre><pre><code class="language-none">CSTParser.PrimeOp</code></pre><pre><code class="language-none">CSTParser.Primitive</code></pre><pre><code class="language-none">CSTParser.Project</code></pre><pre><code class="language-none">CSTParser.Quote</code></pre><pre><code class="language-none">CSTParser.Quotenode</code></pre><pre><code class="language-none">CSTParser.RationalOp</code></pre><pre><code class="language-none">CSTParser.Ref</code></pre><pre><code class="language-none">CSTParser.Return</code></pre><pre><code class="language-none">CSTParser.Row</code></pre><pre><code class="language-none">CSTParser.SemiColonWS</code></pre><pre><code class="language-none">CSTParser.StringH</code></pre><pre><code class="language-none">CSTParser.Struct</code></pre><pre><code class="language-none">CSTParser.TRUE</code></pre><pre><code class="language-none">CSTParser.TYPEMAX_INT128_STR</code></pre><pre><code class="language-none">CSTParser.TYPEMAX_INT64_STR</code></pre><pre><code class="language-none">CSTParser.TimesOp</code></pre><pre><code class="language-none">CSTParser.TopLevel</code></pre><pre><code class="language-none">CSTParser.Try</code></pre><pre><code class="language-none">CSTParser.TupleH</code></pre><pre><code class="language-none">CSTParser.TypedComprehension</code></pre><pre><code class="language-none">CSTParser.TypedHcat</code></pre><pre><code class="language-none">CSTParser.TypedVcat</code></pre><pre><code class="language-none">CSTParser.UNICODE_OPS_REVERSE</code></pre><pre><code class="language-none">CSTParser.UnaryOpCall</code></pre><pre><code class="language-none">CSTParser.UnarySyntaxOpCall</code></pre><pre><code class="language-none">CSTParser.Using</code></pre><pre><code class="language-none">CSTParser.Vcat</code></pre><pre><code class="language-none">CSTParser.Vect</code></pre><pre><code class="language-none">CSTParser.WS</code></pre><pre><code class="language-none">CSTParser.WhereOp</code></pre><pre><code class="language-none">CSTParser.WhereOpCall</code></pre><pre><code class="language-none">CSTParser.While</code></pre><pre><code class="language-none">CSTParser._arg_id</code></pre><pre><code class="language-none">CSTParser._get_import_block</code></pre><pre><code class="language-none">CSTParser._parse_ref</code></pre><pre><code class="language-none">CSTParser._unescape_string</code></pre><pre><code class="language-none">CSTParser.accept_comma</code></pre><pre><code class="language-none">CSTParser.accept_end</code></pre><pre><code class="language-none">CSTParser.accept_rbrace</code></pre><pre><code class="language-none">CSTParser.accept_rparen</code></pre><pre><code class="language-none">CSTParser.accept_rsquare</code></pre><pre><code class="language-none">CSTParser.adjustspan</code></pre><pre><code class="language-none">CSTParser.check_base</code></pre><pre><code class="language-none">CSTParser.check_file</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.check_reformat" href="#CSTParser.check_reformat"><code>CSTParser.check_reformat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_reformat()</code></pre><p>Reads and parses all files in current directory, applys formatting fixes and checks that the output AST remains the same.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.check_span" href="#CSTParser.check_span"><code>CSTParser.check_span</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>check_span(x, neq = [])</p><p>Recursively checks whether the span of an expression equals the sum of the span of its components. Returns a vector of failing expressions.</p></div></div></section><pre><code class="language-none">CSTParser.clear_at!</code></pre><pre><code class="language-none">CSTParser.closer</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.compare" href="#CSTParser.compare"><code>CSTParser.compare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compare(x,y)</code></pre><p>Recursively checks whether two Base.Expr are the same. Returns unequal sub- expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.contributes_scope" href="#CSTParser.contributes_scope"><code>CSTParser.contributes_scope</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contributes_scope(x)</code></pre><p>Checks whether the body of <code>x</code> is included in the toplevel namespace.</p></div></div></section><pre><code class="language-none">CSTParser.convert_iter_assign</code></pre><pre><code class="language-none">CSTParser.create_tmp</code></pre><pre><code class="language-none">CSTParser.cst_parsefile</code></pre><pre><code class="language-none">CSTParser.debug</code></pre><pre><code class="language-none">CSTParser.defines_abstract</code></pre><pre><code class="language-none">CSTParser.defines_anon_function</code></pre><pre><code class="language-none">CSTParser.defines_datatype</code></pre><pre><code class="language-none">CSTParser.defines_function</code></pre><pre><code class="language-none">CSTParser.defines_macro</code></pre><pre><code class="language-none">CSTParser.defines_module</code></pre><pre><code class="language-none">CSTParser.defines_mutable</code></pre><pre><code class="language-none">CSTParser.defines_primitive</code></pre><pre><code class="language-none">CSTParser.defines_struct</code></pre><pre><code class="language-none">CSTParser.dropleadlingnewline</code></pre><pre><code class="language-none">CSTParser.eval</code></pre><pre><code class="language-none">CSTParser.expr_import</code></pre><pre><code class="language-none">CSTParser.fix_range</code></pre><pre><code class="language-none">CSTParser.flatten_tuple</code></pre><pre><code class="language-none">CSTParser.flisp_parse</code></pre><pre><code class="language-none">CSTParser.flisp_parsefile</code></pre><pre><code class="language-none">CSTParser.get_arg_name</code></pre><pre><code class="language-none">CSTParser.get_arg_type</code></pre><pre><code class="language-none">CSTParser.get_args</code></pre><pre><code class="language-none">CSTParser.get_body</code></pre><pre><code class="language-none">CSTParser.get_curly_params</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.get_id" href="#CSTParser.get_id"><code>CSTParser.get_id</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_id(x)</code></pre><p>Get the IDENTIFIER name of a variable, possibly in the presence of  type declaration operators.</p></div></div></section><pre><code class="language-none">CSTParser.get_inner_gen</code></pre><pre><code class="language-none">CSTParser.get_iter</code></pre><pre><code class="language-none">CSTParser.get_name</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.get_sig" href="#CSTParser.get_sig"><code>CSTParser.get_sig</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_sig(x)</code></pre><p>Returns the full signature of function, macro and datatype definitions.  Should only be called when has_sig(x) == true.</p></div></div></section><pre><code class="language-none">CSTParser.get_sig_params</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.get_t" href="#CSTParser.get_t"><code>CSTParser.get_t</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_t(x)</code></pre><p>Basic inference in the presence of type declarations.</p></div></div></section><pre><code class="language-none">CSTParser.get_where_params</code></pre><pre><code class="language-none">CSTParser.has_sig</code></pre><pre><code class="language-none">CSTParser.include</code></pre><pre><code class="language-none">CSTParser.infer_t</code></pre><pre><code class="language-none">CSTParser.is_and</code></pre><pre><code class="language-none">CSTParser.is_anon_func</code></pre><pre><code class="language-none">CSTParser.is_assignment</code></pre><pre><code class="language-none">CSTParser.is_colon</code></pre><pre><code class="language-none">CSTParser.is_comma</code></pre><pre><code class="language-none">CSTParser.is_cond</code></pre><pre><code class="language-none">CSTParser.is_dddot</code></pre><pre><code class="language-none">CSTParser.is_ddot</code></pre><pre><code class="language-none">CSTParser.is_decl</code></pre><pre><code class="language-none">CSTParser.is_dot</code></pre><pre><code class="language-none">CSTParser.is_elof</code></pre><pre><code class="language-none">CSTParser.is_eq</code></pre><pre><code class="language-none">CSTParser.is_exor</code></pre><pre><code class="language-none">CSTParser.is_float</code></pre><pre><code class="language-none">CSTParser.is_func_call</code></pre><pre><code class="language-none">CSTParser.is_if</code></pre><pre><code class="language-none">CSTParser.is_import</code></pre><pre><code class="language-none">CSTParser.is_importall</code></pre><pre><code class="language-none">CSTParser.is_in</code></pre><pre><code class="language-none">CSTParser.is_integer</code></pre><pre><code class="language-none">CSTParser.is_issubt</code></pre><pre><code class="language-none">CSTParser.is_issupt</code></pre><pre><code class="language-none">CSTParser.is_lbrace</code></pre><pre><code class="language-none">CSTParser.is_lit_string</code></pre><pre><code class="language-none">CSTParser.is_lparen</code></pre><pre><code class="language-none">CSTParser.is_lsquare</code></pre><pre><code class="language-none">CSTParser.is_minus</code></pre><pre><code class="language-none">CSTParser.is_module</code></pre><pre><code class="language-none">CSTParser.is_not</code></pre><pre><code class="language-none">CSTParser.is_nothing</code></pre><pre><code class="language-none">CSTParser.is_number</code></pre><pre><code class="language-none">CSTParser.is_pairarrow</code></pre><pre><code class="language-none">CSTParser.is_plus</code></pre><pre><code class="language-none">CSTParser.is_prime</code></pre><pre><code class="language-none">CSTParser.is_punc</code></pre><pre><code class="language-none">CSTParser.is_range</code></pre><pre><code class="language-none">CSTParser.is_rbrace</code></pre><pre><code class="language-none">CSTParser.is_rparen</code></pre><pre><code class="language-none">CSTParser.is_rsquare</code></pre><pre><code class="language-none">CSTParser.is_star</code></pre><pre><code class="language-none">CSTParser.is_valid_iterator</code></pre><pre><code class="language-none">CSTParser.is_where</code></pre><pre><code class="language-none">CSTParser.isajuxtaposition</code></pre><pre><code class="language-none">CSTParser.isassignment</code></pre><pre><code class="language-none">CSTParser.isbinaryop</code></pre><pre><code class="language-none">CSTParser.isbool</code></pre><pre><code class="language-none">CSTParser.iscomma</code></pre><pre><code class="language-none">CSTParser.isemptyws</code></pre><pre><code class="language-none">CSTParser.isidentifier</code></pre><pre><code class="language-none">CSTParser.isinstance</code></pre><pre><code class="language-none">CSTParser.iskw</code></pre><pre><code class="language-none">CSTParser.ispunctuation</code></pre><pre><code class="language-none">CSTParser.isstring</code></pre><pre><code class="language-none">CSTParser.issyntaxcall</code></pre><pre><code class="language-none">CSTParser.issyntaxunarycall</code></pre><pre><code class="language-none">CSTParser.isunaryandbinaryop</code></pre><pre><code class="language-none">CSTParser.isunaryop</code></pre><pre><code class="language-none">CSTParser.julia_normalization_map</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.lex_ws_comment" href="#CSTParser.lex_ws_comment"><code>CSTParser.lex_ws_comment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lex_ws_comment(l::Lexer, c)</code></pre><p>Having hit an initial whitespace/comment/semicolon continues collecting similar <code>Chars</code> until they end. Returns a WS token with an indication of newlines/ semicolons. Indicating a semicolons takes precedence over line breaks as the former is equivalent to the former in most cases.</p></div></div></section><pre><code class="language-none">CSTParser.longest_common_prefix</code></pre><pre><code class="language-none">CSTParser.next</code></pre><pre><code class="language-none">CSTParser.non_dotted_op</code></pre><pre><code class="language-none">CSTParser.norm_ast</code></pre><pre><code class="language-none">CSTParser.normalize_julia_identifier</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse" href="#CSTParser.parse"><code>CSTParser.parse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse(str, cont = false)</code></pre><p>Parses the passed string. If <code>cont</code> is true then will continue parsing until the end of the string returning the resulting expressions in a TOPLEVEL block.</p></div></div></section><pre><code class="language-none">CSTParser.parse_abstract</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_array" href="#CSTParser.parse_array"><code>CSTParser.parse_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_array(ps)</code></pre><p>Having hit &#39;[&#39; return either:</p><ul><li>A vect</li><li>A vcat</li><li>A comprehension</li><li>An array (vcat of hcats)</li></ul></div></div></section><pre><code class="language-none">CSTParser.parse_begin</code></pre><pre><code class="language-none">CSTParser.parse_block</code></pre><pre><code class="language-none">CSTParser.parse_braces</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_call" href="#CSTParser.parse_call"><code>CSTParser.parse_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_call(ps, ret)</code></pre><p>Parses a function call. Expects to start before the opening parentheses and is passed the expression declaring the function name, <code>ret</code>.</p></div></div></section><pre><code class="language-none">CSTParser.parse_comma_sep</code></pre><pre><code class="language-none">CSTParser.parse_comp_operator</code></pre><pre><code class="language-none">CSTParser.parse_compound</code></pre><pre><code class="language-none">CSTParser.parse_const</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_curly" href="#CSTParser.parse_curly"><code>CSTParser.parse_curly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>parse_curly(ps, ret)</p><p>Parses the juxtaposition of <code>ret</code> with an opening brace. Parses a comma seperated list.</p></div></div></section><pre><code class="language-none">CSTParser.parse_directory</code></pre><pre><code class="language-none">CSTParser.parse_do</code></pre><pre><code class="language-none">CSTParser.parse_doc</code></pre><pre><code class="language-none">CSTParser.parse_dot_mod</code></pre><pre><code class="language-none">CSTParser.parse_end</code></pre><pre><code class="language-none">CSTParser.parse_export</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_expression" href="#CSTParser.parse_expression"><code>CSTParser.parse_expression</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_expression(ps)</code></pre><p>Parses an expression until <code>closer(ps) == true</code>. Expects to enter the <code>ParseState</code> the token before the the beginning of the expression and ends on the last token.</p><p>Acceptable starting tokens are:</p><ul><li>A keyword</li><li>An opening parentheses or brace.</li><li>An operator.</li><li>An instance (e.g. identifier, number, etc.)</li><li>An <code>@</code>.</li></ul></div></div></section><pre><code class="language-none">CSTParser.parse_file</code></pre><pre><code class="language-none">CSTParser.parse_for</code></pre><pre><code class="language-none">CSTParser.parse_function</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_generator" href="#CSTParser.parse_generator"><code>CSTParser.parse_generator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>parse_generator(ps)</p><p>Having hit <code>for</code> not at the beginning of an expression return a generator. Comprehensions are parsed as SQUAREs containing a generator.</p></div></div></section><pre><code class="language-none">CSTParser.parse_global</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_if" href="#CSTParser.parse_if"><code>CSTParser.parse_if</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_if(ps, ret, nested=false, puncs=[])</code></pre><p>Parse an <code>if</code> block.</p></div></div></section><pre><code class="language-none">CSTParser.parse_imports</code></pre><pre><code class="language-none">CSTParser.parse_iter</code></pre><pre><code class="language-none">CSTParser.parse_kw</code></pre><pre><code class="language-none">CSTParser.parse_let</code></pre><pre><code class="language-none">CSTParser.parse_local</code></pre><pre><code class="language-none">CSTParser.parse_macro</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_macrocall" href="#CSTParser.parse_macrocall"><code>CSTParser.parse_macrocall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_macrocall(ps)</code></pre><p>Parses a macro call. Expects to start on the <code>@</code>.</p></div></div></section><pre><code class="language-none">CSTParser.parse_module</code></pre><pre><code class="language-none">CSTParser.parse_mutable</code></pre><pre><code class="language-none">CSTParser.parse_operator</code></pre><pre><code class="language-none">CSTParser.parse_operator_anon_func</code></pre><pre><code class="language-none">CSTParser.parse_operator_colon</code></pre><pre><code class="language-none">CSTParser.parse_operator_cond</code></pre><pre><code class="language-none">CSTParser.parse_operator_dot</code></pre><pre><code class="language-none">CSTParser.parse_operator_eq</code></pre><pre><code class="language-none">CSTParser.parse_operator_power</code></pre><pre><code class="language-none">CSTParser.parse_operator_where</code></pre><pre><code class="language-none">CSTParser.parse_parameters</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_paren" href="#CSTParser.parse_paren"><code>CSTParser.parse_paren</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_paren(ps, ret)</code></pre><p>Parses an expression starting with a <code>(</code>.</p></div></div></section><pre><code class="language-none">CSTParser.parse_primitive</code></pre><pre><code class="language-none">CSTParser.parse_quote</code></pre><pre><code class="language-none">CSTParser.parse_ranges</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_ref" href="#CSTParser.parse_ref"><code>CSTParser.parse_ref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_ref(ps, ret)</code></pre><p>Handles cases where an expression - <code>ret</code> - is followed by <code>[</code>. Parses the following bracketed expression and modifies it&#39;s <code>.head</code> appropriately.</p></div></div></section><pre><code class="language-none">CSTParser.parse_return</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_string_or_cmd" href="#CSTParser.parse_string_or_cmd"><code>CSTParser.parse_string_or_cmd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>parse<em>string</em>or_cmd(ps)</p><p>When trying to make an <code>INSTANCE</code> from a string token we must check for interpolating opoerators.</p></div></div></section><pre><code class="language-none">CSTParser.parse_struct</code></pre><pre><code class="language-none">CSTParser.parse_try</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_tuple" href="#CSTParser.parse_tuple"><code>CSTParser.parse_tuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>parse_tuple(ps, ret)</p><p><code>ret</code> is followed by a comma so tries to parse the rest of the tuple.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.parse_unary" href="#CSTParser.parse_unary"><code>CSTParser.parse_unary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_unary(ps)</code></pre><p>Having hit a unary operator at the start of an expression return a call.</p></div></div></section><pre><code class="language-none">CSTParser.parse_unary_colon</code></pre><pre><code class="language-none">CSTParser.parse_while</code></pre><pre><code class="language-none">CSTParser.precedence</code></pre><pre><code class="language-none">CSTParser.read_comment</code></pre><pre><code class="language-none">CSTParser.read_ws</code></pre><pre><code class="language-none">CSTParser.recover_endmarker</code></pre><pre><code class="language-none">CSTParser.rem_call</code></pre><pre><code class="language-none">CSTParser.rem_curly</code></pre><pre><code class="language-none">CSTParser.rem_dddot</code></pre><pre><code class="language-none">CSTParser.rem_decl</code></pre><pre><code class="language-none">CSTParser.rem_invis</code></pre><pre><code class="language-none">CSTParser.rem_kw</code></pre><pre><code class="language-none">CSTParser.rem_subtype</code></pre><pre><code class="language-none">CSTParser.rem_where</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSTParser.remlineinfo!" href="#CSTParser.remlineinfo!"><code>CSTParser.remlineinfo!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remlineinfo!(x)</code></pre><p>Removes line info expressions. (i.e. Expr(:line, 1))</p></div></div></section><pre><code class="language-none">CSTParser.sized_uint_literal</code></pre><pre><code class="language-none">CSTParser.sized_uint_oct_literal</code></pre><pre><code class="language-none">CSTParser.skip_to_nl</code></pre><pre><code class="language-none">CSTParser.span</code></pre><pre><code class="language-none">CSTParser.speed_test</code></pre><pre><code class="language-none">CSTParser.str_value</code></pre><pre><code class="language-none">CSTParser.term_c</code></pre><pre><code class="language-none">CSTParser.test_find</code></pre><pre><code class="language-none">CSTParser.test_order</code></pre><pre><code class="language-none">CSTParser.tostr</code></pre><pre><code class="language-none">CSTParser.trailing_ws_length</code></pre><pre><code class="language-none">CSTParser.update_from_tmp!</code></pre><pre><code class="language-none">CSTParser.update_span!</code></pre><pre><code class="language-none">CSTParser.update_to_default!</code></pre><pre><code class="language-none">CSTParser.utf8proc_map_custom</code></pre><pre><code class="language-none">CSTParser.val</code></pre><pre><code class="language-none">CSTParser.wstype</code></pre><pre><code class="language-none">CSTParser.x_Cmd</code></pre><pre><code class="language-none">CSTParser.x_Str</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
