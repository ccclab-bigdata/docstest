<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · BitBasis.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BitBasis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.@bit_str" href="#BitBasis.@bit_str"><code>BitBasis.@bit_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@bit_str -&gt; BitStr</code></pre><p>Construct a bit string. such as <code>bit&quot;0000&quot;</code>. The bit strings also supports string <code>bcat</code>. Just use it like normal strings.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bit&quot;10001&quot;
10001 (17)

julia&gt; bit&quot;100_111_101&quot;
00001110101 (117)

julia&gt; bcat(bit&quot;1001&quot;, bit&quot;11&quot;, bit&quot;1110&quot;)
1001111110 (638)

julia&gt; v = rand(16);

julia&gt; v[bit&quot;1001&quot;]
0.38965443157314406

julia&gt; onehot(bit&quot;1001&quot;)
16-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
</code></pre></div></div></section><pre><code class="language-none">BitBasis.BitBasis</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.BitStr" href="#BitBasis.BitStr"><code>BitBasis.BitStr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BitStr{T}</code></pre><p>String literal for bits.</p><pre><code class="language-none">BitStr(value[, len=ndigits(value)])</code></pre><p>Returns a <code>BitStr</code>, by default the length is set to the minimum length required to represent <code>value</code> as bits.</p><pre><code class="language-none">BitStr(str::String)</code></pre><p>Parse the input string to a BitStr. See <a href="#BitBasis.@bit_str"><code>@bit_str</code></a> for more details.</p><p><strong>Example</strong></p><p><code>BitStr</code> supports some basic arithmetic operations. It acts like an integer, but supports some frequently used methods for binary basis.</p><pre><code class="language-julia">julia&gt; bit&quot;101&quot; * 2
1010 (10)

julia&gt; bcat(bit&quot;101&quot; for i in 1:10)
101101101101101101101101101101 (766958445)

julia&gt; repeat(bit&quot;101&quot;, 2)
101101 (45)

julia&gt; bit&quot;1101&quot;[2]
0</code></pre></div></div></section><pre><code class="language-none">BitBasis.IntIterator</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ReorderedBasis" href="#BitBasis.ReorderedBasis"><code>BitBasis.ReorderedBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReorderedBasis{N, T}</code></pre><p>Lazy reorderd basis.</p></div></div></section><pre><code class="language-none">BitBasis._packbits</code></pre><pre><code class="language-none">BitBasis._reorder</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.allmasked" href="#BitBasis.allmasked"><code>BitBasis.allmasked</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allmasked(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if all masked position of index is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.anymasked" href="#BitBasis.anymasked"><code>BitBasis.anymasked</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">anymasked(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if any masked position of index is 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.baddrs" href="#BitBasis.baddrs"><code>BitBasis.baddrs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">baddrs(b::Integer) -&gt; Vector</code></pre><p>get the locations of nonzeros bits, i.e. the inverse operation of bmask.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.basis" href="#BitBasis.basis"><code>BitBasis.basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">basis([IntType], num_bits::Int) -&gt; UnitRange{IntType}
basis([IntType], state::AbstractArray) -&gt; UnitRange{IntType}</code></pre><p>Returns the UnitRange for basis in Hilbert Space of num_bits qubits. If an array is supplied, it will return a basis having the same size with the first diemension of array.</p></div></div></section><pre><code class="language-none">BitBasis.bcat</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bdistance" href="#BitBasis.bdistance"><code>BitBasis.bdistance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bdistance(i::Integer, j::Integer) -&gt; Int</code></pre><p>Return number of different bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat" href="#BitBasis.bfloat"><code>BitBasis.bfloat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfloat(b::Integer; nbit::Int=bit_length(b)) -&gt; Float64</code></pre><p>float view, with big end qubit 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat_r" href="#BitBasis.bfloat_r"><code>BitBasis.bfloat_r</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bfloat_r(b::Integer; nbit::Int) -&gt; Float64</code></pre><p>float view, with bits read in inverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint" href="#BitBasis.bint"><code>BitBasis.bint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bint(b; nbit=nothing) -&gt; Int</code></pre><p>integer view, with little end qubit 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint_r" href="#BitBasis.bint_r"><code>BitBasis.bint_r</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bint_r(b; nbit::Int) -&gt; Integer</code></pre><p>integer read in inverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit_length" href="#BitBasis.bit_length"><code>BitBasis.bit_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bit_length(x::Integer) -&gt; Int</code></pre><p>Return the number of bits required to represent input integer x.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bitarray" href="#BitBasis.bitarray"><code>BitBasis.bitarray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bitarray(v::Vector, [num_bits::Int]) -&gt; BitArray
bitarray(v::Int, num_bits::Int) -&gt; BitArray
bitarray(num_bits::Int) -&gt; Function</code></pre><p>Construct BitArray from an integer vector, if num_bits not supplied, it is 64. If an integer is supplied, it returns a function mapping a Vector/Int to bitarray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bmask" href="#BitBasis.bmask"><code>BitBasis.bmask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bmask(::Type{T}) where T &lt;: Integer -&gt; zero(T)
bmask([T::Type], positions::Int...) -&gt; T
bmask([T::Type], range::UnitRange{Int}) -&gt; T</code></pre><p>Return an integer mask of type <code>T</code> where <code>1</code> is the position masked according to <code>positions</code> or <code>range</code>. Directly use <code>T</code> will return an empty mask <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.breflect" href="#BitBasis.breflect"><code>BitBasis.breflect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">breflect(num_bits::Int, b::Integer[, masks::Vector{Integer}]) -&gt; Integer</code></pre><p>Return left-right reflected integer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bsizeof" href="#BitBasis.bsizeof"><code>BitBasis.bsizeof</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bsizeof(::Type)</code></pre><p>Returns the size of given type in number of binary digits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.controller" href="#BitBasis.controller"><code>BitBasis.controller</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">controller(cbits, cvals) -&gt; Function</code></pre><p>Return a function that checks whether a basis at <code>cbits</code> takes specific value <code>cvals</code>.</p></div></div></section><pre><code class="language-none">BitBasis.eat_underscore</code></pre><pre><code class="language-none">BitBasis.eval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.flip" href="#BitBasis.flip"><code>BitBasis.flip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flip(index::Integer, mask::Integer) -&gt; Integer</code></pre><p>Return an Integer with bits at masked position flipped.</p></div></div></section><pre><code class="language-none">BitBasis.getbit</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.hypercubic" href="#BitBasis.hypercubic"><code>BitBasis.hypercubic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypercubic(A::Array) -&gt; Array</code></pre><p>get the hypercubic representation for an array.</p></div></div></section><pre><code class="language-none">BitBasis.include</code></pre><pre><code class="language-none">BitBasis.int</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.invorder" href="#BitBasis.invorder"><code>BitBasis.invorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invorder(X::AbstractVecOrMat)</code></pre><p>Inverse the order of given vector/matrix <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ismasked_equal" href="#BitBasis.ismasked_equal"><code>BitBasis.ismasked_equal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ismasked_equal(index::Integer, mask::Integer, onemask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if bits at positions masked by <code>mask</code> equal to <code>1</code> are equal to <code>onemask</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; n = 0b11001; mask = 0b10100; onemask = 0b10000;

julia&gt; ismasked_equal(n, mask, onemask)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.log2dim1" href="#BitBasis.log2dim1"><code>BitBasis.log2dim1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log2dim1(X)</code></pre><p>Returns the <code>log2</code> of the first dimension&#39;s size.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.log2i" href="#BitBasis.log2i"><code>BitBasis.log2i</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log2i(x::Integer) -&gt; Integer</code></pre><p>Return log2(x), this integer version of <code>log2</code> is fast but only valid for number equal to 2^n.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.neg" href="#BitBasis.neg"><code>BitBasis.neg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neg(index::Integer, num_bits::Int) -&gt; Integer</code></pre><p>Return an integer with all bits flipped (with total number of bit <code>num_bits</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.next_reordered_basis" href="#BitBasis.next_reordered_basis"><code>BitBasis.next_reordered_basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next_reordered_basis(basis, takers, differ)</code></pre><p>Returns the next reordered basis accroding to current basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.onehot" href="#BitBasis.onehot"><code>BitBasis.onehot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">onehot([T=Float64], nbits, x::Integer)</code></pre><p>Returns an onehot vector of type <code>Vector{T}</code>, where index <code>x + 1</code> is one.</p></div></div><div><div><pre><code class="language-none">onehot([T=Float64], bit_str)</code></pre><p>Returns an onehot vector of type <code>Vector{T}</code>, where the <code>bit_str</code>-th element is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.packbits" href="#BitBasis.packbits"><code>BitBasis.packbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">packbits(arr::AbstractArray) -&gt; AbstractArray</code></pre><p>pack bits to integers, usually take a BitArray as input.</p></div></div></section><pre><code class="language-none">BitBasis.parse_bit</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.reorder" href="#BitBasis.reorder"><code>BitBasis.reorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reorder(X::AbstractArray, orders)</code></pre><p>Reorder <code>X</code> according to <code>orders</code>.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Although <code>orders</code> can be any iterable, <code>Tuple</code> is preferred inorder to gain as much performance as possible. But the conversion won&#39;t take much anyway.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.setbit" href="#BitBasis.setbit"><code>BitBasis.setbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setbit(index::Integer, mask::Integer) -&gt; Integer</code></pre><p>set the bit at masked position to 1.</p></div></div></section><pre><code class="language-none">BitBasis.sum_length</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.swapbits" href="#BitBasis.swapbits"><code>BitBasis.swapbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">swapbits(n::Integer, mask_ij::Integer) -&gt; Integer</code></pre><p>Return an integer with bits at <code>i</code> and <code>j</code> in given mask flipped.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>mask_ij</code> should only contain two <code>1</code>, <code>swapbits</code> will not check it, use at your own risk.</p></div></div></div></div><div><div><pre><code class="language-none">swapbits(n::Integer, i::Int, j::Int) -&gt; Integer</code></pre><p>Return an integer with bits at <code>i</code> and <code>j</code> flipped.</p></div></div></section><pre><code class="language-none">BitBasis.takebit</code></pre><pre><code class="language-none">BitBasis.testall</code></pre><pre><code class="language-none">BitBasis.testany</code></pre><pre><code class="language-none">BitBasis.testval</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.unsafe_reorder" href="#BitBasis.unsafe_reorder"><code>BitBasis.unsafe_reorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_reorder(X::AbstractArray, orders)</code></pre><p>Reorder <code>X</code> according to <code>orders</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>unsafe_reorder</code> won&#39;t check whether the length of <code>orders</code> and the size of first dimension of <code>X</code> match, use at your own risk.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.unsafe_sub" href="#BitBasis.unsafe_sub"><code>BitBasis.unsafe_sub</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_sub(a::UnitRange, b::NTuple{N}) -&gt; NTuple{N}</code></pre><p>Returns result in type <code>Tuple</code> of <code>a .- b</code>. This will not check the length of <code>a</code> and <code>b</code>, use at your own risk.</p></div></div><div><div><pre><code class="language-none">unsafe_sub(a::UnitRange{T}, b::Vector{T}) where T</code></pre><p>Returns <code>a .- b</code>, fallback version when b is a <code>Vector</code>.</p></div></div></section><pre><code class="language-none">BitBasis.unsafe_swapbits</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
