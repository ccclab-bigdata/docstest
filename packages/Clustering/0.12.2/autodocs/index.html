<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Clustering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Clustering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">Clustering.AffinityPropResult</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.AverageDistance" href="#Clustering.AverageDistance"><code>Clustering.AverageDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Average distance between a pair of points from each clusters.</p></div></div></section><pre><code class="language-none">Clustering.Clustering</code></pre><pre><code class="language-none">Clustering.ClusteringResult</code></pre><pre><code class="language-none">Clustering.DbscanCluster</code></pre><pre><code class="language-none">Clustering.DbscanResult</code></pre><pre><code class="language-none">Clustering.FuzzyCMeansResult</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.Hclust" href="#Clustering.Hclust"><code>Clustering.Hclust</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Hierarchical clustering of the data returned by <code>hclust()</code>. The data hierarchy is defined by the <code>merges</code> matrix:</p><ul><li>each row specifies which subtrees (referenced by their IDs) are merged into a higher-level subtree</li><li>negative subtree <code>id</code> denotes leaf node and corresponds to the datapoint at position <code>-id</code></li><li>positive <code>id</code> denotes nontrivial subtree: the row <code>merges[id, :]</code> specifies its left and right subtrees, and <code>heights[id]</code> – its height.</li></ul><p>This type mostly follows R&#39;s <code>hclust</code> class.</p></div></div></section><pre><code class="language-none">Clustering.HclustMerges</code></pre><pre><code class="language-none">Clustering.HclustTrees</code></pre><pre><code class="language-none">Clustering.KmCentralityAlg</code></pre><pre><code class="language-none">Clustering.KmeansResult</code></pre><pre><code class="language-none">Clustering.KmedoidsResult</code></pre><pre><code class="language-none">Clustering.KmppAlg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MCLResult" href="#Clustering.MCLResult"><code>Clustering.MCLResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct MCLResult &lt;: ClusteringResult</code></pre><p>Result returned by <code>mcl()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MaximumDistance" href="#Clustering.MaximumDistance"><code>Clustering.MaximumDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Maximum distance between a pair of point from each clusters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.MinimalDistance" href="#Clustering.MinimalDistance"><code>Clustering.MinimalDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Distance between the clusters is the minimal distance between any pair of their points.</p></div></div></section><pre><code class="language-none">Clustering.RandSeedAlg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.ReducibleMetric" href="#Clustering.ReducibleMetric"><code>Clustering.ReducibleMetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Base type for <em>reducible</em> Lance–Williams cluster metrics.</p><p>The metric <code>d</code> is called <em>reducible</em> if for any clusters <code>A</code>, <code>B</code> and <code>C</code> and some <code>ρ &gt; 0</code> s.t.</p><pre><code class="language-none">d(A, B) &lt; ρ, d(A, C) &gt; ρ, d(B, C) &gt; ρ</code></pre><p>it follows that</p><pre><code class="language-none">d(A∪B, C) &gt; ρ</code></pre><p>If the cluster metrics belongs to Lance-Williams family, there is an efficient formula that defines <code>d(A∪B, C)</code> using <code>d(A, C)</code>, <code>d(B, C)</code> and <code>d(A, B)</code>.</p></div></div></section><pre><code class="language-none">Clustering.SeedingAlgorithm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.WardDistance" href="#Clustering.WardDistance"><code>Clustering.WardDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Ward distance between the two clusters <code>A</code> and <code>B</code> is the amount by which merging the two clusters into a single larger cluster <code>A∪B</code> would increase the average squared distance of a point to its cluster centroid.</p></div></div></section><pre><code class="language-none">Clustering._affinityprop</code></pre><pre><code class="language-none">Clustering._afp_compute_a!</code></pre><pre><code class="language-none">Clustering._afp_compute_r!</code></pre><pre><code class="language-none">Clustering._afp_count_exemplars</code></pre><pre><code class="language-none">Clustering._afp_dampen_update!</code></pre><pre><code class="language-none">Clustering._afp_default_damp</code></pre><pre><code class="language-none">Clustering._afp_default_display</code></pre><pre><code class="language-none">Clustering._afp_default_maxiter</code></pre><pre><code class="language-none">Clustering._afp_default_tol</code></pre><pre><code class="language-none">Clustering._afp_extract_exemplars</code></pre><pre><code class="language-none">Clustering._afp_get_assignments</code></pre><pre><code class="language-none">Clustering._dbs_expand_cluster!</code></pre><pre><code class="language-none">Clustering._dbs_region_query</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering._dbscan" href="#Clustering._dbscan"><code>Clustering._dbscan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>An implementation of DBSCAN algorithm that keeps track of both the core and boundary points </p></div></div></section><pre><code class="language-none">Clustering._fcmeans_default_display</code></pre><pre><code class="language-none">Clustering._fcmeans_default_maxiter</code></pre><pre><code class="language-none">Clustering._fcmeans_default_tol</code></pre><pre><code class="language-none">Clustering._find_medoid</code></pre><pre><code class="language-none">Clustering._fuzzy_cmeans</code></pre><pre><code class="language-none">Clustering._isrordered</code></pre><pre><code class="language-none">Clustering._kmeans!</code></pre><pre><code class="language-none">Clustering._kmeans_default_display</code></pre><pre><code class="language-none">Clustering._kmeans_default_init</code></pre><pre><code class="language-none">Clustering._kmeans_default_maxiter</code></pre><pre><code class="language-none">Clustering._kmeans_default_tol</code></pre><pre><code class="language-none">Clustering._kmed_default_display</code></pre><pre><code class="language-none">Clustering._kmed_default_init</code></pre><pre><code class="language-none">Clustering._kmed_default_maxiter</code></pre><pre><code class="language-none">Clustering._kmed_default_tol</code></pre><pre><code class="language-none">Clustering._kmed_update_assignments!</code></pre><pre><code class="language-none">Clustering._kmedoids!</code></pre><pre><code class="language-none">Clustering._mcl_clusters</code></pre><pre><code class="language-none">Clustering._mcl_el_inflate</code></pre><pre><code class="language-none">Clustering._mcl_expand</code></pre><pre><code class="language-none">Clustering._mcl_inflate!</code></pre><pre><code class="language-none">Clustering._mcl_prune!</code></pre><pre><code class="language-none">Clustering._vmeasure</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.accept_cluster!" href="#Clustering.accept_cluster!"><code>Clustering.accept_cluster!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">accept_cluster!(clusters, core_selection, cluster_selection)</code></pre><p>Accept cluster and update the clusters list</p><p><strong>Input</strong></p><ul><li><code>clusters :: Vector{DbscanCluster}</code>: a list of the accepted clusters</li><li><code>core_selection :: Vector{Bool}</code>: selection of the core points of the cluster</li><li><code>cluster_selection :: Vector{Bool}</code>: selection of all the cluster points</li></ul></div></div></section><pre><code class="language-none">Clustering.affinity_propagation</code></pre><pre><code class="language-none">Clustering.affinityprop</code></pre><pre><code class="language-none">Clustering.assertdistancematrix</code></pre><pre><code class="language-none">Clustering.assignments</code></pre><pre><code class="language-none">Clustering.check_seeding_args</code></pre><pre><code class="language-none">Clustering.cluster_elems</code></pre><pre><code class="language-none">Clustering.cluster_size</code></pre><pre><code class="language-none">Clustering.conv_weights</code></pre><pre><code class="language-none">Clustering.copyseeds</code></pre><pre><code class="language-none">Clustering.copyseeds!</code></pre><pre><code class="language-none">Clustering.counts</code></pre><pre><code class="language-none">Clustering.cutree</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.dbscan" href="#Clustering.dbscan"><code>Clustering.dbscan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dbscan(points, radius ; leafsize = 20, min_neighbors = 1, min_cluster_size = 1) -&gt; clusters</code></pre><p>Cluster points using the DBSCAN (density-based spatial clustering of applications with noise) algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: matrix of points</li><li><code>radius::Real</code>: query radius</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>leafsize::Int</code>: number of points binned in each leaf node in the <code>KDTree</code></li><li><code>min_neighbors::Int</code>: minimum number of neighbors to be a core point</li><li><code>min_cluster_size::Int</code>: minimum number of points to be a valid cluster</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{DbscanCluster}</code>: an array of clusters with the id, size core indices and boundary indices</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">points = randn(3, 10000)
clusters = dbscan(points, 0.05, min_neighbors = 3, min_cluster_size = 20) # clusters with less than 20 points will be discarded</code></pre></div></div></section><pre><code class="language-none">Clustering.display_level</code></pre><pre><code class="language-none">Clustering.eval</code></pre><pre><code class="language-none">Clustering.fuzzy_cmeans</code></pre><pre><code class="language-none">Clustering.hclust</code></pre><pre><code class="language-none">Clustering.hclust_minimum</code></pre><pre><code class="language-none">Clustering.hclust_n3</code></pre><pre><code class="language-none">Clustering.hclust_nn</code></pre><pre><code class="language-none">Clustering.hclust_nn_lw</code></pre><pre><code class="language-none">Clustering.hclust_perm</code></pre><pre><code class="language-none">Clustering.height</code></pre><pre><code class="language-none">Clustering.include</code></pre><pre><code class="language-none">Clustering.initial_medoids</code></pre><pre><code class="language-none">Clustering.initseeds</code></pre><pre><code class="language-none">Clustering.initseeds!</code></pre><pre><code class="language-none">Clustering.initseeds_by_costs</code></pre><pre><code class="language-none">Clustering.initseeds_by_costs!</code></pre><pre><code class="language-none">Clustering.kmeans</code></pre><pre><code class="language-none">Clustering.kmeans!</code></pre><pre><code class="language-none">Clustering.kmeans_opts</code></pre><pre><code class="language-none">Clustering.kmeanspp_initialize!</code></pre><pre><code class="language-none">Clustering.kmedoids</code></pre><pre><code class="language-none">Clustering.kmedoids!</code></pre><pre><code class="language-none">Clustering.kmpp</code></pre><pre><code class="language-none">Clustering.kmpp_by_costs</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.mcl" href="#Clustering.mcl"><code>Clustering.mcl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mcl(adj::Matrix; [keyword arguments])::MCLResult</code></pre><p>Identify clusters in the weighted graph using Markov Clustering Algorithm (MCL).</p><p><strong>Arguments</strong></p><ul><li><code>adj::Matrix{Float64}</code>: adjacency matrix that defines the weighted graph to cluster</li><li><code>add_loops::Bool</code>: whether edges of weight 1.0 from the node to itself should be appended to the graph (enabled by default)</li><li><code>expansion::Number</code>: MCL expansion constant (2)</li><li><code>inflation::Number</code>: MCL inflation constant (2.0)</li><li><code>save_final_matrix::Bool</code>: save final equilibrium state in the result, otherwise leave it empty; disabled by default, could be useful if MCL doesn&#39;t converge</li><li><code>max_iter::Integer</code>: max number of MCL iterations</li><li><code>tol::Number</code>: MCL adjacency matrix convergence threshold</li><li><code>prune_tol::Number</code>: pruning threshold</li><li><code>display::Symbol</code>: <code>:none</code> for no output or <code>:verbose</code> for diagnostic messages</li></ul><p>See <a href="http://micans.org/mcl">original MCL implementation</a>.</p><p>Ref: Stijn van Dongen, &quot;Graph clustering by flow simulation&quot;, 2001</p></div></div></section><pre><code class="language-none">Clustering.merge_clusters!</code></pre><pre><code class="language-none">Clustering.merge_trees!</code></pre><pre><code class="language-none">Clustering.nclusters</code></pre><pre><code class="language-none">Clustering.nearest_neighbor</code></pre><pre><code class="language-none">Clustering.nmerges</code></pre><pre><code class="language-none">Clustering.nnodes</code></pre><pre><code class="language-none">Clustering.ntrees</code></pre><pre><code class="language-none">Clustering.printupper</code></pre><pre><code class="language-none">Clustering.push_merge!</code></pre><pre><code class="language-none">Clustering.randindex</code></pre><pre><code class="language-none">Clustering.randseed_initialize!</code></pre><pre><code class="language-none">Clustering.repick_unused_centers</code></pre><pre><code class="language-none">Clustering.rorder!</code></pre><pre><code class="language-none">Clustering.sample</code></pre><pre><code class="language-none">Clustering.sample!</code></pre><pre><code class="language-none">Clustering.seeding_algorithm</code></pre><pre><code class="language-none">Clustering.sil_aggregate_dists</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.silhouettes" href="#Clustering.silhouettes"><code>Clustering.silhouettes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">silhouettes(assignments::AbstractVector, [counts,] dists)
silhouettes(clustering::ClusteringResult, dists)</code></pre><p>Compute silhouette values for individual points w.r.t. given clustering.</p><ul><li><code>assignments</code> the vector of point assignments (cluster indices)</li><li><code>counts</code> the optional vector of cluster sizes (how many points assigned to each cluster; should match <code>assignments</code>)</li><li><code>clustering</code> the output of some clustering method</li><li><code>dists</code> point×point pairwise distance matrix</li></ul><p>Returns a vector of silhouette values for each individual point.</p><p><code>mean(silhouettes(...))</code> could be used as a measure of clustering quality; higher values indicate better separation of clusters w.r.t. distances provided in <code>dists</code>.</p><p><strong>References</strong></p><ol><li><a href="http://en.wikipedia.org/wiki/Silhouette_(clustering)">Silhouette Wikipedia page</a>.</li><li>Peter J. Rousseeuw (1987). &quot;Silhouettes: a Graphical Aid to the Interpretation and Validation of Cluster Analysis&quot;. Computational and Applied Mathematics. 20: 53–65.</li></ol></div></div></section><pre><code class="language-none">Clustering.slicemaximum</code></pre><pre><code class="language-none">Clustering.slicemean</code></pre><pre><code class="language-none">Clustering.sliceminimum</code></pre><pre><code class="language-none">Clustering.tree_elems</code></pre><pre><code class="language-none">Clustering.tree_size</code></pre><pre><code class="language-none">Clustering.update!</code></pre><pre><code class="language-none">Clustering.update_assignments!</code></pre><pre><code class="language-none">Clustering.update_centers!</code></pre><pre><code class="language-none">Clustering.update_distance_after_merge!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.update_exploration_list!" href="#Clustering.update_exploration_list!"><code>Clustering.update_exploration_list!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">update_exploration_list!(adj_list, exploration_list, visited)</code></pre><p>Update the queue for expanding the cluster</p><p><strong>Input</strong></p><ul><li><code>adj_list :: Vector{Int}</code>: indices of the neighboring points</li><li><code>exploration_list :: Vector{Int}</code>: the indices that  will be explored in the future</li><li><code>visited :: Vector{Bool}</code>: a flag to indicate whether a point has been explored already</li></ul></div></div></section><pre><code class="language-none">Clustering.update_weights!</code></pre><pre><code class="language-none">Clustering.updatemin!</code></pre><pre><code class="language-none">Clustering.varinfo</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clustering.vmeasure" href="#Clustering.vmeasure"><code>Clustering.vmeasure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vmeasure(assign1, assign2; β = 1.0)</code></pre><p>V-measure between two clustering assignments.</p><p><code>assign1</code> and <code>assign2</code> can be either <code>ClusteringResult</code> objects or assignments vectors (<code>AbstractVector{&lt;:Integer}</code>).</p><p>The <code>β</code> parameter defines trade-off between <em>homogeneity</em> and <em>completeness</em>:</p><ul><li>if <code>β</code> is greater than 1, <em>completeness</em> is weighted more strongly,</li><li>if <code>β</code> is less than 1, <em>homogeneity</em> is weighted more strongly.</li></ul><p><em>Ref:</em> Andrew Rosenberg and Julia Hirschberg, 2007. &quot;V-Measure: A conditional entropy-based external cluster evaluation measure&quot;</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
