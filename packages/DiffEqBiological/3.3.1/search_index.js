var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#DiffEqBiological.jl-1",
    "page": "Readme",
    "title": "DiffEqBiological.jl",
    "category": "section",
    "text": "(Image: Join the chat at https://gitter.im/JuliaDiffEq/Lobby) (Image: Build Status) (Image: Build status) (Image: Coverage Status) (Image: codecov.io)Full documentation is in the DifferentialEquations.jl models documentation"
},

{
    "location": "#The-Reaction-DSL-1",
    "page": "Readme",
    "title": "The Reaction DSL",
    "category": "section",
    "text": "The @reaction_network DSL allows you to define reaction networks in a more scientific format. Its input is a set of chemical reactions and from them it generates a reaction network object which can be used as input to ODEProblem, SDEProblem and JumpProblem constructors.The basic syntax isrn = @reaction_network rType begin\n  2.0, X + Y --> XY               \n  1.0, XY --> Z            \nendwhere each line corresponds to a chemical reaction. The input rType designates the type of this instance (all instances will inherit from the abstract type AbstractReactionNetwork).The DSL can handle several types of arrows, in both backwards and forward direction. If a bi-directional arrow is used two reaction rates must be designated. These two reaction networks are identicalrn1 = @reaction_network rType begin\n  2.0, X + Y → XY               \n  1.0, XY > Z       \n  1.0, X + Y ← XY               \n  0.5, XY < Z           \nend\nrn1 = @reaction_network rType begin\n  (2.0,1.0), X + Y ↔ XY               \n  (1.0, 0.5), XY ⟷ Z       \nendThe empty set can be used for production or degradation and is declared using either 0 or ∅. Integers denote the number of each reactant partaking in the reaction.rn1 = @reaction_network rType begin\n  2.0, 2X --> 0        \n  2.0, ∅ --> X  \nendMultiple reactions can be declared in a single linern = @reaction_network rType begin\n  2.0, (X,Y) --> 0                   #Identical to reactions [2.0, X --> 0] and [2.0, Y --> 0]\n  (2.0, 1.0), (X,Y) --> 0            #Identical to reactions [2.0, X --> 0] and [1.0, X --> 0]\n  2.0, (X1,Y1) --> (X2,Y2)           #Identical to reactions [2.0, X1 --> X2] and [2.0, Y1 --> Y2]\n  (2.0,1.0), X + Y ↔ XY              #Identical to reactions [2.0, X + Y --> XY] and [1.0, XY --> X + Y].\n  ((2.0,1.0),(1.0,2.0)), (X,Y) ↔ 0   #Identical to reactions [(2.0,1.0), X ↔ 0] and [(1.0,2.0), Y ↔ 0].\nend\n  ```\nParameters can be added to the network by declaring them after the reaction network. Parameters can only exist in the reaction rate and not as a part of the reaction.julia rn = @reaction_network rType begin     (kB, kD), X + Y ↔ XY end kB, kD p = [2.0, 1.0]The parameter set `p` must be passed to the problem constructor. The parameter values can be changed after the reaction network is defined.\n\nThe reaction rate do not need to be constant, but maybe depend on the concentration of the reactants.julia rn = @reaction_network rType begin     (1.0,2XY), X + Y ↔ XY endThe hill function `hill(x,v,K,n) = v*(x^n)/(x^n + K^n)` can be used, as well as the michaelis menten function (the hill function with `n = 1`).julia rn = @reaction_network rType begin     (1.0,hill(XY,1.5,2.0,2)), X + Y ↔ XY endBy using the `@reaction_func` macro it is possible to define your own functions, which may then be used when creating new reaction networks.julia @reactionfunc hill2(x, v, k) = v*x^2/(k^2+x^2)     @reactionnetwork macro can see. rn = @reaction_network rType begin   (1.0,hill2(XY,1.5,2.0)), X + Y ↔ XY end\nReaction rates are automatically adjusted according mass kinetics, including taking special account of higher order terms like `2X -->`. This can be disabled using any non-filled arrow (`⇐, ⟽, ⇒, ⟾, ⇔, ⟺`), in which case the reaction rate will be exactly as input. E.g the two reactions in\nrn = @reaction_network rType begin\n    2.0, X + Y --> XY\n    2.0*X*Y X + Y ⟾ XY\nend\nwill both have reaction rate equal to 2[X][Y].\n\nOnce a reaction network has been created it can be passed as input to either one of the `ODEProblem`, `SDEProblem` or `JumpProblem` constructors.julia   probODE = ODEProblem(rn, args...; kwargs...)         probSDE = SDEProblem(rn, args...; kwargs...)   probJump = JumpProblem(prob,aggregator::Direct,rn)the output problems may then be used as normal input to the solvers of the `DifferentialEquations` package.\n\nThe noise used by the SDEProblem will correspond to the Chemical Langevin Equations. However it is possible to scale the amount of noise be declaring a noise parameter. This will be done after declaring the type but before the network.julia rn = @reaction_network \\eta begin     2.0, X + Y ↔ XY end p = [0.5]The noise term is then added as an additional parameter to the network (by default the last parameter in the parameter array, unless also declared after the reaction network among the other parameters). By reducing (or increasing) the noise term the amount stochastic fluctuations in the system can be reduced (or increased).\n\nIt is possible to access expressions corresponding to the functions determining the deterministic and stochastic development of the network using.julia   fexpr = rn.ffunc   gexpr = rn.gfunc ``` This can e.g. be used to generate LaTeX code corresponding to the system."
},

{
    "location": "autodocs/#DiffEqBiological.@reaction_network",
    "page": "Docstrings",
    "title": "DiffEqBiological.@reaction_network",
    "category": "macro",
    "text": "Macro that inputs an expression corresponding to a reaction network and output a Reaction Network Structure that can be used as input to generation of SDE and ODE and Jump problems. Most arrows accepted (both right, left and bi drectional arrows). Note that while –> is a correct arrow, neither <– nor <–> works. Using non-filled arrows (⇐, ⟽, ⇒, ⟾, ⇔, ⟺) will disable mass kinetics and lets you cutomize reaction rates yourself. Use 0 or ∅ for degradation/creation to/from nothing. Example systems:     ### Basic Usage ###     rn = @reaction_network rType begin #Creates a reaction network of type rType.         2.0, X + Y –> XY                  #This will have reaction rate corresponding to 2.0*[X][Y]         2.0, XY ← X + Y                    #Identical to 2.0, X + Y –> XY     end\n\n### Manipulating Reaction Rates ###\nrn = @reaction_network rType begin\n    2.0, X + Y ⟾ XY                   #Ignores mass kinetics. This will have reaction rate corresponding to 2.0.\n    2.0X, X + Y --> XY                 #Reaction rate needs not be constant. This will have reaction rate corresponding to 2.0*[X]*[X]*[Y].\n    XY+log(X)^2, X + Y --> XY          #Reaction rate accepts quite complicated expressions (user defined functions must first be registered using the @reaction_func macro).\n    hill(XY,2,2,2), X + Y --> XY       #Reaction inis activated by XY according to a hill function. hill(x,v,K,N).\n    mm(XY,2,2), X + Y --> XY           #Reaction inis activated by XY according to a michaelis menten function. mm(x,v,K).\nend\n\n### Multipple Reactions on a Single Line ###\nrn = @reaction_network rType begin\n    (2.0,1.0), X + Y ↔ XY              #Identical to reactions (2.0, X + Y --> XY) and (1.0, XY --> X + Y).\n    2.0, (X,Y) --> 0                   #This corresponds to both X and Y degrading at rate 2.0.\n    (2.0, 1.0), (X,Y) --> 0            #This corresponds to X and Y degrading at rates 2.0 and 1.0, respectively.\n    2.0, (X1,Y1) --> (X2,Y2)           #X1 and Y1 becomes X2 and Y2, respectively, at rate 2.0.\nend\n\n### Adding Parameters ###\nkB = 2.0; kD = 1.0\np = [kB, kD]\np = []\nrn = @reaction_network type begin\n    (kB, kD), X + Y ↔ XY            #Lets you define parameters outside on network. Parameters can be changed without recalling the network.\nend kB, kD\n\n### Defining New Functions ###\n@reaction_func my_hill_repression(x, v, k, n) = v*k^n/(k^n+x^n)     #Creates and adds a new function that the @reaction_network macro can see.\nr = @reaction_network MyReactionType begin\n    my_hill_repression(x, v_x, k_x, n_x), 0 --> x                       #After it has been added in @reaction_func the function can be used when defining new reaction networks.\nend v_x k_x n_x\n\n### Simulating Reaction Networks ###\nprobODE = ODEProblem(rn, args...; kwargs...)        #Using multiple dispatch the reaction network can be used as input to create ODE, SDE and Jump problems.\nprobSDE = SDEProblem(rn, args...; kwargs...)\nprobJump = JumpProblem(prob,aggregator::Direct,rn)\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "DiffEqBiological.@reaction_funcDiffEqBiological.@reaction_networkDiffEqBiological.BracketDataDiffEqBiological.ConstantRateJumpDiffEqBiological.DiffEqBiologicalDiffEqBiological.DiffEqJumpDiffEqBiological.DirectDiffEqBiological.DirectCRDiffEqBiological.DirectFWDiffEqBiological.ExtendedJumpArrayDiffEqBiological.FRMDiffEqBiological.FRMFWDiffEqBiological.JumpProblemDiffEqBiological.JumpSetDiffEqBiological.MassActionJumpDiffEqBiological.NRMDiffEqBiological.RSSADiffEqBiological.ReactantStructDiffEqBiological.ReactionStructDiffEqBiological.RegularJumpDiffEqBiological.RegularSSADiffEqBiological.SDEProblemDiffEqBiological.SSAStepperDiffEqBiological.SimpleTauLeapingDiffEqBiological.SortingDirectDiffEqBiological.SplitCoupledJumpProblemDiffEqBiological.SteadyStateProblemDiffEqBiological.VariableRateJumpDiffEqBiological.add_reactants!DiffEqBiological.bwd_arrowsDiffEqBiological.calculate_jacDiffEqBiological.coordinateDiffEqBiological.depgraph_from_networkDiffEqBiological.double_arrowsDiffEqBiological.empty_setDiffEqBiological.evalDiffEqBiological.expr_arr_to_blockDiffEqBiological.funcdictDiffEqBiological.fwd_arrowsDiffEqBiological.get_fDiffEqBiological.get_gDiffEqBiological.get_jumpsDiffEqBiological.get_net_stoichDiffEqBiological.get_num_majumpsDiffEqBiological.get_parametersDiffEqBiological.get_reactantsDiffEqBiological.get_reactionsDiffEqBiological.get_stoch_diffDiffEqBiological.get_substrate_stoichDiffEqBiological.get_tup_argDiffEqBiological.hillDiffEqBiological.hill_nameDiffEqBiological.includeDiffEqBiological.initDiffEqBiological.make_funcDiffEqBiological.make_majumpDiffEqBiological.maketypeDiffEqBiological.mass_rate_DEDiffEqBiological.mass_rate_SSADiffEqBiological.mmDiffEqBiological.mm_nameDiffEqBiological.needs_depgraphDiffEqBiological.needs_vartojumps_mapDiffEqBiological.network_to_jumpsetDiffEqBiological.no_mass_arrowsDiffEqBiological.push_reactionsDiffEqBiological.rate_to_indicesDiffEqBiological.recursive_clean!DiffEqBiological.recursive_containsDiffEqBiological.recursive_contentDiffEqBiological.recursive_replace!DiffEqBiological.replace_namesDiffEqBiological.rxidxs_to_jidxs_mapDiffEqBiological.solveDiffEqBiological.solve!DiffEqBiological.spec_to_dep_jumps_mapDiffEqBiological.species_to_indicesDiffEqBiological.tup_lengDiffEqBiological.update_reaction_info"
},

]}
