<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme Â· Dierckx.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dierckx.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Install-(Julia-0.7-and-later)-1">Install (Julia 0.7 and later)</a></li><li><a class="toctext" href="#Install-(Julia-0.6-and-earlier)-1">Install (Julia 0.6 and earlier)</a></li><li><a class="toctext" href="#Example-Usage-1">Example Usage</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li><li><a class="toctext" href="#Translation-from-scipy.interpolate-1">Translation from scipy.interpolate</a></li><li><a class="toctext" href="#License-1">License</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Dierckx.jl-1" href="#Dierckx.jl-1">Dierckx.jl</a></h1><p><em>Julia library for 1-d and 2-d splines</em></p><p><a href="https://travis-ci.org/kbarbary/Dierckx.jl"><img src="https://img.shields.io/travis/kbarbary/Dierckx.jl.svg?style=flat-square&amp;label=linux" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/kbarbary/dierckx-jl/branch/master"><img src="https://img.shields.io/appveyor/ci/kbarbary/dierckx-jl.svg?style=flat-square&amp;label=windows" alt="Build status"/></a> <a href="https://coveralls.io/r/kbarbary/Dierckx.jl?branch=master"><img src="http://img.shields.io/coveralls/kbarbary/Dierckx.jl.svg?style=flat-square" alt="Coverage Status"/></a></p><p>This is a Julia wrapper for the <a href="http://www.netlib.org/dierckx/index.html">dierckx</a> Fortran library, the same library underlying the spline classes in scipy.interpolate. Some of the functionality here overlaps with <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations.jl</a>, a pure-Julia interpolation package.  Take a look at it if you have a use case not covered here.</p><p>All new development on <code>Dierckx.jl</code> will be for Julia v0.7 and above. The <code>master</code> branch is therefore incompatible with earlier versions of Julia. </p><h3><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h3><ul><li>Implements B-splines (basis splines).</li><li>Splines from first order to fifth order; default is third order (cubic).</li><li>Fit and evaluate 1-d and 2-d splines on irregular grids.</li><li>Fit and evaluate 2-d splines at unstructured points.</li><li>Fit &quot;smooth&quot; (non-interpolating) splines with adjustable smoothing factor s.</li><li>Derivatives, integrals and roots of 1-d splines.</li><li>Parametric B-splines.</li></ul><h2><a class="nav-anchor" id="Install-(Julia-0.7-and-later)-1" href="#Install-(Julia-0.7-and-later)-1">Install (Julia 0.7 and later)</a></h2><pre><code class="language-julia">(v1.0) pkg&gt; add Dierckx</code></pre><p>(Type <code>]</code> to enter package mode.) No Fortran compiler is requred on any platform.</p><h2><a class="nav-anchor" id="Install-(Julia-0.6-and-earlier)-1" href="#Install-(Julia-0.6-and-earlier)-1">Install (Julia 0.6 and earlier)</a></h2><pre><code class="language-julia">julia&gt; Pkg.add(&quot;Dierckx&quot;)</code></pre><p>The Fortran library source code is distributed with the package, so you need a Fortran compiler on OSX or Linux. On Ubuntu, <code>sudo apt-get install gfortran</code> will do it.</p><p>On Darwin, <code>gfortran</code> comes bundled with <code>gcc</code>, so after instslling Homebrew, <code>brew install gcc</code> should install <code>gfortran</code>.</p><p>On Windows, a compiled dll will be downloaded.</p><h2><a class="nav-anchor" id="Example-Usage-1" href="#Example-Usage-1">Example Usage</a></h2><pre><code class="language-julia">using Dierckx</code></pre><p>Fit a 1-d spline to some input data (points can be unevenly spaced):</p><pre><code class="language-julia">x = [0., 1., 2., 3., 4.]
y = [-1., 0., 7., 26., 63.]  # x.^3 - 1.
spl = Spline1D(x, y)</code></pre><p>Evaluate the spline at some new points:</p><pre><code class="language-julia">spl([1.5, 2.5])  # result = [2.375, 14.625]
spl(1.5)  # result = 2.375</code></pre><p>Equivalent to the above:</p><pre><code class="language-julia">evaluate(spl, [1.5, 2.5])
evaluate(spl, 1.5)</code></pre><p>Evaluate derivative, integral, or roots:</p><pre><code class="language-julia">derivative(spl, 1.5)  # derivate at x=1.5; result is 5.75
integrate(spl, 0., 4.)  # integrate from x=0 to x=4; result is 60.0
roots(spl)  # result is [1.0]</code></pre><p><em>Note that <code>roots()</code> only works for cubic splines (k=3).</em></p><p>Fit a 2-d spline to data on a (possibly irregular) grid:</p><pre><code class="language-julia">x = [0.5, 2., 3., 4., 5.5, 8.]
y = [0.5, 2., 3., 4.]
z = [1. 2. 1. 2.;  # size is (length(x), length(y))
     1. 2. 1. 2.;
     1. 2. 3. 2.;
     1. 2. 2. 2.;
     1. 2. 1. 2.;
     1. 2. 3. 1.]

spline = Spline2D(x, y, z)</code></pre><p><em>Note that if you consider <code>z</code> as a matrix, <code>x</code> refers to row  coordinates and <code>y</code> refers to column coordinates.</em></p><p>Evaluate at element-wise points:</p><pre><code class="language-julia">xi = [1., 1.5, 2.3, 4.5, 3.3, 3.2, 3.]
yi = [1., 2.3, 5.3, 0.5, 3.3, 1.2, 3.]
zi = spline(xi, yi)  # 1-d array of length 7
zi = evaluate(spline, xi, yi)  # equivalent to previous line</code></pre><p>Evaluate at grid spanned by input arrays:</p><pre><code class="language-julia">xi = [1., 1.5, 2.3, 4.5]
yi = [1., 2.3, 5.3]
zi = evalgrid(spline, xi, yi)  # 2-d array of size (4, 3)</code></pre><h2><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h2><h3><a class="nav-anchor" id="d-Splines-1" href="#d-Splines-1">1-d Splines</a></h3><pre><code class="language-julia">Spline1D(x, y; w=ones(length(x)), k=3, bc=&quot;nearest&quot;, s=0.0)
Spline1D(x, y, xknots; w=ones(length(x)), k=3, bc=&quot;nearest&quot;)</code></pre><ul><li><p>Create a spline of degree <code>k</code> (1 = linear, 2 = quadratic, 3 = cubic, up to 5) from 1-d arrays <code>x</code> and <code>y</code>. The parameter <code>bc</code> specifies the behavior when evaluating the spline outside the support domain, which is <code>(minimum(x), maximum(x))</code>. The allowed values are <code>&quot;nearest&quot;</code>, <code>&quot;zero&quot;</code>, <code>&quot;extrapolate&quot;</code>, <code>&quot;error&quot;</code>.</p><p>In the first form, the number and positions of knots are chosen automatically. The smoothness of the spline is then achieved by minimalizing the discontinuity jumps of the <code>k</code>th derivative of the spline at the knots. The amount of smoothness is determined by the condition that <code>sum((w[i]*(y[i]-spline(x[i])))**2) &lt;= s</code>, with <code>s</code> a given non-negative constant, called the smoothing factor. The number of knots is increased until the condition is satisfied. By means of this parameter, the user can control the tradeoff between closeness of fit and smoothness of fit of the approximation.  if <code>s</code> is too large, the spline will be too smooth and signal will be lost ; if <code>s</code> is too small the spline will pick up too much noise. in the extreme cases the program will return an interpolating spline if <code>s=0.0</code> and the weighted least-squares polynomial of degree <code>k</code> if <code>s</code> is very large.</p><p>In the second form, the knots are supplied by the user. There is no smoothing parameter in this form. The program simply minimizes the discontinuity jumps of the <code>k</code>th derivative of the spline at the given knots.</p></li></ul><pre><code class="language-julia">evaluate(spl, x)</code></pre><ul><li>Evalute the 1-d spline <code>spl</code> at points given in <code>x</code>, which can be a 1-d array or scalar. If a 1-d array, the values must be monotonically increasing.</li></ul><pre><code class="language-julia">derivative(spl, x; nu=1)</code></pre><ul><li>Evaluate the <code>nu</code>-th derivative of the spline at points in <code>x</code>.</li></ul><pre><code class="language-julia">integrate(spl, a, b)</code></pre><ul><li>Definite integral of spline between <code>x=a</code> and <code>x=b</code>.</li></ul><pre><code class="language-julia">roots(spl; maxn=8)</code></pre><ul><li>For cubic splines (<code>k=3</code>) only, find roots. Only up to <code>maxn</code> roots are returned. A warning is issued if the spline has more roots than the number returned.</li></ul><h3><a class="nav-anchor" id="Parametric-Splines-1" href="#Parametric-Splines-1">Parametric Splines</a></h3><p>These are the B-spline representation of a curve through N-dimensional space.</p><pre><code class="language-julia">ParametricSpline(X; s=0.0, ...)
ParametricSpline(u, X; s=0.0, ...)
ParametricSpline(X, knots, ...)
ParametricSpline(u, X, knots, ...)</code></pre><ul><li><p><code>X</code> is a 2-d array with size <code>(N, m)</code>: <code>N</code> is the number of dimensions of the space (must be between 1 and 10) and <code>m</code> is the number of points. <code>X[:, i]</code> gives the coordinates of the <code>i</code>th point.</p></li><li><p><code>u</code> is a 1-d array giving parameter values at each of the <code>m</code> points. If not given, values are calculated automatically.</p></li><li><p><code>knots</code> is a 1-d array giving user-specified knots, if desired.</p></li></ul><p>Keyword arguemnts common to all constructor methods:</p><ul><li><code>w</code>: weight applied to each point (length <code>m</code> 1-d array).</li><li><code>k</code>: Spline order (between 1 and 5; default 3).</li><li><code>bc</code>: Boundary condition (default <code>&#39;nearest&#39;</code>).</li><li><code>periodic</code>: Treat curve as periodic? (Default is <code>false</code>).</li></ul><h3><a class="nav-anchor" id="d-Splines-2" href="#d-Splines-2">2-d Splines</a></h3><pre><code class="language-julia">Spline2D(x, y, z; w=ones(length(x)), kx=3, ky=3, s=0.0)
Spline2D(x, y, z; kx=3, ky=3, s=0.0)</code></pre><ul><li><p>Fit a 2-d spline to the input data. <code>x</code> and <code>y</code> must be 1-d arrays.</p><p>If <code>z</code> is also a 1-d array, the inputs are assumed to represent unstructured data, with <code>z[i]</code> being the function value at point <code>(x[i], y[i])</code>. In this case, the lengths of all inputs must match.</p><p>If <code>z</code> is a 2-d array, the data are assumed to be gridded: <code>z[i, j]</code> is the function value at <code>(x[i], y[j])</code>. In this case, it is required that <code>size(z) == (length(x), length(y))</code>. (Note that when interpreting <code>z</code> as a matrix, <code>x</code> gives the row coordinates and <code>y</code> gives the column coordinates.)</p></li></ul><pre><code class="language-julia">evaluate(spl, x, y)</code></pre><ul><li>Evalute the 2-d spline <code>spl</code> at points <code>(x[i], y[i])</code>. Inputs can be Vectors or scalars. Points outside the domain of the spline are set to the values at the boundary.</li></ul><pre><code class="language-julia">evalgrid(spl, x, y)</code></pre><ul><li><p>Evaluate the 2-d spline <code>spl</code> at the grid points spanned by the coordinate arrays <code>x</code> and <code>y</code>. The input arrays must be monotonically increasing. The output is a 2-d array with size <code>(length(x), length(y))</code>: <code>output[i, j]</code> is the function value at <code>(x[i], y[j])</code>. In other words, when interpreting the result as a matrix, <code>x</code> gives the row coordinates and <code>y</code> gives the column coordinates.</p></li><li><p>integral of a 2-d spline over the domain <code>[x0, x1]*[y0, y1]</code></p></li></ul><pre><code class="language-julia">integrate(spl, x0, x1, y0, y1)</code></pre><h2><a class="nav-anchor" id="Translation-from-scipy.interpolate-1" href="#Translation-from-scipy.interpolate-1">Translation from scipy.interpolate</a></h2><p>The <code>Spline</code> classes in scipy.interpolate are also thin wrappers for the Dierckx Fortran library. The performance of Dierckx.jl should be similar or better than the scipy.interpolate classes. (Better for small arrays where Python overhead is more significant.) The equivalent of a specific classes in scipy.interpolate:</p><table><tr><th>scipy.interpolate class</th><th>Dierckx.jl constructor method</th></tr><tr><td>UnivariateSpline</td><td><code>Spline1D(x, y; s=length(x))</code></td></tr><tr><td>InterpolatedUnivariateSpline</td><td><code>Spline1D(x, y; s=0.0)</code></td></tr><tr><td>LSQUnivariateSpline</td><td><code>Spline1D(x, y, xknots)</code></td></tr><tr><td>SmoothBivariateSpline</td><td><code>Spline2D(x, y, z; s=length(x))</code></td></tr><tr><td>LSQBivariateSpline</td><td></td></tr><tr><td>RectBivariateSpline</td><td><code>Spline2D(x, y, z; s=0.0)</code> (z = 2-d array)</td></tr><tr><td>SmoothSphereBivariateSpline</td><td></td></tr><tr><td>LSQSphereBivariateSpline</td><td></td></tr><tr><td>RectSphereBivariateSpline</td><td></td></tr></table><p>Parametric splines:</p><table><tr><th>scipy.interpolate function</th><th>Dierckx.jl constructor method</th></tr><tr><td><code>splprep(X)</code></td><td><code>ParametricSpline(X)</code></td></tr><tr><td><code>splprep(X, u=...)</code></td><td><code>ParametricSpline(u, X)</code></td></tr><tr><td><code>splprep(X, t=...)</code></td><td><code>ParametricSpline(X, t)</code>  (t = knots)</td></tr><tr><td><code>splprep(X, u=..., t=...)</code></td><td><code>ParametricSpline(u, X, t)</code></td></tr></table><h2><a class="nav-anchor" id="License-1" href="#License-1">License</a></h2><p>Dierckx.jl is distributed under a 3-clause BSD license. See LICENSE.md for details. The real*8 version of the Dierckx Fortran library as well as some test cases and error messages are copied from the scipy package, which is distributed under this license.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
