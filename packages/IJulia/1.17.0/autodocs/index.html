<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · IJulia.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IJulia.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">IJulia.@verror_show</code></pre><pre><code class="language-none">IJulia.@vprintln</code></pre><pre><code class="language-none">IJulia.CommManager</code></pre><pre><code class="language-none">IJulia.IJULIA_DEBUG</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.IJulia" href="#IJulia.IJulia"><code>IJulia.IJulia</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>IJulia</strong> is a <a href="http://julialang.org/">Julia-language</a> backend combined with the <a href="http://jupyter.org/">Jupyter</a> interactive environment (also used by <a href="http://ipython.org/">IPython</a>).  This combination allows you to interact with the Julia language using Jupyter/IPython&#39;s powerful <a href="http://ipython.org/notebook.html">graphical notebook</a>, which combines code, formatted text, math, and multimedia in a single document.</p><p>The <code>IJulia</code> module is used in three ways</p><ul><li><p>Typing <code>using IJulia; notebook()</code> will launch the Jupyter notebook interface in your web browser.  This is an alternative to launching <code>jupyter notebook</code> directly from your operating-system command line.</p></li><li><p>In a running notebook, the <code>IJulia</code> module is loaded and <code>IJulia.somefunctions</code> can be used to interact with the running IJulia kernel:</p><ul><li><code>IJulia.load(filename)</code> and <code>IJulia.load_string(s)</code> load the contents of a file or a string, respectively, into a notebook cell.</li><li><code>IJulia.clear_output()</code> to clear the output from the notebook cell, useful for simple animations.</li><li><code>IJulia.clear_history()</code> to clear the history variables <code>In</code> and <code>Out</code>.</li><li><code>push_X_hook(f)</code> and <code>pop_X_hook(f)</code>, where <code>X</code> is either <code>preexecute</code>, <code>postexecute</code>, or <code>posterror</code>.  This allows you to insert a &quot;hook&quot; function into a list of functions to execute when notebook cells are evaluated.</li><li><code>IJulia.set_verbose()</code> enables verbose output about what IJulia is doing internally; this is mainly used for debugging.</li></ul></li><li><p>It is used internally by the IJulia kernel when talking to the Jupyter server.</p></li></ul></div></div></section><pre><code class="language-none">IJulia.IJuliaStdio</code></pre><pre><code class="language-none">IJulia.IJulia_RNG</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.In" href="#IJulia.In"><code>IJulia.In</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>In</code> is a global dictionary of input strings, where <code>In[n]</code> returns the string for input cell <code>n</code> of the notebook (as it was when it was <em>last evaluated</em>).</p></div></div></section><pre><code class="language-none">IJulia.InlineDisplay</code></pre><pre><code class="language-none">IJulia.JUPYTER</code></pre><pre><code class="language-none">IJulia.MiniREPL</code></pre><pre><code class="language-none">IJulia.Msg</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.Out" href="#IJulia.Out"><code>IJulia.Out</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>Out</code> is a global dictionary of output values, where <code>Out[n]</code> returns the output from the last evaluation of cell <code>n</code> in the notebook.</p></div></div></section><pre><code class="language-none">IJulia.SOFTSCOPE</code></pre><pre><code class="language-none">IJulia.__init__</code></pre><pre><code class="language-none">IJulia._showable</code></pre><pre><code class="language-none">IJulia.alias_magic_help</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.ans" href="#IJulia.ans"><code>IJulia.ans</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>ans</code> is a global variable giving the value returned by the last notebook cell evaluated.</p></div></div></section><pre><code class="language-none">IJulia.bufs</code></pre><pre><code class="language-none">IJulia.capture_stderr</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.capture_stdout" href="#IJulia.capture_stdout"><code>IJulia.capture_stdout</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>The IJulia kernel captures all <a href="https://en.wikipedia.org/wiki/Standard_streams">stdout and stderr</a> output and redirects it to the notebook.   When debugging IJulia problems, however, it can be more convenient to <em>not</em> capture stdout and stderr output (since the notebook may not be functioning). This can be done by editing <code>IJulia.jl</code> to set <code>capture_stderr</code> and/or <code>capture_stdout</code> to <code>false</code>.</p></div></div></section><pre><code class="language-none">IJulia.cd_magic_help</code></pre><pre><code class="language-none">IJulia.check_prompt_streams</code></pre><pre><code class="language-none">IJulia.chr2ind</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.clear_history" href="#IJulia.clear_history"><code>IJulia.clear_history</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clear_history([indices])</code></pre><p>The <code>clear_history()</code> function clears all of the input and output history stored in the running IJulia notebook.  This is sometimes useful because all cell outputs are remember in the <code>Out</code> global variable, which prevents them from being freed, so potentially this could waste a lot of memory in a notebook with many large outputs.</p><p>The optional <code>indices</code> argument is a collection of indices indicating a subset of cell inputs/outputs to clear.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.clear_output" href="#IJulia.clear_output"><code>IJulia.clear_output</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clear_output(wait=false)</code></pre><p>Call <code>clear_output()</code> to clear visible output from the current notebook cell.  Using <code>wait=true</code> clears the output only when new output is available, which reduces flickering and is useful for simple animations.</p></div></div></section><pre><code class="language-none">IJulia.complete_request</code></pre><pre><code class="language-none">IJulia.complete_type</code></pre><pre><code class="language-none">IJulia.complete_types</code></pre><pre><code class="language-none">IJulia.connect_request</code></pre><pre><code class="language-none">IJulia.connection_file</code></pre><pre><code class="language-none">IJulia.control</code></pre><pre><code class="language-none">IJulia.copy_config</code></pre><pre><code class="language-none">IJulia.current_module</code></pre><pre><code class="language-none">IJulia.debug_magic_help</code></pre><pre><code class="language-none">IJulia.default_jupyter_data_dir</code></pre><pre><code class="language-none">IJulia.depfile</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_dict" href="#IJulia.display_dict"><code>IJulia.display_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate a dictionary of <code>mime_type =&gt; data</code> pairs for all registered MIME types. This is the format that Jupyter expects in display<em>data and execute</em>result messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_mimejson" href="#IJulia.display_mimejson"><code>IJulia.display_mimejson</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate the preferred json-MIME representation of x.</p><p>Returns a tuple with the selected MIME type and the representation of the data using that MIME type (as a <code>JSONText</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_mimestring" href="#IJulia.display_mimestring"><code>IJulia.display_mimestring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Generate the preferred MIME representation of x.</p><p>Returns a tuple with the selected MIME type and the representation of the data using that MIME type.</p></div></div></section><pre><code class="language-none">IJulia.displayable</code></pre><pre><code class="language-none">IJulia.displayqueue</code></pre><pre><code class="language-none">IJulia.docdict</code></pre><pre><code class="language-none">IJulia.edit_magic_help</code></pre><pre><code class="language-none">IJulia.env_magic_help</code></pre><pre><code class="language-none">IJulia.error_content</code></pre><pre><code class="language-none">IJulia.eval</code></pre><pre><code class="language-none">IJulia.eventloop</code></pre><pre><code class="language-none">IJulia.exe</code></pre><pre><code class="language-none">IJulia.execute_msg</code></pre><pre><code class="language-none">IJulia.execute_payloads</code></pre><pre><code class="language-none">IJulia.execute_request</code></pre><pre><code class="language-none">IJulia.file_magic_help</code></pre><pre><code class="language-none">IJulia.find_jupyter_subcommand</code></pre><pre><code class="language-none">IJulia.find_parsestart</code></pre><pre><code class="language-none">IJulia.flush_all</code></pre><pre><code class="language-none">IJulia.generic_magic_help</code></pre><pre><code class="language-none">IJulia.get_log_preface</code></pre><pre><code class="language-none">IJulia.get_token</code></pre><pre><code class="language-none">IJulia.gui_magic_help</code></pre><pre><code class="language-none">IJulia.handlers</code></pre><pre><code class="language-none">IJulia.heartbeat</code></pre><pre><code class="language-none">IJulia.heartbeat_thread</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.history" href="#IJulia.history"><code>IJulia.history</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">history([io], [indices...])</code></pre><p>The <code>history()</code> function prints all of the input history stored in the running IJulia notebook in a format convenient for copying.</p><p>The optional <code>indices</code> argument is one or more indices or collections of indices indicating a subset input cells to print.</p><p>The optional <code>io</code> argument is for specifying an output stream. The default is <code>stdout</code>.</p></div></div></section><pre><code class="language-none">IJulia.history_magic_help</code></pre><pre><code class="language-none">IJulia.history_request</code></pre><pre><code class="language-none">IJulia.hmac</code></pre><pre><code class="language-none">IJulia.hmacstate</code></pre><pre><code class="language-none">IJulia.html_magic_help</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.ijulia_jsonmime_types" href="#IJulia.ijulia_jsonmime_types"><code>IJulia.ijulia_jsonmime_types</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>MIME types that when rendered (via stringmime) return JSON data. See <code>ijulia_mime_types</code> for a description of how MIME types are selected.</p><p>This is necessary to embed the JSON as is in the displaydata bundle (rather than as stringify&#39;d JSON).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.ijulia_mime_types" href="#IJulia.ijulia_mime_types"><code>IJulia.ijulia_mime_types</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>A vector of MIME types (or vectors of MIME types) that IJulia will try to render. IJulia will try to render every MIME type specified in the first level of the vector. If a vector of MIME types is specified, IJulia will include only the first MIME type that is renderable (this allows for the expression of priority and exclusion of redundant data).</p><p>For example, since &quot;text/plain&quot; is specified as a first-child of the array, IJulia will always try to include a &quot;text/plain&quot; representation of anything that is displayed. Since markdown and html are specified within a sub-vector, IJulia will always try to render &quot;text/markdown&quot;, and will only try to render &quot;text/html&quot; if markdown isn&#39;t possible.</p></div></div></section><pre><code class="language-none">IJulia.include</code></pre><pre><code class="language-none">IJulia.ind2chr</code></pre><pre><code class="language-none">IJulia.ind_to_utf16</code></pre><pre><code class="language-none">IJulia.init</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.inited" href="#IJulia.inited"><code>IJulia.inited</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>inited</code> is a global variable that is set to <code>true</code> if the IJulia kernel is running, i.e. in a running IJulia notebook.  To test whether you are in an IJulia notebook, therefore, you can check <code>isdefined(Main, :IJulia) &amp;&amp; IJulia.inited</code>.</p></div></div></section><pre><code class="language-none">IJulia.inspect_request</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.installkernel" href="#IJulia.installkernel"><code>IJulia.installkernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">installkernel(name::AbstractString, options::AbstractString...;
              specname::AbstractString,
              env=Dict())</code></pre><p>Install a new Julia kernel, where the given <code>options</code> are passed to the <code>julia</code> executable, the user-visible kernel name is given by <code>name</code> followed by the Julia version, and the <code>env</code> dictionary is added to the environment.</p><p>The new kernel name is returned by <code>installkernel</code>.  For example:</p><pre><code class="language-none">kernelpath = installkernel(&quot;Julia O3&quot;, &quot;-O3&quot;, env=Dict(&quot;FOO&quot;=&gt;&quot;yes&quot;))</code></pre><p>creates a new Julia kernel in which <code>julia</code> is launched with the <code>-O3</code> optimization flag and <code>FOO=yes</code> is included in the environment variables.</p><p>The returned <code>kernelpath</code> is the path of the installed kernel directory, something like <code>/...somepath.../kernels/julia-O3-1.0</code> (in Julia 1.0).  The <code>specname</code> argument can be passed to alter the name of this directory (which defaults to <code>name</code> with spaces replaced by hyphens).</p><p>You can uninstall the kernel by calling <code>rm(kernelpath, recursive=true)</code>.</p></div></div></section><pre><code class="language-none">IJulia.interrupt_request</code></pre><pre><code class="language-none">IJulia.ipy_mime</code></pre><pre><code class="language-none">IJulia.is_complete_request</code></pre><pre><code class="language-none">IJulia.israwtext</code></pre><pre><code class="language-none">IJulia.isyes</code></pre><pre><code class="language-none">IJulia.javascript_magic_help</code></pre><pre><code class="language-none">IJulia.jupyter_data_dir</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.jupyterlab" href="#IJulia.jupyterlab"><code>IJulia.jupyterlab</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jupyterlab(; dir=homedir(), detached=false)</code></pre><p>Similar to <code>IJulia.notebook()</code> but launches JupyterLab instead of the Jupyter notebook.</p></div></div></section><pre><code class="language-none">IJulia.kernel_info_request</code></pre><pre><code class="language-none">IJulia.kerneldir</code></pre><pre><code class="language-none">IJulia.latex_magic_help</code></pre><pre><code class="language-none">IJulia.launch</code></pre><pre><code class="language-none">IJulia.limitstringmime</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.load" href="#IJulia.load"><code>IJulia.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load(filename, replace=false)</code></pre><p>Load the file given by <code>filename</code> into a new input code cell in the running IJulia notebook, analogous to the <code>%load</code> magics in IPython. If the optional argument <code>replace</code> is <code>true</code>, then the file contents replace the <em>current</em> cell rather than creating a new cell.</p></div></div></section><pre><code class="language-none">IJulia.load_magic_help</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.load_string" href="#IJulia.load_string"><code>IJulia.load_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_string(s, replace=false)</code></pre><p>Load the string <code>s</code> into a new input code cell in the running IJulia notebook, somewhat analogous to the <code>%load</code> magics in IPython. If the optional argument <code>replace</code> is <code>true</code>, then <code>s</code> replaces the <em>current</em> cell rather than creating a new cell.</p></div></div></section><pre><code class="language-none">IJulia.lsmagic_help</code></pre><pre><code class="language-none">IJulia.magic_help</code></pre><pre><code class="language-none">IJulia.magic_help_string</code></pre><pre><code class="language-none">IJulia.magics_help</code></pre><pre><code class="language-none">IJulia.magics_regex</code></pre><pre><code class="language-none">IJulia.matplotlib_magic_help</code></pre><pre><code class="language-none">IJulia.max_bytes</code></pre><pre><code class="language-none">IJulia.max_output_per_request</code></pre><pre><code class="language-none">IJulia.metadata</code></pre><pre><code class="language-none">IJulia.minirepl</code></pre><pre><code class="language-none">IJulia.msg_header</code></pre><pre><code class="language-none">IJulia.msg_pub</code></pre><pre><code class="language-none">IJulia.msg_reply</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.n" href="#IJulia.n"><code>IJulia.n</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>IJulia.n</code> is the (integer) index of the last-evaluated notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.notebook" href="#IJulia.notebook"><code>IJulia.notebook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">notebook(; dir=homedir(), detached=false)</code></pre><p>The <code>notebook()</code> function launches the Jupyter notebook, and is equivalent to running <code>jupyter notebook</code> at the operating-system command-line.    The advantage of launching the notebook from Julia is that, depending on how Jupyter was installed, the user may not know where to find the <code>jupyter</code> executable.</p><p>By default, the notebook server is launched in the user&#39;s home directory, but this location can be changed by passing the desired path in the <code>dir</code> keyword argument.  e.g. <code>notebook(dir=pwd())</code> to use the current directory.</p><p>By default, <code>notebook()</code> does not return; you must hit ctrl-c or quit Julia to interrupt it, which halts Jupyter.  So, you must leave the Julia terminal open for as long as you want to run Jupyter.  Alternatively, if you run <code>notebook(detached=true)</code>, the <code>jupyter notebook</code> will launch in the background, and will continue running even after you quit Julia.  (The only way to stop Jupyter will then be to kill it in your operating system&#39;s process manager.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.num_utf8_trailing" href="#IJulia.num_utf8_trailing"><code>IJulia.num_utf8_trailing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>If <code>d</code> ends with an incomplete UTF8-encoded character, return the number of trailing incomplete bytes. Otherwise, return <code>0</code>.</p></div></div></section><pre><code class="language-none">IJulia.orig_stderr</code></pre><pre><code class="language-none">IJulia.orig_stdin</code></pre><pre><code class="language-none">IJulia.orig_stdout</code></pre><pre><code class="language-none">IJulia.oslibuv_flush</code></pre><pre><code class="language-none">IJulia.parseok</code></pre><pre><code class="language-none">IJulia.paste_magic_help</code></pre><pre><code class="language-none">IJulia.pdef_magic_help</code></pre><pre><code class="language-none">IJulia.pdoc_magic_help</code></pre><pre><code class="language-none">IJulia.pfile_magic_help</code></pre><pre><code class="language-none">IJulia.pipe_magic_help</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_posterror_hook" href="#IJulia.pop_posterror_hook"><code>IJulia.pop_posterror_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop_posterror_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after an error occurs when a notebook cell is evaluated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_postexecute_hook" href="#IJulia.pop_postexecute_hook"><code>IJulia.pop_postexecute_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop_postexecute_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_preexecute_hook" href="#IJulia.pop_preexecute_hook"><code>IJulia.pop_preexecute_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop_preexecute_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute before executing any notebook cell.</p></div></div></section><pre><code class="language-none">IJulia.posterror_hooks</code></pre><pre><code class="language-none">IJulia.postexecute_hooks</code></pre><pre><code class="language-none">IJulia.precision_magic_help</code></pre><pre><code class="language-none">IJulia.preexecute_hooks</code></pre><pre><code class="language-none">IJulia.profile</code></pre><pre><code class="language-none">IJulia.prun_magic_help</code></pre><pre><code class="language-none">IJulia.psearch_magic_help</code></pre><pre><code class="language-none">IJulia.publish</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_posterror_hook" href="#IJulia.push_posterror_hook"><code>IJulia.push_posterror_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop_posterror_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after an error occurs when a notebook cell is evaluated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_postexecute_hook" href="#IJulia.push_postexecute_hook"><code>IJulia.push_postexecute_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">push_postexecute_hook(f::Function)</code></pre><p>Push a function <code>f()</code> onto the end of a list of functions to execute after executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_preexecute_hook" href="#IJulia.push_preexecute_hook"><code>IJulia.push_preexecute_hook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">push_preexecute_hook(f::Function)</code></pre><p>Push a function <code>f()</code> onto the end of a list of functions to execute before executing any notebook cell.</p></div></div></section><pre><code class="language-none">IJulia.pwd_magic_help</code></pre><pre><code class="language-none">IJulia.qtconsole</code></pre><pre><code class="language-none">IJulia.qtconsole_magic_help</code></pre><pre><code class="language-none">IJulia.raw_input</code></pre><pre><code class="language-none">IJulia.read_stderr</code></pre><pre><code class="language-none">IJulia.read_stdout</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.readprompt" href="#IJulia.readprompt"><code>IJulia.readprompt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">readprompt(prompt::AbstractString; password::Bool=false)</code></pre><p>Display the <code>prompt</code> string, request user input, and return the string entered by the user.  If <code>password</code> is <code>true</code>, the user&#39;s input is not displayed during typing.</p></div></div></section><pre><code class="language-none">IJulia.recall_magic_help</code></pre><pre><code class="language-none">IJulia.recv_ipython</code></pre><pre><code class="language-none">IJulia.register_jsonmime</code></pre><pre><code class="language-none">IJulia.register_mime</code></pre><pre><code class="language-none">IJulia.requests</code></pre><pre><code class="language-none">IJulia.requests_task</code></pre><pre><code class="language-none">IJulia.run_magic_help</code></pre><pre><code class="language-none">IJulia.save_magic_help</code></pre><pre><code class="language-none">IJulia.sc_magic_help</code></pre><pre><code class="language-none">IJulia.send_ipython</code></pre><pre><code class="language-none">IJulia.send_status</code></pre><pre><code class="language-none">IJulia.send_stderr</code></pre><pre><code class="language-none">IJulia.send_stdio</code></pre><pre><code class="language-none">IJulia.send_stdout</code></pre><pre><code class="language-none">IJulia.send_stream</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_cur_msg" href="#IJulia.set_cur_msg"><code>IJulia.set_cur_msg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Jupyter associates cells with message headers. Once a cell&#39;s execution state has been set as to idle, it will silently drop stream messages (i.e. output to stdout and stderr) - see https://github.com/jupyter/notebook/issues/518. When using Interact, and a widget&#39;s state changes, a new message header is sent to the IJulia kernel, and while Reactive is updating Signal graph state, it&#39;s execution state is busy, meaning Jupyter will not drop stream messages if Interact can set the header message under which the stream messages will be sent. Hence the need for this function.</p></div></div></section><pre><code class="language-none">IJulia.set_current_module</code></pre><pre><code class="language-none">IJulia.set_env_magic_help</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_max_stdio" href="#IJulia.set_max_stdio"><code>IJulia.set_max_stdio</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_max_stdio(max_output::Integer)</code></pre><p>Sets the maximum number of bytes, <code>max_output</code>, that can be written to stdout and stderr before getting truncated. A large value here allows a lot of output to be displayed in the notebook, potentially bogging down the browser.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_verbose" href="#IJulia.set_verbose"><code>IJulia.set_verbose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_verbose(v=true)</code></pre><p>This function enables (or disables, for <code>set_verbose(false)</code>) verbose output from the IJulia kernel, when called within a running notebook. This consists of log messages printed to the terminal window where <code>jupyter</code> was launched, displaying information about every message sent or received by the kernel.   Used for debugging IJulia.</p></div></div></section><pre><code class="language-none">IJulia.show_bt</code></pre><pre><code class="language-none">IJulia.showerror_nobt</code></pre><pre><code class="language-none">IJulia.shutdown_request</code></pre><pre><code class="language-none">IJulia.socket_locks</code></pre><pre><code class="language-none">IJulia.start_heartbeat</code></pre><pre><code class="language-none">IJulia.stdio_bytes</code></pre><pre><code class="language-none">IJulia.stream_interval</code></pre><pre><code class="language-none">IJulia.svg_magic_help</code></pre><pre><code class="language-none">IJulia.sx_magic_help</code></pre><pre><code class="language-none">IJulia.threadid</code></pre><pre><code class="language-none">IJulia.time_magic_help</code></pre><pre><code class="language-none">IJulia.undisplay</code></pre><pre><code class="language-none">IJulia.utf16_to_ind</code></pre><pre><code class="language-none">IJulia.uuid4</code></pre><pre><code class="language-none">IJulia.verbose</code></pre><pre><code class="language-none">IJulia.waitloop</code></pre><pre><code class="language-none">IJulia.watch_stdio</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.watch_stream" href="#IJulia.watch_stream"><code>IJulia.watch_stream</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Continually read from (size limited) Libuv/OS buffer into an <code>IObuffer</code> to avoid problems when the Libuv/OS buffer gets full (https://github.com/JuliaLang/julia/issues/8789). Send data immediately when buffer contains more than <code>max_bytes</code> bytes. Otherwise, if data is available it will be sent every <code>stream_interval</code> seconds (see the Timers set up in watch<em>stdio). Truncate the output to `max</em>output<em>per</em>request` bytes per execution request since excessive output can bring browsers to a grinding halt.</p></div></div></section><pre><code class="language-none">IJulia.who_magic_help</code></pre><pre><code class="language-none">IJulia.writefile_magic_help</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
