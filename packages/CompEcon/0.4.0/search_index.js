var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": "(Image: Build Status) (Image: codecov.io) (Image: Coverage Status)This package is a Julia implementation of the routines originally contained in the CompEcon Matlab toolbox by Paul Fackler and Mario Miranda. The original Matlab code was written to accompany the publicationMiranda, Mario J., and Paul L. Fackler. Applied computational economics and finance. MIT press, 2004.This work is derivative of their work and has been licensed with their permission."
},

{
    "location": "#CompEcon-1",
    "page": "Readme",
    "title": "CompEcon",
    "category": "section",
    "text": "This package is a wrapper around BasisMatrices.jl and provides an API similar to the original CompEcon matlab library by Miranda and Fackler. For best use of the underlying routines, we recommend using the BasisMatrices.jl API.The Matlab style API here is as close to the original library as possible (differences are based mostly on syntax). To see what this means, consider the following Matlab example (taken from demapp01.m):% function to approximate\nf = @(x) exp(-x)\n\n% Set the endpoints of approximation interval:\na =  -1;                            % left endpoint\nb =   1;                            % right endpoint\n\n% Choose an approximation scheme. In this case, let us use an order 10\n% Chebychev approximation scheme:\nn = 10;                             % order of approximation\nbasis = fundefn(\'cheb\',n,a,b);      % define basis\n\n% Compute the basis coefficients c.  There are various way to do this:\n% One may use funfitf:\nc = funfitf(basis,@f);\n\n% ... or one may compute the standard approximation nodes x and corresponding\n% function values y and use funfitxy:\nx = funnode(basis);\ny = f(x);\nc = funfitxy(basis,x,y);\n\n% ... or one compute the standard approximation nodes x, corresponding\n% function values y, and the interpolation matrix phi, and solve the\n% interpolation equation directly using the backslash operator:\nx = funnode(basis);\ny = f(x);\nphi = funbase(basis);\nc = phi\\y;\n\n% Having computed the basis coefficients, one may now evaluate the\n% approximant at any point x using funeval:\nx = 0;\ny = funeval(c,basis,x);The corresponding Julia code isusing CompEcon\n# function to approximate\nf(x) = exp(-x)\n\n# Set the endpoints of approximation interval:\na =  -1                            # left endpoint\nb =   1                            # right endpoint\n\n# Choose an approximation scheme. In this case, let us use an order 10\n# Chebychev approximation scheme:\nn = 10                             # order of approximation\nbasis = fundefn(:cheb, n, a, b)      # define basis\n\n# Compute the basis coefficients c.  There are various way to do this:\n# One may use funfitf:\nc = funfitf(basis, f)\n\n# ... or one may compute the standard approximation nodes x and corresponding\n# function values y and use funfitxy:\nx = funnode(basis)[1]\ny = f(x)\nc = funfitxy(basis, x, y)[1]\n\n# ... or one compute the standard approximation nodes x, corresponding\n# function values y, and the interpolation matrix phi, and solve the\n# interpolation equation directly using the backslash operator:\nx = funnode(basis)[1]\ny = f(x)\nphi = funbase(basis)\nc = phi\\y\n\n# Having computed the basis coefficients, one may now evaluate the\n# approximant at any point x using funeval:\nx = [0.0]\ny = funeval(c, basis, x)[1]The main differences are:The Julia code uses symbols instead of strings to specify basis functions and refer to objects in the basis structure. The Matlab uses string (we see this above with use of \'cheb\' in Matlab and :cheb in Julia)\nThe Matlab code relies heavily on the use of varargout to only return some objects. The Julia code always returns all objects the Matlab ones might ever return, so we need to be careful about keeping only some of the return arguments. (notice in the calls to funnode  and funeval we just keep the first output in Julia)."
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "CompEcon.ABSR_MAPCompEcon.AbstractBasisMatrixRepCompEcon.BASE_TYPESCompEcon.BasisCompEcon.BasisFamilyCompEcon.BasisMatricesCompEcon.BasisMatrixCompEcon.BasisParamsCompEcon.BasisStructureCompEcon.ChebCompEcon.ChebParamsCompEcon.CompEconCompEcon.DirectCompEcon.ExpandedCompEcon.InterpolandCompEcon.LinCompEcon.LinParamsCompEcon.RowKronCompEcon.SmolyakCompEcon.SmolyakParamsCompEcon.SplineCompEcon.SplineParamsCompEcon.SplineSparseCompEcon.TensorCompEcon.base_existsCompEcon.basedefCompEcon.basenodeCompEcon.bm_from_dictCompEcon.chebbaseCompEcon.chebbasexCompEcon.chebdefCompEcon.chebdopCompEcon.chebnodeCompEcon.ckronCompEcon.complete_polynomialCompEcon.complete_polynomial!CompEcon.derivative_opCompEcon.do_quadCompEcon.evalCompEcon.evalbaseCompEcon.evaluateCompEcon.fit!CompEcon.funbaseCompEcon.funbasexCompEcon.funbconvCompEcon.fundCompEcon.fundefCompEcon.fundefnCompEcon.funevalCompEcon.funfitfCompEcon.funfitxyCompEcon.funnodeCompEcon.get_bformatCompEcon.get_coefsCompEcon.gridmakeCompEcon.gridmake!CompEcon.includeCompEcon.linbaseCompEcon.lindefCompEcon.lindopCompEcon.linnodeCompEcon.n_completeCompEcon.nodesCompEcon.old_nameCompEcon.old_paramsCompEcon.qnwbetaCompEcon.qnwchebCompEcon.qnwequiCompEcon.qnwgammaCompEcon.qnwlegeCompEcon.qnwlognCompEcon.qnwnormCompEcon.qnwsimpCompEcon.qnwtrapCompEcon.qnwunifCompEcon.quadrectCompEcon.revertCompEcon.row_kronCompEcon.splibaseCompEcon.splibasexCompEcon.splidefCompEcon.splidopCompEcon.splinodeCompEcon.squeeze_trailCompEcon.to_dictCompEcon.update_coefs!"
},

]}
